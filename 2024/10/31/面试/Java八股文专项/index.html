
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Java面试专项</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Java面试专项 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/10/31
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/面试" style=color:#ffa2c4>
                    面试
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><h6 id="我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？"><a href="#我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？" class="headerlink" title="我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？"></a><span style = "color:red">我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？</span></h6><ul>
<li>验证你项目场景的真实性，二是为了深入发问的切入点</li>
<li><strong>缓存</strong> 缓存三兄弟(穿透、击穿、雪崩)、双写一致、持久化、数据过期策略、数据淘汰策略</li>
<li><strong>分布式锁</strong> setnx、redisson</li>
<li><strong>消息队列、延迟队列</strong> 何种数据类型</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><p><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong><br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</p>
</li>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<p><strong>bitmap（位图）</strong>：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大    </p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给某一个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[不设置过期时间] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值</li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<pre><code class="java">《缓存三兄弟》
穿透无中生有key，布隆过滤null隔离。
缓存击穿过期key，锁与非期解难题。
雪崩大量过期key，过期时间要随机。
面试必考三兄弟，可用限流来保底。
</code></pre>
<h6 id="redis作为缓存，mysql的数据如何与redis进行同步呢？-双写一致性"><a href="#redis作为缓存，mysql的数据如何与redis进行同步呢？-双写一致性" class="headerlink" title="redis作为缓存，mysql的数据如何与redis进行同步呢？(双写一致性)"></a><span style = "color:red">redis作为缓存，mysql的数据如何与redis进行同步呢？(双写一致性)</span></h6><p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行<br><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】</p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知</strong>&#x3D;&#x3D;： <u>异步通知保证数据的最终一致性</u>(需要保证MQ的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先将数据写入Redis，然后通过异步通知机制触发数据库的更新操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<h6 id="Redis作为缓存，数据的持久化是怎么做的？"><a href="#Redis作为缓存，数据的持久化是怎么做的？" class="headerlink" title="Redis作为缓存，数据的持久化是怎么做的？"></a><span style = "color:red">Redis作为缓存，数据的持久化是怎么做的？</span></h6><p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果</p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照哦</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h6 id="假如Redis的key过期之后，会立即删除吗"><a href="#假如Redis的key过期之后，会立即删除吗" class="headerlink" title="假如Redis的key过期之后，会立即删除吗"></a><span style = "color:red">假如Redis的key过期之后，会立即删除吗</span></h6><p>Redis对数据设置数据的有效时间，数据过期以后就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略(数据过期策略)</p>
<p>&#x3D;&#x3D;<strong>Redis数据删除策略-惰性删除</strong>&#x3D;&#x3D;</p>
<p>惰性删除：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</p>
<pre><code class="mysql">set name zhangsan 10
get name # 发现name过期了，直接删除key
</code></pre>
<p><strong>优点：</strong>对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不会浪费时间进行过期检查<br><strong>缺点：</strong>对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p>
<p><strong>&#x3D;&#x3D;Redis数据删除策略-定期删除&#x3D;&#x3D;</strong></p>
<p>定期删除：每隔一段时间，我们就会对一些key进行检查，删除里面过期的key (从一定数量的数据库中取出一定数量的<strong>随机key</strong>进行检查，并删除其中的过期key)</p>
<p><strong>定期清理的两种模式：</strong></p>
<ul>
<li><strong>SLOW模式</strong>是定时模式，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件<code>redis.conf</code>的hz选项来调整这个次数</li>
<li><strong>FAST模式</strong>执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li>
</ul>
<p><strong>优点：</strong>可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存<br><strong>难点：</strong>难以确定删除操作执行的时长和频率</p>
<p><strong>Redis过期删除策略：</strong> <strong><u>惰性删除 + 定期删除</u></strong> 两种策略进行配合使用</p>
<h6 id="假如缓存过多，内存是有限的，内存被占满了怎么办？"><a href="#假如缓存过多，内存是有限的，内存被占满了怎么办？" class="headerlink" title="假如缓存过多，内存是有限的，内存被占满了怎么办？"></a><span style = "color:red">假如缓存过多，内存是有限的，内存被占满了怎么办？</span></h6><p>&#x3D;&#x3D;<strong>数据淘汰策略</strong>&#x3D;&#x3D;</p>
<p>当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据制除掉，这种数据的制除规则被称之为内存的淘汰策略</p>
<p><strong>Redis支持8种不同策略来选择要删除的key:</strong></p>
<ul>
<li><p><strong>noeviction：</strong>不淘汰任何key，但是内存满时不允许写入新数据，<strong>默认就是这种策略</strong></p>
<blockquote>
<h6 id="maxmemory-policy-noeviction"><a href="#maxmemory-policy-noeviction" class="headerlink" title="maxmemory-policy noeviction"></a>maxmemory-policy noeviction</h6></blockquote>
</li>
<li><p><strong>volatile-ttl</strong>：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰 (<u>TTL:过期时间的key</u>)</p>
</li>
<li><p><strong>allkeys-random</strong>：对全体key，随机进行淘汰</p>
</li>
<li><p><strong>volatile-random</strong>：对设置了TTL的key，随机进行淘汰</p>
</li>
<li><p><strong>allkeys-lru</strong>：对全体key，基于LRU算法进行淘汰</p>
<blockquote>
<p><strong>LRU</strong>(Least <strong>Recently</strong> Used)：<strong>最近最少使用</strong>，用当前时间减去最后一次访问时间，这个值越大测淘汰优先级越高 [逐出访问时间最少的]<br><strong>LFU</strong>(Least <strong>Frequently</strong> Used)：<strong>最少频率使用</strong>。会统计每个key的访问频率，值越小淘汰优先级越高。[逐出频率最低的] 【电商会应用】</p>
</blockquote>
</li>
<li><p><strong>allkeys-lfu</strong>：对全体key，基于LFU算法进行淘汰</p>
</li>
<li><p><strong>volatile-lfu</strong>：对设置了TTL的key，基于LFU算法进行淘汰</p>
</li>
</ul>
<p><strong>淘汰策略 - 使用建议</strong></p>
<p>1.优先使用 <code>allkeys-lru</code> 策略。充分利用LRU算法的优势，把最近最常访问的数据留在缓存中，如果业务有明显的冷热数据区分，建议使用。<br>2.如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用<code>allkeys-random</code>，随机选择淘汰<br>3.如果业务中有置顶的需求，可以使用<code>volatile-lru</code>策略，同时<strong>置顶数据不设置过期时间</strong>，这些数据就一直不会被删除，会淘汰其他设置过期时间的数据<br>4.如果业务中有<strong>短时高频</strong>访问的数据，可以使用<code>allkeys-lfu</code>或<code>volatile-lfu</code>策略</p>
<h6 id="数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？"><a href="#数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？" class="headerlink" title="数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？"></a>数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？</h6><ul>
<li>使用<code>allkeys-lru</code>(挑选最近最少使用的数据淘汰) 淘汰策略，留下来的都是经常访问的热点数据</li>
</ul>
<h6 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h6><ul>
<li>主要看数据淘汰策略是什么？如果是默认的配置(noeviction)，会直接报错</li>
</ul>
<h6 id="redis分布式锁，是如何实现的？"><a href="#redis分布式锁，是如何实现的？" class="headerlink" title="redis分布式锁，是如何实现的？"></a><span style = "color:red">redis分布式锁，是如何实现的？</span></h6><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题<br><img src="https://raw.githubusercontent.com/P-luminary/images/0f81d6fe238b4774d88facda4329c5ebe4921aa0/Redis%E9%9D%A2%E8%AF%95_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg"></p>
<p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、EX是设置超时时间<br><strong>SET lock value NX EX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h6 id="Redis实现分布式锁如何合理的控制锁的有效时长？"><a href="#Redis实现分布式锁如何合理的控制锁的有效时长？" class="headerlink" title="Redis实现分布式锁如何合理的控制锁的有效时长？"></a><span style = "color:red">Redis实现分布式锁如何合理的控制锁的有效时长？</span></h6><ul>
<li>根据业务执行时间预估</li>
<li><strong>给锁续期</strong></li>
</ul>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责<strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h6 id="Redis集群有哪些方案？"><a href="#Redis集群有哪些方案？" class="headerlink" title="Redis集群有哪些方案？"></a><span style = "color:red">Redis集群有哪些方案？</span></h6><ul>
<li><p>&#x3D;&#x3D;<strong>主从复制</strong>&#x3D;&#x3D; </p>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离<br><u>主节点写操作→增删改</u>     <u>从节点读操作→查</u></p>
<h6 id="介绍一下redis的主从同步"><a href="#介绍一下redis的主从同步" class="headerlink" title="介绍一下redis的主从同步"></a><span style = "color:red">介绍一下redis的主从同步</span></h6><blockquote>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就要搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据</p>
</blockquote>
<p><strong>主从数据同步原理：</strong></p>
<ul>
<li><span style="color:blue"><u>主从<strong>全量同步</strong></u>：</span></li>
</ul>
<p>slave从节点执行replicaof命令建立链接 → 请求master主节点数据同步(<u>replid+offset</u>) → master判断是否是第一次同步(判断replid是否一致) → 是第一次, 返回master的数据版本信息(<u>replid+offset</u>)  → slave保存版本信息 → master执行bgsave, 生成RDB → 发送RDB文件给slave → slave清空本地数据加载RDB数据 → 此时master记录RDB期间所有命令<code>repl_balklog</code> → 发送repl_backlog中的命令 → slave执行接收到的命令</p>
<p><strong>Replication ld</strong>: 简称<u>replid</u>，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid,slave则会继承master节点的replid<br><strong>offset</strong>: 偏移量，随着记录在repl baklog中的数据增多而逐渐增大。save完成同步时也会记录当前同步的ofset，如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p>
<blockquote>
<p>简述全量同步的流程？</p>
<p>• slave节点请求增量同步</p>
<p>• master节点判断replid，发现不一致，拒绝增量同步</p>
<p>• master将完整内存数据生成RDB，发送RDB到slave</p>
<p>• slave清空本地数据，加载master的RDB</p>
<p>• master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</p>
<p>• slave执行接收到的命令，保持与master之间的同步</p>
</blockquote>
<p><span style = "color:red"><strong>能说一下，主从同步数据的流程吗？</strong></span></p>
<p><span style="color:pink"><strong>全量同步</strong></span></p>
<blockquote>
<p>1.从节点请求主节点同步数据(replication id、offset)<br>2.主节点判断是否为第一次请求，是第一次就与从节点同步版本信息(replication id和offset)<br>3.主节点执行bgsave, 生成RDB文件后, 发送给从节点去执行<br>4.在RDB生成执行期间, 主节点会从命令的方式记录到缓冲区(日志文件)</p>
</blockquote>
<ul>
<li><span style="color:blue"><u>主从<strong>增量同步</strong></u></span><br>主从增量同步(slave重启或后期数据变化)</li>
</ul>
<p>① slave重启后 → 携带(replid+offset)找master → master判断请求replid是否一致 → 是第一次, 返回主节点replid和offset → 保存版本信息<br>② slave重启后 → 携带(replid+offset)找master → master判断请求replid是否一致 → 不是第一次, 回复continue向slave → master 去repl_baklog中获取offset后的数据 → 发送offset后的命令给slave → 执行命令</p>
<p><span style="color:pink"><strong>增量同步</strong></span></p>
<blockquote>
<p>1.从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值<br>2.主节点从命令日志中获取offset值后的数据，发送给节点进行数据同步</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>简述全量同步和增量同步区别？</p>
<p>•全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</p>
<p>•增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</p>
<p>什么时候执行全量同步？</p>
<p>•slave节点第一次连接master节点时</p>
<p>•slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</p>
<p>什么时候执行增量同步？</p>
<p>•slave节点断开又恢复，并且在repl_baklog中能找到offset时</p>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>哨兵模式</strong>&#x3D;&#x3D;~~搭过集群，具体多少个节点是组长那边，不太清楚<del>[并发量不是太多 搭哨兵可以节省一点资源]</del><br>Redis提供了<strong>哨兵</strong>(Sentinel)机制来实现主从集群的自动故障恢复</p>
<ul>
<li><strong>监控</strong>：Sentinel会不断检查您的master和slave是否按预期工作</li>
<li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为一个master。当故障实例恢复后也以新的master为主</li>
<li><strong>通知：</strong>Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<p><span style="color:blue"><strong>服务状态监控</strong></span><br>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令 <code>期待回复pong</code></p>
<ul>
<li><strong>主观下线</strong>：如果某sentinel节点发现或某实例未在规定时间相应，则认为该实例<strong>主观下线</strong></li>
<li><strong>客观下线</strong>：若超过指定数量(quorum)的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>，quorum值最好超过Sentinel实例数量的一半</li>
</ul>
<p><span style="color:blue"><strong>哨兵选主规则</strong></span></p>
<ul>
<li>首先判断主与从节点断开时间长短，如超过指定值就排该从节点</li>
<li>然后判断从节点的slave-priority值，越小优先级越高</li>
<li><strong><u>如果slave-priority值一样，则判断slave节点的offset值，越大优先级越高</u></strong> (数据是最全的)</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高</li>
</ul>
<p><strong><span style="color:blue">redis集群(哨兵模式) 脑裂</span></strong><br>因网络问题 主节点和从节点分别在不同的网络分区 这样sentinel只会监控到一部分从节点网络分区 导致RedisClient继续写主节点的数据，这时网络恢复了，哨兵会将老的master强制降级到slave(携带着脑裂前的最新数据)，这个时候slave就会把自己数据清空去同步master数据，这时就存在真正的数据丢失了</p>
<p><strong>怎么解决</strong>？</p>
<blockquote>
<p>redis中有两个配置参数：【若不能达成就拒绝客户端请求 这样就会避免大量数据丢失】<br>min-replicas-to-write 1      <strong>表示最少的salve节点为1</strong><br>min-replicas-max-lag 5      <strong>表示数据复制和同步的延迟不能超过5秒</strong></p>
</blockquote>
<p><span style = "color:red"><strong>怎么保证Redis的高并发高可用呢？</strong></span></p>
<blockquote>
<p>哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知)</p>
</blockquote>
<p><span style = "color:red"><strong>你们使用redis是单点还是集群，哪种集群？</strong></span></p>
<blockquote>
<p>主从(1主1从) + 哨兵就可以了。单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点</p>
</blockquote>
<p><span style = "color:red"><strong>redis集群脑裂，该怎么解决？</strong></span></p>
<blockquote>
<p><strong>集群脑裂</strong>是由于主节点和从节点和sentinel处于不同网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当为网络恢复后，sentinel会将老的主节点降为从节点，此时再从新master同步数据，就会导致数据丢失<br><strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，这样就会避免大量数据丢失。</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>分片集群</strong>&#x3D;&#x3D;</p>
<p>主从和哨兵可以解决高可用、高并发读的问题，但是依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题</li>
</ul>
<p>使用分片集群可用解决上述问题，分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可用有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可用访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
<p><strong><span style="color:blue">分片集群结果 - 数据读写</span></strong></p>
<p>Redis分片集群引入了<strong>哈希槽</strong>的概念，Redis集群有16384个哈希值，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>
<blockquote>
<p>存数据流程：<br>set name itheima → CRC16计算name的hash值(666666) → 666666%16384&#x3D;11306 → 根据11306找寻所对应哈希槽的范围 并且插入数据</p>
</blockquote>
<p><span style = "color:red"><strong>redis的分片集群有什么用？</strong></span></p>
<blockquote>
<ul>
<li>集群中有多个master，每个master保存不同数据。(解决高并发<strong>写</strong>的问题)</li>
<li>每个master都可以有多个slave节点。(解决高并发<strong>读</strong>的问题)</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可用访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>redis的分片集群中数据是怎么存储和读取的？</strong></span></p>
<blockquote>
<ul>
<li>Redis 分片集群引入了哈希槽的概念，Redis 集群有16384个哈槽</li>
<li>将16384个插槽分配到不同的实例</li>
<li>读写数据:根据key的**<u>有效部分</u>**计算哈希值，对16384取余(有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分)余数做为播槽，寻找插所在的实例</li>
</ul>
</blockquote>
</li>
</ul>
<p><span style = "color:red"><strong>Redis是单线程的，但是为什么还那么快</strong></span></p>
<blockquote>
<ul>
<li>Redis是纯内存操作，执行速度非常快</li>
<li>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</li>
<li>使用<strong>I&#x2F;O多路复用</strong>模型，非阻塞IO</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>解释一下I&#x2F;O多路复用模型？</strong></span></p>
<blockquote>
<p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度，I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p>
<ul>
<li><p>是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源，目前的I&#x2F;O多路复用都是采用的epol模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要换个历Socket来判断是否就绪，提升了性能</p>
</li>
<li><p><strong>Redis网络模型</strong>:</p>
<p>就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求</p>
<ul>
<li><p>连接应答处理器</p>
</li>
<li><p>命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</p>
</li>
<li><p>命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>用户空间和内核空间</strong>&#x3D;&#x3D;</p>
<ul>
<li>Linux系统中一个进程使用的内存情况划分两部分：<strong>内核空间、用户空间</strong></li>
<li><strong>用户空间</strong>只能执行受限的命令RIng3，而且不能直接调用系统资源必须通过内核提供的接口来访问</li>
<li><strong>内核空间</strong>可以执行特权命令Ring0，调用一切系统资源</li>
</ul>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区</p>
<ul>
<li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li>
<li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li>
</ul>
</li>
<li><p><strong>常见的IO模型</strong></p>
<ul>
<li><p><strong>&#x3D;&#x3D;阻塞IO&#x3D;&#x3D;</strong></p>
<p>阻塞IO就是两个阶段都必须阻塞等待：<br><strong>阶段一：</strong></p>
<ul>
<li>用户进程尝试读取数据(网卡数据等)</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>此时用户进程也处于阻塞状态</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li>数据到达并拷贝到内核缓冲区，代表已就绪</li>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>非阻塞</strong>IO&#x3D;&#x3D;</p>
<p><strong>阶段一</strong>：</p>
<ul>
<li>用户进程尝试读取数据(比如网卡数据)</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>返回异常给用户进程</li>
<li>用户进程拿到error后，再次尝试读取</li>
<li>循环往复，直到数据就绪</li>
</ul>
<p><strong>阶段二</strong>:</p>
<ul>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;IO<strong>多路复用</strong>&#x3D;&#x3D;</p>
<p>是利用单个线程来同时监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源</p>
<p><strong>IO多路复用</strong>是利用单个线程来同步监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听Socket的方式、通知的方式又有多种实现</p>
<ul>
<li><strong>select</strong></li>
<li><strong>poll</strong></li>
<li><strong>epoll</strong></li>
</ul>
<p><strong>差异:</strong><br>★ select和polI只会通知用户进程有Socket就绪，但不确定具体是哪个Socket，需要用户进程逐个历Socket来确认<br>★ epoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间,</p>
<p><strong>阶段一</strong>:</p>
<ul>
<li>用户进程调用select，指定要监听的Socket集合</li>
<li>内核监听对应的多个socket</li>
<li>任意一个或多个sacket数据就绪则返回readable</li>
<li>此过程中用户进程阻塞</li>
</ul>
<p><strong>阶段二</strong>:</p>
<ul>
<li>用户进程找别就格的socket</li>
<li>依次调用recvfrom读取数据</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redis网络模型</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9490d2cd8e67cb8fae7520ad15c0849821dbfac0/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"></p>
<h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span></p>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、SKywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>那这个SQL语句执行很慢，如何分析呢？</strong></span></p>
<blockquote>
<p>可以采用MySQL自带的分析工具 EXPLAIN</p>
<ul>
<li>通过key和key_len检查是否命中了索引(索引本身存在是否有失效的情况)</li>
<li>通过type字段查看sql是否有进一步的优化空间，是否存在<strong>全索引扫描</strong>或<strong>全盘扫描</strong></li>
<li>通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li>
</ul>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询 → <strong><u>新增临时表的数据</u></strong></li>
<li>多表查询 → <strong><u>优化SQL语句结构</u></strong></li>
<li>表数据量过大查询 → <strong><u>添加索引</u></strong></li>
<li>深度分页查询</li>
</ul>
</blockquote>
<h5 id="一个SQL语句执行很慢，如何分析？"><a href="#一个SQL语句执行很慢，如何分析？" class="headerlink" title="一个SQL语句执行很慢，如何分析？"></a>一个SQL语句执行很慢，如何分析？</h5><p>可以采用<code>EXPLAIN</code>或者<code>DESC</code>命令获取MySQL如何执行SELECT语句的信息</p>
<pre><code class="mysql"># 直接在select语句之前加上关键字 explain/desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
</code></pre>
<blockquote>
<p>mysql &gt; explain select * from t_user where id &#x3D; ‘1’</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>t_user</td>
<td>NULL</td>
<td>const</td>
<td>PRIMARY</td>
<td>PRIMARY</td>
<td>98</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
</tbody></table>
<ul>
<li><strong>possible_key</strong>：当前sql可能会使用到的索引</li>
<li><strong>key：</strong>当前sql实际命中的索引     <u>通过它俩查看是否可能会命中索引</u></li>
<li><strong>key_len</strong>：索引占用的大小          <u>通过它俩查看是否可能会命中索引</u></li>
<li><strong>Extra</strong>：额外的优化建议</li>
</ul>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Using where; Using Index</td>
<td>查找使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据</td>
</tr>
<tr>
<td>Using index condition</td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody></table>
<ul>
<li><strong>type：</strong>这条sql的连接的类型，性能由好到差为 <ul>
<li>NULL</li>
<li>system：查询系统中的表</li>
<li>const：根据主键查询</li>
<li>eq_ref：主键索引查询或唯一索引查询</li>
<li>ref：索引查询</li>
<li>range：范围查询</li>
<li><em>index：索引树扫描</em></li>
<li><em>all：全盘扫描</em></li>
</ul>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>了解过索引吗？（什么是索引）</strong></span></p>
<blockquote>
<p>索引(index)是帮助MySQL高效获取数据的数据结构(有序)，在数据之外，数据库系统还维护着满足特定查找算法的数据结构**(B+树)**，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p>
<ul>
<li>索引(index)是帮助MySQL高效获取数据的数据结构(有序)</li>
<li>提高数据检索的效率，降低数据库的IO成本(不需要全表扫描)</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li>**聚簇索引(聚集索引)**：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个</li>
<li>**非聚簇索引(二级索引)**：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<p><span style = "color:red"><strong>知道什么叫覆盖索引吗？</strong></span></p>
<blockquote>
<p>覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到</p>
<ul>
<li>使用id查询，直接走聚集索引查询，一次索引描述，直接返回数据，性能高</li>
<li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用 **select *** <del>[除非用的聚簇索引(主键)]</del></li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;<strong>覆盖索引</strong>&#x3D;&#x3D;是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</p>
<table>
<thead>
<tr>
<th align="center"><span style = "color:red">id</span></th>
<th align="center"><span style = "color:red">name</span></th>
<th align="center">gender</th>
<th align="center">createdate</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">Arm</td>
<td align="center">1</td>
<td align="center">2021-01-01</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Lily</td>
<td align="center">0</td>
<td align="center">2021-05-04</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">Rose</td>
<td align="center">0</td>
<td align="center">2021-04-21</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">Zoo</td>
<td align="center">1</td>
<td align="center">2021-07-31</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Doc</td>
<td align="center">1</td>
<td align="center">2021-02-26</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">Lee</td>
<td align="center">1</td>
<td align="center">2021-09-11</td>
</tr>
</tbody></table>
<ul>
<li><strong>id为主键，默认是主键索引</strong></li>
<li><strong>name字段为普通索引</strong></li>
</ul>
<pre><code class="mysql">select * from tb_user where id = 1;                     【覆盖索引】
select id, name from tb_user where name = &#39;Arm&#39;         【覆盖索引】
select id, name, gender from tb_user where name = &#39;Arm&#39; 【非覆盖索引】(需要回表查询)
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9b20975f94b299a861457b2214bd985ff4b2625d/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.jpg"></p>
<p><span style = "color:red"><strong>MySQL超大分页怎么处理？</strong></span></p>
<blockquote>
<p>问题：再数据量比较大时，limit分页查询，需要对数据进行排序，效率低<br><strong>解决方案：</strong>可以用<strong>覆盖索引</strong> + <strong>子查询</strong>处理<br>[我们先分页查询获取表中的id 并且对表的id进行排序 就能筛选出分页后的id集合(因为id是覆盖索引效率高)  最后再根据id集合到原来的表中做关联查询就可以得到提升了]</p>
</blockquote>
<p>在数据量比较大时，如果用limit分页查询，在查询时，越往后，分页查询效率越低</p>
<pre><code class="mysql">mysql &gt; select * from tb_sku limit 0,10;
10 rows in set (0.00 sec)

mysql &gt; select * from tb_sku limit 9000000,10;
10 rows in set (11.05 sec)
</code></pre>
<p>因为，当在进行分页查询时，如果执行 limit  9000000,10，此时需要MySQL排序前9000010记录，仅仅返回9000000 - 9000010 的记录，其他记录丢失，查询排序的代价非常大。</p>
<p>&#x3D;&#x3D;<strong>MySQL超大分页查询优化思路</strong>&#x3D;&#x3D;：一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好地提高性能，可以通过<strong>覆盖索引</strong>加<strong>子查询</strong>形式进行优化</p>
<pre><code class="mysql"># 超大分页处理：先通过覆盖索引找到符合条件的id，再通过这个id的覆盖索引查询到所有的列
select * 
from tb_sku t,
(select id from tb_sku order by id limit 9000000,10) a
where t.id = a.id

# 10 rows in set (7.15 sec)
</code></pre>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong><br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><br>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<h6 id="创建索引的方式"><a href="#创建索引的方式" class="headerlink" title="创建索引的方式"></a>创建索引的方式</h6><pre><code class="mysql">① SQL的方式
ALTER TABLE user_innodb ADD INDEX idx_name(name)

② 在建表的时候 去指定索引
...
PRIMARY KEY(&#39;id&#39;),
KEY &#39;idx_name&#39; (&#39;name&#39;) USING HASH

③ 通过界面化工具去指定索引
字段旁边有个`索引` 可以去添加

=============================================
单个字段的索引 → 单列索引
多个字段的索引 → 联合索引
</code></pre>
<h6 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h6><p><u>索引可以增加查询速度 同时也增加了更新&#x2F;修改速度</u><del>因为更新的第一步就是查询</del></p>
<blockquote>
<p>① <strong>普通索引</strong>   经过特殊设计的数据结构<br>② <strong>唯一索引</strong>   唯一约束<br>[索引必须是唯一的 比如name就不行 因为名字可以很多建立普通索引]<br>③ <strong>主键索引</strong>   在主键索引上添加了<strong>非空约束</strong><br>④ <strong>全文索引</strong>   一般使用搜索引擎，因为对中文的搜索不太友好<del>美国英文开发的</del><br>[特殊的sql：select * from 表名 where match(字段名) against(‘马士兵教育’ IN NATURAL LANGUAGE MODE);]</p>
<p>AVL树 右右型左旋 <strong><u>左子树与右子树的深度差绝对值不超过1</u></strong><br>树的节点里应该放：<strong>键值</strong>+<strong>Value值</strong>+<strong>左右子树的地址</strong><del>left+right</del><br>Innodb一次会加载16k(<u>16384字节&#x3D;Redis的槽位</u>) 内存到内存<br>不选红黑树是因为它是二叉的，我们需要多叉树<br>要用&#x3D;&#x3D;<strong>B+树</strong>&#x3D;&#x3D;全盘扫描能力更强 叶子节点是双向链表<br>因为稳定性比较好  B树非所见所得 B+树是稳定几层的查找数据<del>因为数据都在最后一层叶子节点上</del><br>Innodb的索引方法是BTREE 不能改成HASH</p>
</blockquote>
<p>**<u><span style = "color:red">数据结构可视化网</span></u>**：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a></p>
<ul>
<li>针对数据量较大，且查询比较频繁的表建立索引。<strong>单表超过10万数据(增加用户体验)</strong></li>
<li>针对常作为<strong>查询条件(where)、排序(order by)、分组(group by)</strong> 操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 (比如address都在北京市)</li>
<li>如果是字符串类型的字段，字段的长度越长(描述信息…)，可以针对于字段的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引(避免回表)，节省存储空间，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ul>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行运算操作，索引将失效</li>
<li>字符串不加单引号，造成索引失效。(类型转换)</li>
<li>以%开头的Like模糊查询，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><strong>怎么哪块读判断索引是否失效了呢</strong>？</p>
<pre><code class="mysql"># 执行计划explain
</code></pre>
<p>【2024最新版MySQL索引讲解！一个视频带你彻底搞懂MySQL索引！！【马士兵】】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17z421i7Kb?vd_source=5966d6c3cf3709c10b3c53b278b0f4d3">https://www.bilibili.com/video/BV17z421i7Kb?vd_source=5966d6c3cf3709c10b3c53b278b0f4d3</a></p>
<p><strong>什么情况下索引会失效？</strong><br>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引：<br><img src="https://github.com/P-luminary/images/blob/master/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png?raw=true" style="zoom:80%;" /></p>
<p><span style = "color:red"><strong>谈谈你对sql的优化经验？</strong></span></p>
<blockquote>
<ul>
<li>表的设计优化，数据类型的选择</li>
<li>索引优化，索引创建原则</li>
<li>sql语句优化，避免索引失效，避免使用select</li>
<li>主从复制、读写分离，不让数据的写入，影响读操作</li>
<li>分库分表</li>
</ul>
</blockquote>
<ul>
<li><p>表的设计优化(<strong>参考阿里开发手册《嵩山版》</strong>)</p>
<ul>
<li>比如设置合适的数值(tinyint、int、bigint) ，要根据实际情况选择</li>
<li>比如设置合适的字符串类型(char和varchar) char定长效率高，varchar可变长度，效率低</li>
</ul>
<blockquote>
<p>候选人: 这个我们主要参考的阿里出的那个开发手册《嵩山版》，就比如，在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint、int、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型</p>
</blockquote>
</li>
<li><p><strong>索引优化</strong>(参考优化创建原则和索引失效)</p>
</li>
<li><p><strong>SQL语句优化</strong></p>
<ul>
<li><p>SELECT语句务必指明字段名称 (避免直使用select *)<del>回表</del></p>
</li>
<li><p>SQL语句要避免造成索引失效的写法</p>
</li>
<li><p>尽量使用union all代替union，union(不会重复)会多一次过滤, 效率低</p>
<pre><code class="mysql">select * from t_user where id &gt; 2
union all | union
select * from t_user where id &lt; 5
</code></pre>
</li>
<li><p>避免在where子句中对字段进行表达式操作</p>
</li>
<li><p>join优化 能用inner join 就不用left join,  right 如必须使用 一定要以小表为驱动；内链接会对两个表进行优化，<strong>优先把小表放到外边，把大表放到里边</strong>。left join 或 right  join，不会重新调整顺序</p>
<pre><code class="java">for(int i = 0; i &lt; 3; i++)&#123; //只链接查询3次
 for(int j = 0; j &lt; 1000; j++)&#123;

 &#125;  
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>主从复制、读写分离</strong>(在生产环境下一般会搭建主库和从库 分开读操作和写操作)</p>
<p>如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。读写分离解决的是，<strong>数据库的写入</strong>，影响了查询的效率。[Master(写) 和 Slave(读)]</p>
</li>
<li><p><strong>分库分表(后面有介绍)</strong></p>
</li>
</ul>
<p><span style = "color:red"><strong>事务的特性是什么？可以详细的说一下吗？</strong></span>【ACID】</p>
<blockquote>
<p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>候选人：嗯，这个比较清楚，ACID，分别指的是:原子性、一致性、隔离性、持久性;<br><strong>我举个例子</strong>：A向B转账500，转账成功，A扣除500元，B增加500元，原子操作体现在<u>要么都成功，要么都失败</u>。<br>在转账的过程中，数据要一致，A扣除了500，B必须增加500<br>在转账的过程中，隔离性体现在A像B转账，不能受其他事务干扰<br>在转账的过程中，持久性体现在事务提交后，要把数据持久化(可以说是落盘操作)</p>
</blockquote>
<ul>
<li>**原子性(**Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li><strong>一致性</strong>(Consistency)：事务完成时，必须使所有的数据都保持一致状态。</li>
<li><strong>隔离性</strong>(lsolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境运行</li>
<li><strong>持久性</strong>(Durabiity)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p><span style = "color:red"><strong>并发事务带来哪些问题？怎么解决这些问题？MySQL默认隔离级别是？</strong></span></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;<strong>并发事务问题</strong>&#x3D;&#x3D;：脏读、不可重复读、幻读</li>
<li>&#x3D;&#x3D;<strong>隔离级别</strong>&#x3D;&#x3D;：读未提交、读已提交、<strong>可重复读</strong>、串行化</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">脏读</td>
<td>一个事务读到另外一个事务还没有提交的数据</td>
</tr>
<tr>
<td align="center">不可重复读</td>
<td>一个事务先后读取同一条事务，但两次读取的数据不同，称之为不可重复读</td>
</tr>
<tr>
<td align="center">幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，这同时另一个事务B(insert且commit)了事务，此时事务A在插入数据时候，又发现这行数据已经存在了，好像出现了”幻影“</td>
</tr>
</tbody></table>
<h6 id="怎么解决并发事务的问题呢？？"><a href="#怎么解决并发事务的问题呢？？" class="headerlink" title="怎么解决并发事务的问题呢？？"></a>怎么解决并发事务的问题呢？？</h6><p><strong>对事务进行隔离</strong> (× 是代表可以解决此问题)</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Read uncommitted 未提交读</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Read committed 读已提交</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">&#x3D;&#x3D;<strong>Repeatable Read(默认) 可重复读</strong>&#x3D;&#x3D;</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Serializable 串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>注意：**<u>事务隔离级别越高，数据越安全，但是性能越低</u>**</p>
<p><span style = "color:red"><strong>undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是数据页的物理变化，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undolog保证了事务的原子性和一致性</p>
</blockquote>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
<p><span style = "color:red"><strong>事务中的隔离性是如何保证的呢？</strong></span></p>
<blockquote>
<p>排他锁 (如果一个事务获取到了一哥数据行的排他锁，其他事务就不能再获取该行的其他锁)<br>mvcc: 多版本并发控制  让MySQL中的多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突<br><strong>隐藏字段</strong>:<br>① trx _id(事务id)，记录每一次操作的事务id，是自增的<br>② roll _pointer(回滚指针)，指向上一个版本的事务版本记录地址</p>
<p><strong>undo log</strong>:<br>① 回滚日志，存储老版本数据<br>② 版本链:多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过rollpointer指针形成一个链表</p>
<p><strong>readView</strong>：解决的是一个事务查询选择版本的问题<br>根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据》不同的隔离级别快照读是不一样的，最终的访问的结果不一样RC:每一次执行快照读时生成ReadView<br>RR:仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
</blockquote>
<blockquote>
<p><strong>面试官</strong>: 事务中的隔离性是如何保证的呢?(你解释一下MVCC)<br><strong>候选人</strong>: 事务的隔离性是由锁和mvcc实现的。<br>其中mnvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是<u>隐藏字段</u>，第二个是<u>undolog日志</u>，第三个是<u>readView读视图</u><br>隐藏字段是指:在mysq!中给每个表都设置了隐藏字段，有一个是x_id(事务id)，记录每一次操作的事务id，是自增的;另一个字段是roll-pointer(回滚指针)，指向上一个版本的事务版本记录地址<br>undolog主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行探作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表<br>readview解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是r隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
</blockquote>
<p><span style = "color:red"><strong>解释一下MVCC？</strong></span></p>
<p>全程 <strong>Multi-Version Concurrency Control</strong>，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突</p>
<h6 id="问题的来源：-橙色的-查询的是哪个事务版本的记录？"><a href="#问题的来源：-橙色的-查询的是哪个事务版本的记录？" class="headerlink" title="问题的来源：(橙色的)查询的是哪个事务版本的记录？"></a>问题的来源：(橙色的)查询的是哪个事务版本的记录？</h6><table>
<thead>
<tr>
<th align="center">事务2</th>
<th align="center">事务3</th>
<th align="center">事务4</th>
<th align="center">事务5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
</tr>
<tr>
<td align="center">修改id为30记录, age改为3</td>
<td align="center"></td>
<td align="center">查询id为30的记录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">修改id为30记录, name改为A3</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><span style = "color:orange"><strong>查询id为30的记录</strong></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">提交文件</td>
<td align="center">修改id为30的记录, age改为10</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">查询id为30的记录</td>
<td align="center"><span style = "color:orange"><strong>查询id为30的记录</strong></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
</tbody></table>
<h6 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC-实现原理"></a>MVCC-实现原理</h6><ul>
<li><strong>记录中的隐藏字段</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">age</th>
<th align="center">name</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PTR</th>
<th align="center">DB_ROW_ID</th>
</tr>
</thead>
</table>
<ul>
<li><strong>DB_TRX_ID</strong>：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong>：回滚指针，指向这条记录的上一个版本，用于配合undo log, 指向上一个版本</li>
<li><strong>DB_ROW_ID</strong>：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</li>
</ul>
<h6 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h6><ul>
<li>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</li>
<li>当insert的时候，产生的undolog日志只在回滚时需要，在事务提交后，可被立即删除。</li>
<li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除。</li>
</ul>
<h6 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h6><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录</p>
<ul>
<li><strong>readview</strong></li>
</ul>
<p>ReadView(读视图) 是 <strong>快照读</strong> SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id</p>
<p>ReadView中包含了四个核心字段</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">m_ids</td>
<td align="center">当前活跃的事务ID集合</td>
</tr>
<tr>
<td align="center">min_trx_id</td>
<td align="center">最小活跃事务ID</td>
</tr>
<tr>
<td align="center">max_trx_id</td>
<td align="center">预分配事务ID, 当前最大事务ID+1 (事务ID是自增的)</td>
</tr>
<tr>
<td align="center">creator_trx_id</td>
<td align="center">ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<ul>
<li><strong>当前读</strong></li>
</ul>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select .. lock in share mode(共享锁)，select .. for update、update、insert、delete(排他锁)都是一种当前读。</p>
<ul>
<li><strong>快照读</strong></li>
</ul>
<p>简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。<br><strong>Read Committed</strong>:每次select，都生成一个快照读。<br><strong>Repeatable Read</strong>:开启事务后第一个select语句才是快照读的地方。</p>
<p><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></p>
<blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<p><span style = "color:red"><strong>你们项目用过分库分表吗？</strong></span></p>
<blockquote>
<ul>
<li><p>业务介绍<br>1，根据自己简历上的项目，想一个数据量较大业务(请求数多或业务累积大)<br>2，达到了什么样的量级(单表1000万或超过20G)</p>
</li>
<li><p>具体拆分策略<br>1，水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题<br>2，水平分表，解决单表存储和性能的问题<br>3，垂直分库，根据业务进行拆分，高并发下提高磁盘I0和网络连接数<br>4，垂直分表，冷热数据分离，多表互不影响</p>
</li>
</ul>
</blockquote>
<p><strong>分担了访问压力、解决存储压力</strong></p>
<p>分库分表的时机：</p>
<p>① <strong>前提</strong>：项目业务数据逐渐增多，业务发展比较迅速【单表数据量达1000W或20G以后】<br>② 优化解决不了性能问题(主从读写分离、查询索引)<br>③ <strong>IO瓶颈</strong>(磁盘IO、网络IO)、<strong>CPU瓶颈</strong>(聚合查询、连接数太多)</p>
<p><strong>拆分策略</strong>【垂直 ≈ 微服务、水平 ≈ 分配数值】</p>
<ul>
<li>&#x3D;&#x3D;<strong>垂直拆分</strong>&#x3D;&#x3D;<ul>
<li><strong>垂直分库</strong>：以表为依据，根据业务将不同表拆分到不同库中<br>(特点：按业务对数据分级管理、维护、监控、扩展；在高并发下，提高磁盘IO和数据量连接数)<ul>
<li>tb_user → 用户微服务 </li>
<li>tb_order → 订单微服务</li>
<li>tb_sku → 商品微服务</li>
</ul>
</li>
<li><strong>垂直分表</strong>：以字段为依据，根据字段属性将不同字段拆分到不同表中<br>(把不常用的字段单独放在一张表；把<strong>text, blob</strong>等大字段[描述]拆分出来放在附表中)<br>(特点：冷热数据分离、减少IO过渡争抢，两表互不影响)</li>
</ul>
</li>
<li>&#x3D;&#x3D;<strong>水平拆分</strong>&#x3D;&#x3D;<ul>
<li><strong>水平分库</strong>：将一个库的数据拆分到多个库中<br>(解决了单库大数量，高并发的性能瓶颈问题；提高了系统的稳定性和可用性)<br><u>路由规则</u><ul>
<li>根据id节点取模</li>
<li>按id也就是范围路由，节点1(1-100万)，节点2(100万-200万)</li>
</ul>
</li>
<li><strong>水平分表</strong>：将一个库的数据拆分到多个表中(可以在同一个库内)<br>(优化单一表数据量过大而产生的性能问题；避免IO争抢并减少锁表的几率)</li>
</ul>
</li>
</ul>
<h6 id="分库后的问题：↓↓"><a href="#分库后的问题：↓↓" class="headerlink" title="分库后的问题：↓↓"></a>分库后的问题：↓↓</h6><ul>
<li>分布式事务一致性问题</li>
<li>跨节点关联查询</li>
<li>跨节点分页、排序函数</li>
<li>主键避重</li>
</ul>
<h6 id="使用分库分表中间件"><a href="#使用分库分表中间件" class="headerlink" title="使用分库分表中间件"></a>使用分库分表中间件</h6><ul>
<li><span style = "color:blue"><strong>sharding-sphere</strong></span></li>
<li><span style = "color:blue"><strong>mycat</strong></span></li>
</ul>
<p><span style = "color:red"><strong>Spring框架中的单例bean是线程安全的吗？</strong></span></p>
<blockquote>
<p>不是线程安全的，是这样的</p>
<p>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑(成员方法)，如果该处理逻辑中有对该单列状态的修改(体现为该单例的成员属性)，则必须考虑线程同步问题。</p>
<p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。<br>比如:我们通常在项目中使用的Springbean都是不可可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。</p>
<p>如果你的bean有多种状态的话(比如 View Model对象)，就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“singleton”变更为“prototype”。</p>
</blockquote>
<blockquote>
<p>Spring框架中的bean是单例的</p>
<pre><code class="java">@Service
@Scope(&quot;singleton&quot;)
public class UserServiceImpl implements UserService&#123;
    
&#125;
</code></pre>
<ul>
<li><strong>singleton</strong>：bean在每个Spring IOC容器中只有一个实例</li>
<li><strong>prototype：</strong>一个bean的定义可以有多个实例</li>
</ul>
<p>Spring bean并没有可变的状态(比如Service类和DAO类), 所以在某种程度上说Spring的单例bean是线程安全的。但要尽可能的少创造可变参数比如count</p>
<pre><code class="java">@Controller
@RequeestMapping(&quot;/user&quot;)
public class UserController&#123;
    private int count; //成员方法需要考虑线程安全问题

    @Autowired
    private UserService userService;
    
    @GetMapping(&quot;/getById/&#123;id&#125;&quot;)
    public User getById(@PathVariable(&quot;id&quot;) Integer id)&#123;
        count++;
        sout(count);
        return userService.getById(id);
    &#125;
&#125;
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>什么是AOP，你们项目中有没有用到AOP？</strong></span></p>
<p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”(Aspect)，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<h6 id="常见AOP使用场景："><a href="#常见AOP使用场景：" class="headerlink" title="常见AOP使用场景："></a>常见AOP使用场景：</h6><ul>
<li><p><strong>拒绝策略记录操作日志</strong></p>
<blockquote>
<p>nginx → 新增用户 → @Around(“pointcut()”) <u><strong>环绕通知</strong></u></p>
</blockquote>
</li>
<li><p><strong>缓存处理</strong></p>
</li>
<li><p><strong>Spring中内置的事务处理</strong></p>
</li>
</ul>
<p><strong>Spring中的事务是如何实现的</strong><br>Spring支持 <strong>编程式事务管理</strong> 和 <strong>声明式事务</strong> 管理两种方式。</p>
<ul>
<li><strong>编程式事务控制</strong>：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li>
<li><strong>声明式事务管理</strong>：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li>
</ul>
<p><span style = "color:red"><strong>Spring中事务失效的场景有哪些？</strong></span></p>
<blockquote>
<p>异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出<br>抛出检查异常，配置rollbackFor属性为Exception<br>非public方法导致的事务失效，改为public</p>
</blockquote>
<p>考察对spring框架的深入理解、复杂业务的编码经验</p>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>异常捕获处理</strong>&#x3D;&#x3D;</p>
<p><strong>原因</strong>：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉</p>
<p><strong>解决</strong>：<u>在catch块添加throw new RuntimeException(“转账失败”)</u> 抛出</p>
</li>
<li><p>&#x3D;&#x3D;<strong>抛出检查异常</strong>&#x3D;&#x3D;</p>
<p><strong>原因</strong>：Spring默认只会回滚非检查异常</p>
<pre><code class="java">@Transactional
public void update(...) throw FileNotFoundException&#123;
    ...
    new FileInputStream(&quot;dddd&quot;)
    ...
&#125;
</code></pre>
<p><strong>解决：</strong>配置<code>rollbackFor</code>属性</p>
<pre><code class="java">@Transcational(rollbackFor=Exception.class)
</code></pre>
</li>
<li><p>&#x3D;&#x3D;<strong>非public方法</strong>&#x3D;&#x3D;</p>
<pre><code class="java">@Transcational(rollbackFor=Exception.class)
void update(...) throw FileNotFoundException&#123;
    ...
    new FileInputStream(&quot;dddd&quot;)
    ...
&#125;
</code></pre>
<p><strong>原因：</strong>Spring为方法创建代理、添加事务通知、<u>前提条件都是该方法是<strong>public</strong>的</u><br><strong>解决：</strong>把方法改为<code>public</code></p>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>Spring的bean的生命周期？</strong></span></p>
<blockquote>
<p>Spring容器是如何管理和创建bean实力<br>方便调试和解决问题</p>
<p>① 通过BeanDefinition获取bean的定义信息<br>② 调用构造函数实例化bean<br>③ bean的依赖注入<br>④ 处理Aware接囗(BeanNameAware、BeanFactoryAware、ApplicationContextAware)<br>⑤ Bean的后置处理器BeanPostProcessor-前置<br>⑥ 初始化方法(InitializingBean、init-method)<br>⑦ Bean的后置处理器BeanPostProcessor-后置<br>⑧ 销毁bean</p>
</blockquote>
<p><strong>BeanDefinition</strong></p>
<p>Spring容器在进行实例化时，会将xml配置的&lt; bean &gt;的信息封装成一个<strong>BeanDefinition</strong>对象，<u>Spring根据BeanDefinition来创建Bean对象，里面有很多的属性来描述Bean</u></p>
<pre><code class="java">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaolmpl&quot; lazy-init=&quot;true&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.UserServicelmpl&quot; scope=&quot;singleton&quot;&gt;
  &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><img src="https://github.com/P-luminary/images/blob/master/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?raw=true"></p>
<p><span style = "color:red"><strong>Spring中的循环引用？</strong></span></p>
<blockquote>
<p>★ <strong>循环依赖</strong>：循环依赖其实就是循环引用, 也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A<br>★ 循环依赖在spring中是允许存在，spring框架**<u>依据三级缓存已经解决了大部分的循环依赖</u>**<br>  ☆ <strong>一级缓存</strong>：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象<br>  ☆ <strong>二级缓存</strong>：缓存早期的bean对象(生命周期还没走完)<br>  ☆ <strong>三级缓存</strong>：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p>
</blockquote>
<p><span style = "color:red"><strong>构造方法出现了循环依赖怎么解决？</strong></span></p>
<blockquote>
<p>A依赖于B，B依赖于A，注入的方式是构造函数<br><strong>原因</strong>：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入<br><strong>解决方案</strong>：使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建</p>
<p>public A(@Lazy B b){<br>    sout(“A的构造方法执行了”);<br>    this.b&#x3D;b;<br>}</p>
</blockquote>
<blockquote>
<p>@Component                                     @Component<br>public class A{          →      ←             public class B{<br>    @Autowired         ↑          ↑                 @Autowired<br>    private B b;       →↑          ↑←                private A a;<br>}                                                             } </p>
</blockquote>
<h6 id="什么是Spring的循环依赖？？"><a href="#什么是Spring的循环依赖？？" class="headerlink" title="什么是Spring的循环依赖？？"></a>什么是Spring的循环依赖？？</h6><p><u>&#x3D;&#x3D;<strong>一级缓存</strong>&#x3D;&#x3D;作用：限制bean在beanFactory中只存一份，即实现singleton scope，解决不了循环依赖</u></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/14e03913c1c2b7ca24702d5d2226a886bcc373de/%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%961.jpg"></p>
<p><u>如果想打破循环依赖，就需要一个中间人的参与，这个中间人就是&#x3D;&#x3D;<strong>二级缓存</strong>&#x3D;&#x3D;</u><del>如果一个对象是代理对象(被增强了)就不行</del><br><img src="https://github.com/P-luminary/images/blob/master/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%962.jpg?raw=true"></p>
<p><u>针对如果是代理对象的话如何解决呢？</u> → &#x3D;&#x3D;<strong>三级缓存</strong>&#x3D;&#x3D;<br><img src="https://github.com/P-luminary/images/blob/master/%E4%B8%89%E6%AC%A1%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.jpg?raw=true"></p>
<h6 id="那如果构造方法出现了循环依赖怎么解决？"><a href="#那如果构造方法出现了循环依赖怎么解决？" class="headerlink" title="那如果构造方法出现了循环依赖怎么解决？"></a>那如果构造方法出现了循环依赖怎么解决？</h6><blockquote>
<p>@Component                                                                   @Component<br>public class A{                           →      ←                          public class B{<br>    private B b;                             ↑          ↑                             private A a;<br>    public A(B c){                       →↑          ↑←                        public B(A c){<br>          sout(“A的构造方法执行了”)                                          sout(“B的构造方法执行了”)<br>          this.b&#x3D;b;                                                                                 this.b&#x3D;b;<br>    }                                                                                               }<br>}                                                                                            } </p>
<p>报错信息：Is there an unresolvable circular reference?<br>解决：<code>@Lazy </code> 延迟加载→什么时候需要对象的时候什么时候实例化对象</p>
<pre><code class="java">public A(@Lazy B b)&#123;
    sout(&quot;A的构造方法执行了&quot;);
    this.b=b;
&#125;
</code></pre>
</blockquote>
<p><strong>Spring解决循环依赖是通过三级缓存</strong></p>
<pre><code class="java">// 单实例对象注册器
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123;
private static final int SUPPRESSED EXCEPTIONS LIMIT= 100;  
private final Map&lt;String, Object&gt;singletonObjects = new ConcurrentHashMap(256); 一级缓存
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16); 三级缓存
private final Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap(16); 二级缓存 
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>缓存名称</th>
<th>源码名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td>singletonObject</td>
<td>单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</td>
</tr>
<tr>
<td>二级缓存</td>
<td>earlySingletonObjects</td>
<td>缓存早期的bean对象(生命周期还没走完)</td>
</tr>
<tr>
<td>三级缓存</td>
<td>singletonFactories</td>
<td>缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringMVC的执行流程知道吗？</strong></span></p>
<blockquote>
<ul>
<li>视图阶段(老旧JSP等)</li>
<li>前后端分离阶段(接口开发，异步)</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/67d750afe8d0ece9e5cc289483dc164a9897e165/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg"></p>
<p>&#x3D;&#x3D;<strong>视图阶段(jsp)</strong>&#x3D;&#x3D; </p>
<ul>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping(处理器映射器)</li>
<li>HandlerMapping找到具体的处理器，生成处理器<strong>对象</strong>及处理器<strong>拦截器</strong>(如果有)</li>
<li>DispatcherServlet调用HandlerAdapter(处理器适配器)HandlerAdapter经过适配调用具体的处理器(Handler&#x2F;Controller)Controller执行完成返回</li>
<li>ModelAndView对象HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover(视图解析器)</li>
<li>ViewReslover解析后返回具体View(视图)</li>
<li>DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)</li>
<li>DispatcherServlet响应用户</li>
</ul>
<p>&#x3D;&#x3D;<strong>前后端分离阶段(接口开发，异步请求)</strong>&#x3D;&#x3D;</p>
<ul>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping(处理器映射器)</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter(处理器适配器)</li>
<li>HandlerAdapter经过适配调用具体的处理器(Handler&#x2F;Controller)</li>
</ul>
<p><span style = "color:red"><strong>SpringBoot自动配置原理？</strong></span></p>
<blockquote>
<p>SpringBoot中最高频的一道面试题，也是框架最核心的思想<br>&#x3D;&#x3D;<code>@SpringBootConfiguration</code>&#x3D;&#x3D;：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类<br>&#x3D;&#x3D;<code>@ComponentScan</code>&#x3D;&#x3D;：组件扫描，默认扫描当前引导类所在包及其子包<br>&#x3D;&#x3D;<code>@EnableAutoConfiguration</code>&#x3D;&#x3D;：SpringBoot实现自动化配置的核心注解</p>
<p>1，在Spring Boot项目中的引导类上有一个注解<code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是:</p>
<ul>
<li><code>@SpringBootConfiquration</code></li>
<li><code>@EnableAutoConfiquration</code></li>
<li><code>@ComponentScan</code></li>
</ul>
<p>2，其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解。<u>该注解通过<code>@Import</code>注解导入对应的<strong>配置选择器</strong>。内部就是读取了该项目和该项目引用的jar包的classpath路径下<code>META-INF/spring.factories</code>文件中的所配置的类的全类名。在这些配置类中所定义的Bean会根据条件注解<strong>所指定的条件来决定</strong>是否需要将其导入到Spring容器中</u>。</p>
<p>3，条件判断会有像<code>@ConditionalOnClass</code>这样的注解，<u>判断是否有对应的class文件</u>，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p>
</blockquote>
<pre><code class="java">package com.itheima;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// SpringBoot的启动类
// 注意: 我们写的代码要在启动类的包或者子包中
// @SpringBootApplication注解中包含了 @ComponentScan，没有指定扫描哪个包，默认扫描当前类所在的包和子包
@SpringBootApplication
public class Day15TliasManagement01IocDiApplication &#123;
    // 启动项目, 内嵌的Tomcat会启动, 把项目部署到这个内嵌Tomcat中
    public static void main(String[] args) &#123;
        SpringApplication.run(Day15TliasManagement01IocDiApplication.class, args);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>按住<code>ctrl+左键</code>点击<code>@SpringBootApplication</code>会弹到<code>SpringBootApplication.class</code>界面</p>
</blockquote>
<pre><code class="mysql">@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = &#123;@Filter(
    type = FilterType.CUSTOM,
    classes = &#123;TypeExcludeFilter.class&#125;
), @Filter(
    type = FilterType.CUSTOM,
    classes = &#123;AutoConfigurationExcludeFilter.class&#125;
)&#125;
)
</code></pre>
<blockquote>
<p>按住<code>ctrl+左键</code>点击<code>@EnableAutoConfiguration</code>会弹到<code>EnableAutoConfiguration.class</code>界面</p>
</blockquote>
<pre><code class="mysql"># @Import(&#123;AutoConfigurationImportSelector.class&#125;)
# AutoConfigurationImportSelector是自动配置的选择器 
# 会加载META-INF中的spring.factories文件的自动配置类...AutoConfiguration...
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.boot.autoconfigure;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.context.annotation.Import;

@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(&#123;AutoConfigurationImportSelector.class&#125;)
public @interface EnableAutoConfiguration &#123;
    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;

    Class&lt;?&gt;[] exclude() default &#123;&#125;;

    String[] excludeName() default &#123;&#125;;
&#125;
</code></pre>
<p><span style = "color:red"><strong>Spring框架常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围<del>默认单例的</del></td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定Spring在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程(AOP)</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringMVC框架常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping</td>
<td>用于映射请求路径，可以定义在类上和方法上。用于类上，则标识类中的所有的方法都是以该地址作为父路径</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>注解实现接收http请求的json数据，将json转换为java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数的名称</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径中获取请求参数(<code>/user/&#123;id&#125;</code>)，传递给方法的形式参数</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>注解实现将Controller方法返回对象转换成json对象响应给客户端</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>获取指定的请求头数据</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringBoot常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@SpringBootConfiguration</td>
<td>组合了 <code>-@Configuration注解</code>，实现配置文件的功能</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>打开自动配置的功能，也可以关闭某个自动配置的选项</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>Spring组件扫描</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/aa2405d532d8e6606845f6a1a4da8456b797e115/%E6%B3%A8%E8%A7%A3%E5%A4%A7%E6%B1%87%E6%80%BB.png"></p>
<p><span style = "color:red"><strong>MyBatis执行流程？</strong></span></p>
<blockquote>
<ul>
<li>读取MyBatis配置文件:mybatis-config.xml加载运行环境和映射文件</li>
<li>构造会话工厂SqlSessionFactory</li>
<li>会话工厂创建SqlSession对象(包含了执行SQL语句的所有方法)</li>
<li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li>
<li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射</li>
<li>输出结果映射</li>
</ul>
</blockquote>
<ul>
<li>理解了各个组件的关系</li>
<li>Sql的执行过程(参数映射、sql解析、执行和结果处理)</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/7263f0a583711bca127933c0053e2b1fef476cb7/MyBatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" style="zoom:80%;" />



<p><span style = "color:red"><strong>MyBatis是否支持延迟加载？</strong></span></p>
<blockquote>
<ul>
<li>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</li>
<li>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载</li>
<li>在<code>Mybatis配置文件</code>中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true/false</code>，默认是关闭的</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>延迟加载的底层原理知道吗？</strong></span></p>
<blockquote>
<ul>
<li>使用<strong>CGLIB</strong>创建目标对象的代理对象</li>
<li>当调用目标方法时，进入拦截器<strong>invoke</strong>方法，发现目标方法是nul值，执行sql查询</li>
<li>获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</li>
</ul>
</blockquote>
<blockquote>
<p>查询用户的时候，把用户所属的订单数据也查询出来，这个是&#x3D;&#x3D;<strong>立即加载</strong>&#x3D;&#x3D;<br>查询**<u>用户的(sql)</u><strong>时候，暂时不查询订单数据，当需要订单的时候，再查询</strong><u>订单(sql)</u>**，这个就是&#x3D;&#x3D;<strong>延迟加载</strong>&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<h3 id="延迟加载的实现步骤："><a href="#延迟加载的实现步骤：" class="headerlink" title="延迟加载的实现步骤："></a>延迟加载的实现步骤：</h3><ol>
<li><strong>配置开启延迟加载</strong>： 在MyBatis的配置文件中（通常是<code>mybatis-config.xml</code>），需要设置两个属性：<ul>
<li><code>lazyLoadingEnabled=true</code>：开启延迟加载。</li>
<li><code>aggressiveLazyLoading=false</code>：关闭积极的延迟加载，即访问对象的时候不会立即加载其所有属性。</li>
</ul>
</li>
<li><strong>映射文件配置</strong>： 在对应的Mapper映射文件中，对于需要延迟加载的关联查询，使用<code>select</code>标签定义延迟加载的SQL语句，并通过<code>fetchType=&quot;lazy&quot;</code>属性明确指定使用延迟加载。</li>
<li><strong>创建代理对象</strong>： 当执行查询操作时，MyBatis不会立即执行关联查询的SQL，而是返回一个代理对象。这个代理对象是使用CGLIB库创建的，它继承自目标对象。</li>
<li><strong>拦截器方法调用</strong>： 当我们首次访问这个代理对象的某个方法（比如访问订单详情）时，实际上会调用CGLIB生成的代理对象的拦截器方法（<code>intercept</code>方法）。在拦截器方法中，会判断当前要访问的属性是否已经被加载：<ul>
<li>如果属性已经被加载，则直接返回属性值。</li>
<li>如果属性未被加载，则会执行之前定义好的延迟加载SQL语句，从数据库中查询数据。</li>
</ul>
</li>
<li><strong>设置属性值</strong>： 查询得到数据后，MyBatis会将这些数据设置到目标对象的相应属性上，这样下次访问该属性时，就不需要再次查询数据库了。</li>
</ol>
<h3 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h3><ul>
<li><strong>CGLIB代理</strong>：MyBatis使用CGLIB库创建目标对象的代理，当调用目标方法时，实际上会进入拦截器（Interceptor）的<code>intercept</code>方法。</li>
<li><strong>拦截器逻辑</strong>：在拦截器中，会判断当前调用的方法是否需要触发延迟加载。如果需要，则执行延迟加载的SQL查询。</li>
<li><strong>结果处理</strong>：查询结果会被处理并设置到目标对象的属性上，这样目标对象的相关属性就持有了数据，后续访问将直接返回这些数据，而无需再次查询。<code>MyBatis在执行完延迟加载的SQL查询后，会获取查询结果，并将这些结果映射到目标对象的相应属性中</code></li>
</ul>
<h3 id="示例说明："><a href="#示例说明：" class="headerlink" title="示例说明："></a>示例说明：</h3><p>假设有一个用户<code>User</code>和订单<code>Order</code>的关系，在查询用户时，通常不会立即加载其订单信息，而是当需要时再加载。以下是简化的代码示例：</p>
<pre><code class="xml">&lt;!-- UserMapper.xml --&gt;
&lt;resultMap id=&quot;userMap&quot; type=&quot;User&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
  &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
  &lt;!-- 延迟加载订单信息 --&gt;
  &lt;collection property=&quot;orders&quot; column=&quot;id&quot; ofType=&quot;Order&quot; select=&quot;selectOrdersForUser&quot; fetchType=&quot;lazy&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectUser&quot; resultMap=&quot;userMap&quot;&gt;
  SELECT * FROM user WHERE id = #&#123;id&#125;
&lt;/select&gt;

&lt;select id=&quot;selectOrdersForUser&quot; resultType=&quot;Order&quot;&gt;
  SELECT * FROM order WHERE user_id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>在上述配置中，当调用<code>selectUser</code>查询用户信息时，不会立即查询订单信息。只有当程序中访问<code>User</code>对象的<code>orders</code>属性时，才会执行<code>selectOrdersForUser</code>查询，这就是延迟加载的具体实现。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/1fdf519599da660621e27393d18b48f4b2bdb802/MyBatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86.png"  />

<p><span style = "color:red"><strong>MyBatis的一级、二级缓存用过吗？</strong></span></p>
<blockquote>
<ul>
<li>一级缓存:基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</li>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用PerpetualCache，HashMap 存储。需要单独开启，一个是核心配置，一个是mapper映射文件</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>MyBatis的二级缓存什么时候会清理缓存中的数据？</strong></span></p>
<blockquote>
<ul>
<li>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ul>
</blockquote>
<ul>
<li>本地缓存，基于PerpetualCache，本质是一个HashMap</li>
<li><strong>一级缓存</strong>：作用域是session级别<ul>
<li>基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，<strong>默认打开一级缓存</strong></li>
</ul>
</li>
<li><strong>二级缓存</strong>：作用域是namespace和mapper的作用域，不依赖于session<ul>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用 PerpetualCache<br>HashMap 存储</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d5f133abb10da579732fe734073e28b0713a3b63/Mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.jpg"></p>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear</li>
<li>二级缓存需要缓存的数据实现Serializable接口</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li>
</ul>
<h2 id="SpringCloud篇"><a href="#SpringCloud篇" class="headerlink" title="SpringCloud篇"></a><span style = "color:blue">SpringCloud篇</span></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/a556069d277599cc45e30c8e2e719fba7ff392cb/SpringCloud%E9%9D%A2%E8%AF%95%E9%A2%98.jpg"></p>
<p><span style = "color:red"><strong>SpringCloud 5大组件有哪些？</strong></span></p>
<p>回答原则：简单的问题不能答错</p>
<table>
<thead>
<tr>
<th>通常情况</th>
<th>SpringCloudAlibba</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka：注册中心</td>
<td>Nacos：注册中心&#x2F;配置中心</td>
</tr>
<tr>
<td>Ribbon：负载均衡</td>
<td>Ribbon：负载均衡</td>
</tr>
<tr>
<td>Feign：远程调用</td>
<td>Feign：远程调用</td>
</tr>
<tr>
<td>Hystrix：服务熔断</td>
<td>sentinel：服务保护</td>
</tr>
<tr>
<td>Zuul&#x2F;Gateway：网关</td>
<td>Gateway：服务网关</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/39f10dd62358b96346cdf42dd3f893f0d0920bcc/SpringCloud5%E5%A4%A7%E7%BB%84%E4%BB%B6.jpg"></p>
<p><span style = "color:red"><strong>服务注册和发现是什么意思？ SpringCloud 如何实现服务注册发现？</strong></span></p>
<blockquote>
<ul>
<li>我们当时项目采用的<code>eureka</code>作为注册中心，这个也是SpringCloud体系的一个核心组件</li>
<li><strong>服务注册</strong>：服务提供者需要把自己的信息注册到eureka来保存这些信息，比如**<u>服务名称、ip、端口</u>**等等</li>
<li><strong>服务发现</strong>：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者利用<strong>负载均衡</strong>算法，选择一个发起调用</li>
<li><strong>服务监控</strong>：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没有收到心跳，从eureka中剔除</li>
</ul>
</blockquote>
<ul>
<li>微服务中必须要使用的组件，考虑我们使用微服务的程度</li>
<li>注册中心的核心作用是：服务注册和发现</li>
<li>常见的注册中心：<strong>eureka、nocas</strong>、zookeeper</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b4f4fe573949c4168cd4114f6cc6a28679f84181/Eureka%E4%BD%9C%E7%94%A8.jpg"></p>
<p><span style = "color:red"><strong>请你说一下nacos与eureka的区别？</strong></span></p>
<blockquote>
<ul>
<li><strong>Nacos与Eureka的共同点</strong> (<u>注册中心</u>)<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务者心跳方式做健康检测</li>
</ul>
</li>
<li><strong>Nacos与Eureka的区别</strong> (<u>注册中心</u>)<ul>
<li>Nacos支持服务端主动检测提供者状态：<strong>临时实例采用心跳模式，非临时实例采用主动检测模式</strong></li>
<li><strong>临时实例心跳不正常会被剔除，非临时实例则不会被提出</strong></li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式<del>高可用模式</del>，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
<li>Nacos还支持了配置中心，Eureka只有注册中心，也是选择选用nacos的一个重要原因</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3c304f59104d2917c35ecb658f95f7073365ed9c/Eureka%E5%92%8CNacos%E5%8C%BA%E5%88%AB.jpg"></p>
<p><span style = "color:red"><strong>把RestTemplate替换成OpenFeign后它们的底层还是一样的吗？</strong></span><del>OpenFeign是远程调用</del></p>
<p>OpenFeign的底层原理也是根据服务名称，首先去远程注册中心拉取服务列表，底层也会在本地缓存一份，也会根据负载均衡选出一个实例，又运用了jdk的动态代理生成代理类，也会涉及到反射机制，最终拼出完整的url，发起http远程调用</p>
<pre><code class="java">@FeignClient(name = &quot;service-provider&quot;)
public interface ServiceProviderClient &#123;
    // 定义接口方法，映射到服务提供者的具体API
    @GetMapping(&quot;/api/resource&quot;)
    String getResource();
&#125;
</code></pre>
<p><span style = "color:red"><strong>你们项目负载均衡如何实现的？</strong></span><del>图1.1</del></p>
<blockquote>
<p>微服务的负载均衡主要使用了一个组件Ribbon，比如，我们再使用feign远程调用的过程中，底层的负载均衡就是使用了Ribbon</p>
</blockquote>
<ul>
<li>负载均衡Ribbon，发起远程调用feign就会使用Ribbon</li>
<li>Ribbon负载均衡策略有哪些</li>
<li>如果想自定义负载均衡策略如何实现？</li>
</ul>
<h6 id="Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring-Cloud-LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进"><a href="#Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring-Cloud-LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进" class="headerlink" title="Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring Cloud LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进"></a>Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring Cloud LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/2a6397006f0e74e16de4222ac7ab2758e98aa96c/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0.png"></p>
<p><span style = "color:red"><strong>Ribbon负载均衡策略有哪些？</strong></span></p>
<ul>
<li><span style="color:blue"><strong>RoundRobinRule</strong>：简单<u>轮询服务列表</u>来选择服务器</span></li>
<li><span style="color:blue"><strong>WeightedResponseTimeRule</strong>：按照<u>权重</u>来选择服务器，响应时间越长，权重越小</span></li>
<li><span style="color:blue"><strong>RandomRule</strong>：<u>随机选择</u>一个可用的服务器</span></li>
<li>BestAvaliableRule：忽略那些短路的服务器，并选择并发数较低的服务器</li>
<li>RetryRule：重试机制的选择逻辑</li>
<li>AvaliabilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例</li>
<li><span style="color:blue"><strong>ZoneAvoidanceRule</strong>：以<u>区域可用</u>的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可用理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询</span></li>
</ul>
<p><span style = "color:red"><strong>如果想自定义负载均衡策略如何实现？</strong></span><del>图1.2</del></p>
<blockquote>
<ul>
<li>创建类实现IRule接口，可以指定负载均衡策略（全局）</li>
<li>在客户端的配置文件中，可以配置某一个服务调用的负载均衡（局部）</li>
</ul>
</blockquote>
<blockquote>
<p>首先，你需要创建一个类来实现 <code>IRule</code> 接口，这样就能自定义负载均衡的策略。</p>
<pre><code class="java">java复制编辑import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.Server;
import com.netflix.loadbalancer.ZoneAwareLoadBalancer;
import com.netflix.loadbalancer.RandomRule;

import java.util.List;

public class CustomLoadBalancerRule implements IRule &#123;

    private IRule delegate = new RandomRule();  // 默认策略

    @Override
    public Server choose(Object key) &#123;
        // 在这里实现自己的负载均衡算法
        // 比如，你可以使用 RoundRobin、Random 或者基于健康检查的策略
        return delegate.choose(key);
    &#125;

    @Override
    public void setLoadBalancer(ZoneAwareLoadBalancer&lt;?&gt; lb) &#123;
        delegate.setLoadBalancer(lb);
    &#125;

    @Override
    public ZoneAwareLoadBalancer&lt;?&gt; getLoadBalancer() &#123;
        return delegate.getLoadBalancer();
    &#125;
&#125;
</code></pre>
<p>然后，你需要在 Spring 配置类或者启动类上注入该自定义的负载均衡策略。</p>
<pre><code class="java">java复制编辑import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RibbonConfig &#123;

    @Bean
    public IRule customLoadBalancerRule() &#123;
        return new CustomLoadBalancerRule();
    &#125;
&#125;
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>SpringCloud中什么是服务雪崩，怎么解决这个问题？</strong></span></p>
<ul>
<li>什么是&#x3D;&#x3D;<strong>服务雪崩</strong>&#x3D;&#x3D;？<del>一个服务失败，导致整条链路的服务都失败的情形</del></li>
</ul>
<blockquote>
<ul>
<li>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9900715f7f6943c509f9312dc31f4cf581e0af49/%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9.jpg"></p>
<ul>
<li>&#x3D;&#x3D;<u><strong>熔断降级</strong></u>&#x3D;&#x3D; &amp;&amp; &#x3D;&#x3D;<strong>服务熔断</strong>&#x3D;&#x3D;（解决）<strong>Hystix 服务熔断降级</strong></li>
</ul>
<blockquote>
<p><strong><u>服务降级</u></strong><del>部分服务不可用</del>：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，<span style = "color:orange"><strong>一般在实际开发中与Feign接口整合，编写降级逻辑</strong></span></p>
</blockquote>
<blockquote>
<p><strong><u>服务熔断</u></strong><del>整个服务不可用</del>：默认关闭，需要手动打开，如果监测到<span style = "color:orange"><strong>10秒内请求的失败率超过50%</strong></span>，就触发熔断机制。之后<span style = "color:orange"><strong>每隔5秒重新尝试请求</strong></span>微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a3195c4ca2d1f63815e09a802354a9c28209893b/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5.jpg"></p>
<ul>
<li><strong>限流（预防）</strong><del>微服务限流(漏桶算法、令牌桶算法)</del></li>
</ul>
<p><span style = "color:red"><strong>你们项目中有没有做到限流？怎么做的？&amp;&amp; 限流常见的算法有哪些？？</strong></span></p>
<blockquote>
<p>① 先来介绍一下业务，什么情况下去做限流，需要说明<strong>QPS</strong>具体是多少</p>
<ul>
<li>我们有一个活动，到了假期就会抢购优惠券，QPS最高可以达到2000，平时10-50之间，为了应对突发流量，需要做限流</li>
<li>常规限流，为了防止恶意攻击，保护系统正常运行，我们当时系统能够承受最大的QPS是多少(压测结果)</li>
</ul>
<p>② <strong>nginx限流</strong></p>
<ul>
<li>控制速率(突发流量)，使用的<strong>漏桶算法</strong>来实现过滤，让请求以固定的速率处理请求，可以应对突发流量</li>
<li>控制并发数，限制单个ip的连接数和并发链接的总数</li>
</ul>
<p>③ <strong>网关限流</strong></p>
<ul>
<li>在SpringCloudGateway中支持局部过滤器RequestRateLimiter来做限流，使用的是令牌桶算法</li>
<li>可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</li>
</ul>
</blockquote>
<blockquote>
<h4 id="解释原理："><a href="#解释原理：" class="headerlink" title="解释原理："></a>解释原理：</h4><p>QPS（Queries Per Second，每秒查询率）是衡量一个系统处理请求能力的指标，它表示服务器在一秒钟内能够处理的查询数量。这个指标常用于数据库和web服务器等应用，以评估系统在高并发情况下的性能。<br>以下是对您提到的两句话的分析：</p>
<ol>
<li><strong>活动期间的高并发处理：</strong></li>
</ol>
<ul>
<li><strong>背景知识：</strong> 在电子商务等应用中，促销活动往往会引起用户的大量点击和购买行为，导致短时间内流量剧增。</li>
<li><strong>限流原理：</strong> 为了应对这种突发的高流量，系统需要实施限流措施。限流是为了保护系统资源不被过度消耗，确保系统的稳定性和可靠性。常见的限流算法有固定窗口、滑动窗口、令牌桶和漏桶等。</li>
</ul>
<p><code>固定窗口： 假设每 1 分钟允许 100 次请求，10:00:00 到 10:01:00 期间的 100 次请求被允许，超出 100 次则会被限流，10:01:00 到 10:02:00 则重新开始计算。</code></p>
<p><code>滑动窗口： 每 60 秒内最多允许 100 次请求，滑动窗口的时间长度为 60 秒，窗口内的请求数会随着时间滑动更新，防止请求在时间边界上积压</code></p>
<p><code>令牌桶：假设每秒生成 10 个令牌，令牌桶的容量为 100 个令牌。如果 1 秒内有 15 个请求到达，则前 10 个请求能获得令牌并继续执行，剩余的 5 个请求需要等到下一个时间窗口令牌生成后再执行。</code></p>
<p><code>漏桶：假设每秒钟流出 10 个请求，漏桶的容量为 100 个请求。如果 1 秒钟内接收了 30 个请求，系统只会处理 10 个请求，剩余的 20 个请求被丢弃，直到下一个时间点。</code></p>
<ul>
<li><strong>实施方式：</strong> 在您提到的情况下，可以采用以下策略：<ul>
<li><strong>预判性扩容：</strong> 根据历史数据和活动规模预测流量，提前进行服务器资源的扩容。</li>
<li><strong>动态限流：</strong> 在活动期间，根据实时监控的QPS数据动态调整限流阈值，保证系统平稳运行。</li>
<li><strong>排队处理：</strong> 对于超出系统处理能力的请求，可以采用队列进行缓冲，分批次处理。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>常规限流与系统最大承受QPS：</strong></li>
</ol>
<ul>
<li><strong>背景知识：</strong> <strong>常规限流</strong>是为了在日常运行中防止恶意攻击（如<strong>DDoS攻击</strong>）和保护系统资源不被滥用。</li>
<li><strong>压测结果：</strong> 系统的最大承受QPS是通过压力测试得出的。压力测试（也称为负载测试）是通过模拟高并发访问来测试系统的极限性能，以确定系统在保证稳定运行的前提下能够承受的最大QPS。</li>
<li><strong>原理分析：</strong> <ul>
<li><strong>保护系统：</strong> 通过设定一个QPS上限，可以防止系统过载，保障系统的正常运行。</li>
<li><strong>资源分配：</strong> 了解系统的最大承受QPS有助于合理分配资源，如数据库连接、内存和CPU等。</li>
<li><strong>用户体验：</strong> 适当的限流可以保证用户的体验，避免因系统过载导致的响应缓慢或服务不可用。<br>在实施限流策略时，还需要考虑以下因素：</li>
</ul>
</li>
<li><strong>业务优先级：</strong> 对于不同的业务请求，可能需要有不同的限流策略，优先保证核心功能的可用性。</li>
<li><strong>用户体验：</strong> 限流策略应尽量减少对用户体验的影响，例如通过友好的错误提示或降级方案。</li>
<li><strong>数据监控：</strong> 实时监控系统的QPS和其他关键指标，以便快速响应并调整限流策略。<br>综上所述，限流是确保系统在高并发情况下稳定运行的重要措施，而了解系统的最大承受QPS是制定合理限流策略的基础。</li>
</ul>
</blockquote>
<p>为什么要限流？</p>
<ul>
<li><strong>并发业务量大</strong>(突发流量)</li>
<li>防止用户<strong>恶意刷接口</strong></li>
</ul>
<h6 id="限流的实现方式："><a href="#限流的实现方式：" class="headerlink" title="限流的实现方式："></a>限流的实现方式：</h6><ul>
<li><p>&#x3D;&#x3D;<strong>Tomcat</strong>&#x3D;&#x3D;<del>单体项目可以,分布式不行</del>：可以设置最大连接数 <code>&lt;Connector port=&quot;8080&quot;...maxThreads=&quot;150&quot;...&gt;</code></p>
</li>
<li><p>&#x3D;&#x3D;<strong>Nginx</strong>&#x3D;&#x3D;：<strong>漏桶算法</strong><del>固定速率露出(平滑)</del></p>
<p>控制速率(突发流量)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/8090ab914e03e67198de3dd121167624b5c3a541/Nginx%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E9%99%90%E6%B5%81.png" style="zoom: 200%;" />
</li>
<li><p>&#x3D;&#x3D;<strong>网关</strong>&#x3D;&#x3D;：<strong>令牌桶算法</strong></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/e32511e92db5c1c27f7fad58f5078039014016a6/%E7%BD%91%E5%85%B3%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png" style="zoom: 200%;" />
</li>
<li><p>自定义拦截器</p>
</li>
</ul>
<p><span style = "color:red"><strong>你们的微服务是怎么监控的？</strong></span></p>
<blockquote>
<p><strong>我们项目中采用的skywalking进行监控的</strong></p>
<ul>
<li>skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</li>
<li>我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</li>
</ul>
</blockquote>
<h6 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h6><p>一个分布式系统的应用程序性能监控工具(Application Performance Management), 提供了完善的链路追踪能力，apache的顶级项目(前华为产品经理吴晟主导开源)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/889f98186e8bf25ea018e80457f9333fef009d07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A71.jpg"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/33749d5ca478f04bee93c83339a877330485f51a/skywalking%E7%9B%91%E6%8E%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1.png"></p>
<p><span style = "color:red"><strong>解释一下CAP和BASE<del>分布式系统理论</del></strong></span></p>
<blockquote>
<ul>
<li>CAP 定理(一致性、可用性、分区容错性)</li>
</ul>
<ol>
<li>分布式系统节点通过网络连接，一定会出现分区问题(P)</li>
<li>当分区出现时，系统的一致性(C)和可用性(A)就无法同时满足</li>
</ol>
<ul>
<li>BASE理论</li>
</ul>
<ol>
<li>基本可用</li>
<li>软状态</li>
<li>最终一致</li>
</ol>
<ul>
<li>解决分布式事务的思想和模型</li>
</ul>
<ol>
<li><u>最终一致思想</u>：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据(AP)</li>
<li><u>强一致思想</u>：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚(CP)</li>
</ol>
</blockquote>
<ul>
<li>分布式事务方案的指导</li>
<li>分布式系统设计方向</li>
<li>根据业务指导使用正确的技术选择</li>
</ul>
<h5 id="x3D-x3D-CAP定理-x3D-x3D-分布式系统无法同时满足三个指标"><a href="#x3D-x3D-CAP定理-x3D-x3D-分布式系统无法同时满足三个指标" class="headerlink" title="&#x3D;&#x3D;CAP定理&#x3D;&#x3D;分布式系统无法同时满足三个指标"></a>&#x3D;&#x3D;CAP定理&#x3D;&#x3D;<del>分布式系统无法同时满足三个指标</del></h5><ul>
<li>&#x3D;&#x3D;<strong>Consistency</strong>&#x3D;&#x3D;（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。<del>主从一致</del></li>
<li>&#x3D;&#x3D;<strong>Availability</strong>&#x3D;&#x3D;（可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</li>
<li>&#x3D;&#x3D;<strong>Partition</strong> tolerance&#x3D;&#x3D;（分区容错性）：当出现网络分区现象后，系统能够继续运行<ul>
<li>Partition（分区）：因为网络故障或其他原因导致分布式系统中的部分节点与其他节点失去链接，形成独立分区</li>
<li>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务</li>
</ul>
</li>
</ul>
<p>结论：</p>
<ul>
<li>分布式系统节点之间肯定是需要网络链接的，<strong>分区 (P) 必然存在</strong></li>
<li><u>如果保证访问的高可用性（<strong>A</strong>）可以持续对外提供服务</u>，但不能保证数据的强一致性 <strong>AP</strong></li>
<li><u>如果保证访问的数据强一致性（C）就要放弃高可用性</u> <strong>CP</strong></li>
</ul>
<h5 id="x3D-x3D-BASE理论-x3D-x3D"><a href="#x3D-x3D-BASE理论-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;BASE理论&#x3D;&#x3D;"></a>&#x3D;&#x3D;BASE理论&#x3D;&#x3D;</h5><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li>&#x3D;&#x3D;<strong>Basically Avaliable</strong>&#x3D;&#x3D;（基本可用）：分布式系统在出现故时，允许损失部分可用性，即保证核心可用</li>
<li>&#x3D;&#x3D;<strong>Soft State</strong>&#x3D;&#x3D;（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态</li>
<li>&#x3D;&#x3D;<strong>Eventually Consistent</strong>&#x3D;&#x3D;（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3f0f7a676a51ce6dded96d7c6a910a7c6b763d99/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%92%88%E5%AF%B9CAP%E7%9A%84BASE%E7%90%86%E8%AE%BA.jpg"></p>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/data/CAP%E5%AE%9A%E7%90%86.jpg?raw=true"></p>
<p><span style = "color:red"><strong>你们采用哪种分布式事务解决方案？</strong></span></p>
<blockquote>
<p>● 简历上写的微服务，只要是发生了多个服务之间的<strong>写操作</strong>，都需要进行分布式事务控制</p>
<p>● 描述项目中采用的哪种方案(seataMQ)<br>⚪ seata的XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差 (<span style = "color:red"><strong>银行业务</strong></span> )<br>⚪ seata的AT模式，AP，底层使用undolog 实现，性能好 (<span style = "color:red"><strong>互联网业务</strong></span> )<br>⚪ seata的TCC模式，AP，性能较好，不过需要人工编码实现 (<span style = "color:red"><strong>银行业务</strong></span> )<br>⚪ MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务异步，性能最好 (<span style = "color:red"><strong>互联网业务</strong></span> )</p>
</blockquote>
<ul>
<li>Seata框架(XA、AT、TCC)</li>
<li>MQ</li>
</ul>
<h4 id="Seata架构"><a href="#Seata架构" class="headerlink" title="Seata架构"></a>Seata架构</h4><ul>
<li><strong>TC</strong>(Transaction Coordinator) - <strong>事务协调者</strong>：<u>维护全局和分支事务的状态，协调全局事务提交或回滚</u></li>
<li><strong>TM</strong>(Transaction Manager) - <strong>事务管理器</strong>：定义全局事务的范围、开启全局事务、提交或回滚全局事务</li>
<li><strong>RM</strong>(Resource Manager) - <strong>资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/30dd6983ec4340d3f3f4118f3d5ccf89e4199555/XA%2CAT%2CTCC.png"></p>
<p><span style = "color:red"><strong>分布式服务的<u>接口幂等性</u>如何设计？</strong></span></p>
<blockquote>
<ul>
<li>幕等: 多次调用方法或者接口不务状态，可以<strong>保证重复调用的结果和单次调用的结果一致</strong></li>
<li>如果是**<u>新增数据</u>**，可以使用数据库的唯一索引</li>
<li>如果是**<u>新增或修改数据</u>**<ul>
<li>分布式锁，性能较低</li>
<li>使用token+redis来实现，性能较好<br>●  第一次请求，生成一个唯一token存入redis，返回给前端<br>●  第二次请求，业务处理，携带之前的token，到redis进行验证，如果存在，可以执行业务，删除token; 如果不存在，则直接返回，不处理业务</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>幂等</strong>：<u>多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</u></p>
<h6 id="需要幂等场景"><a href="#需要幂等场景" class="headerlink" title="需要幂等场景"></a>需要幂等场景</h6><ul>
<li>用户重复点击(网络波动)</li>
<li>MQ消息重复</li>
<li>应用使用失败或超时</li>
</ul>
<table>
<thead>
<tr>
<th>请求方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>查询操作，天然幂等</td>
</tr>
<tr>
<td>POST</td>
<td>新增操作，请求一次与请求多次造成的结果不同，<strong>不是幂等的</strong></td>
</tr>
<tr>
<td>PUT</td>
<td>更新操作，如果是以绝对值更新，则是幂等的。如果是通过增量的方式更新，则<strong>不是幂等的</strong></td>
</tr>
<tr>
<td>DELETE</td>
<td>删除操作，根据唯一值删除，是幂等的</td>
</tr>
</tbody></table>
<pre><code class="mysql">update a set money = 500 where id = 1 【幂等】
update a set money = money + 500 where id = 1; 【非幂等】
</code></pre>
<ul>
<li><p><strong>数据库唯一索引</strong>【新增】</p>
</li>
<li><p><strong>&#x3D;&#x3D;token + redis&#x3D;&#x3D;</strong> 【新增+修改】**<u>AND</u>**  <strong>&#x3D;&#x3D;分布式锁&#x3D;&#x3D;</strong> 【新增+修改】</p>
<h6 id="创建商品、提交订单、转账、支付等操作"><a href="#创建商品、提交订单、转账、支付等操作" class="headerlink" title="创建商品、提交订单、转账、支付等操作"></a>创建商品、提交订单、转账、支付等操作</h6></li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/58b8b5385bf3e40c1661e824f613b15f57686549/token+redis%20AND%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" style="zoom:200%;" />



<p><span style = "color:red"><strong>你们项目中使用了什么分布式任务调度</strong></span></p>
<p><code>xxl-job</code> 是一个分布式任务调度平台，它致力于解决分布式场景下的任务调度问题，主要由调度中心和执行器两部分组成。调度中心负责统一管理任务调度，而执行器则是负责接收调度并执行任务逻辑的客户端。</p>
<ul>
<li><p><span style = "color:red"><strong>xxl-job路由策略有哪些？</strong></span></p>
<blockquote>
<p>xxl-job提供了很多的路由策略，我们平时用的较多的就是：<strong>轮询、故障转移、分片广播</strong></p>
</blockquote>
</li>
<li><p><span style = "color:red"><strong>xxl-job任务执行失败怎么解决？</strong></span></p>
<blockquote>
<ul>
<li>路由策略选择<strong>故障转移</strong>，使用健康的实例来执行任务</li>
<li>设置重试次数</li>
<li>查看<strong>日志+邮件</strong>警告来通知相关负责人解决</li>
</ul>
</blockquote>
</li>
<li><p><span style = "color:red"><strong>如果有大数据量的任务同时都现需要执行，怎么解决？</strong></span></p>
<blockquote>
<ul>
<li>让多个实例一块去执行(部署集群)，路由策略<strong>分片广播</strong></li>
<li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行</li>
</ul>
</blockquote>
</li>
</ul>
<h6 id="xxl-job解决的问题"><a href="#xxl-job解决的问题" class="headerlink" title="xxl-job解决的问题"></a>xxl-job解决的问题</h6><ul>
<li>解决集群任务的重复执行问题                   xxl-job路由策略有哪些？</li>
<li>cron表达式定义灵活<del>在页面上</del>                      xxl-job任务执行失败怎么解决？</li>
<li>定时任务失败了，重试和统计                   如果有大数据量的任务同时都需要执行，怎么解决？</li>
<li>任务量大，分片执行</li>
</ul>
<blockquote>
<h4 id="场景-1-定时处理过期订单"><a href="#场景-1-定时处理过期订单" class="headerlink" title="场景 1: 定时处理过期订单"></a>场景 1: <strong>定时处理过期订单</strong></h4><p>假设用户下单后如果订单超过了某个时间没有支付，平台需要自动取消该订单并释放库存。这个任务需要在每天的某个固定时间（比如凌晨 2 点）运行。</p>
<h5 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>定时任务调度</strong>：XXL-Job 可以轻松管理该任务的执行时间和周期，确保每天准时执行，不需要开发者手动触发。</li>
<li><strong>任务失败重试</strong>：如果该任务因为某些原因执行失败，XXL-Job 可以自动进行重试，并设置重试次数，确保任务最终被执行。</li>
<li><strong>分布式执行</strong>：假设电商平台是一个分布式系统，订单数据存储在多个数据库中，XXL-Job 可以通过分布式执行确保每个数据库的订单都被正确处理</li>
</ol>
<p><u>假设每晚 2 点有一个任务需要取消未支付的订单</u>：</p>
<pre><code class="java">public class OrderJob &#123;
    @JobHandler(&quot;orderCancelJobHandler&quot;)
    public void cancelUnpaidOrders() &#123;
        // 查询所有未支付的订单
        List&lt;Order&gt; unpaidOrders = orderService.findUnpaidOrders();
        for (Order order : unpaidOrders) &#123;
            if (order.isExpired()) &#123;
                orderService.cancelOrder(order);
                inventoryService.releaseStock(order.getProductId(), order.getQuantity());
                // 发送订单取消通知给用户
                notificationService.sendOrderCancelledNotification(order.getUserId());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="场景-2-定时更新商品库存"><a href="#场景-2-定时更新商品库存" class="headerlink" title="场景 2: 定时更新商品库存"></a>场景 2: <strong>定时更新商品库存</strong></h4><p>假设电商平台上销售的是一些有时效性的商品，商家需要定期更新商品的库存状态（例如，库存数量达到一定阈值时，自动下架商品，或者增加库存数量）。这个任务同样需要定时执行。</p>
<h5 id="解决的问题：-1"><a href="#解决的问题：-1" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>任务分片</strong>：在商品很多的情况下，XXL-Job 可以通过任务分片的方式并行处理不同商品的库存更新，提升任务的执行效率。</li>
<li><strong>任务优先级</strong>：根据不同商品的重要程度，XXL-Job 可以设置任务的优先级，确保关键商品的库存更新优先执行。</li>
</ol>
<pre><code class="java">public class InventoryJob &#123;
    @JobHandler(&quot;inventoryUpdateJobHandler&quot;)
    public void updateProductInventory() &#123;
        // 获取需要更新库存的商品
        List&lt;Product&gt; productsToUpdate = productService.findProductsForInventoryUpdate();
        for (Product product : productsToUpdate) &#123;
            inventoryService.updateInventory(product);
            if (product.getStockQuantity() &lt;= product.getLowStockThreshold()) &#123;
                productService.deactivateProduct(product);
                // 发送商品下架通知
                notificationService.sendOutOfStockNotification(product.getId());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="场景-3-定时发送促销活动通知"><a href="#场景-3-定时发送促销活动通知" class="headerlink" title="场景 3: 定时发送促销活动通知"></a>场景 3: <strong>定时发送促销活动通知</strong></h4><p>假设电商平台有一个促销活动，每个活动的开始和结束时间都由后台系统控制。需要在活动开始前 1 小时、活动结束时发送通知给用户。这些通知可以是短信、邮件或 APP 推送通知。</p>
<h5 id="解决的问题：-2"><a href="#解决的问题：-2" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>定时任务管理</strong>：XXL-Job 可以定时触发通知任务，确保用户在活动前后及时收到通知。</li>
<li><strong>高并发支持</strong>：在促销活动开始或结束时，平台可能会有大量的通知需要发送，XXL-Job 支持任务的并行处理，可以帮助我们高效地分发通知，避免性能瓶颈。</li>
<li><strong>任务状态监控</strong>：XXL-Job 提供任务的实时监控功能，平台可以随时查看任务的执行情况，确保通知任务按时执行。</li>
</ol>
<pre><code class="java">public class PromotionJob &#123;
    @JobHandler(&quot;promotionNotifyJobHandler&quot;)
    public void sendPromotionNotifications() &#123;
        // 获取当前正在进行的促销活动
        List&lt;Promotion&gt; activePromotions = promotionService.findActivePromotions();
        for (Promotion promotion : activePromotions) &#123;
            if (promotion.isStartingSoon()) &#123;
                notificationService.sendStartNotification(promotion);
            &#125; else if (promotion.isEndingSoon()) &#123;
                notificationService.sendEndNotification(promotion);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</blockquote>
<h6 id="xxl-job路由策略有哪些？"><a href="#xxl-job路由策略有哪些？" class="headerlink" title="xxl-job路由策略有哪些？"></a>xxl-job路由策略有哪些？</h6><p>实例找任务项执行任务 这种<strong>找机器的方式</strong>就是路由策略</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0ee1e805b34b443e5fed49434ec33e59c264894b/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5.png"></p>
<h3 id="消息中间件RabbitMQ-Kafka"><a href="#消息中间件RabbitMQ-Kafka" class="headerlink" title="消息中间件RabbitMQ+Kafka"></a>消息中间件<del>RabbitMQ+Kafka</del></h3><h6 id="消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦"><a href="#消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦" class="headerlink" title="消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦"></a>消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦</h6><p><strong>RabbitMQ</strong>：**<u>消息不丢失、消息重复消费、消息堆积、延迟队列、死信队列、高可用机制</u>**<br><strong>Kafka</strong>：**<u>消息不丢失、消息重复消费、高可用机制、高性能设计</u><del>吞吐量达到百万级</del>、<u>数据存储和清理</u>**</p>
<p><span style = "color:red"><strong>RabbitMQ-如何保证消息不丢失？</strong></span></p>
<blockquote>
<ul>
<li><p><u>开启<strong>生产者确认机制</strong>，确保生产者的消息能到达队列</u><br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
<blockquote>
<p>达到队列成功返回<code>ack</code>，失败返回<code>nack</code>【<u><strong>n</strong>egative <strong>ack</strong>nowledgment</u>】</p>
<ol>
<li>生产者发送消息到交换机。</li>
<li>交换机收到消息后，根据绑定规则（是否有匹配的队列）决定消息是否被正确路由。</li>
<li>如果消息成功路由到队列，交换机会向生产者返回 <code>ack</code> 确认。</li>
<li>如果消息没有成功路由到任何队列，交换机会通过 <code>return</code> 将消息退回给生产者。</li>
<li>生产者收到 <code>ack</code> 或 <code>nack</code>，可以处理消息确认或重试逻辑。</li>
</ol>
</blockquote>
</li>
<li><p><u>开启<strong>持久化功能</strong>，确保消息未消费前在队列中不会丢失</u><br>万一broker挂掉就惨了 保证至少成功一次消费<br>MQ是默认内存存储信息，开启持久化功能可以确保缓存在MQ中的消息不丢失[把数据存在磁盘上]</p>
</li>
<li><p><u>开启<strong>消费者确认机制</strong>为auto，由spring确认消息处理成功后完成ack</u><br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：**<u>消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息</u>**，而Spring AMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h5 id="x3D-x3D-生产者确认机制-x3D-x3D"><a href="#x3D-x3D-生产者确认机制-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;生产者确认机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;生产者确认机制&#x3D;&#x3D;</h5><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ad3b4f558db898d6e3a53744beb5512a958f9f57/MQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1.png"></p>
<p><span style = "color:red"><strong>RabbitMQ消息的重复消费问题如何解决的？</strong></span></p>
<blockquote>
<p>我们当时消费者是设置了自动确认机制，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息，这样就重复消费了<br><u>因为我们当时处理的支付（订单|业务唯一标识），它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。<strong>如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了</strong></u>。</p>
</blockquote>
<h6 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h6><ul>
<li>网络抖动</li>
<li>消费者挂了</li>
</ul>
<p>解决方案：<del>适用于任何MQ(Kafka，RabbitMQ，RocketMQ)</del></p>
<ul>
<li><strong>每条消息设置一个唯一的标识id</strong></li>
<li>幂等方案：【<strong>分布式锁</strong>、数据库锁(悲观锁、乐观锁)】</li>
</ul>
<p><span style = "color:red"><strong>RabbitMQ中死信交换机？(RabbitMQ延迟队列有了解过吗)</strong></span></p>
<p>如果用原来的定时任务 也可以但是 可能会有订单空窗期 如果没人消费的时候 它内部还是回去sql查询<strong>已下单</strong> +(now()-下单时间)?15min : true, false</p>
<blockquote>
<ul>
<li>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布）</li>
<li>其中<strong>延迟队列</strong>就用到了<strong>死信交换机</strong>和<strong>TTL</strong>（消息存活时间）实现的</li>
<li>消息超时未消费就会变成死信（死信的其他情况：<strong>拒绝被消费，队列满了</strong>）</li>
</ul>
<p>延迟队列插件实现延迟队列<code>DelayExchange</code></p>
<ul>
<li>声明一个交换机，添加delayed属性为true</li>
<li>发送消息时，添加<code>x-delay</code>头，值为超过时间</li>
</ul>
<pre><code class="java">什么样的消息会成为死信？
★ 消费者返回reject或者nack，且requeue参数设置为false【消息被拒绝并且不重入队列】
★ 消息超时未消费
★ 队列满了

如何给队列绑定死信交换机？
★ 给队列设置dead-letter-exchange属性，指定一个交换机
★ 给队列设置dead-letter-routing-key属性，设置死信交换机与死信队列的RoutingKey

------------------------------------------------------------------------
★ ★ ★ 使用 Spring AMQP 配置 ★ ★ ★ 
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig &#123;

    // 定义普通队列
    @Bean
    public Queue normalQueue() &#123;
        return new Queue(&quot;normalQueue&quot;, true, false, false, 
                Map.of(&quot;x-dead-letter-exchange&quot;, &quot;dlx_exchange&quot;, 
                       &quot;x-dead-letter-routing-key&quot;, &quot;dlx_routing_key&quot;));
    &#125;

    // 定义死信队列
    @Bean
    public Queue dlxQueue() &#123;
        return new Queue(&quot;dlxQueue&quot;, true);
    &#125;

    // 定义普通交换机
    @Bean
    public Exchange normalExchange() &#123;
        return new TopicExchange(&quot;normal_exchange&quot;);
    &#125;

    // 定义死信交换机
    @Bean
    public Exchange dlxExchange() &#123;
        return new TopicExchange(&quot;dlx_exchange&quot;);
    &#125;

    // 将普通队列与交换机绑定
    @Bean
    public Binding bindNormalQueue() &#123;
        return BindingBuilder.bind(normalQueue()).to(normalExchange()).with(&quot;normal.routing.key&quot;).noargs();
    &#125;

    // 将死信队列与死信交换机绑定
    @Bean
    public Binding bindDLXQueue() &#123;
        return BindingBuilder.bind(dlxQueue()).to(dlxExchange()).with(&quot;dlx_routing_key&quot;).noargs();
    &#125;
&#125;
------------------------------------------------------------------------
如果你希望将死信队列配置成带有过期时间或其他特殊属性的队列，可以在定义 dlxQueue 时增加更多的设置，例如 TTL（过期时间）。
例如，设置死信队列的 TTL：

@Bean
public Queue dlxQueue() &#123;
    return QueueBuilder.durable(&quot;dlxQueue&quot;)
            .withArgument(&quot;x-message-ttl&quot;, 60000) // 设置TTL为60秒
            .build();
&#125;
</code></pre>
</blockquote>
<h6 id="延迟队列-x3D-死信交换机-TTL-生存时间"><a href="#延迟队列-x3D-死信交换机-TTL-生存时间" class="headerlink" title="延迟队列 &#x3D; 死信交换机 + TTL (生存时间)"></a><span style = "color:blue">延迟队列 &#x3D; 死信交换机 + TTL (生存时间)</span></h6><ul>
<li><strong>延迟队列</strong>：进入队列的消息会被延迟消费的队列</li>
<li><strong>场景</strong>：超时订单、限时优惠，定时发布</li>
</ul>
<h6 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h6><p>当一个队列中的消息满足下列情况之一时，可以成为<strong>死信</strong>(dead letter)：</p>
<ul>
<li>消费者使用basic.reject 或 basic.nack声明消费失败，并且信息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果该队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>(Dead Letter Exchange，简称DLX)</p>
<pre><code class="java">@Bean
public QUeue ttlQueue()&#123;
    return QueueBuilder.durable(&quot;simple.queue&quot;) // 指定队列名称，并持久化
        .ttl(10000) // 设置队列的超时时间 10秒
        .deadLetterExchange(&quot;dl.direct&quot;) // 指定死信交换机
        .build();
&#125;
</code></pre>
<h6 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h6><p>TTL(Time-To-Live)。如果一个队列中的消息TTL结束仍未消费，则会变成死信，ttl超时分为两种情况：</p>
<ul>
<li><strong>消息所在的队列设置了存活时间</strong></li>
<li><strong>消息本身设置了存活时间</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/50eb7d1338c4fdae6ee9c65274b3116ac361514d/%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="死信图片"></p>
<p><span style = "color:red"><strong>RabbitMQ如果有100万消息堆积在MQ，如何解决(消息堆积怎么解决)？</strong><br></span></p>
<blockquote>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li><strong>增加更多消费者</strong>，提高消费速度</li>
<li>在消费者内<strong>开启线程池</strong>加快消息处理速度</li>
<li><strong>扩大队列容积</strong>，提高堆积上限<ul>
<li>在声明队列的时候可以设置<code>x-queue-model</code>为lazy，即为惰性队列</li>
<li>基于磁盘存储，消息上限高</li>
<li>性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低</li>
</ul>
</li>
</ul>
</blockquote>
<p>当<strong>生产者发送消息的速度超过了消费者处理消息的速度</strong>，就会导致队列中的<strong>消息堆积</strong>，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h6 id="达到上限发送的消息会变成死信，那我为什么不搞个死信交换机-而是用了上面的三种思路？？"><a href="#达到上限发送的消息会变成死信，那我为什么不搞个死信交换机-而是用了上面的三种思路？？" class="headerlink" title="达到上限发送的消息会变成死信，那我为什么不搞个死信交换机 而是用了上面的三种思路？？"></a>达到上限发送的消息会变成死信，那我为什么不搞个死信交换机 而是用了上面的三种思路？？</h6><blockquote>
<p>使用死信交换机（DLX, Dead Letter Exchange）是另一种处理消息堆积的方式，但它的作用更偏向于“消息过期”或“处理失败”的情况下将消息转发到另一个队列。并不直接解决生产者发送消息过快或消费者处理速度过慢的问题。通过死信交换机，你可以将无法处理的消息转发到其他队列，方便你后续进行分析或处理，但它并不能提高消费者处理消息的速度。</p>
<p>针对消息堆积的本质问题，解决方式更多的是优化消费者处理能力，而不是仅依赖死信交换机。具体而言，死信交换机和你的三种思路的关系如下：</p>
<ol>
<li><strong>死信交换机（DLX）</strong>：当消息达到队列上限或无法消费时，消息被转发到死信队列。你可以分析死信队列中的消息，了解原因，并决定是重试、丢弃还是进行其他处理。它的作用是<strong>不丢失消息</strong>，但并不能帮助消除堆积。</li>
<li><strong>增加消费者</strong>：这是直接针对堆积的根本解决方案，通过增加消费者数量来加速消息的处理。死信交换机无法直接解决消费者处理能力不足的问题。</li>
<li><strong>开启消费者线程池</strong>：在单个消费者上开启线程池，可以提高消费者的处理能力，减少堆积。死信交换机并不能增加消息处理速度，它只是用来应对消费失败的情况。</li>
<li><strong>扩大队列容量并使用惰性队列</strong>：惰性队列可以将消息存储在磁盘上，而非内存中，减轻内存压力，但这也会降低时效性，并不能解决生产者生产过快或消费者消费过慢的问题。死信交换机同样无法直接解决这一点。</li>
</ol>
<p>总结来说，死信交换机是处理消息丢失或无法消费的方式，它和通过增加消费者、线程池、队列优化这些手段并不冲突，但也无法替代这些更直接的解决方案。你可以结合这两者，使用死信交换机来保障消息不丢失，同时采取上述方法来提高消息消费速度。</p>
</blockquote>
<h6 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h6><p>惰性队列特征如下：</p>
<ul>
<li>接收到消息后直接存入磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<pre><code class="java">@Bean
public Queue lazyQueue()&#123;
    return QueueBuilder
            .durable(&quot;lazy.queue&quot;)
            .lazy()
            .build();
&#125;
</code></pre>
<pre><code class="java">@RabbitListener(queuesToDeclare = @Queue)&#123;
    name = &quot;lazy.queue&quot;,
    durable = &quot;true&quot;,
    arguments = @Argument(name = &quot;x-queue-mode&quot;), value=&quot;lazy&quot;
&#125;
public void listenLazyQUeue(String msg)&#123;
    log.info(&quot;接收到lazy.queue的消息：&#123;&#125;&quot;,msg);
&#125;
</code></pre>
<p><strong><span style = "color:red">RabbitMQ高可用机制有了解过吗？ &amp;&amp;  请描述 RabbitMQ 镜像队列的工作原理及其在高可用性场景下的优缺点<br></span></strong></p>
<blockquote>
<p>我们当时的项目在生产环境下，采用的是镜像模式搭建的集群，共有3个节点<br>镜像队列结构是一主多从(从就是镜像)，所有(写)操作都是主节点完成，然后同步给镜像节点<br>主宕机后，镜像节点会代替成为新的主(如果在主从同步完成前，主就已经宕机，可能出现数据丢失)</p>
</blockquote>
<p><span style = "color:red"><strong>那出现丢数据怎么解决呢？</strong><br></span></p>
<blockquote>
<p>我们可以采用<strong>仲裁队列</strong>，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致性，并且使用起来也非常简单，不需要格外的配置，<strong>在声明队列的时候只需要指定这个是仲裁队列即可</strong></p>
</blockquote>
<ul>
<li>在生产环境下，使用集群来保证高可用性</li>
<li>普通集群、<strong>镜像集群</strong>、仲裁队列</li>
</ul>
<h5 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h5><p>普通集群，或者叫标准集群(classic cluster)</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的信息</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<h5 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h5><p>镜像集群：本质是<strong>主从模式</strong>，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</li>
<li>创建队列的节点被称为该队列的<strong>主节点</strong>，备份到的其他节点叫做该队列的<strong>镜像</strong>节点</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/59b655f55c1f3031f72c5790425b8ae8e76e9d1f/%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4.png" style="zoom:150%;" />

<h5 id="仲裁队列：-quorum"><a href="#仲裁队列：-quorum" class="headerlink" title="仲裁队列：.quorum()"></a>仲裁队列：<del>.quorum()</del></h5><p>仲裁队列是<strong>3.8版本</strong>以后才有的新功能，用来替代镜像队列</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于<strong>Raft</strong>协议，强一致性</li>
</ul>
<p>仲裁队列的工作原理如下：</p>
<ol>
<li><strong>主从模式</strong>：仲裁队列也是主从模式，支持主从数据同步。</li>
<li><strong>Raft 协议</strong>：主从同步基于 Raft 协议，确保数据的一致性和可靠性。</li>
<li><strong>强一致性</strong>：所有写操作必须得到大多数节点的确认后才能完成，避免了数据丢失。</li>
</ol>
<p>仲裁队列通过以下机制保证数据不丢失：</p>
<ul>
<li><strong>多数派确认</strong>：<u>每次写操作需要得到大多数节点的确认，确保数据已经成功复制到多个节点</u>。</li>
<li><strong>自动故障转移</strong>：如果主节点宕机，<strong>Raft 协议</strong>会自动选举新的主节点，确保服务的连续性。</li>
<li><strong>数据一致性</strong>：<u>Raft 协议保证了数据的<strong>强一致性</strong></u>，即使在网络分区或节点宕机的情况下，也不会出现数据不一致的问题。</li>
</ul>
<p>仲裁队列的优点是配置简单、数据强一致，但需要至少 3 个节点，并且在写操作上的延迟和资源消耗可能会比镜像队列高。</p>
<pre><code class="java">@Bean
public Queue quorumQueue()&#123;
    return QueueBuilder
            .durable(&quot;quorum.queue&quot;) // 持久化
            .quorum() // 仲裁队列
            .build();
&#125;
</code></pre>
<p><span style = "color:red"><strong>Kafka是如何保证消息不丢失？</strong><br></span></p>
<blockquote>
<p>需要从三个层面去解决这个问题</p>
<ul>
<li><p>生产者发送消息到Brocker丢失</p>
<ul>
<li>设置异步发送，发送失败使用回调进行记录或重发</li>
<li>失败重试，参数配置，可以设置重试次数消息</li>
</ul>
</li>
<li><p>在Brocker中存储丢失</p>
<p>发送确认acks，选择all，让所有的副本都参与保存数据后确认</p>
</li>
<li><p>消费者从Brocker接收消息丢失</p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式：最好是<strong>同步+异步提交</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>使用Kafka在消息的收发过程中都会出现消息丢失，Kafka分别给出了解决方案</p>
<ul>
<li>生产者发送消息到Brocker丢失</li>
<li>消息在Brocker中存储丢失</li>
<li>消费者从Brocker接收消息丢失</li>
</ul>
</blockquote>
<p>kafka-高产出的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/ckafka?from_column=20065&from=20065">分布式消息系统</a>(A high-throughput distributed messaging system)。</p>
<p>Kafka是一个高吞吐、分布式、基于发布订阅的消息系统，利用Kafka技术可以在廉价的PC Server上搭建起大规模消息系统。</p>
<h5 id="Kafka的特性："><a href="#Kafka的特性：" class="headerlink" title="Kafka的特性："></a><strong>Kafka的特性：</strong></h5><ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作；</li>
<li>可扩展性：kafka集群支持热扩展；</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/backup?from_column=20065&from=20065">数据备份</a>防止数据丢失；</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）；</li>
<li>高并发：支持数千个客户端同时读写；</li>
<li>支持实时在线处理和离线处理：可以使用Storm这种实时流处理系统对消息进行实时进行处理，同时还可以使用Hadoop这种批处理系统进行离线处理；</li>
</ul>
<p>Kafka和其他组件比较，具有消息持久化、高吞吐、分布式、多客户端支持、实时等特性，适用于离线和在线的消息消费，如常规的消息收集、网站活性跟踪、聚合统计系统运营数据（监控数据）、日志收集等大量数据的互联网服务的数据收集场景。</p>
<ol>
<li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如Hadoop、Hbase、Solr等；</li>
<li>消息系统：解耦和生产者和消费者、缓存消息等；</li>
<li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到Hadoop、数据仓库中做离线分析和挖掘；</li>
<li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告；</li>
<li>流式处理：比如spark streaming和storm；</li>
<li>事件源；</li>
<li>kafka在FusionInsight中的位置：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/fcebf13cb4e2d12dc10727d9d5942720bbd114e6/Kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1.png"></p>
<p><span style = "color:red"><strong>Kafka是如何保证消费的顺序性？</strong><br></span></p>
<blockquote>
<p><strong>问题原因：</strong><br>一个topic的数据可能存储在不同的分区中 ，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p>
<p>&#x3D;&#x3D;<strong>解决方案：</strong>&#x3D;&#x3D;</p>
<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key</li>
</ul>
</blockquote>
<blockquote>
<p>应用场景：</p>
<ul>
<li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li>
<li>充值转账两个渠道在同一个时间进行金额变更，短信通知必须要有顺序</li>
</ul>
</blockquote>
<p>承接上图<code>消费者从Brocker接收消息丢失</code>：<br><strong>如何做</strong>？→ topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<pre><code class="java">// 指定分区
kafkaTemplate.sent(&quot;springboot-kafka-topic&quot;,0,&quot;key-001&quot;,&quot;value-001&quot;);
// 相同的业务key
kafkaTemplate.sent(&quot;springboot-kafka-topic&quot;,&quot;key-001&quot;,&quot;value-001&quot;);
</code></pre>
<p>会计算key的hashcode值推断出它在哪个分区，如果要求有顺序性 就可以设置同一个key，此时hash值都是一样的 就可以在同一个分区存储</p>
<p><span style = "color:red"><strong>Kafka的高可用机制有了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>集群模式</strong>&#x3D;&#x3D;</p>
<p>一个kafka集群由多个broker实例组成，即使某一台宕机，也不会耽误其他broker继续对外提供服务</p>
</li>
<li><p>&#x3D;&#x3D;<strong>分区备份机制</strong>&#x3D;&#x3D;</p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>解释一下复制机制中的ISR？</strong><br></span></p>
<blockquote>
<p>ISR (in-sync replica) 需要同步复制保存的follower<br>分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉后，会优先从ISR副本列表中选取一个作为leader</p>
</blockquote>
<pre><code class="java">// 一个topic默认分区的replication个数，不能大于集群中broker的个数。默认为1
default.replication.factor=3
// 最小的ISR副本个数
min.insync.replicas=2
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b273ced4f6ca9b43b9fb5279e651199e7ad52e9f/Kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6(%E9%9B%86%E7%BE%A4+%E5%88%86%E5%8C%BA%E5%A4%87%E4%BB%BD%E6%9C%BA%E5%88%B6).png"></p>
<p><span style = "color:red"><strong>Kafka数据清理机制了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li>kafka文件存储机制<ul>
<li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li>
<li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxx.log)的形式存储</li>
<li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理</li>
</ul>
</li>
<li>数据清理机制<ul>
<li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认168小时(7天)</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息(默认关闭)</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dbab52581ab3ed1350e8310825216f279c66d7f7/Kafka%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86.png"></p>
<p><span style = "color:red"><strong>Kafka中实现高性能的设计有了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li><span style = "color:blue">消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</span></li>
<li><span style = "color:blue">顺序读写：磁盘顺序读写，提升读写效率</span></li>
<li><span style = "color:blue">页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</span></li>
<li><span style = "color:blue">零拷贝：减少上下文切换及数据拷贝</span></li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：将消息打包批量发送，减少网络开销</li>
</ul>
</blockquote>
<h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/86a930ef22442fc6b9460ee88b64b21983cc9847/kafka%E9%9B%B6%E6%8B%B7%E8%B4%9D.png"></p>
<h2 id="集合面试篇"><a href="#集合面试篇" class="headerlink" title="集合面试篇"></a><span style = "color:red"><strong>集合面试篇</strong></span></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/9f0a0968283f4255bf0047d1761499c7b493ed97/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BBpng.png"></p>
<p><span style = "color:orange"><strong>算法复杂度分析</strong><br></span></p>
<blockquote>
<p>什么是算法时间复杂度？</p>
<ul>
<li>时间复杂度表示了算法的<strong>执行时间</strong>与<strong>数据规模</strong>之间的增长关系</li>
</ul>
<p>常见的时间复杂度有哪些？<del>口诀：常对幂指阶</del></p>
<ul>
<li>O(1)、O(n)、O(n^2)、O(logn)</li>
</ul>
<p>什么是算法的空间复杂度？</p>
<ul>
<li>表示算法占用的额外<code>存储空间</code>和<code>数据规模之间</code>的增长关系<br>常见的空间复杂度：O(1)、O(n)、O(n^2)</li>
</ul>
</blockquote>
<h6 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h6><ul>
<li>指导你编写出性能更优的代码</li>
<li>评判别人写的代码的好坏</li>
</ul>
<h6 id="时间复杂度分析：来评估代码的执行耗时的"><a href="#时间复杂度分析：来评估代码的执行耗时的" class="headerlink" title="时间复杂度分析：来评估代码的执行耗时的"></a>时间复杂度分析：来评估代码的执行耗时的</h6><ul>
<li><p>大O表示法：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong></p>
</li>
<li><p>只要代码的执行时间**<u>不随着n的增大而增大</u><strong>，这样的代码复杂度都是</strong>O(1)**</p>
</li>
<li><p>复杂度分析就是要弄清楚代码的<strong>执行次数</strong>和<strong>数据规模n</strong>之间的关系</p>
</li>
</ul>
<h6 id="时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系"><a href="#时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系" class="headerlink" title="时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系"></a>时间复杂度：全称是<code>渐进空间复杂度</code>，表示算法占用的额外<code>存储空间</code>和<code>数据规模之间</code>的增长关系</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/a0d4930dbc47574f03c8f4db7b995944fb4418e3/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png"></p>
<h3 id="List相关面试题"><a href="#List相关面试题" class="headerlink" title="List相关面试题"></a><span style = "color:red"><strong>List相关面试题</strong></span></h3><blockquote>
<ul>
<li><p>数组是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数组的线性数据结构</p>
</li>
<li><p>数组下标为什么从0开始</p>
<p>寻址公式是：<code>baseAddress + i * data TypeSize</code> 计算下标的内存地址效率较高</p>
</li>
<li><p>查找的时间复杂度</p>
<ul>
<li>随机(<strong>通过下标</strong>)查询的时间复杂度是O(1)</li>
<li>查找元素(<strong>未知下标</strong>)的时间复杂度是O(n)</li>
<li>查找元素(<strong>未知下标但排序</strong>)通过二分查找的时间复杂度是O(logn)</li>
</ul>
</li>
<li><p>插入和删除时间复杂度</p>
<p>插入和删除的时候，为了保证数组的内存连续性，需要挪动数组元素，平均复杂度为O(n)</p>
</li>
</ul>
</blockquote>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><ul>
<li>数据结构—数组</li>
<li>ArrayList源码分析</li>
</ul>
<h6 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h6><ul>
<li>ArrayList底层的实现原理是什么</li>
<li>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次</li>
<li>如何实现数组和List之间的转换</li>
<li>ArrayList和LinkedList的区别是什么</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9c400fc7d26d51223654eb4c997ae331fed38ac8/%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%B8%BA%E4%BB%80%E4%B9%880%E5%BC%80%E5%A7%8B.png"></p>
<p><span style = "color:red"><strong>ArrayList源码分析</strong></span></p>
<blockquote>
<p>List&lt; Integer &gt; list &#x3D; new ArrayList&lt; Integer &gt;();<br>list.add(1)</p>
</blockquote>
<pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;

    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 用于空实例的共享空数组实例
     */
    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;

    /**
     * 用于默认大小的空实例的共享空数组实例
     * 与上面的区分开，以了解添加第一个元素时要膨胀多少
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;
  
    /* 存储ArrayList元素的数组缓冲区，ArrayList的容量就是这个数组缓冲区的长度 */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList的大小(包含的元素数量)
     * @serial
     */
    private int size;
...
&#125;

--------------------------------------------------------------------------------

public ArrayList(int initialCapacity) &#123;
        if (initialCapacity &gt; 0) &#123;
       // 创建一个真正存储集合位置的数组
            this.elementData = new Object[initialCapacity];
        &#125; else if (initialCapacity == 0) &#123;
    // 如果容量是0则创建一个新的数组给elementData
            this.elementData = EMPTY_ELEMENTDATA;
        &#125; else &#123;
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        &#125;
    &#125;
    public ArrayList() &#123; 
         // 无参构造函数，默认创建空集合
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    &#125;

-------------------------------------------------------------------------------
// Collection是所有单列集合的父接口
// 将 Collection 对象转换成数组，然后将数组的地址赋给 elementData
 public ArrayList(Collection&lt;? extends E&gt; c) &#123;
        elementData = c.toArray();
        if ((size = elementData.length) != 0) &#123;
            // 判断集合类型是否为不为object[] 
            // 在其他jdk此处是 ?? == ArrayList.class
            if (elementData.getClass() != Object[].class)
                // 不是的话就拷贝到数组elementData中
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        &#125; else &#123;
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        &#125;
    &#125;
</code></pre>
<h6 id="ArrayList源码分析-添加和扩容操作-第1次添加数据"><a href="#ArrayList源码分析-添加和扩容操作-第1次添加数据" class="headerlink" title="ArrayList源码分析-添加和扩容操作(第1次添加数据)"></a>ArrayList源码分析-添加和扩容操作(第1次添加数据)</h6><img src="https://raw.githubusercontent.com/P-luminary/images/94991acfd36ad12ca17dfd7578011cfeffe34022/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.png" style="zoom: 67%;" />



<p><span style = "color:red"><strong>ArrayList底层的实现原理是什么</strong></span></p>
<ul>
<li>ArrayList底层是用<strong>动态数组</strong>实现的</li>
<li>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</li>
<li>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</li>
<li>ArrayList在添加数据的时候<ul>
<li>确保数组已使用长度(size)加1之后足够存下下一个数据</li>
<li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用<code>grow</code>方法扩容<del>(原来的1.5倍)</del></li>
<li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上</li>
<li>返回添加成功布尔值</li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次</strong></span></p>
<ul>
<li>该语句只是声明和实例了一个<code>ArrayList</code>，指定了容量为10，未扩容</li>
</ul>
<p><span style = "color:red"><strong>如何实现数组和List之间的转换</strong></span></p>
<ul>
<li>数组转List，使用JDK中<code>java.util.Arrays</code>工具类的<code>asList</code>方法</li>
<li>List转数组，使用List的<code>toArray</code>方法，无参toArray方法返回Object数组，传入初始化长度的数组对象，返回该对象数组</li>
</ul>
<blockquote>
<p>使用 Hutool 工具库可以非常方便地实现数组和 <code>List</code> 之间的转换。Hutool 提供了 <code>ArrayUtil</code> 和 <code>CollUtil</code> 工具类来处理数组和集合之间的转换。</p>
<p>问：我不能用BeanUtil吗？<br>答：<code>BeanUtil</code> 是 Hutool 工具库中用于 <strong>Java Bean 操作</strong>的工具类，主要用于 <strong>对象属性拷贝</strong>、<strong>Bean 转 Map</strong>、<strong>Map 转 Bean</strong> 等操作。它并不适用于 <strong>数组和 List 之间的转换</strong>。</p>
<p>如果你误以为 <code>BeanUtil</code> 可以用于数组和 List 的转换，可能是因为它的名字容易让人误解。实际上，数组和 List 的转换应该使用 <code>ArrayUtil</code> 或 <code>CollUtil</code>。</p>
<h3 id="正确的工具类选择"><a href="#正确的工具类选择" class="headerlink" title="正确的工具类选择"></a>正确的工具类选择</h3><ol>
<li><strong>数组转 List</strong>：使用 <code>ArrayUtil.toList</code>。</li>
<li><strong>List 转数组</strong>：使用 <code>CollUtil.toArray</code>。</li>
<li><strong>Bean 属性拷贝</strong>：使用 <code>BeanUtil.copyProperties</code>。</li>
<li><strong>Bean 转 Map</strong>：使用 <code>BeanUtil.beanToMap</code>。</li>
<li><strong>Map 转 Bean</strong>：使用 <code>BeanUtil.fillBeanWithMap</code>。</li>
</ol>
<h6 id="更多的Hutool工具使用高能预警"><a href="#更多的Hutool工具使用高能预警" class="headerlink" title="更多的Hutool工具使用高能预警"></a>更多的Hutool工具使用<del>高能预警</del></h6><h5 id="1-字符串工具类：StrUtil"><a href="#1-字符串工具类：StrUtil" class="headerlink" title="1. 字符串工具类：StrUtil"></a>1. <strong>字符串工具类：<code>StrUtil</code></strong></h5><ul>
<li><strong>功能</strong>：字符串操作，如判空、格式化、截取、替换等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>StrUtil.isEmpty()</code>：判断字符串是否为空。</li>
<li><code>StrUtil.format()</code>：格式化字符串。</li>
<li><code>StrUtil.split()</code>：拆分字符串。</li>
<li><code>StrUtil.join()</code>：连接字符串。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-日期时间工具类：DateUtil"><a href="#2-日期时间工具类：DateUtil" class="headerlink" title="2. 日期时间工具类：DateUtil"></a>2. <strong>日期时间工具类：<code>DateUtil</code></strong></h5><ul>
<li><strong>功能</strong>：日期和时间的格式化、解析、计算等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>DateUtil.now()</code>：获取当前时间。</li>
<li><code>DateUtil.format()</code>：格式化日期。</li>
<li><code>DateUtil.parse()</code>：解析字符串为日期。</li>
<li><code>DateUtil.offsetDay()</code>：日期加减。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-文件工具类：FileUtil"><a href="#3-文件工具类：FileUtil" class="headerlink" title="3. 文件工具类：FileUtil"></a>3. <strong>文件工具类：<code>FileUtil</code></strong></h5><ul>
<li><strong>功能</strong>：文件和目录的操作，如读写、复制、删除等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>FileUtil.readUtf8String()</code>：读取文件内容为字符串。</li>
<li><code>FileUtil.writeUtf8String()</code>：将字符串写入文件。</li>
<li><code>FileUtil.copy()</code>：复制文件或目录。</li>
<li><code>FileUtil.del()</code>：删除文件或目录。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-JSON-工具类：JSONUtil"><a href="#4-JSON-工具类：JSONUtil" class="headerlink" title="4. JSON 工具类：JSONUtil"></a>4. <strong>JSON 工具类：<code>JSONUtil</code></strong></h5><ul>
<li><strong>功能</strong>：JSON 的解析和生成。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>JSONUtil.parseObj()</code>：将 JSON 字符串解析为 JSON 对象。</li>
<li><code>JSONUtil.parseArray()</code>：将 JSON 字符串解析为 JSON 数组。</li>
<li><code>JSONUtil.toJsonStr()</code>：将对象转换为 JSON 字符串。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-集合工具类：CollUtil"><a href="#5-集合工具类：CollUtil" class="headerlink" title="5. 集合工具类：CollUtil"></a>5. <strong>集合工具类：<code>CollUtil</code></strong></h5><ul>
<li><strong>功能</strong>：集合操作，如创建集合、判空、过滤、分组等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>CollUtil.newArrayList()</code>：快速创建 ArrayList。</li>
<li><code>CollUtil.isEmpty()</code>：判断集合是否为空。</li>
<li><code>CollUtil.filter()</code>：过滤集合。</li>
<li><code>CollUtil.group()</code>：对集合进行分组。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-反射工具类：ReflectUtil"><a href="#6-反射工具类：ReflectUtil" class="headerlink" title="6. 反射工具类：ReflectUtil"></a>6. <strong>反射工具类：<code>ReflectUtil</code></strong></h5><ul>
<li><strong>功能</strong>：反射操作，如调用方法、获取字段、创建对象等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ReflectUtil.invoke()</code>：调用方法。</li>
<li><code>ReflectUtil.getFieldValue()</code>：获取字段值。</li>
<li><code>ReflectUtil.newInstance()</code>：创建对象实例。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-HTTP-工具类：HttpUtil"><a href="#7-HTTP-工具类：HttpUtil" class="headerlink" title="7. HTTP 工具类：HttpUtil"></a>7. <strong>HTTP 工具类：<code>HttpUtil</code></strong></h5><ul>
<li><strong>功能</strong>：HTTP 请求的发送和响应处理。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>HttpUtil.get()</code>：发送 GET 请求。</li>
<li><code>HttpUtil.post()</code>：发送 POST 请求。</li>
<li><code>HttpUtil.downloadFile()</code>：下载文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-加密解密工具类：SecureUtil"><a href="#8-加密解密工具类：SecureUtil" class="headerlink" title="8. 加密解密工具类：SecureUtil"></a>8. <strong>加密解密工具类：<code>SecureUtil</code></strong></h5><ul>
<li><strong>功能</strong>：常见的加密解密操作，如 MD5、SHA、AES 等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>SecureUtil.md5()</code>：计算 MD5 值。</li>
<li><code>SecureUtil.sha256()</code>：计算 SHA-256 值。</li>
<li><code>SecureUtil.aes()</code>：AES 加密解密。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="9-IO-工具类：IoUtil"><a href="#9-IO-工具类：IoUtil" class="headerlink" title="9. IO 工具类：IoUtil"></a>9. <strong>IO 工具类：<code>IoUtil</code></strong></h5><ul>
<li><strong>功能</strong>：IO 流操作，如读写、关闭流等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>IoUtil.read()</code>：读取流内容。</li>
<li><code>IoUtil.write()</code>：写入流内容。</li>
<li><code>IoUtil.close()</code>：关闭流。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="10-随机工具类：RandomUtil"><a href="#10-随机工具类：RandomUtil" class="headerlink" title="10. 随机工具类：RandomUtil"></a>10. <strong>随机工具类：<code>RandomUtil</code></strong></h5><ul>
<li><strong>功能</strong>：生成随机数、随机字符串等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>RandomUtil.randomInt()</code>：生成随机整数。</li>
<li><code>RandomUtil.randomString()</code>：生成随机字符串。</li>
<li><code>RandomUtil.randomEle()</code>：从集合中随机选择一个元素。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="11-验证工具类：Validator"><a href="#11-验证工具类：Validator" class="headerlink" title="11. 验证工具类：Validator"></a>11. <strong>验证工具类：<code>Validator</code></strong></h5><ul>
<li><strong>功能</strong>：数据验证，如邮箱、手机号、身份证等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>Validator.isEmail()</code>：验证是否为邮箱。</li>
<li><code>Validator.isMobile()</code>：验证是否为手机号。</li>
<li><code>Validator.isCitizenId()</code>：验证是否为身份证号。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="12-缓存工具类：CacheUtil"><a href="#12-缓存工具类：CacheUtil" class="headerlink" title="12. 缓存工具类：CacheUtil"></a>12. <strong>缓存工具类：<code>CacheUtil</code></strong></h5><ul>
<li><strong>功能</strong>：简单的缓存操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>CacheUtil.newTimedCache()</code>：创建定时缓存。</li>
<li><code>CacheUtil.put()</code>：添加缓存。</li>
<li><code>CacheUtil.get()</code>：获取缓存。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="13-线程工具类：ThreadUtil"><a href="#13-线程工具类：ThreadUtil" class="headerlink" title="13. 线程工具类：ThreadUtil"></a>13. <strong>线程工具类：<code>ThreadUtil</code></strong></h5><ul>
<li><strong>功能</strong>：线程操作，如睡眠、创建线程池等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ThreadUtil.sleep()</code>：线程睡眠。</li>
<li><code>ThreadUtil.newExecutor()</code>：创建线程池。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="14-Excel-工具类：ExcelUtil"><a href="#14-Excel-工具类：ExcelUtil" class="headerlink" title="14. Excel 工具类：ExcelUtil"></a>14. <strong>Excel 工具类：<code>ExcelUtil</code></strong></h5><ul>
<li><strong>功能</strong>：Excel 文件的读写操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ExcelUtil.getReader()</code>：读取 Excel 文件。</li>
<li><code>ExcelUtil.getWriter()</code>：写入 Excel 文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="15-压缩工具类：ZipUtil"><a href="#15-压缩工具类：ZipUtil" class="headerlink" title="15. 压缩工具类：ZipUtil"></a>15. <strong>压缩工具类：<code>ZipUtil</code></strong></h5><ul>
<li><strong>功能</strong>：文件或目录的压缩和解压缩。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ZipUtil.zip()</code>：压缩文件或目录。</li>
<li><code>ZipUtil.unzip()</code>：解压缩文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="16-日志工具类：Log"><a href="#16-日志工具类：Log" class="headerlink" title="16. 日志工具类：Log"></a>16. <strong>日志工具类：<code>Log</code></strong></h5><ul>
<li><strong>功能</strong>：简化日志操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>Log.get()</code>：获取日志对象。</li>
<li><code>Log.info()</code>：输出日志信息。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="17-数学工具类：MathUtil"><a href="#17-数学工具类：MathUtil" class="headerlink" title="17. 数学工具类：MathUtil"></a>17. <strong>数学工具类：<code>MathUtil</code></strong></h5><ul>
<li><strong>功能</strong>：数学计算，如四舍五入、最大值、最小值等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>MathUtil.round()</code>：四舍五入。</li>
<li><code>MathUtil.max()</code>：获取最大值。</li>
<li><code>MathUtil.min()</code>：获取最小值。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="18-网络工具类：NetUtil"><a href="#18-网络工具类：NetUtil" class="headerlink" title="18. 网络工具类：NetUtil"></a>18. <strong>网络工具类：<code>NetUtil</code></strong></h5><ul>
<li><strong>功能</strong>：网络相关操作，如获取本机 IP、Ping 等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>NetUtil.getLocalhost()</code>：获取本机 IP。</li>
<li><code>NetUtil.ping()</code>：Ping 测试。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>用<code>Arrays.asList</code>转List后，如果修改了数组内容，list受影响吗</li>
<li>List用<code>toArray</code>转数组后，如果修改了List内容，数组受影响吗</li>
</ul>
<h6 id="再答："><a href="#再答：" class="headerlink" title="再答："></a>再答：</h6><ul>
<li>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</li>
<li>list用了toArray转数组后，如果修改了list内容，数组不会受影响，当调用了toArray以后，在底层是它进行了数组拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2a0e6fcd9e82104de79aeb269b64bee2fe250a37/%E6%95%B0%E7%BB%84%E5%92%8Clist%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p>
<p><span style = "color:red"><strong>LinkedList的数据结构—链表</strong></span></p>
<p><strong>单向链表</strong></p>
<ul>
<li>链表中的每一个元素称之为结点(Node)</li>
<li>物理存储单元上，非连续、非顺序的存储结构</li>
<li>单向链表：每个结点包括两个部分:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针 next</li>
</ul>
<h6 id="1-单向链表和双向链表的区别是什么"><a href="#1-单向链表和双向链表的区别是什么" class="headerlink" title="1.单向链表和双向链表的区别是什么"></a>1.单向链表和双向链表的区别是什么</h6><ul>
<li>单向链表只有一个方向，结点只有一个后继指针 next。</li>
<li>双向链表它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点</li>
</ul>
<h6 id="2-链表操作数据的时间复杂度是多少"><a href="#2-链表操作数据的时间复杂度是多少" class="headerlink" title="2.链表操作数据的时间复杂度是多少"></a>2.链表操作数据的时间复杂度是多少</h6><table>
<thead>
<tr>
<th></th>
<th>查询</th>
<th>新增删除</th>
</tr>
</thead>
<tbody><tr>
<td>单向链表</td>
<td>头O(1), 其他O(n)</td>
<td>头O(1), 其他O(n)</td>
</tr>
<tr>
<td>双向链表</td>
<td>头尾O(1), 其他O(n), 给定节点O(1)</td>
<td>头尾O(1), 其他O(n), 给定节点O(1)</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/89cd60c5af783394daee166cbfce512c0b796d0f/LinkedList%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E9%93%BE%E8%A1%A8.png"></p>
<p><span style = "color:red"><strong>ArrayList和LinkedList的区别</strong></span></p>
<ul>
<li><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a><span style = "color:blue">底层数据结构</span></h5><ul>
<li>ArrayList 是<strong>动态数组</strong>的数据结构实现</li>
<li>LinkedList 是<strong>双向链表</strong>的数据结构实现</li>
</ul>
</li>
<li><p><strong>操作数组效率</strong></p>
<ul>
<li><p>ArrayList  按照下标查询的时间复杂度O(1);【内存是连续的，根据寻址公式】，LinkedList不支持下标查询</p>
</li>
<li><p>查找(未知索引)：ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)</p>
</li>
<li><p><strong>新增</strong>和<strong>删除</strong></p>
<ul>
<li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li>
<li>LinkedList 头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内存空间占用</strong></p>
<ul>
<li>ArrayList 底层是数组，内存连续，节省内存</li>
<li>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</li>
</ul>
</li>
<li><p><strong>线程安全</strong></p>
<ul>
<li><p>ArrayList和LinkedList都不是线程安全的</p>
</li>
<li><p>如果要保证线程安全，有两种方法</p>
<ul>
<li><p>在方法内使用，局部变量则是线程安全的</p>
</li>
<li><p>使用线程安全的ArrayList和LinkedList</p>
<pre><code class="java">List&lt;Object&gt; syncArrayList = Collections.synchronizedList(new ArrayList&lt;&gt;());
List&lt;Object&gt; syncLinkedList = Collections.synchronizedList(new LinkedList&lt;&gt;());
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HashMap相关面试题"><a href="#HashMap相关面试题" class="headerlink" title="HashMap相关面试题"></a><span style = "color:red"><strong>HashMap相关面试题</strong></span></h3><ul>
<li><p><strong>二叉树</strong></p>
<ul>
<li><p>满二叉树</p>
</li>
<li><p>完全二叉树</p>
</li>
<li><p><strong>二叉搜索树</strong></p>
<p>二叉搜索树又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p>
</li>
<li><p><strong>红黑树</strong></p>
</li>
</ul>
</li>
<li><p><strong>红黑树</strong></p>
</li>
<li><p><strong>散列表</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/678118180d1bda0ac019f934c04c3db01eff5cf8/%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p>
<p><span style = "color:red"><strong>数据结构—红黑树 什么是红黑树？</strong></span></p>
<ul>
<li>红黑树：也是一种自平衡的二叉搜索树(BST)</li>
<li>所有的红黑规则都是希望红黑树能够保证平衡</li>
<li>红黑树的时间复杂度：查找、添加、删除都是O(logn)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d52e3005e6dbb2c546a407bdb237c51cbdab9694/%E7%BA%A2%E9%BB%91%E6%A0%91.png"></p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><span style = "color:red"><strong>散列表</strong></span></h4><p><span style = "color:red"><strong>什么是散列表？</strong></span></p>
<blockquote>
<ul>
<li>散列表(Hash Table)又叫哈希表&#x2F;Hash表</li>
<li>根据键(Key)直接访问再内存存储位置值(Value)的数据结构</li>
<li>由数组演化而来的，利用了数组支持按照下标进行随机访问数据</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>散列冲突</strong></span></p>
<blockquote>
<ul>
<li>散列冲突又成为哈希冲突，哈希碰撞</li>
<li>指多个key映射到同一个数组下标位置</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>散列冲突—链表法(拉链)</strong></span></p>
<blockquote>
<ul>
<li>数组的每个下标位置称之为<strong>桶</strong>(bucket) 或者 <strong>槽</strong>(slot)</li>
<li>每个桶(槽)会对应一条链表</li>
<li>hash冲突后的元素都放到相同槽位对应的链表中或红黑树中</li>
</ul>
</blockquote>
<p>在<strong>HashMap</strong>中的最重要的一个数据结构就是散列表，在散列表中又用到了<strong>红黑树</strong>和<strong>链表</strong><br>散列表(Hash Table)又名为<strong>哈希表</strong>&#x2F;Hash表，是<strong>根据键(Key)直接访问</strong>在内存存储位置<strong>值(value)<strong>的数据结构，它是</strong>由数组演化而来的</strong>，利用了数组支持按照下标进行随机访问数据的特性<del>[根据寻址公式,时间复杂度O(1)]</del></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6dd0e10d2aaa9a064fde0c973b9d942ae149d17c/%E6%95%A3%E5%88%97%E8%A1%A8.png"></p>
<h4 id="说一下HashMap的实现原理"><a href="#说一下HashMap的实现原理" class="headerlink" title="说一下HashMap的实现原理"></a><span style = "color:red"><strong>说一下HashMap的实现原理</strong></span></h4><blockquote>
<p>1.说一下HashMap的实现原理</p>
<ul>
<li><p>HashMap的数据结构：底层使用hash表数据结构，即数组和链表或红黑树</p>
</li>
<li><p>添加数据时，计算key的值确定元素在数组中的下标</p>
<ul>
<li>key相同则替换</li>
<li>不同则存入链表或红黑树中</li>
</ul>
<p>获取数据通过key的hash计算数组下标获取元素</p>
</li>
</ul>
<p>2.HashMap的jdk1.7和jdk1.8有什么区别</p>
<ul>
<li>JDK1.8之前采用的拉链法，数组+链表</li>
<li>JDK1.8之后采用数组+链表+红黑树<br>链表长度大于8且数组长度大于64则会从链表转化为红黑树</li>
</ul>
</blockquote>
<p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算</p>
<p>出当前对象的元素在数组中的下标</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/27826dde4b711105a212f30f6381f8097eca69ba/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<h4 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a><span style = "color:red"><strong>HashMap的put方法的具体流程</strong></span></h4><blockquote>
<p>1.判断键值对数组table是否为空或为null，否则执行resize()进行扩容 [初始化]<br>2.根据键值key计算hash值得到数组索引<br>3.判断table[i] &#x3D;&#x3D; null，条件成立，直接新建节点添加<br>4.如果table[i] &#x3D;&#x3D; null，不成立<br>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value<br>4.2 判断table[i]是否为<strong>treeNode</strong>，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对<br>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d2fa5788e2f2f5c7e75e724c8bef242b6661c10c/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>讲一下HashMap的扩容机制</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c4e2b5bca4f89ece679358c70cdb042f8028aa81/HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6.png"></p>
<p><span style = "color:red"><strong>HashMap源码分析</strong></span></p>
<p>桶下标是hash值取模数组(长度)下标 capacity</p>
<p><span style = "color:red"><strong>HashMap的寻址算法</strong></span></p>
<p>Hash值右移16位后与原来的hash值进行异或运算【扰动算法<del>hash值更加均匀,减少hash冲突</del>】<br>数组长度必须是2的n次幂 按位<strong>与运算</strong>的效果才能代替取模</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/85bdc4d076df91ec3d29294926d65f55713b2d26/HashMap%E5%AF%BB%E5%9D%80%E7%AE%97w%E6%B3%95.png"></p>
<p><span style = "color:red"><strong>HashMap在1.7情况下的多线程死循环问题</strong></span></p>
<p>jdk7的数据结构是：数组+链表<br>在数组进行扩容的时候，因为链表是<strong>头插法</strong>，在进行数据迁移的过程中，有可能导致死循环</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1be6d73360d8cdf5baa6b2fea0b1fc8fa8b7fadc/HashMap%E5%9C%A81.7%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98.png"></p>
<h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a><span style = "color:red">进程和线程的区别？</span></h4><blockquote>
<h6 id="两者对比："><a href="#两者对比：" class="headerlink" title="两者对比："></a>两者对比：</h6><ul>
<li>进程是整个在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ul>
</blockquote>
<p>程序由<strong>指令</strong>和<strong>数据</strong>组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备，<strong>进程</strong>就是用来加载指令、管理内存、管理IO的。<br>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个**<u>进程</u>**</p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。一个进程之内可以分为一到多个线程</p>
<blockquote>
<p>core → 线程1[指令1，指令2，指令3…]   线程2[指令1，指令2，指令3…] </p>
</blockquote>
<h4 id="并行和并发的区别？"><a href="#并行和并发的区别？" class="headerlink" title="并行和并发的区别？"></a><span style = "color:red">并行和并发的区别？</span></h4><blockquote>
<p>现在都是多核CPU，在多核CPU下</p>
<ul>
<li>并发是<strong>同一时间</strong>应对多件事情的能力，多个线程<strong>轮流使用</strong>一个或多个CPU</li>
<li>并行是<strong>同一时间</strong>动手做多件事的能力，4核CPU<strong>同时执行</strong>4个线程</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;<strong>单核CPU</strong>&#x3D;&#x3D; → 单核CPU下线程实际还是串行执行的</p>
<ul>
<li>操作系统中有一个组件叫做任务调度器，将cpu的时间片(windows下时间片最小约为15ms)分给不同的程序使用，只是由于cpu在线程间(时间片很短)的切换非常快，人类感觉是同时运行的</li>
<li>每个时间片只能用有一个线程被执行</li>
<li>总结一句话：**<u>微观串行，宏观并行</u>**</li>
<li>一般会将这种线程轮流使用CPU的做法称为并发(concurrent)</li>
</ul>
<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片1</th>
<th>时间片2</th>
<th>时间片3</th>
</tr>
</thead>
<tbody><tr>
<td>core</td>
<td>线程1</td>
<td>线程2</td>
<td>线程3</td>
</tr>
</tbody></table>
<p><strong>&#x3D;&#x3D;多核CPU&#x3D;&#x3D;</strong> → 每个核(core)都可以调度运行线程，这个时候线程是可以并行的</p>
<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片1</th>
<th>时间片2</th>
<th>时间片3</th>
<th>时间片4</th>
</tr>
</thead>
<tbody><tr>
<td>core1</td>
<td>线程1</td>
<td>线程2</td>
<td>线程3</td>
<td>线程3</td>
</tr>
<tr>
<td>core2</td>
<td>线程2</td>
<td>线程4</td>
<td>线程2</td>
<td>线程4</td>
</tr>
</tbody></table>
<blockquote>
<p>并发 (concurrent) 是同一时间<strong>应对</strong> (dealing with) 多件事情的能力<br>并行 (parallel) 是同一时间<strong>动手做</strong> (doing) 多件事情的能力</p>
<ul>
<li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这么多件事，这就是<strong>并发</strong>【单核CPU】</li>
<li>家庭主妇雇了个保姆，她们一起做这些事，这时既有并发，也有并行【会产生竞争，例如锅只有一个，一个人用锅时，另一个人就要等待】</li>
<li>雇了3个保姆，一个专门做饭，一个专门打扫卫生，一个专门喂奶，互不干扰，这就是<strong>并行</strong></li>
</ul>
</blockquote>
<h4 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a><span style = "color:red">创建线程的方式有哪些？</span></h4><ul>
<li><h5 id="继承Thread类，重写run方法"><a href="#继承Thread类，重写run方法" class="headerlink" title="继承Thread类，重写run方法"></a>继承Thread类，重写run方法</h5></li>
</ul>
<pre><code class="java">public class MyThread extends Thread&#123;
    @Override
    public void run()&#123;
        sout(&quot;MyThread...run...&quot;);
    &#125;
    public static void main(String[] args)&#123;
        // 创建MyThread对象
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        
        // 调用start方法启动线程
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Runnable接口，重写run方法"><a href="#实现Runnable接口，重写run方法" class="headerlink" title="实现Runnable接口，重写run方法"></a>实现Runnable接口，重写run方法</h5></li>
</ul>
<pre><code class="java">public class MyRunnable implements Runnable &#123;

    @Override
    public void run() &#123;
        // 在这里编写要执行的任务
        System.out.println(&quot;线程正在执行任务...&quot;);
    &#125;
    public static void main(String[] args) &#123;
        // 创建MyRunnable实例
        MyRunnable myRunnable = new MyRunnable();
        
        // 创建线程并启动
        Thread t1 = new Thread(myRunnable);
        Thread t2 = new Thread(myRunnable);
        // 调用start方法启动线程
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Callable-lt-T-gt-接口，重写call方法泛型和重写方法一致"><a href="#实现Callable-lt-T-gt-接口，重写call方法泛型和重写方法一致" class="headerlink" title="实现Callable&lt; T &gt;接口，重写call方法泛型和重写方法一致"></a>实现Callable&lt; T &gt;接口，重写call方法<del>泛型和重写方法一致</del></h5></li>
</ul>
<pre><code class="java">public class MyCallable implements Callable&lt;String&gt; &#123;
 @Override
    public String call() throws Exception &#123;
        sout(Thread.currentThread().getName());
        return &quot;ok&quot;;
    &#125;
     public static void main(String[] args) &#123;
        // 创建MyCallable实例
        MyCallable myCallable = new MyCallable();
        
        // 使用FutureTask来包装Callable对象
        FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;(myCallable);
        
        // 创建并启动线程
        Thread t1 = new Thread(ft);
        t1.start();
        // 调用ft的get方法获取执行结果
        String result = ft.get();
        sout(result)
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="线程池创建线程-项目中使用的方式"><a href="#线程池创建线程-项目中使用的方式" class="headerlink" title="线程池创建线程 (项目中使用的方式)"></a><span style = "color:blue">线程池创建线程 (项目中使用的方式)</span></h5></li>
</ul>
<pre><code class="java">public class MyExecutors implements Runnable&#123;
    @Override
    public void run()&#123;
        sout(&quot;MyRunnable...run...&quot;);
    &#125;
    public static void main(String[] args)&#123;
        // 创建线程池对象
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        threadPool.submit(new MyExecutors()); 
        //submit用来提交线程
        
        // 关闭线程池
        threadPool.shutdown();
    &#125;
&#125;
</code></pre>
<h6 id="刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？"><a href="#刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？" class="headerlink" title="刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？"></a><span style = "color:red">刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？</span></h6><blockquote>
<ul>
<li>Runnable接口run方法<strong>没有返回值</strong></li>
<li><strong>Callable</strong>接口call方法<strong>有返回值</strong>，要结合FutureTask配合可以用来获取异步执行的结果</li>
</ul>
<blockquote>
<p><strong><code>FutureTask</code></strong> 是 <strong><code>Future</code></strong> 的实现类，它可以包装一个 <code>Callable</code> 或 <code>Runnable</code> 对象，并允许我们在任务执行完毕后获取执行结果或取消任务。</p>
<p><strong><code>FutureTask</code></strong> 可以在子线程中异步执行任务，而主线程可以通过调用 <code>FutureTask.get()</code> 方法获取任务执行的结果。</p>
</blockquote>
<ul>
<li>Callable接口的call()方法<strong>允许抛出异常</strong>；而Runnabble接口的run()方法的异常只能在<strong>内部消化</strong>，不能继续上抛</li>
</ul>
<pre><code class="java">import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class CallableExample &#123;

    public static void main(String[] args) throws Exception &#123;
        // 创建一个Callable任务
        Callable&lt;Integer&gt; task = new Callable&lt;Integer&gt;() &#123;
            @Override
            public Integer call() throws Exception &#123;
                System.out.println(&quot;Task is running in the background...&quot;);
                // 模拟耗时操作
                Thread.sleep(2000);
                return 42; // 返回计算结果
            &#125;
        &#125;;

        // 创建FutureTask对象，包装Callable任务
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task);

        // 启动线程执行FutureTask
        Thread thread = new Thread(futureTask);
        thread.start();

        // 主线程可以做一些其他工作
        System.out.println(&quot;Main thread is doing something else...&quot;);

        // 获取异步执行结果，阻塞直到任务完成
        Integer result = futureTask.get(); // 这会阻塞主线程直到获取到结果
        System.out.println(&quot;Task result: &quot; + result); // 打印任务执行结果
    &#125;
&#125;
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>在启动线程的时候，可以使用run方法吗？run()和start()有什么区别？</strong></span></p>
<p>start()是开启一个线程   run()跟开启普通方法一样</p>
<blockquote>
<p><strong>start()：</strong>用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。<strong>start方法只能被调用一次</strong><br><strong>run()：</strong>封装了要被线程执行的代码，<strong>可以被调用多次</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/807ae461bb166b0aa6a755a66e43d57c0166323c/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9.png"></p>
<h4 id="线程包括哪些状态，状态之间是如何变化的？"><a href="#线程包括哪些状态，状态之间是如何变化的？" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的？"></a><span style = "color:red"><strong>线程包括哪些状态，状态之间是如何变化的？</strong></span></h4><blockquote>
<p>状态：<br><strong>新建</strong>New、<strong>可运行</strong>Runnable、<strong>阻塞</strong>Blocked、<strong>等待</strong>Waiting、<strong>时间等待</strong>Timed_waiting、<strong>终止</strong>Terminated</p>
<p>线程状态之间如何变化：</p>
<ul>
<li>创建线程对象是<strong>新建状态</strong></li>
<li>调用了start()方法转变为<strong>可执行状态</strong></li>
<li>线程获取到了CPU的执行权，执行结束是<strong>终止状态</strong></li>
<li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态<ul>
<li>如果没有获取锁(synchronized或lock) 进入<strong>阻塞状态</strong>，获得锁再切换为可执行状态</li>
<li>如果线程调用了wait()方法进入<strong>等待状态</strong>，其他线程调用notify()唤醒后可转换为可执行状态</li>
<li>如果线程调用了sleep(50)方法，进入<strong>计时等待状态</strong>，到时间后可切换为可执行状态</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code class="java">Thread.java
public enum State &#123;
    /**
     * 新建状态。线程已经被创建，但尚未启动。
     */
    NEW,

    /**
     * 可运行状态。线程在JVM中是可运行的，这并不意味着它一定在运行，它可能在等待其他线程或操作系统的资源。
     */
    RUNNABLE,

    /**
     * 阻塞状态。线程正在等待监视器锁，以进入一个同步块/方法，或者在调用Object.wait后等待重新进入同步块/方法。
     */
    BLOCKED,

    /**
     * 等待状态。线程在等待另一个线程执行特定操作。例如，一个线程调用了Thread.join，它在等待指定的线程终止。
     */
    WAITING,

    /**
     * 超时等待状态。线程在等待另一个线程执行特定操作，但它设置了超时时间。如果线程在指定时间内没有等待到所需条件，它将自动返回。
     */
    TIMED_WAITING,

    /**
     * 终止状态。线程已经完成了执行。
     */
    TERMINATED;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/981d7e954005439be7e8261b142100e3e87f800b/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p>
<p><span style = "color:red"><strong>新建T1、T2、T3三个线程，如何保证它们按顺序执行？</strong></span></p>
<p>可以使用线程中的join方法解决<br><code>join() 等待线程运行结束</code></p>
<pre><code class="java">t.join() 阻塞调用此方法的线程进入timed_waiting 直到线程t执行完毕后，此线程再继续执行
</code></pre>
<pre><code class="java">Thread t1 = new Thread(()-&gt;&#123;
    sout(&quot;t1&quot;);
&#125;);
Thread t2 = new Thread(()-&gt;&#123;
    try&#123;
        t1.join();
    &#125;catch(InterruptedException e)&#123;
        e.printStackTrance();
    &#125;
    sout(&quot;t2&quot;);
&#125;)
Thread t3 = new Thread(()-&gt;&#123;
    try&#123;
        t2.join();
    &#125;catch(InterruptedException e)&#123;
        e.printStackTrance();
    &#125;
    sout(&quot;t3&quot;);
&#125;);
// 启动线程
t1.start();
t2.start();
t3.start();
</code></pre>
<p><span style = "color:red"><strong>notify() 和 notifyAll() 有什么区别？</strong></span></p>
<blockquote>
<ul>
<li><strong>notifyAll</strong>：唤醒所有wait的线程</li>
<li><strong>notify</strong>：只随机唤醒一个wait线程</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>java中wait和sleep方法有什么区别？</strong></span><del>wait要和synchronized一起使用</del></p>
<h6 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h6><p>wait()，wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态</p>
<h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul>
<li><p>方法归属不同</p>
<ul>
<li>sleep(long)是Thread的静态方法</li>
<li>而wait()，wait(long)都是Object的成员方法，每个对象都有</li>
</ul>
</li>
<li><p>醒来时机不同</p>
<ul>
<li>执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来</li>
<li>wait(long)和wait()还可以被notify唤醒，wait()如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><p><strong>锁特性不同</strong>【重点】</p>
<ul>
<li>wait方法的调用必须先获取wait对象的锁，而sleep则无此限制</li>
<li>wait方法执行后会释放锁对象，允许其他线程获得该锁对象 (我放弃cpu，但你们还可以用)</li>
<li>而sleep如果在synchronized代码块中执行，并不会释放锁对象 (我放弃cpu，你们也用不了)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5541d691652184639a4936426271a2f6ea03d2fb/wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.png"></p>
<p><span style = "color:red"><strong>如何停止一个正在运行的线程？</strong></span></p>
<h6 id="有三种方式可以停止线程"><a href="#有三种方式可以停止线程" class="headerlink" title="有三种方式可以停止线程"></a>有三种方式可以停止线程</h6><ul>
<li>使用退出标志，使线程<strong>正常退出</strong>，也就是当run方法完成后线程终止</li>
<li>使用<strong>stop方法</strong>强行终止(不推荐，方法已作废)</li>
<li>使用<strong>interrupt</strong>方法中断线程<ul>
<li>打断阻塞的线程(sleep, wait, join)的线程，线程会抛出InterruptedException异常</li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/64f320ea60791a6cc20d9e238d50be95345d1485/%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>synchronized关键字的底层原理？</strong></span><del>底层：Monitor</del></p>
<blockquote>
<ul>
<li>synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</li>
<li>它的底层由monitor实现的，monitor**是jvm级别的现象(C++实现)**，线程获得锁需要使用对象(锁)关联monitor</li>
<li>在monitor内部有三个属性，分别是<code>owner、entrylist、waitset</code><ul>
<li>owner是关联的获得锁的线程，并且只能关联一个线程；</li>
<li>entrylist关联的是处于阻塞状态的线程；</li>
<li>waitset关联的是处于Waiting状态的线程；</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4fd1c205a0d2d906c28c4a924b883b4082605a78/Synchronized%E4%B8%8ELock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>synchronized关键字的底层原理—进阶</strong></span></p>
<p><span style = "color:red"><strong><u>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</u></strong></span></p>
<blockquote>
<h4 id="一旦锁发生了竞争，都会升级为重量级锁"><a href="#一旦锁发生了竞争，都会升级为重量级锁" class="headerlink" title="一旦锁发生了竞争，都会升级为重量级锁"></a>一旦锁发生了竞争，都会升级为重量级锁</h4><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>重量级锁</td>
<td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 【有多个线程来抢】</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程加锁的时间是错开的(也就是没有竞争)可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li>Monitor实现的锁属于重量级锁，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<h6 id="Monitor重量级锁"><a href="#Monitor重量级锁" class="headerlink" title="Monitor重量级锁"></a>Monitor重量级锁</h6><p>每个Java对象都可以关联一个Monitor对象，如果使用 synchronized 给对象上锁(重量级)之后，该对象头的Mark Word中就被设置指向Monitor对象的指针</p>
<h6 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h6><ul>
<li>在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</li>
<li>通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</li>
<li>如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为nul，起到了一个重入计数器的作用。</li>
<li>如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</li>
</ul>
<h6 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h6><ul>
<li>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record.</li>
<li>如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</li>
<li>如果Lock Record的 Mark Word不为nul，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</li>
</ul>
<h6 id="偏向锁性能比轻量级锁好"><a href="#偏向锁性能比轻量级锁好" class="headerlink" title="偏向锁性能比轻量级锁好"></a>偏向锁<del>性能比轻量级锁好</del></h6><ul>
<li>轻量级锁在没有竞争时(就自己这个线程)每次重入仍然需要执行 CAS 操作。</li>
<li>Java6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d930bb7ad0d897e72b69faa5bb15fa1f387b728a/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%5B%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%5D%E2%80%94%E8%BF%9B%E9%98%B6%E7%AF%87.png"></p>
<h4 id="你谈谈JMM-Java内存模型"><a href="#你谈谈JMM-Java内存模型" class="headerlink" title="你谈谈JMM (Java内存模型)"></a><span style = "color:red"><strong>你谈谈JMM (Java内存模型)</strong></span></h4><h6 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h6><ul>
<li>JMM(Java Memory Model)Java内存模型，定义了<strong>共享内存</strong>中<strong>多线程程序读写操作</strong>的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li>
<li>JMM把内存分为两块，一块是私有线程的工作区域(工作内存)，一块是所有线程的共享区域(主内存)</li>
<li>线程跟线程之间是相互隔离，线程跟线程相互需要通过主内存</li>
</ul>
<p><span style = "color:red"><strong>CAS你知道吗？</strong></span></p>
<blockquote>
<ul>
<li>CAS全称是：Compare And Swap(比较再交换)，它体现的一种<strong>乐观锁</strong>的思想，在无锁情况下保证线程操作共享数据的原子性。</li>
<li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li>
<li>在操作共享变量的时候使用自旋锁，效率上更高一些</li>
<li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</li>
</ul>
</blockquote>
<p>在JUC(java.util.concurrent)包下实现的很多类都用到了CAS操作</p>
<ul>
<li>AbstractQueuedSynchronizer (AQS框架)</li>
<li>AtomicXXX类</li>
</ul>
<p><span style = "color:red"><strong>乐观锁和悲观锁的区别？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ed89cde4cab6a88d6f2a86f3430be2b28a5e3626/JMM%20(Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)+CAS.png"></p>
<p><span style = "color:red"><strong>谈一谈你对volatile的理解？</strong></span></p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li><h5 id="保证线程间的可见性"><a href="#保证线程间的可见性" class="headerlink" title="保证线程间的可见性"></a>保证线程间的可见性</h5><p>用volatile修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p>
</li>
<li><h5 id="禁止进行指令重排序"><a href="#禁止进行指令重排序" class="headerlink" title="禁止进行指令重排序"></a>禁止进行指令重排序</h5><p>用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ce52eb544e19cacdc7c7d22cb6fa3135b27e6a3/volatile%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%90%86%E8%A7%A3[%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8F%AF%E8%A7%81+%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F].png"></p>
<p><span style = "color:red"><strong>什么是AQS？</strong></span></p>
<blockquote>
<ul>
<li>是多线程中的队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li>AQS内部维护了一个**<u>先进先出的双向队列</u>**，队列中存储的排队的线程</li>
<li>在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0(无所状态)，如果队列中有一个线程修改成功了state为1，则当前线程就相当于获取了资源。</li>
<li>在对state修改的时候使用CAS(compare and swap)操作，保证多个线程修改的情况下原子性</li>
</ul>
</blockquote>
<p>AQS(<strong>A</strong>bstract<strong>Q</strong>ueued<strong>S</strong>ynchronizer)，即抽象队列同步器。它是构建锁或者其他同步组件的<strong>基础框架</strong></p>
<h6 id="AQS与Synchronized的区别"><a href="#AQS与Synchronized的区别" class="headerlink" title="AQS与Synchronized的区别"></a>AQS与Synchronized的区别</h6><table>
<thead>
<tr>
<th align="center">synchronized</th>
<th align="center">AQS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关键字，C++语言实现</td>
<td align="center">java语言实现</td>
</tr>
<tr>
<td align="center">悲观锁，自动释放锁</td>
<td align="center">悲观锁，手动开启和关闭</td>
</tr>
<tr>
<td align="center">锁竞争激励都会升级为<strong>重量级锁</strong>，性能差</td>
<td align="center">锁竞争激烈的情况下，提供了多种解决方案</td>
</tr>
</tbody></table>
<h6 id="AQS常见的实现类"><a href="#AQS常见的实现类" class="headerlink" title="AQS常见的实现类"></a>AQS常见的实现类</h6><ul>
<li><strong>ReentrantLock 阻塞式锁</strong></li>
<li>Semaphore 信号量</li>
<li>CountDownLatch 倒计时锁</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dd56a7110e36eebc67c093ce454bd7052a1ad30/%E4%BB%80%E4%B9%88%E6%98%AFAQS.png"></p>
<p><span style = "color:red"><strong>ReentrantLock [rɪ’entrənt]lock 的实现原理？</strong></span><del>[关联HashMap线程不安全需加锁(synchronized或ReentrantLock)]</del></p>
<blockquote>
<p>ReentrantLock主要利用<strong>CAS+AQS队列</strong><del>CompareAndSwap+AbstractQueuedSynchronized</del>来实现。**<u>它支持公平锁和非公平锁</u><strong>，两者的实现类似构造方法接受一个可选的公平参数(<strong>默认非公平锁</strong>)，</strong><u>当设置为true时，表示公平锁，否则为非公平锁</u>**。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p>
</blockquote>
<p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p>
<ul>
<li>可中断<del>synchronized不可中断</del></li>
<li>可设置超时时间<del>没有获得锁时只能进入等待</del>[<u>没有获取锁可以放弃锁</u>]</li>
<li>可以设置公平锁<del>synchronized只有非公平锁</del>[也支持非公平锁]</li>
<li>支持多个条件变量</li>
<li>与synchronized一样，都支持重入</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9279a890a6163298e551a9f594f3c0b921a438ad/ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>synchronized和Lock有什么区别？</strong></span></p>
<ul>
<li><strong>语法层面</strong></li>
</ul>
<p>synchronized是关键字，源码在jvm中，用c++语言实现<br>Lock是接口，源码由jdk提供，用java语言实现<br>使用synchronized时，退出同步代码块锁会<strong>自动释放</strong>，而使用Lock时，需要<strong>手动</strong>调用unlock方法<strong>释放锁</strong></p>
<ul>
<li><strong>功能层面</strong></li>
</ul>
<p><strong>二者均属于悲观锁</strong>、都具备基本的互斥、同步、锁重入功能<br>Lock提供了许多synchronized不具备的功能，例如<strong>公平锁、可打断、可超时、多条件变量</strong><br>Lock有适合不同场景的实现，如ReentrantLock、ReentrantReadWeiteLock(读写锁)</p>
<p><span style = "color:red"><strong>死锁产生的条件是什么</strong></span></p>
<p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<h6 id="如何进行死锁诊断-？"><a href="#如何进行死锁诊断-？" class="headerlink" title="如何进行死锁诊断 ？"></a>如何进行死锁诊断 ？</h6><p>当程序出现了死锁现象，我们可以使用jdk自带的工具：<strong>jps</strong>和<strong>jstack</strong></p>
<ul>
<li><strong>jps</strong>：输出JVM中运行的<strong>进程状态</strong>信息</li>
<li><strong>jstack</strong>：查看java进程内<strong>线程的堆栈</strong>信息</li>
</ul>
<p>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack -l &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<h6 id="其他解决工具，可视化工具"><a href="#其他解决工具，可视化工具" class="headerlink" title="其他解决工具，可视化工具"></a>其他解决工具，可视化工具</h6><ul>
<li><strong>jconsole</strong></li>
</ul>
<p>用于对jvm的 <u>内存，线程，类</u>  的监控，是一个基于jmx的GUI性能监控工具<br>打开方式：java安装目录 bin目录下 直接启动 <code>jconsole.exe</code>就行</p>
<ul>
<li><strong>VisualVM</strong>：故障处理工具</li>
</ul>
<p>能够监控线程，内存情况，查看方法的cpu时间和内存中的对象，已被GC的对象，反向查看分配的堆栈<br>打开方式：java安装目录 bin目录下 直接启动 <code>jvisualvm.exe</code>就行</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e76fa529b0f5ed6e555f615f22b4ad646e02f0d6/%E6%AD%BB%E9%94%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<p><strong>死锁</strong>：两个线程争夺两个资源的时候  <code>1线程拿到a 想拿b   2线程拿到了b 想拿a</code><br><strong>四个原因</strong>：<u>互斥条件 请求保持 不可剥夺 循环等待</u><br>产生死锁的四个因素 同时满足才会死锁     想要解决死锁 需要打破其中一个原因就行</p>
<blockquote>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时使用。即某个资源在一段时间内只能由一个线程占用，其他线程必须等待该资源被释放后才能使用。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源又被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：已经分配给某个线程的资源在该线程完成任务前不能被抢占，即只能由线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一种线程资源的循环等待链，每个线程都在等待下一个线程所持有的资源。</li>
</ol>
</blockquote>
<blockquote>
<h4 id="在实际操作中，以下是一些打破死锁的具体方法：银行家算法可以避免死锁"><a href="#在实际操作中，以下是一些打破死锁的具体方法：银行家算法可以避免死锁" class="headerlink" title="在实际操作中，以下是一些打破死锁的具体方法：银行家算法可以避免死锁"></a>在实际操作中，以下是一些打破死锁的具体方法：<del>银行家算法可以避免死锁</del></h4><ul>
<li><strong>资源分配图</strong>：使用资源分配图来检测循环等待条件，并在检测到循环时采取措施。</li>
<li><strong>锁排序</strong>：确保所有线程以相同的顺序获取锁，从而避免循环等待。</li>
<li><strong>超时机制</strong>：线程在请求资源时设置超时时间，如果超过时间未获得资源，则放弃当前任务并释放已持有的资源。</li>
<li><strong>死锁检测算法</strong>：运行死锁检测算法，如银行家算法，来检测系统中的死锁，并在必要时采取措施。</li>
<li><strong>线程中断</strong>：允许系统或其他线程中断正在等待资源的线程。</li>
<li><strong>回滚操作</strong>：如果检测到死锁，可以让某些线程回滚它们的工作，并释放资源，从而打破死锁。</li>
</ul>
</blockquote>
<p>MySQL是不会有死锁的 自身会检测 [让后面的超时释放回滚]<br>在分布式事务 线程1拿着资源a是数据库1 线程2拿着资源b是数据库2<br>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<p><span style = "color:red"><strong>聊一下ConcurrentHashMap</strong></span></p>
<p><code>ConcurrentHashMap</code>是一种线程安全的高效Map集合<br><strong>底层数据结构</strong>：</p>
<ul>
<li><p>JDK1.7底层采用分段的数组+链表实现</p>
</li>
<li><p>JDK1.8采用的数数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：<code>数组+红黑树+链表</code>，采用CAS + Synchronized来保证并发安全进行实现</p>
<ul>
<li>CAS控制数组节点的添加</li>
<li>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题，效率得到提升</li>
</ul>
</li>
</ul>
<p><strong>加锁的方式</strong>：</p>
<ul>
<li>JDK1.7采用<code>Segment</code>分段锁，底层使用的是<code>ReentrantLock</code></li>
<li>JDK1.8采用<code>CAS</code><del>自旋锁</del>添加新节点，采用<code>synchronized</code>锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/fc8e6e126e8fff5692b8c53102ac3237b913310d/%E8%81%8A%E4%B8%80%E8%81%8AConcurrentHashMap.png"></p>
<h4 id="导致并发程序出现问题的根本原因是什么-Java程序中怎么保证多线程的执行安全"><a href="#导致并发程序出现问题的根本原因是什么-Java程序中怎么保证多线程的执行安全" class="headerlink" title="导致并发程序出现问题的根本原因是什么 (Java程序中怎么保证多线程的执行安全)"></a><span style = "color:red"><strong>导致并发程序出现问题的根本原因是什么 (Java程序中怎么保证多线程的执行安全)</strong></span></h4><h6 id="Java并发编程三大特性"><a href="#Java并发编程三大特性" class="headerlink" title="Java并发编程三大特性"></a>Java并发编程三大特性</h6><ul>
<li><span style = "color:blue"><strong>原子性<del>synchronized、lock</del></strong></span>：一个线程在CPU中操作不可暂停，也不可中断，要么执行完成，要么不执行</li>
</ul>
<pre><code class="java">int ticketNum = 10;
public void getTicket()&#123;
    if(ticketNum &lt;= 0)&#123;
        return;
    &#125;
    sout(Thread.currentThread().getName() + &quot;抢到一张票，剩余：&quot; + ticketNum);
    // 非原子性操作
    ticketNum--;
&#125;
main&#123;
    TicketDemo demo = new TicketDemo();
    for(int i = 0; i &lt; 20; i++)&#123;
        new Thread(demo::getTicket).start();
    &#125;
&#125;
</code></pre>
<h6 id="不是原子操作，怎么保证原子操作呢？"><a href="#不是原子操作，怎么保证原子操作呢？" class="headerlink" title="不是原子操作，怎么保证原子操作呢？"></a>不是原子操作，怎么保证原子操作呢？</h6><ol>
<li>synchronized：同步加锁</li>
<li>JUC里面的lock：加锁</li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4fd1c205a0d2d906c28c4a924b883b4082605a78/Synchronized%E4%B8%8ELock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<ul>
<li><strong><span style = "color:blue">可见性<del>volatile、synchronized、lock</del></span></strong></li>
</ul>
<h6 id="内存可见性：让一个线程对共享变量的修改对另一个线程可见"><a href="#内存可见性：让一个线程对共享变量的修改对另一个线程可见" class="headerlink" title="内存可见性：让一个线程对共享变量的修改对另一个线程可见"></a>内存可见性：让一个线程对共享变量的修改对另一个线程可见</h6><pre><code class="java">public class VolatileDemo&#123;
    private static boolean flag = false;
    public static void main(String[] args) throws InterruptedException&#123;
        new Thread(()-&gt;&#123;
            while(!flag)&#123;
                sout(&quot;第一个线程执行完毕...&quot;);
            &#125;
        &#125;).start();
        Thread.sleep(100);
        new Thread(()-&gt;&#123;
            flag = true;
            sout(&quot;第二个线程执行完毕...&quot;);
        &#125;).start();
    &#125;
&#125;
</code></pre>
<p><strong>解决方案：synchronized、<u>volatile</u>、LOCK</strong> </p>
<p>volatile：加在共享变量上面即可 →  private static <strong>volatile</strong> boolean flag &#x3D; false;</p>
<ul>
<li><strong><span style = "color:blue">有序性<del>volatile</del></span></strong></li>
</ul>
<p><strong>指令重排</strong>：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p>
<pre><code class="java">int x;
int y;
@Actor
public void actor1()&#123;
    x = 1;
    y = 1;
&#125;
@Actor
public void actor2(II_Result r)&#123;
    r.r1 = y;
    r.r2 = x;
&#125;
</code></pre>
<p><strong>解决办法</strong>：在前面加上<code>volatile</code></p>
<p><span style = "color:red"><strong>说一下线程池的核心参数</strong></span></p>
<p>为什么要创建线程池 因为每次创建线程的时候就要占用一定的内存空间 无限创建线程回浪费内存<del>严重会导致内存溢出</del><br>CPU有限的同一时刻只能同时处理一个线程 大量线程来的话就没有线程权 会造成线程等待 造成大量线程在之间切换也会导致性能变慢</p>
<pre><code class="java">在这个例子中，我们创建了一个线程池，核心线程数为5，最大线程数为10，如果线程池中的线程数大于核心线程数，则空闲线程在60秒后会被终止。工作队列使用ArrayBlockingQueue，其容量为100。

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolExample &#123;
    public static void main(String[] args) &#123;
        // 核心线程数
        int corePoolSize = 5;
        // 最大线程数 = （核心线程 + 救急线程的最大数目）
        int maximumPoolSize = 10;
        // 线程池中超过 corePoolSize 数量的空闲线程最大存活时间
        long keepAliveTime = 60L;
        // 时间单位 - 救急线程的生存时间单位，如秒、毫秒等
        TimeUnit unit = TimeUnit.SECONDS;
        // 工作队列，用于存放提交的任务 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务
        ArrayBlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;&gt;(100);
        // 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等
        ThreadFactory threadFactory = new ThreadFactory;
        // 拒绝策略 - 当所有线程豆繁忙，workQueue也繁忙时，会触发拒绝策略
        RejectedExecutionHandler handler = new RejectedExecutionHandler;
        
        // 创建线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                corePoolSize,
                maximumPoolSize,
                keepAliveTime,
                unit,
                workQueue
        );

        // 示例：向线程池提交任务  threadPoolExecutor.submit()/.execute()
        for (int i = 0; i &lt; 20; i++) &#123;
            int taskNumber = i;
            threadPoolExecutor.execute(() -&gt; &#123;
                System.out.println(&quot;Executing task &quot; + taskNumber);
                // 模拟任务执行时间
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;);
        &#125;

        // 关闭线程池
        threadPoolExecutor.shutdown();
    &#125;
&#125;
</code></pre>
<p>一开始new的时候没有 是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><span style = "color:red"><strong>线程池中有哪些常见的阻塞队列</strong></span></p>
<p><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>workQueue - 阻塞队列常用的队列</u>：当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
<li>DelayedWorkQueue：是一个优先级队列，它可以保证每次出队的任务都是当前队列中时间最靠前的</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作</li>
</ol>
<table>
<thead>
<tr>
<th align="center">ArrayBlockingQueue</th>
<th align="center"><span style = "color:red">LinkedBlockingQueue<del>不给值默认最大值</del></span></th>
</tr>
</thead>
<tbody><tr>
<td align="center">强制有界</td>
<td align="center">默认无界，支持有界</td>
</tr>
<tr>
<td align="center">底层是数组</td>
<td align="center">底层是链表</td>
</tr>
<tr>
<td align="center">提前初始化Node数组</td>
<td align="center">是懒惰的，创建节点的时候添加数据</td>
</tr>
<tr>
<td align="center">Node需要是提前创建好的</td>
<td align="center">入队会生成新Node</td>
</tr>
<tr>
<td align="center">一把锁</td>
<td align="center">两把锁(头尾)<del>可以一边入队,一边出队</del></td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>如何确定核心线程数</strong></span></p>
<blockquote>
<p>① 高并发、任务执行时间短 → (CPU核数 + 1)，减少线程上下文的切换<br>② 并发不高、任务执行时间长</p>
<ul>
<li><strong>IO密集型任务 → (CPU核数 * 2 + 1)</strong></li>
<li>计算密集型任务 → (CPU核数 + 1)</li>
</ul>
<p>③ <strong>并发高、业务执行时间长</strong>，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置参考②</p>
</blockquote>
<ul>
<li>IO密集型任务：文件读写、DB读写、网络请求等                            <span style = "color:blue"><strong>核心线程数大小设置为2N+1</strong></span></li>
<li>CPU密集型任务：计算型代码、Bitmap转换、Gson转换等            <span style = "color:blue"><strong>核心线程数大小设置为N+1</strong></span></li>
</ul>
<pre><code class="java">// 查看机器的CPU核数
public static void main(String[] args)&#123;
    // 查看机器的CPU核数
    System.out.println(Runtime.getRuntime().avaliableProcessors());
&#125;
</code></pre>
<p><span style = "color:red"><strong>线程池的种类有哪些</strong></span></p>
<p>在<code>java.util.concurrent.Executors</code>类中提供了大量创建线程池的静态方法，常见的有四种</p>
<h6 id="①-创建使用固定线程数的线程池"><a href="#①-创建使用固定线程数的线程池" class="headerlink" title="① 创建使用固定线程数的线程池"></a>① 创建使用固定线程数的线程池</h6><p><span style = "color:blue">适用于任务已知，相对耗时的任务</span></p>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads)&#123;
    return new ThreadPoolExecutor(nThreads, nThreads,0L,TimeUnit.MILLISECONDS.new LinkedBlockingQueue&lt;Runnable&gt;)
&#125;
</code></pre>
<ul>
<li>核心线程数与最大线程数一样，没有<code>救急线程 = 最大线程数 - 核心线程数</code></li>
<li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li>
</ul>
<h6 id="②-单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-执行→-先进先出"><a href="#②-单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-执行→-先进先出" class="headerlink" title="② 单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO)执行→[先进先出]"></a>② 单线程化的线程池<del>它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO)执行→[先进先出]</del></h6><p><span style = "color:blue">适用于按照顺序执行的任务</span></p>
<pre><code class="java">public static ExecutorService newSingleThreadExecutor()&#123;
    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));
&#125;
</code></pre>
<ul>
<li>核心线程数和最大线程数都是1</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code>，最大容量为<code>Integer.MAX_VALUE</code></li>
</ul>
<h6 id="③-可缓存线程池"><a href="#③-可缓存线程池" class="headerlink" title="③ 可缓存线程池"></a>③ 可缓存线程池</h6><pre><code class="java">public static ExecutorService newCachedThreadPool()&#123;
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());
&#125;
</code></pre>
<ul>
<li>核心线程数为0</li>
<li>最大线程数是<code>Integer.MAX_VALUE</code></li>
<li>阻塞队列是<code>SynchronousQueue</code>: 不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作</li>
</ul>
<h6 id="④-提供了-延迟-和-周期执行-功能的ThreadPoolExecutor"><a href="#④-提供了-延迟-和-周期执行-功能的ThreadPoolExecutor" class="headerlink" title="④ 提供了 延迟 和 周期执行 功能的ThreadPoolExecutor"></a>④ 提供了 <code>延迟</code> 和 <code>周期执行</code> 功能的ThreadPoolExecutor</h6><pre><code class="java">public ScheduledThreadPoolExecutor(int corePoolSize)&#123;
    super(corePoolSize, Integer.MAX_VALUE,0,NANOSECONDS,new DelayedWorkQueue());
&#125;
</code></pre>
<p><span style = "color:red"><strong>为什么不建议使用Executors创建线程池？</strong></span></p>
<p>参考阿里开发手册</p>
<pre><code class="java">【强制】 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors返回的线程池对象的弊端如下：
1. FixedThreadPool 和 SingleThreadPool：
允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM
2. CachedThreadPool：
允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程，从而导致OOM
</code></pre>
<p><span style = "color:red"><strong>线程池的使用场景①：ES数据批量导入</strong></span></p>
<h6 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h6><p>CountDownLatch(闭锁&#x2F;倒计时锁)用来进行线程同步协作，等待所有线程完成倒计时时(一个或多个线程，等待其他多个线程完成某件事情之后才能执行)</p>
<ul>
<li>其中构造参数用来初始化等待计数值</li>
<li><code>await()</code>用来等待计数归零</li>
<li><code>countDown()</code>用来让计数减一</li>
</ul>
<h6 id="多线程使用场景一-es数据批量导入"><a href="#多线程使用场景一-es数据批量导入" class="headerlink" title="多线程使用场景一 (es数据批量导入)"></a>多线程使用场景一 (es数据批量导入)</h6><p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右一次性读取数据肯定不行(oom异常)，当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制就能避免一次性加载过多，防止内存溢出</p>
<p>DB(一千万) → 线程池(CountDownLatch) → Elasticearch</p>
<pre><code class="java">       批量导入  →  查询总条数   →       DB
                      ↓               ↑          批量导入到ES中     →   ES
(固定每页2000条)        计算总页数            ↑  (countDownLatch.countDown())
                        ↓               ↑                ↑
(总页数)         CountDownLatch        ↑                ↑
                        ↓               ↑                ↑
                分页查询文章数据 → [查询当前页的文章 → 创建任务批量导入ES → 提交到线程池执行]循环
                                             (文章列表, countDownLatch)
                                                          ↓
                                                countDownLatch.await()
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a8e33cd1bf93eca7f789f20cee1a67770b426f68/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-CountDownLatch%E7%94%A8ES%E6%89%B9%E9%87%8F.png"></p>
<p><span style = "color:red"><strong>线程池的使用场景②：数据汇总</strong></span></p>
<ul>
<li>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息;这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢?<ul>
<li>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口(或部分接口)的没有依赖关系，就可以使用线程池+future来提升性能<br>[<u>统计的图文发布量、点赞数量、收藏数量、评论数量若不在同一台微服务下 或者 部分没有依赖关系</u>]</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b9ec7c6d685bab18893fbfa3b6637c48f3384ecf/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%94%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB.png"></p>
<p><span style = "color:red"><strong>线程池的使用场景③：异步调用</strong></span></p>
<p>为了避免下一级方法影响上一级方法(性能考虑)，可使用<strong>异步线程调用</strong>下一个方法(不需要下一级方法返回值)，可以提升方法相应时间</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8b9788570956b65f8073f31b82bada34a8ddb799/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png"></p>
<p><span style = "color:red"><strong>如何控制某个方法允许并发访问线程的数量</strong></span></p>
<p>Semaphore信号量，是JUC包下的一个工具类，底层是AQS，我们可以通过其限制执行的线程数量<br><strong>适用场景</strong>：<br>通常用于那些资源有明确访问数量限制的场景，常用于限流</p>
<h6 id="Semaphore使用步骤"><a href="#Semaphore使用步骤" class="headerlink" title="Semaphore使用步骤"></a>Semaphore使用步骤</h6><ul>
<li>创建Semaphore对象，可以给一个容器</li>
<li>semaphore.acquire()：请求一个信号量，这时候的信号量个数 -1 (<u>一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量</u>)</li>
<li>semaphore.release()：释放一个信号量，此时信号量个数 +1</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76cde79a53b36086d940f2874f8aa7ffd93ce6ef/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F.png"></p>
<p><span style = "color:red"><strong>谈一谈你对ThreadLocal的理解</strong></span></p>
<blockquote>
<ul>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
<li>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线<br>程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中査找关联的资源值</li>
<li>调用remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
</li>
<li>ThreadLocal内存泄漏问题ThreadLocalMap 中的key是弱引用，值为强引用; key会被Gc释放内存，关联 value的内存并不会释放。建议主动remove 释放 key，value</li>
</ul>
</blockquote>
<h6 id="ThreadLocal概述"><a href="#ThreadLocal概述" class="headerlink" title="ThreadLocal概述"></a>ThreadLocal概述</h6><p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会<strong>为每个线程都分配一个独立的线程副本</strong>从而解决了变量并发访问冲突的问题。ThreadLocal同时实现了线程内的资源共享</p>
<p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p>
<p><strong>ThreadLocal基本使用</strong></p>
<ul>
<li>set(value) 设置值</li>
<li>get() 获取值</li>
<li>remove() 清除值</li>
</ul>
<h6 id="ThreadLocal的实现原理-amp-源码解析"><a href="#ThreadLocal的实现原理-amp-源码解析" class="headerlink" title="ThreadLocal的实现原理 &amp; 源码解析"></a>ThreadLocal的实现原理 &amp; 源码解析</h6><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离<br><img src="https://raw.githubusercontent.com/P-luminary/images/4471cf0ff69616926ff6fab93392d3d9fa5aba32/%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3.png"></p>
<h2 id="JVM相关面试题"><a href="#JVM相关面试题" class="headerlink" title="JVM相关面试题"></a>JVM相关面试题</h2><p><span style = "color:red"><strong>什么是JVM？</strong></span></p>
<p>JVM &#x3D; <code>Java Virtual Machine</code>  是java程序的运行环境<br>JVM是运行在操作系统中的 屏蔽了操作系统的差异</p>
<p><strong>好处</strong>：</p>
<ul>
<li>一次编码，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a325bf161b1cdb5a49058d007d4e21a05f2a1fc5/JVM%E7%94%B1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png"></p>
<p><span style = "color:red"><strong>什么是程序计数器？</strong></span></p>
<p><strong>程序计数器</strong>：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址</p>
<p><code>javap -v xx.class</code>：打印堆栈大小，局部变量的数量和方法的参数</p>
<blockquote>
<p>找到Application的class文件后 → Build → Rebuild Project<del>编译一下</del> → 找到该Application的class文件<del>黄色的</del> → Open in → Terminal → javap -v Application.class</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f1c8f0c34bb891c12d945dd852ab575a787a2112/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png"></p>
<p><span style = "color:red"><strong>你能给我详细介绍Java堆吗？</strong></span></p>
<p><strong>线程共享的区域：</strong>主要用来保存<strong>对象实例、数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展，则抛出<code>OutOfMemoryError</code>异常</p>
<ul>
<li>组成：<strong>年轻代 + 老年代</strong><ul>
<li><strong>年轻代</strong>被划分为三部分，Eden区和两个大小严格相同的Survivor区<del>幸存者区</del></li>
<li><strong>老年代</strong>主要保存生命周期长的对象，一般是一些老的对象</li>
</ul>
</li>
<li>jdk1.7和1.8的区别<ul>
<li>1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码</li>
<li>1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5e6f155423b028b82378d40f63a3713073b75410/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86.png"></p>
<p><span style = "color:red"><strong>什么是虚拟机栈？</strong></span></p>
<p><code>Java Virtual machine Stacks</code>(Java虚拟机栈)</p>
<ul>
<li>每个线程运行时所需要的内存，称为<strong>虚拟机栈</strong>，先进后出</li>
<li>每个栈由多个栈帧(frame)组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<p><span style = "color:blue">垃圾回收是否涉及栈内存？</span></p>
<p>不涉及，因为垃圾回收主要指的是<strong>堆内存</strong>。<br>这里当栈帧弹栈后，内存就会释放</p>
<p><span style = "color:blue">栈内存分配越大越好吗？</span></p>
<p>未必，默认的栈内存通常为1024k<br>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p>
<p><span style = "color:blue">方法内的局部变量是否线程安全？</span></p>
<p>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的<br>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p>
<p><span style = "color:blue">什么情况下会导致栈内存溢出？</span></p>
<p>栈帧过多导致栈内存溢出，经典问题：递归调用<br>栈帧过大导致栈内存溢出</p>
<p><span style = "color:blue">堆栈的区别是什么？</span></p>
<p>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会<br>栈内存是线程私有的，而堆内存是线程共有的。<br>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常<br>  栈空间不足:java.lang.StackOverFlowError。<br>  堆空间不足:java.ang.OutOfMemoryError。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/420de72ff7c225960e7aff5d59f20c14e93ecb0a/%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p>
<p><span style = "color:red"><strong>能不能解释一下方法区</strong></span></p>
<ul>
<li>方法区(Method Area)是各个线程<strong>共享的内存区域</strong></li>
<li>主要存储类的信息、运行时常量池</li>
<li>虚拟机启动的时候创建，关闭虚拟机时释放</li>
<li>如果方法区域中的内存无法满足分配请求，则会抛出<code>OutOfMemoryError: Metaspace</code></li>
</ul>
<h6 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h6><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息<br>在<strong>Terminal</strong>中执行：<code>javap -v Application.class</code><br>可以查看字节码结构 (<strong><u>类的基本信息、常量池、方法定义</u></strong>)<br>当类被加载，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dea620655b2b4c7234ba3b2f4fcedbf76a0bb9a8/%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA.png"></p>
<p><span style = "color:red"><strong>你听过直接内存吗？</strong></span></p>
<p><strong>直接内存</strong>：并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存，常见于NIO操作时，用于数据缓冲区，它分配回收成本较高，但读写能力高。[平时的是BIO]</p>
<p>直接内存并不属于JVM中的内存结构，不由VM进行管理。是虚拟机的系统内存常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5823b0e711a3e4029e411438f0a85468af5dfa3f/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.png"></p>
<p><span style = "color:red"><strong>什么是类加载器，类加载器有哪些？</strong></span></p>
<h6 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h6><p>JVM只会运行二进制文件，类加载器的作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来</p>
<ol>
<li><strong>引导类加载器（Bootstrap ClassLoader）</strong>：<del>加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的库</del><ul>
<li>这是最顶层的类加载器，它用于加载Java的核心库，这些库位于<code>&lt;JAVA_HOME&gt;/jre/lib</code>目录（比如<code>rt.jar</code>、<code>resources.jar</code>等），或者被<code>-Xbootclasspath</code>参数指定的路径中。</li>
<li><u><strong>引导类加载器是用原生代码（如C&#x2F;C++）实现的</strong></u>，它属于JVM的一部分。</li>
<li>它并不继承自<code>java.lang.ClassLoader</code>，而是由JVM自身实现。</li>
</ul>
</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：<del>加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类</del><ul>
<li>它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录中，或者由系统属性<code>java.ext.dirs</code>指定的路径中的类库。</li>
<li>它是<code>sun.misc.Launcher$ExtClassLoader</code>类的实例。</li>
</ul>
</li>
<li><strong>系统类加载器（System ClassLoader）</strong>：<del>用于加载classPath下的类</del><ul>
<li>也称为应用类加载器（Application ClassLoader），它负责加载用户类路径（Classpath）上的所有类库。</li>
<li>系统类加载器是<code>sun.misc.Launcher$AppClassLoader</code>类的实例。</li>
<li>它是程序中默认的类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>方法获取。</li>
</ul>
</li>
<li><strong>自定义加载器（CustomizeClassLoader）</strong><del>自定义继承ClassLoader，实现自定义类加载规则</del><ul>
<li>用户还可以自定义类加载器。自定义类加载器通过继承<code>java.lang.ClassLoader</code>类并重写相应的方法来实现。自定义类加载器可以用于特定的需求，例如在Web容器中加载类，或者在运行时从网络或其他地方动态加载类。</li>
</ul>
</li>
</ol>
<p><span style = "color:red"><strong>什么是双亲委派模型？</strong></span></p>
<p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类</p>
<h6 id="JVM为什么采用双亲委派机制？"><a href="#JVM为什么采用双亲委派机制？" class="headerlink" title="JVM为什么采用双亲委派机制？"></a>JVM为什么采用双亲委派机制？</h6><ul>
<li>通过双亲委派机制可以<strong>避免某一个类被重复加载</strong>，当父类已经加载后则无需重复加载，保证唯一性</li>
<li>为了安全，保证类库API不会被修改</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/994e5705a6bdb7a164308d3496942d154c877b36/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p>
<p><span style = "color:red"><strong>说一下类装载的执行过程？</strong></span></p>
<blockquote>
<p><strong>加载</strong>：查找和导入class文件<br><strong>验证</strong>：保证加载类的准确性<br><strong>准备</strong>：为类变量分配内存并设置类变量初始值<br><strong>解析</strong>：把类中的符号引用转换为直接引用<br><strong>初始化</strong>：对类的静态变量，静态代码块执行初始化操作<br><strong>使用</strong>：JVM 开始从入口方法开始执行用户的程序代码<br><strong>卸载</strong>：当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象</p>
</blockquote>
<p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：<strong>加载、验证、准备、解析、初始化、使用</strong>和<strong>卸载</strong>这7个阶段。其中，验证、准备和解析这三个部分统称为连接(linking)</p>
<ul>
<li>通过类的全名，获得类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构(Java类模型)</li>
<li>创建<code>java.lang.Class</code>类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6e58e968ea6bb8bb002556d37d5cc31b73f820e3/%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B1.png"></p>
<p><span style = "color:red"><strong>对象什么时候可以被垃圾器回收</strong></span></p>
<p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收</p>
<h6 id="怎么确定什么是垃圾？"><a href="#怎么确定什么是垃圾？" class="headerlink" title="怎么确定什么是垃圾？"></a>怎么确定什么是垃圾？</h6><ul>
<li><p><strong>引用计数法</strong></p>
<p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<p>采用的都是通过可达性分析算法来确定哪些内容是垃圾</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e29795c3537bdedf4f596d20c78cda8b7f8abc8c/%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6.png"></p>
<p><span style = "color:red"><strong>JVM垃圾回收算法有哪些？</strong></span></p>
<ul>
<li><p><strong>标记清除算法</strong></p>
<p>是将垃圾回收分为2个阶段，分别为<strong>标记</strong>和<strong>清除</strong></p>
<ul>
<li>根据可达性分析算法得出的垃圾进行标记</li>
<li>对这些标记为可回收的内容进行垃圾回收</li>
</ul>
</li>
<li><p><strong>复制算法</strong></p>
<p>将原有的内存空间一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收；无碎片，内存使用率低</p>
</li>
<li><p><strong>标记清理算法</strong><del>一般用于老年代</del></p>
<p>标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，无碎片，对象需要移动，效率低</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/da45a9b399c0614bb286b0dfef59d0d737ee7b38/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png"></p>
<p><span style = "color:red"><strong>JVM的分代回收是什么？</strong></span></p>
<h6 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h6><p>在java8时，堆被分为了两份：<strong>新生代和老年代</strong>[1:2]<br>对于新生代，内部又分为了三个区域，Eden区，幸存者区survivor(分成from和to)【8:1:1】</p>
<h6 id="MinorGC、MixedGC、FullGC的区别是什么"><a href="#MinorGC、MixedGC、FullGC的区别是什么" class="headerlink" title="MinorGC、MixedGC、FullGC的区别是什么"></a>MinorGC、MixedGC、FullGC的区别是什么</h6><ul>
<li>MinorGC<del>(youngGC)</del>发生在新生代的垃圾回收，暂停时间短(STW)</li>
<li>MixedGC：新生代 + 老年代 <strong>部分</strong>区域的垃圾回收，G1收集器特有</li>
<li>FullGC：新生代 + 老年代 <strong>完整</strong>垃圾回收，暂停时间长(STW)，应尽力避免</li>
</ul>
<p><code>STW(Stop-The-World)</code>：<u>暂停所有应用程序线程，等待垃圾回收的完成</u></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3cf5dfdf35165c472440a0b24f3561c6bef9b81a/JVM%E7%9A%84%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%80%E4%B9%88.png"></p>
<p><span style = "color:red"><strong>JVM有哪些垃圾回收器？</strong></span></p>
<p>在jvm中，实现了多种垃圾收集器，包括：</p>
<ul>
<li><p><strong>串行垃圾收集器</strong></p>
<p><strong>Serial</strong>和<strong>Serial Old</strong>串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p>
<ul>
<li>Serial 作用于新生代，采用复制算法</li>
<li>Serial Old 作用于老年代，采用标记-整理算法垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成</li>
</ul>
</li>
<li><p><strong>并行垃圾收集器</strong></p>
<p>Parallel New和Parallel Old是一个<strong>并行</strong>垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p>
<ul>
<li><p>Parallel New作用于新生代，采用复制算法</p>
</li>
<li><p>Parallel Old作用于老年代，采用标记-整理算法</p>
<p>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成。</p>
</li>
</ul>
</li>
<li><p><strong>CMS(并发)垃圾收集器</strong></p>
<p>CMS全称 Concurrent Mark Sweep，是一款<strong>并发</strong>的、使用<strong>标记-清除</strong>算法的垃圾回收器，该回收器是<strong>针对老年代垃圾回收的</strong>，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行</p>
</li>
<li><p><strong>G1垃圾收集器</strong></p>
<p>作用在新生代和老年代</p>
</li>
</ul>
<p><span style = "color:red"><strong>详细聊一下G1垃圾回收器</strong></span></p>
<ul>
<li>应用于新生代和老年代，<strong>在JDK9之后默认使用G1</strong></li>
<li>划分成多个区域，每个区域都可以充当<strong>eden，survivor，old，humongous</strong>，其中<code>humongous</code>专为大对象准备</li>
<li>采用复制算法</li>
<li>响应时间与吞吐量兼顾</li>
<li>分成三个阶段：新生代回收(STW)、并发标记(重新标记STW)、混合收集</li>
<li>如果并发失败(即回收速度赶不上创建新对象速度)，就会触发<code>Full GC</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1a968a17f25b1bbd6bdde1c89b08cb064802b868/%E8%AF%A6%E7%BB%86%E8%81%8A%E4%B8%80%E4%B8%8BG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
<p><span style = "color:red"><strong>强引用、软引用、弱引用、虚引用的区别</strong></span></p>
<blockquote>
<p><strong>强引用</strong>：只要所有 GC Roots 能找到，就不会被回收<br><strong>软引用</strong>：需要配合<code>SoftReference</code>使用，当垃圾多次回收，内存依然不够时候会回收软引用对象<br><strong>弱引用</strong>：需要配合<code>WeakReference</code>使用，只要进行了垃圾回收，就会把引用对象回收<br><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</p>
</blockquote>
<ul>
<li><strong>强引用</strong>：只有所有 <code>GCRoots</code> 对象都不通过【强引用】 引用该对象，该对象才能被垃圾回收</li>
</ul>
<pre><code class="java">User user = new User();
</code></pre>
<p>  <u>GC Root → User对象</u></p>
<ul>
<li><strong>软引用</strong>：仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足</strong>时会再次触发垃圾回收</li>
</ul>
<pre><code class="java">User user = new User();
SoftReference softReference = new SoftReference(user);
</code></pre>
<p>  <u>GC Root → SoftReference对象 →→<del>虚线</del> User对象</u><br>  一开始并不会对User对象进行回收 此时User对象就是软引用 如果内存还是不够 马上又再次进行了垃    圾回收 此时软引用的User就会被回收</p>
<ul>
<li><strong>弱引用</strong>：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
</ul>
<pre><code class="java">User user = new User();
WeakReference weakReference = new WeakReference(user)
</code></pre>
<p>  <u>GC Root → WeakReference对象 →→<del>虚线</del> User对象</u></p>
<blockquote>
<p>延申话题：ThreadLocal内存泄露问题</p>
<pre><code class="java">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;&#123;
    Object value;
    Entry(ThreadLocal&lt;?&gt;k, Object v)&#123;
        super(k); // k是弱引用
        value = v; // 强引用，不会被回收
    &#125;
&#125;
</code></pre>
</blockquote>
<ul>
<li><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</li>
</ul>
<pre><code class="java">User user = new User();
ReferenceQueue referenceQueue = new ReferenceQueue();
PhantomReference phantomReference = new PhantomReference(user, queue);
</code></pre>
<p><span style = "color:red"><strong>JVM调优的参数可以在哪里设置？</strong></span></p>
<ul>
<li><p><code>war包</code>部署在<code>tomcat</code>中设置</p>
<p>修改 <code>TOMCAT_HOME/bin/catalina.sh</code> 文件<br><code>D:\apache-tomcat-8.5.93\bin\catalina.sh</code></p>
<pre><code class="mysql"># OS specific support.  $var _must_ be set to either true or false.
JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot;
cygwin=false
darwin=false
os400=false
hpux=false
</code></pre>
</li>
<li><p><code>jar包</code>部署在<code>启动参数</code>设置</p>
<p>通常在linux系统下直接加参数启动SpringBoot项目<del>—VM</del></p>
<p><code>nohup java -Xms512m -Xmx1024n -jar xxxx.jar --spring.profiles.active=prod &amp;</code></p>
</li>
</ul>
<p><strong>nohup</strong>：用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行<br>**参数<code>&amp;</code>**：让命令在后台执行，终端退出后命令仍然执行</p>
<p><span style = "color:red"><strong>JVM调优的参数都有哪些？</strong></span></p>
<p>对于JVM调优，主要就是调整 <code>年轻代、老年代、元空间</code> 的内存大小及使用的垃圾回收器类型</p>
<ul>
<li><p><strong>设置堆空间大小</strong></p>
<p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p>
<pre><code class="java">-Xms: 设置堆的初始化大小
-Xmx: 设置堆的最大大小
// 不指定单位默认为字节
-Xms：1024
-Xms：1024k
</code></pre>
<p>堆内存设置多少合适？</p>
<ul>
<li>最大大小的默认值是物理内存的1&#x2F;4，<strong>初始大小是物理内存的1&#x2F;64</strong><del>【不设置的情况下】</del></li>
<li>堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生STW，暂停用户线程</li>
<li>堆内存大肯定是好的，存在风险，假如发生了fullgc，它会扫描整个堆空间，暂停用户线程的时间长</li>
</ul>
</li>
<li><p><strong>虚拟机栈的设置</strong></p>
<p>虚拟机栈的设置：<strong>每个线程默认会开启1M的内存</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>
<p><code>-Xss 对每个线程stack大小的调整，-Xss128k</code></p>
</li>
<li><p><strong>年轻代中Eden区和两个Survivor区的大小比例</strong></p>
<p>设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。通过增大Eden区的大小来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p>
<p><code>-XXSurvivorRatio=8，表示年轻代中的分配比率：survivor:eden = 2:8</code></p>
</li>
<li><p><strong>年前代晋升老年代阈值</strong>【默认值为15，取值范围0-15】</p>
<p><code>-XX:MaxTenuringThreshold=threshold</code></p>
</li>
<li><p><strong>设置垃圾回收收集器</strong></p>
<p>通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器</p>
<p><code>-XX:+UseParallelGC</code><br><code>-XX:+UseParallelOldGC</code></p>
<p><code>-XX:+UserG1GC</code></p>
</li>
</ul>
<p><span style = "color:red"><strong>JVM调优的参数都有哪些？</strong></span></p>
<ul>
<li><p><strong>命令工具</strong></p>
<ul>
<li><p><strong>jps</strong> 进程状态信息</p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
</li>
<li><p><strong>jmap</strong> 查看堆栈信息[生成堆转内存快照,内存使用信息]</p>
<pre><code class="java">jmap -head pid 显示Java堆的信息
jmap -dump:format=b,file=heap.hprof pid
</code></pre>
<ul>
<li><p>format&#x3D;b 表示以hprof二进制格式存储Java堆的内存</p>
</li>
<li><p>file&#x3D;&lt; filename  &gt; 用于指定快照dump文件的文件名</p>
<p><code>dump</code>：它是我们都可以通过工个进程或系统在某一给定的时间的快照。比如在进程崩溃时，甚至是任何时候，具将系统或某进程的内存备份出来供调试分析用，dump文件中包含了程序运行的模块信息、线程信息、堆调用信息、异常信息等数据，方便系统技术人品进行错误排查</p>
</li>
</ul>
</li>
<li><p><strong>jhat</strong> 堆转储快照分析工具</p>
</li>
<li><p><strong>jstat</strong> JVM统计监测工具[可以用来显示垃圾回收信息、类加载信息、新生代统计信息等]</p>
<ul>
<li>总结垃圾回收统计：<code>jstat -gcutil pid</code></li>
<li>垃圾回收统计：<code>jstat -gc pid</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可视化工具</strong></p>
<ul>
<li><strong>jconsole</strong> 用于对jvm的内存，线程，类的监控, 是一个可视化工具<br><code>D:\java\jdk-11.0.20\bin\jconsole.exe</code></li>
<li><strong>VisualVM</strong> 能够监控线程，内存情况<del>只有jdk1.8有</del><br><code>D:\java\jdk1.8.0_181\bin\jvisualvm.exe</code></li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>Java内存泄露的排查思路？</strong></span></p>
<blockquote>
<p>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况<br>1、通过jmap或设置jvm参数获取堆内存快照dump<br>2、通过工具，VisualVM去分析dump文件，VisualVM可以加载离线的dump文件<br>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题<br>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
</blockquote>
<p>JVM  Stacks <strong>虚拟机栈</strong> → <code>StackOverFlowError</code><br>Heap <strong>堆</strong> → <code>OutOfMemoryError：java heap space</code><br>Method Are&#x2F; MateSpace <strong>方法区&#x2F;元空间</strong> → <code>OutOfMemoryError: Metaspace</code></p>
<p>模拟堆空间溢出场景：-VM设置参数 → <code>-Xmx10m</code></p>
<pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
while(true)&#123;
    list.add(&quot;北京&quot;);
&#125;
-------------------------------------------
// OutOfMemoryError：java heap space
</code></pre>
<h6 id="如何排查启动闪退、运行一段时间宕机"><a href="#如何排查启动闪退、运行一段时间宕机" class="headerlink" title="如何排查启动闪退、运行一段时间宕机"></a>如何排查启动闪退、运行一段时间宕机</h6><ul>
<li><p>获取堆内存快照dump</p>
<ul>
<li>使用jmap命令获取运行中程序的dump文件<del>【只有在项目运行时候才可以用】</del></li>
</ul>
<pre><code class="java">jmap -head pid 显示Java堆的信息
jmap -dump:format=b,file=heap.hprof pid 【只有在项目运行时候才可以用】
</code></pre>
<ul>
<li><p><strong>使用vm参数获取dump文件</strong></p>
<p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式生成dump文件</p>
</li>
</ul>
<pre><code class="java">-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/home/app/dumps/
</code></pre>
</li>
<li><p>VisualVM区分析dump文件</p>
</li>
<li><p>通过查看堆内存的信息，定位内存溢出问题</p>
</li>
</ul>
<p><span style = "color:red"><strong>CPU飙高排查方案与思路？</strong></span></p>
<blockquote>
<p>1.使用top命令查看占用cpu的情况<br>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>3.使用ps命令查看进程中的线程信息<br>4.使用jstack命令查看进程中哪些线程出现了问题，最终定位问题</p>
</blockquote>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程转换十六进程<br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><span style = "color:red">设计模式</span></h2><h5 id="框架中的设计模式-项目中的设计模式"><a href="#框架中的设计模式-项目中的设计模式" class="headerlink" title="框架中的设计模式 + 项目中的设计模式"></a>框架中的设计模式 + 项目中的设计模式</h5><p><span style = "color:red"><strong>简单工厂模式</strong></span></p>
<p>简单工厂包含如下角色</p>
<ul>
<li><strong>抽象产品</strong>：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li><strong>具体产品</strong> ：实现或者继承抽象产品的子类</li>
<li><strong>具体工厂</strong>：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<p>需求：设计一个咖啡店点餐系统。<br>设计一个咖啡类(Coffee)，并定义其两个子类(美式咖啡【AmericanCofee】和拿铁咖啡【LatteCoffee】); 再设计一个咖啡店类(CoffeeStore)，咖啡店具有点咖啡的功能。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d91b96f4466457e253dd9a8b298f99c098e4501c/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<p><span style = "color:red"><strong>工厂方法模式</strong></span><del>完全遵循开闭原则</del></p>
<p>方法模式的主要角色:<br><strong>抽象工厂</strong>(Abstract Factory)：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。<br><strong>具体工厂</strong>(ConcreteFactory)：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。<br><strong>抽象产品</strong>(Product)：定义了产品的规范，描述了产品的主要特性和功能。<br><strong>具体产品</strong>(ConcreteProduct)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一 一对应。</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/55e41a4a745af324a0d0a18d0af0694fb0d319e9/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" style="zoom: 67%;" />



<p><span style = "color:red"><strong>抽象工厂模式</strong></span></p>
<p>工厂方法模式只考虑生产同等级的产品，抽象工厂可以处理等级产品的生产<br>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产–个等级的产品，而抽象工厂模式可生产多个等级的产品<strong>。一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dc778be8350e592f74d23beeee7c256826204f4/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<p><span style = "color:red"><strong>策略模式</strong></span></p>
<ul>
<li>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</li>
<li>它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</li>
</ul>
<p>策略模式的主要角色如下:<br><strong>抽象策略(Strategy)类</strong>：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口<br><strong>具体策略(Concrete Strategy)类</strong>：实现了抽象策略定义的接口，提供具体的算法实现或行为。<br><strong>环境(Context)类</strong>：持有一个策略类的引用，最终给客户端调用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b29eac1685bcdf60e7adde25286c276ddbeb43a7/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F+%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA.png"></p>
<h4 id="策略模式—登录案例-工厂模式-策略模式"><a href="#策略模式—登录案例-工厂模式-策略模式" class="headerlink" title="策略模式—登录案例 (工厂模式 + 策略模式)"></a><span style = "color:red"><strong>策略模式—登录案例 (工厂模式 + 策略模式)</strong></span></h4><blockquote>
<ul>
<li><p>什么是策略模式</p>
<ul>
<li><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</p>
</li>
<li><p>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中</p>
</li>
</ul>
</li>
<li><p>案例(工厂方法+策略)</p>
<ul>
<li>介绍业务(登录、支付、解析excel、优惠等级…)</li>
<li>提供了很多种策略，都让spring容器管理</li>
<li>提供一个工厂：准备策略对象，根据参数提供对象</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>一句话总结</strong>：只要代码中有冗长的if-else 或switch 分支判断都可以采用策略模式优化</p>
<p><span style = "color:blue"><strong>举一反三</strong></span></p>
<ul>
<li>订单的支付策略(支付宝、微信、银行卡..)</li>
<li>解析不同类型excel(xls格式、xlsx格式)</li>
<li>打折促销(满300元9折、满500元8折、满1000元7折..)</li>
<li>物流运费阶梯计算(5kg以下、5-10kg、10-20kg、20kg以上)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/69c802f411142a1bdabf991a27b8a48662cc8ca9/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E6%8B%9F.png" alt="策略模式和工厂方法模拟.png"></p>
<p><span style = "color:red"><strong>责任链模式—概述及案例</strong></span></p>
<p>责任链模式：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<ul>
<li><strong>抽象处理者(Handler)角色</strong>：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li><strong>具体处理者(Concrete Handler)角色</strong>：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li><strong>客户类(Cient)角色</strong>：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<p><span style = "color:blue"><strong>举一反三</strong></span></p>
<ul>
<li>内容审核(视频、文章、课程)</li>
<li>订单创建</li>
<li>简易流程审批</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c73c212f673d69975c55ad134b045e433a6f1e23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F2.png"></p>
<h3 id="常见技术场景题"><a href="#常见技术场景题" class="headerlink" title="常见技术场景题"></a><span style = "color:red">常见技术场景题</span></h3><h6 id="单点登录这块怎么实现的？"><a href="#单点登录这块怎么实现的？" class="headerlink" title="单点登录这块怎么实现的？"></a><span style = "color:red">单点登录这块怎么实现的？</span></h6><p>单点登录的英文名：Single Sign On (<strong>SSO</strong>)，只需要登录一次，就可以访问所有信任的应用系统</p>
<p>① 先解释什么是单点登录：单点登录的英文名叫做:Single SignOn(简称SSO)<br>② 介绍自己项目中涉及到的单点登录(即使没涉及过，也可以说实现的思路)<br>③ 介绍单点登录的解决方案，以JWT为例<br>    用户访问其他系统，会在网关判断token是否有效<br>    如果token无效则会返回401(认证失败)前端跳转到登录页面<br>    用户发送登录请求，返回浏览器一个token，浏览器把token保存到cookie<br>    再去访问其他服务的时候，都需要携带token，由网关统一验证后路由到目标服务</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b3389992651a50673831641a3ae5dd61aa8e344a/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%BF%99%E5%9D%97%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.png"></p>
<h6 id="权限认证是如何实现的？"><a href="#权限认证是如何实现的？" class="headerlink" title="权限认证是如何实现的？"></a><span style = "color:red">权限认证是如何实现的？</span></h6><p>后台的管理系统，更注重权限控制，最常见的就是<strong>RBAC</strong>模型来指导实现权限<br>RBAC(Role-Based Access Control)基于角色的访问控制</p>
<ul>
<li>3个基础部分组成：<strong>用户、角色、权限</strong></li>
<li>具体实现：<ul>
<li>5张表：<strong>用户表、角色表、权限表、用户角色中间表、角色权限中间表</strong></li>
<li>7张表：<strong>用户表、角色表、权限表、菜单表、用户角色中间表、角色权限中间表、权限菜单中间表</strong></li>
</ul>
</li>
</ul>
<p>张三具有什么权限呢？<br>流程：张三登录系统 → 查询张三拥有的角色列表 → 再根据角色查询拥有的权限</p>
<p>权限框架：<code>Apache shiro</code>、<code>Spring Security（推荐）</code><br><img src="https://raw.githubusercontent.com/P-luminary/images/ed40dce8c09b42689021c6ee66a4565a314acc69/RBAC%E6%A8%A1%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<h6 id="上传数据的安全性你们怎么控制？"><a href="#上传数据的安全性你们怎么控制？" class="headerlink" title="上传数据的安全性你们怎么控制？"></a><span style = "color:red">上传数据的安全性你们怎么控制？</span></h6><p>主要说的是数据在网络上传输如何保证安全</p>
<p>使用**非对称加密(或对称加密)**，给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据</p>
<h6 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h6><p>文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9886840e455bef1ee39b93c8c75495b6e80fe6fb/%E5%AF%B9%E7%A7%B0+%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png"></p>
<h6 id="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1-3"><a href="#你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1-3" class="headerlink" title="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1+3"></a><span style = "color:red">你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？</span><del>1+3</del></h6><blockquote>
<p>其次你也可以说说aop的实现，比如你们操作日志记录等，利用aop切面思想，通过环绕通知等但需封装出出个切面工具类。建议你们说说sql调优，比如商品列表页需要分页查询，但是几百万商品导致查询慢，如何优化的，这是一个</p>
</blockquote>
<h6 id="①-设计模式在项目中的应用"><a href="#①-设计模式在项目中的应用" class="headerlink" title="① 设计模式在项目中的应用"></a><span style = "color:blue">① 设计模式在项目中的应用</span></h6><p>是为了遵循一系列的开发原则【工厂、策略、责任链】</p>
<ul>
<li>什么背景[技术问题] → 登录的例子</li>
<li>过程[解决问题的过程]</li>
<li>最终落地方案</li>
</ul>
<h6 id="②-线上BUGJVM-多线程"><a href="#②-线上BUGJVM-多线程" class="headerlink" title="② 线上BUGJVM+多线程"></a><span style = "color:blue">② 线上BUG<del>JVM+多线程</del></span></h6><ul>
<li>CPU飙高</li>
<li>内存泄露</li>
<li>线程死锁</li>
</ul>
<h6 id="③-调优"><a href="#③-调优" class="headerlink" title="③ 调优"></a><span style = "color:blue">③ 调优</span></h6><ul>
<li>慢接口</li>
<li>慢SQL</li>
<li>缓存方案</li>
</ul>
<p><span style = "color:blue"><strong>④ 组件封装</strong></span></p>
<ul>
<li>分布式锁</li>
<li>接口幂等</li>
<li>分布式事务</li>
<li>支付通用</li>
</ul>
<h6 id="你们项目中日志怎么采集的？"><a href="#你们项目中日志怎么采集的？" class="headerlink" title="你们项目中日志怎么采集的？"></a><span style = "color:red">你们项目中日志怎么采集的？</span></h6><blockquote>
<p>我们搭建了ELK日志采集系统<br>介绍ELK的三个组件:<br><strong>Elasticsearch</strong>是全文搜索分析引擎，可以对数据存储、搜索、分析<br><strong>Logstash</strong>是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置<br><strong>Kibana</strong>是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示</p>
</blockquote>
<ul>
<li><strong>为什么要采集日志</strong>？</li>
</ul>
<p>日志是定位系统问题的重要手段，可以根据日志信息快速定位系统中的问题</p>
<ul>
<li><strong>采集日志的方式有哪些</strong><ul>
<li><span style = "color:orange"><strong>ELK</strong>：即<code>ElasticSearch、LogStash、Kibanna</code>三个软件的首字母</span></li>
<li><strong>常规采集</strong>：按天保存到一个日志文件</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b737bd7a31bb44363954ebefe0f32095096a3793/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E6%80%8E%E4%B9%88%E9%87%87%E9%9B%86%E7%9A%84.png"></p>
<h6 id="查看日志的命令？查看是否在线查看过日志"><a href="#查看日志的命令？查看是否在线查看过日志" class="headerlink" title="查看日志的命令？查看是否在线查看过日志"></a><span style = "color:red">查看日志的命令？</span><del>查看是否在线查看过日志</del></h6><ul>
<li><p><strong>实时监控日志的变化</strong><br>实时监控某一个日志文件的变化：<code>tail -f xx.log</code><br>实时监控日志文件最后100行的变化：<code>tail -n 100 -f xx.log</code></p>
</li>
<li><p><strong>按照行号查询</strong><br>查询日志尾部最后100行日志：<code>tail -n 100 xx.log</code><br>查询日志头部开始100行日志：<code>head -n 100 xx.log</code><br>查询某一个日志行号区间：<code>cat -n xx.log | tail -n +100 | head -n 100</code>(查询100行至200行的日志)</p>
</li>
<li><p><strong>按照关键字找日志的信息</strong><br>查询日志文件中包含debug的日志行号：<code>cat -n xx.log | grep &quot;debug&quot;</code></p>
</li>
<li><p><strong>按照日期查询</strong><del>日期必须在日志中出现过</del></p>
<p><code>sed -n &#39;/2025-01-14 14:22:31.070/,/ 2025-01-14 14:27:18.158/p&#39; xx.log</code></p>
</li>
<li><p><strong>日志太多，处理方式</strong></p>
<ul>
<li>分页查询日志信息：<code>cat -n xx.log | grep &quot;debug&quot; | more</code></li>
<li>筛选过滤后，输出到一个文件：<code>cat -n xx.log | grep &quot;debug&quot; &gt; debug.txt</code></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9ee9064d3f9fa8ae290a4ccfe1da9af84b88e584/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4.png"></p>
<h6 id="上线的项目远程Debug-——-生产问题怎么排查？本地调试远程代码"><a href="#上线的项目远程Debug-——-生产问题怎么排查？本地调试远程代码" class="headerlink" title="上线的项目远程Debug —— 生产问题怎么排查？本地调试远程代码"></a><span style = "color:red">上线的项目远程Debug —— 生产问题怎么排查？</span><del>本地调试远程代码</del></h6><p>已经上线的bug排查的思路:</p>
<ul>
<li>先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题</li>
<li>远程debug(通常公司的正式环境(生产环境)是<strong>不允许远程debug的</strong>。一般远程debug都是公司的测试环<br>境，方便调试代码)</li>
</ul>
<p><strong>远程debug</strong></p>
<p>前提条件：<strong>远程的代码和本地的代码要保持一致</strong></p>
<p><strong>①</strong> 远程代码需要配置启动参数，把项目打包放到服务器后启动项目的参数：</p>
<p><code>java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 project-1.0-SNAPSHOT.jar</code></p>
<p><strong>②</strong> idea中设置远程debug，找到idea中的<code>Edit Configurations...</code> → 添加一个<code>Remote JVM debug</code> → 右侧要配置<code>Configuration</code>的Host → 添加上面的代码…</p>
<p><strong>③</strong> 在项目中点debug(绿色小虫子)</p>
<p><strong>④</strong> 访问远程服务器，在本地代码中打断点即可调试远程</p>
<p><span style = "color:red"><strong>怎么快速定位系统的瓶颈？</strong></span></p>
<ul>
<li><p>压测(性能测试)，<strong>项目上线之前测评系统的压力</strong></p>
<ul>
<li>压测目的：给出系统当前的性能状况;定位系统性能瓶颈或潜在性能瓶颈</li>
<li>指标：响应时间、QPS、并发数、吞吐量、CPU利用率、内存使用率、磁盘IO、错误率</li>
<li>压测工具：LoadRunner、Apache Jmeter …</li>
<li>后端工程师：根据压测的结果进行解决或调优(接口、代码报错、并发达不到要求.)</li>
</ul>
</li>
<li><p>监控工具、链路追踪工具，<strong>项目上线之后监控</strong></p>
<ul>
<li>监控工具：Prometheus+Grafana</li>
<li>链路追踪工具：skywalking、Zipkin</li>
</ul>
</li>
<li><p>线上诊断工具Arthas(阿尔萨斯)，<strong>项目上线之后监控、排查</strong></p>
<ul>
<li><p>官网：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></p>
</li>
<li><p>核心功能:Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。<br>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决:</p>
<ul>
<li><p>这个类从哪个jar 包加载的?为什么会报各种类相关的 Exception?</p>
</li>
<li><p>我改的代码为什么没有执行到?难道是我没 commit?分支搞错了?</p>
</li>
<li><p>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗?</p>
</li>
<li><p>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现!</p>
</li>
<li><p>是否有一个全局视角来查看系统的运行状况?</p>
</li>
<li><p>有什么办法可以监控到 JVM 的实时运行状态?</p>
</li>
<li><p>怎么快速定位应用的热点，生成火焰图?</p>
</li>
<li><p>怎样直接从 JVM 内查找某个类的实例?</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>怎么解决cpu飙高?</strong></span></p>
<p>使用top命令查看占用cpu的情况<br>通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>使用ps命令查看进程中的线程信息    使用<code>top -H -p 进程Id</code> [找线程哪个使用多]<br>记住要打印<code>%X十六进制</code>的<br>使用jstack命令查看进程中哪些线程出现了问题，最终定位问题<br><code>jstack 进程PID | grep 16进制线程PID -A 20</code></p>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程<strong>转换十六进程</strong><br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>
<h3 id="2025-x2F-1-x2F-14-20-35-地点广州-完结撒花"><a href="#2025-x2F-1-x2F-14-20-35-地点广州-完结撒花" class="headerlink" title="2025&#x2F;1&#x2F;14 20:35 地点广州 完结撒花"></a><span style = "color:red">2025&#x2F;1&#x2F;14 20:35 地点广州 完结撒花</span></h3><p><span style = "color:red"><strong>秒杀系统如何优化？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/96a974e196f2d93a561775732ddf415ee4b401cd/%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF.png"></p>
<h6 id="痛点描述："><a href="#痛点描述：" class="headerlink" title="痛点描述："></a>痛点描述：</h6><ul>
<li><strong>瞬时并发量大</strong><ul>
<li>大量用户会在同一时间进行抢购</li>
<li>网站瞬时访问流量激增</li>
</ul>
</li>
<li><strong>库存少</strong><ul>
<li>访问请求数量远远大于库存数量</li>
<li>只有少部分用户能够秒杀成功</li>
</ul>
</li>
</ul>
<p><strong>Ⅰ. 访问层 — 商品页</strong></p>
<ul>
<li>可以将<strong>静态秒杀页面</strong>放在cdn上[用户访问速度↑   减轻服务器压力++]</li>
</ul>
<p><strong>Ⅱ. 访问层 — 秒杀按钮</strong></p>
<ul>
<li>活动前禁用按钮、点击后禁用按钮、滑动验证码[防羊毛党]、排队体验[提升用户体验]</li>
</ul>
<p><strong>Ⅲ. 中间转换层 — 多级负载均衡 &amp; 限流 &amp; 自动伸缩</strong></p>
<ul>
<li>通常会通过Nginx来进行负载均衡【单台Ng处理的并发量是两三万左右】</li>
<li>在它上层要做到硬件级别的隔离器 【F5&#x2F;LVS】</li>
<li>通过Ng负载均衡到网关之后 通过客户端的负载均衡器Ribbon</li>
<li>4级的负载均衡 可以处理每秒上10W以上的QPS并发量</li>
<li>通过<strong>Docker</strong>或<strong>K8S</strong>来进行云服务器的<strong>动态伸缩</strong>的部署[秒杀开始自动扩容 秒杀结束自动缩减]</li>
<li>注意要在Ng上做好限流 防止一些绕过了我们前端的DDOS攻击 还需要在网关层通过<code>Sentinel</code>对不同的服务节点去设置限流以及熔断的机制</li>
<li>可以在秒杀中通过MQ做削锋填股 通过MQ可以减轻下游的压力 防止激增流量打垮下游数据库</li>
</ul>
<p><strong>Ⅳ. 服务端 — 用Redis做缓存减轻数据库压力</strong></p>
<ul>
<li>秒杀商品信息预热到Redis中 防止Redis被击穿我们的数据库</li>
<li>通过Redis的<strong>Lua脚本</strong>[保证多个操作的原子性]操作库存</li>
<li>防重 可以通过 redis的SETNX → 用 <strong><u>Token + 商品URL</u></strong> &#x2F;&#x2F; <strong><u>IP + 商品URL</u></strong> 只能有一个有效</li>
<li>分布式锁保证请求的原子性 → Redisson的分布式锁</li>
</ul>
<p>**Ⅴ. 数据库 — 读写分离 **</p>
<ul>
<li>数据量很大就分库分表</li>
</ul>
<p><span style = "color:red"><strong>订单超时自动取消是怎么实现的？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/743d8b7cd78b5a1fe4023554fee8d62726435cb2/%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88.png"></p>
<h5 id="①-JDK自带的延时队列"><a href="#①-JDK自带的延时队列" class="headerlink" title="① JDK自带的延时队列"></a>① JDK自带的延时队列</h5><p><strong>优点</strong>：简单，不需要借助其他第三方组件，成本低。<br><strong>缺点</strong>：所有超时处理订单都要加入到<code>DelayQueue</code>中，占用内存大，没办法做到分布式处理，之恶能在集群中挑选一台leader专门处理，效率低<br>不适合订单量比较大的</p>
<h5 id="②-基于RocketMQ的定时消息-—-延时消息"><a href="#②-基于RocketMQ的定时消息-—-延时消息" class="headerlink" title="② 基于RocketMQ的定时消息 — 延时消息"></a>② 基于RocketMQ的定时消息 — 延时消息</h5><p><strong>优点</strong>：使用简单，和使用普通消息一样，支持分布式。精度高，支持任意时刻</p>
<p><strong>缺点</strong>：<strong>使用限制</strong>：定时时长最大值24小时。<br><strong>成本高</strong>：每个订单需要新增一个定时消息，且不会马上消费，给MQ带来很大的存储成本。<br>同一个时刻大量消息会导致<u>消息延迟:</u>定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p>
<h5 id="③-基于Redis的过期监听"><a href="#③-基于Redis的过期监听" class="headerlink" title="③ 基于Redis的过期监听"></a>③ 基于Redis的过期监听</h5><p>设置过期时间：24小时内没有支付就会自动取消<br><strong>缺点</strong>：(也是所有中间件的缺点)</p>
<ul>
<li>不可靠 Redis在过期通知的时候，如果应用<strong>正好重启了</strong>，那么就有可能<strong>通知事件就丢了，会导致订单一直无法关闭</strong>，有稳定性问题。如果一定要使用Redis过期监听方案，建议再通过定时任务做补偿机制。</li>
<li>如果订单量大需要占用中间件大量的存储空间，需要额外维护成本。</li>
</ul>
<h5 id="④-定时任务分布式处理【要按照成本思维的思考方式】"><a href="#④-定时任务分布式处理【要按照成本思维的思考方式】" class="headerlink" title="④ 定时任务分布式处理【要按照成本思维的思考方式】"></a>④ 定时任务分布式处理【要按照成本思维的思考方式】</h5><p>通过定时任务(任务调度)的批量处理 → 一次性把所有超时的订单全部捞出来 处理完再全部执行更新<br>如果使用中间件都要单独存储那些数据，如果存储压力大就要涉及到集群</p>
<blockquote>
<p>如果对于超时精度比较高，超时时间在24小时内，且不会有峰值压力的场景下，推荐使用RocketMQ的定时消息解决方案<br>在电商业务下，许多订单超时场景都在24小时以上，对于超时精度没那么敏感，并且有海量订单需要批处理，推荐使用基于定时任务的<strong>跑批</strong>解决方案。</p>
</blockquote>
<p><span style = "color:red"><strong>如何防止重复下单？</strong></span></p>
<h5 id="方案一：提交订单按钮置灰-防止用户无意点击多次"><a href="#方案一：提交订单按钮置灰-防止用户无意点击多次" class="headerlink" title="方案一：提交订单按钮置灰 [防止用户无意点击多次]"></a>方案一：提交订单按钮置灰 [防止用户无意点击多次]</h5><h5 id="方案二：后端采用redis的setnx-来保证它的唯一幂等性"><a href="#方案二：后端采用redis的setnx-来保证它的唯一幂等性" class="headerlink" title="方案二：后端采用redis的setnx 来保证它的唯一幂等性"></a>方案二：后端采用redis的<span style = "color:red">setnx</span> 来保证它的唯一幂等性</h5><p>setnx：当我们调用setnx来去保存一个key和value的时候，如果这个value没有值的话，那么就会返回<strong>true</strong>保存成功；如果有值就会返回<strong>false</strong> → 保证多次存储只能存储一个值</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/be8debbe9711d790569ea62e3954dca9e6f2937b/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E4%B8%8B%E5%8D%95.png"></p>
<p><span style = "color:red"><strong>怎么防止刷单？【人肉机刷单！！】</strong></span></p>
<h5 id="业务风控"><a href="#业务风控" class="headerlink" title="业务风控"></a>业务风控</h5><p>提高羊毛门槛:实名认证、消费门槛、随机优惠<br>限制用户参与、中奖、奖励次数<br>根据用户的历史行为和忠诚度，提供不同层次的优惠，优待忠实用户<br>奖池(优惠券数量)限制上限</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3850683ae318970983834aa03ac35168bbf52a8/%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E4%BA%BA%E8%82%89%E5%88%B7%E5%8D%95%EF%BC%9F.png"></p>
<p><span style="color:red"><strong>分布式集群架构下怎么保证并发安全？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/48788978d525bf16e52bb10180e63022de6a5ea3/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%B8%8B%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8.png"></p>
<p><span style = "color:red"><strong>让你设计一个扫码登录怎么实现？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b3bbc19e0da554166000933c31bf749e2f6d3313/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>
<h6 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h6><p>请求登录页生成二维码，PC端请求后端生成一个二维码，此时在后端就会生成一个全局唯一的二维码ID，主要保存二维码的状态[二维码ID, NEW]，状态设置到Redis设置过期时间，然后把当前的二维码ID返回给前端，然后生成二维码 【前后端都可以生成 → 返回Base64的编码给前端】此时的二维码就绑定了用户的ID让用户扫描。</p>
<h6 id="扫码"><a href="#扫码" class="headerlink" title="扫码"></a>扫码</h6><p>PC端和后端会建立一个轮询的请求，不断的根据二维码ID去查询二维码状态，一旦状态改变页面也会改变。也可以通过长连接<strong>WebSocket</strong>获取状态 <code>淘宝用的轮询、抖音用的长连接</code>，此时就可以扫码。<br>扫码前保证手机是登录状态 没有登录肯定是不能扫码的，登录后进行扫码就会携带手机端的用户token以及二维码的ID在后端去校验请求Token，如果校验成功就代表手机可以登录，此时可以变更二维码状态为扫描。前端就可以根据这个把页面变为<code>待确认</code>状态</p>
<p><span style = "color:red"><strong>如何设计分布式日志存储架构？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/38bcadd4a99fd1093a4d7ab6e39c60340bfc73a8/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png"></p>
<p><span style = "color:red"><strong>项目难点？</strong></span><del>四方保险——day11-数据中心：时序数据库、看板展示【实战】</del></p>
<p>技术上的难点：<strong>时序数据库</strong>、<strong>看板展示</strong></p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>