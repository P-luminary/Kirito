
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2025/01/03/后端/ElasticSearch/">
        <h2>
            ElasticSearch
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/1/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>ElasticSearch结合Kibana、Logstash、Beats，核心是elastic stack的核心，负责<strong>存储、搜索、分析数据</strong><br>Lucene的优势：容易扩展、高性能(基于倒排索引)<br>Lucene的缺点：直选与java语言开发<br>ElasticSearch是基于Lucene开发的</p>
<h6 id="Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能"><a href="#Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能" class="headerlink" title="Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能"></a>Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</h6><h4 id="正向索引和倒排索引"><a href="#正向索引和倒排索引" class="headerlink" title="正向索引和倒排索引"></a>正向索引和倒排索引</h4><p>传统数据库是<strong>正向索引</strong></p>
<p><strong>ElasticSearch采用倒排索引</strong>：</p>
<ul>
<li>文档(document)：每条数据就是一个文档</li>
<li>词条(term)：文档按照语义分成词语</li>
</ul>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">title</th>
<th align="center">price</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">小米手机</td>
<td align="center">3499</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">华为手机</td>
<td align="center">4999</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">华为小米充电器</td>
<td align="center">49</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">小米手环</td>
<td align="center">299</td>
</tr>
</tbody></table>
<p>  ↓↓↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓       </p>
<table>
<thead>
<tr>
<th align="center">词条(term)</th>
<th align="center">文档id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">小米</td>
<td align="center">1，3，4</td>
</tr>
<tr>
<td align="center">手机</td>
<td align="center">1，2</td>
</tr>
<tr>
<td align="center">华为</td>
<td align="center">2，3</td>
</tr>
<tr>
<td align="center">充电器</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">手环</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p><strong>过程</strong>：搜索<code>华为手机</code> → 得到：<code>华为</code>、<code>手机</code>两个词条 → 得到每个词条所在文档id：华为:2,3 手机:1,2 → 得到id为1,2,3的文档 → 存入结果集<br><strong>倒排索引</strong>：对文档内容分词，对词条创建索引，并记录词条所在文档的信息。查询时现根据词条查询到文档id，而后获取到文档<br><strong>正排索引</strong>：基于文档id创建索引。查询词条时必须先找到文档，而后判断是否包含词条</p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>ElasticSearch是面向文档存储的，可以是数据库中的一条商品数据，一个订单信息，文档数据会被序列化为json格式后存储在ElasticSearch中<br>在ElasticSearch中</p>
<ul>
<li>**索引(index)**：相同类型的文档的集合</li>
<li>**映射(mapping)**：索引中文档的字段约束信息，类似表的结构约束</li>
</ul>
<h6 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h6><table>
<thead>
<tr>
<th align="center">MySQL</th>
<th align="center">ElasticSearch</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Table</td>
<td align="center">Index</td>
<td align="center">索引(index)，就是文档的集合，类似于数据库的表(table)</td>
</tr>
<tr>
<td align="center">Row</td>
<td align="center">Document</td>
<td align="center">文档(Document)，就是一条条的数据，类似数据库中的行(Row)，文档都是JSON格式</td>
</tr>
<tr>
<td align="center">Column</td>
<td align="center">Field</td>
<td align="center">字段(Field)，就是JSON文档中的字段，类似数据库中的列(Column)</td>
</tr>
<tr>
<td align="center">Schema</td>
<td align="center">Mapping</td>
<td align="center">Mapping(映射)，就是索引中文档的约束，例如字段类型约束。类似数据库的表结构(Schema)</td>
</tr>
<tr>
<td align="center">SQL</td>
<td align="center">DSL</td>
<td align="center">DSL是ElasticSearch提供的JSON风格的请求语句，用来操作ElasticSearch，实现CRUD</td>
</tr>
</tbody></table>
<h6 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h6><p><strong>MySQL</strong><del>写操作</del>：擅长事务类型操作，可以确保数据的安全和一致性<br><strong>ElasticSearch</strong><del>查询</del>：擅长海量数据的搜索、分析、计算<br>[<strong><u>可以互补达到数据双写一致性</u></strong>]</p>
<h2 id="1-1-创建网络"><a href="#1-1-创建网络" class="headerlink" title="1.1.创建网络"></a>1.1.创建网络</h2><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络（创建过的不用再创建）：</p>
<pre><code class="sh">docker network create es-net
</code></pre>
<h2 id="1-2-加载镜像"><a href="#1-2-加载镜像" class="headerlink" title="1.2.加载镜像"></a>1.2.加载镜像</h2><p>这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。</p>
<p>课前资料提供了镜像的tar包：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210510165308064.png" alt="image-20210510165308064"></p>
<p>大家将其上传到虚拟机中，然后运行命令加载即可：</p>
<pre><code class="sh"># 导入数据
docker load -i es.tar
</code></pre>
<p>同理还有<code>kibana</code>的tar包也需要这样做。</p>
<h2 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3.运行"></a>1.3.运行</h2><p>运行docker命令，部署单点es：</p>
<pre><code class="sh">docker run -d \
    --name es \
    -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \
    -e &quot;discovery.type=single-node&quot; \
    -v es-data:/usr/share/elasticsearch/data \
    -v es-plugins:/usr/share/elasticsearch/plugins \
    --privileged \
    --network es-net \
    -p 9200:9200 \
    -p 9300:9300 \
elasticsearch:7.12.1
</code></pre>
<p>命令解释：</p>
<ul>
<li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li>
<li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li>
<li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li>
<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li>
<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li>
<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li>
<li><code>--privileged</code>：授予逻辑卷访问权</li>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中</li>
<li><code>-p 9200:9200</code>：端口映射配置</li>
</ul>
<p>在浏览器中输入：<a target="_blank" rel="noopener" href="http://192.168.xxx.xxx:9200/">http://192.168.xxx.xxx:9200</a> 即可看到elasticsearch的响应结果：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506101053676.png" alt="image-20210506101053676"></p>
<h1 id="2-部署kibana"><a href="#2-部署kibana" class="headerlink" title="2.部署kibana"></a>2.部署kibana</h1><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p>
<h2 id="2-1-部署"><a href="#2-1-部署" class="headerlink" title="2.1.部署"></a>2.1.部署</h2><p>运行docker命令，部署kibana，同理先加载镜像： docker load -i kibana.tar，然后启动：</p>
<pre><code class="sh">docker run -d \
--name kibana \
-e ELASTICSEARCH_HOSTS=http://es:9200 \
--network=es-net \
-p 5601:5601  \
kibana:7.12.1
</code></pre>
<ul>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li>
<li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为<strong>kibana已经与elasticsearch在一个网络</strong>，因此可以用容器名直接访问elasticsearch</li>
<li><code>-p 5601:5601</code>：端口映射配置</li>
</ul>
<p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p>
<pre><code class="sh">docker logs -f kibana
</code></pre>
<p>查看运行日志，当查看到下面的日志，说明成功：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210109105135812.png" alt="image-20210109105135812"></p>
<p>此时，在浏览器输入地址访问：<a href="http://192.168.xxx.xxx:5601，即可看到结果">http://192.168.xxx.xxx:5601，即可看到结果</a></p>
<h6 id="分词效果概览-Dev-Tools-Elastic"><a href="#分词效果概览-Dev-Tools-Elastic" class="headerlink" title="分词效果概览 Dev Tools - Elastic"></a>分词效果概览 <a target="_blank" rel="noopener" href="http://192.168.200.146:5601/app/dev_tools#/console">Dev Tools - Elastic</a></h6><blockquote>
<p>GET &#x2F;_analyze<br>{<br>  “analyzer”: “standard”,<br>  “text”: “黑马程序员”<br>}</p>
</blockquote>
<pre><code class="json">&#123;
  &quot;tokens&quot; : [
    &#123;
      &quot;token&quot; : &quot;黑&quot;,
      &quot;start_offset&quot; : 0,
      &quot;end_offset&quot; : 1,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 0
    &#125;,
    &#123;
      &quot;token&quot; : &quot;马&quot;,
      &quot;start_offset&quot; : 1,
      &quot;end_offset&quot; : 2,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 1
    &#125;,
    &#123;
      &quot;token&quot; : &quot;程&quot;,
      &quot;start_offset&quot; : 2,
      &quot;end_offset&quot; : 3,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 2
    &#125;,
    &#123;
      &quot;token&quot; : &quot;序&quot;,
      &quot;start_offset&quot; : 3,
      &quot;end_offset&quot; : 4,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 3
    &#125;,
    &#123;
      &quot;token&quot; : &quot;员&quot;,
      &quot;start_offset&quot; : 4,
      &quot;end_offset&quot; : 5,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 4
    &#125;
  ]
&#125;
</code></pre>
<p>如果是分析中午就不能用它原有的，存在明显的问题：将中文逐字分词，没有任何业务语义，因此需要借助专业的分词器</p>
<h1 id="3-安装IK分词器"><a href="#3-安装IK分词器" class="headerlink" title="3.安装IK分词器"></a>3.安装IK分词器</h1><h2 id="3-1-在线安装ik插件（较慢）"><a href="#3-1-在线安装ik插件（较慢）" class="headerlink" title="3.1.在线安装ik插件（较慢）"></a>3.1.在线安装ik插件（较慢）</h2><pre><code class="shell"># 进入容器内部
docker exec -it elasticsearch /bin/bash

# 在线下载并安装
./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip

#退出
exit
#重启容器
docker restart elasticsearch
</code></pre>
<h2 id="3-2-离线安装ik插件（推荐）"><a href="#3-2-离线安装ik插件（推荐）" class="headerlink" title="3.2.离线安装ik插件（推荐）"></a>3.2.离线安装ik插件（推荐）</h2><h3 id="1）查看数据卷目录"><a href="#1）查看数据卷目录" class="headerlink" title="1）查看数据卷目录"></a>1）查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p>
<pre><code class="sh">docker volume inspect es-plugins
</code></pre>
<p>显示结果：</p>
<pre><code class="json">[
    &#123;
        &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: null,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;,
        &quot;Name&quot;: &quot;es-plugins&quot;,
        &quot;Options&quot;: null,
        &quot;Scope&quot;: &quot;local&quot;
    &#125;
]
</code></pre>
<p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code>这个目录中。</p>
<h3 id="2）解压缩分词器安装包"><a href="#2）解压缩分词器安装包" class="headerlink" title="2）解压缩分词器安装包"></a>2）解压缩分词器安装包</h3><p>下面我们需要把课前资料中的ik分词器解压缩，重命名为ik</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506110249144.png" alt="image-20210506110249144"></p>
<h3 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a>3）上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data </code>：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506110704293.png" alt="image-20210506110704293"></p>
<h3 id="4）重启容器"><a href="#4）重启容器" class="headerlink" title="4）重启容器"></a>4）重启容器</h3><pre><code class="shell"># 4、重启容器
docker restart es
</code></pre>
<pre><code class="sh"># 查看es日志
docker logs -f es
</code></pre>
<h3 id="5）测试："><a href="#5）测试：" class="headerlink" title="5）测试："></a>5）测试：</h3><p><span style = "color:red"><strong>IK分词器包含两种模式</strong>：</span></p>
<ul>
<li><p><code>ik_smart</code>：最少切分</p>
</li>
<li><p><code>ik_max_word</code>：最细切分</p>
</li>
</ul>
<pre><code class="json">GET /_analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;黑马程序员学习java太棒了&quot;
&#125;
</code></pre>
<p>结果：</p>
<pre><code class="json">&#123;
  &quot;tokens&quot; : [
    &#123;
      &quot;token&quot; : &quot;黑马&quot;,
      &quot;start_offset&quot; : 0,
      &quot;end_offset&quot; : 2,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 0
    &#125;,
    &#123;
      &quot;token&quot; : &quot;程序员&quot;,
      &quot;start_offset&quot; : 2,
      &quot;end_offset&quot; : 5,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 1
    &#125;,
    &#123;
      &quot;token&quot; : &quot;程序&quot;,
      &quot;start_offset&quot; : 2,
      &quot;end_offset&quot; : 4,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 2
    &#125;,
    &#123;
      &quot;token&quot; : &quot;员&quot;,
      &quot;start_offset&quot; : 4,
      &quot;end_offset&quot; : 5,
      &quot;type&quot; : &quot;CN_CHAR&quot;,
      &quot;position&quot; : 3
    &#125;,
    &#123;
      &quot;token&quot; : &quot;学习&quot;,
      &quot;start_offset&quot; : 5,
      &quot;end_offset&quot; : 7,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 4
    &#125;,
    &#123;
      &quot;token&quot; : &quot;java&quot;,
      &quot;start_offset&quot; : 7,
      &quot;end_offset&quot; : 11,
      &quot;type&quot; : &quot;ENGLISH&quot;,
      &quot;position&quot; : 5
    &#125;,
    &#123;
      &quot;token&quot; : &quot;太棒了&quot;,
      &quot;start_offset&quot; : 11,
      &quot;end_offset&quot; : 14,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 6
    &#125;,
    &#123;
      &quot;token&quot; : &quot;太棒&quot;,
      &quot;start_offset&quot; : 11,
      &quot;end_offset&quot; : 13,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 7
    &#125;,
    &#123;
      &quot;token&quot; : &quot;了&quot;,
      &quot;start_offset&quot; : 13,
      &quot;end_offset&quot; : 14,
      &quot;type&quot; : &quot;CN_CHAR&quot;,
      &quot;position&quot; : 8
    &#125;
  ]
&#125;
</code></pre>
<h2 id="3-3-扩展词词典"><a href="#3-3-扩展词词典" class="headerlink" title="3.3 扩展词词典"></a>3.3 扩展词词典</h2><h5 id="注意当前文件的编码必须是-UTF-8-格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑"><a href="#注意当前文件的编码必须是-UTF-8-格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑" class="headerlink" title="注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑"></a><span style = "color:red">注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑</span></h5><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。</p>
<p>所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p>
<p>1）打开IK分词器config目录：<code>/var/lib/docker/volumes/es-plugins/_data/ik/config/IKAnalyzer.cfg.xml</code></p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506112225508.png" alt="image-20210506112225508"></p>
<p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;
&lt;properties&gt;
        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;
      
        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; 
&lt;/properties&gt;
</code></pre>
<p>3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p>
<pre><code class="properties">传智播客
奥力给
</code></pre>
<p>4）重启elasticsearch </p>
<pre><code class="sh">docker restart es

# 查看 日志
docker logs -f es
</code></pre>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20201115230900504.png" alt="image-20201115230900504"></p>
<p>日志中已经成功加载ext.dic配置文件</p>
<p>5）测试效果：</p>
<pre><code class="json">GET /_analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;传智播客Java就业超过90%,奥力给！&quot;
&#125;
</code></pre>
<blockquote>
<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑</p>
</blockquote>
<h2 id="3-4-停用词词典"><a href="#3-4-停用词词典" class="headerlink" title="3.4 停用词词典"></a>3.4 停用词词典</h2><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p>
<p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p>
<p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;
&lt;properties&gt;
        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;
        &lt;!--用户可以在这里配置自己的扩展字典--&gt;
        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;
         &lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;
        &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;
&lt;/properties&gt;
</code></pre>
<p>3）在 stopword.dic 添加停用词</p>
<pre><code class="properties">习大大
</code></pre>
<p>4）重启elasticsearch </p>
<pre><code class="sh"># 重启服务
docker restart es
docker restart kibana

# 查看 日志
docker logs -f es
</code></pre>
<p>日志中已经成功加载stopword.dic配置文件</p>
<p>5）测试效果：</p>
<pre><code class="json">GET /_analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;传智播客Java就业率超过95%,习大大都点赞,奥力给！&quot;
&#125;
</code></pre>
<blockquote>
<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p>
</blockquote>
<hr>
<hr>
<h4 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h4><h5 id="mapping属性"><a href="#mapping属性" class="headerlink" title="mapping属性"></a>mapping属性</h5><h6 id="mapping是对索引库中文档的约束，常见的mapping属性包括："><a href="#mapping是对索引库中文档的约束，常见的mapping属性包括：" class="headerlink" title="mapping是对索引库中文档的约束，常见的mapping属性包括："></a>mapping是对索引库中文档的约束，常见的mapping属性包括：</h6><p>• type：字段数据类型，常见的简单类型有：<br>• 字符串：text（可分词的文本）、<strong>keyword</strong>（精确值，例如：品牌、国家、ip地址）<br>• 数值：long、integer、short、byte、double、float<br>• 布尔：boolean<br>• 日期：date<br>• 对象：object<br>• index：是否创建索引，默认为true【默认倒排】<br>• analyzer：使用哪种分词器【只有text才需要分词】<br>• properties：该字段的子字段</p>
<pre><code class="java">&#123;
    &quot;age&quot;: 21,
    &quot;weight&quot;: 52.1,
    &quot;isMarried&quot;: false,
    &quot;info&quot;: &quot;黑马程序员Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;score&quot;: [99.1, 99.5, 98.9],
    &quot;name&quot;: &#123;
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    &#125;
&#125;
</code></pre>
<h5 id="索引库操作-1"><a href="#索引库操作-1" class="headerlink" title="索引库操作"></a>索引库操作</h5><h6 id="创建索引库和mapping的请求语法"><a href="#创建索引库和mapping的请求语法" class="headerlink" title="创建索引库和mapping的请求语法"></a>创建索引库和mapping的请求语法</h6><pre><code class="java">PUT /索引库名称
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;字段名&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_smart&quot;
      &#125;,
      &quot;字段名2&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: &quot;false&quot;
      &#125;,
      &quot;字段名3&quot;:&#123;
        &quot;properties&quot;: &#123;
          &quot;子字段&quot;: &#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;,
      // ...略
    &#125;
  &#125;
&#125;
</code></pre>
<p>↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓</p>
<pre><code class="java"># 创建索引库
PUT /heima
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;info&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      &#125;,
      &quot;email&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      &#125;,
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: &#123;
          &quot;firstName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;,
          &quot;lastName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
---------------------------------------------------------------------
&#123;
  &quot;acknowledged&quot; : true,
  &quot;shards_acknowledged&quot; : true,
  &quot;index&quot; : &quot;heima&quot;
&#125;
</code></pre>
<h4 id="操作索引库禁止修改索引库-因为已经映射好了"><a href="#操作索引库禁止修改索引库-因为已经映射好了" class="headerlink" title="操作索引库禁止修改索引库(因为已经映射好了)"></a>操作索引库<del>禁止修改索引库(因为已经映射好了)</del></h4><h6 id="查看索引语法："><a href="#查看索引语法：" class="headerlink" title="查看索引语法："></a>查看索引语法：</h6><p><code>GET/索引名</code></p>
<h6 id="删除索引库的语法："><a href="#删除索引库的语法：" class="headerlink" title="删除索引库的语法："></a>删除索引库的语法：</h6><p><code>DELETE/索引库名</code></p>
<h6 id="可以在修改索引的过程中添加新的字段"><a href="#可以在修改索引的过程中添加新的字段" class="headerlink" title="可以在修改索引的过程中添加新的字段"></a>可以在修改索引的过程中添加新的字段</h6><pre><code class="java">PUT /索引库名/_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;新字段名&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;
---------------------------
PUT /heima/_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;age&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>当您使用Elasticsearch（ES）的PUT请求创建索引库时，这个索引库实际上是存储在Elasticsearch集群的节点上的。如果您的Elasticsearch集群是安装在Linux服务器上的，那么是的，索引库会被创建在Linux文件系统中。</p>
<p>Elasticsearch为每个索引分配一个或多个主分片，并为每个主分片分配一个或多个副本分片。这些分片实际上是存储在Elasticsearch节点的文件系统上的。具体来说，索引数据存储在以下路径：</p>
<p>复制</p>
<pre><code>/path/to/elasticsearch/data/nodes/&lt;node-id&gt;/&lt;index&gt;/&lt;shard-id&gt;
</code></pre>
<p>这里的<code>/path/to/elasticsearch</code>是Elasticsearch的安装路径，<code>data</code>目录是默认的数据存储位置，<code>nodes</code>目录包含了集群中各个节点的数据，<code>&lt;node-id&gt;</code>是节点的唯一标识，<code>&lt;index&gt;</code>是您创建的索引名称，而<code>&lt;shard-id&gt;</code>则是分片的ID。</p>
</blockquote>
<h4 id="索引库的增删改查汇总"><a href="#索引库的增删改查汇总" class="headerlink" title="索引库的增删改查汇总"></a>索引库的增删改查汇总</h4><pre><code class="mysql">
# 创建索引库
PUT /heima
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;info&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      &#125;,
      &quot;email&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      &#125;,
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: &#123;
          &quot;firstName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;,
          &quot;lastName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;

# 查询
GET /heima

# 修改索引库
PUT /heima/_mapping
&#123;
  &quot;properties&quot;:&#123;
    &quot;age&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;

# 修改
DELETE /heima
</code></pre>
<h5 id="文档操作——添加文档"><a href="#文档操作——添加文档" class="headerlink" title="文档操作——添加文档"></a>文档操作——添加文档</h5><pre><code class="mysql"># 每次写操作的时候 版本会增加 &quot;_version ++&quot;

# 插入文档
POST /heima/_doc/1
&#123;
  &quot;info&quot;: &quot;广州黑马198班&quot;,
  &quot;email&quot;: &quot;390415049@qq.com&quot;,
  &quot;name&quot;:&#123;
    &quot;firstName&quot;: &quot;春&quot;,
    &quot;lastName&quot;: &quot;尧&quot;
  &#125;
&#125;

# 查询文档
GET /heima/_doc/1

# 删除文档
DELETE /heima/_doc/1
</code></pre>
<h5 id="文档操作——修改文档"><a href="#文档操作——修改文档" class="headerlink" title="文档操作——修改文档"></a>文档操作——修改文档</h5><h6 id="方式一：全量修改，会删除旧文档，添加新文档"><a href="#方式一：全量修改，会删除旧文档，添加新文档" class="headerlink" title="方式一：全量修改，会删除旧文档，添加新文档"></a>方式一：全量修改，会删除旧文档，添加新文档</h6><pre><code class="java">PUT /索引库名/_doc/文档id
&#123;
    &quot;字段1&quot;: &quot;值1&quot;,
    &quot;字段2&quot;: &quot;值2&quot;,
    // ... 略
&#125;
-------------------------
PUT /heima/_doc/1
&#123;
    &quot;info&quot;: &quot;黑马程序员高级Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;name&quot;: &#123;
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    &#125;
&#125;


# 全量修改文档
POST /heima/_doc/1
&#123;
  &quot;info&quot;: &quot;广州黑马198班&quot;,
  &quot;email&quot;: &quot;90415049@qq.com&quot;,
  &quot;name&quot;:&#123;
    &quot;firstName&quot;: &quot;尧&quot;,
    &quot;lastName&quot;: &quot;春&quot;
  &#125;
&#125;
</code></pre>
<h6 id="方式二：增量修改，修改指定字段值"><a href="#方式二：增量修改，修改指定字段值" class="headerlink" title="方式二：增量修改，修改指定字段值"></a>方式二：增量修改，修改指定字段值</h6><pre><code class="java">POST /索引库名/_update/文档id
&#123;
    &quot;doc&quot;: &#123;
         &quot;字段名&quot;: &quot;新的值&quot;,
    &#125;
&#125;
-------------------------
POST /heima/_update/1
&#123;
  &quot;doc&quot;: &#123;
    &quot;email&quot;: &quot;ZhaoYun@itcast.cn&quot;
  &#125;
&#125;


# 局部修改文档
POST /heima/_update/1
&#123;
  &quot;doc&quot;: &#123;
    &quot;email&quot;: &quot;ZYun@itcast.cn&quot;
  &#125;
&#125;
</code></pre>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>文档操作有哪些？</p>
<ul>
<li><p>创建文档：POST &#x2F;索引库名&#x2F;_doc&#x2F;文档id { json文档 }</p>
</li>
<li><p>查询文档：GET &#x2F;索引库名&#x2F;_doc&#x2F;文档id</p>
</li>
<li><p>删除文档：DELETE &#x2F;索引库名&#x2F;_doc&#x2F;文档id</p>
</li>
<li><p>修改文档：</p>
<ul>
<li><p>全量修改：PUT &#x2F;索引库名&#x2F;_doc&#x2F;文档id { json文档 }</p>
</li>
<li><p>增量修改：POST &#x2F;索引库名&#x2F;_update&#x2F;文档id { “doc”: {字段}}</p>
</li>
</ul>
</li>
</ul>
<h3 id="JavaRestClient"><a href="#JavaRestClient" class="headerlink" title="JavaRestClient"></a>JavaRestClient</h3><p>Elasticsearch目前最新版本是8.0，其Java客户端有很大变化。不过大多数企业使用的还是8以下版本，所以我们选择使用早期的JavaRestClient客户端来学习。官方文档地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">Elasticsearch Clients | Elastic</a></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2025/01/03/后端/ElasticSearch/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/23/后端/MyBatisPlus/">
        <h2>
            MyBatisPlus
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/23
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><a target="_blank" rel="noopener" href="https://www.baomidou.com/">MyBatis-Plus</a><br><a target="_blank" rel="noopener" href="https://www.baomidou.com/introduce/">简介 | MyBatis-Plus</a></p>
<h5 id="引入MybatisPlus起步依赖写依赖-认爸爸"><a href="#引入MybatisPlus起步依赖写依赖-认爸爸" class="headerlink" title="引入MybatisPlus起步依赖写依赖+认爸爸"></a>引入MybatisPlus起步依赖<del>写依赖+认爸爸</del></h5><ul>
<li>MyBatisPlus官方提供了starter，其中集成了Mybatis和MybatisPlus的所有功能，并且实现了自动装配效果。因此我们可以用MybatisPlus的starter代替Mybatis的starter：</li>
</ul>
<pre><code class="xml">&lt;!--MybatisPlus--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; 
    &lt;version&gt;3.5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>自定义的Mapper继承MybatisPlus提供的<code>BaseMapper</code>接口</li>
</ul>
<pre><code class="java">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">UserMapper.java

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
</code></pre>
<pre><code class="xml">UserMapper.xml

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.itheima.mp.mapper.UserMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul>
<li><code>@TableName</code>：用来指定表名</li>
<li><code>@Tableld</code>：用来指定表中的主键字段信息<ul>
<li><code>IdType枚举</code>：<ul>
<li><strong>AUTO</strong>：数据库自增长</li>
<li><strong>INPUT</strong>：通过set方法自行输入</li>
<li><em>ASSIGN_ID</em>：<u>分配ID 默认实现类是</u><code>雪花算法</code></li>
</ul>
</li>
</ul>
</li>
<li><code>@TableField</code>：用来指定表中的普通字段信息<del>默认驼峰转下划线，不一致需要改</del><ul>
<li>成员变量名与数据库字段名不一致</li>
<li><u>成员变量名是以<strong>is开头</strong>，且是<strong>布尔值</strong></u><del>isMarried</del></li>
<li>成员变量名与数据库关键字冲突<del>order</del></li>
<li>成员变量不是数据库字段<del>address</del>，要标记不存在不然会默认数据库字段</li>
</ul>
</li>
</ul>
<pre><code class="java">@Data
public class User &#123;
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Long id;
    
    @TableField(&quot;username&quot;)
    private String name;

    @TableField(&quot;is_married&quot;)
    private Boolean isMarried;  // is经过反射会默认变成变量名Married
    
    @TableField(&quot;`order`&quot;)
    private Integer order;
    
    @TableField(exist = false)
    private String address;
......
&#125;
</code></pre>
<p>此时如果数据库的表名是：<code>tb_user</code> 就需要用到 <code>@TableName</code> 了</p>
<pre><code class="mysql">数据库名：tb_user (用户表)
#  名称
1  id
2  username
3  is_married
4  order
</code></pre>
<h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><p><code>MyBatisPlus</code>的配置项继承了MyBatis原生配置和一些自己特有的配置<br>MP更擅长单表的增删改查，如果是多表还是推荐用xml</p>
<pre><code class="yaml">mybatis:
  mapper-locations: classpath*:mapper/*.xml # Mapper.xml文件地址，默认值
  type-aliases-package: com.itheima.po # 别名扫描包
  configuration:
    map-underscore-to-camel-case: true # 开启驼峰命名自动映射
    cache-enabled: false # 是否开启二级缓存
  global-config:
    db-config:
      id-type: assign_id # id为雪花算法生成
      update-strategy: not_null # 更新策略：只更新非空字段 类似于动态sql
</code></pre>
<p><span style="color:red"><strong>MyBatisPlus使用的基本流程</strong></span></p>
<ul>
<li>引入起步依赖</li>
<li>自定义Mapper基础BaseMapper</li>
<li>在实体类上添加注释声明 表信息</li>
<li>在application.yml中根据需要添加配置</li>
</ul>
<h3 id="核心功能—条件构造器"><a href="#核心功能—条件构造器" class="headerlink" title="核心功能—条件构造器"></a>核心功能—条件构造器</h3><h6 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/3b9a3950642e32ab3182e3aae6cd2ba50c25f42f/MyBatisPlus%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%88%97%E8%A1%A8.jpg"></p>
<p><code>MyBatisPlus</code>支持各种复杂的<code>where</code>条件，满足日常开发的所有需求</p>
<ul>
<li>查询出名字中带o的，存款大于等于1000元的人的id、username、info、balance字段</li>
</ul>
<pre><code class="mysql"># 原始SQL：
SELECT id,username,info,balance
FROM user
WHERE username LIKE ? AND balance &gt;= ?
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testQueryWrapper()&#123;
        // 1.构建查询条件
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;()
                .select(&quot;id&quot;, &quot;username&quot;, &quot;phone&quot;)
                .like(&quot;username&quot;, &quot;o&quot;)
                .ge(&quot;balance&quot;, 1000);
        // 2.查询
        List&lt;User&gt; users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    &#125;
</code></pre>
<pre><code class="java">// MyBatisPlus Lambda编码格式(解决硬编码)：
 @Test
    void testLambdaQueryWrapper()&#123;
        // 1.构建查询条件
        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;User&gt;()
                // 利用反射 解决字符串硬编码
                .select(User::getId, User::getUsername, User::getPhone)
                .like(User::getUsername, &quot;o&quot;)
                .ge(User::getBalance, 1000);
        // 2.查询
        List&lt;User&gt; users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    &#125;

-------------------------------------------------------------------------
@Test
void testLambdaQueryWrapperWithQueryWrapper()&#123;
    // 1. 构建查询条件
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();
    LambdaQueryWrapper&lt;User&gt; wrapper = queryWrapper.lambda()
            .select(User::getId, User::getUsername, User::getPhone)
            .like(User::getUsername, &quot;o&quot;)
            .ge(User::getBalance, 1000);

    // 2. 查询
    List&lt;User&gt; users = userMapper.selectList(wrapper);
    users.forEach(System.out::println);
&#125;
</code></pre>
<ul>
<li>更新用户名为jack的用户的余额为2000</li>
</ul>
<pre><code class="mysql"># 原始SQL：
UPDATE user
    SET balance = 2000
    WHERE (username = &quot;jack&quot;)
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testUpdateByQueryWrapper()&#123;
        // 1.要更新的数据
        User user = new User();
        user.setBalance(2000);
        // 2.更新的条件
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().eq(&quot;username&quot;, &quot;jack&quot;);
        // 3.执行更新
        userMapper.update(user, wrapper);
    &#125;
</code></pre>
<ul>
<li>更新id为1，2，4的用户的余额，扣200</li>
</ul>
<pre><code class="mysql"># 原始SQL：
UPDATE user
    SET balance = balance - 200
    WHERE id in (1,2,4)
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testUpdateWrapper()&#123;
        List&lt;Long&gt; ids = List.of(1L, 2L, 4L);
        UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;User&gt;()
                .setSql(&quot;balance = balance - 100&quot;)
                .in(&quot;id&quot;, ids);
        userMapper.update(null, wrapper);
    &#125;
</code></pre>
<h5 id="条件构造器的用法："><a href="#条件构造器的用法：" class="headerlink" title="条件构造器的用法："></a>条件构造器的用法：</h5><ul>
<li><p>QueryWrapper和LambdaQueryWrapper通常用来构建select、delete、update的where条件部分</p>
</li>
<li><p>UpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才使用</p>
</li>
<li><p>尽量使用LambdaQueryWrapper和LambdaUpdateWrapper，避免硬编码</p>
</li>
</ul>
<h3 id="4-字段映射与表名映射"><a href="#4-字段映射与表名映射" class="headerlink" title="4. 字段映射与表名映射"></a>4. 字段映射与表名映射</h3><h4 id="4-1-问题一：表字段与编码属性设计不同步"><a href="#4-1-问题一：表字段与编码属性设计不同步" class="headerlink" title="4.1 问题一：表字段与编码属性设计不同步"></a>4.1 问题一：表字段与编码属性设计不同步</h4><ul>
<li>在模型类属性上方，使用**@TableField**属性注解，通过&#x3D;&#x3D;<strong>value</strong>&#x3D;&#x3D;属性，设置当前属性对应的数据库表中的字段关系。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\1683796001750.png" alt="1683796001750"></p>
<h4 id="4-2-问题二：编码中添加了数据库中未定义的属性"><a href="#4-2-问题二：编码中添加了数据库中未定义的属性" class="headerlink" title="4.2 问题二：编码中添加了数据库中未定义的属性"></a>4.2 问题二：编码中添加了数据库中未定义的属性</h4><ul>
<li>在模型类属性上方，使用**@TableField<strong>注解，通过</strong>&#x3D;&#x3D;exist&#x3D;&#x3D;**属性，设置属性在数据库表字段中是否存在，默认为true。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\exist.png" alt="1683796121907"></p>
<h4 id="4-3-问题三：表名与编码开发设计不同步"><a href="#4-3-问题三：表名与编码开发设计不同步" class="headerlink" title="4.3 问题三：表名与编码开发设计不同步"></a>4.3 问题三：表名与编码开发设计不同步</h4><ul>
<li>在<u><strong>模型类</strong></u>上方，使用**@TableName<strong>注解，通过</strong>&#x3D;&#x3D;value&#x3D;&#x3D;**属性，设置当前类对应的数据库表名称。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\table.png" alt="1683798660359"></p>
<h2 id="四、主键生成策略"><a href="#四、主键生成策略" class="headerlink" title="四、主键生成策略"></a>四、主键生成策略</h2><p>id主键生成的策略有哪几种方式？</p>
<p>不同的表应用不同的id生成策略</p>
<ul>
<li>日志：自增（1,2,3,4，……）</li>
<li>购物订单：特殊规则（FQ23948AK3843）</li>
<li>外卖单：关联地区日期等信息（10 04 20200314 34 91）</li>
<li>关系表：可省略id</li>
<li>……</li>
</ul>
<h3 id="1-id生成策略控制（-TableId注解）"><a href="#1-id生成策略控制（-TableId注解）" class="headerlink" title="1 id生成策略控制（@TableId注解）"></a>1 id生成策略控制（@TableId注解）</h3><p>雪花算法：<code>@TableId(type= IdType.ASSIGN_ID)</code><br><code>ASSIGN_UUID</code>是趋势递增<br>用了<code>分库分表</code>就不能用默认的id自增了 要用雪花算法</p>
<ul>
<li><p>名称：@TableId</p>
</li>
<li><p>类型：<strong>属性注解</strong></p>
</li>
<li><p>位置：模型类中用于表示主键的属性定义上方</p>
</li>
<li><p>作用：设置当前类中主键属性的生成策略</p>
</li>
<li><p>相关属性</p>
<p>​    <strong>type</strong>：设置主键属性的生成策略，值参照IdType枚举值</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801192449901.png" alt="image-20210801192449901"></p>
</li>
</ul>
<h3 id="2-全局策略配置"><a href="#2-全局策略配置" class="headerlink" title="2 全局策略配置"></a>2 全局策略配置</h3><pre><code class="yml">mybatis-plus:
  global-config:
    db-config:
      id-type: assign_id #全局设置主键id策略
      table-prefix: tbl_  #表名前缀设置
</code></pre>
<h5 id="id生成策略全局配置"><a href="#id生成策略全局配置" class="headerlink" title="id生成策略全局配置"></a>id生成策略全局配置</h5><p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801183128266.png" alt="image-20210801183128266"></p>
<h5 id="表名前缀全局配置"><a href="#表名前缀全局配置" class="headerlink" title="表名前缀全局配置"></a>表名前缀全局配置</h5><p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801183157694.png" alt="image-20210801183157694"></p>
<h3 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h3><p>我们可以利用MyBatisPlus的Wrapper来**<u>构造复杂的where条件</u>**，然后自己定义SQL语句中剩下的部分。</p>
<h6 id="将id在指定范围的用户-1-2-4-的余额扣减指定值"><a href="#将id在指定范围的用户-1-2-4-的余额扣减指定值" class="headerlink" title="将id在指定范围的用户(1,2,4)的余额扣减指定值"></a>将id在指定范围的用户(1,2,4)的余额扣减指定值</h6><pre><code class="sql">&lt;update id = &quot;updateBalanceByIds&quot;&gt;
    UPDATE user
    SET balance = balance - #&#123;amount&#125;
    WHERE id IN
    &lt;foreach collection=&quot;ids&quot; separator=&quot;,&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
    #&#123;id&#125;
    &lt;/foreach&gt;
&lt;/update&gt;
</code></pre>
<ul>
<li>基于Wrapper构建where条件</li>
</ul>
<pre><code class="java">// 1.更新条件
  List&lt;Long&gt; ids = List.of(1L, 2L, 4L);
  int amount = 200;
// 2.定义条件
  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().in(User::getId, ids);
// 3.调用自定义SQL方法
  userMapper.updateBalanceByIds(wrapper, amount);
</code></pre>
<ul>
<li>在mapper方法参数中用Param注解声明wrapper变量名称，<strong>必须是ew</strong></li>
</ul>
<pre><code class="java">void updateBalanceByIds(@Param(Constants.WRAPPER) QueryWrapper&lt;User&gt; wrapper, @Param(&quot;amount&quot;) int amount);
</code></pre>
<ul>
<li>自定义SQL，并使用Wrapper条件</li>
</ul>
<pre><code class="xml">&lt;update id=&quot;updateBalanceByIds&quot;&gt;
        update user
        set balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;
    &lt;/update&gt;
</code></pre>
<h3 id="IService接口基本用法"><a href="#IService接口基本用法" class="headerlink" title="IService接口基本用法"></a>IService接口基本用法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/d025a67eaeb98c3eb9725d71e36e36b6516b2b7d/IService%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.jpg" style="zoom:150%;" />

<ul>
<li>自定义Service接口继承IService接口</li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.mp.domain.po.User;

public interface IUserService extends IService&lt;User&gt; &#123;

&#125;
</code></pre>
<ul>
<li>自定义Service实现类，实现自定义接口并继承ServiceImpl类</li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.impl.IUserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;

&#125;
</code></pre>
<ul>
<li>搞了个测试类<code>@Test</code></li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl;

import com.itheima.mp.domain.po.User;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

@SpringBootTest
class IUserServiceTest &#123;
    @Autowired
    private IUserService userService;

    @Test
    void testSaveUser() &#123;
        User user = new User();
        user.setId(5L);
        user.setUsername(&quot;Lucy&quot;);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;18688990011&quot;);
        user.setBalance(200);
        user.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        userService.save(user);
    &#125;
    @Test
    void testQuery()&#123;
        List&lt;User&gt; users = userService.listByIds(Arrays.asList(1L, 2L, 3L));
        users.forEach(System.out::println);
    &#125;

&#125;
</code></pre>
<h3 id="IService开发基础业务接口"><a href="#IService开发基础业务接口" class="headerlink" title="IService开发基础业务接口"></a>IService开发基础业务接口</h3><ul>
<li>基于Restful风格实现下面的接口：<br>飞书文档说明：(<a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc</a>)</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>编号</strong></th>
<th align="left"><strong>接口</strong></th>
<th align="left"><strong>请求方式</strong></th>
<th align="left"><strong>请求路径</strong></th>
<th><strong>请求参数</strong></th>
<th><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">新增用户</td>
<td align="left">POST</td>
<td align="left">&#x2F;users</td>
<td>用户表单实体</td>
<td>无</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">删除用户</td>
<td align="left">DELETE</td>
<td align="left">&#x2F;users&#x2F;{id}</td>
<td>用户id</td>
<td>无</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">根据id查询用户</td>
<td align="left">GET</td>
<td align="left">&#x2F;users&#x2F;{id}</td>
<td>用户id</td>
<td>用户VO</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">根据id批量查询</td>
<td align="left">GET</td>
<td align="left">&#x2F;users</td>
<td>用户id集合</td>
<td>用户VO集合</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">根据id扣减余额</td>
<td align="left">PUT</td>
<td align="left">&#x2F;users&#x2F;{id}&#x2F;deduction&#x2F;{money}</td>
<td>•用户id  •扣减金额</td>
<td>无</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/thinkingandworkinghard/p/10482929.html">解决在IDEA 的Maven下 出现 Cannot access in offline mode 问题 - Doyourself! - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/doc.html">管理接口文档</a></p>
<pre><code class="java">UserController.java
package com.itheima.mp.controller;

import cn.hutool.core.bean.BeanUtil;
import com.itheima.mp.domain.po.User;

import com.itheima.mp.domain.dto.UserFormDTO;

import com.itheima.mp.domain.vo.UserVO;
import com.itheima.mp.service.IUserService;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Api(tags = &quot;用户管理接口&quot;)
@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;users&quot;)
public class UserController &#123;

    private final IUserService userService;

    @PostMapping
    @ApiOperation(&quot;新增用户&quot;)
    public void saveUser(@RequestBody UserFormDTO userFormDTO) &#123;
        // 1.转换DTO为PO
        User user = BeanUtil.copyProperties(userFormDTO, User.class);
        // 2.新增
        userService.save(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;删除用户&quot;)
    public void removeUserById(@PathVariable(&quot;id&quot;) Long userId) &#123;
        userService.removeById(userId);
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询用户&quot;)
    public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long userId) &#123;
        // 1.查询用户
        User user = userService.getById(userId);
        // 2.处理vo
        return BeanUtil.copyProperties(user, UserVO.class);
    &#125;

    @GetMapping
    @ApiOperation(&quot;根据id集合查询用户&quot;)
    public List&lt;UserVO&gt; queryUserByIds(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;
        // 1.查询用户
        List&lt;User&gt; users = userService.listByIds(ids);
        // 2.处理vo
        return BeanUtil.copyToList(users, UserVO.class);
    &#125;

    @PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)
    @ApiOperation(&quot;扣减用户余额&quot;)
    public void deductBalance(@ApiParam(&quot;用户id&quot;) @PathVariable(&quot;id&quot;) Long id, @ApiParam(&quot;扣减的金额&quot;) @PathVariable(&quot;money&quot;) Integer money) &#123;
        userService.deductBalance(id, money);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserFormDTO.java
package com.itheima.mp.domain.dto;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户表单实体&quot;)
public class UserFormDTO &#123;

    @ApiModelProperty(&quot;id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;密码&quot;)
    private String password;

    @ApiModelProperty(&quot;注册手机号&quot;)
    private String phone;

    @ApiModelProperty(&quot;详细信息，JSON风格&quot;)
    private String info;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;
&#125;
</code></pre>
<pre><code class="java">UserQuery.java
package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery &#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.IUserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;
    @Override
    public void deductBalance(Long id, Integer money) &#123;
        // 1.查询用户
        User user = getById(id);
        // 2.判断用户状态
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 3.判断用户余额
        if (user.getBalance() &lt; money) &#123;
            throw new RuntimeException(&quot;用户余额不足&quot;);
        &#125;
        // 4.扣减余额
        baseMapper.deductMoneyById(id, money);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.mp.mapper;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.baomidou.mybatisplus.core.toolkit.Constants;
import com.itheima.mp.domain.po.User;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Update;

import java.util.List;

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;

    List&lt;User&gt; queryUserByIds(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);

    void updateBalanceByIds(@Param(Constants.WRAPPER) QueryWrapper&lt;User&gt; wrapper, @Param(&quot;amount&quot;) int amount);

    @Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)
    void deductMoneyById(Long id, Integer money);
&#125;
</code></pre>
<h3 id="Iservice的Lambda方法"><a href="#Iservice的Lambda方法" class="headerlink" title="Iservice的Lambda方法"></a>Iservice的Lambda方法</h3><h6 id="需求：实现一个根据复杂条件查询用户的接口，查询条件如下："><a href="#需求：实现一个根据复杂条件查询用户的接口，查询条件如下：" class="headerlink" title="需求：实现一个根据复杂条件查询用户的接口，查询条件如下："></a>需求：实现一个根据复杂条件查询用户的接口，查询条件如下：</h6><p><strong>name</strong>：用户名关键字，可以为空<br><strong>status</strong>：用户状态，可以为空<br><strong>minBalance</strong>：最小余额，可以为空<br><strong>maxBalance</strong>：最大余额，可以为空</p>
<pre><code class="mysql">&lt;select id=&quot;queryUsers&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;
    SELECT *
    FROM tb_user
    &lt;where&gt;
        &lt;if test=&quot;name != null&quot;&gt;
            AND username LIKE CONCAT(&#39;%&#39;, #&#123;name&#125;, &#39;%&#39;)
        &lt;/if&gt;
        &lt;if test=&quot;status != null&quot;&gt;
            AND `status` = #&#123;status&#125;
        &lt;/if&gt;
        &lt;if test=&quot;minBalance != null and maxBalance != null&quot;&gt;
            AND balance BETWEEN #&#123;minBalance&#125; AND #&#123;maxBalance&#125;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<h6 id="UserQuery-java"><a href="#UserQuery-java" class="headerlink" title="UserQuery.java"></a>UserQuery.java</h6><pre><code class="java">package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery &#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<h6 id="UserController-java"><a href="#UserController-java" class="headerlink" title="UserController.java"></a>UserController.java</h6><pre><code class="java">    @ApiOperation(&quot;根据复杂条件查询用户接口&quot;)
    @GetMapping(&quot;/list&quot;)
    public List&lt;UserVO&gt; queryUsers(UserQuery query) &#123;
        // 1.查询用户PO
        List&lt;User&gt; users = userService.queryUsers(query.getName(), query.getStatus(), query.getMinBalance(), query.getMaxBalance());
        // 2.把po拷贝到vo
        return BeanUtil.copyToList(users, UserVO.class);
    &#125;
</code></pre>
<h6 id="IUserService-java"><a href="#IUserService-java" class="headerlink" title="IUserService.java"></a>IUserService.java</h6><pre><code class="java">package com.itheima.mp.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.mp.domain.po.User;

import java.util.List;

public interface IUserService extends IService&lt;User&gt; &#123;
    void deductBalance(Long id, Integer money);

    List&lt;User&gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance);
&#125;
</code></pre>
<h6 id="UserServiceImpl-java"><a href="#UserServiceImpl-java" class="headerlink" title="UserServiceImpl.java"></a>UserServiceImpl.java</h6><pre><code class="java">package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.IUserService;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;
   @Override
    public List&lt;User&gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance) &#123;
        return lambdaQuery()
                .like(name!=null, User::getUsername,name)
                .eq(status!=null, User::getStatus,status)
                .gt(minBalance!=null, User::getBalance,minBalance) // 大于
                .lt(maxBalance!=null, User::getBalance,maxBalance) // 小于
                .list();
    &#125;
&#125;
</code></pre>
<h3 id="IService的Lambda更新LambdaUpdate-、LambdaQuery"><a href="#IService的Lambda更新LambdaUpdate-、LambdaQuery" class="headerlink" title="IService的Lambda更新LambdaUpdate()、LambdaQuery()"></a>IService的Lambda更新<del>LambdaUpdate()、LambdaQuery()</del></h3><h6 id="改造根据id修改用户余额的接口，要求如下"><a href="#改造根据id修改用户余额的接口，要求如下" class="headerlink" title="改造根据id修改用户余额的接口，要求如下"></a>改造根据id修改用户余额的接口，要求如下</h6><ul>
<li><p>完成对用户状态校验</p>
</li>
<li><p>完成对用户余额校验</p>
</li>
<li><p>如果扣减后余额为0，则将用户status修改为冻结状态 (2)</p>
<h6 id="UserController-java-1"><a href="#UserController-java-1" class="headerlink" title="UserController.java"></a>UserController.java</h6></li>
</ul>
<pre><code class="java"> @PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)
    @ApiOperation(&quot;扣减用户余额&quot;)
    public void deductBalance(@ApiParam(&quot;用户id&quot;) @PathVariable(&quot;id&quot;) Long id, @ApiParam(&quot;扣减的金额&quot;) @PathVariable(&quot;money&quot;) Integer money) &#123;
        userService.deductBalance(id, money);
    &#125;
</code></pre>
<h6 id="UserServiceImpl-java-1"><a href="#UserServiceImpl-java-1" class="headerlink" title="UserServiceImpl.java"></a>UserServiceImpl.java</h6><pre><code class="java"> @Override
    public void deductBalance(Long id, Integer money) &#123;
        // 1.查询用户
        User user = getById(id);
        // 2.判断用户状态
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 3.判断用户余额
        if (user.getBalance() &lt; money) &#123;
            throw new RuntimeException(&quot;用户余额不足&quot;);
        &#125;
        // 4.扣减余额 update tb_user set balance = balance - ?
        int remainBalance = user.getBalance() - money;
        lambdaUpdate()
                .set(User::getBalance, remainBalance)
                .set(remainBalance == 0,User::getStatus, 2)
                .eq(User::getId, id)
                .eq(User::getBalance, user.getBalance()) // 乐观锁
                .update();
    &#125;
</code></pre>
<h3 id="IService的批量新增"><a href="#IService的批量新增" class="headerlink" title="IService的批量新增"></a>IService的批量新增</h3><h6 id="批量插入10万条用户数据，并作出对比："><a href="#批量插入10万条用户数据，并作出对比：" class="headerlink" title="批量插入10万条用户数据，并作出对比："></a>批量插入10万条用户数据，并作出对比：</h6><ul>
<li>普通for循环插入<del>4分钟</del></li>
<li><strong>IService的批量插入</strong><del>30秒</del></li>
<li>开启<strong>rewriteBatchedStatements&#x3D;true</strong>参数【6秒】<del>重写Statement语句，在application.yaml的sql中url拼接</del></li>
</ul>
<pre><code class="java">Test  com/itheima/mp/service/IUserServiceTest.java
@Test
    void testSaveOneByOne() &#123;
        long b = System.currentTimeMillis();
        for (int i = 1; i &lt;= 100000; i++) &#123;
            userService.save(buildUser(i));
        &#125;
        long e = System.currentTimeMillis();
        System.out.println(&quot;耗时：&quot; + (e - b));
    &#125;

    private User buildUser(int i) &#123;
        User user = new User();
        user.setUsername(&quot;user_&quot; + i);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;&quot; + (18688190000L + i));
        user.setBalance(2000);
        user.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(user.getCreateTime());
        return user;
    &#125;
</code></pre>
<h6 id="MyBatisPlus的批处理"><a href="#MyBatisPlus的批处理" class="headerlink" title="MyBatisPlus的批处理"></a>MyBatisPlus的批处理</h6><pre><code class="java">@Test
void testSaveBatch() &#123;
    // 准备10万条数据
    List&lt;User&gt; list = new ArrayList&lt;&gt;(1000);
    long b = System.currentTimeMillis();
    for (int i = 1; i &lt;= 100000; i++) &#123;
        list.add(buildUser(i));
        // 每1000条批量插入一次
        if (i % 1000 == 0) &#123;
            userService.saveBatch(list);
            list.clear();
        &#125;
    &#125;
    long e = System.currentTimeMillis();
    System.out.println(&quot;耗时：&quot; + (e - b));
&#125;
</code></pre>
<p>可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。</p>
<p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p>
<pre><code class="SQL">Preparing: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? )
Parameters: user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
Parameters: user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
Parameters: user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
</code></pre>
<p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p>
<pre><code class="SQL">INSERT INTO user ( username, password, phone, info, balance, create_time, update_time )
VALUES 
(user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_4, 123, 18688190004, &quot;&quot;, 2000, 2023-07-01, 2023-07-01);
</code></pre>
<p>该怎么做呢？</p>
<p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。参考文档：</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements</a></p>
<p>这个参数的默认值是false，我们需要修改连接参数，将其配置为true</p>
<p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p>
<pre><code class="YAML">spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: MySQL123
</code></pre>
<h3 id="扩展功能-——-代码生成器生成代码的代码"><a href="#扩展功能-——-代码生成器生成代码的代码" class="headerlink" title="扩展功能 —— 代码生成器生成代码的代码"></a>扩展功能 —— 代码生成器<del>生成代码的代码</del></h3><h2 id="3-1-代码生成"><a href="#3-1-代码生成" class="headerlink" title="3.1 代码生成"></a><strong>3.1 代码生成</strong></h2><p>在使用MybatisPlus以后，基础的<code>Mapper</code>、<code>Service</code>、<code>PO</code>代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成<code>PO</code>、<code>Mapper</code>、<code>Service</code>等相关代码。只不过代码生成器同样要编码使用，也很麻烦。</p>
<p>这里推荐大家使用一款<code>MybatisPlus</code>的插件，它可以基于图形化界面完成<code>MybatisPlus</code>的代码生成，非常简单。</p>
<h3 id="3-1-1-安装插件"><a href="#3-1-1-安装插件" class="headerlink" title="3.1.1.安装插件"></a><strong>3.1.1.安装插件</strong></h3><p>在<code>Idea</code>的plugins市场中搜索并安装<code>MyBatisPlus</code>插件：</p>
<p>然后重启你的Idea即可使用。</p>
<h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a><strong>3.1.2.使用</strong></h3><p>刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到<code>other</code>，选择<code>Config Database</code>：</p>
<p>点击OK保存。</p>
<p>然后再次点击Idea顶部菜单中的other，然后选择<code>Code Generator</code>:</p>
<p>在弹出的表单中填写信息：</p>
<p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY1ZmEzNjMxODM4NjkzMjUzZDkxMGY1NDdlZjUzNmRfMjQweXV3NE1lRmpkWGNzcU5pOGxyMW1yaGoxNmtJamZfVG9rZW46WlRqemI4SGVjb080VWp4Sko0ZWNZR2lTbnRoXzE3MzI0MTU0NDQ6MTczMjQxOTA0NF9WNA" alt="img"></p>
<p>最终，代码自动生成到指定的位置了：</p>
<h3 id="扩展功能-——-DB静态工具两个Service相互注入"><a href="#扩展功能-——-DB静态工具两个Service相互注入" class="headerlink" title="扩展功能 —— DB静态工具两个Service相互注入"></a>扩展功能 —— DB静态工具<del>两个Service相互注入</del></h3><ul>
<li>改造根据id查询用户的接口，查询用户的同时<del>user表</del>，查询出用户对应的所有地址<del>address表</del></li>
<li>改造根据id批量查询用户的接口，查询用户的同时，查询出用户对应的所有地址</li>
<li>实现根据用户id查询收货地址功能，需要验证用户状态，冻结用户抛出异常(练习)</li>
</ul>
<h2 id="3-2-静态工具"><a href="#3-2-静态工具" class="headerlink" title="3.2.静态工具"></a><strong>3.2.静态工具</strong></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/76848ff08a98edaf6d5d07285cd76e50f42e7c5b/DB%E9%9D%99%E6%80%81%E5%B7%A5%E5%85%B7.jpg"></p>
<p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：</p>
<pre><code class="java">UserController.java
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询用户&quot;)
    public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long id) &#123;
        // 1.查询用户
//        User user = userService.getById(userId);
        // 2.处理vo
        return userService.queryUserAndAddressById(id);
    &#125;
</code></pre>
<pre><code class="java">IUserService.java
public interface IUserService extends IService&lt;User&gt; &#123;
    UserVO queryUserAndAddressById(Long id);
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public UserVO queryUserAndAddressById(Long id) &#123;
        // 1.查询用户
        User user = getById(id);
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 2.查询方法
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)
                .eq(Address::getUserId, id).list();
        // 3.封装VO
        // 3.1 转User的PO为VO
        UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
        if (CollUtil.isEmpty(addresses)) &#123;
           userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));
        &#125;
        return userVO;
    &#125;
</code></pre>
<h3 id="扩展功能—DB静态工具-练习"><a href="#扩展功能—DB静态工具-练习" class="headerlink" title="扩展功能—DB静态工具(练习)"></a>扩展功能—DB静态工具(练习)</h3><pre><code class="java">UserController.java
@GetMapping
    @ApiOperation(&quot;根据id集合查询用户&quot;)
    public List&lt;UserVO&gt; queryUserByIds(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;
        // 1.查询用户
//        List&lt;User&gt; users = userService.listByIds(ids);
        // 2.处理vo
        return userService.queryUserAndAddressByIds(ids);
    &#125;
</code></pre>
<pre><code class="java">IUserService.java
public interface IUserService extends IService&lt;User&gt; &#123;
    List&lt;UserVO&gt; queryUserAndAddressByIds(List&lt;Long&gt; ids);
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public List&lt;UserVO&gt; queryUserAndAddressByIds(List&lt;Long&gt; ids) &#123;
        // 1.查询用户
        List&lt;User&gt; users = listByIds(ids);
        if (CollUtil.isEmpty(users)) &#123;
            return Collections.emptyList();
        &#125;
        // 2.查询地址
        // 2.1 获取用户id集合
        List&lt;Long&gt; userIds = users.stream().map(User::getId).collect(Collectors.toList());
        // 2.2 根据用户id查询地址 这是全部地址
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class).in(Address::getUserId, userIds).list();
        // 2.3 转换地址VO
        List&lt;AddressVO&gt; addressVOList = BeanUtil.copyToList(addresses, AddressVO.class);
        // 2.4 梳理地址集合分组处理，分类整理，相同用户放入一个集合(组)中
        Map&lt;Long, List&lt;AddressVO&gt;&gt; addressMap = new HashMap&lt;&gt;(0);
        if (CollUtil.isNotEmpty(addressVOList))&#123;
            addressMap = addressVOList.stream().collect(Collectors.groupingBy(AddressVO::getUserId));
        &#125;
        // 3.转换VO返回
        List&lt;UserVO&gt; list = new ArrayList&lt;&gt;(users.size());
        for (User user : users) &#123;
            // 3.1 转换User的Po为VO
            UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
            list.add(userVO);

            // 3.2 转换地址VO
            userVO.setAddresses(addressMap.get(user.getId()));
        &#125;
        return null;
    &#125;
</code></pre>
<h3 id="扩展功能—逻辑删除要在数据库里面创建一个deleted表"><a href="#扩展功能—逻辑删除要在数据库里面创建一个deleted表" class="headerlink" title="扩展功能—逻辑删除要在数据库里面创建一个deleted表"></a>扩展功能—逻辑删除<del>要在数据库里面创建一个deleted表</del></h3><h6 id="订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息"><a href="#订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息" class="headerlink" title="订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息"></a>订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息</h6><p><strong>逻辑删除</strong>就是基于代码逻辑模拟删除效果，但并不会真正删除数据。思路如下：</p>
<ul>
<li>在表中添加一个字段标记数据是否被删除</li>
<li>当删除数据时把标记置为1</li>
<li>查询时只查询标记为0的数据</li>
</ul>
<p>例如逻辑删除字段为deleted：</p>
<p>• 删除操作：</p>
<pre><code class="mysql"># 是0才删除 是1就不用删除 所以用AND
UPDATE user SET deleted = 1 WHERE id = 1 AND deleted = 0
</code></pre>
<p>• 查询操作：</p>
<pre><code class="mysql"># 查询未删除的数据
SELECT * FROM user WHERE deleted = 0
</code></pre>
<h5 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h5><p><strong>MybatisPlus</strong>提供了逻辑删除功能，无需改变方法调用的方式，而是在底层帮我们自动修改CRUD的语句。我们要做的就是在application.yaml文件中配置逻辑删除的字段名称和值即可：</p>
<pre><code class="yaml">mybatis-plus: 
  global-config:    
   db-config:
    logic-delete-field: flag # 全局逻辑删除的实体字段名，字段类型可以是boolean、integer
    logic-delete-value: 1 # 逻辑已删除值(默认为 1)
    logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
</code></pre>
<h6 id="逻辑删除本身也有自己的问题，比如："><a href="#逻辑删除本身也有自己的问题，比如：" class="headerlink" title="逻辑删除本身也有自己的问题，比如："></a>逻辑删除本身也有自己的问题，比如：</h6><p>• 会导致数据库表垃圾数据越来越多，影响查询效率<br>• SQL中全都需要对逻辑删除字段做判断，影响查询效率</p>
<p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。</p>
<h3 id="扩展功能—枚举处理器"><a href="#扩展功能—枚举处理器" class="headerlink" title="扩展功能—枚举处理器"></a>扩展功能—枚举处理器</h3><p>像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p>
<p>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p>
<h3 id="3-3-1-定义枚举"><a href="#3-3-1-定义枚举" class="headerlink" title="3.3.1.定义枚举"></a><strong>3.3.1.定义枚举</strong></h3><p>我们定义一个用户状态的枚举：</p>
<pre><code class="java">User.java //使用枚举类型
// 使用状态(1正常 2冻结)
private UserStatus status;
</code></pre>
<p>要让<code>MybatisPlus</code>处理枚举与数据库类型自动转换，我们必须告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值。 <code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性：</p>
<pre><code class="java">package com.itheima.mp.enums;

import com.baomidou.mybatisplus.annotation.EnumValue;
import lombok.Getter;

@Getter
public enum UserStatus &#123;
    NORMAL(1, &quot;正常&quot;),
    FREEZE(2, &quot;冻结&quot;)
    ;
    @EnumValue
    private final int value;
    private final String desc;

    UserStatus(int value, String desc) &#123;
        this.value = value;
        this.desc = desc;
    &#125;
&#125;
</code></pre>
<h3 id="3-3-2-配置枚举处理器MP增加了Enum和JSON处理器"><a href="#3-3-2-配置枚举处理器MP增加了Enum和JSON处理器" class="headerlink" title="3.3.2.配置枚举处理器MP增加了Enum和JSON处理器"></a>3.3.2.配置枚举处理器<del>MP增加了Enum和JSON处理器</del></h3><p>在application.yaml文件中添加配置：</p>
<pre><code class="YAML">mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
</code></pre>
<pre><code class="java">UserVO.java
package com.itheima.mp.domain.vo;

import com.itheima.mp.enums.UserStatus;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.util.List;

@Data
@ApiModel(description = &quot;用户VO实体&quot;)
public class UserVO &#123;

    @ApiModelProperty(&quot;用户id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;详细信息&quot;)
    private String info;

    @ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)
    private UserStatus status;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;

    @ApiModelProperty(&quot;用户的收货地址&quot;)
    private List&lt;AddressVO&gt; addresses;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
 @Override
    public UserVO queryUserAndAddressById(Long id) &#123;
        // 1.查询用户
        User user = getById(id);
        if (user == null || user.getStatus() == UserStatus.FREEZE) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 2.查询方法
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)
                .eq(Address::getUserId, id).list();
        // 3.封装VO
        // 3.1 转User的PO为VO
        UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
        if (CollUtil.isEmpty(addresses)) &#123;
           userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));
        &#125;
        return userVO;
    &#125;
</code></pre>
<h6 id="想要前端返回正常还是冻结-JsonValue"><a href="#想要前端返回正常还是冻结-JsonValue" class="headerlink" title="想要前端返回正常还是冻结  @JsonValue"></a>想要前端返回正常还是冻结 <code> @JsonValue</code></h6><pre><code class="java">package com.itheima.mp.enums;

import com.baomidou.mybatisplus.annotation.EnumValue;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonValue;
import lombok.Getter;

@Getter
public enum UserStatus &#123;
    NORMAL(1, &quot;正常&quot;),
    FREEZE(2, &quot;冻结&quot;)
    ;
    @EnumValue
    private final int value;
    @JsonValue
    private final String desc;

    UserStatus(int value, String desc) &#123;
        this.value = value;
        this.desc = desc;
    &#125;
&#125;
</code></pre>
<h3 id="扩展功能—JSON处理器AbstractJsonTypeHandler"><a href="#扩展功能—JSON处理器AbstractJsonTypeHandler" class="headerlink" title="扩展功能—JSON处理器AbstractJsonTypeHandler"></a>扩展功能—JSON处理器<del>AbstractJsonTypeHandler</del></h3><p>数据库中user表中有一个json类型的字段</p>
<blockquote>
<p><strong>名称   数据类型      注释</strong><br>info    JSON            详细信息<br>。。。。。。。。。。。。</p>
<p>JSON：<br>{ “age”:20,<br>“intro”: “”青年”,<br>“gender”:”male”}</p>
</blockquote>
<p>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。</p>
<p>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p>
<p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p>
<h6 id="接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器："><a href="#接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：" class="headerlink" title="接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器："></a>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：</h6><p><code>@TableField(typeHandler = JacksonTypeHandler.class)</code> 定义类型处理器<br><code>@TableName(value = &quot;user&quot;, autoResultMap = true)</code></p>
<pre><code class="java">User.java
@Data
@TableName(value = &quot;user&quot;, autoResultMap = true)
public class User &#123;

    /**
     * 用户id
     */
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Long id;

    /**
     * 用户名
     */
    private String username;

    /**
     * 详细信息
     */
    @TableField(typeHandler = JacksonTypeHandler.class)
    private UserInfo info;
&#125;
</code></pre>
<pre><code class="java">UserVO.java
package com.itheima.mp.domain.vo;

import com.itheima.mp.domain.po.UserInfo;
import com.itheima.mp.enums.UserStatus;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.util.List;

@Data
@ApiModel(description = &quot;用户VO实体&quot;)
public class UserVO &#123;

    @ApiModelProperty(&quot;用户id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;详细信息&quot;)
    private UserInfo info;

    @ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)
    private UserStatus status;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;

    @ApiModelProperty(&quot;用户的收货地址&quot;)
    private List&lt;AddressVO&gt; addresses;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.mp.domain.po;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor(staticName = &quot;of&quot;)
public class UserInfo &#123;
    private Integer age;
    private String intro;
    private String gender;
    // 添加静态方法 of
    public static UserInfo of(Integer age, String intro, String gender) &#123;
        return new UserInfo(age, intro, gender);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserMapperTest.java
@SpringBootTest
class UserMapperTest &#123;

    @Autowired
    private UserMapper userMapper;

    @Test
    void testInsert() &#123;
        User user = new User();
        user.setId(5L);
        user.setUsername(&quot;Lucy&quot;);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;18688990011&quot;);
        user.setBalance(200);
        user.setInfo(UserInfo.of(14, &quot;英文老师&quot;, &quot;female&quot;));
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        userMapper.insert(user);
    &#125;
</code></pre>
<h3 id="插件功能—分页插件基本用法"><a href="#插件功能—分页插件基本用法" class="headerlink" title="插件功能—分页插件基本用法"></a>插件功能—分页插件基本用法</h3><p>MyBatisPlus提供的内置拦截器有下面这些：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>拦截器</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TenantLineInnerInterceptor</td>
<td>多租户插件</td>
</tr>
<tr>
<td>2</td>
<td>DynamicTableNameInnerInterceptor</td>
<td>动态表名插件</td>
</tr>
<tr>
<td>3</td>
<td>PaginationInnerInterceptor</td>
<td>分页插件</td>
</tr>
<tr>
<td>4</td>
<td>OptimisticLockerInnerInterceptor</td>
<td>乐观锁插件</td>
</tr>
<tr>
<td>5</td>
<td>IllegalSQLInnerInterceptor</td>
<td>SQL性能规范插件，检测并拦截垃圾SQL</td>
</tr>
<tr>
<td>6</td>
<td>BlockAttackInnerInterceptor</td>
<td>防止全表更新和删除的插件</td>
</tr>
</tbody></table>
<h6 id="首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】"><a href="#首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】" class="headerlink" title="首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】"></a>首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】</h6><pre><code class="java">@Configuration
public class MybatisConfig &#123;

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;
        // 1. 初始化核心插件
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 2. 添加分页插件
        PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);
        pageInterceptor.setMaxLimit(1000L); // 设置分页上限
        interceptor.addInnerInterceptor(pageInterceptor);
        return interceptor;
    &#125;
&#125;
</code></pre>
<h6 id="接着，就可以使用分页的API了：-IService里面就有"><a href="#接着，就可以使用分页的API了：-IService里面就有" class="headerlink" title="接着，就可以使用分页的API了：[IService里面就有]"></a>接着，就可以使用分页的API了：[IService里面就有]</h6><pre><code class="java">@Test
    void testPageQuery() &#123;
        // 1. 查询
        int pageNo = 1, pageSize = 5;
        // 1.1. 分页参数
        Page&lt;User&gt; page = Page.of(pageNo, pageSize);
        // 1.2. 排序参数, 通过OrderItem来指定
        page.addOrder(new OrderItem(&quot;balance&quot;, true));
        // 先按balance排序 再按id排序
        page.addOrder(new OrderItem(&quot;id&quot;, true));
        // 1.3. 分页查询
        Page&lt;User&gt; p = userService.page(page);
        // 2. 总条数
        System.out.println(&quot;total = &quot; + p.getTotal());
        // 3. 总页数
        System.out.println(&quot;pages = &quot; + p.getPages());
        // 4. 分页数据
        List&lt;User&gt; records = p.getRecords();
        records.forEach(System.out::println);
    &#125;
</code></pre>
<h3 id="插件功能—通用分页实体"><a href="#插件功能—通用分页实体" class="headerlink" title="插件功能—通用分页实体"></a>插件功能—通用分页实体</h3><h6 id="遵循下面的接口规范，编写一个UserController接口，实现User的分页查询"><a href="#遵循下面的接口规范，编写一个UserController接口，实现User的分页查询" class="headerlink" title="遵循下面的接口规范，编写一个UserController接口，实现User的分页查询"></a>遵循下面的接口规范，编写一个UserController接口，实现User的分页查询</h6><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>请求方式</td>
<td>GET</td>
</tr>
<tr>
<td>请求路径</td>
<td>&#x2F;users&#x2F;page</td>
</tr>
<tr>
<td>请求参数</td>
<td>“pageNo”: 1<br/>“pageSize”: 5<br/>“sortBy”: “balance”<br/>“isAsc”: false<br/>“name”: “jack”<br/>“status”: 1</td>
</tr>
<tr>
<td>返回值</td>
<td>“total”: 1005<br/>“pages”: 201<br/>“list”: 包含两个元素的数组，每个元素都是一个对象，包含以下键值对：<br/>“id”: 1 或 2<br/>“username”: “Jack” 或 “Rose”<br/>“info”: 包含以下键值对的对象：<br/>“age”: 21 或 20<br/>“gender”: “male” 或 “female”<br/>“intro”: “佛系青年” 或 “文艺青年”<br/>“status”: “正常” 或 “冻结”<br/>“balance”: 2000 或 1000</td>
</tr>
<tr>
<td>特殊说明</td>
<td>如果排序字段为空，默认按照更新时间排序  •排序字段不为空，则按照排序字段排序</td>
</tr>
</tbody></table>
<h6 id="准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】"><a href="#准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】" class="headerlink" title="准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】"></a>准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】</h6><p><code>写一个 【统一的分页条件】 和 【统一的分页结果】</code></p>
<pre><code class="java">com/itheima/mp/domain/query/UserQuery.java
// 要记得继承哦
package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery extends PageQuery&#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/query/PageQuery.java
package com.itheima.mp.domain.query;

import com.baomidou.mybatisplus.core.metadata.OrderItem;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;分页查询实体&quot;)
public class PageQuery &#123;
    @ApiModelProperty(&quot;页码&quot;)
    private Integer pageNo;
    @ApiModelProperty(&quot;页码个数&quot;)
    private Integer pageSize;
    @ApiModelProperty(&quot;排序字段&quot;)
    private String sortBy;
    @ApiModelProperty(&quot;是否升序&quot;)
    private Boolean isAsc;

    public &lt;T&gt;  Page&lt;T&gt; toMpPage(OrderItem ... orders)&#123;
        // 1.分页条件
        Page&lt;T&gt; p = Page.of(pageNo, pageSize);
        // 2.排序条件
        // 2.1.先看前端有没有传排序字段
        if (sortBy != null) &#123;
            p.addOrder(new OrderItem(sortBy, isAsc));
            return p;
        &#125;
        // 2.2.再看有没有手动指定排序字段
        if(orders != null)&#123;
            p.addOrder(orders);
        &#125;
        return p;
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPage(String defaultSortBy, boolean isAsc)&#123;
        return this.toMpPage(new OrderItem(defaultSortBy, isAsc));
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByCreateTimeDesc() &#123;
        return toMpPage(&quot;create_time&quot;, false);
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByUpdateTimeDesc() &#123;
        return toMpPage(&quot;update_time&quot;, false);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/dto/PageDTO.java
package com.itheima.mp.domain.dto;

import cn.hutool.core.bean.BeanUtil;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

@Data
@ApiModel(description = &quot;分页结果&quot;)
@NoArgsConstructor
@AllArgsConstructor
public class PageDTO&lt;V&gt; &#123;
    @ApiModelProperty(&quot;总条数&quot;)
    private Long total;
    @ApiModelProperty(&quot;总页数&quot;)
    private Long pages;
    @ApiModelProperty(&quot;集合&quot;)
    private List&lt;V&gt; list;

    /**
     * 返回空分页结果
     * @param p MybatisPlus的分页结果
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; empty(Page&lt;P&gt; p)&#123;
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果
     * @param p MybatisPlus的分页结果
     * @param voClass 目标VO类型的字节码
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Class&lt;V&gt; voClass) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式
     * @param p MybatisPlus的分页结果
     * @param convertor PO到VO的转换函数
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">com/itheima/mp/controller/UserController.java
@ApiOperation(&quot;根据复杂条件查询用户接口&quot;)
    @GetMapping(&quot;/list&quot;)
    public List&lt;UserVO&gt; queryUsers(UserQuery query) &#123;
        return (List&lt;UserVO&gt;) userService.queryUsersPage(query);
    &#125;
</code></pre>
<pre><code class="java">// 如果你想在字符串中表示一个大于号，
你可以直接输入 &gt;，或者使用HTML实体 &amp;gt; 
小于号可以使用 &lt; 或者 &amp;lt;，
等于号可以使用 = 或者 &amp;equals
</code></pre>
<h3 id="插件功能—通用分页实体与MP转换"><a href="#插件功能—通用分页实体与MP转换" class="headerlink" title="插件功能—通用分页实体与MP转换"></a>插件功能—通用分页实体与MP转换</h3><p>需求：</p>
<ul>
<li>在PageQuery中定义方法，将PageQuery对象转为MyBatisPlus中的Page对象</li>
<li>在PageDTO中定义方法，将MyBatisPlus中的Page结果转为PageDTO结果</li>
</ul>
<h6 id="最好直接封装通用部分"><a href="#最好直接封装通用部分" class="headerlink" title="最好直接封装通用部分"></a>最好直接封装通用部分</h6><h5 id="封装查询"><a href="#封装查询" class="headerlink" title="封装查询"></a>封装查询</h5><pre><code class="java"> @Override
    public PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query) &#123;
        String name = query.getName();
        Integer status = query.getStatus();
        // 1.构建查询条件
        // 1.1 分页条件
        Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());
        // 1.2 排序条件
        if (StrUtil.isNotBlank(query.getSortBy())) &#123;
            // 不为空
            page.addOrder(new OrderItem(query.getSortBy(), query.getIsAsc()));
        &#125;else &#123;
            // 为空，默认按照更新时间排序
            page.addOrder(new OrderItem(&quot;update_time&quot;, false));
        &#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/query/PageQuery.java
package com.itheima.mp.domain.query;

import com.baomidou.mybatisplus.core.metadata.OrderItem;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;分页查询实体&quot;)
public class PageQuery &#123;
    @ApiModelProperty(&quot;页码&quot;)
    private Integer pageNo;
    @ApiModelProperty(&quot;页码个数&quot;)
    private Integer pageSize;
    @ApiModelProperty(&quot;排序字段&quot;)
    private String sortBy;
    @ApiModelProperty(&quot;是否升序&quot;)
    private Boolean isAsc;

    public &lt;T&gt;  Page&lt;T&gt; toMpPage(OrderItem ... orders)&#123;
        // 1.分页条件
        Page&lt;T&gt; p = Page.of(pageNo, pageSize);
        // 2.排序条件
        // 2.1.先看前端有没有传排序字段
        if (sortBy != null) &#123;
            p.addOrder(new OrderItem(sortBy, isAsc));
            return p;
        &#125;
        // 2.2.再看有没有手动指定排序字段
        if(orders != null)&#123;
            p.addOrder(orders);
        &#125;
        return p;
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPage(String defaultSortBy, boolean isAsc)&#123;
        return this.toMpPage(new OrderItem(defaultSortBy, isAsc));
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByCreateTimeDesc() &#123;
        return toMpPage(&quot;create_time&quot;, false);
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByUpdateTimeDesc() &#123;
        return toMpPage(&quot;update_time&quot;, false);
    &#125;
&#125;
</code></pre>
<h5 id="封装结果"><a href="#封装结果" class="headerlink" title="封装结果"></a>封装结果</h5><pre><code class="java">// 3.封装VO结果
        PageDTO&lt;UserVO&gt; dto = new PageDTO&lt;&gt;();
        // 3.1 总条数
        dto.setTotal(p.getTotal());
        // 3.2 总页数
        dto.setPages(p.getPages());
        // 3.3 当前页数据
        List&lt;User&gt; records = p.getRecords();
        if (CollUtil.isEmpty(records)) &#123;
            dto.setList(Collections.emptyList());
            return dto;
        &#125;
        // 3.4 拷贝user的VO
        dto.setList(BeanUtil.copyToList(records, UserVO.class));
        // 4.返回
        return dto;
    &#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/dto/PageDTO.java
package com.itheima.mp.domain.dto;

import cn.hutool.core.bean.BeanUtil;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

@Data
@ApiModel(description = &quot;分页结果&quot;)
@NoArgsConstructor
@AllArgsConstructor
public class PageDTO&lt;V&gt; &#123;
    @ApiModelProperty(&quot;总条数&quot;)
    private Long total;
    @ApiModelProperty(&quot;总页数&quot;)
    private Long pages;
    @ApiModelProperty(&quot;集合&quot;)
    private List&lt;V&gt; list;

    /**
     * 返回空分页结果
     * @param p MybatisPlus的分页结果
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; empty(Page&lt;P&gt; p)&#123;
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果
     * @param p MybatisPlus的分页结果
     * @param voClass 目标VO类型的字节码
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Class&lt;V&gt; voClass) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式
     * @param p MybatisPlus的分页结果
     * @param convertor PO到VO的转换函数
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query) &#123;
        String name = query.getName();
        Integer status = query.getStatus();
        // 1.构建查询条件
        // 1.1 分页条件
        Page&lt;User&gt; page = query.toMpPageDefaultSortByUpdateTimeDesc();
        // 2. 分页查询
        Page&lt;User&gt; p = lambdaQuery()
                .like(name != null, User::getUsername, name)
                .eq(status != null, User::getStatus, status)
                .page(page);
        // 3. 封装VO结果
//        return PageDTO.of(p, UserVO.class); 属性转换 ↓
        return PageDTO.of(p, user -&gt; &#123;
            // 1.拷贝基础属性
            UserVO vo = BeanUtil.copyProperties(user, UserVO.class);
            // 2.处理特殊逻辑 密码加**
            vo.setUsername(vo.getUsername().substring(0, vo.getUsername().length()-2)+&quot;**&quot;);
            return vo;
        &#125;);
    &#125;
</code></pre>
<hr>
<hr>
<hr>
<h3 id="tilas-all-成功案例"><a href="#tilas-all-成功案例" class="headerlink" title="tilas-all 成功案例"></a>tilas-all 成功案例</h3><pre><code class="java">package com.itheima.domain.dto;

import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class GenderStatisticsDTO &#123;
    private String name;
    private Integer value;

&#125;
==================================================
package com.itheima.domain.dto;

import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName(&quot;emp&quot;)
public class JobStatisticsDTO &#123;
    private List&lt;String&gt; jobList;
    private List&lt;Long&gt; dataList;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.domain.dto.CombinedStatisticsDTO;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.pojo.Emp;

import java.util.List;

public interface ReportService extends IService&lt;Emp&gt; &#123;
    List&lt;GenderStatisticsDTO&gt; getGenderStatistics(); // 获取性别统计信息
    JobStatisticsDTO getJobStatistics(); // 获取职位统计信息
&#125;


//    CombinedStatisticsDTO getCombinedStatistics();
</code></pre>
<pre><code class="java">com/itheima/controller/ReportController.java
package com.itheima.controller;

import com.itheima.domain.dto.CombinedStatisticsDTO;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.pojo.Result;
import com.itheima.service.ReportService;
import io.swagger.annotations.Api;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@Api(tags = &quot;报表统计接口&quot;)
@RestController
@RequestMapping(&quot;/report&quot;)
@RequiredArgsConstructor
public class ReportController &#123;

    private final ReportService reportService;

    // 获取合并后的统计信息
//    @GetMapping(&quot;/statistics&quot;)
//    public Result&lt;CombinedStatisticsDTO&gt; getStatistics() &#123;
//        CombinedStatisticsDTO combinedStatistics = reportService.getCombinedStatistics();
//        return Result.success(combinedStatistics);
//    &#125;

    // 获取员工性别统计信息
    @GetMapping(&quot;/empGenderData&quot;)
    public Result&lt;List&lt;GenderStatisticsDTO&gt;&gt; getEmployeeGenderStatistics() &#123;
        List&lt;GenderStatisticsDTO&gt; genderStatistics = reportService.getGenderStatistics();
        return Result.success(genderStatistics);
    &#125;

    // 获取员工职位统计信息
    @GetMapping(&quot;/empJobData&quot;)
    public Result&lt;JobStatisticsDTO&gt; getEmployeeJobStatistics() &#123;
        JobStatisticsDTO jobStatistics = reportService.getJobStatistics();
        return Result.success(jobStatistics);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/service/impl/ReportServiceImpl.java
package com.itheima.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.mapper.ReportMapper;
import com.itheima.pojo.Emp;
import com.itheima.service.ReportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class ReportServiceImpl extends ServiceImpl&lt;ReportMapper, Emp&gt; implements ReportService &#123;

    private final ReportMapper reportMapper;

    @Autowired
    public ReportServiceImpl(ReportMapper reportMapper) &#123;
        this.reportMapper = reportMapper;
    &#125;

    // 获取员工职位统计信息
    @Override
    public JobStatisticsDTO getJobStatistics() &#123;
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();

        // 修改查询字段，注意这里你仍然需要写正确的字段名
        wrapper.select(&quot;CASE job WHEN 1 THEN &#39;班主任&#39; WHEN 2 THEN &#39;讲师&#39; WHEN 3 THEN &#39;学工主管&#39; WHEN 4 THEN &#39;校研主管&#39; WHEN 5 THEN &#39;咨询师&#39; ELSE &#39;其他&#39; END AS 职位&quot;,
                        &quot;COUNT(*) AS 数量&quot;)
                .groupBy(&quot;job&quot;);

        // 通过 selectMaps 执行查询
        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 创建两个列表来存储职位和数量
        List&lt;String&gt; jobTitles = new ArrayList&lt;&gt;();
        List&lt;Long&gt; counts = new ArrayList&lt;&gt;();

        // 遍历查询结果并填充列表
        for (Map&lt;String, Object&gt; stat : statistics) &#123;
            jobTitles.add((String) stat.get(&quot;职位&quot;));
            counts.add((Long) stat.get(&quot;数量&quot;));
        &#125;

        // 返回JobStatisticsDTO对象，传入两个列表
        return new JobStatisticsDTO(jobTitles, counts);
    &#125;

    // 获取员工性别统计信息
    @Override
    public List&lt;GenderStatisticsDTO&gt; getGenderStatistics() &#123;
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.select(&quot;gender&quot;, &quot;COUNT(gender) AS value&quot;)
                .groupBy(&quot;gender&quot;);

        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 转换为 GenderStatisticsDTO
        return statistics.stream()
                .map(stat -&gt; &#123;
                    String genderName = &quot;1&quot;.equals(String.valueOf(stat.get(&quot;gender&quot;))) ? &quot;男性员工&quot; : &quot;女性员工&quot;;
                    int count = ((Number) stat.get(&quot;value&quot;)).intValue();
                    return new GenderStatisticsDTO(genderName, count);
                &#125;)
                .collect(Collectors.toList());
    &#125;
&#125;
</code></pre>
<h6 id="上面的获取员工职位属性已修改为高级版本"><a href="#上面的获取员工职位属性已修改为高级版本" class="headerlink" title="上面的获取员工职位属性已修改为高级版本"></a>上面的获取员工职位属性已修改为高级版本</h6><pre><code class="java">// 获取员工职位统计信息
    @Override
    public JobStatisticsDTO getJobStatistics() &#123;
        // 1. 构建查询条件
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.select(&quot;job&quot;, &quot;COUNT(*) AS count&quot;)
                .groupBy(&quot;job&quot;);

        // 2. 查询数据
        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 如果返回结果为 null 或为空列表，返回默认对象
        if (statistics == null || statistics.isEmpty()) &#123;
            return new JobStatisticsDTO(new ArrayList&lt;&gt;(), new ArrayList&lt;&gt;());
        &#125;

        // 3. 转换结果：处理 `null` 值和字段映射
        List&lt;String&gt; jobTitles = new ArrayList&lt;&gt;();
        List&lt;Long&gt; counts = new ArrayList&lt;&gt;();

        for (Map&lt;String, Object&gt; stat : statistics) &#123;
            if (stat == null) &#123;
                continue; // 跳过 null 数据
            &#125;

            // 使用 `getOrDefault` 方法，确保不会返回 null
            Integer jobCode = (Integer) stat.getOrDefault(&quot;job&quot;, -1);
            Long count = stat.get(&quot;count&quot;) == null ? 0L : ((Number) stat.get(&quot;count&quot;)).longValue();

            // 如果 jobCode 是 -1 或其他无效值，则视为“其他”
            String jobTitle = switch (jobCode) &#123;
                case 1 -&gt; &quot;班主任&quot;;
                case 2 -&gt; &quot;讲师&quot;;
                case 3 -&gt; &quot;学工主管&quot;;
                case 4 -&gt; &quot;校研主管&quot;;
                case 5 -&gt; &quot;咨询师&quot;;
                default -&gt; &quot;其他&quot;;
            &#125;;

            jobTitles.add(jobTitle);
            counts.add(count);
        &#125;

        // 返回封装好的 DTO 对象
        return new JobStatisticsDTO(jobTitles, counts);
    &#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/23/后端/MyBatisPlus/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/22/后端/Stream模板+Lambda常用+@注释+常用方法模板集合/">
        <h2>
            Stream模板+Lambda常用+@注释+常用方法模板集合
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/22
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Stream模板"><a href="#Stream模板" class="headerlink" title="Stream模板"></a>Stream模板</h1><h6 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h6><p>中间方法的特点惰性求值：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。可以链式调用：多个中间操作可以链接在一起，形成一个操作链。返回类型：所有的中间操作返回的都是一个 Stream 对象。</p>
<h6 id="Stream中间代码"><a href="#Stream中间代码" class="headerlink" title="Stream中间代码"></a>Stream中间代码</h6><pre><code class="java">功能：过滤流中的元素，仅保留满足给定条件的元素。
// 示例：
Stream.of(1, 2, 3, 4, 5)
      .filter(n -&gt; n % 2 == 0) // 只保留偶数
      .forEach(System.out::println);//打印功能：将流中的元素映射为其他形式（通常是不同类型）。
// 示例：
Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。示例：Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);功能：去除流中的重复元素。示例：Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4功能：对流中的元素进行排序。示例：Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);功能：截取流中的前 maxSize 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);功能：跳过流中的前 n 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5下面是一个示例，展示了多种中间方法的使用：import java.util.Arrays;
import java.util.List;
</code></pre>
<details class="lake-collapse"><summary id="u41427c34"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 16px">中间方法：</span></strong></summary><ol class="ne-ol"><li id="ue6d895fe" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">中间方法的特点<br /></span></strong><a href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">惰性求值</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">可以</span></strong><a href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">链式调用</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：多个中间操作可以链接在一起，形成一个操作链。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">返回类型：所有的中间操作返回的都是一个 Stream 对象。</span></strong></li></ol></details>
<details class="lake-collapse"><summary id="ueec7bf3e"><strong><span class="ne-text" style="color: #DF2A3F">stream中间操作</span></strong></summary><p id="u9155c15c" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：过滤流中的元素，仅保留满足给定条件的元素。</span></strong></p><p id="ue9508648" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oyHwt" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
.filter(n -&gt; n % 2 == 0) // 只保留偶数
.forEach(System.out::println);//打印</code></pre><p id="u7087b579" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素映射为其他形式（通常是不同类型）。</span></strong></p><p id="uec5be4e7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="rVrS1" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写</code></pre><p id="ufc5f99d4" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。</span></strong></p><p id="ub40cb3ec" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="NUaVI" class="ne-codeblock language-java"><code>Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);</code></pre><p id="u9bb719ff" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F">功能：去除流中的重复元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="Q888J" class="ne-codeblock language-java"><code>Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4</code></pre><p id="u18f09612" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">功能：对流中的元素进行排序。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">示例：</span></strong></p><pre data-language="java" id="JLF00" class="ne-codeblock language-java"><code>Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);</code></pre><p id="ue50c0c95" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：截取流中的前 maxSize 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="OdjlP" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);</code></pre><p id="u5c024d35" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：跳过流中的前 n 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="fN4RR" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5</code></pre><p id="u05623b28" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种中间方法的使用：</span></strong></p><pre data-language="java" id="wLvBv" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
public class StreamIntermediateOperations &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;, &quot;Eve&quot;);

<pre><code>    // 使用中间方法
    names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;)) // 过滤以 &#39;A&#39; 开头的名字
        .map(String::toUpperCase) // 将名字转换为大写
        .sorted() // 排序
        .forEach(System.out::println); // 输出结果
&#125;
</code></pre>
<p>}</code></pre><p id="ud6df2a51" class="ne-p"><br></p></details></p>
<details class="lake-collapse"><summary id="u8303321d"><strong><span class="ne-text">终结方法</span></strong></summary><p id="u6620a2d6" class="ne-p"><strong><span class="ne-text">在 Java Stream API 中，终结方法（Terminal Operations）是指那些会触发流的计算并最终产生结果的方法。与中间操作不同，终结方法会结束流的操作链，并返回一个具体的结果或副作用。以下是对终结方法的详细介绍：</span></strong></p><p id="ued92678c" class="ne-p"><strong><span class="ne-text">1. 终结方法的特点</span></strong></p><p id="u4f276cc4" class="ne-p"><strong><span class="ne-text">触发计算：终结方法会对流中的数据进行处理并生成结果，通常会遍历流中的所有元素。</span></strong></p><p id="u06c9bbef" class="ne-p"><strong><span class="ne-text">返回类型：终结方法可以返回不同类型的结果，包括：</span></strong></p><p id="ucfcd69c3" class="ne-p"><strong><span class="ne-text">基本类型（如 int、double）</span></strong></p><p id="u477c4769" class="ne-p"><strong><span class="ne-text">对象（如 List、Set、Map）</span></strong></p><p id="u935ad81e" class="ne-p"><strong><span class="ne-text">特殊值（如 Optional、Void）</span></strong></p></details>
<details class="lake-collapse"><summary id="u2b491d90"><strong><span class="ne-text" style="color: #DF2A3F">终结方法</span></strong></summary><p id="u6772e1b1" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：对流中的每个元素执行指定的操作。</span></strong></p><p id="udd84ed9a" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oUmRF" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).forEach(System.out::println);</code></pre><p id="u8e4efc31" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素收集到集合或其他形式。</span></strong></p><p id="u5b5cf4d3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="zF3zf" class="ne-codeblock language-java"><code>List&lt;String&gt; list = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).collect(Collectors.toList());</code></pre><p id="u76f88dab" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F; font-size: 14px">功</span></strong><strong><span class="ne-text" style="color: #DF2A3F">能：对流中的元素进行归约，返回一个单一的结果。</span></strong></p><p id="ue96e0ab3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="H9hY0" class="ne-codeblock language-java"><code>int sum = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</code></pre><p id="uab6649eb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中元素的数量。</span></strong></p><p id="u88fba7fd" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="ATK6U" class="ne-codeblock language-java"><code>long count = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).count();</code></pre><p id="u2f406546" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中是否有任何元素满足给定的条件。</span></strong></p><p id="uc612e6ba" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="yGMii" class="ne-codeblock language-java"><code>boolean hasA = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).anyMatch(s -&gt; s.equals(&quot;a&quot;));</code></pre><p id="u371b5ce7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中所有元素是否满足给定的条件。</span></strong></p><p id="ufd1731bb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="O6I5A" class="ne-codeblock language-java"><code>boolean allMatch = Stream.of(1, 2, 3).allMatch(n -&gt; n &lt; 5);</code></pre><p id="u5928384b" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中的第一个元素（如果存在）。</span></strong></p><p id="ufe6ffdc2" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="qh5FK" class="ne-codeblock language-java"><code>Optional&lt;String&gt; first = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).findFirst();</code></pre><p id="ub4cf4986" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种终结方法的使用：</span></strong></p><pre data-language="java" id="dakWh" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;


<p>public class StreamTerminalOperations &#123;<br>    public static void main(String[] args) &#123;<br>        List&lt;String&gt; names &#x3D; Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;);</p>
<pre><code>    // forEach
    names.stream().forEach(System.out::println);

    // collect
    List&amp;lt;String&amp;gt; filteredNames = names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;))
        .collect(Collectors.toList());
    System.out.println(filteredNames);

    // reduce
    String concatenated = names.stream()
        .reduce(&amp;quot;&amp;quot;, (a, b) -&amp;gt; a + b);
    System.out.println(concatenated);
    
    // count
    long count = names.stream().count();
    System.out.println(&amp;quot;Count: &amp;quot; + count);
    
    // findFirst
    String firstName = names.stream().findFirst().orElse(&amp;quot;No Name&amp;quot;);
    System.out.println(&amp;quot;First Name: &amp;quot; + firstName);
&#125;
</code></pre>
<p>}</code></pre></details></p>
<h3 id="stream流超强引用"><a href="#stream流超强引用" class="headerlink" title="stream流超强引用"></a>stream流超强引用</h3><pre><code class="java">package com.itheima.pojo.test;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Arrays.asList 是 Java 中 java.util.Arrays 类的一个静态方法，
 * 用于将指定的数组或可变数量的参数转换为一个固定大小的 List。
 * 这个 List 是 ArrayList 的一个内部实现类，
 * 但它不是 java.util.ArrayList，
 * 而是一个不可变的列表
 */
public class Test2 &#123;
    public static void main(String[] args) &#123;
        // List&lt;String&gt; list：将上述列表赋值给 list 变量
        List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);
        // 定义一个映射，键为整数，值为字符串列表 = 创建一个新的空哈希映射
        // 键的类型是 Integer，值的类型是 List&lt;String&gt; 表示具有相同长度的字符串列表
        // 用HashMap  允许 null 值：键和值都可以为 null，但键只能有一个 null。
        Map&lt;Integer, List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
        for (String s : list) &#123;
            int length = s.length();
            // 检查 groups 映射中是否已经存在键为 length 的条目
            if (!groups.containsKey(length)) &#123;
                // 将新创建的列表作为值，以 length 为键添加到 groups 映射中
                // 创建一个新的 ArrayList，并将当前字符串 s 添加到其中
                groups.put(length, new ArrayList&lt;&gt;(Arrays.asList(s)));
            &#125; else &#123;
                // 从 groups 映射中获取键为 length 的列表
                List&lt;String&gt; group = groups.get(length);
                group.add(s);
            &#125;
            System.out.println(groups);
        &#125;

        // 使用 Stream API 进行分组
        // 使用 Collectors.groupingBy 方法按字符串长度进行分组
        // 将分组结果收集到一个新的映射 group2 中。
        Map&lt;Integer, List&lt;String&gt;&gt; group2 = list.stream().collect(Collectors.groupingBy(String::length));
        System.out.println(group2);
    &#125;
&#125;
</code></pre>
<h1 id="Lambda-Stream实用方法"><a href="#Lambda-Stream实用方法" class="headerlink" title="Lambda+Stream实用方法"></a>Lambda+Stream实用方法</h1><pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.for循环输出
for (String s : list)&#123;
System.out.println(s);&#125;

2.表达式输出   
list.forEach(s -&gt;
System.out.println(s);&#125;);

3.表达式最简洁输出
List.forEach(System.out::println);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.使用重写Collections 排序
Collections.sort(list,new Comparator&lt;String&gt;（） &#123;
@override
public int compare(String o1, String o2) &#123;
return o1.compareTo(o2);
&#125;
&#125;);

2.使用lambda表达式排序
Collections.sort(list,(o1,o2) -&gt;&#123;
    return o1.compareTo(o2)
&#125;);

3.使用最简洁的表达式
Collections.sort(list,(o1,o2) -&gt;&#123;o1.compareTo(o2)&#125;);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式过滤
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
List&lt;String s : list2)&#123;
if(s.startsWith(&quot;a&quot;))&#123;
     list2.add(s);
&#125; &#125;

2.使用 Stream API 进行过滤和收集,过滤以 &#39;a&#39; 开头的字符串,收集结果到一个新的 List 中
List&lt;String&gt;list3 = list.stream().filter(s - &gt; s.startsWith(&quot;a&quot;)).collect(Collectrs.toList());
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式获取长度
List&lt;Integer&gt; List2 = new ArrayList&lt;&gt;();
for （String s:list)&#123;
    
list2.add(s.length());&#125;

2.Lambda表达式+stream流获取长度
(map)这个函数对我们管道中的每个元素做了处理，在此处为把string转换为Integer类型 主要进行转换作用
List&lt;Integer&gt; list3 = list.stream().map(s -&gt; s.length()).collect(Collectors.toList());
</code></pre>
<pre><code class="java">//新建一个List集合
List&lt;Integer&gt; list = Arrays.asList（1,2, 3, 4, 5);
1.普通方式相加操作
int sum =0;
for (Integer v : list) &#123;
SUm +=V  &#125;
System.out.println(sum);

2.Lambda+stream
(表达式含义)：【0】操作的起始值，【a = a+b】 循环下去
int sum2 = list.stream().reduce( identity: 0, (a, b) -&gt; a + b);
System.out.println(sum2)
</code></pre>
<pre><code class="java">//新建一个集合
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);

Map&lt;Integer,List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();

1.普通方式分组
for （String s:list)&#123;
int length = s.length();
if (!groups.containsKey(length))&#123;
groups.put(length,new ArrayList&lt;&gt;());
&#125;
groups.get(Length) .add(s);
&#125;
    System.out.println(groups);

2.Lambda+stream分组
Map&lt;Integer,List&lt;String&gt;&gt; groups2 = list.stream().collect(Collectors.groupingBy(String::length));
System.out.println（groups2）
</code></pre>
<pre><code class="java">1.普通方式创建线程

Thread thread = newThread(new Runnable()&#123;
@Override
public void run()&#123;
System.out.println(&quot;hello world&quot;);
&#125;
&#125;);
thread.start();

2.Lambda表达式

Thread thread1 = new Threal(() -&gt; System.out.println(hello world&quot;));
thread1.start();
</code></pre>
<pre><code class="java">1.创建接口
interface  MyInterface&#123;
public void doSomething(String s);&#125;

2.普通实现接口
MyInterface myInterface = new MyInterface&#123;
    @override
    public void doSomething(String s)&#123;
    System.out.println(s);
    &#125;
&#125;;
myInterface.doSomething( s:&quot;hello world&quot;);

3.Lambda表达式实现接口
MyInterface myInterface1 = (s) -&gt; System.out.println(s);
myInterface1.doSomething( s:&quot;hello worLd&quot;)
</code></pre>
<pre><code class="java">String str = &quot;hello world&quot;;

1.普通方式
if（str !=null）&#123;
System.out.println(str.toUpperCase());&#125;

2.Lambda表达式
Optional.ofNuLlable(str).map(String::toUpperCase).ifPresent(System.out::println);
</code></pre>
<pre><code class="java">List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.普通方式
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
for （String s:list2)&#123; //遍历循环
    if （s.startsWith(&quot;a&quot;))&#123; //取出 包含a的元素
        list2.add(s.toUpperCase());//添加到list2中然后转换为大写
    &#125;
&#125;       Collections.sort(list2); //排序

2.Lambda+stream方式

List&lt;String&gt; list3 = list.stream().filter(s -&gt; s.startsWith(&quot;a&quot;))
.map(String::toupperCase).sorted().collect(collectors.toList());
</code></pre>
<pre><code class="java">public class Dept &#123;
    private int id;

    public Dept(int id) &#123;
        this.id = id;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Dept&#123;id=&quot; + id + &quot;&#125;&quot;;
    &#125;
&#125;

public class TestCollectStopOptions &#123;

    public void testCollectStopOptions() &#123;
        // 创建一个包含 Dept 对象的列表
        List&lt;Dept&gt; ids = Arrays.asList(new Dept(17), new Dept(22), new Dept(23));

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 List 中
        List&lt;Dept&gt; collectList = ids.stream()
                                   .filter(dept -&gt; dept.getId() &gt; 20)
                                   .collect(Collectors.toList());
        System.out.println(&quot;collectList: &quot; + collectList);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Set 中
        Set&lt;Dept&gt; collectSet = ids.stream()
                                 .filter(dept -&gt; dept.getId() &gt; 20)
                                 .collect(Collectors.toSet());
        System.out.println(&quot;collectSet: &quot; + collectSet);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Map 中，key 为 id，value 为 Dept 对象
        Map&lt;Integer, Dept&gt; collectMap = ids.stream()
                                          .filter(dept -&gt; dept.getId() &gt; 20)
                                          .collect(Collectors.toMap(Dept::getId, dept -&gt; dept));
        System.out.println(&quot;collectMap: &quot; + collectMap);
    &#125;

    public static void main(String[] args) &#123;
        new TestCollectStopOptions().testCollectStopOptions();
    &#125;
&#125;

结果

collectList:[Dept&#123;id=22&#125;, Dept&#123;id=23&#125;]
collectSet:[Dept&#123;id=23&#125;, Dept&#123;id=22&#125;]
collectMap:&#123;22=Dept&#123;id=22&#125;, 23=Dept&#123;id=23&#125;&#125;
</code></pre>
<pre><code class="java">import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class User &#123;
    private String id;

    public User() &#123;
    &#125;

    public String getId() &#123;
        return id;
    &#125;

    public void setId(String id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;id=&#39;&quot; + id + &#39;\&#39;&#39; + &#39;&#125;&#39;;
    &#125;
&#125;

public class TestStringToIntMap &#123;

    /**
     * 演示map的用途：一对一转换
     */
    public void stringToIntMap() &#123;
        // 创建一个包含字符串 ID 的列表
        List&lt;String&gt; ids = Arrays.asList(&quot;205&quot;, &quot;105&quot;, &quot;308&quot;, &quot;469&quot;, &quot;627&quot;, &quot;193&quot;, &quot;111&quot;);

        // 使用流操作
        List&lt;User&gt; results = ids.stream()
                               .map(id -&gt; &#123;
                                   // 创建一个新的 User 对象
                                   User user = new User();
                                   // 设置 User 对象的 id 属性
                                   user.setId(id);
                                   // 返回 User 对象
                                   return user;
                               &#125;)
                               .collect(Collectors.toList()); // 收集结果到一个新的 List 中

        // 打印结果
        System.out.println(results);
    &#125;

    public static void main(String[] args) &#123;
        new TestStringToIntMap().stringToIntMap();
    &#125;
&#125;
</code></pre>
<h1 id="注释笔记"><a href="#注释笔记" class="headerlink" title="@注释笔记"></a>@注释笔记</h1><p>@RequestBody ：获取请全体json字符串数据 封装给java对象，封装的前提是 json字符串属性要与实体类属性名一致才可以封装。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>#{name} 占位符 会从方法参数 对象里面调用getname封装方法获取数据映射到占位符位置。</p>
<p>#{参数名} 是Mybatis的参数占位符，可以自动将参数映射到SQL语句去执行</p>
<p>参数名要与接口方法的参数名要一致，但是方法只有一个参数时，参数名可以是任意的。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>Spring MVC 的 <font style="color:#DF2A3F;">@RequestMapping </font>注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的请求默认都会是 HTTP GET 类型的。比如<font style="color:#DF2A3F;">@GetMapping </font></p>
<p><font style="color:#DF2A3F;">加入路径处理前端响应</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>注解<font style="color:#DF2A3F;">@RequiredArgsConstructor</font> 是 Lombok 提供的一个注解，其主要作用在于简化 @Autowired 的书写过程。在编写 Controller 层或 Service 层代码时，常常需要注入众多的 mapper 接口或 service 接口。若每个接口都使用 @Autowired 进行标注，代码会显得繁琐。而 @RequiredArgsConstructor 注解能够替代 @Autowired 注解，但需注意，在类上添加 @RequiredArgsConstructor 时，需要注入的类必须使用 final 进行声明。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;"> ：</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">的作用与</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Controller&lt;/font&gt;</code><font style="color:#000000;">，</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Service&lt;/font&gt;</code><font style="color:#000000;">的作用都是把对象交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">是标注在</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Dao&lt;/font&gt;</code><font style="color:#000000;">层接口上，作用是将接口的一个实现类交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Mapper</font></p>
<p><font style="color:#000000;">@Mapper: 这个注解一般使用在Dao层接口上，相当于一个mapper.xml文件，它的作用就是将接口生成一个动态代理类。加入了@Mapper注解，目的就是为了不再写mapper映射文件。这个注解就是用来映射mapper.xml文件的。</font></p>
<p><font style="color:#000000;">使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中</font></p>
<p><font style="color:#000000;">注意：</font></p>
<p><font style="color:#000000;">在Dao层不要存在相同名字的接口，也就是在Dao不要写重载。因为mapper文件是通过id与接口进行对应的，如果写了两个同名的接口，就会导致mapper文件映射出错。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Transactional </font></p>
<p><font style="color:#000000;">Spring事务管理-控制事务 注解:@Transactional</font></p>
<p><font style="color:#000000;">作用:将当前方法交给spring进行事务管理，方法执行前，开启事务;成功执行完毕，提交事务;出现异常，回滚事务  放在类上 则是整个类都会启动事务  放在接口上 接口的实现类都会去启动事务。放在方法上此方法中的代码会启动事务。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>规则:JSON数据的键名与方法形参对象的属性名相同，并需要使用@RequestBody注解标识。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>MultipartFile  接收文件接口</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@Service 表明这个是逻辑层 可以被调用</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ConfigurationPropertise（）</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#000000;">@Autowired 注入bean</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;background-color:#131314;">集合:@RequestParam[List<Integer> ids</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>是一个在Java项目中常用的注解，特别是在使用日志框架如SLF4J时，通过在你的类上使用<code>@Slf4j</code>注解，Lombok会自动为你的类生成一个静态的日志字段，这个字段通常是<code>org.slf4j.Logger</code>类型的，并且通常命名为<code>log</code>。这样，你就可以在类中直接使用<code>log.info()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.error()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.debug()</code>等方法来记录日志，而无需手动声明和初始化<code>Logger</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">对象。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">@PathVariable  是 Spring MVC 中用于将 URL 模板变量绑定到你控制器处理器方法参数上的注解。这个注解使得你可以从 URL 中提取出变量值，并将其作为参数传递给控制器的方法。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RequestParam(defaultValue &#x3D; “1”)  给参数设置默认值  如果前端没有参数传进来 默认值为1 可自己设置</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@RequestBody 注解  使用对象去接收 的时候使用的注解  </p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RestControllerAdvice</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@ExceptionHandler</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">限制请求的方式</font></p>
<p><font style="color:#DF2A3F;">@RequestMapping  可以放在类上，获取的路径可以当做所有方法的父路径</font></p>
<p>@PostMapping(value&#x3D;”&#x2F;depts”,method&#x3D;RequestMethod.GET)注解 可以放方法上，获取前端的路径。</p>
<p>@GetMapping（”&#x2F;depts”）</p>
<p>@PutMapping</p>
<p>@DeleteMapping</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">junnit5</font></p>
<p>@Test</p>
<p><font style="color:#DF2A3F;">@ParameterizedTest</font></p>
<p><font style="color:#DF2A3F;">@BeforeEach</font></p>
<p>@AfterEach</p>
<p>@BeforeAll  标识静态方法</p>
<p>@AfterAll  标识静态方法</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@RestController &#x3D;  @Controller+@ResponseBody</font></p>
<p>标识当前控制类所有方法都有了@ResponseBody</p>
<p>@ResponseBody 将控制器方法直接输出给前端，将java对象转换为json字符串输出给前端</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>lombok</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">在定义完Filter之后，Filter其实并不会生效，还需要完成Filter的配置，Filter的配置非常简单，只需要在Filter类上添加一个注解：</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;@WebFilter&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，并指定属性</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;urlPatterns&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，通过这个属性指定过滤器要拦截哪些请求。</font></p>
<p><font style="color:rgb(51, 51, 51);">当我们在Filter类上面加了@WebFilter注解之后，接下来我们还需要在启动类上面加上一个注解@ServletComponentScan，通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持。</font></p>
<p><font style="color:rgb(51, 51, 51);">@Order注解 控制过滤器优先级数字越小 优先级越高</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">Spring Boot 中注解的作用</font></p>
<p><font style="color:#DF2A3F;"></font></p>
<p><font style="color:#000000;">Spring Boot 利用注解来简化配置和提高开发效率。主要注解包括但不限于：</font></p>
<p><font style="color:#000000;">@SpringBootApplication: 启动 Spring Boot 应用程序。</font></p>
<p><font style="color:#000000;">@Component, @Service, @Repository, @Controller: 标记组件，以便 Spring 容器可以自动检测和管理它们。</font></p>
<p><font style="color:#000000;">@Bean 该方法会在spring项目启动时自动调用，并将方法的返回值交给IOC容器管理 – bean对象</font></p>
<p><font style="color:#000000;">@Autowired: 用于自动装配 Bean。</font></p>
<p><font style="color:#000000;">@Bean: 在配置类中定义 Bean。</font></p>
<p><font style="color:#000000;">@Configuration: 定义配置类。</font></p>
<p><font style="color:#000000;">@EnableAutoConfiguration: 开启自动配置。</font></p>
<p><font style="color:#000000;">这些注解通常被组合使用，以提供一个高度可配置且易于扩展的应用程序结构。</font></p>
<p><font style="color:#000000;">12. @PathVariable, @RequestParam, @ModelAttribute, @RequestBody, @ResponseBody</font></p>
<p><font style="color:#000000;">参数绑定</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">这些注解用于从 HTTP 请求中提取参数，并将它们绑定到方法参数上。</font></p>
<p><font style="color:#000000;">@PathVariable: 用于从 URL 中提取路径变量。</font></p>
<p><font style="color:#000000;">@RequestParam: 用于从查询字符串中提取参数。</font></p>
<p><font style="color:#000000;">@ModelAttribute: 用于将多个请求参数绑定到一个对象上。</font></p>
<p><font style="color:#000000;">@RequestBody: 用于将请求体中的数据绑定到方法参数上。 获取请求体json字符串数据封装给java对象</font></p>
<p><font style="color:#000000;">@ResponseBody: 用于将方法的结果直接写入响应体。</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">13. @RestController</font></p>
<p><font style="color:#000000;">控制器注解</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">@RestController 注解是一个组合注解，它等价于 @Controller 和 @ResponseBody 的组合。它表示这是一个 REST 控制器，所有返回值都将被序列化为 JSON 格式并直接写入 HTTP 响应体。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">全局异常处理</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@ControllerAdvice&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于定义全局异常处理类，它可以捕获控制器方法抛出的所有异常，并提供统一的错误响应。</font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class)</font></p>
<p><font style="color:rgb(77, 77, 77);">测试运行器</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class) 注解告诉 JUnit 使用 Spring 测试运行器 (SpringRunner) 来运行测试。Spring 测试运行器提供了一种方便的方式来加载 Spring 上下文并管理测试生命周期。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">整体测试</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@SpringBootTest&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于执行整体测试，它会加载整个 Spring 应用上下文，包括所有自动配置的 Bean。这对于集成测试非常有用，因为它可以模拟完整的 Spring Boot 应用程序。</font></p>
<p>@Configuration 用于定义配置类，<font style="color:rgb(77, 77, 77);">配置类中的bean可以自动装配到其他bean中</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类可以使用其他Spring注解，如@ComponentScan和@Import，来扫描组件或导入其他配置类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类在Spring容器启动时会通过CGLIB动态代理机制生成代理类，以确保@Bean方法只被调用一次，从而保证单例bean的行为</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">环境和属性配置：</font></strong><font style="color:rgb(77, 77, 77);"><br></font><font style="color:rgb(77, 77, 77);">使用@PropertySource和@Value注解可以将外部属性文件中的值注入到配置类中</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">作用:按照一定的条件进行判断，在满足给定条件才会注册对应的bean对象到Spring IOC容器中。</font></p>
<p><font style="color:rgb(77, 77, 77);">位置:方法、类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Conditional 本身是一个父注解，派生出大量子注解</font></p>
<p><font style="color:rgb(77, 77, 77);">@ConditionalonClass:判断环境中是否有对应节码文件才注册bean到IOC容器</font></p>
<p><font style="color:rgb(77, 77, 77);">对应的bean(类型或名称)，才注册bean到IOC容器@ConditionalOnMissingBean:判断环境中没@ConditionalonProperty:判断配置文件中有应属性和值，才注册bean到IOC容器。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">SpringBoot 底层原理</font></p>
<p><font style="color:rgb(77, 77, 77);">bean获取。</font></p>
<p><font style="color:rgb(77, 77, 77);">@singleton   默认容器内同名称的bean只有一个实例（单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@prototype  每次使用该bean时会创建新的实例（非单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@request 每个请求范围内会创建新的实例（web环境中，了解即可）</font></p>
<p><font style="color:rgb(77, 77, 77);">@session 每个会话范围内都会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:rgb(77, 77, 77);">@application 每个应用范围内会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:#DF2A3F;">@Scope 设置bean的作用域 </font><font style="color:rgb(77, 77, 77);"> </font></p>
<p><font style="color:rgb(77, 77, 77);">@Lazy 延迟加载 会延迟到第一次使用的时候才会去加载</font></p>
<p><font style="color:rgb(77, 77, 77);">默认singleton的bean，在容器启动时被创建，可以使用aLazy注解来延迟初始化(延迟到第一次使用时)</font></p>
<p><font style="color:rgb(77, 77, 77);">prototype的bean，每一次使用该bean的时候都会创建一个新的实例。</font></p>
<p><font style="color:rgb(77, 77, 77);">实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性</font></p>
<p><font style="color:rgb(77, 77, 77);">– 非单例是每次使用时会创建一个全新的bean</font></p>
<p><font style="color:rgb(77, 77, 77);">@Import  </font><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">是 Java 中 Spring 框架（特别是 Spring Framework 和 Spring Boot）中用于配置类的一个注解。它主要用于导入其他配置类，使得当前的配置类能够复用其他配置类中的配置信息，从而避免重复的配置代码。</font></p>
<p><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Conditional&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 是 Spring Framework 中的一个注解，它用于在自动配置类（@Configuration 类）中或者通过 </font><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Bean&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 方法定义 bean 时，根据特定的条件来决定是否创建某个 bean 或配置。这个注解使得 Spring 的自动配置更加灵活和强大，因为它允许开发者基于特定的条件（如类路径上的特定类、操作系统属性、环境变量等）来启用或禁用配置。</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">@Transactional注解书写位置：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">方法</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前方法交给spring进行事务管理</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">类</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前类中所有的方法都交由spring进行事务管理 （推荐）</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">接口</font><ul>
<li><font style="color:rgb(51, 51, 51);">接口下所有的实现类当中所有的方法都交给spring 进行事务管理</font></li>
</ul>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<ul>
<li><p><font style="color:rgb(51, 51, 51);">@Data是lombok注解,可以生成getter&#x2F;setter方法,tostring&#x2F;hashcode&#x2F;equals等方法重写</font></p>
<pre><code>@NoArgsConstructor /添加无参构造

@AllArgsConstructor //添加全参构造
</code></pre>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ResponseBody: 将控制器方法返回值直接输出给前端，将java对象转换为json字符串输出给前端@RestController &#x3D; @controller + @ResponseBody</p>
<p>标识了当前控制器类所有方法就都有了@ResponseBody</p>
<p>@Controller : spring框架的ioc注解，用于给当前类创建实例对象，也就是加入ioc容器中。</p>
<p>@Autowired ：依赖注入注解:在运行时会从spring容器中找当前接口实现类对象并注入</p>
<p>@Qualifier(“Bean对象”)：指定Bean别名这与对象</p>
<p>@Qualifier常与@Autowired一起使用</p>
<p>@0ptions(useGeneratedKeys &#x3D; true，keyProperty &#x3D;”id”)&#x2F;&#x2F;需要获取数据库赋值的id属性 并赋值给对象的id</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<h1 id="常用方法模板集合"><a href="#常用方法模板集合" class="headerlink" title="常用方法模板集合"></a>常用方法模板集合</h1><pre><code class="java">@Test
1:JsONUtil.toJsonStr(paramMap)//将任意对象转换为json字符串形式
                     
//使用hutool工具类把BedDto类型转换成Bed实体类 类型
2:Bed bean = BeanUtil.toBean(bedDto, Bed.class);

//判断对象是否为null 如果为null 返回true
3:Objects.isNull(xx)

//判断对象是否不为null 如果不为null 返回true
4:Objects.nonNull(xx)
                  
//工具类Objects 专门用来解决空指针异常 意思 先判断s1！=null 在调用s1.equals(s2)
5:Objects.equals(s1,s2)

//强转方法
6:String.valueOf() 

//整个对象的转换方法
7:BeanUtils.copyProperties(user,userPojo) 

8:StringUtils.toStringArray(把括号中的内容转换为一个字符串类型数组)

//在java中，JSONOBject类中的get（String key）方法接收一个字符串参数作为键名，用于从JSON对象中获取对应的值，这种方法运行通过建模来检索特定的数据项
//当我们调用JSONOBject.get(&quot;acces_token&quot;)的时候，实际上是在告诉程序：请查找名为“access_token”的键，并返回其关键的值，
//如果找到匹配的键，则返回相应的值，如果没有找到，则返回null
9:JSONOBject.get(&quot;acces_token&quot;)
//建造者设计模式：利用各种组件（各种属性）随意组合生成对象，目的是创建对象更加灵活
//与直接调用构造函数对比
//类一般要提供很多构造函数才可以灵活构建对象，这种方式很麻烦
//建造者模式创建对象底层只需需要提供一个构造函数即可，在使用的时候想设置哪个属性就设置哪个属性，最终都调用同一个构造函数
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder给当前类添加建造者设计模式创建对象    这几个注解都要有
10：member = Member.builder()
.openId(openid)
.build();
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/22/后端/Stream模板+Lambda常用+@注释+常用方法模板集合/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/19/攻略/Git详细操作/">
        <h2>
            git详细操作
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><code>@Author yuan</code></p>
<h2 id="Git作用"><a href="#Git作用" class="headerlink" title="Git作用"></a>Git作用</h2><p><font style="color:#DF2A3F;background-color:#FBDE28;">Git 作用</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">代码回溯  版本控制  多人协作  远程备份</font></p>
<p>Git 简介</p>
<p>Git 是一个分布式版本控制工具，通常用来对软件开发过程中的源代码文件进行管理。通过Git 仓库来存储和管理这些文件，Git 仓库分为两种:</p>
<p><font style="color:#DF2A3F;background-color:#FBE4E7;">本地仓库:开发人员自己电脑上的 Git 仓库</font></p>
<p><font style="color:#DF2A3F;background-color:#FBE4E7;">远程仓库:远程服务器上的 Git 仓库</font></p>
<p>commit:提交,将本地文件和版本信息保存到本地仓库</p>
<p>push:推送,将本地仓库文件和版本信息上传到远程仓库</p>
<p>pull:拉取,将远程仓库文件和版本信息下载到本地仓库</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728304999728-8681df84-6516-4c9a-a9e7-69119132c404.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">常用的 Git 代码托管服务</font></p>
<p>Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢?</p>
<p>我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">获取Git 仓库-从远程仓库克隆</font></p>
<p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地命令形式:git clone【远程Git仓库地址】</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">工作区、暂存区、版本库 概念</font></p>
<p>版本库:前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等工作区:包含.git文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码暂存区:.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">Git工作区中文件的状态</font></p>
<p>Git工作区中的文件存在两种状态:untracked 未跟踪(未被纳入版本控制)</p>
<p>tracked 已跟踪(被纳入版本控制)</p>
<p>1.Unmodified 未修改状态</p>
<p>2.Modified 已修改状态</p>
<p>3.Staged 已暂存状态</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">本地仓库操作</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">本地仓库常用命令如下:</font></p>
<p><strong>git status          查看文件状态</strong></p>
<p><strong>git add             将文件的修改加入暂存区</strong></p>
<p><strong>git reset           将暂存区的文件取消暂存或者是切换到指定版本</strong></p>
<p>git commit       将暂存区的文件修改提交到版本库</p>
<p>git log              查看日志</p>
<h1 id="Git项目克隆"><a href="#Git项目克隆" class="headerlink" title="Git项目克隆"></a>Git项目克隆</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">在IDEA中克隆Git项目</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">首先配置Git  </font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728347762923-5f8a0d24-f11c-4162-bd3f-b17b6fdfd7cc.png"></p>
<p><font style="color:rgb(51, 51, 51);">说明：如果Git安装在默认目录中（C:\Program Files\Git），则IDEA中无需再手动配置，直接就可以使用。</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第一步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728347513186-e3f2fa07-4c0b-46fe-920f-3982080e4299.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第二步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348065880-ac6cf502-c456-4122-a6ab-e70075051bf5.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第三步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348271734-59eff3ed-f0c4-4d72-b3d1-0c6c16584db3.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第四步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348416264-cd2e8e62-f156-45dd-82cd-9e9e6033170c.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第五步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348466727-6131437b-652f-4f1e-af23-ba44a5b06f34.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第六步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348514297-16fde195-3353-4143-b11f-1e2525409467.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>红色:未跟踪文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>绿色</strong>:<strong>已暂存文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>蓝色</strong>:<strong>已修改文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>黑色</strong>:<strong>未修改文件</strong></font></p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">1.创建一个标签</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356563022-557a0fbc-3faf-4e88-97dd-ebecc3f671e3.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">确认标签名：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356633874-991c5be6-115b-44dc-83f0-a14a3d8ae038.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">添加成功：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356669609-147814c4-3fc5-4905-8840-72f80f5051d2.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">推送到远程仓库：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356774166-0d41891d-631a-4313-937f-85f09f5438ef.png"></p>
<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">分支操作:</font></p>
<p>查看分支，本质就是执行 gitbranch 命令</p>
<p>创建分支，本质就是执行 git branch 分支名 </p>
<p>命令切换分支，本质就是执行 git checkout命令</p>
<p>将分支推送到远程仓库，本质就是执行 git push 命令</p>
<p>合并分支，本质就是执行 git merge 命令</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">IDEA中查看分支在右下角，如图</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355362895-b04cd00a-03e0-456c-b901-fc343da9be6d.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355451938-5e8ae2ff-5c6b-470a-8419-814bbc077498.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355509519-a24c495a-3bde-447e-8557-b8ef2bdc4405.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支推送</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355654046-73a4dbc8-b73d-4b40-b5e9-659ea5d82945.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">切换分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355795984-ecf5519c-c5ee-46fb-b86a-9b6f5a6d5bf2.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">合并分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356060830-877aa5cd-7b37-41df-a7b3-3c90f34d623c.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356178679-0aa3a848-e212-4bee-909a-d0360ede2269.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">合并分支后需要推送到远程仓库同步</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356308073-89d5e135-2d4c-437e-823d-cc122b649b3f.png"></p>
<h1 id="切换版本开发"><a href="#切换版本开发" class="headerlink" title="切换版本开发"></a>切换版本开发</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">切换版本：</font></p>
<p>在开发过程中，有a1到a5这几个版本的项目，现在需要重新基于a3去开发后续项目。基于这种情况，我们可以右键这个版本的项目，新建分支进行开发。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728357068967-77c87275-510e-4067-a7cd-17b8448bdecd.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728357294505-f9518280-5b27-4922-b4c6-0d3a68fc6399.png"></p>
<h1 id="提交-amp-amp-拉取-amp-amp-冲突"><a href="#提交-amp-amp-拉取-amp-amp-冲突" class="headerlink" title="提交 &amp;&amp; 拉取 &amp;&amp; 冲突"></a>提交 &amp;&amp; 拉取 &amp;&amp; 冲突</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">1.提交</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351542021-b166f619-90aa-438f-9679-bf82ac777e12.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">2.推送</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351606771-c5aa2b2a-b25d-4923-a1b1-5e57dc79a098.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">3.拉取</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351707487-a8cbd23f-0b89-4e76-9afd-9f9d4cf24fb1.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">4.提交推送2</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351889553-2e93cea9-f5a9-49a1-b38e-ed889eebe51e.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">5.拉取</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351959955-8efb3bf0-1fbf-456a-b187-0c8e56939498.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">操作冲突：</font>多个人操作同一个文件，其中有人基于旧的版本修改，提交新版本会成功，但是推送到远程会失败，就是发送冲突。</p>
<p>冲突为什么发生：a和b同时修改c1文件，a先修改完成c1文件，提交推送到远程仓库，c1文件进行更新版本成为c2，提交推送后b也修改完成c1文件，提交的时候成功 推送则失败，因为远程仓库的文件已经进行了更新。<strong>b推送的时候没有拉取最新的文件进行修改，而是使用的过期版本，所以造成冲突。</strong></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突，拉取，合并，推送</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">操作冲突：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353222693-dfb36773-9de9-4e59-913e-76ab27d9c7af.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：1</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353384068-45d7181b-852b-4c20-876c-c54ac075c495.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：2</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353537745-00b91a2b-d5b8-4490-8925-df9fb5637584.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：3</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353826957-3282047c-26eb-4555-8b12-19f1c2f9a5dc.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：4</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353863162-0e943f20-1ae9-4747-9008-3e253c18b7eb.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">推送合并后的项目到远程仓库</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728354076794-ee920b1a-dc3a-4524-ad43-753fb6e75526.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728354258412-947fe27d-bcf5-4153-ac1b-cf8c38a7db53.png"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/攻略" style=color:#ffa2c4>
                攻略
            </a>
        </span>
        
    </div>

    <a href="/2024/11/19/攻略/Git详细操作/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/03/后端/若依-AI & 帝可得/">
        <h2>
            若依-AI & 帝可得
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="RuoYi-Vue"><a href="#RuoYi-Vue" class="headerlink" title="RuoYi-Vue"></a>RuoYi-Vue</h3><ul>
<li>RuoYi-Vue版本，采用了前后端分离的单体架构设计<br><a target="_blank" rel="noopener" href="https://gitee.com/ys-gitee/RuoYi-Vue3">https://gitee.com/ys-gitee/RuoYi-Vue3</a><br><a target="_blank" rel="noopener" href="https://gitee.com/y_project/RuoYi-Vue">https://gitee.com/y_project/RuoYi-Vue</a></li>
</ul>
<table>
<thead>
<tr>
<th align="center">课程版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDK 11</td>
</tr>
<tr>
<td align="center">MySQL 8</td>
</tr>
<tr>
<td align="center">Redis 5</td>
</tr>
<tr>
<td align="center">Maven 3.6</td>
</tr>
<tr>
<td align="center">Node 16 (Vue3)</td>
</tr>
</tbody></table>
<ul>
<li>技术选型：SpringBoot、SpringSecurity、MyBatis、Jwt、VUE3、Element-Plus</li>
</ul>
<ol>
<li><p><strong>从VCS导入项目</strong>：</p>
<ul>
<li><p>点击<code>VCS</code>菜单。</p>
</li>
<li><p>选择<code>Get from Version Control...</code>选项。</p>
</li>
<li><pre><code class="java">URL：https://gitee.com/y_project/RuoYi-Vue.git
Directory：C:\Users\Pluminary\Desktop\RuoYi-Vue
</code></pre>
</li>
</ul>
</li>
<li><p><strong>输入项目地址</strong>：</p>
<ul>
<li>在弹出的窗口中，您可以看到不同的版本控制系统（例如Git, SVN等）。</li>
<li>选择您要导入的项目所使用的版本控制系统。</li>
<li>在接下来的窗口中，您需要输入项目的URL地址。这通常是项目的仓库地址，例如Git仓库的HTTPS或SSH链接。</li>
</ul>
</li>
</ol>
<blockquote>
<p>① 若模块没有导入进去没有亮 就<strong>Maven → clean → package</strong></p>
<p>C:\Users\Pluminary\Desktop\RuoYi-Vue\sql 导入Sql文件两个<br><strong>sql&#x2F;quartz.sql</strong><br><strong>sql&#x2F;ry_20240629.sql</strong></p>
</blockquote>
<p>先git<a target="_blank" rel="noopener" href="https://github.com/wzs28150/RuoYi-Vue3">wzs28150&#x2F;RuoYi-Vue3: :tada: (RuoYi)官方仓库 基于SpringBoot，Spring Security，JWT，Vue3 &amp; Vite、Element Plus 的前后端分离权限管理系统</a>下载这里面的资料，在里面<code>C:\Users\Pluminary\Desktop\itcast&gt;code ./RuoYi-Vue3</code>导入vscode里面，再安装依赖(要进入Vue3里面才能利用package.json去生成)<code>npm install</code> → 运行前端项目<code>npm run dev</code></p>
<pre><code class="java">// npm install慢的话 就用中国镜像去下载
npm install --registr=https://registry.npmmirror.com

C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3&gt;npm run dev

&gt; ruoyi@3.8.8 dev
&gt; vite


  VITE v5.3.2  ready in 2026 ms

  ➜  Local:   http://localhost:8080/
  ➜  Network: http://10.254.3.124:8080/
  ➜  Network: http://192.168.104.38:8080/
  ➜  Network: http://192.168.22.1:8080/
  ➜  Network: http://192.168.36.1:8080/
  ➜  press h + enter to show help
</code></pre>
<p>再导入<code>课程管理.sql</code>数据库 → 在若依的后台系统 → 系统工具 → 代码生成 → 配置好后下载代码 → 导入数据库</p>
<p> → 导入RuoYi生成的前端代码<code>C:\Users\Pluminary\Downloads\ruoyi\vue\api</code> 的<strong>course</strong>导入vscode中 <code>C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3\src\api\course</code> &amp;&amp; <code>C:\Users\Pluminary\Downloads\ruoyi\vue\views</code> 的<strong>course</strong>导入vscode中 <code>C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3\src\api\course</code></p>
<p>→ 导入RuoYi生成的后端代码<code>C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3\src\views\course</code>的<strong>com</strong> 并且导入配置文件 &amp;&amp; <code>C:\Users\Pluminary\Downloads\ruoyi\main\resources</code>的<strong>mapper</strong>导入到idea的resource中</p>
<h3 id="功能详解"><a href="#功能详解" class="headerlink" title="功能详解"></a>功能详解</h3><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><ul>
<li>若依内置了强大的权限控制系统，为企业级项目提供了通用的解决方案<ul>
<li>**demo账号 (超级管理员)**，查看所有功能菜单</li>
<li>**zhangsan账号 (市场专员)**，查看线索菜单</li>
<li>**yueyue账号 (销售专员)**，查看商机、合同等菜单</li>
</ul>
</li>
<li><strong>RBAC (基于<span style = "color:red">角色的控制访问</span>)</strong> 是一种广泛使用的访问控制模型，通过<strong>角色</strong>来分配和管理<strong>用户</strong>的菜单<strong>权限</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">表名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sys_dept</td>
<td align="center">部门表</td>
</tr>
<tr>
<td align="center">sys_post</td>
<td align="center">岗(职)位信息表</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_menu</strong></span></td>
<td align="center"><span style = "color:red"><strong>菜单权限表</strong></span></td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_role</strong></span></td>
<td align="center"><span style = "color:red"><strong>角色信息表</strong></span></td>
</tr>
<tr>
<td align="center">sys_role_dept</td>
<td align="center">角色和部门关联表</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_role_menu</strong></span></td>
<td align="center"><span style = "color:red"><strong>角色和菜单关联表</strong></span></td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_user</strong></span></td>
<td align="center"><span style = "color:red"><strong>用户信息表</strong></span></td>
</tr>
<tr>
<td align="center">sys_user_post</td>
<td align="center">用户与岗位关联表</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_user_role</strong></span></td>
<td align="center"><span style = "color:red"><strong>用户和角色关联表</strong></span></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e34a8982a14929c9b4d00cae2f337c3e043708da/%E8%8B%A5%E4%BE%9D-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.jpg"></p>
<h6 id="创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。"><a href="#创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。" class="headerlink" title="创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。"></a>创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。</h6><p>① <strong>创建菜单</strong><br>② <strong>创建角色，并分配权限</strong><del>课研人员</del><br>③ <strong>创建用户，并关联角色</strong><del>xiaozhi</del></p>
<pre><code class="java">若依通过简单的功能配置实现RBC的权限管理
</code></pre>
<h5 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h5><ul>
<li>若依内置的数据字典，用于维护系统中常见的静态数据。例如：性别、状态</li>
<li>功能包括：字典类型管理、字典数据管理</li>
<li>表关系说明【一对多】</li>
</ul>
<table>
<thead>
<tr>
<th>表名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sys_dict_type</td>
<td>字典类型表</td>
</tr>
<tr>
<td>sys_dict_data</td>
<td>字典数据表</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>dict_id</th>
<th>dict_name</th>
<th><span style = "color:red">dict_type</span></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户性别</td>
<td>sys_user_sex</td>
</tr>
<tr>
<td>2</td>
<td>菜单状态</td>
<td>sys_show_hide</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>dict_code</th>
<th>dict_sort</th>
<th>dict_label</th>
<th>dict_value</th>
<th><span style = "color:red">dict_type</span></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>男</td>
<td>0</td>
<td>sys_user_sex</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>女</td>
<td>1</td>
<td>sys_user_sex</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>未知</td>
<td>2</td>
<td>sys_user_sex</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>将一些不经常修改的数据(课程管理的学科字段)改为数据字典维护，以免占用大量空间</strong></p>
<ul>
<li><p>添加字典类型和数据</p>
<blockquote>
<p>系统管理 → 字典管理 → 新增 → <strong>添加字典类型</strong><br>字典名称：学科<br>字典类型：course_subject<br>第二页点进去<strong>添加字典数据</strong><br>javaEE → 0 → 1 </p>
</blockquote>
</li>
<li><p>修改代码生成信息</p>
<blockquote>
<p>系统工具 → 代码生成 → 编辑课程管理 → subject课程学科 显示类型从<strong>文本框</strong>改成<strong>下拉框</strong> → 字典类型 是学科 → 下载最新的代码<br>只需要修改前端vue组件 因为只改了从前端文本框到下拉框 和一些数据字典</p>
</blockquote>
</li>
<li><p>下载代码，导入前端</p>
<blockquote>
<p>C:\Users\Pluminary\Downloads\ruoyi (1)\vue\views\course\course\index.vue去替换前端的index.vue  此时去若依前端查看课程管理→课程学科就会发现已经添加新的进去了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>此时去<code>课程管理</code>里面找<code>课程学科：JavaEE</code>进行筛选不会出 因为若依底层<br><a target="_blank" rel="noopener" href="http://10.254.2.179/dev-api/course/course/list?pageNum=1&amp;pageSize=10&amp;subject=0">http://10.254.2.179/dev-api/course/course/list?pageNum=1&amp;pageSize=10&amp;subject=0</a><br>要从数据库里把JavaEE的subject改成0<br>优点：<strong>降低数据库的存储压力 提高磁盘利用率</strong></p>
</blockquote>
<h5 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h5><ul>
<li><p><strong>参数设置</strong>：对系统中的参数进行动态维护</p>
<blockquote>
<p>系统管理 → 参数设置 → 验证码开关 → 修改 → 参数键值 → false<br>还可以开启是否 <u>用户注册功能</u> → 前端代码隐藏需要修改 → src&#x2F;views&#x2F;login.vue → 97行注册开关<br>const register &#x3D; ref(true) 此时登录界面就有立即注册 跳转注册</p>
</blockquote>
</li>
<li><p><strong>通知公告(半成品)：</strong>促进组织内部信息传递</p>
<blockquote>
<p>系统管理 → 通知公告 → 新增</p>
</blockquote>
</li>
<li><p><strong>日志管理：</strong>轻松追踪用户行为和系统运行状况</p>
<blockquote>
<p>系统管理 → 通知公告 → 日志管理 → 操作日志</p>
</blockquote>
</li>
</ul>
<h5 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h5><ul>
<li><p>若依提供了一些列强大的监控工具，能够帮助开发者和运维快速了解应用程序的性能状态</p>
<blockquote>
<p>系统监控 → 在线用户 &amp;&amp; 缓存列表<br>数据监控【Druid Monitor】 → ruoyi &amp;&amp; 123456</p>
</blockquote>
</li>
</ul>
<h5 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h5><ul>
<li><p>若依为定时任务功能提供方便友好的web界面，实现动态管理任务</p>
<pre><code class="java">@Component
public class MyTask&#123;
  @Scheduled(cron = &quot;0/5 *****?&quot;)
  public void showTime()&#123;
     sout(&quot;定时任务开始执行：&quot; + new Date());
  &#125;
&#125;
// 硬编码 改代码需要重新修改 重新编译 重新上传...
</code></pre>
</li>
<li><p><strong>每间隔5秒，控制台输出系统时间</strong></p>
<ul>
<li><p>创建任务类</p>
<blockquote>
<p>创建一个类 <code>C:\Users\Pluminary\Desktop\RuoYi-Vue\ruoyi-quartz\src\main\java\com\ruoyi\quartz\task\MyTask.java</code></p>
<pre><code class="java">package com.ruoyi.quartz.task;

import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class MyTask &#123;
    public void showTime()&#123;
        System.out.println(&quot;定时任务开始执行：&quot; + new Date());
    &#125;
&#125;
</code></pre>
</blockquote>
</li>
<li><p>添加任务规则</p>
<blockquote>
<p>系统监控 → 定时任务 → 新增 →<br>任务名称：输出时间        任务分组：默认<br>调用方式：myTask.showTime()<br>Cron表达式生成器：<u>从0秒开始，每5秒执行一次</u> → 0&#x2F;5 * * * * ?<br>开启输出时间 状态打开！</p>
<h2 id="然后每间隔5秒就会向控制台输出时间"><a href="#然后每间隔5秒就会向控制台输出时间" class="headerlink" title="然后每间隔5秒就会向控制台输出时间"></a>然后每间隔5秒就会向控制台输出时间</h2><p>定时任务开始执行：Wed Nov 06 18:12:30 CST 2024<br>18:12:30.001 [quartzScheduler_Worker-4] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &gt; Preparing: insert into sys_job_log( job_name, job_group, invoke_target, job_message, status, create_time )values( ?, ?, ?, ?, ?, sysdate() ) 18:12:30.002 [quartzScheduler_Worker-4] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - –&gt; Parameters: 输出时间(String), DEFAULT(String), myTask.showTime()(String), 输出时间 总共耗时：0毫秒(String), 0(String) 18:12:30.009 [quartzScheduler_Worker-4] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &lt; Updates: 1 定时任务开始执行：Wed Nov 06 18:12:35 CST 2024 18:12:35.006 [quartzScheduler_Worker-5] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &gt; Preparing: insert into sys_job_log( job_name, job_group, invoke_target, job_message, status, create_time )values( ?, ?, ?, ?, ?, sysdate() ) 18:12:35.006 [quartzScheduler_Worker-5] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - –&gt; Parameters: 输出时间(String), DEFAULT(String), myTask.showTime()(String), 输出时间 总共耗时：0毫秒(String), 0(String) 18:12:35.012 [quartzScheduler_Worker-5] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &lt; Updates: 1</p>
</blockquote>
</li>
<li><p><strong>启动任务</strong></p>
<p>官方有提供可以训练的模型</p>
<blockquote>
<p>在这里面：com&#x2F;ruoyi&#x2F;quartz&#x2F;task&#x2F;RyTask.java</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="表单构建"><a href="#表单构建" class="headerlink" title="表单构建"></a>表单构建</h5><ul>
<li><h6 id="通过表单构建工具，单独制作一个添加课程的表单页面"><a href="#通过表单构建工具，单独制作一个添加课程的表单页面" class="headerlink" title="通过表单构建工具，单独制作一个添加课程的表单页面"></a>通过表单构建工具，单独制作一个添加课程的表单页面</h6><ul>
<li><p>制作表单并导出</p>
<blockquote>
<p>系统工具 → 表单构建 → 左侧<strong>行容器</strong> → 拖入第一个单行文本 → 右侧可以改名字 如果想实现一行两个文本的化 就把<code>表单栅格调小一点</code> → 选择性组件的<strong>下拉选择</strong>托到右面 → 修改字段名、标题、表单栅格…<br>日期范围 → 课程有效期 → 选择型组件里的日期范围 命名为：课程有效期<br>文件上传组件 → 课程封面<br>评分 → 推荐指数<br>多行文本 → 课程介绍</p>
</blockquote>
</li>
<li><p>复制到前端工程</p>
<blockquote>
<p>搞完后打开前端工程把add.vue它放在 src&#x2F;views&#x2F;course&#x2F;course&#x2F;中</p>
</blockquote>
</li>
<li><p>创建动态菜单</p>
<blockquote>
<p>系统管理 → 菜单管理 → 添加菜单 →<br>菜单类型：菜单<br>菜单名称：添加课程<br>显示排序：1<br>路由地址：course&#x2F;add<br>组件路径：course&#x2F;course&#x2F;add<br>刷新界面 就会有菜单管理→添加课程了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h4><h5 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h5><ul>
<li>代码生成器，根据数据库表结构自动生成前后端CRUD代码</li>
<li>提供三种生成模板：单表、树表、主子表(一对多)</li>
<li>树表是一种展示层级数据的表格，能展开折叠，清晰呈现父子关系，便于管理</li>
</ul>
<blockquote>
<p>系统工具 → 代码生成 → 导入部门表 → 编辑 → 生成信息 → 生成模板：树表 →<br>树编码字段：dept_id：部门id<br>树父编码字段：parent_id：父部门id<br>树名称字段：dept_name：部门名称<br>提交后下载代码<br>导入后就是 系统管理&#x2F;部门管理 的树型结构界面了</p>
</blockquote>
<table>
<thead>
<tr>
<th>dept_id</th>
<th>parent_id</th>
<th>ancestors</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>0</td>
<td>0</td>
<td>若依科技</td>
</tr>
<tr>
<td>101</td>
<td>100</td>
<td>0,100</td>
<td>深圳总公司</td>
</tr>
<tr>
<td><span style = "color:red">102</span></td>
<td>100</td>
<td>0,100</td>
<td>长沙分公司</td>
</tr>
<tr>
<td>108</td>
<td><span style = "color:red">102</span></td>
<td>0,100,101</td>
<td>市场部门</td>
</tr>
<tr>
<td>109</td>
<td><span style = "color:red">102</span></td>
<td>0,100,102</td>
<td>财务部门</td>
</tr>
</tbody></table>
<h5 id="系统接口"><a href="#系统接口" class="headerlink" title="系统接口"></a>系统接口</h5><ul>
<li><p>Swagger，能够自动生成API的同步在线文档，并提供Web界面进行接口调用和测试</p>
<blockquote>
<p>系统工具 → 系统接口<br>若依的Token在应用程序里 需要搞token进去<br>测试：获取用户列表GET<br>得到Token(F12后找应用程序 → Cookie<del>若依</del> → 找到Admin-Token<del>一定是当前ip地址的Token</del> → 在Authorize中设置Token令牌 → 去后端改swagger的请求前缀pathMapping：&#x2F;<del>因为他的地址前面默认佩戴&#x2F;dev-api</del></p>
<pre><code class="yaml"># Swagger配置
swagger:
  # 是否开启swagger
  enabled: true
  # 请求前缀
  pathMapping: /
</code></pre>
<p>然后重启后台项目刷新浏览器打开接口再调用Token再去测试<br>此时就操作成功了</p>
<pre><code class="json">&#123;
  &quot;code&quot;: 200,
  &quot;msg&quot;: &quot;操作成功&quot;,
  &quot;data&quot;: [
    &#123;
      &quot;userId&quot;: 1,
      &quot;username&quot;: &quot;admin&quot;,
      &quot;password&quot;: &quot;admin123&quot;,
      &quot;mobile&quot;: &quot;15888888888&quot;
    &#125;,
    &#123;
      &quot;userId&quot;: 2,
      &quot;username&quot;: &quot;ry&quot;,
      &quot;password&quot;: &quot;admin123&quot;,
      &quot;mobile&quot;: &quot;15666666666&quot;
    &#125;
  ]
&#125;
</code></pre>
</blockquote>
</li>
</ul>
<p><span style = "color:red"><strong>若依常用功能？</strong></span></p>
<p>① <strong>权限控制</strong><br>② <strong>数据字典</strong><br>③ <strong>定时任务</strong><br>④ <strong>表单构建</strong><br>⑤ <strong>代码生成</strong></p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><img src="https://raw.githubusercontent.com/P-luminary/images/2d1ced51ed4dfb918b78181cb385e58594e7bdaa/RuoYi%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg"  />

<h5 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h5><img src="https://raw.githubusercontent.com/P-luminary/images/f157a27c9825e2305562a5f7a5917ad511ee7ac5/RuoYi%E8%A1%A8%E7%BB%93%E6%9E%84.jpg" style="zoom:150%;" />

<h5 id="前端代码分析"><a href="#前端代码分析" class="headerlink" title="前端代码分析"></a>前端代码分析</h5><ul>
<li><code>api/course/course.js</code>  用于向后端发送Ajax请求的接口代码</li>
<li><code>views/course/course/index.vue</code>用于在浏览器展示课程的视图组件</li>
</ul>
<pre><code class="vue">src\views\course\course\index.vue
&lt;template&gt;
  &lt;div class=&quot;app-container&quot;&gt;
    &lt;!-- :model做双向绑定 将前端录入条件封装给响应对象  v-show控制搜索栏显示隐藏--&gt;
    &lt;el-form :model=&quot;queryParams&quot; ref=&quot;queryRef&quot; :inline=&quot;true&quot; v-show=&quot;showSearch&quot; label-width=&quot;68px&quot;&gt;
      &lt;el-form-item label=&quot;课程编码&quot; prop=&quot;code&quot;&gt;
        &lt;!-- v-model双向绑定code(前端课程编码) clearable清理用户输入信息 @keyup键盘回车事件完成搜索--&gt;
        &lt;el-input
          v-model=&quot;queryParams.code&quot;
          placeholder=&quot;请输入课程编码&quot;
          clearable
          @keyup.enter=&quot;handleQuery&quot;
        /&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;课程学科&quot; prop=&quot;subject&quot;&gt;
        &lt;!-- v-for遍历课程学科的字典数据列表 :lable展示label :value提交value值--&gt;
        &lt;el-select v-model=&quot;queryParams.subject&quot; placeholder=&quot;请选择课程学科&quot; clearable&gt;
          &lt;el-option
            v-for=&quot;dict in course_subject&quot;
            :key=&quot;dict.value&quot;
            :label=&quot;dict.label&quot;
            :value=&quot;dict.value&quot;
          /&gt;
        &lt;/el-select&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt;
        &lt;el-input
          v-model=&quot;queryParams.name&quot;
          placeholder=&quot;请输入课程名称&quot;
          clearable
          @keyup.enter=&quot;handleQuery&quot;
        /&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;applicablePerson&quot;&gt;
        &lt;el-select v-model=&quot;queryParams.applicablePerson&quot; placeholder=&quot;请选择适用人群&quot; clearable&gt;
          &lt;el-option
            v-for=&quot;dict in course_applicable_person&quot;
            :key=&quot;dict.value&quot;
            :label=&quot;dict.label&quot;
            :value=&quot;dict.value&quot;
          /&gt;
        &lt;/el-select&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item&gt;
        &lt;el-button type=&quot;primary&quot; icon=&quot;Search&quot; @click=&quot;handleQuery&quot;&gt;搜索&lt;/el-button&gt;
        &lt;el-button icon=&quot;Refresh&quot; @click=&quot;resetQuery&quot;&gt;重置&lt;/el-button&gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;

    &lt;el-row :gutter=&quot;10&quot; class=&quot;mb8&quot;&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;!-- @click点击新增按钮弹出新增 v-hasPermi自定义属性完成菜单显示/隐藏 --&gt;
        &lt;el-button
          type=&quot;primary&quot;
          plain
          icon=&quot;Plus&quot;
          @click=&quot;handleAdd&quot;
          v-hasPermi=&quot;[&#39;course:course:add&#39;]&quot;
        &gt;新增&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;!-- :disabled表示这个框是否可用 --&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;el-button
          type=&quot;success&quot;
          plain
          icon=&quot;Edit&quot;
          :disabled=&quot;single&quot;
          @click=&quot;handleUpdate&quot;
          v-hasPermi=&quot;[&#39;course:course:edit&#39;]&quot;
        &gt;修改&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;el-button
          type=&quot;danger&quot;
          plain
          icon=&quot;Delete&quot;
          :disabled=&quot;multiple&quot;
          @click=&quot;handleDelete&quot;
          v-hasPermi=&quot;[&#39;course:course:remove&#39;]&quot;
        &gt;删除&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;el-button
          type=&quot;warning&quot;
          plain
          icon=&quot;Download&quot;
          @click=&quot;handleExport&quot;
          v-hasPermi=&quot;[&#39;course:course:export&#39;]&quot;
        &gt;导出&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;!-- 点击会控制&#39;搜索栏&#39;显示隐藏 @queryTable重新加载表格展示数据 --&gt;
      &lt;right-toolbar v-model:showSearch=&quot;showSearch&quot; @queryTable=&quot;getList&quot;&gt;&lt;/right-toolbar&gt;
    &lt;/el-row&gt;
    &lt;!-- v-loading展示表格的加载状态 遍历展示courseList 事件监听器监听选中行 --&gt;
    &lt;el-table v-loading=&quot;loading&quot; :data=&quot;courseList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;
      &lt;!-- 当用户勾选复选框 触发@selection-change --&gt;
      &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
      &lt;!-- 展示具体数据源数据 --&gt;
      &lt;el-table-column label=&quot;课程id&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
      &lt;el-table-column label=&quot;课程编码&quot; align=&quot;center&quot; prop=&quot;code&quot; /&gt;
      &lt;el-table-column label=&quot;课程学科&quot; align=&quot;center&quot; prop=&quot;subject&quot;&gt;
 &lt;!-- 通过scope拿到整个表格数据 通过:value=&quot;scope.row.subject&quot;拿到字典值去匹配字典数据列表 找到该值对应的标签显示给前端--&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;dict-tag :options=&quot;course_subject&quot; :value=&quot;scope.row.subject&quot;/&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;课程名称&quot; align=&quot;center&quot; prop=&quot;name&quot; /&gt;
      &lt;el-table-column label=&quot;价格&quot; align=&quot;center&quot; prop=&quot;price&quot; /&gt;
      &lt;el-table-column label=&quot;适用人群&quot; align=&quot;center&quot; prop=&quot;applicablePerson&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;dict-tag :options=&quot;course_applicable_person&quot; :value=&quot;scope.row.applicablePerson&quot;/&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;课程介绍&quot; align=&quot;center&quot; prop=&quot;info&quot; /&gt;
      &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
&lt;!-- 使用了模板插槽 --&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;!-- @click=&quot;handleUpdate(scope.row)把当前行的数据传给当前方法  v-hasPermi自定义权限属性--&gt;
          &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;course:course:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot; icon=&quot;Delete&quot; @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;course:course:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
    
    &lt;!-- 分页区域 --&gt;
     &lt;!-- v-show如果大于0条就显示反之隐藏 :total展示总条数 展示分页页码 @pagination=&quot;getList&quot;换页后新数据的查询--&gt;
    &lt;pagination
      v-show=&quot;total&gt;0&quot;
      :total=&quot;total&quot;
      v-model:page=&quot;queryParams.pageNum&quot;
      v-model:limit=&quot;queryParams.pageSize&quot;
      @pagination=&quot;getList&quot;
    /&gt;

    &lt;!-- 添加或修改课程管理对话框 --&gt;
     &lt;!-- el-dialog默认隐藏的 点击会显示 append-to-body默认将对话框在body上追加显示 :title动态绑定标题(新增和修改不一样)--&gt;
    &lt;el-dialog :title=&quot;title&quot; v-model=&quot;open&quot; width=&quot;500px&quot; append-to-body&gt;
      &lt;!-- :model来双向绑定 :rules校验规则--&gt;
      &lt;el-form ref=&quot;courseRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt;
        &lt;el-form-item label=&quot;课程编码&quot; prop=&quot;code&quot;&gt;
          &lt;el-input v-model=&quot;form.code&quot; placeholder=&quot;请输入课程编码&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;课程学科&quot; prop=&quot;subject&quot;&gt;
          &lt;el-select v-model=&quot;form.subject&quot; placeholder=&quot;请选择课程学科&quot;&gt;
            &lt;el-option
              v-for=&quot;dict in course_subject&quot;
              :key=&quot;dict.value&quot;
              :label=&quot;dict.label&quot;
              :value=&quot;dict.value&quot;
            &gt;&lt;/el-option&gt;
          &lt;/el-select&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt;
          &lt;el-input v-model=&quot;form.name&quot; placeholder=&quot;请输入课程名称&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;价格&quot; prop=&quot;price&quot;&gt;
          &lt;el-input v-model=&quot;form.price&quot; placeholder=&quot;请输入价格&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;applicablePerson&quot;&gt;
          &lt;el-select v-model=&quot;form.applicablePerson&quot; placeholder=&quot;请选择适用人群&quot;&gt;
            &lt;el-option
              v-for=&quot;dict in course_applicable_person&quot;
              :key=&quot;dict.value&quot;
              :label=&quot;dict.label&quot;
              :value=&quot;dict.value&quot;
            &gt;&lt;/el-option&gt;
          &lt;/el-select&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;课程介绍&quot; prop=&quot;info&quot;&gt;
          &lt;el-input v-model=&quot;form.info&quot; placeholder=&quot;请输入课程介绍&quot; /&gt;
        &lt;/el-form-item&gt;
      &lt;/el-form&gt;
      &lt;template #footer&gt;
        &lt;div class=&quot;dialog-footer&quot;&gt;
          &lt;!-- 提交前先进行表单规则的校验:rules=&quot;rules&quot;  --&gt;
          &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm&quot;&gt;确 定&lt;/el-button&gt;
          &lt;el-button @click=&quot;cancel&quot;&gt;取 消&lt;/el-button&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/el-dialog&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup name=&quot;Course&quot;&gt;
// 引入后端api接口文件
import &#123; listCourse, getCourse, delCourse, addCourse, updateCourse &#125; from &quot;@/api/course/course&quot;;
// 获取当前实例代理对象，用于访问组件数据、方法
const &#123; proxy &#125; = getCurrentInstance();
// 获取课程学科的数据字典
const &#123; course_applicable_person, course_subject &#125; = proxy.useDict(&#39;course_applicable_person&#39;, &#39;course_subject&#39;);
// 列表数据
const courseList = ref([]);
// 是否显示弹框
const open = ref(false);
// 是否显示加载状态
const loading = ref(true);
// 是否显示搜索栏
const showSearch = ref(true);
// 复选框，被选中id的数组
const ids = ref([]);
// 复选框，是否单选，用于高亮修改、删除按钮
const single = ref(true);
// 复选框，是否多选，仅高亮删除按钮
const multiple = ref(true);
// 总(记录)条数
const total = ref(0);
// 用于区分新增、修改对话框标题
const title = ref(&quot;&quot;);
// 定义reactive响应式对象
const data = reactive(&#123;
  // 新增或修改表单数据
  form: &#123;&#125;,
  // 搜索条件参数
  queryParams: &#123;
    pageNum: 1,
    pageSize: 10,
    code: null,
    subject: null,
    name: null,
    applicablePerson: null,
  &#125;,
  // 表单校验规则
  rules: &#123;
    code: [
      &#123; required: true, message: &quot;课程编码不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
    subject: [
      &#123; required: true, message: &quot;课程学科不能为空&quot;, trigger: &quot;change&quot; &#125;
    ],
    name: [
      &#123; required: true, message: &quot;课程名称不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
    price: [
      &#123; required: true, message: &quot;价格不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
    applicablePerson: [
      &#123; required: true, message: &quot;适用人群不能为空&quot;, trigger: &quot;change&quot; &#125;
    ],
    info: [
      &#123; required: true, message: &quot;课程介绍不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
  &#125;
&#125;);
// 将data对象的三个属性，转换为ref响应式对象
const &#123; queryParams, form, rules &#125; = toRefs(data);

/** 查询课程管理列表 */
function getList() &#123;
  loading.value = true;
  listCourse(queryParams.value).then(response =&gt; &#123;
    courseList.value = response.rows;
    total.value = response.total;
    loading.value = false;
  &#125;);
&#125;

// 取消按钮
function cancel() &#123;
  open.value = false;
  reset();
&#125;

// 表单重置
function reset() &#123;
  form.value = &#123;
    id: null,
    code: null,
    subject: null,
    name: null,
    price: null,
    applicablePerson: null,
    info: null,
    createTime: null,
    updateTime: null
  &#125;;
  proxy.resetForm(&quot;courseRef&quot;);
&#125;

/** 搜索按钮操作 */
function handleQuery() &#123;
  // 最新的从第一页开始 再发送请求
  queryParams.value.pageNum = 1;
  getList();
&#125;

/** 重置按钮操作 */
function resetQuery() &#123;
  proxy.resetForm(&quot;queryRef&quot;);
  handleQuery();
&#125;

// 多选框选中数据
// 把选中的复选框对象传递过来
function handleSelectionChange(selection) &#123;
  // 拿到对象调用map方法进行遍历取每个复选框的id
  // 封装给ids的响应式数组对象
  ids.value = selection.map(item =&gt; item.id);
  // 控制修改和删除按钮是否高亮可用的 23默认为true
  single.value = selection.length != 1;
  // 修改按钮只要大于0 就是false 那么修改按钮可用使用
  multiple.value = !selection.length;
&#125;

/** 新增按钮操作 */
function handleAdd() &#123;
  reset();
  open.value = true;
  title.value = &quot;添加课程管理&quot;;
&#125;

/** 修改按钮操作 */
// 拿到行对象 重置 取出当前行id或一个id
function handleUpdate(row) &#123;
  reset();
  const _id = row.id || ids.value
  getCourse(_id).then(response =&gt; &#123;
    form.value = response.data;
    open.value = true;
    title.value = &quot;修改课程管理&quot;;
  &#125;);
&#125;

/** 提交按钮 */
function submitForm() &#123;
  // &#39;修改课程&#39;对表单进行校验 正则规则...是否必填
  proxy.$refs[&quot;courseRef&quot;].validate(valid =&gt; &#123;
    if (valid) &#123;// 区分新增还是修改的操作
      if (form.value.id != null) &#123;
        updateCourse(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;修改成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125; else &#123;
        addCourse(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;新增成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125;
    &#125;
  &#125;);
&#125;

/** 删除按钮操作 */
function handleDelete(row) &#123;
  // 一行或数组
  const _ids = row.id || ids.value;
  // 防止误操作
  proxy.$modal.confirm(&#39;是否确认删除课程管理编号为&quot;&#39; + _ids + &#39;&quot;的数据项？&#39;).then(function() &#123;
    return delCourse(_ids);
  &#125;).then(() =&gt; &#123;
    getList();
    proxy.$modal.msgSuccess(&quot;删除成功&quot;);
  &#125;).catch(() =&gt; &#123;&#125;);
&#125;

/** 导出按钮操作 */
function handleExport() &#123;
  proxy.download(&#39;course/course/export&#39;, &#123;
    ...queryParams.value
  &#125;, `course_$&#123;new Date().getTime()&#125;.xlsx`)
&#125;

getList();
&lt;/script&gt;
</code></pre>
<pre><code class="js">src\api\course\course.js
// 封装了请求和响应拦截器 下面return每个都调用请求
import request from &#39;@/utils/request&#39;

// 查询课程管理列表
// 接收用户输入参数 调用工具类把参数传过去 向后端发送请求完成课程列表的查询
// 然后返回前端并展示数据
export function listCourse(query) &#123;
  return request(&#123;
    url: &#39;/course/course/list&#39;,
    method: &#39;get&#39;,
    params: query
  &#125;)
&#125;

// 查询课程管理详细
// 点击修改按钮时候根据id去查询 返回给前端
export function getCourse(id) &#123;
  return request(&#123;
    url: &#39;/course/course/&#39; + id,
    method: &#39;get&#39;
  &#125;)
&#125;

// 新增课程管理
// 当点击确定按钮的时候 就把数据添加进来发送请求后返回前端
export function addCourse(data) &#123;
  return request(&#123;
    url: &#39;/course/course&#39;,
    method: &#39;post&#39;,
    data: data
  &#125;)
&#125;

// 修改课程管理
// 修改完毕(根据id去查找数据库的)
export function updateCourse(data) &#123;
  return request(&#123;
    url: &#39;/course/course&#39;,
    method: &#39;put&#39;,
    data: data
  &#125;)
&#125;

// 删除课程管理
// 批量/单体删除
export function delCourse(id) &#123;
  return request(&#123;
    url: &#39;/course/course/&#39; + id,
    method: &#39;delete&#39;
  &#125;)
&#125;
</code></pre>
<h3 id="再次熟悉：前-后端结构"><a href="#再次熟悉：前-后端结构" class="headerlink" title="再次熟悉：前+后端结构"></a><span style = "color:red">再次熟悉：前+后端结构</span></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/2d1ced51ed4dfb918b78181cb385e58594e7bdaa/RuoYi%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg"></p>
<h6 id="若i18n乱码的情况下"><a href="#若i18n乱码的情况下" class="headerlink" title="若i18n乱码的情况下"></a>若i18n乱码的情况下</h6><blockquote>
<p>file -&gt; settings -&gt; editor -&gt; file ecoding -&gt; <strong>default encoding for properties files</strong>：utf-8</p>
</blockquote>
<h3 id="后端代码分析"><a href="#后端代码分析" class="headerlink" title="后端代码分析"></a>后端代码分析</h3><ul>
<li><p><strong>CourseController</strong></p>
</li>
<li><p><strong>ICourseService及实现类</strong></p>
</li>
<li><p><strong>CourseMapper及映射方法</strong></p>
</li>
<li><p><strong>Course</strong></p>
</li>
<li><p><strong><u>BaseController：web层通用数据处理</u></strong></p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/afd799acd589023d8452649e6565150168bee83b/BaseController%E5%86%85%E5%AE%B9.jpg" style="zoom:200%;" />

<pre><code class="java">/**
     * 查询课程管理列表
     */
    @PreAuthorize(&quot;@ss.hasPermi(&#39;course:course:list&#39;)&quot;)
    @GetMapping(&quot;/list&quot;)
    public TableDataInfo list(Course course) &#123;
        //1.开启分页
        startPage();
        //2.查询课程列表
        List&lt;Course&gt; list = courseService.selectCourseList(course);
        return getDataTable(list);
    &#125;
// 在分页查询那块会附带着两个封装好的sql语句
// select * from tb_course where xxx 【逐步细分成两个小sql】
  1. select count(*) from tb_course where xxx      //总记录数
  2. select * from tb_course where xxx limit ?,?   //获取当前的数据列表
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/644e3ab525e8c4aaf75d6f6f3e3879cb2a196303/%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%8E%9F%E7%90%86.jpg"></p>
<h5 id="分页原理"><a href="#分页原理" class="headerlink" title="分页原理"></a>分页原理</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/14bbabe082a07e29da26ea9d5f0c648dcf91677a/%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%8E%9F%E7%90%862.jpg"></p>
<h5 id="AjaxResult：操作消息提醒"><a href="#AjaxResult：操作消息提醒" class="headerlink" title="AjaxResult：操作消息提醒"></a>AjaxResult：操作消息提醒</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/92f34019d9a098b23780c66e99a5bab18541ee9a/AjaxResult%E6%93%8D%E4%BD%9C%E4%BF%A1%E6%81%AF%E6%8F%90%E9%86%92.jpg"></p>
<h5 id="权限解读"><a href="#权限解读" class="headerlink" title="权限解读"></a>权限解读</h5><ul>
<li><code>@PreAuthorize</code>注解是Spring Security框架中用来做权限检查的。</li>
<li>它在运行方法前先验证权限，权限够就放行，不够就拦截</li>
</ul>
<pre><code class="java">@RestController
@RequestMapping(&quot;/course/course&quot;)
public class CourseController extends BaseController &#123;
    @Autowired
    private ICourseService courseService;

    /**
     * 查询课程管理列表
     */
// 问题：我怎么知道该用户有没有权限呢？基于RBC权限模型 
    @PreAuthorize(&quot;@ss.hasPermi(&#39;course:course:list&#39;)&quot;)
    @GetMapping(&quot;/list&quot;)
    public TableDataInfo list(Course course) &#123;
        startPage();
        List&lt;Course&gt; list = courseService.selectCourseList(course);
        return getDataTable(list);
    &#125;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>菜单名称</th>
<th>排序</th>
<th>权限标识</th>
</tr>
</thead>
<tbody><tr>
<td>课程管理</td>
<td>1</td>
<td>course:course:list</td>
</tr>
<tr>
<td>课程管理查询</td>
<td>1</td>
<td>course:course:query</td>
</tr>
<tr>
<td>课程管理新增</td>
<td>2</td>
<td>course:course:add</td>
</tr>
<tr>
<td>课程管理修改</td>
<td>3</td>
<td>course:course:edit</td>
</tr>
<tr>
<td>课程管理删除</td>
<td>4</td>
<td>course:course:remove</td>
</tr>
<tr>
<td>课程管理导出</td>
<td>5</td>
<td>course:course:export</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/623caf468a6f636c5fe27e119368bfabc1e20aa2/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg"></p>
<pre><code class="java">PermissionService.java
源码解读在后期

/**
 * RuoYi首创 自定义权限实现，ss取自SpringSecurity首字母
 * 
 * @author ruoyi
 */
@Service(&quot;ss&quot;)
public class PermissionService
&#123;
    /**
     * 验证用户是否具备某权限
     * 
     * @param permission 权限字符串
     * @return 用户是否具备某权限
     */
    public boolean hasPermi(String permission)
    &#123;
        if (StringUtils.isEmpty(permission))
        &#123;
            return false;
        &#125;
        LoginUser loginUser = SecurityUtils.getLoginUser();
        if (StringUtils.isNull(loginUser) || CollectionUtils.isEmpty(loginUser.getPermissions()))
        &#123;
            return false;
        &#125;
        PermissionContextHolder.setContext(permission);
        return hasPermissions(loginUser.getPermissions(), permission);
    &#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7e976e8ec0b1bb90abd5f6fc94d23c9b8ba39a8b/%E5%89%8D%E5%90%8E%E8%81%94%E8%B0%83.jpg"></p>
<h3 id="二次开发-——-苍穹外卖"><a href="#二次开发-——-苍穹外卖" class="headerlink" title="二次开发 —— 苍穹外卖"></a>二次开发 —— 苍穹外卖</h3><h5 id="若依框架修改器"><a href="#若依框架修改器" class="headerlink" title="若依框架修改器"></a>若依框架修改器</h5><ul>
<li>若依框架修改器是一个可以一键修改RuoYi框架包名、项目名等的工具</li>
</ul>
<blockquote>
<p>E:\Java实例项目1-20套\2024-Java若依框架专题课\01-基础篇\资料\04-二次开发\若依框架修改器.exe</p>
</blockquote>
<pre><code class="java">选择系列：RuoYi-Vue
目录名称: sky
项目名：sky
包名：com.sky
artifactId：sky
groupId：com.sky
站点名称：外卖管理系统


C:\Users\Pluminary\Desktop\20241108150415\sky
</code></pre>
<h5 id="新建业务模块"><a href="#新建业务模块" class="headerlink" title="新建业务模块"></a>新建业务模块</h5><ul>
<li><p>新建<code>sky-merchant</code>子模块<del>商家管理</del></p>
<ul>
<li><p>新建子模块<br><code>sky-merchant</code> → Advanced Settings → GroupId：com.sky</p>
</li>
<li><p>父工程版本锁定</p>
<pre><code class="xml">pom.xml(sky总)
&lt;!-- 商家管理--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.sky&lt;/groupId&gt;
                &lt;artifactId&gt;sky-merchant&lt;/artifactId&gt;
                &lt;version&gt;$&#123;sky.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">pom.xml(sky-merchant)
&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sky&lt;/groupId&gt;
            &lt;artifactId&gt;sky-framework&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
</li>
<li><p>sky-admin添加依赖</p>
<pre><code class="xml">pom.xml(sky-admin) 
&lt;dependency&gt;
            &lt;groupId&gt;com.sky&lt;/groupId&gt;
            &lt;artifactId&gt;sky-merchant&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h3><ul>
<li><strong>利用若依代码生成器(主子表模板)，生成菜品管理的前后端代码</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">tb_dish【菜品管理】</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><span style = "color:red"><strong>id</strong></span></td>
</tr>
<tr>
<td align="left">name</td>
</tr>
<tr>
<td align="left">price</td>
</tr>
<tr>
<td align="left">image</td>
</tr>
<tr>
<td align="left">description</td>
</tr>
<tr>
<td align="left">status</td>
</tr>
<tr>
<td align="left">create_time</td>
</tr>
<tr>
<td align="left">update_time</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>tb_dish_flavor【菜品口味关系表】</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
</tr>
<tr>
<td><span style = "color:red"><strong>dish_id</strong></span></td>
</tr>
<tr>
<td>name</td>
</tr>
<tr>
<td>value</td>
</tr>
</tbody></table>
<ul>
<li><p>准备SQL并导入数据库</p>
<blockquote>
<p>E:\Java实例项目1-20套\2024-Java若依框架专题课\01-基础篇\资料\04-二次开发\菜品管理</p>
</blockquote>
</li>
<li><p>配置代码生成信息【主子表的生成】</p>
<blockquote>
<p>在若依代码生成 → 导入表<strong>tb_dish</strong> 和 <strong>tb_dish_flavor</strong></p>
</blockquote>
</li>
<li><p>下载代码并导入项目</p>
</li>
<li><p>修改代码 → 系统工具 → 代码生成 → 菜品管理(修改) → </p>
<blockquote>
<p>基本信息：实体类名称→Dish     作者→itheima</p>
</blockquote>
<p>字段信息<del>参考页面原型生成</del> → 系统管理 → 字典管理 →</p>
<blockquote>
<p>字典名称：售卖状态<br>字典类型：dish_status<br>第二页点进去售卖状态的字典类型 dish_status → 新增</p>
<blockquote>
<p>数据标签：停售  +  起售<br>数据键值：0  +  1<br>显示排序：1  +  2</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>​      回到系统工具 → 代码生成 → 菜品管理修改 → 售卖状态 → 显示类型：下拉框 → 字典类型：售卖状态</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f50e3c057b0a8fae3fb16f4e3bcc1c9b507ed227/%E8%8F%9C%E5%8D%95%E8%8B%A5%E4%BE%9D%E4%BD%BF%E7%94%A8.jpg"></p>
<p>→ 代码生成 → 修改菜单配置信息 → 菜品</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/26b0d18887d1c565926b28e8d450fa2a773ccadb/%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%93%81.jpg"></p>
<p>→ 上面的生成信息</p>
<blockquote>
<p>生成模板：主子表<br>生成模块名：merchant<br>生成业务名：dish<br>关联子表的表名：tb_dish_flavor：菜品口味关系表<br>子表关联的外键名：dish_id：菜品</p>
</blockquote>
<p>→ 在代码生成 → tb_dish_flavor菜品口味关系表 → 点击编辑</p>
<blockquote>
<p>基本信息：<br>实体名：DishFalvor</p>
</blockquote>
<p>→ 生成代码(main后端 + vue前端 + dishMenu.sql数据库动态菜单) → 动态sql导入进去 → 前端vue将merchant导入到.&#x2F;src&#x2F;api中，将views导入到views中 → 在前端中将java和resources导入到merchant模块中</p>
<h4 id="对菜品管理进行升级改造"><a href="#对菜品管理进行升级改造" class="headerlink" title="对菜品管理进行升级改造"></a>对菜品管理进行升级改造</h4><h6 id="主键隐藏掉-售价前缀￥-修改时间时分秒"><a href="#主键隐藏掉-售价前缀￥-修改时间时分秒" class="headerlink" title="主键隐藏掉 售价前缀￥ 修改时间时分秒"></a>主键隐藏掉 售价前缀￥ 修改时间时分秒</h6><pre><code class="java">src\views\merchant\dish\index.vue 
把  &lt;el-table-column label=&quot;主键&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;  打注释符
////////////////////////////////////////////////////////////////////////////
插入￥流程：
&lt;el-table-column label=&quot;售价&quot; align=&quot;center&quot; prop=&quot;price&quot; /&gt; 修改为 →
&lt;el-table-column label=&quot;售价&quot; align=&quot;center&quot; prop=&quot;price&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;div&gt;
            ￥&#123;&#123; scope.row.price &#125;&#125;
          &lt;/div&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
通义灵码操作：
先解析那行代码，然后输入使用vue3语法在售价前显示￥
////////////////////////////////////////////////////////////////////////////
生成年月日时分秒：
&lt;el-table-column label=&quot;更新时间&quot; align=&quot;center&quot; prop=&quot;updateTime&quot; width=&quot;180&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;span&gt;&#123;&#123; parseTime(scope.row.updateTime, '&#123;y&#125;-&#123;m&#125;-&#123;d&#125;') &#125;&#125;&lt;/span&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
修改为：

</code></pre>
<h6 id="修改图片回显bug"><a href="#修改图片回显bug" class="headerlink" title="修改图片回显bug"></a>修改图片回显bug</h6><blockquote>
<p>新增毛血旺的图片若依默认保存在了本地服务器而不是阿里云上<br><code>/profile/upload/2024/11/10/毛血旺_20241110093243A001.jpg</code></p>
<p>C:\Users\Pluminary\Desktop\20241108150415\sky\sky-admin\src\main\resources\application.yml</p>
<pre><code class="yaml"># 项目相关配置
ruoyi:
  # 名称
  name: RuoYi
  # 版本
  version: 3.8.8
  # 版权年份
  copyrightYear: 2024
  # 文件路径 示例（ Windows配置D:/ruoyi/uploadPath，Linux配置 /home/ruoyi/uploadPath）
  profile: D:/ruoyi/uploadPath
  # 获取ip地址开关
  addressEnabled: false
  # 验证码类型 math 数字计算 char 字符验证
  captchaType: math
</code></pre>
<p><code>D:\ruoyi\uploadPath\upload\2024\11\10</code><br>文件上传组件标签修改 增加<code>&amp;&amp; item.indexOf(&quot;http&quot;) === -1</code></p>
<pre><code class="js">watch(() =&gt; props.modelValue, val =&gt; &#123;
  if (val) &#123;
    // 首先将值转为数组
    const list = Array.isArray(val) ? val : props.modelValue.split(&quot;,&quot;);
    // 然后将数组转为对象数组
    fileList.value = list.map(item =&gt; &#123;
      if (typeof item === &quot;string&quot;) &#123;
        if (item.indexOf(baseUrl) === -1 &amp;&amp; item.indexOf(&quot;http&quot;) === -1) &#123;
          item = &#123; name: baseUrl + item, url: baseUrl + item &#125;;
        &#125; else &#123;
          item = &#123; name: item, url: item &#125;;
        &#125;
      &#125;
      return item;
    &#125;);
  &#125; else &#123;
    fileList.value = [];
    return [];
  &#125;
&#125;,&#123; deep: true, immediate: true &#125;);
</code></pre>
</blockquote>
<h6 id="修改口味列表数组格式-改为下拉框的口味搭配"><a href="#修改口味列表数组格式-改为下拉框的口味搭配" class="headerlink" title="修改口味列表数组格式 改为下拉框的口味搭配"></a>修改口味列表数组格式 改为下拉框的口味搭配</h6><pre><code class="js">src\views\merchant\dish\index.vue
//------------------------------------------------
// 定义口味名称和口味列表静态数据
const dishFlavorListSelect = ref([
  &#123;name:&quot;辣度&quot;, value:[&quot;不辣&quot;,&quot;微辣&quot;,&quot;中辣&quot;,&quot;重辣&quot;]&#125;,
  &#123;name:&quot;忌口&quot;, value:[&quot;不要葱&quot;,&quot;不要蒜&quot;,&quot;不要香菜&quot;,&quot;不要辣&quot;]&#125;,
  &#123;name:&quot;甜味&quot;, value:[&quot;无糖&quot;,&quot;少糖&quot;,&quot;半糖&quot;]&#125;
]);
//------------------------------------------------
</code></pre>
<pre><code class="js">src\views\merchant\dish\index.vue
&lt;template #default=&quot;scope&quot;&gt;
      &lt;!-- &lt;el-input v-model=&quot;scope.row.name&quot; placeholder=&quot;请输入口味名称&quot; /&gt; --&gt;
               &lt;!-- label是最终看到下拉框的内容 value是用户提交的内容 --&gt;
           &lt;el-select v-model=&quot;scope.row.name&quot;  placeholder=&quot;请选择口味名称&quot;&gt;
                &lt;el-option
                  v-for=&quot;dishFlavor in dishFlavorListSelect&quot;
                  :key=&quot;dishFlavor.name&quot;
                  :label=&quot;dishFlavor.name&quot; 
                  :value=&quot;dishFlavor.name&quot;
                &gt;
                &lt;/el-option&gt;
            &lt;/el-select&gt;
           &lt;/template&gt;
       &lt;/el-table-column&gt;
</code></pre>
<pre><code class="js">src\views\merchant\dish\index.vue【修改当选中辣度时候 后面的规格】
// 存储当前选中口味列表数组
const checkValueList = ref([]);
// 定义改变口味名称时更新当前选中的口味列表
function changeFlavorName(row)&#123;
  // 清空当前行的value
  row.value = [];
  // 根据选中的name去查找静态数据的value
  checkValueList.value = dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;
&#125;
</code></pre>
<pre><code class="js">//增加了一个 @change   注意：如果是多选框一定要 → multiple

&lt;el-table-column label=&quot;口味名称&quot; prop=&quot;name&quot; width=&quot;150&quot;&gt;
            &lt;template #default=&quot;scope&quot;&gt;
              &lt;!-- &lt;el-input v-model=&quot;scope.row.name&quot; placeholder=&quot;请输入口味名称&quot; /&gt; --&gt;
               &lt;!-- label是最终看到下拉框的内容 value是用户提交的内容 --&gt;
               &lt;el-select v-model=&quot;scope.row.name&quot;  placeholder=&quot;请选择口味名称&quot;
               @change=&quot;changeFlavorName(scope.row)&quot;&gt;
                &lt;el-option
                  v-for=&quot;dishFlavor in dishFlavorListSelect&quot;
                  :key=&quot;dishFlavor.name&quot;
                  :label=&quot;dishFlavor.name&quot; 
                  :value=&quot;dishFlavor.name&quot;
                &gt;
                &lt;/el-option&gt;
               &lt;/el-select&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;口味列表&quot; prop=&quot;value&quot; width=&quot;150&quot;&gt;
            &lt;template #default=&quot;scope&quot;&gt;
              &lt;!-- &lt;el-input v-model=&quot;scope.row.value&quot; placeholder=&quot;请输入口味列表&quot; /&gt; --&gt;
          &lt;el-select v-model=&quot;scope.row.value&quot;  placeholder=&quot;请选择口味列表&quot; multiple&gt;
                &lt;el-option
                  v-for=&quot;value in checkValueList&quot;
                  :key=&quot;value&quot;
                  :label=&quot;value&quot; 
                  :value=&quot;value&quot;
                /&gt;
          &lt;/el-select&gt;
          &lt;/template&gt;
          &lt;/el-table-column&gt;
</code></pre>
<pre><code class="js">//------------------------------------------------
// 定义口味名称和口味列表静态数据
const dishFlavorListSelect = ref([
  &#123;name:&quot;辣度&quot;, value:[&quot;不辣&quot;,&quot;微辣&quot;,&quot;中辣&quot;,&quot;重辣&quot;]&#125;,
  &#123;name:&quot;忌口&quot;, value:[&quot;不要葱&quot;,&quot;不要蒜&quot;,&quot;不要香菜&quot;,&quot;不要辣&quot;]&#125;,
  &#123;name:&quot;甜味&quot;, value:[&quot;无糖&quot;,&quot;少糖&quot;,&quot;半糖&quot;]&#125;
]);


// 存储当前选中口味列表数组
const checkValueList = ref([]);
// 定义改变口味名称时更新当前选中的口味列表
function changeFlavorName(row)&#123;
  // 根据选中的name去查找静态数据的value
  checkValueList.value =       dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;
&#125;
//------------------------------------------------
</code></pre>
<pre><code class="java">// 此时报错了 
11:59:00.441 [http-nio-8080-exec-64] ERROR c.s.f.w.e.GlobalExceptionHandler - [handleRuntimeException,100] - 请求地址&#39;/merchant/dish&#39;,发生未知异常.
org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.lang.String` from Array value (token `JsonToken.START_ARRAY`); nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize value of type `java.lang.String` from Array value (token `JsonToken.START_ARRAY`)
 at [Source: (org.springframework.util.StreamUtils$NonClosingInputStream); line: 1, column: 239] (through reference chain: com.sky.system.domain.Dish[&quot;dishFlavorList&quot;]-&gt;java.util.ArrayList[0]-&gt;com.sky.system.domain.DishFlavor[&quot;value&quot;])
    
/*
根据错误日志，问题出在请求地址 /merchant/dish 处理过程中，JSON 解析时出现了类型不匹配的问题。具体来说，Dish 对象中的 dishFlavorList 字段下的 DishFlavor 对象的 value 字段期望接收一个 String 类型的值，但实际接收到的是一个数组。
*/
</code></pre>
<h6 id="解决序列化问题bug将口味列表中value通过JSON工具类转换为字符串"><a href="#解决序列化问题bug将口味列表中value通过JSON工具类转换为字符串" class="headerlink" title="解决序列化问题bug将口味列表中value通过JSON工具类转换为字符串"></a>解决序列化问题bug<del>将口味列表中value通过JSON工具类转换为字符串</del></h6><p>提交数据后是字符串 而不是数组</p>
<pre><code class="js">在331行
/** 提交按钮 */
function submitForm() &#123;
  proxy.$refs[&quot;dishRef&quot;].validate(valid =&gt; &#123;
    if (valid) &#123;
      form.value.dishFlavorList = dishFlavorList.value;
      // 将口味列表中value通过JSON工具类转换为字符串
      form.value.dishFlavorList.forEach(item=&gt;item.value = JSON.stringify(item.value))
      if (form.value.id != null) &#123;
        updateDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;修改成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125; else &#123;
        addDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;新增成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125;
    &#125;
  &#125;);
</code></pre>
<h6 id="解决后端添加成功后-修改后口味列表无法回显再增加个非空判断"><a href="#解决后端添加成功后-修改后口味列表无法回显再增加个非空判断" class="headerlink" title="解决后端添加成功后 修改后口味列表无法回显再增加个非空判断"></a>解决后端添加成功后 修改后口味列表无法回显<del>再增加个非空判断</del></h6><p>因为前端提交了字符串給后端，后端再回去修改的时候无法解析字符串 <code>拿到字符串后返回JSON数组即可</code></p>
<pre><code class="js">/** 修改按钮操作 */
function handleUpdate(row) &#123;
  reset();
  const _id = row.id || ids.value
  getDish(_id).then(response =&gt; &#123;
    form.value = response.data;
    dishFlavorList.value = response.data.dishFlavorList;
    // 将口味列表的value字符串转成json数组
    if(dishFlavorList.value!=null)&#123;
      form.value.dishFlavorList.forEach(item=&gt;item.value = JSON.parse(item.value))
    &#125;
    open.value = true;
    title.value = &quot;修改菜品管理&quot;;
  &#125;);
&#125;

/** 提交按钮 */
function submitForm() &#123;
  proxy.$refs[&quot;dishRef&quot;].validate(valid =&gt; &#123;
    if (valid) &#123;
      form.value.dishFlavorList = dishFlavorList.value;
      // 将口味列表中value通过JSON工具类转换为字符串
      if(form.value.dishFlavorList!=null)&#123;
        form.value.dishFlavorList.forEach(item=&gt;item.value = JSON.stringify(item.value))
      &#125;
      if (form.value.id != null) &#123;
        updateDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;修改成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125; else &#123;
        addDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;新增成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125;
    &#125;
  &#125;);
&#125;
</code></pre>
<h6 id="解决修改时无法修改口味列表的下拉框"><a href="#解决修改时无法修改口味列表的下拉框" class="headerlink" title="解决修改时无法修改口味列表的下拉框"></a>解决修改时无法修改口味列表的下拉框</h6><blockquote>
<p>給口味下拉框绑定一个获取焦点事件 再该事件内调用方法根据当前行的口味名称去查询静态数据 再赋值給静态数组</p>
</blockquote>
<pre><code class="js">// 删除清除策略
// 定义口味列表获取焦点时更新当前选中的口味列表
function FocusFlavorName(row)&#123;
  // 根据选中的name去查找静态数据的value
  checkValueList.value = dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;
&#125;
</code></pre>
<pre><code class="js">// 加个 @focus
&lt;el-table-column label=&quot;口味列表&quot; prop=&quot;value&quot; width=&quot;150&quot;&gt;
            &lt;template #default=&quot;scope&quot;&gt;
              &lt;!-- &lt;el-input v-model=&quot;scope.row.value&quot; placeholder=&quot;请输入口味列表&quot; /&gt; --&gt;
              &lt;el-select v-model=&quot;scope.row.value&quot;  placeholder=&quot;请选择口味列表&quot; multiple
              @focus = &quot;FocusFlavorName(scope.row)&quot;&gt;
                &lt;el-option
                  v-for=&quot;value in checkValueList&quot;
                  :key=&quot;value&quot;
                  :label=&quot;value&quot; 
                  :value=&quot;value&quot;
                /&gt;
               &lt;/el-select&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
</code></pre>
<h3 id="二次开发——页面调整"><a href="#二次开发——页面调整" class="headerlink" title="二次开发——页面调整"></a>二次开发——页面调整</h3><h6 id="将原有的页面，调整为外卖管理系统的项目标识"><a href="#将原有的页面，调整为外卖管理系统的项目标识" class="headerlink" title="将原有的页面，调整为外卖管理系统的项目标识"></a>将原有的页面，调整为外卖管理系统的项目标识</h6><ul>
<li>浏览器标签页icon、标题</li>
<li>系统页面中的logo、标题</li>
<li>去除源码 &amp; 文档 </li>
<li>主题和自定义图标</li>
<li>登录页面中标题、背景图</li>
</ul>
<blockquote>
<p><strong>icon</strong>：public中的favicon.ico 改为 favicon.ico.bak 就作废了<br>把新的图标复制进来改成favicon.ico</p>
<p><strong>标题</strong>：最外层index.html<br>&lt; title&gt; 外卖管理系统 &lt; &#x2F;title&gt;<br>但是改完没有效果 是因为运行环境給覆盖了<br><code>.env.development</code>修改一下</p>
<p><strong>logo</strong>放在了静态资源页面<br>src\assets\logo\logo.png</p>
<p><strong>修改顶部源码和文档图标内容</strong><br>src\layout\components\Navbar.vue</p>
<pre><code class="js">&lt;!-- &lt;el-tooltip content=&quot;源码地址&quot; effect=&quot;dark&quot; placement=&quot;bottom&quot;&gt;
          &lt;ruo-yi-git id=&quot;ruoyi-git&quot; class=&quot;right-menu-item hover-effect&quot; /&gt;
        &lt;/el-tooltip&gt;

        &lt;el-tooltip content=&quot;文档地址&quot; effect=&quot;dark&quot; placement=&quot;bottom&quot;&gt;
          &lt;ruo-yi-doc id=&quot;ruoyi-doc&quot; class=&quot;right-menu-item hover-effect&quot; /&gt;
        &lt;/el-tooltip&gt; --&gt;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a><br>下载一个<strong>菜品管理的小图标</strong><br>然后给它复制进去src\assets\icons\svg\菜品管理.svg<br>随后回到菜单管理修改图标就好</p>
<p><strong>登录界面图片修改：</strong><br>src\views\login.vue 修改一下标题<br>背景图 → src\assets\images\login-background1.jpg<br>通过css样式修改背景图<br>171行<br> <code>background-image: url(&quot;../assets/images/login-background.jpg&quot;);</code><br>修改为<br><code> background-image: url(&quot;../assets/images/login-background1.jpg&quot;);</code></p>
<pre><code class="css">.login &#123;
  display: flex;
  justify-content: right;
  align-items: center;
  height: 100%;
  background-image: url(&quot;../assets/images/login-background1.jpg&quot;);
  background-size: cover;
&#125;
</code></pre>
</blockquote>
<h6 id="給外卖商家的员工创建角色和用户分配菜单的权限-登录后只能看到自己的功能"><a href="#給外卖商家的员工创建角色和用户分配菜单的权限-登录后只能看到自己的功能" class="headerlink" title="給外卖商家的员工创建角色和用户分配菜单的权限 登录后只能看到自己的功能"></a>給外卖商家的员工创建角色和用户分配菜单的权限 登录后只能看到自己的功能</h6><blockquote>
<p>系统管理 → 角色管理 →  新增 →<br>角色名称：商家员工<br>权限字符串：merchant<br>角色顺序：4<br>菜单权限：父子联动<br>√ 菜品管理</p>
<p>再到用户管理 → 新增 → 添加用户 →<br>用户昵称：波妞<br>用户名称：boniu<br>用户密码：admin123<br>角色：商家员工</p>
</blockquote>
<h1 id="帝可得"><a href="#帝可得" class="headerlink" title="帝可得"></a>帝可得</h1><ul>
<li><p>帝可得是一个基于<strong>物联网</strong>概念下的<strong>智能售货机</strong>运营管理系统</p>
<ul>
<li><p><strong>物联网</strong>(IOT)</p>
<p>让各种物品通过互联网链接起来，实现信息的交换和通信</p>
<ul>
<li>智能家居</li>
<li>共享充电桩</li>
<li>智能售货机</li>
</ul>
</li>
<li><p><strong>智能售货机</strong></p>
<p>是物联网技术的一个典型应用</p>
<ul>
<li>物联网技术</li>
<li>智能分析与推荐</li>
<li>人员设备绑定管理</li>
<li>线上线下融合</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="售货机术语"><a href="#售货机术语" class="headerlink" title="售货机术语"></a>售货机术语</h6><ul>
<li><p><strong>区域管理</strong></p>
<p>为了更高效地进行经营管理，公司将运营范围划分为若干个逻辑区域</p>
</li>
<li><p><strong>点位选择</strong></p>
<p>点位指的是智能售货机的具体放置位置</p>
</li>
<li><p><strong>售货机功能</strong></p>
<p>自动小店，摆满了各种零食</p>
</li>
<li><p><strong>货道设计</strong></p>
<p>售货机里的货道</p>
</li>
</ul>
</li>
</ul>
<h3 id="角色与功能"><a href="#角色与功能" class="headerlink" title="角色与功能"></a>角色与功能</h3><ul>
<li>一个完整的售货机系统由**<u>五端五角色</u>**组成:</li>
<li><strong>管理员</strong>：对基础数据(区域、点位、设备、货道、商品等)进行管理</li>
<li><strong>运维人员</strong>：投放设备、撤除设备、维修设备。</li>
<li><strong>运营人员</strong>：补货。</li>
<li><strong>合作商</strong>：仅提供点位，坐收渔翁之利。</li>
<li><strong>消费者</strong>：在小程序或屏幕端下单购买商品。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://ksg50j5gph.feishu.cn/docx/NxIqdCZVzo2tRfxNL6Nc1BD1nnf">帝可得在线功能文档_Docs</a></p>
<p>帝可得项目点击链接立即查看 <a target="_blank" rel="noopener" href="https://codesign.qq.com/s/426304924036117">https://codesign.qq.com/s/426304924036117</a></p>
<h3 id="库表设计"><a href="#库表设计" class="headerlink" title="库表设计"></a>库表设计</h3><ul>
<li>系统后台基础数据表关系说明：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e677e01fa90ed813fd68cab1fabdde7b958ec9df/%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%85%B3%E7%B3%BB%E8%AF%B4%E6%98%8E.png"></p>
<h3 id="AIGC"><a href="#AIGC" class="headerlink" title="AIGC"></a>AIGC</h3><ul>
<li><p><strong>AI</strong> (Artificial Intelligence)：即<strong>人工智能</strong>，是指通过计算机系统模拟人类<strong>思维</strong>和<strong>行为</strong>一种技术</p>
</li>
<li><p>它通过机器学习、深度学习等算法，使计算机具备对数据分析、理解、推理和决策的能力</p>
</li>
<li><p><strong>AIGC</strong> (AI Generated content)：是AI领域的一个应用分支，专注于利用AI技术自动生成内容</p>
</li>
<li><p>国内常见的通用大模型(AGI)产品：</p>
<ul>
<li>文心一言</li>
<li>讯飞星火</li>
<li>通义千问</li>
<li>KIMI</li>
</ul>
</li>
</ul>
<h3 id="Prompt的组成"><a href="#Prompt的组成" class="headerlink" title="Prompt的组成"></a>Prompt的组成</h3><ul>
<li><strong>角色</strong>：给 AI 定义一个最匹配任务的角色，比如：「你是一位软件工程师」「你是一位小学老师」</li>
<li><strong>指示</strong>：对任务进行描述</li>
<li><strong>上下文</strong>：给出与任务相关的其它背景信息（尤其在多轮交互中）</li>
<li><strong>例子</strong>：必要时给出举例，[实践证明其对输出正确性有帮助]</li>
<li><strong>输入</strong>：任务的输入信息；在提示词中明确的标识出输入</li>
<li><strong>输出</strong>：输出的格式描述，以便后继模块自动解析模型的输出结果，比如（JSON、Java）</li>
</ul>
<blockquote>
<p>先定义角色，其实就是在<strong>开头把问题域收窄</strong>，减少二义性。</p>
</blockquote>
<p><strong>案例：</strong></p>
<pre><code class="markdown">角色：你是一位专业的博客作者。

指示：撰写一篇关于最新AI技术发展的文章。

上下文：文章应该涵盖AI技术的当前状态和未来趋势。

例子：可以引用最近的AI技术突破和行业专家的见解。

输入：当前AI技术的相关信息和数据。

输出：一篇结构清晰、观点鲜明的文章草稿。
</code></pre>
<pre><code class="markdown">角色：你是一位资深的Java开发工程师。

指示：编写一个Java函数，该函数接收两个整数参数，并返回它们的和。

上下文：这个函数将被用于一个简单的数学应用程序，该程序帮助学生练习基本的算术运算。

例子：如果你调用函数 `addNumbers(3, 5)`，它应该返回 `8`。

输入：两个整数参数，分别为 `int a` 和 `int b`。

输出：返回这两个整数的和，类型为 `int`。
</code></pre>
<h3 id="常见的编程相关的Prompt"><a href="#常见的编程相关的Prompt" class="headerlink" title="常见的编程相关的Prompt"></a>常见的编程相关的Prompt</h3><h4 id="表结构-1"><a href="#表结构-1" class="headerlink" title="表结构"></a>表结构</h4><pre><code class="markdown">你是一个软件工程师，帮我生成MySQL的表结构
需求如下：
    1，课程管理表，表名tb_course，字段有主键id、课程编码、课程学科、课程名称、课程价格、适用人群、课程介绍
其他要求：
    1，每个表中都有创建时间(create_time)、修改时间(date_time)、创建人(create_by)、修改人(update_by)、备注(remark)这些字段
    2，每个表的主键都是自增的
    3，课程价格是整型、课程编码是字符串
    4，请为每个字段都添加上comment
    5，帮我给生成的表中插入一些IT课程示例数据
        课程学科：Java、人工智能、大数据
        适用人群：小白学员、中级程序员
</code></pre>
<h4 id="生成数据库说明文档"><a href="#生成数据库说明文档" class="headerlink" title="生成数据库说明文档"></a>生成数据库说明文档</h4><pre><code class="markdown">你是一个软件工程师，现在要根据数据库的sql脚本，编写数据库说明文档，sql脚本如下：
CREATE TABLE `tb_course` (
    `id` INT AUTO_INCREMENT COMMENT &#39;主键ID&#39;,
    `course_code` VARCHAR(255) NOT NULL COMMENT &#39;课程编码&#39;,
    `course_subject` VARCHAR(100) NOT NULL COMMENT &#39;课程学科&#39;,
    `course_name` VARCHAR(255) NOT NULL COMMENT &#39;课程名称&#39;,
    `course_price` INT COMMENT &#39;课程价格&#39;,
    `target_audience` VARCHAR(100) COMMENT &#39;适用人群&#39;,
    `course_introduction` TEXT COMMENT &#39;课程介绍&#39;,
    `create_time` DATETIME COMMENT &#39;创建时间&#39;,
    `update_time` DATETIME COMMENT &#39;修改时间&#39;,
    `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
    `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
    `remark` VARCHAR(255) COMMENT &#39;备注&#39;,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;课程管理表&#39;;

输出要求是：
    1，每个表以及每个表的字段都要详细说明，包括，字段名称、类型、作用
    2，使用markdown的输出格式，字段的描述需要使用表格展示
    3，如果表之间有关系，需要描述清楚表之间的关系
</code></pre>
<h4 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h4><p>代码生成算是比较常规的方案，用的也比较多，分为了几种情况</p>
<ul>
<li>给出表生成代码（项目中常见）<ul>
<li>给出表结构的ddl，可以输出这个表的增删改查的所有代码</li>
<li>给出表结构的dll，可以输出增删改查的接口文档</li>
</ul>
</li>
<li>补全代码<ul>
<li>例1-给出实体类，帮助编写getter、setter、toString、构造方法等等</li>
<li>例2-给出一个controller，帮助编写swagger注解等</li>
</ul>
</li>
<li>提取结构（无含金量，费时间的编程）<ul>
<li>例1-根据接口文档提取dto类或者vo类</li>
</ul>
</li>
</ul>
<h4 id="生成代码流程图"><a href="#生成代码流程图" class="headerlink" title="生成代码流程图"></a>生成代码流程图</h4><p>有一些比较复杂的业务流程，往往需要画出流程图，现在就可以使用ai协助我们画流程图</p>
<pre><code class="java">你是一个软件工程师，为了方便理解代码执行流程，需要给出代码执行的流程图，代码如下：
    // 创建工单
    @Transactional
    @Override
    public int insertTaskDto(TaskDto taskDto) &#123;
    //1. 查询售货机是否存在
    VendingMachine vm = vendingMachineService.selectVendingMachineByInnerCode(taskDto.getInnerCode());
    if (vm == null) &#123;
        throw new ServiceException(&quot;设备不存在&quot;);
    &#125;
    //2. 校验售货机状态与工单类型是否相符
    checkCreateTask(vm.getVmStatus(), taskDto.getProductTypeId());
    //3. 校验这台设备是否有未完成的同类型工单，如果存在则不能创建
    hasTask(taskDto.getInnerCode(), taskDto.getProductTypeId());
    //4. 校验员工是否存在
    Emp emp = empService.selectEmpById(taskDto.getUserId());
    if (emp == null) &#123;
        throw new ServiceException(&quot;员工不存在&quot;);
    &#125;
    // 5. 校验非同区域下的工作人员不能接受工单
    if (emp.getRegionId() != vm.getRegionId()) &#123;
        throw new ServiceException(&quot;非同区域下的工作人员不能接受工单&quot;);
    &#125;
    //6. 保存工单信息
    Task task = new Task();
    BeanUtil.copyProperties(taskDto, task);// 属性赋值
    task.setCreateTime(DateUtils.getNowDate());// 创建时间
    task.setTaskCode(generateTaskCode());// 工单编号 202405150001
    task.setTaskStatus(DkdContants.TASK_STATUS_CREATE);// 创建工单
    task.setAddr(vm.getAddr());
    task.setRegionId(vm.getRegionId());
    task.setUserName(emp.getUserName());
    int taskResult = taskMapper.insertTask(task);
    //7. 如果是补货工单，向工单明细表插入记录
    if (task.getProductTypeId() == DkdContants.TASK_TYPE_SUPPLY) &#123;
        if (CollUtil.isEmpty(taskDto.getDetails())) &#123;
            throw new ServiceException(&quot;补货工单明细不能为空&quot;);
        &#125;
        List&lt;TaskDetails&gt; taskDetailsList = taskDto.getDetails().stream().map(details -&gt; &#123;
            TaskDetails taskDetails = BeanUtil.copyProperties(details, TaskDetails.class);
            taskDetails.setTaskId(task.getTaskId());
            return taskDetails;
        &#125;).collect(Collectors.toList());
        taskDetailsService.insertBatch(taskDetailsList);
    &#125;

    return taskResult;
&#125;

输出：请使用mermaid语言来描述这个方法的流程
</code></pre>
<pre><code class="mermaid">graph TD;
    A[查询售货机] --&gt; B(售货机不存在?)
    B -- 是 --&gt; C[抛出异常: 设备不存在]
    B -- 否 --&gt; D[校验售货机状态与工单类型]
    D --&gt; E(校验失败?)
    E -- 是 --&gt; F[抛出异常]
    E -- 否 --&gt; G[检查未完成同类型工单]
    G --&gt; H(存在未完成同类型工单?)
    H -- 是 --&gt; I[抛出异常]
    H -- 否 --&gt; J[查询员工]
    J --&gt; K(员工不存在?)
    K -- 是 --&gt; L[抛出异常: 员工不存在]
    K -- 否 --&gt; M[校验员工区域与售货机区域是否一致]
    M --&gt; N(不一致?)
    N -- 是 --&gt; O[抛出异常: 非同区域工作人员不能接受工单]
    N -- 否 --&gt; P[保存工单信息]
    P --&gt; Q(保存成功?)
    Q -- 否 --&gt; R[处理保存失败]
    Q -- 是 --&gt; S(工单类型为补货?)
    S -- 是 --&gt; T[处理补货工单明细]
    T --&gt; U[补货明细处理结果?]
    U -- 失败 --&gt; V[抛出异常: 补货工单明细不能为空]
    U -- 成功 --&gt; END(结束)
    S -- 否 --&gt; END
</code></pre>
<h3 id="项目搭建-后端"><a href="#项目搭建-后端" class="headerlink" title="项目搭建(后端)"></a>项目搭建(后端)</h3><blockquote>
<p>复制gitee克隆的地址<code>https://gitee.com/Pluminary/dkd-parent.git</code>，在新的idea中找到<code>Get from Version Control</code>在URL中导入<code>xxx.git</code><br>若左列模块没有高亮 右侧找maven→clean→package<br>MySQL的配置和导入 → sql里的sql文件导入到Database<br>C:\Users\Pluminary\Desktop\dkd-parent\dkd-admin\src\main\resources\application-druid.yml<br>连接好数据库配置信息<br>Redis的配置(搞个密码)<br>为了方便学习我没有搞redis的password 项目里的是：root【application.yml的redis里面】<br>打开redis服务后就可以启动啦<code>dkd-parent\dkd-admin\src\main\java\com\dkd\DkdApplication.java</code></p>
</blockquote>
<h3 id="项目搭建-前端"><a href="#项目搭建-前端" class="headerlink" title="项目搭建(前端)"></a>项目搭建(前端)</h3><blockquote>
<p>通过vscode克隆源码，仓库地址：<a target="_blank" rel="noopener" href="https://gitee.com/ys-gitee/dkd-vue.git/">https://gitee.com/ys-gitee/dkd-vue.git\</a></p>
<ul>
<li>打开VS Code，并确保已经安装了Git。如果未安装Git，请先下载并安装。</li>
<li>在VS Code<strong>左侧的活动栏</strong>中点击”Source Control”图标，或者按下Ctrl+Shift+G，打开Git集成面板。</li>
<li>在Git集成面板上方的输入框中，选择并输入要克隆的Git仓库地址。可以是HTTP或SSH地址。</li>
<li>点击Enter键，VS Code将连接到Git仓库并拉取最新的代码</li>
</ul>
<p>在vscode中右上角第二个小框框 点击打开命令行 导入jar包 <code>npm install</code><br>然后<code>npm run dev</code>打开项目<br><a target="_blank" rel="noopener" href="http://10.254.1.228/index">帝可得管理系统 http://10.254.1.228/index</a></p>
<pre><code class="java">在VSCode项目中运行npm install命令主要是用于安装项目所需的Node.js包依赖。以下是具体的作用和步骤：

安装依赖包：当你创建一个Node.js项目或者从版本控制系统中克隆一个项目到本地时，项目中通常会包含一个package.json文件。这个文件里列出了项目所有依赖的包及其版本号。运行npm install命令会读取这个文件，然后从npm（Node Package Manager）仓库下载并安装所有列出的依赖包到项目的node_modules目录。

确保环境一致性：通过npm install，可以确保在不同的开发环境和生产环境中，项目使用的是相同版本的依赖包，这有助于避免因为环境差异导致的bug。

项目初始化：如果你是第一次在一个项目中运行npm install，它还会运行每个依赖包的install脚本，这些脚本可能会进行一些设置工作，比如编译代码、生成必要的文件等。

脚本命令：在package.json中，除了依赖项，还可以定义一些脚本命令（scripts）。npm install会使得这些命令变为可用状态，你可以在项目目录下通过npm run &lt;script-name&gt;来执行这些脚本。
</code></pre>
<p>[npm 加速，命令行修改国内镜像源【附带国内最新几个镜像】超简约版<del>_npm 修改国内镜像-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52172586/article/details/142930356#">https://blog.csdn.net/m0_52172586/article/details/142930356#</a>:</del>:text&#x3D;1.查看目前的镜像源 &gt;npm get registry 2.设置镜像源 &gt;npm,config set registry https%3A %2F%2Fregistry.npmmirror.com 3.验证)</p>
<pre><code class="java">1.查看目前的镜像源
&gt; npm get registry
2.设置镜像源
&gt; npm config set registry https://registry.npmmirror.com
3.验证
&gt; npm get registry
    
/////////////////////////////////////////
后端maven镜像就先设置好maven地址(非C盘)
然后再去配置maven里的文件设置镜像
</code></pre>
</blockquote>
<h1 id="点位管理"><a href="#点位管理" class="headerlink" title="点位管理"></a>点位管理</h1><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p><strong>业务场景</strong>： 假设我们的公司现在有一个宏伟的计划——在北京发展业务。首先，我们需要确定几个有潜力的区域，这些区域可能是人流量大、消费能力高的商业区或居民区。然后，我们要与这些区域内的潜在合作商进行洽谈，比如商场、写字楼、学校等地方的管理者或所有者。</p>
<p>一旦我们与合作商达成协议，确定了合作的细节和点位，我们就可以安排工作人员去投放智能售货机了。这些点位将成为我们智能售货机的“家”，为消费者提供便捷的购买服务。</p>
<p>点位管理主要涉及到三个功能模块，业务流程如下：</p>
<ol>
<li><strong>登录系统</strong>：后台管理人员登录后台系统</li>
<li><strong>新增区域</strong>: 后台管理人员可以添加区域范围，区域范围与运维&#x2F;运维人员挂钩，区域下可关联点位。</li>
<li><strong>新增合作商</strong>: 管理人员可以添加合作商，合作商与点位进行关联。</li>
<li><strong>新增区域点位</strong>: 后台管理人员可以在特定区域内新增点位，这些点位是放置智能售货机的具体位置。</li>
</ol>
<pre><code class="mermaid">graph TD
    A[登录系统] 
    A --&gt; B[新增区域]
    B --&gt; C[新增合作商]
    C --&gt; D[新增区域点位]
</code></pre>
<h2 id="库表设计-1"><a href="#库表设计-1" class="headerlink" title="库表设计"></a>库表设计</h2><ul>
<li>参考页面原型和具体需求完成库表设计</li>
</ul>
<blockquote>
<p><strong>区域表</strong>: 主键id、区域名称、备注说明<br><strong>合作商表</strong>: 主键id、合作商名称、联系人、联系电话、分成比例、账号、密码<br><strong>点位表</strong>: 主键id、点位名称、详细地址、商圈类型、区域外键、合作商外键</p>
</blockquote>
<pre><code class="java">// 你是一位软件工程师，帮我生成MySQL的表结构
需求如下：
1，区域表，表名tb_region，字段有主键id、区域名称
2，合作商表，表名tb_partner，字段有主键id、合作商名称、联系人、联系电话、分成比例（int类型）、账号、密码
3，点位表，表名tb_node，字段有主键id、点位名称、详细地址、商圈类型（int类型）
    
其他要求：
1，每张表中都有创建时间(create_time)、修改时间(date_time)、创建人(create_by)、修改人(update_by)、备注(remark)这些字段
2，每张表的主键都是自增的
3，区域与点位是一对多的关系，合作商与点位是一对多的关系，请用字段表示出来，并建立外键约束
4，请为所有字段都添加上comment
5，帮我给生成的表中插入一些北京城市相关区域、点位、合作商的测试数据
</code></pre>
<pre><code class="sql">CREATE TABLE `tb_region` (
  `id` INT AUTO_INCREMENT COMMENT &#39;主键id&#39; PRIMARY KEY,
  `region_name` VARCHAR(255) NOT NULL COMMENT &#39;区域名称&#39;,
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
  `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
  `remark` TEXT COMMENT &#39;备注&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;区域表&#39;;

-- 插入测试数据
INSERT INTO `tb_region` (`region_name`,`remark`) VALUES (&#39;北京市朝阳区&#39;,&#39;北京市朝阳区&#39;), (&#39;北京市海淀区&#39;,&#39;北京市海淀区&#39;), (&#39;北京市东城区&#39;,&#39;北京市东城区&#39;);

CREATE TABLE `tb_partner` (
  `id` INT AUTO_INCREMENT COMMENT &#39;主键id&#39; PRIMARY KEY,
  `partner_name` VARCHAR(255) NOT NULL COMMENT &#39;合作商名称&#39;,
  `contact_person` VARCHAR(64) COMMENT &#39;联系人&#39;,
  `contact_phone` VARCHAR(15) COMMENT &#39;联系电话&#39;,
  `profit_ratio` INT COMMENT &#39;分成比例&#39;,
  `account` VARCHAR(64) COMMENT &#39;账号&#39;,
  `password` VARCHAR(64) COMMENT &#39;密码&#39;,
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
  `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
  `remark` TEXT COMMENT &#39;备注&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;合作商表&#39;;

-- 插入测试数据
INSERT INTO `tb_partner` (`partner_name`, `contact_person`, `contact_phone`, `profit_ratio`, `account`, `password`) VALUES
(&#39;合作商A&#39;, &#39;张三&#39;, &#39;13800138000&#39;, 30, &#39;a001&#39;, &#39;pwdA&#39;),
(&#39;合作商B&#39;, &#39;李四&#39;, &#39;13912345678&#39;, 25, &#39;b002&#39;, &#39;pwdB&#39;);

CREATE TABLE `tb_node` (
  `id` INT AUTO_INCREMENT COMMENT &#39;主键id&#39; PRIMARY KEY,
  `node_name` VARCHAR(255) NOT NULL COMMENT &#39;点位名称&#39;,
  `address` VARCHAR(255) NOT NULL COMMENT &#39;详细地址&#39;,
  `business_type` INT COMMENT &#39;商圈类型&#39;,
  `region_id` INT COMMENT &#39;区域ID&#39;,
  `partner_id` INT COMMENT &#39;合作商ID&#39;,
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
  `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
  `remark` TEXT COMMENT &#39;备注&#39;,
  FOREIGN KEY (`region_id`) REFERENCES `tb_region`(`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  FOREIGN KEY (`partner_id`) REFERENCES `tb_partner`(`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;点位表&#39;;


-- 插入测试数据
-- 假设区域ID为1对应&#39;北京市朝阳区&#39;，合作商ID为1对应&#39;合作商A&#39;
INSERT INTO `tb_node` (`node_name`, `address`, `business_type`, `region_id`, `partner_id`) VALUES
(&#39;三里屯点位&#39;, &#39;北京市朝阳区三里屯路&#39;, 1, 1, 1),
(&#39;五道口点位&#39;, &#39;北京市海淀区五道口&#39;, 2, 2, 2);
</code></pre>
<p>对于点位管理数据模型，下面是示意图：</p>
<ul>
<li><p>关系字段：region_id、partner_id</p>
</li>
<li><p>数据字典：business_type</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2aea3c59b88952c77f32514636619e7de0202c16/dkd%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1.jpg"></p>
<h3 id="生成基础代码"><a href="#生成基础代码" class="headerlink" title="生成基础代码"></a>生成基础代码</h3><h6 id="使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中："><a href="#使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中：" class="headerlink" title="使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中："></a>使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中：</h6><ul>
<li>创建目录菜单</li>
<li>添加数据字典</li>
<li>配置代码生成信息</li>
<li>下载代码并导入项目</li>
</ul>
<blockquote>
<p>系统管理 → 菜单管理 → 新增菜单<br>→ <u>主类目、点位管理、2、node</u></p>
<p>→ 系统管理 → 字典管理<br>→ <u>字典名称：商圈类型</u><br>     <u>字典类型：business_type</u><br>→ 在第二页找到商圈类型点进去<br>→ <u>新增：旅游区</u><br>     &lt;u<u>&gt;数据标签：旅游区</u><br>     <u>数据键值：1</u><br>     <u>显示排序：1</u><br>→ 新增：商场写字楼、2、2；学校33、交通枢纽44</p>
<p>→ 系统工具 → 代码生成 → 导入表(<u>tb_node、tb_partner、tb_region</u>)<br>分别配置表的生成信息<br>→ 点击<u><strong>区域表</strong></u> → <u>字段信息</u><br>→ 根据新增区域弹出菜单显示 需要增加<u>区域名称全打勾 备注说明除了查询全打勾 其余全×</u></p>
<p>→ 点击**<u>合作商表</u>** → 生成信息<br>→ <u>包路径：com.dkd.manage、生成模块名：manage、生成业务名：region、生成功能名：区域管理、上级菜单：点位管理</u><br>→ 代码生成：Partner<br>→  基本信息：<br><u>实体类名称：Partner</u><br><u>作者：itheima</u><br>→ 字段信息：见**<u>帝可得后台管理系统.md</u>**<br>→ 生成信息：<br><u>生成包路径：com.dkd.manage</u><br><u>生成模块名：manage</u><br><u>生成功能名：合作商管理</u><br><u>上级菜单：点位管理</u></p>
<p>→ 点击**<u>点位表</u>**<br>→ 生成信息：<br><u>生成包路径：com.dkd.manage</u><br><u>生成模块名：manage</u><br><u>生成功能名：点位管理</u><br><u>上级菜单：点位管理</u><br>→ 字段信息：见**<u>帝可得后台管理系统.md</u>**<br>→ 基本信息：<br><u>实体类名称：Node</u><br><u>表描述：点位表</u><br><u>作者：itheima</u></p>
<p>回到代码生成 选中三张表 生成！！<br>分别在前后端和数据库 导入java&#x2F;manage、vue&#x2F;manage、sql代码</p>
</blockquote>
<blockquote>
<p><strong>细节</strong>：如果当你创建一个模块以后 src.main.java里面没有任何代码 resources里面也没有 它提交仓库的时候是默认空的 所以可以手动添加一个占位符<code>.gitkeep</code>虽然什么都不是，但是可以提交空项目模块</p>
</blockquote>
<h3 id="区域管理改造"><a href="#区域管理改造" class="headerlink" title="区域管理改造"></a>区域管理改造</h3><h4 id="基础页面"><a href="#基础页面" class="headerlink" title="基础页面"></a>基础页面</h4><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul>
<li>参考页面原型，完成基础布局展示改造</li>
</ul>
<pre><code class="html">// 让前端页面自动排序
src\views\manage\region\index.vue
&lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
</code></pre>
<h5 id="区域管理改造-1"><a href="#区域管理改造-1" class="headerlink" title="区域管理改造"></a>区域管理改造</h5><ul>
<li><p>查看详情，需要显示所有区域下所有点位列表(<strong>稍后完成</strong>)</p>
</li>
<li><p><strong>在查询区域列表时，同时显示每个区域的点位数，还要新增查看详情</strong></p>
<p><span style="color:red; font-family: 'KaiTi';"><strong>修改<u>后端</u>要参考<u>接口文档</u>，修改<u>前端</u>要参考<u>产品原型</u></strong></span></p>
</li>
<li><p>实现此功能方案：</p>
<p>(1) <strong>同步存储</strong>在区域表中有点位数的字段，当点位发生变化时候，同步区域表中的点位数(<u>在tb_region里面新增一个<code>node_count</code></u> 方案可行考虑缺点：每次点位数据变化时都要更新区域表[增加了工作量]，添加数据不一致也会)<br>(2) <span style="color:red"><strong>关联查询</strong></span>编写关联查询语句，在mapper层封装</p>
</li>
</ul>
<p>SQL查询：先聚合统计每个区域的点位数，然后与区域表进行关联查询<br>[提前在idea中下面的通义灵码状态勾选 <code>本地补全模型</code>、<code>云端模型自动触发</code>]<br><span style="color:red; font-family: 'KaiTi';"><strong>数据库返回的数据 要结合前端所需要的返回数据来写</strong> </span><br><span style="color:blue; font-family: 'KaiTi';"><strong>比如接口文档需要返回remark id name nodeCount</strong> &#x3D;&#x3D;&gt; select r.id,r.region_name,r.remark,ifnull(n.node_count,0) as node_count</span></p>
<pre><code class="sql">-- 传统模式
-- 1.先聚合统计每个区域下的点位数
-- 确定查询表 tb_node
-- 确定分组字段 region_id
select region_id,count(*) as node_count from tb_node group by region_id;
-- 2.然后与区域表进行关联查询   内连接是两个表的交集
select r.id,r.region_name,r.remark,ifnull(n.node_count,0) as node_count 
   from tb_region r
left join (select region_id,count(*) as node_count 
   from tb_node group by region_id) n 
on r.id=n.region_id;

-- AI辅助编程模式
-- 查询区域表所有的信息,需要显示每个区域的点位数
SELECT r.*, COUNT(n.id) AS node_count FROM tb_region r LEFT JOIN tb_node n ON r.id = n.region_id GROUP BY r.id;
</code></pre>
<pre><code class="java">com/dkd/manage/domain/Region.java
package com.dkd.manage.domain;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import com.dkd.common.annotation.Excel;
import com.dkd.common.core.domain.BaseEntity;

/**
 * 区域管理对象 tb_region
 * 
 * @author itheima
 * @date 2024-11-12
 */
public class Region extends BaseEntity
&#123;
    private static final long serialVersionUID = 1L;

    /** 主键id */
    private Long id;

    /** 区域名称 */
    @Excel(name = &quot;区域名称&quot;)
    private String regionName;

    public void setId(Long id) 
    &#123;
        this.id = id;
    &#125;

    public Long getId() 
    &#123;
        return id;
    &#125;
    public void setRegionName(String regionName) 
    &#123;
        this.regionName = regionName;
    &#125;

    public String getRegionName() 
    &#123;
        return regionName;
    &#125;

    @Override
    public String toString() &#123;
        return new ToStringBuilder(this,ToStringStyle.MULTI_LINE_STYLE)
            .append(&quot;id&quot;, getId())
            .append(&quot;regionName&quot;, getRegionName())
            .append(&quot;createTime&quot;, getCreateTime())
            .append(&quot;updateTime&quot;, getUpdateTime())
            .append(&quot;createBy&quot;, getCreateBy())
            .append(&quot;updateBy&quot;, getUpdateBy())
            .append(&quot;remark&quot;, getRemark())
            .toString();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/domain/vo/RegionVo.java
package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Region;
import lombok.Data;

@Data
public class RegionVo extends Region &#123;
    // 点位数量
    private Integer nodeCount;

&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/RegionMapper.java
/**
     * 查询区域列表
     * @param regionVo
     * @return
     */
    public List&lt;RegionVo&gt; selectRegionVoList(RegionVo regionVo);
</code></pre>
<pre><code class="xml">mapper/manage/RegionMapper.xml    
&lt;select id=&quot;selectRegionVoList&quot; resultType=&quot;com.dkd.manage.domain.vo.RegionVo&quot;&gt;
        SELECT r.*, COUNT(n.id) AS node_count FROM tb_region r LEFT JOIN tb_node n ON r.id = n.region_id GROUP BY r.id
    &lt;/select&gt;
</code></pre>
<h6 id="思考：上面的xml中提取的字段是-node-count-而前端让返回的是驼峰式命名-nodeCount-若依默认关闭了此功能需要手动开启此功能"><a href="#思考：上面的xml中提取的字段是-node-count-而前端让返回的是驼峰式命名-nodeCount-若依默认关闭了此功能需要手动开启此功能" class="headerlink" title="思考：上面的xml中提取的字段是 node_count 而前端让返回的是驼峰式命名 nodeCount,  若依默认关闭了此功能需要手动开启此功能"></a>思考：上面的xml中提取的字段是 <u>node_count</u> 而前端让返回的是驼峰式命名 <u>nodeCount</u>,  若依默认关闭了此功能需要手动开启此功能</h6><pre><code class="xml">dkd-parent → resources → mybatis → mybatis-config.xml
&lt;!-- 使用驼峰命名法转换字段 --&gt;
&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
</code></pre>
<h6 id="Ctrl-F9是热部署-在不新增文件的时候可以直接部署"><a href="#Ctrl-F9是热部署-在不新增文件的时候可以直接部署" class="headerlink" title="Ctrl+F9是热部署 在不新增文件的时候可以直接部署"></a>Ctrl+F9是热部署 在不新增文件的时候可以直接部署</h6><h4 id="RegionMapper"><a href="#RegionMapper" class="headerlink" title="RegionMapper"></a>RegionMapper</h4><pre><code class="java">/**
 * 查询区域管理列表
 * @param region
 * @return RegionVo集合
 */
public List&lt;RegionVo&gt; selectRegionVoList(Region region);
</code></pre>
<h4 id="RegionMapper-xml"><a href="#RegionMapper-xml" class="headerlink" title="RegionMapper.xml"></a>RegionMapper.xml</h4><pre><code class="xml">&lt;select id=&quot;selectRegionVoList&quot; resultType=&quot;com.dkd.manage.domain.vo.RegionVo&quot;&gt;
select r.id,r.region_name,r.remark,ifnull(n.node_count,0) as node_count from tb_region r
    left join (select region_id,count(*) as node_count from tb_node group by region_id) n on r.id=n.region_id
    &lt;where&gt;
       &lt;if test=&quot;regionName != null  and regionName != &#39;&#39;&quot;&gt; and r.region_name like concat(&#39;%&#39;, #&#123;regionName&#125;, &#39;%&#39;)&lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt; 
</code></pre>
<h4 id="IRegionService"><a href="#IRegionService" class="headerlink" title="IRegionService"></a>IRegionService</h4><pre><code class="java">/**
 * 查询区域管理列表
 * @param region
 * @return RegionVo集合
 */
public List&lt;RegionVo&gt; selectRegionVoList(Region region);
</code></pre>
<h4 id="RegionServiceImpl"><a href="#RegionServiceImpl" class="headerlink" title="RegionServiceImpl"></a>RegionServiceImpl</h4><pre><code class="java">/**
 * 查询区域管理列表
 * @param region
 * @return RegionVo集合
 */
@Override
public List&lt;RegionVo&gt; selectRegionVoList(Region region) &#123;
    return regionMapper.selectRegionVoList(region);
&#125;
</code></pre>
<h4 id="RegionController"><a href="#RegionController" class="headerlink" title="RegionController"></a>RegionController</h4><pre><code class="java">/**
 * 查询区域管理列表
 */
@PreAuthorize(&quot;@ss.hasPermi(&#39;manage:region:list&#39;)&quot;)
@GetMapping(&quot;/list&quot;)
public TableDataInfo list(Region region)
&#123;
    startPage();
    List&lt;RegionVo&gt; voList = regionService.selectRegionVoList(region);
    return getDataTable(voList);
&#125;
</code></pre>
<h4 id="region-x2F-index-vue"><a href="#region-x2F-index-vue" class="headerlink" title="region&#x2F;index.vue"></a>region&#x2F;index.vue</h4><pre><code class="vue">&lt;!-- 区域列表 --&gt;
&lt;el-table v-loading=&quot;loading&quot; :data=&quot;regionList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;
  &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
  &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
  &lt;el-table-column label=&quot;区域名称&quot; align=&quot;center&quot; prop=&quot;regionName&quot; /&gt;
  &lt;el-table-column label=&quot;点位数&quot; align=&quot;center&quot; prop=&quot;nodeCount&quot; /&gt;
  &lt;el-table-column label=&quot;备注说明&quot; align=&quot;center&quot; prop=&quot;remark&quot; /&gt;
  &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
      &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
      &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
    &lt;/template&gt;
  &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><strong>区域列表改造步骤</strong><ul>
<li>确定关联查询方案并编写sql</li>
<li>创建RegionVo</li>
<li>在RegionMapper和xml中添加查询Vo方法和sql</li>
<li>在RegionService接口和实现类中添加查询Vo方法</li>
<li>修改RegionController查询方法</li>
<li>修改前端视图组件</li>
</ul>
</li>
</ul>
<h3 id="合作商改造-查看详情"><a href="#合作商改造-查看详情" class="headerlink" title="合作商改造-查看详情"></a>合作商改造-查看详情</h3><h5 id="密码是明文-改成密文"><a href="#密码是明文-改成密文" class="headerlink" title="密码是明文 改成密文"></a>密码是明文 改成密文</h5><pre><code class="html">&lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;
   &lt;el-input v-model=&quot;form.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;
&lt;/el-form-item&gt;
</code></pre>
<h5 id="隐藏修改时的账号密码id存在时隐藏不存在显示-因为修改和新增共用了一个对话框ui"><a href="#隐藏修改时的账号密码id存在时隐藏不存在显示-因为修改和新增共用了一个对话框ui" class="headerlink" title="隐藏修改时的账号密码id存在时隐藏不存在显示,因为修改和新增共用了一个对话框ui"></a>隐藏修改时的账号密码<del>id存在时隐藏不存在显示,因为修改和新增共用了一个对话框ui</del></h5><pre><code class="html">&lt;el-form-item label=&quot;账号&quot; prop=&quot;account&quot; v-if=&quot;form.id==null&quot;&gt;
    &lt;el-input v-model=&quot;form.account&quot; placeholder=&quot;请输入账号&quot; /&gt;
&lt;/el-form-item&gt;
&lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot; v-if=&quot;form.id==null&quot;&gt;
    &lt;el-input v-model=&quot;form.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;
&lt;/el-form-item&gt;
</code></pre>
<h5 id="前端需要返回创建时间因为数据返回时有，用v-if判断是否修改显示创建时间"><a href="#前端需要返回创建时间因为数据返回时有，用v-if判断是否修改显示创建时间" class="headerlink" title="前端需要返回创建时间因为数据返回时有，用v-if判断是否修改显示创建时间"></a>前端需要返回创建时间<del>因为数据返回时有，用v-if判断是否修改显示创建时间</del></h5><pre><code class="html"> &lt;el-form-item label=&quot;创建时间&quot; prop=&quot;contactPhone&quot; v-if=&quot;form.id!=null&quot;&gt;
          &#123;&#123;form.createTime&#125;&#125;
        &lt;/el-form-item&gt;
</code></pre>
<h5 id="新增时保存的数据是以明文保存到了数据库此时新增的合作商就是密文了"><a href="#新增时保存的数据是以明文保存到了数据库此时新增的合作商就是密文了" class="headerlink" title="新增时保存的数据是以明文保存到了数据库此时新增的合作商就是密文了"></a>新增时保存的数据是以明文保存到了数据库<del>此时新增的合作商就是密文了</del></h5><pre><code class="java">com/dkd/manage/service/impl/PartnerServiceImpl.java  
/**
     * 新增合作商管理
     *
     * @param partner 合作商管理
     * @return 结果
     */
    @Override
    public int insertPartner(Partner partner) &#123;
        // 使用SpringSecurity工具类，对前端传入的密码进行加密
        partner.setPassword(SecurityUtils.encryptPassword(partner.getPassword()));
        partner.setCreateTime(DateUtils.getNowDate());
        return partnerMapper.insertPartner(partner);
    &#125;
</code></pre>
<h5 id="合作商管理改造—合作商详情"><a href="#合作商管理改造—合作商详情" class="headerlink" title="合作商管理改造—合作商详情"></a>合作商管理改造—合作商详情</h5><ul>
<li>查看详情，需要显示合作商名称、联系人、联系电话、分成比例</li>
<li>在查询合作商列表时，同时显示每个合作商的点位数</li>
<li>重置密码，初始密码为123456</li>
</ul>
<pre><code class="js">/** 借鉴修改流程
/** 修改按钮操作 */
function handleUpdate(row) &#123;
  reset();
  const _id = row.id || ids.value
  getPartner(_id).then(response =&gt; &#123;
    form.value = response.data;
    open.value = true;
    title.value = &quot;修改合作商管理&quot;;
  &#125;);
&#125;
</code></pre>
<pre><code class="html">&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
  &lt;template #default=&quot;scope&quot;&gt;
    &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;getPartnerInfo(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:partner:query&#39;]&quot;&gt;查看详情&lt;/el-button&gt;
  &lt;/template&gt;
&lt;/el-table-column&gt;
</code></pre>
<pre><code class="java">com/dkd/manage/controller/PartnerController.java
    /**
     * 获取合作商管理详细信息
     */
    @PreAuthorize(&quot;@ss.hasPermi(&#39;manage:partner:query&#39;)&quot;)
    @GetMapping(value = &quot;/&#123;id&#125;&quot;)
    public AjaxResult getInfo(@PathVariable(&quot;id&quot;) Long id)
    &#123;
        return success(partnerService.selectPartnerById(id));
    &#125;
</code></pre>
<pre><code class="js">/** 查看合作商详情 **/
  const partnerInfoOpen = ref(false)
  function getPartnerInfo(row)&#123;
    reset();
    const _id = row.id
    getPartner(_id).then(response =&gt; &#123;
      form.value = response.data;
      partnerInfoOpen.value = true;
    &#125;);
  &#125;
</code></pre>
<pre><code class="html">    &lt;!-- 查看合作商详情对话框 --&gt;
&lt;el-dialog title=&quot;合作商详情&quot; v-model=&quot;partnerInfoOpen&quot; width=&quot;500px&quot; append-to-body&gt;
    &lt;!-- 使用el-descriptions组件以卡片形式展示信息，更加整洁 --&gt;
    &lt;el-descriptions :column=&quot;2&quot; border&gt;
        &lt;el-descriptions-item label=&quot;合作商名称&quot;&gt;&#123;&#123; form.partnerName &#125;&#125;&lt;/el-descriptions-item&gt;
        &lt;el-descriptions-item label=&quot;联系人&quot;&gt;&#123;&#123; form.contactPerson &#125;&#125;&lt;/el-descriptions-item&gt;
        &lt;el-descriptions-item label=&quot;联系电话&quot;&gt;&#123;&#123; form.contactPhone &#125;&#125;&lt;/el-descriptions-item&gt;
        &lt;el-descriptions-item label=&quot;分成比例&quot;&gt;&#123;&#123; form.profitRatio &#125;&#125;%&lt;/el-descriptions-item&gt;
    &lt;/el-descriptions&gt;
&lt;/el-dialog&gt;
</code></pre>
<h3 id="合作商改造—列表查询点位管理→合作商管理→增加点位数"><a href="#合作商改造—列表查询点位管理→合作商管理→增加点位数" class="headerlink" title="合作商改造—列表查询点位管理→合作商管理→增加点位数"></a>合作商改造—列表查询<del>点位管理→合作商管理→增加点位数</del></h3><ul>
<li>实现此功能方案：</li>
</ul>
<h4 id="后端改造"><a href="#后端改造" class="headerlink" title="后端改造"></a>后端改造</h4><p><strong>关联查询</strong>编写关联查询语句，在mapper层封装</p>
<blockquote>
<p><strong>tb_node</strong>(点位表)的partner_id(合作商ID)<br><u>关联</u><br><strong>tb_partner</strong>(合作商表)的id</p>
<pre><code class="sql">-- 查询合作商表的所有信息，同时显示每个合作商的点位数
select p.*, count(n.id) as node_count
from tb_partner p
    left join tb_node n on p.id = n.partner_id
group by p.id
</code></pre>
</blockquote>
<p><strong>首先先创建一个需要查询新东西的方法<del>增加</del></strong></p>
<pre><code class="java">com/dkd/manage/domain/vo/PartnerVo.java
package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Partner;
import lombok.Data;

@Data
public class PartnerVo extends Partner &#123;
    // 点位数量
    private Integer nodeCount;
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/controller/PartnerController.java
 /**
     * 查询合作商管理列表
     */
    @PreAuthorize(&quot;@ss.hasPermi(&#39;manage:partner:list&#39;)&quot;)
    @GetMapping(&quot;/list&quot;)
    public TableDataInfo list(Partner partner) &#123;
        startPage();
        List&lt;PartnerVo&gt; voList = partnerService.selectPartnerVoList(partner);
        return getDataTable(voList);
    &#125;
</code></pre>
<pre><code class="java">com/dkd/manage/service/IPartnerService.java
/**
     * 查询合作商列表
     * @param partner
     * @return
     */
    public List&lt;PartnerVo&gt; selectPartnerVoList(Partner partner);
</code></pre>
<pre><code class="java">com/dkd/manage/service/impl/PartnerServiceImpl.java
/**
     * 查询合作商列表
     * @param partner
     * @return
     */
    @Override
    public List&lt;PartnerVo&gt; selectPartnerVoList(Partner partner) &#123;
        return partnerMapper.selectPartnerVoList(partner);
    &#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/PartnerMapper.java
/**
     * 查询合作商列表
     * @param partner
     * @return
     */
    public List&lt;PartnerVo&gt; selectPartnerVoList(Partner partner);
</code></pre>
<pre><code class="java">mapper/manage/PartnerMapper.xml
&lt;/select&gt;
        &lt;select id=&quot;selectPartnerVoList&quot; resultType=&quot;com.dkd.manage.domain.vo.PartnerVo&quot;&gt;
        select p.*, count(n.id) as node_count
        from tb_partner p
                 left join tb_node n on p.id = n.partner_id
        &lt;where&gt;
            &lt;if test=&quot;partnerName != null  and partnerName != &#39;&#39;&quot;&gt; and partner_name like concat(&#39;%&#39;, #&#123;partnerName&#125;, &#39;%&#39;)&lt;/if&gt;
        &lt;/where&gt;
        group by p.id
    &lt;/select&gt;
</code></pre>
<h4 id="前端改造"><a href="#前端改造" class="headerlink" title="前端改造"></a>前端改造</h4><pre><code class="html">&lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
      &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
      &lt;el-table-column label=&quot;合作商名称&quot; align=&quot;center&quot; prop=&quot;partnerName&quot; /&gt;
      &lt;el-table-column label=&quot;点位数&quot; align=&quot;center&quot; prop=&quot;nodeCount&quot; /&gt;
      &lt;el-table-column label=&quot;账号&quot; align=&quot;center&quot; prop=&quot;account&quot; /&gt;
      &lt;el-table-column label=&quot;分成比例&quot; align=&quot;center&quot; prop=&quot;profitRatio&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &#123;&#123; scope.row.profitRatio + '%' &#125;&#125;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;联系人&quot; align=&quot;center&quot; prop=&quot;contactPerson&quot; /&gt;
      &lt;el-table-column label=&quot;联系电话&quot; align=&quot;center&quot; prop=&quot;contactPhone&quot; /&gt;
      &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
</code></pre>
<h3 id="合作商改造——重置密码"><a href="#合作商改造——重置密码" class="headerlink" title="合作商改造——重置密码"></a>合作商改造——重置密码</h3><ul>
<li>查看详情，需要显示合作商名称、联系人、联系电话、分成比例</li>
<li>在查询合作商列表时，同时显示每个合作商的点位数</li>
<li>重置密码，初始密码为123456</li>
</ul>
<h4 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h4><p>在PartnerController中</p>
<pre><code class="java">/**
 * 重置合作商密码
 */
@PreAuthorize(&quot;@ss.hasPermi(&#39;manage:partner:edit&#39;)&quot;)
@Log(title = &quot;重置合作商密码&quot;, businessType = BusinessType.UPDATE)
@PutMapping(&quot;/resetPwd/&#123;id&#125;&quot;)
public AjaxResult resetpwd(@PathVariable Long id) &#123;//1. 接收参数
    //2. 创建合作商对象
    Partner partner = new Partner();
    partner.setId(id);// 设置id
    partner.setPassword(SecurityUtils.encryptPassword(&quot;123456&quot;));// 设置加密后的初始密码
    //3. 调用service更新密码
    return toAjax(partnerService.updatePartner(partner));
&#125;
</code></pre>
<h4 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h4><p>在<code>manage/partner.js</code>请求api中</p>
<pre><code class="js">// 重置合作商密码
export function resetPartnerPwd(id)&#123;
  return request(&#123;
    url: &#39;/manage/partner/resetPwd/&#39; + id,
    method: &#39;put&#39;
  &#125;)
&#125;
</code></pre>
<p>在<code>partner/index.vue</code>视图组件中<del>参考@click&#x3D;”handleDelete”，此方法删除时弹出对话框</del></p>
<pre><code class="vue">&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot; width=&quot;300px&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
        &lt;el-button link type=&quot;primary&quot; @click=&quot;resetPwd(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:partner:edit&#39;]&quot;&gt;重置密码&lt;/el-button&gt;
    &lt;/template&gt;
&lt;/el-table-column&gt;

&lt;script&gt;
    import &#123; listPartner, getPartner, delPartner, addPartner, updatePartner,resetPartnerPwd &#125; from &quot;@/api/manage/partner&quot;;
    /* 重置合作商密码 */
    function resetPwd(row) &#123;
        proxy.$modal.confirm(&#39;你确定要重置该合作商密码吗？&#39;).then(function () &#123;
            return resetPartnerPwd(row.id);
        &#125;).then(() =&gt; &#123;
            proxy.$modal.msgSuccess(&quot;重置成功&quot;);
        &#125;).catch(() =&gt; &#123; &#125;);
    &#125;
&lt;/script&gt;
</code></pre>
<h3 id="点位管理改造——基础布局"><a href="#点位管理改造——基础布局" class="headerlink" title="点位管理改造——基础布局"></a>点位管理改造——基础布局</h3><p>修改前端更简单一些 可以把前端一次性请求1w条数据 后端接口就可以重复调用</p>
<p>在<code>src\views\manage\node\index.vue</code>视图组件中</p>
<pre><code class="js">import &#123;listRegion&#125; from &quot;@/api/manage/region&quot;;

/* 查询所有条件对象 */
const loadAllParams=reactive(&#123;
  pageNum:1,
  pageSize:10000
&#125;)
/** 查询区域列表 **/
const regionList=ref([]);
function getRegionList() &#123;
  listRegion(loadAllParams).then(response=&gt;&#123;
    regionList.value=response.rows;
  &#125;)
&#125;
getRegionList();
getList();
</code></pre>
<p>在<code>src\api\manage\region.js</code>中</p>
<pre><code class="js">// 查询区域管理列表
export function listRegion(query) &#123;
  return request(&#123;
    url: &#39;/manage/region/list&#39;,
    method: &#39;get&#39;,
    params: query
  &#125;)
&#125;
</code></pre>
<h6 id="新增点位管理的时候想把合作商输入的改成自动获取的下拉框"><a href="#新增点位管理的时候想把合作商输入的改成自动获取的下拉框" class="headerlink" title="新增点位管理的时候想把合作商输入的改成自动获取的下拉框"></a>新增点位管理的时候想把合作商输入的改成自动获取的下拉框</h6><ul>
<li>定义js代码向后台发送请求，将请求后的结果封装给合作商parnterList集合</li>
<li>将文本框改成下拉框来遍历展示每个合作商的名称，提交时关联合作商的id</li>
</ul>
<pre><code class="js">      &lt;el-table-column label=&quot;详细地址&quot; align=&quot;center&quot; prop=&quot;address&quot; show-overflow-tooltip/&gt; 详细地址多出的部分隐藏只有鼠标移动到才会显示


import &#123;listPartner&#125; from &quot;@/api/manage/partner&quot;

&lt;el-form-item label=&quot;合作商ID&quot; prop=&quot;partnerId&quot;&gt;
          &lt;!-- &lt;el-input v-model=&quot;form.partnerId&quot; placeholder=&quot;请输入合作商ID&quot; /&gt; --&gt;
           &lt;el-select v-model=&quot;form.partnerId&quot; placeholder=&quot;请选择合作商&quot;&gt;
            &lt;el-option
              v-for=&quot;item in partnerList&quot;
              :key=&quot;item.id&quot;
              :label=&quot;item.partnerName&quot;
              :value=&quot;item.id&quot;&gt;
            &lt;/el-option&gt;
           &lt;/el-select&gt;
&lt;/el-form-item&gt;

/* 查询合作商列表 */
const partnerList=ref([]);
function getPartnerList()&#123;
  listPartner(loadAllParams).then(response=&gt;&#123;
    partnerList.value = response.rows;
  &#125;)
&#125;
getPartnerList();
</code></pre>
<h6 id="避免每次都要写pageSize：10000-直接搞入js里面"><a href="#避免每次都要写pageSize：10000-直接搞入js里面" class="headerlink" title="避免每次都要写pageSize：10000 直接搞入js里面"></a>避免每次都要写pageSize：10000 直接搞入js里面</h6><pre><code class="java">src\api\page.js
/* 查询所有条件对象 */
// const loadAllParams=reactive(&#123;
//   pageNum:1,
//   pageSize:10000
// &#125;) →

export const loadAllParams = reactive(&#123;
  pageNum: 1,
  pageSize: 10000,
&#125;);
</code></pre>
<h3 id="点位管理改造点位中增加个查看详情-将单表查询改为多表查询咯"><a href="#点位管理改造点位中增加个查看详情-将单表查询改为多表查询咯" class="headerlink" title="点位管理改造点位中增加个查看详情(将单表查询改为多表查询咯)"></a>点位管理改造<del>点位中增加个查看详情(将单表查询改为多表查询咯)</del></h3><ul>
<li>查看详情，需要显示当前点位下所有设备列表(稍后完成)</li>
<li>在区域详情中，需要显示每个点位的设备数</li>
<li>在点位列表查询中，关联显示区域、合作商等信息</li>
<li><strong>关联查询：</strong><u>对于设备数量的统计，我们需要执行关联查询，在mapper层封装</u></li>
<li><strong>关联实体</strong>：<u>对于区域和合作商的数据，我们会采用Mybatis提供的嵌套查询功能</u></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/601b425cc8b355cd33badf92ed988dbdabef1b9d/%E7%82%B9%E4%BD%8D%E7%AE%A1%E7%90%86%E6%94%B9%E9%80%A0%E8%A1%A8%E8%AE%BE%E8%AE%A1.png" alt="点位管理改造表设计.png"></p>
<pre><code class="mysql">&lt;resultMap&gt;......&lt;/resultMap&gt;   #完成手动映射

#解决一对一 或 多对一 映射结果集只有一个对象时完成的ORM的映射封装
&lt;association&gt;......&lt;/association&gt;  #点位和点位1对1  点位和合作商1对多

#解决一对多场景下来映射多个结果的集合 单个区域表+区域点位列表 映射的是集合！！
&lt;collection&gt;......&lt;/collection&gt; 
</code></pre>
<pre><code class="mysql"># AI辅助编程模式
-- AI辅助编程模式
-- 你是一个软件开发工程师，现在要根据数据库的sql脚本，查询并显示点位表所有的字段信息,同时显示每个点位的设备数量，sql脚本如下：
create table tb_node
(
    id            int auto_increment comment &#39;主键id&#39;
        primary key,
    node_name     varchar(255)                        not null comment &#39;点位名称&#39;,
    address       varchar(255)                        not null comment &#39;详细地址&#39;,
    business_type int                                 null comment &#39;商圈类型&#39;,
    region_id     int                                 null comment &#39;区域ID&#39;,
    partner_id    int                                 null comment &#39;合作商ID&#39;,
    create_time   timestamp default CURRENT_TIMESTAMP null comment &#39;创建时间&#39;,
    update_time   timestamp default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment &#39;修改时间&#39;,
    create_by     varchar(64)                         null comment &#39;创建人&#39;,
    update_by     varchar(64)                         null comment &#39;修改人&#39;,
    remark        text                                null comment &#39;备注&#39;,
    constraint tb_node_ibfk_1
        foreign key (region_id) references tb_region (id)
            on update cascade on delete cascade,
    constraint tb_node_ibfk_2
        foreign key (partner_id) references tb_partner (id)
            on update cascade on delete cascade
)
    comment &#39;点位表&#39;;
    
create table tb_vending_machine
(
    id                   bigint auto_increment comment &#39;主键&#39;
        primary key,
    inner_code           varchar(15) default &#39;000&#39;                 null comment &#39;设备编号&#39;,
    channel_max_capacity int                                       null comment &#39;设备容量&#39;,
    node_id              int                                       not null comment &#39;点位Id&#39;,
    addr                 varchar(100)                              null comment &#39;详细地址&#39;,
    last_supply_time     datetime    default &#39;2000-01-01 00:00:00&#39; not null comment &#39;上次补货时间&#39;,
    business_type        int                                       not null comment &#39;商圈类型&#39;,
    region_id            int                                       not null comment &#39;区域Id&#39;,
    partner_id           int                                       not null comment &#39;合作商Id&#39;,
    vm_type_id           int         default 0                     not null comment &#39;设备型号&#39;,
    vm_status            int         default 0                     not null comment &#39;设备状态，0:未投放;1-运营;3-撤机&#39;,
    running_status       varchar(100)                              null comment &#39;运行状态&#39;,
    longitudes           double      default 0                     null comment &#39;经度&#39;,
    latitude             double      default 0                     null comment &#39;维度&#39;,
    client_id            varchar(50)                               null comment &#39;客户端连接Id,做emq认证用&#39;,
    policy_id            bigint                                    null comment &#39;策略id&#39;,
    create_time          timestamp   default CURRENT_TIMESTAMP     not null comment &#39;创建时间&#39;,
    update_time          timestamp   default CURRENT_TIMESTAMP     null comment &#39;修改时间&#39;,
    constraint vendingmachine_VmId_uindex
        unique (inner_code),
    constraint tb_vending_machine_ibfk_1
        foreign key (vm_type_id) references tb_vm_type (id),
    constraint tb_vending_machine_ibfk_2
        foreign key (node_id) references tb_node (id),
    constraint tb_vending_machine_ibfk_3
        foreign key (policy_id) references tb_policy (policy_id)
)
    comment &#39;设备表&#39;;
</code></pre>
<pre><code class="sql">-- 查询并显示点位表所有的字段信息,同时显示每个点位的设备数量
SELECT
    n.id,
    n.node_name,
    n.address,
    n.business_type,
    n.region_id,
    n.partner_id,
    n.create_time,
    n.update_time,
    n.create_by,
    n.update_by,
    n.remark,
    COUNT(v.id) AS vm_count
FROM
    tb_node n
LEFT JOIN
    tb_vending_machine v ON n.id = v.node_id
GROUP BY
    n.id;
</code></pre>
<pre><code class="java">package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Node;
import com.dkd.manage.domain.Partner;
import com.dkd.manage.domain.Region;
import lombok.Data;

@Data
public class NodeVo extends Node &#123;
    // 设备数量
    private Integer vmCount;
    // 区域信息
    private Region region;
    // 合作商信息
    private Partner partner;
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/NodeMapper.java
/**
     *  查询点位管理列表
     * @param node
     * @return
     */
    public List&lt;NodeVo&gt; selectNodeVoList(Node node);
</code></pre>
<pre><code class="xml">&lt;!--
resultType=&quot;com.dkd.manage.domin.vo.NodeVo&quot;&gt;...
这个是mybatis以前搞的自动映射封装直接把结果映射给了NodeVo的实体类了
嵌套查询就不能使用resultType自动映射 要改为resultMap做自动映射
&lt;resultMap type=&quot;NodeVo&quot; id=&quot;NodeVoResult&quot;&gt;
多表查询一定要起别名噢 不然会报错没有指明where的子句是来自tb_node表的region_id  还是来自tb_vending_machine表的region_id
--&gt;

&lt;select id=&quot;selectNodeVoList&quot; parameterType=&quot;Node&quot; resultMap=&quot;NodeVoResult&quot;&gt;
        SELECT
        n.id,
        n.node_name,
        n.address,
        n.business_type,
        n.region_id,
        n.partner_id,
        n.create_time,
        n.update_time,
        n.create_by,
        n.update_by,
        n.remark,
        COUNT(v.id) AS vm_count
        FROM
        tb_node n
        LEFT JOIN
        tb_vending_machine v ON n.id = v.node_id
        &lt;where&gt;
            &lt;if test=&quot;nodeName != null  and nodeName != &#39;&#39;&quot;&gt; and n.node_name like concat(&#39;%&#39;, #&#123;nodeName&#125;, &#39;%&#39;)&lt;/if&gt;
            &lt;if test=&quot;regionId != null &quot;&gt; and n.region_id = #&#123;regionId&#125;&lt;/if&gt;
            &lt;if test=&quot;partnerId != null &quot;&gt; and n.partner_id = #&#123;partnerId&#125;&lt;/if&gt;
        &lt;/where&gt;
        GROUP BY
        n.id
    &lt;/select&gt;
</code></pre>
<pre><code class="xml">多对一标签用association
&lt;resultMap type=&quot;NodeVo&quot; id=&quot;NodeVoResult&quot;&gt;
        &lt;result property=&quot;id&quot;    column=&quot;id&quot;    /&gt;
        &lt;result property=&quot;nodeName&quot;    column=&quot;node_name&quot;    /&gt;
        &lt;result property=&quot;address&quot;    column=&quot;address&quot;    /&gt;
        &lt;result property=&quot;businessType&quot;    column=&quot;business_type&quot;    /&gt;
        &lt;result property=&quot;regionId&quot;    column=&quot;region_id&quot;    /&gt;
        &lt;result property=&quot;partnerId&quot;    column=&quot;partner_id&quot;    /&gt;
        &lt;result property=&quot;createTime&quot;    column=&quot;create_time&quot;    /&gt;
        &lt;result property=&quot;updateTime&quot;    column=&quot;update_time&quot;    /&gt;
        &lt;result property=&quot;createBy&quot;    column=&quot;create_by&quot;    /&gt;
        &lt;result property=&quot;updateBy&quot;    column=&quot;update_by&quot;    /&gt;
        &lt;result property=&quot;remark&quot;    column=&quot;remark&quot;    /&gt;
        &lt;result property=&quot;vmCount&quot;    column=&quot;vm_count&quot;    /&gt;
&lt;!--
sql语法拿到region_id去执行区域当中的selectRegionById 方法执行的时候需要传递区域的id
原理：RegionMapper.java中的 public Region selectRegionById(Long id)把条件拿到手并封装给区域的Region对象 返回的Region对象最终映射给NodeVo.java的 private Region region;
怎么执行的映射呢？需要指定java属性名和执行的类型：
property=&quot;region&quot; 
javaType=&quot;Region&quot;
至此完成了mybatis的嵌套查询
--&gt;
        &lt;association property=&quot;region&quot; javaType=&quot;Region&quot; column=&quot;region_id&quot; select=&quot;com.dkd.manage.mapper.RegionMapper.selectRegionById&quot;/&gt;
        &lt;association property=&quot;partner&quot; javaType=&quot;Partner&quot; column=&quot;partner_id&quot; select=&quot;com.dkd.manage.mapper.PartnerMapper.selectPartnerById&quot;/&gt;
    &lt;/resultMap&gt;
</code></pre>
<pre><code class="java">&lt;resultMap&gt;......&lt;/resultMap&gt;   // 完成手动映射 为了实现多表映射情况组合查询

// 解决一对一 或 多对一 映射结果集只有一个对象时完成的ORM的映射封装
&lt;association&gt;......&lt;/association&gt;  #点位和点位1对1  点位和合作商1对多

// 解决一对多场景下来映射多个结果的集合 单个区域表+区域点位列表 映射的是集合！！
&lt;collection&gt;......&lt;/collection&gt; 


/*
// &lt;association&gt; 标签允许你在查询结果中嵌套另一个对象。
 这样可以方便地在 NodeVo 对象中直接访问 Region 和 Partner 的属性，而不需要额外的查询
 
property：指定 NodeVo 类中的属性名称，该属性将引用关联的对象。
javaType：指定关联对象的 Java 类型。
column：指定用于关联查询的列名，通常是外键。
select：指定一个子查询的方法，用于根据外键查询关联对象
*/
</code></pre>
<h4 id="NodeService"><a href="#NodeService" class="headerlink" title="NodeService"></a>NodeService</h4><pre><code class="java">/**
 * 查询点位管理列表
 * @param node
 * @return NodeVo集合
 */
public List&lt;NodeVo&gt; selectNodeVoList(Node node);
</code></pre>
<h4 id="NodeServiceImpl"><a href="#NodeServiceImpl" class="headerlink" title="NodeServiceImpl"></a>NodeServiceImpl</h4><pre><code class="java">/**
 * 查询点位管理列表
 *
 * @param node
 * @return NodeVo集合
 */
@Override
public List&lt;NodeVo&gt; selectNodeVoList(Node node) &#123;
    return nodeMapper.selectNodeVoList(node);
&#125;
</code></pre>
<h4 id="NodeController"><a href="#NodeController" class="headerlink" title="NodeController"></a>NodeController</h4><pre><code class="java">/**
 * 查询点位管理列表
 */
@PreAuthorize(&quot;@ss.hasPermi(&#39;manage:node:list&#39;)&quot;)
@GetMapping(&quot;/list&quot;)
public TableDataInfo list(Node node)
&#123;
    startPage();
    List&lt;NodeVo&gt; voList = nodeService.selectNodeVoList(node);
    return getDataTable(voList);
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/NodeMapper.java
/**
     *  查询点位管理列表
     * @param node
     * @return
     */
    public List&lt;NodeVo&gt; selectNodeVoList(Node node);
</code></pre>
<h4 id="node-x2F-index-vue"><a href="#node-x2F-index-vue" class="headerlink" title="node&#x2F;index.vue"></a>node&#x2F;index.vue</h4><pre><code class="vue">&lt;!-- 点位列表 --&gt;
&lt;el-table v-loading=&quot;loading&quot; :data=&quot;nodeList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;
  &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
  &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
  &lt;el-table-column label=&quot;点位名称&quot; align=&quot;center&quot; prop=&quot;nodeName&quot; /&gt;
  &lt;el-table-column label=&quot;所在区域&quot; align=&quot;center&quot; prop=&quot;region.regionName&quot; /&gt;
  &lt;el-table-column label=&quot;商圈类型&quot; align=&quot;center&quot; prop=&quot;businessType&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
      &lt;dict-tag :options=&quot;business_type&quot; :value=&quot;scope.row.businessType&quot; /&gt;
    &lt;/template&gt;
  &lt;/el-table-column&gt;
  &lt;el-table-column label=&quot;合作商&quot; align=&quot;center&quot; prop=&quot;partner.partnerName&quot; /&gt;
  &lt;el-table-column label=&quot;详细地址&quot; align=&quot;center&quot; prop=&quot;address&quot; show-overflow-tooltip=&quot;true&quot;/&gt;
  &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
      &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:node:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
      &lt;el-button link type=&quot;primary&quot; icon=&quot;Delete&quot; @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:node:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
    &lt;/template&gt;
  &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre>
<h3 id="区域管理改造-地区详情新增查看详情"><a href="#区域管理改造-地区详情新增查看详情" class="headerlink" title="区域管理改造-地区详情新增查看详情"></a>区域管理改造-地区详情<del>新增查看详情</del></h3><pre><code class="html">src\views\manage\region\index.vue
&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;el-button link type=&quot;primary&quot;  @click=&quot;getRegionInfo(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:list&#39;]&quot;&gt;查看详情&lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;

&lt;!-- 
template 插槽：
#default=&quot;scope&quot;：定义默认插槽，scope 是当前行的数据对象。

@click=&quot;getRegionInfo(scope.row)&quot;：点击按钮时调用 getRegionInfo 函数，并传入当前行的数据。
--&gt;

...
...

/* 查看详情操作按钮 */
function getRegionInfo(row) &#123;
  // 查询区域信息
  reset();
  const _id = row.id
  getRegion(_id).then(response =&gt; &#123;
    form.value = response.data
  &#125;);
&#125;

&lt;!-- 
nodeList 变量：

const nodeList = ref([])：定义一个响应式数组 nodeList，用于存储点位列表。
getRegionInfo 函数：

reset()：调用 reset 函数，可能用于重置表单或其他状态。
const _id = row.id：获取当前行的 id。
getRegion(_id).then(response =&gt; &#123; form.value = response.data &#125;)：调用 getRegion 函数查询区域信息，并将返回的数据赋值给 form.value。
loadAllParams.regionId = row.id：设置 loadAllParams 对象的 regionId 属性为当前行的 id。
listNode(loadAllParams).then(response =&gt; &#123; nodeList.value = response.rows &#125;)：调用 listNode 函数查询点位列表，并将返回的行数据赋值给 nodeList.value。
--&gt;
</code></pre>
<h5 id="区域管理里引入点位的api文件"><a href="#区域管理里引入点位的api文件" class="headerlink" title="区域管理里引入点位的api文件"></a>区域管理里引入点位的api文件</h5><pre><code class="js">import &#123; listNode &#125; from &quot;@/api/manage/node&quot;;
import &#123; loadAllParams &#125; from &quot;@/api/page&quot;;
...
/* 查看详情操作按钮 */
const nodeList = ref([]);
function getRegionInfo(row) &#123;
  // 查询区域信息
  reset();
  const _id = row.id
  getRegion(_id).then(response =&gt; &#123;
    form.value = response.data
  &#125;);
  // 查看点位列表
  loadAllParams.regionId=row_id
  listNode(loadAllParams).then(response =&gt; &#123;
    nodeList.value = response.rows;
  &#125;);
&#125;
</code></pre>
<h6 id="添加区域管理对话框"><a href="#添加区域管理对话框" class="headerlink" title="添加区域管理对话框"></a>添加区域管理对话框</h6><pre><code class="html"> &lt;!-- 添加或修改区域管理对话框 --&gt;
    &lt;el-dialog :title=&quot;title&quot; v-model=&quot;open&quot; width=&quot;500px&quot; append-to-body&gt;
      &lt;el-form ref=&quot;regionRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt;
        &lt;el-form-item label=&quot;区域名称&quot; prop=&quot;regionName&quot;&gt;
          &lt;el-input v-model=&quot;form.regionName&quot; placeholder=&quot;请输入区域名称&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;备注说明&quot; prop=&quot;remark&quot;&gt;
          &lt;el-input v-model=&quot;form.remark&quot; type=&quot;textarea&quot; placeholder=&quot;请输入内容&quot; /&gt;
        &lt;/el-form-item&gt;
      &lt;/el-form&gt;
      &lt;template #footer&gt;
        &lt;div class=&quot;dialog-footer&quot;&gt;
          &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm&quot;&gt;确 定&lt;/el-button&gt;
          &lt;el-button @click=&quot;cancel&quot;&gt;取 消&lt;/el-button&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/el-dialog&gt;
   &lt;!-- 查看详情对话框 --&gt;
&lt;el-dialog title=&quot;区域详情&quot; v-model=&quot;regionInfoOpen&quot; width=&quot;500px&quot; append-to-body&gt;
    &lt;el-form-item label=&quot;区域名称&quot; prop=&quot;regionName&quot;&gt;
        &lt;el-input v-model=&quot;form.regionName&quot; disabled /&gt;
    &lt;/el-form-item&gt;
    &lt;label&gt;包含点位：&lt;/label&gt;
    &lt;el-table :data=&quot;nodeList&quot;&gt;
        &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; /&gt;
        &lt;el-table-column label=&quot;点位名称&quot; align=&quot;center&quot; prop=&quot;nodeName&quot; /&gt;
        &lt;el-table-column label=&quot;设备数量&quot; align=&quot;center&quot; prop=&quot;vmCount&quot; /&gt;
    &lt;/el-table&gt;
&lt;/el-dialog&gt;
</code></pre>
<pre><code class="js">/* 查看详情操作按钮 */
const nodeList = ref([]);
const regionInfoOpen=ref(false);
function getRegionInfo(row) &#123;
  // 查询区域信息
  reset();
  const _id = row.id
  getRegion(_id).then(response =&gt; &#123;
    form.value = response.data
  &#125;);
  // 查看点位列表
  loadAllParams.regionId=row_id
  listNode(loadAllParams).then(response =&gt; &#123;
    nodeList.value = response.rows;
  &#125;);
  regionInfoOpen.value=true;
&#125;
</code></pre>
<h5 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h5><ul>
<li>在删除区域或合作商数据时，关联的点位数据该如何处理？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/05e49c8d5a61f85f41c20ded647d7f32c03ae296/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7_%E5%AD%97%E6%AE%B5%E4%BE%9D%E8%B5%96.png"></p>
<blockquote>
<p>tb_region(区域表)                     tb_node(点位表)                       tb_partner(合作商表)<br>id           ←region_id:id ←        region_id                                                  id<br>                                                    partner_id             partner_id:id →→→↑     </p>
</blockquote>
<p>找到设置外键约束<del>(取消约束)</del><code>dkd → tb_node → Modify Table(old)</code> 找到<code>Foreign Keys</code>  双击打开后将<u>Update rule</u>和<u>Delete rule</u>修改为：<strong>no action</strong></p>
<blockquote>
<p>**CASCADE（级联操作）:**当父表中的某行记录被删除或更新时，与其关联的所有子表中的匹配行也会自动被删除或更新。这种方式适用于希望保持数据一致性的场景，即父记录不存在时，相关的子记录也应该被移除。</p>
<p>**SET NULL（设为空）:**若父表中的记录被删除或更新，子表中对应的外键字段会被设置为NULL。选择此选项的前提是子表的外键列允许为NULL值。这适用于那些子记录不再需要明确关联到任何父记录的情况。</p>
<p>**RESTRICT（限制）:**在尝试删除或更新父表中的记录之前，数据库首先检查是否有相关联的子记录存在。如果有，则拒绝执行删除或更新操作，以防止意外丢失数据或破坏数据关系的完整性。这是一种保守策略，确保数据间的引用完整性。</p>
<p>**NO ACTION（无操作）:**在标准SQL中，NO ACTION是一个关键字，它要求数据库在父表记录被删除或更新前，检查是否会影响子表中的相关记录。在MySQL中，NO ACTION的行为与RESTRICT相同，即如果子表中有匹配的行，则禁止执行父表的删除或更新操作。这意味着如果存在依赖关系，操作将被阻止，从而保护数据的参照完整性。</p>
</blockquote>
<p>修改完毕后，如果你尝试进行删除操作，会发现数据库的完整性约束生效了，它会阻止删除操作并给出错误提示。但是，这个错误提示信息可能对于用户来说不够友好，可能会让用户感到困惑。</p>
<p><code>SQLIntegrityConstraintViolationException</code>是Java中的一个异常类，这个类通常用于表示SQL数据库操作中的完整性约束违反异常</p>
<p>例如：外键约束、唯一约束等。当数据库操作违反了这些约束时，就会抛出这个异常。</p>
<p>这个错误是由于外键约束导致的。它表明在删除或更新父表的行时，存在外键约束，子表中的相关行会受到影响。</p>
<p>是因为在删除tb_region表中的行时，tb_node表中的region_id外键约束会阻止操作。</p>
<p>如果你在使用Spring框架进行数据库操作，可能会先遇到DataIntegrityViolationException，它是对SQLIntegrityConstraintViolationException的一个更高层次的抽象，旨在提供一种更加面向应用的错误表示。</p>
<p>而SQLIntegrityConstraintViolationException是更底层的异常，直接来源于数据库驱动，包含更多底层数据库相关的细节。</p>
<p>在实际开发中，推荐捕获并处理DataIntegrityViolationException，因为它更符合Spring应用的异常处理模式，同时也可以通过其内部的cause（原因）属性来获取具体的SQLIntegrityConstraintViolationException，进而获取详细的错误信息。</p>
<p>为了提升用户体验，我们可以使用Spring Boot框架的全局异常处理器来捕获这些错误信息，并返回更友好的提示信息给用户。这样，当用户遇到这种情况时，他们将收到一个清晰、易懂的提示，告知他们操作无法完成的原因。</p>
<pre><code class="java">com/dkd/framework/web/exception/GlobalExceptionHandler.java
/**
     * 数据完整性异常
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public AjaxResult handleDataIntegrityViolationException(DataIntegrityViolationException e) &#123;
        log.error(e.getMessage(), e);
        if (e.getMessage().contains(&quot;foreign&quot;)) &#123;
            return AjaxResult.error(&quot;无法删除该数据，有其他数据引用&quot;);
        &#125;
        return AjaxResult.error(&quot;数据完整性异常，请联系管理员&quot;);
    &#125;
</code></pre>
<p>16</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/03/后端/若依-AI & 帝可得/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/10/21/后端/SpringBoot趣味实战课/">
        <h2>
            SpringBoot趣味实战课
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/10/21
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="Swagger-Mariadb-Hibernate-实现极简CRUD"><a href="#Swagger-Mariadb-Hibernate-实现极简CRUD" class="headerlink" title="Swagger + Mariadb + Hibernate 实现极简CRUD"></a>Swagger + Mariadb + Hibernate 实现极简CRUD</h3><pre><code class="yaml">application.yaml
spring:
  application:
    name: Pluminary
  datasource:
    driver-class-name: org.mariadb.jdbc.Driver
    url: jdbc:mariadb://localhost:3306/pcy?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;nullCatalogMeansCurrent=true
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MariaDB103Dialect
  springdoc:
    api-docs:
      path: /v3/api-docs
    swagger-ui:
      path: /swagger-ui.html

  server:
    port: 8080
    servlet:
      context-path: /springboot
      session:
        timeout: 60
  debug: true
</code></pre>
<pre><code class="java">com/pcy/Swagger/SwaggerConfig.java
package com.pcy.Swagger;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;) //这里是扫描包
                .build();
    &#125;

    @Bean
    public OpenAPI customOpenAPI() &#123;
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Spring Boot 实战&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Spring Boot 实战的 RESTFul 接口文档说明&quot;)
                        .contact(new Contact()
                                .name(&quot;Pluminary&quot;)
                                .url(&quot;https://github.com/P-luminary&quot;)
                                .email(&quot;390415030@qq.com&quot;)));
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserRepository.java //【这个是持久化接口 实现CRUD】
package com.pcy.service;

import com.pcy.dao.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">com/pcy/controller/UserController.java
package com.pcy.controller;

import com.pcy.dao.User;
import com.pcy.service.UserRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/users&quot;)
@Tag(name = &quot;User Controller&quot;, description = &quot;用户相关操作&quot;)
public class UserController &#123;

    @Autowired
    private UserRepository userRepository;

    @Operation(summary = &quot;根据ID获取用户信息&quot;, description = &quot;通过用户ID获取用户详细信息&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功获取用户信息&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;未找到用户&quot;)
    &#125;)
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User get(@PathVariable int id) &#123;
        return userRepository.findById(id).orElse(null);
    &#125;

    @Operation(summary = &quot;创建用户&quot;, description = &quot;创建一个新的用户&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功创建用户&quot;),
            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;无效的输入&quot;)
    &#125;)
    @PostMapping
    public User create(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;更新用户&quot;, description = &quot;更新用户信息&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功更新用户信息&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;未找到用户&quot;)
    &#125;)
    @PutMapping
    public User update(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;删除用户&quot;, description = &quot;根据ID删除用户&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功删除用户&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;未找到用户&quot;)
    &#125;)
    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void delete(@PathVariable int id) &#123;
        userRepository.deleteById(id);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.pcy&lt;/groupId&gt;
    &lt;artifactId&gt;Pluminary&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;Pluminary&lt;/name&gt;
    &lt;description&gt;Pluminary&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.swagger.core.v3&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.2.15&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;!--        &lt;dependency&gt;--&gt;
&lt;!--            &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;
&lt;!--            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;
&lt;!--            &lt;version&gt;8.0.33&lt;/version&gt;--&gt;
&lt;!--        &lt;/dependency&gt;--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;2.7.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
            &lt;version&gt;6.1.7.Final&lt;/version&gt; &lt;!-- 选择与 Spring Boot 3.3.2 兼容的版本 --&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h3 id="增加分页、排序"><a href="#增加分页、排序" class="headerlink" title="增加分页、排序"></a>增加分页、排序</h3><pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;获取用户列表&quot;, description = &quot;获取用户列表&quot;)
    @GetMapping
    public Page&lt;User&gt; list(@RequestParam(defaultValue = &quot;id&quot;) String property,
 @RequestParam(defaultValue = &quot;ASC&quot;)Sort.Direction direction,
 @RequestParam(defaultValue = &quot;0&quot;) Integer page,
 @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123;
    Pageable pageable = PageRequest.of(page, pageSize, direction, property);
        return userRepository.findAll(pageable);
    &#125;
</code></pre>
<h3 id="根据姓名查用户"><a href="#根据姓名查用户" class="headerlink" title="根据姓名查用户"></a>根据姓名查用户</h3><pre><code class="java">com/pcy/controller/UserController.java    
    @Operation(summary = &quot;根据姓名查用户&quot;,description = &quot;根据姓名查用户&quot;)
    @GetMapping(&quot;/name&quot;)
    public List&lt;User&gt; getByName(String name)&#123;
        return userRepository.findByNameContaining(name);
    &#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserRepository.java
package com.pcy.service;

import com.pcy.dao.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;
    List&lt;User&gt; findByNameContaining(String name);
&#125;
</code></pre>
<h3 id="根据生日查用户、删除User表"><a href="#根据生日查用户、删除User表" class="headerlink" title="根据生日查用户、删除User表"></a>根据生日查用户、删除User表</h3><pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;根据生日获取用户信息①&quot;,description = &quot;根据生日获取用户信息①&quot;)
    @GetMapping(&quot;/birthdayOne&quot;)
    public List&lt;User&gt; getBirthDayOne(LocalDate birthDay)&#123;
        return userRepository.findByBirthDay(birthDay);
    &#125;

    @Operation(summary = &quot;根据生日获取用户信息②&quot;,description = &quot;根据生日获取用户信息②&quot;)
    @GetMapping(&quot;/birthdayTwo&quot;)
    public List&lt;User&gt; getBirthDayTwo(LocalDate birthDay)&#123;
        return userRepository.findByBirthDayNative(birthDay);
    &#125;

    @Operation(summary = &quot;删除User&quot;,description = &quot;删除User&quot;)
    @GetMapping(&quot;/delete&quot;)
    public void delete()&#123;
        userRepository.delete();
    &#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserRepository.java
@Query(&quot;SELECT u FROM User u WHERE u.birthday=?1&quot;)
    List&lt;User&gt; findByBirthDay(LocalDate birthDay);

    @Query(value = &quot;SELECT * FROM user WHERE birth_day =:birthDay&quot;,nativeQuery = true)
    List&lt;User&gt; findByBirthDayNative(LocalDate birthDay);

    @Modifying
    @Transactional
    @Query(value = &quot;DELETE FROM User&quot;)
    int delete();
</code></pre>
<h3 id="增加审计"><a href="#增加审计" class="headerlink" title="增加审计"></a>增加审计</h3><pre><code class="java">com/pcy/MallApplication.java //【增加@EnableJpaAuditing】
package com.pcy;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@EnableJpaAuditing
@SpringBootApplication
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/dao/BaseEntity.java //【没有必要为每个实体类都编写 直接封装导一个类 User去继承】
package com.pcy.dao;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Data;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Data
@MappedSuperclass
//该注解用于监听实体类，在save、update之后的状态
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity &#123;
    @CreatedBy
    @Column(updatable = false)
    private String creator;

    @LastModifiedBy
    private String modifier;

    @CreatedDate
    @Column(updatable = false) //不可修改的
    private LocalDateTime createTime;

    @LastModifiedDate
    private LocalDateTime updateTime;
&#125;
</code></pre>
<pre><code class="java">com/pcy/dao/User.java //【增加@EqualsAndHashCode 与 extends BaseEntity】
@Data
@Entity
@EqualsAndHashCode(callSuper = true)
//@Schema(name=&quot;用户信息&quot;)
@Table(indexes = &#123;@Index(name = &quot;uk_email&quot;,columnList = &quot;email&quot;,unique = true)&#125;)
public class User extends BaseEntity&#123;
    @Id
//    @Schema(description = &quot;用户ID&quot;)
//    @NotBlank(message = &quot;Id不能为空&quot;)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    ...
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/AuditorAwareImpl.java
package com.pcy.service.impl;

import org.springframework.data.domain.AuditorAware;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class AuditorAwareImpl implements AuditorAware&lt;String&gt; &#123;

    @Override
    public Optional&lt;String&gt; getCurrentAuditor() &#123;
        // 添加一个随机数
        return Optional.of(&quot;管理员&quot;+(int)(Math.random()));
    &#125;
&#125;
</code></pre>
<h3 id="引入Mybatis-Plus-FreeMarker"><a href="#引入Mybatis-Plus-FreeMarker" class="headerlink" title="引入Mybatis-Plus + FreeMarker"></a>引入Mybatis-Plus + FreeMarker</h3><pre><code class="xml">pom.xml
&lt;dependency&gt;
  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;3.4.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">//根据你提供的实体类BaseEntity和User，我为你设计了一个基于MyBatis-Plus 3.5.x版本的代码生成器MysqlGenerator，它将自动生成与这些实体类相关的代码，如Mapper、Service、Controller等。以下是生成器的代码示例
【仅供查看学习 实际代码爆红无法导入】
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.core.toolkit.StringPool;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.*;
import com.baomidou.mybatisplus.generator.config.builder.*;
import com.baomidou.mybatisplus.generator.config.po.TableInfo;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;
import com.baomidou.mybatisplus.generator.fill.Property;
import com.baomidou.mybatisplus.generator.keywords.MySqlKeyWordsHandler;

import java.util.Collections;

public class MysqlGenerator &#123;

    // 项目路径
    private static final String PROJECT_PATH = System.getProperty(&quot;user.dir&quot;);
    // 输出路径
    private static final String OUTPUT_DIR = PROJECT_PATH + &quot;/src/main/java&quot;;
    // 作者
    private static final String AUTHOR = &quot;YourName&quot;;
    // 包名
    private static final String BASE_PACKAGE = &quot;com.pcy&quot;;
    // 数据源配置
    private static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/your_database&quot;;
    private static final String DATABASE_USERNAME = &quot;root&quot;;
    private static final String DATABASE_PASSWORD = &quot;password&quot;;
    private static final String DATABASE_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;

    public static void main(String[] args) &#123;
        // 1. 全局配置
        GlobalConfig.Builder globalConfig = new GlobalConfig.Builder()
            .outputDir(OUTPUT_DIR)
            .author(AUTHOR)
            .enableSwagger()
            .fileOverride()
            .disableOpenDir(); // 不自动打开输出目录

        // 2. 数据源配置
        DataSourceConfig.Builder dataSourceConfig = new DataSourceConfig.Builder(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD)
            .dbQuery(new MySqlQuery())
            .schema(&quot;public&quot;)
            .dbType(DbType.MYSQL)
            .keyWordsHandler(new MySqlKeyWordsHandler())
            .driverName(DATABASE_DRIVER);

        // 3. 包配置
        PackageConfig.Builder packageConfig = new PackageConfig.Builder()
            .parent(BASE_PACKAGE)
            .entity(&quot;dao&quot;)
            .mapper(&quot;mapper&quot;)
            .service(&quot;service&quot;)
            .controller(&quot;controller&quot;);

        // 4. 策略配置
        StrategyConfig.Builder strategyConfig = new StrategyConfig.Builder()
            .addInclude(&quot;user&quot;) // 生成指定表
            .addTablePrefix(&quot;t_&quot;) // 去掉表前缀
            .entityBuilder()
                .superClass(BaseEntity.class)
                .enableLombok()
                .addSuperEntityColumns(&quot;id&quot;, &quot;creator&quot;, &quot;modifier&quot;, &quot;create_time&quot;, &quot;update_time&quot;)
                .logicDeleteColumnName(&quot;deleted&quot;)
                .addTableFills(new Property(&quot;create_time&quot;, FieldFill.INSERT))
                .addTableFills(new Property(&quot;update_time&quot;, FieldFill.INSERT_UPDATE))
                .enableActiveRecord()
                .naming(NamingStrategy.underline_to_camel)
                .columnNaming(NamingStrategy.underline_to_camel)
            .controllerBuilder()
                .enableRestStyle()
                .enableHyphenStyle()
            .serviceBuilder()
                .formatServiceFileName(&quot;%sService&quot;)
                .formatServiceImplFileName(&quot;%sServiceImpl&quot;)
            .mapperBuilder()
                .enableBaseResultMap()
                .enableBaseColumnList();

        // 5. 模板配置
        TemplateConfig.Builder templateConfig = new TemplateConfig.Builder();

        // 6. 自定义配置
        InjectionConfig.Builder injectionConfig = new InjectionConfig.Builder()
            .beforeOutputFile((tableInfo, objectMap) -&gt; objectMap.put(&quot;parent&quot;, BASE_PACKAGE));

        // 7. 整合配置
        AutoGenerator autoGenerator = new AutoGenerator(dataSourceConfig.build())
            .global(globalConfig.build())
            .packageInfo(packageConfig.build())
            .strategy(strategyConfig.build())
            .template(templateConfig.build())
            .injection(injectionConfig.build())
            .templateEngine(new FreemarkerTemplateEngine()); // 选择模板引擎

        // 8. 执行
        autoGenerator.execute();
    &#125;
&#125;
/*
关键配置说明：
GlobalConfig：设置代码生成的全局配置，包括作者、输出目录、是否覆盖已有文件等。
DataSourceConfig：配置数据库连接信息，使用MySQL数据库。
PackageConfig：指定生成的代码所在的包路径。
StrategyConfig：配置生成策略，包括实体类的继承关系、使用Lombok、Rest风格的控制器等。
TemplateConfig：模板配置，可定制生成的模板。
InjectionConfig：自定义配置，用于在生成文件前注入自定义的变量或逻辑。
AutoGenerator：整合所有配置并执行代码生成。

生成的文件包括：
实体类：根据数据库表生成实体类，并继承BaseEntity。
Mapper接口：生成Mapper接口用于数据库操作。
Service接口和实现类：生成Service接口及其实现类。
Controller类：生成Rest风格的控制器类。

使用方法：
修改数据库连接信息（DATABASE_URL、DATABASE_USERNAME、DATABASE_PASSWORD）。
配置需要生成代码的表名（addInclude(&quot;user&quot;)）。
运行MysqlGenerator.java的main方法，代码将会生成在指定的输出目录中。
*
</code></pre>
<pre><code class="java">//【以下都是自动生成的代码】
com/pcy/mapper/UserMapper.java
package com.pcy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.pcy.entity.User;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserService.java
package com.pcy.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.pcy.entity.User;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * &lt;p&gt;
 * 用户表 服务类
 * &lt;/p&gt;
 */
public interface UserService extends IService&lt;User&gt; &#123;
// 在Spring中使用事务
    @Transactional(propagation = Propagation.REQUIRED)
    void addWithRequired(User user);

    @Transactional(propagation = Propagation.REQUIRED)
    void addWithRequiredAndException(User user);

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void addWithRequiredNew(User user);

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void addWithRequiredNewAndException(User user);

    @Transactional(propagation = Propagation.NESTED)
    void addWithNested(User user);

    @Transactional(propagation = Propagation.NESTED)
    void addWithNestedAndException(User user);
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/UserServiceImpl.java
package com.pcy.service.impl;


import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.pcy.entity.User;
import com.pcy.mapper.UserMapper;
import com.pcy.service.UserService;
import com.pcy.mapper.UserMapper;
import com.pcy.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * &lt;p&gt;
 * 用户表 服务实现类
 * &lt;/p&gt;
 */
@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;

    @Autowired
    private UserMapper mapper;
    
    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void addWithRequired(User user) &#123;
        mapper.insert(user);
    &#125;

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void addWithRequiredAndException(User user) &#123;
        mapper.insert(user);
        throw new RuntimeException();
    &#125;

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void addWithRequiredNew(User user) &#123;
        mapper.insert(user);
    &#125;

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void addWithRequiredNewAndException(User user) &#123;
        mapper.insert(user);
        throw new RuntimeException();
    &#125;

    @Override
    @Transactional(propagation = Propagation.NESTED)
    public void addWithNested(User user) &#123;
        mapper.insert(user);
    &#125;

    @Override
    @Transactional(propagation = Propagation.NESTED)
    public void addWithNestedAndException(User user) &#123;
        mapper.insert(user);
        throw new RuntimeException();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">resources/mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.pcy.mapper.UserMapper&quot;&gt;

    &lt;!-- 通用查询映射结果 --&gt;
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.pcy.entity.User&quot;&gt;
    &lt;result column=&quot;id&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;creator&quot; property=&quot;creator&quot; /&gt;
    &lt;result column=&quot;modifier&quot; property=&quot;modifier&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; /&gt;
    &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot; /&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
        &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;
        &lt;result column=&quot;birth_day&quot; property=&quot;birthDay&quot; /&gt;
    &lt;/resultMap&gt;

    &lt;!-- 通用查询结果列 --&gt;
    &lt;sql id=&quot;Base_Column_List&quot;&gt;
        id,
        creator,
        modifier,
        create_time,
        update_time,
        name, email, birth_day
    &lt;/sql&gt;

&lt;/mapper&gt;
</code></pre>
<pre><code class="java">//【提问：爆bug  &quot;Could not autowire. No beans of &#39;UserMapper&#39; type found&quot;】 深度解析
1. @MapperScan 注解的原理 //启动类里面的 @MapperScan(&quot;com.pcy.mapper&quot;)
@MapperScan 是 MyBatis-Spring 提供的一个注解，用于指定要扫描的 Mapper 接口所在的包路径。它的作用是告诉 Spring 框架应该在哪些包路径下寻找 Mapper 接口，并将它们注册为 Spring 的 Bean。
扫描 Mapper 接口：Spring Boot 在启动时，会扫描你指定的包路径下的所有接口，并检测这些接口是否包含 MyBatis 的 Mapper 注解或者继承了 BaseMapper 等相关接口。
注册为 Bean：一旦找到这些接口，Spring 会自动为这些接口生成一个实现类，并将它们注册为 Spring 容器中的 Bean，这样你就可以通过 @Autowired 注入这些 Mapper。

2. @Mapper 注解的原理
@Mapper 是 MyBatis 提供的一个注解，用于标记一个接口为 MyBatis 的 Mapper 接口。被标记为 @Mapper 的接口会被 MyBatis-Spring 扫描到，并且 MyBatis 会为该接口生成一个实现类，负责执行 SQL 语句。
当你在 UserMapper 接口上添加 @Mapper 注解时，即使没有使用 @MapperScan，MyBatis 也会知道这个接口是一个 Mapper 接口，并将其注册为一个 Bean。这使得你可以在 UserServiceImpl 中通过 @Autowired 注入它。

3. 为什么使用 @MapperScan 和 @Mapper 不会报错
自动注册 Bean：@MapperScan 会自动扫描指定包路径下的所有 Mapper 接口，并将它们注册为 Spring 容器中的 Bean。这意味着在 UserServiceImpl 中，当你使用 @Autowired 注入 UserMapper 时，Spring 可以找到对应的 Bean，从而避免 Could not autowire 错误。
手动注册 Bean：当你在 Mapper 接口上直接使用 @Mapper 注解时，Spring 也会将该接口注册为一个 Bean，这样你同样可以通过 @Autowired 进行注入，而不会出现 Bean 找不到的问题。
</code></pre>
<pre><code class="java">//【提问：MysqlGenerator 逆向生成那些包的原理】
MyBatis-Plus 提供的 MyBatis-Plus Generator 是一个非常强大的代码生成工具，可以通过数据库表结构生成对应的 Java 代码，包括实体类、Mapper 接口、Mapper XML 文件、Service 类、Controller 类等。这个过程通常被称为“逆向工程”或“代码生成”。
1. MyBatis-Plus Generator 的工作原理
 1.1 读取数据库表结构
数据源配置：首先，MyBatis-Plus Generator 通过配置的数据源连接到指定的数据库。它会读取数据库中的表结构信息，包括表名、字段名、数据类型、主键、外键、索引等信息。
&gt; DataSourceConfig dsc = new DataSourceConfig.Builder(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD)
    .driverName(DATABASE_DRIVER)
    .build();

元数据解析：MyBatis-Plus Generator 通过 JDBC 获取数据库的元数据 (Metadata)，并解析每个表的结构，将其转换为可以用于代码生成的数据结构。

 1.2 生成代码
代码生成器：AutoGenerator 是核心的代码生成器类。它根据从数据库中获取的表结构信息，生成相应的 Java 类文件。
&gt; AutoGenerator generator = new AutoGenerator(dsc);

模板引擎：MyBatis-Plus Generator 使用模板引擎（例如 Freemarker）来渲染代码模板。通过模板和解析后的元数据，生成代码文件。每个生成的 Java 类文件都对应着一个模板文件，模板文件中包含了如何生成特定类型文件的逻辑。
&gt; generator.templateEngine(new FreemarkerTemplateEngine());

 1.3 生成的包和文件
实体类 (entity)：根据表结构生成对应的 Java 实体类。每个实体类与数据库表一一对应，包含表中字段的定义。
&gt; strategyConfig.entityBuilder().enableLombok().naming(NamingStrategy.underline_to_camel);

Mapper 接口 (mapper)：生成的 Mapper 接口用于与数据库交互，执行基本的增删改查操作。Mapper 接口通常继承自 BaseMapper，提供基本的 CRUD 操作。
&gt; strategyConfig.mapperBuilder().enableBaseResultMap().enableBaseColumnList();
Mapper XML 文件 (mapper.xml)：生成的 Mapper XML 文件包含了 Mapper 接口中对应的方法的 SQL 语句。这些 XML 文件用于定义复杂的查询、更新语句等。

Service 接口和实现类 (service, service.impl)：Service 层是业务逻辑层。生成的 Service 接口提供了业务操作的定义，Service 实现类则实现这些业务操作。
&gt; strategyConfig.serviceBuilder().formatServiceFileName(&quot;%sService&quot;);

Controller 类 (controller)：生成的 Controller 类用于处理 HTTP 请求，调用 Service 层的方法进行业务处理，然后返回结果。Controller 通常与前端交互，处理用户请求。
&gt; strategyConfig.controllerBuilder().enableRestStyle().enableHyphenStyle();


2. MyBatis-Plus Generator 如何生成这些包和文件
 2.1 代码生成策略 (StrategyConfig)
StrategyConfig 类用于配置代码生成的策略，如生成哪些表，生成哪些类，类的命名规则，是否使用 Lombok 等。
StrategyConfig strategyConfig = new StrategyConfig.Builder()
    .addInclude(&quot;user&quot;) // 生成指定表
    .entityBuilder().enableLombok() // 实体类配置
    .mapperBuilder().enableBaseResultMap() // Mapper 配置
    .serviceBuilder().formatServiceFileName(&quot;%sService&quot;) // Service 配置
    .controllerBuilder().enableRestStyle() // Controller 配置
    .build();

 2.2 模板文件
MyBatis-Plus Generator 使用的模板文件可以自定义，通常位于 resources/templates 目录下。每个模板文件对应一个需要生成的 Java 文件类型，例如 entity.java.ftl 对应实体类，mapper.java.ftl 对应 Mapper 接口。
     
模板文件中可以使用变量和逻辑来决定生成的代码内容。例如，$&#123;className&#125; 会被替换为实际的类名，&lt;#if useLombok&gt; @Data &lt;/#if&gt; 会根据条件生成代码。
     
 2.3 文件输出配置 (InjectionConfig 和 FileOutConfig)
通过 InjectionConfig 和 FileOutConfig，可以控制生成文件的路径、名称、以及自定义生成的文件内容。例如，可以指定某个表的实体类生成到特定的包下，或者将 XML 文件输出到特定的路径。
InjectionConfig cfg = new InjectionConfig.Builder()
    .beforeOutputFile((tableInfo, objectMap) -&gt; &#123;
        // 自定义处理逻辑
    &#125;)
    .build();
</code></pre>
<h3 id="用MyBatis-Plus的分页"><a href="#用MyBatis-Plus的分页" class="headerlink" title="用MyBatis Plus的分页"></a>用MyBatis Plus的分页</h3><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.pcy&lt;/groupId&gt;
    &lt;artifactId&gt;Pluminary&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;Pluminary&lt;/name&gt;
    &lt;description&gt;Pluminary&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.swagger.core.v3&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.2.15&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;!--        &lt;dependency&gt;--&gt;
&lt;!--            &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;
&lt;!--            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;
&lt;!--            &lt;version&gt;8.0.33&lt;/version&gt;--&gt;
&lt;!--        &lt;/dependency&gt;--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
            &lt;version&gt;6.1.7.Final&lt;/version&gt; &lt;!-- 选择与 Spring Boot 3.3.2 兼容的版本 --&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.5&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
                    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
            &lt;version&gt;3.5.5&lt;/version&gt; &lt;!-- 版本对齐 --&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">//【添加MyBatis-Plus的分页插件】
com/pcy/utils/MyBatisPlusConfig.java
package com.pcy.utils;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
//@Configuration 用于定义配置类，被注解的类内部包含有一个或多个被@Bean注解的方法
// 用于构建bean定义，初始化Spring容器
@Configuration
public class MyBatisPlusConfig &#123;
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MARIADB));
        return interceptor;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/controller/UserController.java //【增加listPage】
package com.pcy.controller;

import com.pcy.entity.User;
import com.pcy.service.UserRepository;
import com.pcy.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping(&quot;/users&quot;)
@Tag(name = &quot;User Controller&quot;, description = &quot;用户相关操作&quot;)
public class UserController &#123;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserService userService;

    @Operation(summary = &quot;根据ID获取用户信息&quot;, description = &quot;通过用户ID获取用户详细信息&quot;)
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User get(@PathVariable int id) &#123;
        return userRepository.findById(id).orElse(null);
    &#125;

    @Operation(summary = &quot;创建用户&quot;, description = &quot;创建一个新的用户&quot;)
    @PostMapping
    public User create(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;更新用户&quot;, description = &quot;更新用户信息&quot;)
    @PutMapping
    public User update(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;删除用户&quot;, description = &quot;根据ID删除用户&quot;)
    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void delete(@PathVariable int id) &#123;
        userRepository.deleteById(id);
    &#125;

    @Operation(summary = &quot;获取用户列表&quot;, description = &quot;获取用户列表&quot;)
    @GetMapping(&quot;/list&quot;)
    public org.springframework.data.domain.Page&lt;User&gt; list(@RequestParam(defaultValue = &quot;id&quot;) String property,
                                                           @RequestParam(defaultValue = &quot;ASC&quot;) Sort.Direction direction,
                                                           @RequestParam(defaultValue = &quot;0&quot;) Integer page,
                                                           @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123;
        Pageable pageable = PageRequest.of(page, pageSize, direction, property);
        return userRepository.findAll(pageable);
    &#125;

    @Operation(summary = &quot;根据生日获取用户信息①&quot;, description = &quot;根据生日获取用户信息①&quot;)
    @GetMapping(&quot;/birthdayOne&quot;)
    public List&lt;User&gt; getBirthDayOne(@RequestParam LocalDate birthDay) &#123;
        return userRepository.findByBirthDay(birthDay);
    &#125;

    @Operation(summary = &quot;根据生日获取用户信息②&quot;, description = &quot;根据生日获取用户信息②&quot;)
    @GetMapping(&quot;/birthdayTwo&quot;)
    public List&lt;User&gt; getBirthDayTwo(@RequestParam LocalDate birthDay) &#123;
        return userRepository.findByBirthDayNative(birthDay);
    &#125;

    @Operation(summary = &quot;删除所有用户&quot;, description = &quot;删除所有用户&quot;)
    @DeleteMapping(&quot;/deleteAll&quot;)
    public void deleteAll() &#123;
        userRepository.deleteAll();
    &#125;

    @Operation(summary = &quot;分页查询用户列表&quot;, description = &quot;分页查询用户列表&quot;)
    @GetMapping(&quot;/page&quot;)
    public Page&lt;User&gt; listPage(@RequestParam(defaultValue = &quot;1&quot;) Integer page,
                               @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123;
        return userService.page(new Page&lt;&gt;(page, pageSize));
    &#125;
&#125;
</code></pre>
<h3 id="高级SQL语句-Lambda"><a href="#高级SQL语句-Lambda" class="headerlink" title="高级SQL语句(Lambda)"></a>高级SQL语句(Lambda)</h3><pre><code class="java">wrapper.lambda().like(user -&gt; user.getName(), &quot;p&quot;);
/*
Lambda 表达式:

user -&gt; user.getName() 是一个 Lambda 表达式。
user 是 User 类的一个实例，作为 Lambda 表达式的输入参数。
user.getName() 是对 user 对象的 getName() 方法的调用，返回 name 字段的值。
作用:

这行代码告诉 MyBatis-Plus：在生成的 SQL 查询中，查找 name 字段值中包含 &quot;p&quot; 的所有记录。
wrapper.lambda() 返回一个 LambdaQueryWrapper&lt;User&gt; 对象，支持使用 Lambda 表达式进行条件构建。
.like() 方法添加了一个 LIKE 条件，表示在 SQL 查询中进行模糊匹配。
*/


wrapper.lambda().like(User::getName, &quot;p&quot;);
/*
方法引用:

User::getName 是一种方法引用，它引用了 User 类的 getName() 方法。
方法引用是对 Lambda 表达式的一种简写。它表示将某个方法作为函数式接口的实现。
作用:

这行代码与第一行代码的作用相同，都是在生成的 SQL 查询中查找 name 字段值中包含 &quot;p&quot; 的所有记录。
User::getName 告诉 MyBatis-Plus：使用 User 类中的 getName() 方法来获取要参与条件判断的字段。
*/
</code></pre>
<pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;自定义查询&quot;, description = &quot;自定义查询&quot;)
    @GetMapping(&quot;/Dingyi&quot;)
    public List&lt;User&gt; getWrapper() &#123; //类型List&lt;User&gt; 可以返回数据库列表
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
//        wrapper.eq(&quot;name&quot;, &quot;潘春尧&quot;);
//        wrapper.lambda().ge(User::getBirthDay, LocalDate.parse(&quot;2011-01-01&quot;));
//        wrapper.between(User::getBirthDay, &quot;2011-01-01&quot;, &quot;2011-12-31&quot;);
        wrapper.lambda().like(User::getName, &quot;string&quot;);

//      wrapper.lambda().like(user -&gt; user.getName(), &quot;p&quot;);
//        wrapper.select(&quot;name,count(*)&quot;).groupBy(&quot;name&quot;);
//        return (QueryWrapper&lt;User&gt;) userMapper.selectList(wrapper);
//        wrapper.in(CollectionUtils.isNotEmpty(nameList), User::getName, nameList);
        return userMapper.selectList(wrapper);
    &#125;
</code></pre>
<h3 id="自动填充、填充实现策略"><a href="#自动填充、填充实现策略" class="headerlink" title="自动填充、填充实现策略"></a>自动填充、填充实现策略</h3><pre><code class="java">com/pcy/utils/MyMetaObjectHandler.java
package com.pcy.utils;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;

import java.time.LocalDateTime;

public class MyMetaObjectHandler implements MetaObjectHandler &#123;
    @Override
    public void insertFill(MetaObject metaObject) &#123;
        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime::now, LocalDateTime.class);
        this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime::now, LocalDateTime.class);
        this.strictInsertFill(metaObject, &quot;creator&quot;, this::getCurrentUser, String.class);
        this.strictInsertFill(metaObject, &quot;modifier&quot;, this::getCurrentUser, String.class);
    &#125;

    @Override
    public void updateFill(MetaObject metaObject) &#123;
        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime::now, LocalDateTime.class);
        this.strictUpdateFill(metaObject, &quot;modifier&quot;, this::getCurrentUser, String.class);
    &#125;
    
    // 模拟获取当前用户
    private String getCurrentUser()&#123;
        return &quot;管理员&quot; + (int) (Math.random() * 10);
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 这是自动填充的原理
default MetaObjectHandler strictFillStrategy(MetaObject metaObject, String fieldName, Supplier&lt;?&gt; fieldVal) &#123;
        if (metaObject.getValue(fieldName) == null) &#123;
            Object obj = fieldVal.get();
            if (Objects.nonNull(obj)) &#123;
                metaObject.setValue(fieldName, obj);
            &#125;
        &#125;
        return this;
    &#125;
</code></pre>
<h3 id="强大的Druid"><a href="#强大的Druid" class="headerlink" title="强大的Druid"></a>强大的Druid</h3><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.5&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">// Druid和MariaDB是两种不同类型的数据库系统
1、类型和用途：
Druid：Druid是一种分布式的实时分析数据库，主要用于处理高吞吐量的时间序列数据或事件数据。它专为快速查询和分析大规模数据而设计，常用于数据仓库、在线分析处理（OLAP）以及实时数据分析等场景。
MariaDB：MariaDB是一种关系型数据库管理系统（RDBMS），它是MySQL的一个分支，广泛用于常规的事务处理、数据存储和管理。MariaDB通常用于传统的OLTP（在线事务处理）场景，如web应用、内容管理系统等。

2、适用场景：
Druid：适合用于实时数据分析、日志分析、时间序列分析、用户行为分析等需要快速响应的场景。
MariaDB：适合传统的数据库应用，如电子商务系统、内容管理系统、ERP、CRM等需要强事务处理能力的场景。
    
总结来说，Druid和MariaDB各自适用于不同的数据处理需求，Druid更侧重于实时分析和大规模数据处理，而MariaDB更侧重于事务处理和关系型数据管理
</code></pre>
<h3 id="Spring-Data-JPA与MyBatis-Plus的区别并且简单举例说明"><a href="#Spring-Data-JPA与MyBatis-Plus的区别并且简单举例说明" class="headerlink" title="Spring Data JPA与MyBatis-Plus的区别并且简单举例说明"></a>Spring Data JPA与MyBatis-Plus的区别并且简单举例说明</h3><pre><code class="java">Spring Data JPA: //【实现接口】

@Entity
public class User &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    // Other fields, getters, and setters
&#125;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;
    List&lt;User&gt; findByName(String name);
&#125;
</code></pre>
<pre><code class="java">Spring Data JPA: //【实现控制类】
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/jpa/users&quot;)
public class UserJpaController &#123;

    @Autowired
    private UserRepository userRepository;

    @GetMapping
    public List&lt;User&gt; getAllUsers() &#123;
        return userRepository.findAll();
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User getUserById(@PathVariable Long id) &#123;
        return userRepository.findById(id)
                             .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));
    &#125;

    @PostMapping
    public User createUser(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;
    @PutMapping(&quot;/&#123;id&#125;&quot;)
    public User updateUser(@PathVariable Long id, @RequestBody User userDetails) &#123;
        User user = userRepository.findById(id)
                                  .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));

        user.setName(userDetails.getName());
        // Update other fields here
        return userRepository.save(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void deleteUser(@PathVariable Long id) &#123;
        User user = userRepository.findById(id)
                                  .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));

        userRepository.delete(user);
    &#125;

    @GetMapping(&quot;/search&quot;)
    public List&lt;User&gt; searchUsersByName(@RequestParam String name) &#123;
        return userRepository.findByName(name);
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<pre><code class="java">MyBatis Plus: //【实现接口】

@TableName(&quot;user&quot;)
public class User &#123;
    private Long id;
    private String name;
    // Other fields, getters, and setters
&#125;

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
    // Custom SQL
    @Select(&quot;SELECT * FROM user WHERE name = #&#123;name&#125;&quot;)
    List&lt;User&gt; selectByName(@Param(&quot;name&quot;) String name);
&#125;
</code></pre>
<pre><code class="java">MyBatis-Plus: //【实现控制类】
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/mybatis/users&quot;)
public class UserMyBatisController &#123;

    @Autowired
    private UserMapper userMapper;

    @GetMapping
    public List&lt;User&gt; getAllUsers() &#123;
        return userMapper.selectList(null);
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User getUserById(@PathVariable Long id) &#123;
        return userMapper.selectById(id);
    &#125;

    @PostMapping
    public void createUser(@RequestBody User user) &#123;
        userMapper.insert(user);
    &#125;

    @PutMapping(&quot;/&#123;id&#125;&quot;)
    public void updateUser(@PathVariable Long id, @RequestBody User userDetails) &#123;
        User user = userMapper.selectById(id);
        if (user == null) &#123;
            throw new ResourceNotFoundException(&quot;User not found with id: &quot; + id);
        &#125;

        user.setName(userDetails.getName());
        // Update other fields here
        userMapper.updateById(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void deleteUser(@PathVariable Long id) &#123;
        User user = userMapper.selectById(id);
        if (user == null) &#123;
            throw new ResourceNotFoundException(&quot;User not found with id: &quot; + id);
        &#125;

        userMapper.deleteById(id);
    &#125;

    @GetMapping(&quot;/search&quot;)
    public List&lt;User&gt; searchUsersByName(@RequestParam String name) &#123;
        return userMapper.selectByName(name);
    &#125;
&#125;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 构建查询条件的包装类，它使用 Lambda 表达式避免了手写字符串可能导致的字段错误。
// 这种方式非常适合需要根据多个条件动态生成SQL查询的场景，使用LambdaQueryWrapper不仅能提高代码的可读性，还能减少由于硬编码字符串导致的错误。
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/mybatis/users&quot;)
public class UserMyBatisController &#123;

    @Autowired
    private UserMapper userMapper;

    @GetMapping(&quot;/search&quot;)
    public List&lt;User&gt; searchUsersByName(@RequestParam String name) &#123;
        // 使用 LambdaQueryWrapper 构建模糊查询条件
        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.like(User::getName, name); // 类似于 SQL 中的 &quot;WHERE name LIKE &#39;%name%&#39;&quot;

        // 执行查询并返回结果
        return userMapper.selectList(queryWrapper);
    &#125;
    // 其他CRUD方法与前面的示例相同
&#125;
</code></pre>
<h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><h6 id="经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。"><a href="#经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。" class="headerlink" title="经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。"></a>经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。</h6><pre><code class="xml">pom.xml
          &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/pcy/service/impl/UserServiceImpl.java
@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;
    private static final Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);
    @Autowired
    private UserMapper mapper;

    public User getById(int id) &#123;
        logger.info(&quot;id为：&quot;,id);
        return mapper.selectById(id);
    &#125;
......
&#125;
</code></pre>
<h6 id="这是测试Service"><a href="#这是测试Service" class="headerlink" title="这是测试Service"></a>这是测试Service</h6><pre><code class="java">test/java  com/pcy/service/impl/UserServiceImplTest.java //【用Mock改造 + log4j】
// 检查 UserServiceImpl 是否在测试中被 @MockBean 或其他方式替换为Mock对象。如果使用了Mock对象，测试时不会真正访问数据库，而是使用模拟数据。
package com.pcy.service.impl;

import com.pcy.entity.User;
import com.pcy.mapper.UserMapper;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class UserServiceImplTest &#123;
    @InjectMocks
    UserServiceImpl userService;

    @Mock
    UserMapper userMapper;

    @Test
    @DisplayName(&quot;Test Service getById&quot;)
    void getById() &#123;
        // 模拟userMapper的selectById方法返回一个User对象
        User mockUser = new User().setId(1).setName(&quot;qwe&quot;).setEmail(&quot;1234@qq.com&quot;);
        Mockito.when(userMapper.selectById(1)).thenReturn(mockUser);

        // 调用userService的getById方法，并验证返回结果
        User user = userService.getById(1);

        System.out.println(user);
        Assertions.assertEquals(&quot;qwe&quot;, user.getName());
    &#125;
&#125;
=====================================================================
Java HotSpot(TM) 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended
2024-08-12T21:18:07.805+08:00  INFO 31512 --- [Pluminary] [           main] com.pcy.service.impl.UserServiceImpl     : id为：
User(id=1, name=qwe, age=0, email=1234@qq.com, birthDay=null)
</code></pre>
<pre><code class="java">com/pcy/entity/User.java
//你的 User 类同时使用了 Lombok 注解 (@Data, @Accessors(chain = true)) 和手动定义的 getter/setter 方法。由于 Lombok 已经生成了这些方法，手动定义的 getter/setter 方法会覆盖 Lombok 自动生成的方法，这可能导致链式调用的 setEmail 和其他类似方法无法正确解析。
package com.pcy.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

import java.time.LocalDate;

@Data
@Entity
@EqualsAndHashCode(callSuper = true)
//@Schema(name=&quot;用户信息&quot;)
@Table(indexes = &#123;@Index(name = &quot;uk_email&quot;,columnList = &quot;email&quot;,unique = true)&#125;)
@Accessors(chain = true) // 允许链式调用
public class User extends BaseEntity&#123;
    @Id
//    @Schema(description = &quot;用户ID&quot;)
//    @NotBlank(message = &quot;Id不能为空&quot;)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

//    @Schema(description = &quot;用字&quot;)
//    @NotBlank(message = &quot;名字不能为空&quot;)
    @Column(nullable = false, columnDefinition = &quot;varchar(20) comment &#39;姓名&#39;&quot;)
    private String name;

//    @Transient //注解修饰
//    @Schema(description = &quot;年龄&quot;)
//    @Min(value = 1, message = &quot;年龄不能小于1&quot;)
    private int age;

//    @Schema(description = &quot;邮箱&quot;)
//    @Email(message = &quot;E-mail格式不正确&quot;)
    @Column(nullable = false, length = 50)
    private String email;

//    @Schema(description = &quot;生日&quot;)
//    @Past(message = &quot;生日必须为过去的时间&quot;)
    private LocalDate birthDay;
&#125;
</code></pre>
<h6 id="这是测试Controller"><a href="#这是测试Controller" class="headerlink" title="这是测试Controller"></a>这是测试Controller</h6><pre><code class="java">test/java  com/pcy/controller/UserControllerTest.java
// Controller层的单元测试需要用到一个特定的类——MockMvc 专门为SpringMVC提供支持的
package com.pcy.controller;

import com.pcy.entity.User;
import com.pcy.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.annotation.Before;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.BDDMockito;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import static org.junit.jupiter.api.Assertions.*;
@Slf4j
@SpringBootTest
class UserControllerTest &#123;
    MockMvc mockMvc;

    @Mock
    UserService userService;

    @InjectMocks
    UserController userController;

    @BeforeEach
    void setUp()&#123;
        mockMvc = MockMvcBuilders.standaloneSetup(userController).build();
    &#125;

    @Test
    @DisplayName(&quot;Test Controller get&quot;)
    void get() throws Exception &#123;
        Mockito.when(userService.getById(1)).thenReturn(new User().setName(&quot;刘水镜&quot;).setEmail(&quot;liushuijing@mail.com&quot;));
        BDDMockito.given(userService.getById(1)).willReturn(new User().setName(&quot;刘水镜&quot;).setEmail(&quot;liushuijing@mail.com&quot;));
        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/&#123;id&#125;&quot;, 1)
                        .accept(&quot;application/json;charset=UTF-8&quot;)
                        .contentType(&quot;application/json;charset=UTF-8&quot;))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.name&quot;).value(&quot;刘水镜&quot;))
                .andDo(MockMvcResultHandlers.print())
                .andReturn();
        log.info(&quot;Test Controller get&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><pre><code class="java">/*
一、@RestControllerAdvice 注解的作用
@RestControllerAdvice 是 Spring Framework 为我们提供的一个复合注解，它是 @ControllerAdvice 和 @ResponseBody 的结合体。

@ControllerAdvice：该注解标志着一个类可以为所有的 @RequestMapping 处理方法提供通用的异常处理和数据绑定等增强功能。当应用到一个类上时，该类中定义的方法将在所有控制器类的请求处理链中生效。

@ResponseBody：表示方法的返回值将被直接写入 HTTP 响应体中，通常配合 Jackson 或 Gson 等 JSON 库将对象转换为 JSON 格式的响应。

因此，@RestControllerAdvice 就是专门为 RESTful 控制器设计的全局异常处理器，它的方法返回值将自动转换为响应体。
*/
</code></pre>
<h6 id="“全球”异常"><a href="#“全球”异常" class="headerlink" title="“全球”异常"></a>“全球”异常</h6><pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;异常查询&quot;, description = &quot;异常查询&quot;)
    @GetMapping(value = &quot;/&#123;id&#125;&quot;)
    public Result&lt;User&gt; get(@PathVariable Integer id) &#123;
        User user = userService.getById(id);
        if (user == null)&#123;
            throw new RuntimeException(&quot;找不到id信息&quot; + id);
        &#125;
        return Result.success(userService.getById(id));
    &#125;
/*
当输入id信息错误的时候
&#123;
  &quot;code&quot;: 200,
  &quot;message&quot;: &quot;操作成功&quot;,
  &quot;data&quot;: &#123;
    &quot;creator&quot;: null,
    &quot;modifier&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null,
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;潘春尧&quot;,
    &quot;age&quot;: 1,
    &quot;email&quot;: &quot;390@qq.com&quot;,
    &quot;birthDay&quot;: &quot;2024-08-10&quot;
  &#125;
&#125;


当输入id信息错误的时候
&#123;
  &quot;code&quot;: 500,
  &quot;message&quot;: &quot;找不到id信息3323&quot;,
  &quot;data&quot;: null
&#125;
*/
</code></pre>
<pre><code class="java">com/pcy/utils/GlobalExceptionHandler.java
package com.pcy.utils;

import com.pcy.entity.MessageEnum;
import com.pcy.entity.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler &#123;
//@ExceptionHandler注解用于在Spring MVC控制器中处理特定类型的异常。它可以应用于方法上
//当控制器方法抛出指定类型的异常时，@ExceptionHandler注解的方法将被调用来处理该异常
    @ExceptionHandler(Exception.class)
    public Result&lt;Boolean&gt; globalException(Exception e)&#123;
        Result&lt;Boolean&gt; result = new Result&lt;&gt;();
        result.setCode(MessageEnum.ERROR.getCode());
        result.setMessage(e.getMessage() == null ? MessageEnum.ERROR.getMessage() : e.getMessage());
        log.error(e.getMessage(), e);
        return result;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/entity/MessageEnum.java
package com.pcy.entity;

import lombok.Getter;

@Getter
public enum MessageEnum &#123;
    SUCCESS(200, &quot;操作成功&quot;),
    ERROR(500, &quot;操作失败&quot;);

    private final Integer code;
    private final String message;
    MessageEnum(Integer code, String message)&#123;
        this.code = code;
        this.message = message;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/entity/Result.java
package com.pcy.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result&lt;T&gt; &#123;
   private Integer code;
   private String message;
   private T data;
   // 用于生成一个没有具体数据内容的成功响应
   public static &lt;T&gt; Result&lt;T&gt; success()&#123;
       return success(null);
   &#125;
   // 用于生成包含数据的成功响应
    public static &lt;T&gt; Result&lt;T&gt; success(T data)&#123;
        return new Result&lt;&gt;(MessageEnum.SUCCESS.getCode(), MessageEnum.SUCCESS.getMessage(), data);
    &#125;
    // 用于生成一个没有具体错误信息的默认错误响应
    public static&lt;T&gt; Result&lt;T&gt; error()&#123;
        return error(MessageEnum.ERROR);
    &#125;
    // 用于生成带有特定错误信息的错误响应，MessageEnum 是一个枚举类型，包含了不同的错误信息和代码。
    public static&lt;T&gt; Result&lt;T&gt; error(MessageEnum messageEnum)&#123;
        return new Result&lt;&gt;(messageEnum.ERROR.getCode(), messageEnum.getMessage(), null);
    &#125;
    // 用于生成包含自定义错误信息的错误响应
    public static &lt;T&gt; Result&lt;T&gt; error(String message) &#123;
        return error(message, MessageEnum.ERROR.getCode());
    &#125;
    // 用于生成包含自定义错误信息和自定义状态码的错误响应
    protected static &lt;T&gt; Result&lt;T&gt; error(String message, Integer code) &#123;
        return new Result&lt;&gt;(code, message, null);
    &#125;
&#125;
</code></pre>
<h6 id="写个小异常"><a href="#写个小异常" class="headerlink" title="写个小异常"></a>写个小异常</h6><pre><code class="java">com/pcy/controller/ExceptionController.java
package com.pcy.controller;

import com.pcy.entity.Result;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/exception&quot;)
@Tag(name = &quot;Exception&quot;, description = &quot;异常操作&quot;)
public class ExceptionController &#123;
    @GetMapping(&quot;/runtimeexception&quot;)
    public Result&lt;Boolean&gt; runtimeException()&#123;
        throw new RuntimeException();
    &#125;
&#125;
/*
开启全局异常处理的返回值
&#123;
  &quot;code&quot;: 500,
  &quot;message&quot;: &quot;操作失败&quot;,
  &quot;data&quot;: null
&#125;

没有全局异常处理的错误返回值
&#123;
  &quot;timestamp&quot;: &quot;2024-08-13T08:21:43.192+00:00&quot;,
  &quot;status&quot;: 500,
  &quot;error&quot;: &quot;Internal Server Error&quot;,
  &quot;path&quot;: &quot;/exception/runtimeexception&quot;
&#125;
*/
</code></pre>
<pre><code class="java">//在SwaggerConfig中添加扫描路径 &quot;/exception/**&quot;  不然接口无法获取
package com.pcy.Swagger;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
// http://localhost:8080/swagger-ui/index.html
@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;, &quot;/exception/**&quot;)
                // .addPathsToMatch(&quot;/exception/**&quot;)
                .build();
    &#125;

    @Bean
    public OpenAPI customOpenAPI() &#123;
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Spring Boot 实战&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Spring Boot 实战的 RESTFul 接口文档说明&quot;)
                        .contact(new Contact()
                                .name(&quot;Pluminary&quot;)
                                .url(&quot;https://github.com/P-luminary&quot;)
                                .email(&quot;390415030@qq.com&quot;)));
    &#125;
&#125;
</code></pre>
<pre><code class="java">你提到的 GlobalExceptionHandler 和 ExceptionController 是用于统一处理 Spring MVC 控制器中的异常。让我逐步分析它们的作用，以及为什么在某些情况下它返回错误值。

//1. GlobalExceptionHandler 的作用
@RestControllerAdvice：这个注解用来全局处理控制器层的异常。它会拦截所有抛出的异常，并根据异常类型调用相应的 @ExceptionHandler 方法。

@ExceptionHandler(Exception.class)：这个注解标注的方法会在控制器抛出 Exception 或其子类时执行。它用来捕获并处理全局的异常，比如你代码中的 RuntimeException。

globalException(Exception e)：这是一个全局异常处理方法。当控制器中出现 Exception 时，这个方法会被调用。它将返回一个带有错误状态码的 Result&lt;Boolean&gt; 对象，并且会将错误信息记录到日志中。

//2. ExceptionController 的作用
@RestController：声明这个类是一个 Spring MVC 控制器，处理 Web 请求并返回数据。

runtimeException() 方法：在这个方法中，你手动抛出了一个 RuntimeException，这会触发 GlobalExceptionHandler 中的 globalException 方法，并返回一个包含错误信息的 Result&lt;Boolean&gt; 对象。

//3. 为什么只有引用 runtimeException() 才返回错误值
runtimeException() 方法直接抛出了一个 RuntimeException，因此会被 GlobalExceptionHandler 捕获并处理。这就是为什么在访问 /exception/runtimeexception 时，你会看到返回的是错误信息。

//4. 在 get() 方法中返回 200 状态码的原因
在 get() 方法中，如果你传入的 id 是无效的，返回的 Result&lt;User&gt; 仍然会是 Result.success(userService.getById(id))，即使 userService.getById(id) 返回的是 null。这种情况下，你的 Result.success(null) 仍然会返回状态码 200，因为 Result.success() 的设计是用于表示成功状态的，且你没有抛出任何异常。

//5. 如何让 get() 方法在出错时返回错误信息
你可以通过以下方法来确保在 get() 方法中传入无效的 id 时，抛出异常并触发全局异常处理器：

手动抛出异常：

java
复制代码
@GetMapping(value = &quot;/&#123;id&#125;&quot;)
public Result&lt;User&gt; get(@PathVariable Integer id) &#123;
    User user = userService.getById(id);
    if (user == null) &#123;
        throw new RuntimeException(&quot;User not found with id: &quot; + id);
    &#125;
    return Result.success(user);
&#125;
在 userService.getById(id) 方法中抛出异常：如果你的业务逻辑要求在找不到用户时抛出异常，那么可以在 userService.getById(id) 方法中实现这个逻辑。

//6. 总结
GlobalExceptionHandler 用于捕获和处理全局异常。
当你手动抛出 RuntimeException 或其他异常时，它会捕获并返回带有错误信息的 Result。
在 get() 方法中，如果你想要在找不到用户时返回错误信息，需要手动抛出异常，这样才能触发 GlobalExceptionHandler。
</code></pre>
<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><h6 id="方法一：直接编写使用"><a href="#方法一：直接编写使用" class="headerlink" title="方法一：直接编写使用"></a>方法一：直接编写使用</h6><pre><code class="java">// [配置方法：一种是直接在application.yml文件中配置、另一种是在外置logback-spring.xml文件中配置]
logging:
  pattern:
    console: &quot;%d - %m%n&quot;
</code></pre>
<h6 id="方法二：引用外置xml文件"><a href="#方法二：引用外置xml文件" class="headerlink" title="方法二：引用外置xml文件"></a>方法二：引用外置xml文件</h6><pre><code class="xml">resources/pom.xml               &lt;引用外部的配置&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
&lt;/dependency&gt;

resources/application.yaml
logging:
  config: classpath:logback-spring.xml
</code></pre>
<pre><code class="xml">               &lt;如果你有更多样的配置需求，就需要使用外置XML文件的配置方式&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;

&lt;configuration&gt;

    &lt;!--    日志文件存放路径--&gt;
    &lt;property name=&quot;PATH&quot; value=&quot;C:/Users/Pluminary/Desktop/log&quot;/&gt;

    &lt;!-- 彩色日志依赖的渲染类 --&gt;
    &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot;/&gt;
    &lt;conversionRule conversionWord=&quot;wex&quot;
                    converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;/&gt;
    &lt;conversionRule conversionWord=&quot;wEx&quot;
                    converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;/&gt;
    &lt;!-- 彩色日志格式 --&gt;
    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;
              value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt;
    &lt;!-- 文件日志格式 --&gt;
    &lt;property name=&quot;FILE_LOG_PATTERN&quot;
              value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; -%msg%n&quot;/&gt;

    &lt;!-- 控制台输出配置--&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;!--日志输出格式--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;pattern&gt;
                $&#123;CONSOLE_LOG_PATTERN&#125;
            &lt;/pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;!-- INFO 级别日志文件输出配置--&gt;
    &lt;appender name=&quot;info&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!--按级别过滤日志，只输出 INFO 级别--&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
            &lt;level&gt;INFO&lt;/level&gt;
            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
        &lt;/filter&gt;
        &lt;!--当天日志文件名--&gt;
        &lt;File&gt;$&#123;PATH&#125;/info.log&lt;/File&gt;
        &lt;!--按天分割日志文件--&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!--历史日志文件名规则--&gt;
            &lt;fileNamePattern&gt;$&#123;PATH&#125;/info.log.%d&#123;yyyy-MM-dd&#125;.%i&lt;/fileNamePattern&gt;
            &lt;!--按大小分割同一天的日志--&gt;
            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;
                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
            &lt;!--日志文件保留天数--&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;!--日志输出格式--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;Pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/Pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;!-- ERROR 级别日志文件输出配置--&gt;
    &lt;appender name=&quot;error&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!--按级别过滤日志，只输出 ERROR 及以上级别--&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
            &lt;level&gt;ERROR&lt;/level&gt;
        &lt;/filter&gt;
        &lt;!--当天日志文件名--&gt;
        &lt;File&gt;$&#123;PATH&#125;/error.log&lt;/File&gt;
        &lt;!--按天分割日志文件--&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!--历史日志文件名规则--&gt;
            &lt;fileNamePattern&gt;$&#123;PATH&#125;/error.log.%d&#123;yyyy-MM-dd&#125;.%i&lt;/fileNamePattern&gt;
            &lt;!--按大小分割同一天的日志--&gt;
            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;
                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
            &lt;!--日志文件保留天数--&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;!--日志输出格式--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;Pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/Pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;!--日志级别--&gt;
    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
        &lt;appender-ref ref=&quot;info&quot;/&gt;
        &lt;appender-ref ref=&quot;error&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
                   
                   
&lt;
Logback 能够精确区分并输出特定日志级别的错误，是通过 Appender 配置中的 Filter 机制实现的。在你的 Logback 配置文件中，RollingFileAppender 使用了不同的 Filter 来确保只有指定级别的日志信息会被记录到特定的日志文件中。

工作原理
LevelFilter 和 ThresholdFilter:

LevelFilter: 这个过滤器允许你指定只接受特定日志级别的日志。例如，LevelFilter 被配置为只接受 INFO 级别的日志，而拒绝其他级别的日志。&lt;level&gt;INFO&lt;/level&gt; 表示只记录 INFO 级别的日志。
ThresholdFilter: 这个过滤器允许你指定一个日志级别的下限，只有高于或等于这个级别的日志才会被记录。例如，ThresholdFilter 被配置为只接受 ERROR 级别及以上的日志（例如 ERROR 和 FATAL）。
日志级别的传递:

日志框架从最底层（比如 TRACE）开始逐级向上检查日志的级别，直到它与 Appender 中配置的 Filter 级别匹配。例如，如果一个 ERROR 级别的日志被触发，RollingFileAppender 的 ThresholdFilter 将检测到这个日志并允许它通过，然后将日志写入指定的 error.log 文件。
日志级别匹配:

当应用程序运行时，它会生成不同级别的日志信息（如 DEBUG、INFO、WARN、ERROR 等）。每个 Appender 都会根据它的 Filter 规则检查这些日志条目。只有符合条件的日志条目才会被记录到相应的日志文件中。
&gt;
</code></pre>
<h3 id="AOP切面"><a href="#AOP切面" class="headerlink" title="AOP切面"></a>AOP切面</h3><pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/pcy/controller/AspectController.java
package com.pcy.controller;

import com.pcy.entity.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@RequestMapping(&quot;/aspect&quot;)
public class AspectController &#123;
    @GetMapping
    public Result aspect(String message)&#123;
        log.info(&quot;aspect controller&quot;);
        return Result.success(message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/Swagger/SwaggerConfig.java //【增加&quot;/aspect/**&quot;】
package com.pcy.Swagger;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
// http://localhost:8080/swagger-ui/index.html
@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;, &quot;/exception/**&quot;,&quot;/aspect/**&quot;)
                // .addPathsToMatch(&quot;/exception/**&quot;)
                .build();
    &#125;

    @Bean
    public OpenAPI customOpenAPI() &#123;
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Spring Boot 实战&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Spring Boot 实战的 RESTFul 接口文档说明&quot;)
                        .contact(new Contact()
                                .name(&quot;Pluminary&quot;)
                                .url(&quot;https://github.com/P-luminary&quot;)
                                .email(&quot;390415030@qq.com&quot;)));
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/utils/WebAspect.java
package com.pcy.utils;

import com.pcy.entity.Result;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@Aspect
@Component
public class WebAspect &#123;
// ★★★★★★★★★★★ 一定要注意这个AOP切面扫描的包 ★★★★★★★★★★★
    @Pointcut(&quot;execution(public * com.pcy.controller.*.*(..))&quot;)
    public void pointCut() &#123;
    &#125;

    @Before(value = &quot;pointCut()&quot;)
    public void before(JoinPoint joinPoint) &#123;
        System.out.println(&quot;======================================== 这是@Before ========================================&quot;);
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getName();
        Object[] args = joinPoint.getArgs();
        String[] parameterNames = ((MethodSignature) joinPoint.getSignature()).getParameterNames();

        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();

        Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; parameterNames.length; i++) &#123;
            paramMap.put(parameterNames[i], args[i]);
        &#125;

        log.info(&quot;before path：&#123;&#125;&quot;,request.getServletPath());
        log.info(&quot;before class name：&#123;&#125;&quot;,className);
        log.info(&quot;before method name：&#123;&#125;&quot;,methodName);
        log.info(&quot;before args：&#123;&#125;&quot;,paramMap.toString());
    &#125;

    @After(value = &quot;pointCut()&quot;)
    public void after(JoinPoint joinPoint) &#123;
        System.out.println(&quot;======================================== 这是@After =========================================&quot;);
        log.info(&quot;&#123;&#125; after&quot;, joinPoint.getSignature().getName());
    &#125;

    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;returnVal&quot;)
    public void afterReturning(JoinPoint  joinPoint, Object returnVal) &#123;
        System.out.println(&quot;==================================== 这是@AfterReturning ====================================&quot;);
        log.info(&quot;&#123;&#125; after return, returnVal: &#123;&#125;&quot;, joinPoint.getSignature().getName(), returnVal);
    &#125;
&#125;

/*
2024-08-14 18:28:20.249  INFO 3296 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
2024-08-14 18:28:20.249  INFO 3296 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#39;dispatcherServlet&#39;
2024-08-14 18:28:20.250  INFO 3296 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
2024-08-14 18:28:20.261  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：18:28:20:261 毫秒
======================================== 这是@Before ========================================
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before path：/aspect
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before method name：aspect
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before args：&#123;message=www&#125;
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.controller.AspectController      : aspect controller
==================================== 这是@AfterReturning ====================================
2024-08-14 18:28:20.279  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : aspect after return, returnVal: Result(code=200, message=操作成功, data=www)
======================================== 这是@After =========================================
2024-08-14 18:28:20.280  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : aspect after
2024-08-14 18:28:20.308  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：18:28:20:308 毫秒
2024-08-14 18:28:20.308  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-14 18:28:20.309  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：47 毫秒

*/
</code></pre>
<h6 id="若是调用UserController的get接口"><a href="#若是调用UserController的get接口" class="headerlink" title="若是调用UserController的get接口"></a>若是调用UserController的get接口</h6><pre><code class="java">com/pcy/controller/UserController.java
...
    @Operation(summary = &quot;根据ID获取用户信息&quot;, description = &quot;通过用户ID获取用户详细信息&quot;)
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    public User get(@PathVariable int id) &#123;
        return userRepository.findById(id).orElse(null);
    &#125;
...

Console控制台的报错信息：
/*
2024-08-14 18:33:22.383  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：18:33:22:383 毫秒
======================================== 这是@Before ========================================
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before path：/users/user/2
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.UserController
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before method name：get
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before args：&#123;id=2&#125;
==================================== 这是@AfterReturning ====================================
2024-08-14 18:33:22.425  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : get after return, returnVal: User(id=2, name=we2, age=2, email=2, birthDay=2024-08-10)
======================================== 这是@After =========================================
2024-08-14 18:33:22.426  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : get after
2024-08-14 18:33:22.428  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：18:33:22:428 毫秒
2024-08-14 18:33:22.428  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-14 18:33:22.428  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：45 毫秒
*/
</code></pre>
<h6 id="异常善后处理"><a href="#异常善后处理" class="headerlink" title="异常善后处理"></a>异常善后处理</h6><pre><code class="java">com/pcy/controller/AspectController.java //【浏览exception接口的时候会报错】
package com.pcy.controller;

import com.pcy.entity.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@RequestMapping(&quot;/aspect&quot;)
public class AspectController &#123;
    @GetMapping
    public Result aspect(String message)&#123;
        log.info(&quot;aspect controller&quot;);
        return Result.success(message);
    &#125;
    @GetMapping(&quot;/exception&quot;)
    public Result exception()&#123;//抛出异常
        throw new RuntimeException(&quot;runtime exception&quot;);
    &#125;
&#125;


/*
======================================== 这是@Before ========================================
2024-08-15 15:09:20.586  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before path：/aspect/exception
2024-08-15 15:09:20.586  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-15 15:09:20.586  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before method name：exception
2024-08-15 15:09:20.587  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before args：&#123;&#125;
2024-08-15 15:09:20.587  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : exception after throwing, message: runtime exception
======================================== 这是@After =========================================
2024-08-15 15:09:20.587  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : exception after
2024-08-15 15:09:20.588 ERROR 4200 --- [nio-8080-exec-4] com.pcy.utils.GlobalExceptionHandler     : runtime exception
*/
</code></pre>
<pre><code class="java">com/pcy/utils/WebAspect.java
@AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;e&quot;)
    public void afterThrowing(JoinPoint  joinPoint, Exception e) &#123;
        log.info(&quot;&#123;&#125; after throwing, message: &#123;&#125;&quot;, joinPoint.getSignature().getName(), e.getMessage());
    &#125;
</code></pre>
<h6 id="综上所述：after方法不关心方法是否成功，当方法执行完成之后就会被执行；afterReturning方法必须在目标方法成果return之后才会被执行；afterThrowing方法则会在目标方法抛出异常后被执行"><a href="#综上所述：after方法不关心方法是否成功，当方法执行完成之后就会被执行；afterReturning方法必须在目标方法成果return之后才会被执行；afterThrowing方法则会在目标方法抛出异常后被执行" class="headerlink" title="综上所述：after方法不关心方法是否成功，当方法执行完成之后就会被执行；afterReturning方法必须在目标方法成果return之后才会被执行；afterThrowing方法则会在目标方法抛出异常后被执行"></a><span style = "color:red">综上所述：<span style = "color:blue">after</span>方法不关心方法是否成功，当方法执行完成之后就会被执行；<span style = "color:blue">afterReturning</span>方法必须在目标方法成果return之后才会被执行；<span style = "color:blue">afterThrowing</span>方法则会在目标方法抛出异常后被执行</span></h6><h5 id="性能统计"><a href="#性能统计" class="headerlink" title="性能统计"></a>性能统计</h5><blockquote>
<p>Around可以囊括以上所有能力</p>
</blockquote>
<pre><code class="java">com/pcy/controller/AspectController.java
@Slf4j
@RestController
@RequestMapping(&quot;/aspect&quot;)
public class AspectController &#123;
  @GetMapping(&quot;/sleep/&#123;time&#125;&quot;)
    public Result sleep(@PathVariable(&quot;time&quot;) long time) &#123;
        log.info(&quot;sleep&quot;);
        try &#123;
            Thread.sleep(time);
        &#125; catch (InterruptedException e) &#123;
           log.error(&quot;error&quot;, e);
        &#125;
        if (time == 1000) &#123;
            throw new RuntimeException(&quot;runtime exception&quot;);
        &#125;
        log.info(&quot;wake up&quot;);
        return Result.success(&quot;wake up&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Around(&quot;pointCut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) &#123;
        log.info(&quot;around start&quot;);
        long startTime = System.currentTimeMillis();
        Object result = null;
        try &#123;
            result = joinPoint.proceed();
        &#125; catch (Throwable e) &#123;
            log.error(&quot;around error&quot;,e);
        &#125;
        long endTime = System.currentTimeMillis();
        log.info(&quot;execute time：&#123;&#125; ms&quot;,endTime - startTime);
        return result;
    &#125;
</code></pre>
<pre><code class="java">//【当输入time值为2004时】
2024-08-15 15:27:21.987  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：15:27:21:987 毫秒
2024-08-15 15:27:21.990  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : around start
======================================== 这是@Before ========================================
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before path：/aspect/sleep/2004
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before method name：sleep
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before args：&#123;time=2004&#125;
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.controller.AspectController      : sleep
2024-08-15 15:27:23.996  INFO 10844 --- [nio-8080-exec-6] com.pcy.controller.AspectController      : wake up
==================================== 这是@AfterReturning ====================================
2024-08-15 15:27:23.997  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : sleep after return, returnVal: Result(code=200, message=操作成功, data=wake up)
======================================== 这是@After =========================================
2024-08-15 15:27:23.997  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : sleep after
2024-08-15 15:27:23.997  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : execute time：2007 ms
2024-08-15 15:27:23.999  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：15:27:23:999 毫秒
2024-08-15 15:27:23.999  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-15 15:27:23.999  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：12 毫秒


//【当输入time值为1000时】
2024-08-15 15:28:19.596  INFO 10844 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：15:28:19:596 毫秒
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : around start
======================================== 这是@Before ========================================
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before path：/aspect/sleep/1000
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before method name：sleep
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before args：&#123;time=1000&#125;
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.controller.AspectController      : sleep
2024-08-15 15:28:20.607  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : sleep after throwing, message: runtime exception
======================================== 这是@After =========================================
2024-08-15 15:28:20.607  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : sleep after
2024-08-15 15:28:20.607 ERROR 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : around error

java.lang.RuntimeException: runtime exception
    at com.pcy.controller.AspectController.sleep(AspectController.java:32)
    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
    at java.base/java.lang.reflect.Method.invoke(Method.java:578)
......
</code></pre>
<h6 id="同一切面内的执行顺序"><a href="#同一切面内的执行顺序" class="headerlink" title="同一切面内的执行顺序"></a>同一切面内的执行顺序</h6><blockquote>
<p>先执行before方法，再执行afterReturning &#x2F; afterThrowing方法，最后执行after方法<br>要验证的关键点是around方法和它们之间的先后关系</p>
<p>around方法早于before方法开始执行，并且晚于after方法结束执行，刚好将其他同志完全包裹了起来</p>
</blockquote>
<pre><code class="java">//【注释掉WebAspect.java里面的代码不然会叠叠乐累加】
com/pcy/utils/AspectOne.java
package com.pcy.utils;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Slf4j
@Aspect
@Component
public class AspectOne &#123;
    @Pointcut(&quot;execution(public * com.pcy.controller.*.*(..))&quot;)
    public void pointCut()&#123;&#125;
    @Before(value = &quot;pointCut()&quot;)
    public void before()&#123;
        log.info(&quot;before one&quot;);
    &#125;
    @After(value = &quot;pointCut()&quot;)
    public void after()&#123;
        log.info(&quot;after one&quot;);
    &#125;
    @AfterReturning(value = &quot;pointCut()&quot;)
    public void afterReturning()&#123;
        log.info(&quot;afterReturning one&quot;);
    &#125;

    @Around(value = &quot;pointCut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) &#123;
        log.info(&quot;around one start&quot;);
        Object result = null;
        try &#123;
            result = joinPoint.proceed();
        &#125; catch (Throwable e) &#123;
            log.error(&quot;around error&quot;, e);
        &#125;
        log.info(&quot;around one end&quot;);
        return result;
    &#125;
&#125;

/*
2024-08-15 16:12:12.819  INFO 28788 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
2024-08-15 16:12:12.819  INFO 28788 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#39;dispatcherServlet&#39;
2024-08-15 16:12:12.820  INFO 28788 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 0 ms
2024-08-15 16:12:12.839  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：16:12:12:839 毫秒
2024-08-15 16:12:12.864  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : around one start
2024-08-15 16:12:12.864  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : before one
2024-08-15 16:12:12.864  INFO 28788 --- [nio-8080-exec-1] com.pcy.controller.AspectController      : aspect controller
2024-08-15 16:12:12.865  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : afterReturning one
2024-08-15 16:12:12.865  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : after one
2024-08-15 16:12:12.865  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : around one end
2024-08-15 16:12:12.908  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：16:12:12:908 毫秒
2024-08-15 16:12:12.909  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-15 16:12:12.909  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：69 毫秒
*/
</code></pre>
<h6 id="不同切面间的执行顺序"><a href="#不同切面间的执行顺序" class="headerlink" title="不同切面间的执行顺序"></a>不同切面间的执行顺序</h6><blockquote>
<p>将AspectOne复制两份命名AspectTwo和AspectThree [<strong>执行后是One→Three→Two</strong>]<br>在Spring中的加载顺序是根据类名升序排列的，Three字母排序排在Two前面<br>那如何指定执行顺序按照One Two Three？<br>分别为AspectOne&#x2F;Two&#x2F;Three加上@Order(1)，@Order(2)，@Order(3)</p>
</blockquote>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h6 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h6><pre><code class="xml">pom.xml
       &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
                    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">spring:
  application:
    name: Pluminary
  datasource:
    driver-class-name: org.mariadb.jdbc.Driver
    url: jdbc:mariadb://localhost:3306/pcy?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;nullCatalogMeansCurrent=true
    username: root
    password: root

    redis:
      host: localhost port:6379
      connect-timeout: 1000
      jedis:
        pool:
          min-idle: 5
          max-active: 10
          max-idle: 10
          max-wait: 2000
</code></pre>
<pre><code class="java">com/pcy/controller/HelloController.java
@Slf4j
@RestController
@RequestMapping(&quot;/test&quot;)
public class HelloController &#123;
 @Autowired
    private StringRedisTemplate stringRedisTemplate;
    @GetMapping(&quot;/hello&quot;)
    public String hello()&#123;
        stringRedisTemplate.opsForValue().set(&quot;hello&quot;,&quot;world&quot;);
        return stringRedisTemplate.opsForValue().get(&quot;hello&quot;);
    &#125;
&#125;

//先访问hello接口 再去redis-cli中尝试访问自己定义的内容
http://localhost:8080/swagger-ui/index.html#/hello-controller/hello

/*
127.0.0.1:6379&gt; get hello
&quot;world&quot;
*/
</code></pre>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/pcy/controller/HelloController.java
package com.pcy.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
@Slf4j
@RestController
@RequestMapping(&quot;/test&quot;)
public class HelloController &#123;
    @GetMapping(&quot;/hi&quot;)
//  http://localhost:8080/hi
    public String hi()&#123;
        log.info(&quot;hi&quot;);
        return &quot;ok!&quot;;
    &#125;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    @GetMapping(&quot;/hello&quot;)
    public String hello()&#123;
        stringRedisTemplate.opsForValue().set(&quot;hello&quot;,&quot;world&quot;);
        return stringRedisTemplate.opsForValue().get(&quot;hello&quot;);
    &#125;
&#125;

/* Console:
Using generated security password: 4147707e-58d6-46d9-b5cc-19865a2c523f
*/

账号：user
密码：4147707e-58d6-46d9-b5cc-19865a2c523f
</code></pre>
<pre><code class="java">com/pcy/config/SecurityConfig.java
package com.pcy.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;

    // 配置HTTP安全性
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeRequests(authorizeRequests -&gt;
                        authorizeRequests
//          .antMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll() // 允许访问Swagger UI和API文档
                                .anyRequest().authenticated() // 所有请求都需要认证
                )
                .httpBasic(withDefaults()); // 使用HTTP Basic认证

        return http.build();
    &#125;

    // 配置认证管理器
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception &#123;
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .inMemoryAuthentication()
                .withUser(&quot;pcy&quot;)
                .password(passwordEncoder().encode(&quot;123456&quot;))
                .roles(&quot;admin&quot;);

        return authenticationManagerBuilder.build();
    &#125;

    // 配置密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() &#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;

/*
你可能无法访问 http://localhost:8080/swagger-ui/index.html 的原因可能与 Spring Security 配置有关。由于你启用了 Spring Security，默认情况下，所有请求都需要经过身份认证，这可能会阻止你访问 Swagger UI。

为了确保你能够访问 Swagger UI，你需要在 Spring Security 的配置中添加一个例外规则，允许对 /swagger-ui/** 和相关的 Swagger 资源进行无认证访问。

添加代码：.antMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll()


账号：pcy
密码：123456
*/
</code></pre>
<h3 id="从数据库中获取用户信息"><a href="#从数据库中获取用户信息" class="headerlink" title="从数据库中获取用户信息"></a>从数据库中获取用户信息</h3><pre><code class="java">com/pcy/config/SecurityConfig.java
package com.pcy.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;
    @Autowired
    private UserDetailsService userDetailsService; // 使用 Spring Security 的 UserDetailsService

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeHttpRequests(authorizeRequests -&gt;
                        authorizeRequests
                                .anyRequest().authenticated()
                )
                .userDetailsService(userDetailsService) // 设置 UserDetailsService
                .httpBasic(withDefaults())
                .csrf(csrf -&gt; csrf.disable());

        return http.build();
    &#125;

    // 配置认证管理器
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception &#123;
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .userDetailsService(userDetailsService)  // 使用数据库中的用户信息
                .passwordEncoder(passwordEncoder());

        return authenticationManagerBuilder.build();
    &#125;

    // 配置密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() &#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/UserDetailsServiceImpl.java
package com.pcy.service.impl;

import com.baomidou.mybatisplus.core.toolkit.Wrappers;
import com.pcy.entity.SysUser;
import com.pcy.service.SysUserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
//确保你的 UserDetailsServiceImpl 类被 Spring 管理，且实现了 Spring Security 的 UserDetailsService 接口
@Service
public class UserDetailsServiceImpl implements UserDetailsService  &#123;

    @Autowired
    private SysUserService sysUserService;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
        SysUser sysUser = sysUserService.getOne(Wrappers.&lt;SysUser&gt;lambdaQuery().eq(SysUser::getUsername, username));
        if (sysUser == null) &#123;
            throw new UsernameNotFoundException(&quot;User not found with username: &quot; + username);
        &#125;
        return User.builder()
                .username(sysUser.getUsername())
                .password(sysUser.getPassword())
                .authorities(AuthorityUtils.commaSeparatedStringToAuthorityList(sysUser.getRole()))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/entity/SysUser.java
package com.pcy.entity;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.extension.activerecord.Model;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

import java.io.Serializable;

@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@Schema(name = &quot;SysUser对象&quot;, description = &quot;系统用户表&quot;)
public class SysUser extends Model&lt;SysUser&gt; &#123;

    private static final long serialVersionUID = 1L;

    @Schema(description = &quot;主键 id&quot;)
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Integer id;

    @Schema(description = &quot;用户名&quot;)
    private String username;

    @Schema(description = &quot;密码&quot;)
    private String password;

    @Schema(description = &quot;角色&quot;)
    private String role;


    @Override
    public Serializable pkVal() &#123;
        return this.id;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/SysUserService.java
package com.pcy.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.pcy.entity.SysUser;

public interface SysUserService extends IService&lt;SysUser&gt; &#123;
    String getCurrentUser();
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/SysUserServiceImpl.java
package com.pcy.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.pcy.common.ApiException;
import com.pcy.entity.SysUser;
import com.pcy.mapper.SysUserMapper;
import com.pcy.service.SysUserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
@Slf4j
@Service
public class SysUserServiceImpl extends ServiceImpl&lt;SysUserMapper, SysUser&gt; implements SysUserService &#123;
    @Override
    public String getCurrentUser() &#123;
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        // 非匿名用户访问才能获得用户信息
        if (!(authentication instanceof AnonymousAuthenticationToken)) &#123;
            String userName = authentication.getName();
            log.info(&quot;userName by SecurityContextHolder: &#123;&#125;&quot;, userName);
            return userName;
        &#125;
        throw new ApiException(&quot;用户不存在！&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/mapper/SysUserMapper.java
package com.pcy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.pcy.entity.SysUser;

/**
 * &lt;p&gt;
 * 系统用户表 Mapper 接口
 * &lt;/p&gt;
 */
public interface SysUserMapper extends BaseMapper&lt;SysUser&gt; &#123;

&#125;
</code></pre>
<pre><code class="java">com/pcy/common/ApiException.java
package com.pcy.common;

import com.pcy.entity.MessageEnum;
import lombok.Data;

@Data
public class ApiException extends RuntimeException &#123;

    private Integer code;

    public ApiException(MessageEnum messageEnum) &#123;
        super(messageEnum.getMessage());
        this.code = messageEnum.getCode();
    &#125;

    public ApiException(String message) &#123;
        super(message);
        this.code = 500;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//【由于数据库的密码要被加密后的形式保存到数据中】
com/pcy/common/test.java
package com.pcy.common;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

public class test &#123;
    public static void main(String[] args) &#123;
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        String encodedPassword = encoder.encode(&quot;123456&quot;);
        System.out.println(encodedPassword);
    &#125;
&#125;

//$2a$10$GzDPdLyrzC9NudmE937AAetR2bef2VQzuSbP6KM6Y.I3045OuT/xC
</code></pre>
<h6 id="修改创建SysUser用户的时候用Spring-Security-登录的时候就可以用自己创建的了"><a href="#修改创建SysUser用户的时候用Spring-Security-登录的时候就可以用自己创建的了" class="headerlink" title="修改创建SysUser用户的时候用Spring Security [登录的时候就可以用自己创建的了]"></a>修改创建SysUser用户的时候用Spring Security [登录的时候就可以用自己创建的了]</h6><pre><code class="java">com/pcy/controller/UserController.java
/* 对比User数据
    @Operation(summary = &quot;创建User用户&quot;, description = &quot;创建一个新的User用户&quot;)
    @PostMapping(&quot;/create/&quot;)
    public User create(@RequestBody User User) &#123;
        return userRepository.save(User);
    &#125;
*/
    @Autowired
    private SysUserService sysUserService;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Operation(summary = &quot;创建SysUser用户&quot;, description = &quot;创建一个新的SysUser用户&quot;)
    @PostMapping(&quot;/create/test&quot;)
    public SysUser create(@RequestBody SysUser sysUser) &#123;
        sysUser.setPassword(passwordEncoder.encode(sysUser.getPassword()));
        sysUserService.save(sysUser);
        return sysUser;
    &#125;
</code></pre>
<pre><code class="java">package com.pcy.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.pcy.entity.SysUser;
public interface SysUserService extends IService&lt;SysUser&gt;&#123;

    String getCurrentUser();
&#125;
</code></pre>
<pre><code class="java">@Slf4j
@Service
public class SysUserServiceImpl extends ServiceImpl&lt;SysUserMapper, SysUser&gt; implements SysUserService &#123;

 @Override
    public boolean save(SysUser sysUser) &#123;
        return SqlHelper.retBool(this.baseMapper.insert(sysUser));
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/mapper/SysUserMapper.java
package com.pcy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.pcy.entity.SysUser;

/**
 * &lt;p&gt;
 * 系统用户表 Mapper 接口
 * &lt;/p&gt;
 */
public interface SysUserMapper extends BaseMapper&lt;SysUser&gt; &#123;

&#125;
</code></pre>
<h6 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h6><pre><code class="java">com/pcy/config/SecurityConfig.java
package com.pcy.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;
    @Autowired
    private UserDetailsService userDetailsService; // 使用 Spring Security 的 UserDetailsService

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeHttpRequests(authorizeRequests -&gt; authorizeRequests
                        .requestMatchers(&quot;/security/permitall&quot;).permitAll() // 允许所有人访问
                        .requestMatchers(&quot;/security/anonymous&quot;).anonymous() // 仅允许匿名用户访问
                        .requestMatchers(&quot;/security/config&quot;).hasAuthority(&quot;ROLE_config&quot;) // 仅拥有 ROLE_config 权限的用户可以访问
                        .requestMatchers(&quot;/security/Secured&quot;).hasRole(&quot;Secured&quot;) // 仅拥有 ROLE_Secured 的用户可以访问
                        .requestMatchers(&quot;/security/preAuthorize&quot;).hasAuthority(&quot;PreAuthorize&quot;) // 仅拥有 PreAuthorize 权限的用户可以访问
                        .anyRequest().authenticated() // 其他所有请求需要认证
                )
                .userDetailsService(userDetailsService) // 设置 UserDetailsService
                .httpBasic(withDefaults()) // 使用 HTTP Basic 认证
                .csrf(csrf -&gt; csrf.disable()); // 禁用 CSRF

        return http.build();
    &#125;

    // 配置认证管理器
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception &#123;
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .userDetailsService(userDetailsService)  // 使用数据库中的用户信息
                .passwordEncoder(passwordEncoder());

        return authenticationManagerBuilder.build();
    &#125;

    // 配置密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() &#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/controller/SecurityController.java
package com.pcy.controller;

import com.pcy.entity.Result;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.security.access.annotation.Secured;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/security&quot;)
@Tag(name = &quot;权限控制&quot;, description = &quot;权限控制&quot;)
public class SecurityController &#123;
    // Anyone
    @Operation(summary = &quot;permitAll 权限&quot;)
    @GetMapping(value = &quot;/permitall&quot;)
    public Result&lt;String&gt; permitAll()&#123;
        return Result.success(&quot;permitAll&quot;);
    &#125;
    // 未登录时可以访问
    @Operation(summary = &quot;anonymous 权限&quot;)
    @GetMapping(value = &quot;/anonymous&quot;)
    public Result&lt;String&gt; anonymous()&#123;
        return Result.success(&quot;anonymous&quot;);
    &#125;
    // xiaopan可以访问
    @Operation(summary = &quot;config 权限&quot;)
    @GetMapping(value = &quot;/config&quot;)
    public Result&lt;String&gt; config()&#123;
        return Result.success(&quot;permitAll&quot;);
    &#125;
    // xiaochun可以访问
    @Operation(summary = &quot;Secured 权限&quot;)
    @GetMapping(value = &quot;/Secured&quot;)
    @Secured(&#123;&quot;ROLE_Secured&quot;&#125;)
    public Result&lt;String&gt; Secured()&#123;
        return Result.success(&quot;Secured&quot;);
    &#125;
    // panchunyao可以访问
    @Operation(summary = &quot;PreAuthorize 权限&quot;)
    @GetMapping(value = &quot;/preAuthorize&quot;)
    @PreAuthorize(&quot;hasAnyAuthority(&#39;PreAuthorize&#39;)&quot;)
    public Result&lt;String&gt; PreAuthorize()&#123;
        return Result.success(&quot;PreAuthorize&quot;);
    &#125;
&#125;

/*
首先，确保在数据库中创建几个测试用户，并为每个用户分配不同的角色或权限。假设你有以下几个用户：
User 1: Username: xiaopan, Password: 123456, Role: ROLE_config
User 2: Username: xiaochun, Password: 123456, Role: ROLE_Secured
User 3: Username: panchun, Password: 123456, Authority: PreAuthorize

尝试使用不同用户登录:
使用 xiaopan 登录后，尝试访问 /security/config。
使用 xiaochun 登录后，尝试访问 /security/Secured。
使用 panchunyao 登录后，尝试访问 /security/preAuthorize。

检查响应:
/security/config: 只有 xiaopan 能访问，其他用户会被拒绝访问。
/security/Secured: 只有 xiaochun 能访问，其他用户会被拒绝访问。
/security/preAuthorize: 只有 panchunyao 能访问，其他用户会被拒绝访问。
/security/permitall: 所有用户都可以访问。
/security/anonymous: 只有未登录的用户可以访问，登录的用户会被拒绝。

验证权限控制
每个请求的响应应该反映你在 SecurityConfig 中配置的权限。
如果用户没有适当的角色或权限，应该会返回 403 Forbidden 或其他错误响应。
*/
</code></pre>
<pre><code class="java">@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;, &quot;/exception/**&quot;,&quot;/aspect/**&quot;,&quot;/test/**&quot;,&quot;/security/**&quot;)
                // .addPathsToMatch(&quot;/exception/**&quot;)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 【问答环节】
我的数据库创建的是Role字段但是为什么 下面这些有.hasAuthority 有.hasRole 还有其他的 这是怎么匹配到我数据库 按照你的方式设置的数据的

/*
1. hasRole() 和 hasAuthority() 的区别

hasRole(String role):
hasRole 方法通常用于检查用户是否拥有特定的角色。
Spring Security 会在你传递的角色名称前自动加上 &quot;ROLE_&quot; 前缀。因此，当你使用 hasRole(&quot;Secured&quot;) 时，实际上它会检查用户是否有 &quot;ROLE_Secured&quot; 这个权限。

hasAuthority(String authority):
hasAuthority 方法用于检查用户是否拥有特定的权限（或授权）。
hasAuthority 不会自动添加任何前缀。所以当你使用 hasAuthority(&quot;ROLE_config&quot;) 时，它会直接匹配 &quot;ROLE_config&quot;，而不会添加任何前缀。


2. 匹配数据库中的角色和权限
hasRole(&quot;Secured&quot;):
代码中的 hasRole(&quot;Secured&quot;) 实际上会匹配数据库中的 ROLE_Secured，因为 hasRole 方法会自动加上 &quot;ROLE_&quot; 前缀。

hasAuthority(&quot;ROLE_config&quot;):
代码中的 hasAuthority(&quot;ROLE_config&quot;) 会直接匹配数据库中的 &quot;ROLE_config&quot;，没有任何前缀变化。

hasAuthority(&quot;PreAuthorize&quot;):
代码中的 hasAuthority(&quot;PreAuthorize&quot;) 会直接匹配数据库中的 &quot;PreAuthorize&quot;，因为没有添加任何前缀。
*/
    
它为什么能查到我数据库的role字段里面的数据 如果我把这个字段换成test这个名字 它又是怎么去匹配到的呢
/*
Spring Security 默认会使用 UserDetails 接口中的 getAuthorities() 方法来获取用户的权限或角色信息。这些权限或角色信息通常是通过你在 UserDetailsService 实现类中定义的逻辑从数据库中获取的。
而在SecurityConfig中有代码：
@Autowired // 使用 Spring Security 的UserDetailsService
private UserDetailsService userDetailsService; 
回顾securityFilterChain代码
下面会有 .userDetailsService(userDetailsService) // 设置 UserDetailsService

Spring Security 本身并不直接访问你的数据库表或字段。它依赖于你在 UserDetailsService 中提供的 UserDetails 对象的 getAuthorities() 方法的返回值。因此，当你在 SecurityConfig 中使用 hasRole() 或 hasAuthority() 方法时，它实际上是在检查用户的权限信息，即 UserDetails 对象中的 authorities。
===========================================================================
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
    SysUser sysUser = sysUserService.getOne(Wrappers.&lt;SysUser&gt;lambdaQuery().eq(SysUser::getUsername, username));
    if (sysUser == null) &#123;
        throw new UsernameNotFoundException(&quot;User not found with username: &quot; + username);
    &#125;
    return User.builder()
            .username(sysUser.getUsername())
            .password(sysUser.getPassword())
            .authorities(AuthorityUtils.commaSeparatedStringToAuthorityList(sysUser.getTest()))  // 修改为使用 &#39;test&#39; 字段
            .build();
&#125;

*/
</code></pre>
<h3 id="记住我-√-Remember-Me"><a href="#记住我-√-Remember-Me" class="headerlink" title="记住我               √ Remember Me"></a>记住我               √ Remember Me</h3><h6 id="基于SpringSession的方式"><a href="#基于SpringSession的方式" class="headerlink" title="基于SpringSession的方式"></a>基于SpringSession的方式</h6><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
            &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">//【要新搞个登录界面 .ftl】
application.yaml

spring:
  freemarker:
    template-loader-path: /templates/
    suffix: .ftl
</code></pre>
<pre><code class="html">resources/templates/loginPage.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Login&lt;/h1&gt;
&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;
    &lt;div&gt;
        &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;
        &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; required&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;
        &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; required&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;input type=&quot;checkbox&quot; id=&quot;remember-me&quot; name=&quot;remember-me&quot;&gt;
        &lt;label for=&quot;remember-me&quot;&gt;Remember me&lt;/label&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/pcy/controller/LoginController.java
package com.pcy.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class LoginController &#123;
    @GetMapping(&quot;/login&quot;) // 修改为 &quot;/custom-login&quot;
    public String login() &#123;
        return &quot;loginPage&quot;; // 返回的视图名仍然是 &quot;loginPage&quot;
    &#125;
&#125;

/*
http://localhost:8080/login

Please sign in
Username
    panchunyao
Password
    •••••••••••••
√ Remember me on this computer.


127.0.0.1:6379&gt; keys spring*
1) &quot;spring:session:sessions:96c83240-f939-4fd1-ac2c-93542f883aef&quot;
2) &quot;spring:session:sessions:56baf3c6-7a5c-483b-b04a-422b8a2be1b7&quot;
*/
</code></pre>
<pre><code class="java">com/pcy/config/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;
    @Autowired
    private UserDetailsService userDetailsService; // 使用 Spring Security 的 UserDetailsService

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeHttpRequests(authorizeRequests -&gt; authorizeRequests
                        .requestMatchers(&quot;/security/permitall&quot;).permitAll() // 允许所有人访问
                        .requestMatchers(&quot;/security/anonymous&quot;).anonymous() // 仅允许匿名用户访问
                        .requestMatchers(&quot;/security/config&quot;).hasAuthority(&quot;ROLE_config&quot;) // 仅拥有 ROLE_config 权限的用户可以访问
                        .requestMatchers(&quot;/security/Secured&quot;).hasRole(&quot;Secured&quot;) // 仅拥有 ROLE_Secured 的用户可以访问
                        .requestMatchers(&quot;/security/preAuthorize&quot;).hasAuthority(&quot;PreAuthorize&quot;) // 仅拥有 PreAuthorize 权限的用户可以访问
                        .anyRequest().authenticated() // 其他所有请求需要认证
                )
                .formLogin(form -&gt; form
//                        .loginPage(&quot;/custom-login&quot;) // 将登录页面的路径改为 &quot;/custom-login&quot; 打开会循环重定向
                        .defaultSuccessUrl(&quot;http://localhost:8080/swagger-ui/index.html&quot;, true) // 登录成功后的跳转路径
                        .permitAll()
                )
                .rememberMe(rememberMe -&gt; rememberMe
                        .rememberMeServices(rememberMeServices()) // 配置 Remember Me 服务
                )
                .userDetailsService(userDetailsService) // 设置 UserDetailsService
                .httpBasic(withDefaults()) // 使用 HTTP Basic 认证
                .csrf(csrf -&gt; csrf.disable()); // 禁用 CSRF

        return http.build();
    &#125;
&#125;
......
</code></pre>
<pre><code class="java">//【问答环节】
分析一下freemarker这个配置的含义
    freemarker:
      template-loader-path: /templates/
      suffix: .ftl
/*
这些配置项的含义如下：
template-loader-path: /templates/: 这个配置指定了 Freemarker 模板文件的加载路径，也就是 /templates/ 目录。Spring Boot 会在这个目录下寻找所有的 .ftl 模板文件。

suffix: .ftl: 这个配置指定了 Freemarker 模板文件的文件后缀，也就是 .ftl。在控制器中返回视图名称时，Spring 会自动添加这个后缀来查找相应的模板文件。


配置的工作原理
@Controller
public class LoginController &#123;
    @GetMapping(&quot;/login&quot;)
    public String login() &#123;
        return &quot;loginPage&quot;; // 返回的视图名
    &#125;
&#125;
在 LoginController 中的 login() 方法中，你返回的是 &quot;loginPage&quot;：
因为在 application.yaml 中已经配置了 template-loader-path 和 suffix，Spring Boot 会根据这些配置来查找模板文件：
它会在 template-loader-path 配置的 /templates/ 目录下寻找文件。
它会在视图名称 &quot;loginPage&quot; 后面自动添加 .ftl 后缀。
因此，最终 Spring Boot 会查找路径 /templates/loginPage.ftl，并使用这个模板文件来渲染登录页面。这就是为什么当你在控制器中返回 &quot;loginPage&quot; 时，Freemarker 能正确地找到并渲染 loginPage.ftl 模板。

如果你想修改 Freemarker 模板文件的目录或后缀，可以调整 application.yaml 中的相应配置。
视图名称在 return 中不需要包含目录或后缀，Spring 会根据配置自动处理。
*/
</code></pre>
<h1 id="SpringBoot-Vue企业级狐狸"><a href="#SpringBoot-Vue企业级狐狸" class="headerlink" title="SpringBoot + Vue企业级狐狸"></a>SpringBoot + Vue企业级狐狸</h1><pre><code class="mysql">@RequestMapping 注解指定控制器类中的方法可以处理哪些格式的URL请求
@RequestMapping(&quot;/hello&quot;) 说明该方法将接收并处理格式为/hello的HTTP请求
@RestController 注解指定本类承担着SpringBoot项目的&#39;控制器&#39;效果
</code></pre>
<table>
<thead>
<tr>
<th>包名</th>
<th>所放置的业务代码类型</th>
</tr>
</thead>
<tbody><tr>
<td>common</td>
<td>放置了通用的参数和业务方法</td>
</tr>
<tr>
<td>controller</td>
<td>放置了针对各业务请求的控制类</td>
</tr>
<tr>
<td>domain</td>
<td>放置了各种业务实体类</td>
</tr>
<tr>
<td>mapper</td>
<td>放置了针对MyBatis框架的映射关系类</td>
</tr>
<tr>
<td>service</td>
<td>放置了诸多实现业务逻辑的类</td>
</tr>
</tbody></table>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/10/21/后端/SpringBoot趣味实战课/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/09/28/后端/苍穹外卖/">
        <h2>
            苍穹外卖
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/9/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="苍穹外卖"><a href="#苍穹外卖" class="headerlink" title="苍穹外卖"></a>苍穹外卖</h1><h3 id="软件开发整体介绍"><a href="#软件开发整体介绍" class="headerlink" title="软件开发整体介绍"></a>软件开发整体介绍</h3><h4 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h4><h6 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h6><ul>
<li>需求规格说明书(word)、产品原型</li>
</ul>
<h6 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h6><ul>
<li>UI设计、数据库设计、接口设计</li>
</ul>
<h6 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h6><ul>
<li>项目代码、单元测试</li>
</ul>
<h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><ul>
<li>测试用例、测试报告</li>
</ul>
<h6 id="上线运维"><a href="#上线运维" class="headerlink" title="上线运维"></a>上线运维</h6><ul>
<li>软件环境安装、配置</li>
</ul>
<h5 id="角色分工"><a href="#角色分工" class="headerlink" title="角色分工"></a>角色分工</h5><ul>
<li><strong>项目经理</strong>：对整个项目负责，任务分配、把控进度</li>
<li><strong>产品经理</strong>：进行需求调研，输出需求调研文档、产品原型等</li>
<li><strong>UI设计师</strong>：根据产品原型输出界面效果图</li>
<li><strong>架构师</strong>：项目整体架构设计、技术选型等</li>
<li><span style = "color:red"><strong>开发工程师</strong></span>：代码实现</li>
<li><strong>测试工程师</strong>：编写测试用例，输出测试报告</li>
<li><strong>运维工程师</strong>：软件环境搭建、项目上线</li>
</ul>
<h5 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h5><ul>
<li><p>开发环境：开发人员在开发阶段使用的环境</p>
</li>
<li><p>测试环境：专门给测试人员使用的环境，用于项目测试</p>
</li>
<li><p>生产环境：线上环境</p>
</li>
</ul>
<h2 id="第二轮补充知识点复习-会以橙色标注"><a href="#第二轮补充知识点复习-会以橙色标注" class="headerlink" title="第二轮补充知识点复习 会以橙色标注"></a><span style = "color:orange"><strong>第二轮补充知识点复习 会以橙色标注</strong></span></h2><h3 id="苍穹外卖项目介绍"><a href="#苍穹外卖项目介绍" class="headerlink" title="苍穹外卖项目介绍"></a>苍穹外卖项目介绍</h3><h5 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h5><ul>
<li>定位：专门为餐饮制定的一款软件产品[<strong>管理端</strong> 与 <strong>用户端</strong>]</li>
</ul>
<h5 id="功能架构-体现项目中的业务功能模块"><a href="#功能架构-体现项目中的业务功能模块" class="headerlink" title="功能架构 (体现项目中的业务功能模块)"></a>功能架构 (体现项目中的业务功能模块)</h5><ul>
<li><strong>管理端</strong>：员工、分类、菜品、套餐、订单管理、工作台、数据统计、来单提醒</li>
<li><strong>用户端</strong>：微信登录、商品浏览、购物车、用户下单、微信支付、历史订单、地址管理、用户催单</li>
</ul>
<h5 id="产品原型“在文件里有用户端和管理端”-用于展示项目的业务功能-一般由产品经理进行设计"><a href="#产品原型“在文件里有用户端和管理端”-用于展示项目的业务功能-一般由产品经理进行设计" class="headerlink" title="产品原型“在文件里有用户端和管理端” (用于展示项目的业务功能 一般由产品经理进行设计)"></a><span style = "color:red">产品原型<del>“在文件里有用户端和管理端”</del></span> (用于展示项目的业务功能 一般由产品经理进行设计)</h5><h5 id="技术选型-展示项目中使用到的技术框架和中间件"><a href="#技术选型-展示项目中使用到的技术框架和中间件" class="headerlink" title="技术选型 (展示项目中使用到的技术框架和中间件)"></a>技术选型 (展示项目中使用到的技术框架和中间件)</h5><ul>
<li><p><strong>用户层</strong>：node.js、VUE.js、ElementUI、微信小程序、apache echarts</p>
</li>
<li><p><strong>网关层</strong>：Nginx</p>
</li>
<li><p><strong>应用层</strong>：SpringBoot、SpringMVC、SpringTask、httpclient、SpringCache、JWT、阿里云OSS、Swagger、POI(操作excel表格)、WebSocket(网络协议&lt;催单…&gt;)</p>
</li>
<li><p><strong>数据层</strong>：MySQL、Redis、MyBatis、PageHelper、Spring Data Redis</p>
</li>
<li><p><strong>工具</strong>：Git、Maven、Junit、PostMan</p>
</li>
</ul>
<h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><p><strong>前端</strong>：管理端(Web<del>基于Nginx</del>)、用户端(小程序)</p>
<blockquote>
<p>前端环境位置：<br>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day01\前端运行环境\nginx-1.20.2\html\sky</p>
<p>D:\nginx-1.20.2 [放在英文目录下 双击 nginx.exe] 默认端口号80</p>
<p><strong>[苍穹外卖]</strong> (<a target="_blank" rel="noopener" href="http://localhost/#/login">http://localhost/#/login</a>)</p>
</blockquote>
<p><strong>后端</strong>：后端服务(Java)</p>
<blockquote>
<p>后端环境位置：<br>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day01\后端初始工程\sky-take-out</p>
<p>把sky-take-out导入到idea</p>
</blockquote>
<ul>
<li><strong>sky-take-out</strong> [maven父工程，<strong>统一管理依赖版本</strong>，<strong>聚合其他子模块</strong>]<ul>
<li>sky-common [子模块，存放公共类(工具类、常量类、异常类)]</li>
<li>sky-pojo [子模块，存放实体类、VO、DTO等]</li>
<li>sky-server [子模块，后端服务，存放配置文件、Controller、Service、Mapper等]</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Entity</td>
<td>实体，通常和数据库中的表对应</td>
</tr>
<tr>
<td>DTO</td>
<td>数据传输对象，通常用程序中各层之间传递数据</td>
</tr>
<tr>
<td>VO</td>
<td>视图对象，为前端展示数据提供的对象</td>
</tr>
<tr>
<td>POJO</td>
<td>普通Java对象，只有属性和对应的Getter和Setter</td>
</tr>
</tbody></table>
<p><span style = "color:orange"><strong>深刻理解POJO</strong></span></p>
<blockquote>
<p><strong>POJO</strong>的内在含义是指：那些没有继承任何类、也没有实现任何接口[可以实现]，更没有被其它框架侵入的java对象。<br><strong>POJO是一个简单的、普通Java对象，它包含业务逻辑处理或持久化逻辑等，但不是JavaBean、EntityBean等</strong>不具有任何特殊角色，不继承或不实现任何其它Java框架的类或接口。 <strong><u>可以包含类似与JavaBean属性和对属性访问的setter和getter方法的</u></strong><br>一般在web应用程序中建立一个<strong>数据库</strong>的映射对象时，我们只能称它为POJO。</p>
<ul>
<li><strong>POJO持久化之后</strong>&#x3D;&#x3D;〉PO（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）</li>
<li><strong>POJO传输过程中</strong>&#x3D;&#x3D;&gt; DTO</li>
<li><strong>POJO用作表示层</strong>&#x3D;&#x3D;&gt; VO</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解PO、DTO、VO</strong></span></p>
<blockquote>
<p><strong>PO</strong>(persistent object)：就是将对象与关系数据库绑定，用对象来表示关系数据，<br>最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。</p>
<ul>
<li>有时也被称为Data对象，对应数据库的entity，简单认为一个PO对应数据库中的一条记录</li>
<li>PO中不应该包含任何对数据库的操作</li>
<li><strong>PO的属性是跟数据表的字段一一对应的</strong></li>
<li>PO对象需要实现序列化接口</li>
</ul>
<hr>
<p><strong>DTO</strong>(<u>Data Transfer Object</u>)： → 数据传输对象<br>主要用于远程调用需要大量传输对象的地方<br>我们可以将PO中的部分属性抽取出来，就形成了DTO<br><strong>举例说明</strong>：<br>比如我们有一张表有100个字段，那么对应的PO就有100个属性<br>但是我们界面上需要显示10个字段，客户端用WEB service来获取数据，没必要把整个PO对象传递到客户端，这时<u>我们就可以用只有这10个属性的DTO来传递结果到客户端</u>，这样就<u><strong>不会暴露服务端表结构</strong></u>，到达客户端后，<u>如果用这个对象来对应界面显示，那么此时它的身份就转为了<strong>VO</strong>(View Object)</u></p>
<hr>
<p><strong>VO</strong><br>VO(value object) 是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 VO是什么？它是值对象，准确地讲，它是业务对象，是生活在业务层的，是业务逻辑需要了解，需要使用的，再简单地讲，它是概念模型转换得到的。<br><strong>重点</strong>：<br>一个VO可以只是PO的一部分，也可以是多个PO构成，同样也等同于一个PO(指的是属性)。正因为这样，PO独立出来，<u>数据持久层</u>也就独立出来了，它不会受到任何业务的影响和干涉。又因为这样，<u>业务逻辑层</u>也独立开来，它不会受到数据持久层的影响，业务层只关心业务逻辑的处理，怎么存和读都交给别人。</p>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解什么是DAO</strong></span></p>
<blockquote>
<p><strong>DAO</strong>(Data Access Object)：数据访问对象<br>主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO。<br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO，提供数据库的CRUD操作…</p>
<ul>
<li><p>主要用来封装对DB（数据库）的访问（CRUD操作）。</p>
</li>
<li><p>通过接收业务层的数据，把POJO持久化为PO。</p>
</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解JavaBean</strong></span></p>
<blockquote>
<p><strong>JavaBean是一个遵循特定写法的Java类，是一种Java语言编写的可重用组件，它的方法命名，构造及行为必须符合特定的约定：</strong></p>
<p><strong>1、这个类必须具有一个公共的(public)无参构造函数；</strong><br><strong>2、所有属性私有化（private）；</strong><br><strong>3、私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。</strong><br><strong>4、这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）</strong><br>JavaBean在JavaEE开发中，通常用于<strong>封装数据</strong><br>许多开发者会把<strong>JavaBean</strong>看作村从特定命名约定的<strong>POJO</strong><del>POJO按照JavaBean的规则来就可以变成JavaBean</del><br><strong>当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个JavaBean</strong><br>JavaBean是一种组件技术，就好像你做了一个扳手，而这个扳手会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳手扳、锤、撬等等)，而这个扳手就是一个组件。</p>
</blockquote>
<p><span style = "color:orange"><strong>common里的constant、context、properties代表什么意思</strong></span></p>
<pre><code class="java">constant:
用于存放常量类。这些常量可能是项目中频繁使用的固定值，如状态码、错误码、系统配置项等。
常量类中的变量一般使用public static final修饰，确保其不可变性。
    
context:
用于存放上下文类。上下文类通常用来保存和传递运行时环境信息或状态。
在Spring框架中，ApplicationContext就是一个典型的上下文对象，它提供了对Bean的访问以及配置信息的管理。
    
properties:
用于存放属性文件。这些文件通常以.properties为扩展名，用于存储配置信息，如数据库连接字符串、系统参数等。
属性文件可以通过Properties类来读取和写入，方便在运行时动态调整系统行为。
</code></pre>
<p><span style = "color:orange"><strong>Final的巩固</strong></span></p>
<pre><code class="java">问：对于引用类型（如String、Object等），final变量的引用不能被改变，但引用的对象内部状态可以改变。 这句话是什么意思？

答：当一个引用类型的变量被声明为final时，这个变量的引用（即指向的对象）不能被改变，但该对象的内部状态是可以改变的。我们可以通过具体的例子来理解这一点。
public class Example &#123;
    public static final String EMP_ID = &quot;empId&quot;;
    public static void main(String[] args)&#123;
        // 下面这行代码会编译失败，因为EMP_ID是final的
        // EMP_ID = &quot;newEmpId&quot;; // 编译错误
        
// 但是可以创建一个新的String对象并使用EMP_ID内容
    String anotherId = EMP_ID + &quot;123&quot;;
    sout(anotherId) =&gt; empId123;
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>解析context (实现上下类的逻辑原理) 内的代码</strong></span></p>
<pre><code class="java">package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
//ThreadLocal 是一个线程局部变量，每个线程都有自己的独立副本。这意味着不同线程之间不会共享同一个 ThreadLocal实例的数据，从而避免了多线程环境下的数据竞争问题。
    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;
&#125;
/*
这个类通常用于需要在多线程环境中传递和管理线程上下文信息的场景。例如：

Web应用：在处理HTTP请求时，可能需要将用户ID或其他上下文信息绑定到当前线程，以便在整个请求处理过程中都能访问到这些信息。

日志记录：在日志记录中，可能需要记录每个操作的执行者ID，通过 ThreadLocal 可以方便地在日志记录器中获取当前操作者的ID。

事务管理：在分布式事务中，可能需要将事务ID绑定到当前线程，以便在事务的各个阶段都能访问到这个ID。

内存泄漏：如果 ThreadLocal 中存储的对象没有及时释放，可能会导致内存泄漏。因此，建议在不再需要 ThreadLocal 中的数据时，调用 remove 方法将其移除。

线程池：在使用线程池时，特别需要注意 ThreadLocal 的管理。线程池中的线程是复用的，如果不及时清理 ThreadLocal 中的数据，可能会导致数据混淆或内存泄漏。
*/
</code></pre>
<p><span style = "color:orange"><strong>静态变量解析</strong></span></p>
<pre><code class="java">//静态变量 (static)
静态变量：在 Java 中，静态变量属于类而不是类的实例。这意味着无论创建多少个类的实例，静态变量都只有一份拷贝，并且所有实例共享这份拷贝。
作用域：静态变量在类加载时初始化，并且在类卸载时销毁。它们存在于类的生命周期内，而不是实例的生命周期内。

//结合 static 和 ThreadLocal
在 BaseContext 类中，threadLocal 被声明为 static，这意味着所有 BaseContext 实例共享同一个 ThreadLocal 实例。但这并不意味着所有线程共享同一个 ThreadLocal 实例的数据。相反，每个线程都有自己独立的 ThreadLocal 数据副本。
    
静态变量：
public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
这行代码声明了一个静态的 ThreadLocal 变量 threadLocal，所有 BaseContext 实例共享这个 ThreadLocal 实例。
</code></pre>
<h3 id="使用Git进行版本控制"><a href="#使用Git进行版本控制" class="headerlink" title="使用Git进行版本控制"></a>使用Git进行版本控制</h3><ul>
<li>创建Git本地仓库</li>
<li>创建Git远程仓库[GitHub、Gitee]</li>
<li>将本地文件推送到Git远程仓库</li>
</ul>
<pre><code class="java">.gitignore[文件设置]
    
//忽略git管理的文件
**/target/
.idea
*.iml
*.class
*Test.java
**/test/
</code></pre>
<blockquote>
<p><strong>创建远程仓库流程</strong>：【提交到本地】<br>VCS → Create Git Repository → sky-take-out → √ → Unversinoed Files(All)  → Commit</p>
<p><strong>去创建一个仓库</strong>：[Pluminary&#x2F;sky-take-out (gitee.com)] (<a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out">https://gitee.com/Pluminary/sky-take-out</a>)</p>
<p><strong>推送代码到Gitee远程仓库</strong>：Idea右上角的↗ → 定义一下本地和远程仓库关联 点击Define remote → Name: origin<br>URL: <a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out.git">https://gitee.com/Pluminary/sky-take-out.git</a> (这个是在Gitee上创建仓库后复制的代码)</p>
<p><strong>推送成功</strong>：[Pluminary&#x2F;sky-take-out (gitee.com)] (<a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out">https://gitee.com/Pluminary/sky-take-out</a>)</p>
</blockquote>
<h3 id="后端环境搭建"><a href="#后端环境搭建" class="headerlink" title="后端环境搭建"></a>后端环境搭建</h3><h6 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h6><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42914989/article/details/113155204">Unknown collation: ‘utf8mb4_0900_ai_ci‘的解决方法_unknown collation utf8mb4-CSDN博客</a></p>
<h6 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h6><pre><code class="java">浏览器

↓
Controller:
1.接收并封装参数
2.调用service方法查询数据库
3.封装结果并相应

↓
Service：
1.调用mapper查询数据库
2.密码对比
3.返回结果

↓
Mapper：
1.select * from employee where username = ? 

↓
数据库
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tlk20071/article/details/103629336">IDEA中导入多module的Maven项目无法识别module的解决办法_idea modules太多 mvn clean 对某个module不起作用-CSDN博客</a></p>
<blockquote>
<p>Maven → <strong>compile</strong>(编译聚合模块 )</p>
<p>[INFO] ————————————————————————<br>[INFO] Reactor Summary for sky-take-out 1.0-SNAPSHOT:<br>[INFO]<br>[INFO] sky-take-out ………………………………… SUCCESS [  0.003 s]<br>[INFO] sky-common ………………………………….. SUCCESS [  2.761 s]<br>[INFO] sky-pojo ……………………………………. SUCCESS [  2.227 s]<br>[INFO] sky-server ………………………………….. SUCCESS [  1.294 s]<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS</p>
</blockquote>
<p><span style="color:red">在数据库中 <u>新建查询</u> <strong>→</strong> <u>SELECT VERSION()</u>; <strong>→</strong> 引擎是8.0.33的是正规操作mysql此时对应的任务管理器<strong>服务</strong>里搜索mysql(名称:MySQL80)开启这个 <strong>→</strong> 如果开启了服务里的MySQL那<u>SELECT VERSION()</u>查询就是11.0.5-MariaDB</span></p>
<blockquote>
<p>handler：全局异常处理器</p>
</blockquote>
<p><span style = "color:orange"><strong>右侧Maven的具体用途</strong></span></p>
<blockquote>
<ol>
<li><p><strong>clean</strong><br> 功能：<strong>清除项目构建过程中生成的所有文件，通常包括 target 目录下的内容</strong>。<br> 命令：mvn clean<br> 使用场景：<br> 在每次构建之前，确保没有旧的构建产物干扰新构建。<br> 清理项目目录，准备进行新的构建。</p>
</li>
<li><p><strong>validate</strong><br> 功能：<strong>验证项目的正确性，确保所有必要的信息都已就绪</strong>。<br> 命令：mvn validate<br> 使用场景：<br> 在构建过程的早期阶段，检查项目配置是否正确。<br> **<u>确保所有依赖项和资源都可用</u>**。</p>
</li>
<li><p><span style = "color:red"><strong>compile</strong></span><br> 功能：<strong>编译项目的源代码</strong>。<br> 命令：mvn compile<br> 使用场景：<br> <u>编译项目源代码，生成 .class 文件。</u><br> <u><strong>通常在开发过程中频繁使用</strong>，<strong>确保代码可以成功编译</strong>。</u></p>
</li>
<li><p><strong>test</strong><br> 功能：运行项目的单元测试。<br> 命令：mvn test<br> 使用场景：<br> 在代码提交前，确保所有单元测试通过。<br> 持续集成（CI）过程中，自动运行测试以确保代码质量。</p>
</li>
<li><p><span style = "color:red"><strong>package</strong></span><br> 功能：<strong>将编译后的代码打包成可分发的格式，如 JAR、WAR 等</strong>。<br> 命令：mvn package<br> 使用场景：<br> 构建项目并生成可部署的包。<br> <strong>通常在开发和部署过程中使用，生成最终的可发布版本。</strong></p>
</li>
<li><p><strong>verify</strong><br> 功能：<strong>运行任何检查以验证包的完整性和有效性。</strong><br> 命令：mvn verify<br> 使用场景：<br> 在发布前，进行更严格的验证，确保包的质量。<br> <strong>运行集成测试、性能测试</strong>等。</p>
</li>
<li><p><span style = "color:red"><strong>install</strong></span><br> <strong>功能：将包安装到本地 Maven 仓库，供其他项目使用</strong>。<br> 命令：mvn install<br> 使用场景：<br> 将项目依赖安装到本地仓库，以便其他项目可以引用。<br> 通常在开发和测试环境中使用，确保依赖项可用。</p>
</li>
<li><p><strong>site</strong><br> 功能：生成项目的站点文档，包括项目报告、测试覆盖率等。<br> 命令：mvn site<br> 使用场景：<br> 生成项目文档，供团队成员和外部用户查阅。<br> 文档生成和发布，提高项目的透明度和可维护性。</p>
</li>
<li><p><strong>deploy</strong><br> 功能：将最终的包部署到远程仓库，如 Nexus、Artifactory 等。<br> 命令：mvn deploy<br> 使用场景：<br> 将项目发布到远程仓库，供其他团队或项目使用。<br> 通常在持续集成和持续部署（CI&#x2F;CD）流程中使用，确保发布的版本可用。</p>
</li>
</ol>
<p>  <strong>总结</strong><br>  clean：清理构建产物。<br>  validate：验证项目配置。<br>  compile：编译源代码。<br>  test：运行单元测试。<br>  package：打包项目。<br>  verify：验证包的完整性和有效性。<br>  install：安装到本地仓库。<br>  site：生成项目文档。<br>  deploy：部署到远程仓库。</p>
</blockquote>
<h6 id="思考：前端发送的请求，是如何请求到后端服务的？"><a href="#思考：前端发送的请求，是如何请求到后端服务的？" class="headerlink" title="思考：前端发送的请求，是如何请求到后端服务的？"></a>思考：前端发送的请求，是如何请求到后端服务的？</h6><pre><code class="java">前端请求地址：http://localhost/api/employee/login
后端接口地址：http://localhost:8080/admin/employee/login
</code></pre>
<ul>
<li><p><strong>nginx</strong>反向代理，就是将前端发送的动态请求由nginx转发到后端服务器</p>
</li>
<li><p><strong>浏览器</strong> → <a target="_blank" rel="noopener" href="http://localhost/api/employee/login">http://localhost/api/employee/login</a> → <strong>Nginx</strong> → <a target="_blank" rel="noopener" href="http://localhost:8080/admin/employee/login">http://localhost:8080/admin/employee/login</a> → <strong>Tomcat</strong></p>
</li>
<li><p>nginx反向代理的好处：提高访问速度、进行负载均衡<del>(否则前端就只能访问一台服务器)</del>、保证后端服务安全<del>(不对外开放)</del></p>
</li>
</ul>
<h6 id="nginx-反向代理的配置方式"><a href="#nginx-反向代理的配置方式" class="headerlink" title="nginx 反向代理的配置方式"></a>nginx 反向代理的配置方式</h6><pre><code class="java">nginx.conf

server&#123;
    listen 80;
    server_name localhost;
    location /api/&#123;
        proxy_pass http://localhost:8080/admin/;  #反向代理
    &#125;
&#125;
</code></pre>
<h6 id="nginx-负载均衡的配置方法-平均转发到多台后端服务器"><a href="#nginx-负载均衡的配置方法-平均转发到多台后端服务器" class="headerlink" title="nginx 负载均衡的配置方法(平均转发到多台后端服务器)"></a>nginx 负载均衡的配置方法(平均转发到多台后端服务器)</h6><pre><code class="java">nginx.conf

upstream webservers&#123;
    server 192.168.100.128:8080;
    server 192.168.100.129:8080;
&#125;

server&#123;
    listen 80;
    server_name localhost;
    location /api/&#123;
        proxy_pass http://webservers/admin/;  #反向代理
    &#125;
&#125;
</code></pre>
<h6 id="nginx-负载均衡策略："><a href="#nginx-负载均衡策略：" class="headerlink" title="nginx 负载均衡策略："></a>nginx 负载均衡策略：</h6><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式，默认为1，权重越高，被分配的客户端请求就越多</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式，这样每个访客可以固定访问一个后端服务</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据url分配方式，这样相同的url会被分配到同一个后端服务</td>
</tr>
<tr>
<td>fair</td>
<td>依据相应时间方式，响应时间短的服务将会被优先分配</td>
</tr>
</tbody></table>
<h3 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h3><h6 id="问题：员工表中的密码是明文存储，安全性太低"><a href="#问题：员工表中的密码是明文存储，安全性太低" class="headerlink" title="问题：员工表中的密码是明文存储，安全性太低"></a>问题：员工表中的密码是明文存储，安全性太低</h6><ul>
<li><p>将密码加密后存储，提高安全性</p>
</li>
<li><p>使用<strong>MD5</strong>加密方式对明文密码加密 <strong>[不可逆]</strong></p>
</li>
<li><p>修改数据库中的明文代码，改为MD5加密后的密文</p>
</li>
<li><p>修改Java代码，前端提交的代码进行MD5加密后再跟数据库中密码比对</p>
</li>
</ul>
<p><span style = "color:yellow"><strong>在Idea中有 “&#x2F;&#x2F;TODO” 这代表着标记处 此处还未完成一些操作 标记后可以在idea的下面快速定位到TODO</strong></span></p>
<blockquote>
<p>MD5密码加密后 也区分大小写 如果相同的密文但是大小写不同 结果还是不同的</p>
</blockquote>
<h6 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a><span style ="color:orange">修改密码</span></h6><pre><code class="java">com/sky/controller/admin/EmployeeController.java
 @PutMapping(&quot;/editPassword&quot;)
    @ApiOperation(&quot;修改密码&quot;)
    public Result editPassword(@RequestBody PasswordEditDTO passwordEditDTO) &#123;
        log.info(&quot;修改密码：&#123;&#125;&quot;, passwordEditDTO);
        employeeService.updatePassword(passwordEditDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">com/sky/service/EmployeeService.java
/**
     * 更改密码
     * @param passwordEditDTO
     */
    void updatePassword(PasswordEditDTO passwordEditDTO);
</code></pre>
<pre><code class="java">com/sky/service/impl/EmployeeServiceImpl.java
 /**
     * 更改密码
     * @param passwordEditDTO
     */
    @Override
    public void updatePassword(PasswordEditDTO passwordEditDTO) &#123;
    //getCurrentId 方法：public static Long getCurrentId() 方法用于获取当前线程的用户ID。

        Long empId = BaseContext.getCurrentId();
    //select * from employee where id = #&#123;id&#125;   根据id查员工的所有
        Employee employee = employeeMapper.getById(empId);
    //用md根据从前端传来的oldpassword 去判断employee的原始代码是否相同
        if (!employee.getPassword().equals(DigestUtils.md5DigestAsHex(passwordEditDTO.getOldPassword().getBytes()))) &#123; 
            throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);
        &#125;
        String newPassword = DigestUtils.md5DigestAsHex(passwordEditDTO.getNewPassword().getBytes());
        employee.setPassword(newPassword);
        employeeMapper.update(employee);
    &#125;
</code></pre>
<h3 id="导入接口文档"><a href="#导入接口文档" class="headerlink" title="导入接口文档"></a>导入接口文档</h3><h6 id="前后端分离开发流程"><a href="#前后端分离开发流程" class="headerlink" title="前后端分离开发流程"></a>前后端分离开发流程</h6><ul>
<li><strong>定制接口</strong>(定义规范) → <strong>前端开发</strong>(mock数据) + <strong>后端开发</strong>(后端自测) → <strong>连调</strong>(校验格式) → <strong>提测</strong>(自动化测试)</li>
</ul>
<h6 id="操作步骤-YApi-Pro-高效、易用、功能强大的可视化接口管理平台"><a href="#操作步骤-YApi-Pro-高效、易用、功能强大的可视化接口管理平台" class="headerlink" title="操作步骤 YApi Pro-高效、易用、功能强大的可视化接口管理平台"></a>操作步骤 <a target="_blank" rel="noopener" href="https://yapi.pro/">YApi Pro-高效、易用、功能强大的可视化接口管理平台</a></h6><blockquote>
<p>将课程资料中提供的项目接口导入YApi<br>苍穹外卖-管理端接口.json<br>苍穹外卖-用户端接口.json<br>苍穹外卖-管理端+用户端接口 → 数据管理 → 数据导入(json 随后把json文件拖入) → 点击接口可查看</p>
</blockquote>
<h3 id="Swagger介绍和使用方式"><a href="#Swagger介绍和使用方式" class="headerlink" title="Swagger介绍和使用方式"></a>Swagger介绍和使用方式</h3><p><strong>Knife4j</strong>是为Java MVC框架集成Swagger生成Api文档的增强解决方案</p>
<pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h6><ul>
<li>导入knife4j的maven坐标</li>
<li>在配置类中加入knife4j相关配置</li>
</ul>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
/**
 * 通过knife4j生成接口文档
 * @return
*/ 
@Bean
    public Docket docket() &#123;
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                    //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller&quot;))
                .paths(PathSelectors.any())
                .build();
        return docket;
    &#125;
</code></pre>
<ul>
<li>设置静态资源映射，否则接口文档页面无法访问</li>
</ul>
<pre><code class="java">/**
 * 设置静态资源映射
 * @param registry
*/
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;
</code></pre>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a>) 这个文档是解析<code>EmployeeController</code>来的</p>
<h6 id="通过Swagger就可以生成接口文档，那么我们不需要Yapi了？"><a href="#通过Swagger就可以生成接口文档，那么我们不需要Yapi了？" class="headerlink" title="通过Swagger就可以生成接口文档，那么我们不需要Yapi了？"></a>通过Swagger就可以生成接口文档，那么我们不需要Yapi了？</h6><ul>
<li>Yapi是设计阶段使用的工具，管理和维护接口</li>
<li>Swagger在开发阶段使用的框架，帮助后端开发人员做后端的接口测试</li>
</ul>
<p><strong>编写接口文档 在企业中需要注意：</strong></p>
<pre><code class="java">测试：
为每个API编写单元测试和集成测试，确保API的正确性和稳定性。
使用自动化测试工具（如Postman, JUnit等）来定期验证API的行为。
</code></pre>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Api</strong></td>
<td>用在类上，例如<strong>Controller</strong>，表明对类的说明</td>
</tr>
<tr>
<td>@ApiModel</td>
<td>用在类上，例如entity、DTO、VO</td>
</tr>
<tr>
<td>@ApiModelProperty</td>
<td>用在属性上，描述属性信息</td>
</tr>
<tr>
<td><strong>@ApiOperation</strong></td>
<td>用在方法上，例如Controller的方法，说明方法的用途、作用</td>
</tr>
</tbody></table>
<pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
package com.sky.controller.admin;

import com.sky.constant.JwtClaimsConstant;
import com.sky.dto.EmployeeLoginDTO;
import com.sky.entity.Employee;
import com.sky.properties.JwtProperties;
import com.sky.result.Result;
import com.sky.service.EmployeeService;
import com.sky.utils.JwtUtil;
import com.sky.vo.EmployeeLoginVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

/**
 * 员工管理
 */
@RestController
@RequestMapping(&quot;/admin/employee&quot;)
@Slf4j
@Api(tags = &quot;员工相关接口&quot;)
public class EmployeeController &#123;

    @Autowired
    private EmployeeService employeeService;
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping(&quot;/login&quot;)
    @ApiOperation(value = &quot;员工登录&quot;)
    public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) &#123;
        log.info(&quot;员工登录：&#123;&#125;&quot;, employeeLoginDTO);

        Employee employee = employeeService.login(employeeLoginDTO);

        //登录成功后，生成jwt令牌
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
        String token = JwtUtil.createJWT(
                jwtProperties.getAdminSecretKey(),
                jwtProperties.getAdminTtl(),
                claims);

        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return Result.success(employeeLoginVO);
    &#125;

    /**
     * 退出
     *
     * @return
     */
    @PostMapping(&quot;/logout&quot;)
    @ApiOperation(value = &quot;员工退出&quot;)
    public Result&lt;String&gt; logout() &#123;
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/vo/EmployeeLoginVO.java
// 这里是最后返回的数据vo [已经经历过由po→DTO→vo的过程] 这里的po应该就是Employee
package com.sky.vo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ApiModel(description = &quot;员工登录返回的数据格式&quot;)
public class EmployeeLoginVO implements Serializable &#123;

    @ApiModelProperty(&quot;主键值&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String userName;

    @ApiModelProperty(&quot;姓名&quot;)
    private String name;

    @ApiModelProperty(&quot;jwt令牌&quot;)
    private String token;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/dto/EmployeeLoginDTO.java
// 这里的DTO是传输中的数据
package com.sky.dto;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.io.Serializable;

@Data
@ApiModel(description = &quot;员工登录时传递的数据模型&quot;)
public class EmployeeLoginDTO implements Serializable &#123;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;密码&quot;)
    private String password;

&#125;
</code></pre>
<p><span style = "color:orange"><strong>Getter与Setter无中生有？？    以及快速创建对象builder</strong>  </span></p>
<blockquote>
<p>在上述VO和DTO代码中很显然没有看到常见的Getter和Setter<br>这是因为代码使用了 Lombok 注解，Lombok 是一个 Java 库，可以通过注解自动生成常见的样板代码，如 getter、setter、toString、equals 和 hashCode 等方法。</p>
<p><u>Lombok 注解解释</u>：<br>@<strong>Data</strong>：<br>作用：这是一个组合注解，包含了 @ToString、@EqualsAndHashCode、<u>@Getter、@Setter</u> 和 @RequiredArgsConstructor。<br><span style = "color:pink"><strong>效果：自动生成所有字段的 getter 和 setter 方法，toString 方法，equals 和 hashCode 方法，以及一个包含所有 final 字段和 @NonNull 字段的构造函数。</strong></span></p>
<p>@<strong>Builder</strong>：<br>作用：生成一个构建器模式的类，使得对象的创建更加灵活和可读。<br>效果：自动生成一个静态内部类 EmployeeLoginVO.EmployeeLoginVOBuilder，并提供构建方法。</p>
<ul>
<li><p>生成的构建器类包含所有字段的设置方法，并提供一个 build 方法来最终构建对象</p>
</li>
<li><p>使用构建器模式可以让你在创建对象时更清晰地指定各个字段的值，特别是在对象有很多字段时。<br>构建器模式允许你按需设置字段，而不需要为每个字段组合创建多个构造函数。</p>
</li>
<li><p>生成的构建器类：<br>Lombok 会自动生成一个静态内部类 EmployeeLoginVOBuilder，包含所有字段的设置方法和一个 build 方法。</p>
<ul>
<li>设置字段：<br>你可以按需调用构建器的设置方法来设置字段值，例如 id(1L)、userName(“john_doe”) 等。</li>
<li>构建对象：<br>最后调用 build 方法来创建 EmployeeLoginVO 对象。</li>
</ul>
</li>
</ul>
<pre><code class="java"> // 使用构建器创建 EmployeeLoginVO 对象
        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(1L)
                .userName(&quot;john_doe&quot;)
                .name(&quot;John Doe&quot;)
                .token(&quot;eyJhbGciOiJIUzI1NiJ9...&quot;)
                .build();

        System.out.println(employeeLoginVO);
</code></pre>
<p>@<strong>NoArgsConstructor</strong>：<br>作用：生成一个无参构造函数。<br>效果：自动生成一个不带任何参数的构造函数。</p>
<p>@<strong>AllArgsConstructor</strong>：<br>作用：生成一个全参构造函数。<br>效果：自动生成一个包含所有字段的构造函数。</p>
</blockquote>
<p><span style = "color:orange"><strong>详细解析@GetMapping 与 @PostMapping</strong></span></p>
<blockquote>
<p>选择使用 @GetMapping 还是 @PostMapping 主要取决于Http请求的性质和用途<br><strong>@GetMapping</strong></p>
<p>作用：</p>
<ul>
<li><p>@GetMapping专门用于处理HTTP GET请求</p>
</li>
<li><p>GET请求通常用于从服务器获取资源，不会对服务器上的数据进行修改</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li>请求参数通常附加在URL中 <code>@GetMapping(&quot;/xxx/&#123;id&#125;&quot;)</code> 底下会跟 <code>@PathVariable</code></li>
<li>请求是安全的不会修改服务器状态</li>
</ul>
<p><span style = "color:orange"><strong>适用场景：</strong></span></p>
<ul>
<li>查询数据：获取<strong>用户列表、搜索结果</strong></li>
<li>获取静态资源：图片、css文件</li>
<li>获取单个资源：获取某个用户的详细信息</li>
</ul>
<p>@<strong>PostMapping</strong></p>
<p>作用：</p>
<ul>
<li>@PostMapping专门用于处理HTTP POST请求</li>
<li>POST请求通常用于向服务器发送数据，可能会对服务器上的数据进行修改</li>
</ul>
<p>特点：</p>
<ul>
<li>请求参数放在请求体中，不会显示在URL这种 <code>@PostMapping(&quot;/users&quot;)</code>底下会跟<code>@RequestBody</code></li>
<li>请求体的大小没有固定限制，可以发送大量数据</li>
<li>多次相同的POST请求可能会产生不同的结果，可能会修改服务器状态</li>
<li>请求是不安全的，可能会修改服务器状态</li>
</ul>
<p><span style = "color:orange"><strong>适用场景：</strong></span></p>
<ul>
<li>创建新资源：注册新用户、添加新订单</li>
<li>更新现有资源：修改用户信息、更新订单状态</li>
<li>发送表单数据：登录、提交评论</li>
<li>上传文件：图片、文档</li>
</ul>
</blockquote>
<blockquote>
<p>以下是一些可能的原因，解释了为什么您看到的前端项目代码不是“正经的网页代码”：</p>
<ul>
<li><strong>构建过程</strong>：现代前端项目通常有一个构建过程，使用工具如Webpack、Rollup或Parcel等将源代码转换和打包。原始的代码可能在<code>src</code>目录中，而您看到的是构建后的<code>dist</code>目录，其中包含了转换和压缩后的文件。</li>
<li><strong>模块化和组件化</strong>：前端框架和库鼓励开发者将UI拆分成可复用的模块和组件。这意味着不再有传统的HTML、CSS和JavaScript混合在一起的代码，而是分别在不同的文件中定义。</li>
<li><strong>框架和库的使用</strong>：现代前端开发往往依赖于各种框架和库，这些框架和库有自己的文件结构和编写方式，可能和您熟悉的传统网页代码写法有很大不同。</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>根据@PutMapping(“&#x2F;{Id}”)提问</strong></span></p>
<h6 id="我为什么-PutMapping-“-x2F-id-”-是id呢-是不是因为我后面需要数据库where-id-x3D-id-查询才这样传输-如果-我想以name去查询呢"><a href="#我为什么-PutMapping-“-x2F-id-”-是id呢-是不是因为我后面需要数据库where-id-x3D-id-查询才这样传输-如果-我想以name去查询呢" class="headerlink" title="我为什么@PutMapping(“&#x2F;{id}”)是id呢 是不是因为我后面需要数据库where id &#x3D; #{id} 查询才这样传输 如果 我想以name去查询呢"></a>我为什么@PutMapping(“&#x2F;{id}”)是id呢 是不是因为我后面需要数据库where id &#x3D; #{id} 查询才这样传输 如果 我想以name去查询呢</h6><blockquote>
<p>在RESTful API设计中，资源通常通过其唯一标识符（如ID）来访问和操作。<code>@PutMapping(&quot;/&#123;id&#125;&quot;)</code>使用<code>&#123;id&#125;</code>作为路径变量是因为ID是数据库中记录的唯一标识，这使得通过ID查找和更新特定的记录变得直接和高效。</p>
<p>如果你想要通过<code>name</code>来查询和更新记录，这在理论上是可行的，但需要注意以下几点：</p>
<ol>
<li><code>name</code>字段可能不是唯一的，这意味着可能有多条记录具有相同的名称。</li>
<li>使用非唯一字段作为更新依据可能会导致数据不一致或错误更新。</li>
</ol>
</blockquote>
<p><span style = "color:orange"><strong>更新员工 前后端联调原理</strong></span></p>
<pre><code class="javascript">★ 在前端使用Ajax与后端URL对应时，你需要确保Ajax请求的URL与后端控制器中定义的映射相匹配。在你提供的例子中，后端使用@PutMapping(&quot;/&#123;id&#125;&quot;)来定义更新员工信息的端点，因此前端的Ajax URL应该包含员工的ID

// 绑定更新按钮的点击事件
$(&#39;#updateBtn&#39;).click(function() &#123;
    var employee = &#123;
        id: $(&#39;#id&#39;).val(), // 假设这是员工的唯一标识符
        name: $(&#39;#name&#39;).val(),
        email: $(&#39;#email&#39;).val(),
        department: $(&#39;#department&#39;).val()
    &#125;;

    // 发起Ajax PUT请求，URL中包含员工的ID
    $.ajax(&#123;
        url: `/api/employees/$&#123;employee.id&#125;`, // 注意这里的URL与后端的@PutMapping(&quot;/&#123;id&#125;&quot;)对应
        type: &#39;PUT&#39;,
        contentType: &#39;application/json&#39;, // 指定发送给服务器的数据类型
        data: JSON.stringify(employee), // 将JavaScript对象转换为JSON字符串
        success: function(response) &#123;
            // 请求成功，可以在这里处理响应数据
            alert(&#39;Employee information updated successfully!&#39;);
            // 如果需要，可以在这里更新页面上的表单数据
        &#125;,
        error: function(xhr, status, error) &#123;
            // 请求失败，可以在这里处理错误信息
            alert(&#39;Error updating employee information: &#39; + xhr.responseText);
        &#125;
    &#125;);
&#125;);

//在这个例子中，employee.id是从表单中获取的员工ID，它被拼接到URL字符串中，以形成完整的请求URL。这个URL应该与后端控制器中定义的@PutMapping(&quot;/&#123;id&#125;&quot;)相对应。当点击更新按钮时，Ajax请求会被发送到后端，后端会根据提供的ID找到对应的员工记录并进行更新。
</code></pre>
<pre><code class="java"> @PutMapping(&quot;/&#123;id&#125;&quot;)
    public ResponseEntity&lt;Employee&gt; updateEmployee(@PathVariable Long id, @RequestBody Employee employeeDetails) &#123;
        Employee employee = employeeService.getEmployeeById(id);
        if (employee != null) &#123;
            employee.setName(employeeDetails.getName());
            employee.setEmail(employeeDetails.getEmail());
            employee.setDepartment(employeeDetails.getDepartment());
            Employee updatedEmployee = employeeService.updateEmployee(employee);
            return ResponseEntity.ok(updatedEmployee);
        &#125; else &#123;
            return ResponseEntity.notFound().build();
        &#125;
    &#125;
&#125;
//这里&#123;id&#125;是路径变量，它会匹配Ajax请求URL中的employee.id。这样，前后端的URL就正确对应起来了。
</code></pre>
<h3 id="新增员工-Post-Json提交格式"><a href="#新增员工-Post-Json提交格式" class="headerlink" title="新增员工(Post+Json提交格式)"></a>新增员工(Post+Json提交格式)</h3><h4 id="需求分析和设计"><a href="#需求分析和设计" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h4><h6 id="账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456"><a href="#账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456" class="headerlink" title="账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456"></a>账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456</h6><p><strong>本项目约定</strong>：</p>
<ul>
<li><strong>管理端</strong>发出的请求，统一使用 <strong>&#x2F;admin</strong> 作为前缀</li>
<li><strong>用户端</strong>发出的请求，统一使用 <strong>&#x2F;user</strong> 作为前缀</li>
</ul>
<h4 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h4><p>根据新增员工接口设计对应的DTO<br>注意：当前提交的数据和实体类中对应的属性差别比较大时，建议使用DTO(数据传输)来封装数据</p>
<pre><code class="java">sky-pojo  com/sky/dto/EmployeeDTO.java
package com.sky.dto;

import lombok.Data;

import java.io.Serializable;

@Data
public class EmployeeDTO implements Serializable &#123;

    private Long id;

    private String username;

    private String name;

    private String phone;

    private String sex;

    private String idNumber;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
/**
     * 新增员工
     * @param employeeDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增员工&quot;)
    public Result save(@RequestBody  EmployeeDTO employeeDTO)&#123;
    // 因为是JSON格式 要加@RequestBody
        log.info(&quot;新增员工：&#123;&#125;&quot;,employeeDTO);
        employeeService.save(employeeDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
package com.sky.service;

import com.sky.dto.EmployeeDTO;
import com.sky.dto.EmployeeLoginDTO;
import com.sky.entity.Employee;

public interface EmployeeService &#123;

    /**
     * 员工登录
     * @param employeeLoginDTO
     * @return
     */
    Employee login(EmployeeLoginDTO employeeLoginDTO);

    /**
     * 新增员工
     * @param employeeDTO
     */
    void save(EmployeeDTO employeeDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
 /**
     * 新增员工
     * @param employeeDTO
     */
    @Override
    public void save(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
        //employee.setName(employeeDTO.getName()); 太多了 用对象属性拷贝
        BeanUtils.copyProperties(employeeDTO,employee); //其余的要手动设置
        //设置账号状态，默认正常状态 1正常 0锁定  规范封装
        employee.setStatus(StatusConstant.ENABLE);
        //设置密码，默认密码123456
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
        //设置当前记录的创建时间和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        //设置当前记录创建人id和修改人id
        //TODO 后期需要改为当前登录用户的id
        employee.setCreateUser(10L);
        employee.setUpdateUser(10L);

        employeeMapper.insert(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/entity/Employee.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Employee implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    private String name;

    private String password;

    private String phone;

    private String sex;

    private String idNumber;

    private Integer status;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime createTime;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime updateTime;

    private Long createUser;

    private Long updateUser;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
/**
 * 插入员工数据
*/
    @Insert(&quot;insert into employee (name,username,password,phone,sex,id_number,create_time,update_time,create_user,update_user))&quot; +
            &quot;values&quot; +
            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)
    void insert(Employee employee);
</code></pre>
<p><span style = "color:orange"><strong>@Builder 和 @JsonFormat</strong></span></p>
<blockquote>
<p>@Builder 是 Lombok 提供的一个注解，用于自动生成构建器模式的代码。<br>它会在编译时生成一个静态的 Builder 类和相关的方法，使得对象的创建更加灵活和可读。<br>需要<strong>创建不可变对象</strong>时，可以使用 @Builder 结合 @Value 注解。<br>需要<strong>创建复杂的对象</strong>时，可以通过构建器模式逐步设置属性，提高代码的可读性和可维护性</p>
<p>@JsonFormat 是 Jackson 库提供的注解，用于指定日期时间字段在 JSON 序列化和反序列化时的格式。<br>通过设置 pattern 属性，可以控制日期时间字段的格式化方式。<br>当需要将 LocalDateTime、Date 等日期时间类型的字段转换为特定格式的字符串时。<br>在 RESTful API 中，返回的 JSON 数据需要符合特定的日期时间格式要求。</p>
<h6 id="使用-Builder-的场景"><a href="#使用-Builder-的场景" class="headerlink" title="使用 @Builder 的场景"></a>使用 @Builder 的场景</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        // 使用 @Builder 创建 Employee 对象
        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .createUser(1L)
                .updateUser(1L)
                .build();

        System.out.println(employee);
    &#125;
&#125;
</code></pre>
<h6 id="使用-JsonFormat-的场景"><a href="#使用-JsonFormat-的场景" class="headerlink" title="使用 @JsonFormat 的场景"></a>使用 @JsonFormat 的场景</h6><pre><code class="java">//创建 RESTful API
Employee里面的pojo就不详细写了
    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime createTime;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime updateTime;
==========================================================================

@RestController
public class EmployeeController &#123;

    @GetMapping(&quot;/employee&quot;)
    public ResponseEntity&lt;String&gt; getEmployee() throws Exception &#123;
        // 创建 Employee 对象
        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .createUser(1L)
                .updateUser(1L)
                .build();

        // 使用 ObjectMapper 将 Employee 对象转换为 JSON 字符串
        ObjectMapper objectMapper = new ObjectMapper();
        String json = objectMapper.writeValueAsString(employee);

        return ResponseEntity.ok(json);
    &#125;
&#125;
===========================================================================
// 除了 @JsonFormat 注解，还有其他方式可以指定日期时间格式，具体取决于你的需求和使用的库。
 public static void main(String[] args) &#123;
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String formattedDateTime = now.format(formatter);

        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(now)
                .updateTime(now)
                .createUser(1L)
                .updateUser(1L)
                .build();

        System.out.println(&quot;Formatted Create Time: &quot; + formattedDateTime);
        System.out.println(&quot;Formatted Update Time: &quot; + formattedDateTime);
    &#125;
</code></pre>
<p>@<strong>Builder</strong>：<br>通过 Employee.builder() 创建了一个构建器对象。<br>使用链式调用设置各个属性，最后调用 build() 方法生成 Employee 实例。<br>这种方式使得创建对象的代码更加简洁和易读，特别是当对象属性较多时。</p>
<p>@<strong>JsonFormat</strong>：<br>在 createTime 和 updateTime 字段上使用了 @JsonFormat 注解，指定了日期时间的格式为 “yyyy-MM-dd HH:mm:ss”。<br><u><strong>当 Employee 对象被转换为 JSON 字符串</strong></u>时，这两个字段会被格式化为指定的日期时间格式。<br>这样可以确保返回的 JSON 数据符合预期的格式要求。</p>
</blockquote>
<p><span style = "color:orange"><strong>RESTful风</strong></span></p>
<blockquote>
<p><strong>可缓存性：</strong><br>RESTful API 可以利用 HTTP 缓存机制，减少网络请求，提高性能。<br>客户端可以缓存响应，减少服务器的负载。</p>
<p>易于集成：<br>RESTful API 使用标准的 HTTP 协议，几乎所有的编程语言和框架都支持 HTTP 请求。<br>这使得不同系统之间的集成变得更加容易。</p>
<p>可读性强：<br>RESTful API 的 URL 设计通常非常直观，易于理解和记忆。<br>例如，&#x2F;users&#x2F;123 表示用户 ID 为 123 的资源，&#x2F;users&#x2F;123&#x2F;orders 表示该用户的订单资源。</p>
<p>灵活性：<br>RESTful API 支持多种数据格式（如 JSON、XML 等），可以根据需要选择合适的格式。<br>客户端和服务器可以通过协商确定数据格式，提高了灵活性。</p>
<p>  GET &#x2F;users<br>  GET &#x2F;users&#x2F;{id}<br>  POST &#x2F;users<br>  PUT &#x2F;users&#x2F;{id}</p>
</blockquote>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><h6 id="功能测试方式："><a href="#功能测试方式：" class="headerlink" title="功能测试方式："></a>功能测试方式：</h6><ul>
<li>通过接口文档测试</li>
<li>通过前后端联调测试</li>
</ul>
<p>注意：由于开发阶段前后端是并行开发的，后端完成某个功能后，此时前端对应的功能可能还没有开发完成，导致无法进行前后端联调测试。所以在开发阶段，后端测试主要以接口文档测试为主</p>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/documentManager/GlobalParameters-default">http://localhost:8080/doc.html#/documentManager/GlobalParameters-default</a>)</p>
<p><span style = "color:red">首先要拿到<strong>JWT令牌</strong>(去接口进行一次登录测试后会有) → 全局参数设置 → 添加参数</span><br><strong>注意</strong>：这个jwt→json是有有效期的(2小时&#x3D;7200000秒)</p>
<pre><code class="xml">sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 7200000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
</code></pre>
<blockquote>
<p>{<br>  “code”: 1,<br>  “msg”: null,<br>  “data”: {<br>    “id”: 1,<br>    “userName”: “admin”,<br>    “name”: “管理员”,<br>    “token”: “eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI3NjAxMTAxfQ.rnxaRc7fjPzMYwGHk3VzKA4EOxRFrYkKzesxEQsCQUc”<br>  }<br>}</p>
<hr>
<p>新增参数：<br>  参数名称：token<br>  参数值：eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI3NjAxMTAxfQ.rnxaRc7fjPzMYwGHk3VzKA4EOxRFrYkKzesxEQsCQUc<br>  参数类型：header</p>
<p>新增员工接口<br>{<br>  “idNumber”: “1321321312”,<br>  “name”: “张三”,<br>  “phone”: “11111111111”,<br>  “sex”: “1”,<br>  “username”: “zhangsan”<br>}</p>
<p>响应内容：<br>{<br>  “code”: 1,<br>  “msg”: null,<br>  “data”: null<br>}</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/interceptor/JwtTokenAdminInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component  //将该类注册为 Spring 管理的 Bean。
@Slf4j //使用 Lombok 自动生成日志记录器
public class JwtTokenAdminInterceptor implements HandlerInterceptor &#123;
// 包含 JWT 相关的配置属性，如令牌名称和密钥
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
//检查当前拦截到的是否是 Controller 的方法。如果不是，直接放行
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/properties/JwtProperties.java
package com.sky.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &quot;sky.jwt&quot;)
@Data
public class JwtProperties &#123;

    /**
     * 管理端员工生成jwt令牌相关配置
     */
    private String adminSecretKey;
    private long adminTtl;
    private String adminTokenName;

    /**
     * 用户端微信用户生成jwt令牌相关配置
     */
    private String userSecretKey;
    private long userTtl;
    private String userTokenName;
&#125;
</code></pre>
<h4 id="代码完善"><a href="#代码完善" class="headerlink" title="代码完善"></a>代码完善</h4><h6 id="程序存在的问题："><a href="#程序存在的问题：" class="headerlink" title="程序存在的问题："></a>程序存在的问题：</h6><ul>
<li>录入的用户名已存在，抛出异常后没有处理</li>
<li>新增员工时，创建人id和修改人id设置了固定值</li>
</ul>
<blockquote>
<p>当你在 Maven 中执行 compile 命令时，它会强制 Maven 重新编译整个项目，包括所有的类和资源。这一过程会清除任何旧的编译结果，确保所有的依赖和代码都是最新的。这可能导致以下几种情况，从而解决了你的问题：</p>
<p>**<u>重新编译：</u>**Maven 会重新编译所有的源代码，包括你修改或新增的类，这样就能解决因为旧的编译缓存而引起的引用问题。<br>**<u>更新依赖：</u>**如果你在项目中添加或修改了依赖，执行 compile 可以确保这些依赖被正确加载和引用。<br><u><strong>清理旧缓存</strong>：</u>在编译过程中，Maven 会清理旧的缓存和临时文件，避免由于这些文件造成的潜在冲突。<br>**<u>IDE 同步：</u>**有时候，IDE 的状态可能与 Maven 项目状态不一致，执行 Maven 命令可以帮助 IDE 重新同步项目的状态。</p>
</blockquote>
<h6 id="问题①"><a href="#问题①" class="headerlink" title="问题①"></a>问题①</h6><pre><code class="java">sky-server  com/sky/handler/GlobalExceptionHandler.java
package com.sky.handler;

import com.sky.constant.MessageConstant;
import com.sky.exception.BaseException;
import com.sky.result.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常处理器，处理项目中抛出的业务异常
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler &#123;

    /**
     * 捕获业务异常
     * @param ex
     * @return
     */
    @ExceptionHandler
    public Result exceptionHandler(BaseException ex)&#123;
        log.error(&quot;异常信息：&#123;&#125;&quot;, ex.getMessage());
        return Result.error(ex.getMessage());
    &#125;

    @ExceptionHandler
    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex) &#123;
        String message = ex.getMessage();
        if (message.contains(&quot;Duplicate entry&quot;)) &#123;
            // Duplicate entry &#39;zhangsan&#39; for key &#39;employee.idx_username&#39;
// 在这里，我们使用 split(&quot;&#39;&quot;) 将字符串分割为多个部分。这样，parts[1] 将得到 zhangsan，因为它位于单引号之间。这种方式可以正确提取用户名。
            String[] split = message.split(&quot;&#39;&quot;);
            String username = split[1];
//            String msg = username + &quot;已存在&quot;;
            String msg = username + MessageConstant.ALREADY_EXISTS;
            return Result.error(msg);
        &#125;else &#123;
            return Result.error(MessageConstant.UNKNOWN_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>Split的深入学习</strong></span></p>
<blockquote>
<ul>
<li><strong>正则表达式</strong></li>
</ul>
<p>split 方法接受一个<strong>正则表达式</strong>作为参数，因此分隔符可以是复杂的模式，而不仅仅是单个字符。<br>例如，<strong>split(“\s+”)</strong> 可以用来按一个或多个空白字符（包括空格、制表符、换行符等）进行分割。</p>
<ul>
<li><strong>限制分割次数</strong></li>
</ul>
<p>split 方法还有一个重载版本 split(String regex, int limit)，可以限制分割的次数。<br>例如，split(“‘“, 3) 只会进行两次分割，结果数组最多包含三个元素。</p>
</blockquote>
<h3 id="问题②-解析出员工登录id后，如何转递给Service的save方法？→-ThreadLocal"><a href="#问题②-解析出员工登录id后，如何转递给Service的save方法？→-ThreadLocal" class="headerlink" title="问题②  解析出员工登录id后，如何转递给Service的save方法？→ ThreadLocal"></a>问题②  <span style = "color:orange"><strong>解析出员工登录id后，如何转递给Service的save方法？</strong></span>→ <span style = "color:red">ThreadLocal</span></h3><img src="https://raw.githubusercontent.com/P-luminary/images/2dd9f9e12ba173719123c685949c277632af5ce4/data/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E7%99%BB%E5%BD%95%E5%8F%8A%E6%A0%A1%E9%AA%8C.jpg" style="zoom:150%;" />

<h6 id="前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id："><a href="#前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id：" class="headerlink" title="前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id："></a>前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id：</h6><pre><code class="java">        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
</code></pre>
<h6 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h6><p>ThreadLocal并不是一个Thread，Thread的局部变量<br><strong>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获得到对应的值，线程外则不能访问</strong></p>
<pre><code class="java">sky-common  com/sky/context/BaseContext.java
package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/interceptor/JwtTokenAdminInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor &#123;

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
// ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
            BaseContext.setCurrentId(empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 新增员工
     * @param employeeDTO
     */
    @Override
    public void save(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
//        employee.setName(employeeDTO.getName()); 太多了 用对象属性拷贝
        BeanUtils.copyProperties(employeeDTO,employee); //其余的要手动设置
        //设置账号状态，默认正常状态 1正常 0锁定  规范封装
        employee.setStatus(StatusConstant.ENABLE);
        //设置密码，默认密码123456
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
        //设置当前记录的创建时间和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        //设置当前记录创建人id和修改人id
        //TODO 后期需要改为当前登录用户的id
//        employee.setCreateUser(10L);
// ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        employee.setCreateUser(BaseContext.getCurrentId());
        employee.setUpdateUser(BaseContext.getCurrentId());
    
        employeeMapper.insert(employee);
    &#125;

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 如果想单独针对22行代码 测试部分的值是多少 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
// 左键选中&#39;BaseContext.getCurrentId()&#39; 右键Evaluate Expression单独计算即可
</code></pre>
<p><span style = "color:orange"><strong>将员工登录ID放在 ThreadLocal 中的原因</strong></span></p>
<blockquote>
<p>在多线程环境中，使用 ThreadLocal 来存储和传递员工的完整信息是一个常见的做法。这样可以确保每个线程都有独立的变量副本，避免并发问题。以下是一些步骤和最佳实践，帮助你在 ThreadLocal 中安全地传递和存储员工的完整信息。<br>ThreadLocal 主要用于在同一个线程内传递和存储数据，确保每个线程都有独立的变量副本。在你的例子中，ThreadLocal 用于存储员工ID，确保在多线程环境下员工ID的安全传递。</p>
<ul>
<li><strong>线程隔离</strong>：ThreadLocal 确保每个线程都有独立的员工ID副本，避免了多线程环境下的并发问题。<br>防止篡改：<u><strong>只有当前线程可以访问和修改 ThreadLocal 中的员工ID</strong></u>，其他线程无法访问，确保了ID的安全性。</li>
<li><strong>员工其他信息的安全性</strong><br><u>数据库查询</u>：员工的其他信息是从数据库中查询的，而不是从 ThreadLocal 中获取的。数据库查询本身是安全的，只要数据库连接和查询操作是安全的。<br><u>权限控制</u>：确保只有经过认证的用户才能执行查询操作，防止未授权访问。<br><u>数据加密</u>：敏感信息（如密码）在存储和传输过程中应进行加密，确保数据的安全性。</li>
</ul>
<p><strong>线程安全</strong>：<br>ThreadLocal 为每个线程提供独立的变量副本，避免了多线程环境下的并发问题。每个线程都可以安全地读取和修改自己的 ThreadLocal 变量，而不会影响其他线程。</p>
<p><strong>简化代码</strong>：<br>在 Web 应用中，通常需要在多个方法或组件之间传递用户身份信息（如员工登录ID）。使用 ThreadLocal 可以避免在每个方法调用中显式传递这些信息，从而简化代码。</p>
<p><strong>全局访问</strong>：<br>在同一个线程内，任何地方都可以访问 ThreadLocal 中存储的值，这使得在复杂的业务逻辑中传递和使用员工登录ID变得非常方便。</p>
<p><strong>避免传递参数</strong>：<br>在多层调用中，如果需要传递员工登录ID，通常需要在每个方法签名中添加相应的参数。使用 ThreadLocal 可以避免这种繁琐的参数传递，提高代码的可读性和可维护性。</p>
<pre><code class="java">// 设置员工登录ID：
在用户登录成功后，将员工登录ID设置到 ThreadLocal 中。
@PostMapping(&quot;/login&quot;)
public ResponseEntity&lt;?&gt; login(@RequestBody LoginRequest loginRequest) &#123;
    // 验证用户名和密码
    User user = userService.validateUser(loginRequest.getUsername(), loginRequest.getPassword());
    if (user != null) &#123;
        // 设置当前线程的员工登录ID
        BaseContext.setCurrentId(user.getId());
        // 返回登录成功信息
        return ResponseEntity.ok(&quot;Login successful&quot;);
    &#125; else &#123;
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(&quot;Invalid username or password&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 获取员工登录ID
在需要使用员工登录ID的地方，直接从 ThreadLocal 中获取
@Service
public class OrderService &#123;

    public void createOrder(Order order) &#123;
        Long currentUserId = BaseContext.getCurrentId();
        if (currentUserId != null) &#123;
            order.setCreatedBy(currentUserId);
            orderRepository.save(order);
        &#125; else &#123;
            throw new RuntimeException(&quot;User ID not found in context&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>将员工登录ID放在 ThreadLocal 中，可以确保每个线程都有独立的变量副本，避免多线程环境下的并发问题。同时，这种方式简化了代码，提供了全局访问的能力，避免了繁琐的参数传递，使得在复杂的业务逻辑中传递和使用员工登录ID变得非常方便。</p>
</blockquote>
<h3 id="员工分页查询"><a href="#员工分页查询" class="headerlink" title="员工分页查询"></a>员工分页查询</h3><h5 id="需求分析和设计-1"><a href="#需求分析和设计-1" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h5><h6 id="业务规则：-查询-→-get"><a href="#业务规则：-查询-→-get" class="headerlink" title="业务规则：(查询 → get)"></a>业务规则：(查询 → get)</h6><ul>
<li>根据页码展示员工信息</li>
<li>每页展示10条数据</li>
<li>分页查询时可以根据需要，输入员工姓名进行查询</li>
</ul>
<h5 id="代码开发-1"><a href="#代码开发-1" class="headerlink" title="代码开发"></a>代码开发</h5><h6 id="根据分页查询接口设计对应的DTO"><a href="#根据分页查询接口设计对应的DTO" class="headerlink" title="根据分页查询接口设计对应的DTO:"></a>根据分页查询接口设计对应的DTO:</h6><p><strong>Query</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>是否必须</th>
<th>示例</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>否</td>
<td>张三</td>
<td>员工姓名</td>
</tr>
<tr>
<td>page</td>
<td>是</td>
<td>1</td>
<td>页码</td>
</tr>
<tr>
<td>pageSize</td>
<td>是</td>
<td>10</td>
<td>每页记录数</td>
</tr>
</tbody></table>
<pre><code class="java">@Data
public class EmployeePageQueryDTO implements Serializable&#123;
    private String name;
    private int page;
    private int pageSize;
&#125;
</code></pre>
<h6 id="后面所有的分页查询，统一都封装成PageResult对象"><a href="#后面所有的分页查询，统一都封装成PageResult对象" class="headerlink" title="后面所有的分页查询，统一都封装成PageResult对象"></a>后面所有的分页查询，统一都封装成PageResult对象</h6><pre><code class="java">/*封装分页查询结果*/
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable&#123;
    private long total; 
    private List records;
&#125;
</code></pre>
<h6 id="员工信息分页查询后端返回的对象类型为：Result-lt-PageResult-gt"><a href="#员工信息分页查询后端返回的对象类型为：Result-lt-PageResult-gt" class="headerlink" title="员工信息分页查询后端返回的对象类型为：Result &lt; PageResult &gt;"></a>员工信息分页查询后端返回的对象类型为：<strong>Result &lt; PageResult &gt;</strong></h6><pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
/**
     * 员工分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    public Result&lt;PageResult&gt; page(EmployeePageQueryDTO employeePageQueryDTO)&#123;
        //格式不是JSON不用加 @RequestBody
        log.info(&quot;员工分页查询，参数为：&#123;&#125;&quot;, employeePageQueryDTO);
        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
        return Result.success(pageResult);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
/**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @Override
    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;
        // select * from employee limit 0,10
        // 开始分页查询 动态拼接
        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
        Page&lt;Employee&gt; page =  employeeMapper.pageQuery(employeePageQueryDTO);

        long total = page.getTotal();
        List&lt;Employee&gt; records = page.getResult();

        return new PageResult(total, records);
&#125;
</code></pre>
<p><span style = "color:orange"><strong>逐行研究分页查询</strong></span></p>
<blockquote>
<ul>
<li><p>PageHelper.startPage 是 MyBatis 分页插件提供的方法，用于开启分页功能</p>
<ul>
<li><p>employeePageQueryDTO.getPage() 获取当前页码。</p>
</li>
<li><p>employeePageQueryDTO.getPageSize() 获取每页显示的记录数</p>
<p>这一行代码的作用是告诉 MyBatis 在接下来的查询中启用分页，并设置分页参数</p>
</li>
</ul>
</li>
<li><p>employeeMapper.pageQuery(employeePageQueryDTO) 是调用 MyBatis 的 Mapper 接口方法，执行分页查询。</p>
<ul>
<li>employeePageQueryDTO 包含了查询条件，如关键字、排序字段等。</li>
<li>查询结果会被封装成 Page<Employee> 对象，其中包含了分页数据和分页元数据。</li>
</ul>
</li>
<li><p>page.getTotal() 获取分页查询的总记录数。</p>
<ul>
<li>总记录数用于计算总页数和其他分页相关的计算</li>
</ul>
</li>
<li><p>List<Employee> records &#x3D; page.getResult();</p>
<ul>
<li>page.getResult() 获取分页查询的实际数据列表。</li>
<li>这个列表包含了当前页的员工记录</li>
</ul>
</li>
<li><p>return new PageResult(total, records);</p>
</li>
<li><p>new PageResult(total, records) 创建一个新的 PageResult 对象，将总记录数和分页数据列表封装起来</p>
</li>
<li><p>PageResult 类通常包含 total 和 records 属性，用于返回给客户端</p>
</li>
<li><p>假设 employeePageQueryDTO.getPage() 返回 2，employeePageQueryDTO.getPageSize() 返回 10，那么 MyBatis 生成的 SQL 可能类似于：</p>
</li>
</ul>
<pre><code class="mysql">SELECT * FROM employee
WHERE ... -- 根据 employeePageQueryDTO 中的查询条件
LIMIT 10 OFFSET 10;
</code></pre>
<p>LIMIT 10：表示每页显示 10 条记录。<br>OFFSET 10：表示从第 11 条记录开始（因为页码从 1 开始，所以第 2 页的偏移量是 10）。</p>
<ul>
<li><p><strong>PageResult 类</strong>：用于封装分页查询的结果，包括总记录数和当前页的数据集合。<br>使用场景：在分页查询服务中，将查询结果封装为 PageResult 对象，通过控制器返回给客户端。</p>
</li>
<li><p><strong>Serializable 接口</strong>：是 Java 中的一个标记接口，没有定义任何方法。实现 Serializable 接口的类的对象可以被序列化，即将对象的状态转换为字节流，以便在网络上传输或持久化存储。反序列化则是将字节流恢复为对象的过程。 </p>
<ul>
<li><strong>序列化</strong></li>
</ul>
<p><u>对象状态转换</u>：将对象的状态（即对象的字段值）转换为字节流。<br>默认序列化机制：Java 提供了默认的序列化机制，通过 ObjectOutputStream 类的 writeObject 方法实现。<br><u>自定义序列化</u>：可以通过实现 writeObject 和 readObject 方法来自定义序列化和反序列化过程。</p>
<ul>
<li><strong>持久化</strong></li>
</ul>
<p>持久化：序列化的主要目的是将对象的状态保存到存储介质中，或者通过网络传输对象。</p>
</li>
</ul>
<p>查询结果会被封装到 PageResult 对象中，其中 total 表示总记录数，records 表示当前页的数据集合。</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
 /**
     * 分页查询 [动态sql 不用注解了 写道 EmployeeMapper.xml]
     * @param employeePageQueryDTO
     * @return
     */
    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
</code></pre>
<pre><code class="xml">sky-server  mapper/EmployeeMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.EmployeeMapper&quot;&gt;
    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Employee&quot;&gt;
        select * from employee
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
        &lt;/where&gt;
        order by create_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
&lt;!--
and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)：
如果条件成立，生成的 SQL 条件为 AND name LIKE &#39;%$&#123;name&#125;%&#39;，实现名称的模糊匹配
--&gt;
</code></pre>
<p>[员工管理] (<a target="_blank" rel="noopener" href="http://localhost/#/employee">http://localhost/#/employee</a>)</p>
<h5 id="代码完善-1"><a href="#代码完善-1" class="headerlink" title="代码完善"></a>代码完善</h5><h6 id="问题：创建-x2F-更新时间那边传入的数据不是想要的"><a href="#问题：创建-x2F-更新时间那边传入的数据不是想要的" class="headerlink" title="问题：创建&#x2F;更新时间那边传入的数据不是想要的"></a>问题：创建&#x2F;更新时间那边传入的数据不是想要的</h6><pre><code class="java">// 2024929214237
&quot;createTime&quot;: [
          2024,
          9,
          29,
          22,
          10,
          37
        ],
        &quot;updateTime&quot;: [
          2024,
          9,
          29,
          22,
          10,
          37
        ],
</code></pre>
<h6 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h6><ul>
<li><p><strong>方法一</strong>：在属性上加注解，对日期进行格式化<del>(只能处理单独一个属性)</del></p>
<pre><code class="java">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
private LocalDateTime updateTime;
------------------------------------------------------------------------
 &quot;createTime&quot;: &quot;2024-09-29 22:10:37&quot;,
</code></pre>
</li>
<li><p><strong>方法二</strong>：在<code>WebMvcConfiguration</code>中扩展Spring MVC的消息转换器，统一对日期类型进行格式化处理</p>
</li>
</ul>
<blockquote>
<p>重写父类方法 去扩展 消息转换器</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
 /**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        log.info(&quot;扩展消息转换器...&quot;);
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转化器加入容器中
        converters.add(0,converter);
    &#125;
</code></pre>
<pre><code class="java">package com.sky.json;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper &#123;

    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;
    //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;;
    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;

    public JacksonObjectMapper() &#123;
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    &#125;
&#125;
</code></pre>
<h3 id="启用禁用员工账号"><a href="#启用禁用员工账号" class="headerlink" title="启用禁用员工账号"></a>启用禁用员工账号</h3><h5 id="需求分析和设计-2"><a href="#需求分析和设计-2" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h5><h6 id="业务规则："><a href="#业务规则：" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>可以对状态为 “启用” 的员工账号进行 “禁用” 操作</li>
<li>可以对状态为 “禁用” 的员工账号进行 “启用” 操作</li>
<li>状态为 “禁用” 的员工账号不能登录系统</li>
</ul>
<pre><code class="java">sky-server
/**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;启用禁用员工账号&quot;)
    //因为上面的和下面的参数都是一致 不然需要@PathVariable(&quot;status&quot;)解释一下
    public Result startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id) &#123;
        log.info(&quot;启用禁用员工账号: &#123;&#125;,&#123;&#125;&quot;,status,id);
        employeeService.startOrStop(status, id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
 /**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @Override
    public void startOrStop(Integer status, Long id) &#123;
        // update employee set status = ? where id = ?
        Employee employee = new Employee();
        employee.setStatus(status);
        employee.setId(id);

/** 要在Employee.java中添加@Builder 才能使用这种风格
 *      Employee employee = Employee.builder()
 *              .status(status)
 *              .id(id)
 *              .build();
 */
        employeeMapper.update(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
/**
     * 根据主键动态修改属性
     * @param employee
     */
    void update(Employee employee);
</code></pre>
<pre><code class="java">sky-server  mapper/EmployeeMapper.xml
&lt;update id=&quot;update&quot; parameterType=&quot;Employee&quot;&gt;
        update employee
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt;
            &lt;if test=&quot;username != null&quot;&gt;username = #&#123;username&#125;,&lt;/if&gt;
            &lt;if test=&quot;password != null&quot;&gt;password = #&#123;password&#125;,&lt;/if&gt;
            &lt;if test=&quot;phone != null&quot;&gt;phone = #&#123;phone&#125;,&lt;/if&gt;
            &lt;if test=&quot;sex != null&quot;&gt;sex = #&#123;sex&#125;,&lt;/if&gt;
            &lt;if test=&quot;idNumber != null&quot;&gt;id_Number = #&#123;idNumber&#125;,&lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;update_Time = #&#123;updateTime&#125;,&lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;update_User = #&#123;updateUser&#125;,&lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125;,&lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
</code></pre>
<h3 id="编辑员工"><a href="#编辑员工" class="headerlink" title="编辑员工"></a>编辑员工</h3><h4 id="需求分析和设计-回写数据"><a href="#需求分析和设计-回写数据" class="headerlink" title="需求分析和设计[回写数据]"></a>需求分析和设计[回写数据]</h4><h6 id="编辑员工功能涉及到两个接口："><a href="#编辑员工功能涉及到两个接口：" class="headerlink" title="编辑员工功能涉及到两个接口："></a>编辑员工功能涉及到两个接口：</h6><ul>
<li>根据id查询员工信息</li>
<li>编辑员工信息</li>
</ul>
<h4 id="代码开发-2"><a href="#代码开发-2" class="headerlink" title="代码开发"></a>代码开发</h4><pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
    /**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询员工信息&quot;)
    public Result&lt;Employee&gt; getById(@PathVariable Long id)&#123;
        Employee employee = employeeService.getById(id);
        return Result.success(employee);
    &#125;

    /**
     * 编辑员工信息
     * @param employeeDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;编辑员工信息&quot;)
    public Result update(@RequestBody EmployeeDTO employeeDTO)&#123;
        log.info(&quot;编辑员工信息：&#123;&#125;&quot;, employeeDTO);
        employeeService.update(employeeDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
/**
     * 根据id查询员工
     * @param id
     * @return
     */
    Employee getById(Long id);

    /**
     * 编辑员工信息
     * @param employeeDTO
     */
    void update(EmployeeDTO employeeDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 根据id查询员工
     * @param id
     * @return
     */
    public Employee getById(Long id) &#123;
        Employee employee = employeeMapper.getById(id);
        employee.setPassword(&quot;****&quot;);
        return employee;
    &#125;

    /**
     * 编辑员工信息
     * @param employeeDTO
     */
    public void update(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
        BeanUtils.copyProperties(employeeDTO, employee);

        //employee.setUpdateTime(LocalDateTime.now());
        //employee.setUpdateUser(BaseContext.getCurrentId());

        employeeMapper.update(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
 /**
     * 根据主键动态修改属性
     * @param employee
     */
    void update(Employee employee);

    /**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)
    Employee getById(Long id);
</code></pre>
<blockquote>
<ul>
<li>前端提交表单：<br>用户在前端页面编辑员工信息并提交表单。<br>表单数据被序列化为 JSON 格式，通过 HTTP PUT 请求发送到后端。</li>
<li>后端接收数据：<br>控制器方法 update 接收到 EmployeeDTO 对象。<br>记录日志，输出接收到的员工信息。<br>调用服务层的 update 方法，处理员工信息的更新。</li>
<li>服务层处理：<br>创建一个新的 Employee 对象。<br>使用 BeanUtils.copyProperties 将 EmployeeDTO 的属性复制到 Employee 对象中。<br>调用 MyBatis 的 employeeMapper，执行更新操作。</li>
<li>MyBatis 更新操作：<br>生成动态 SQL 语句，只更新传入的非 null 属性。<br>例如，如果 name 和 phone 不为 null，生成的 SQL 语句如下：</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>数据回写的具体过程</strong></span></p>
<blockquote>
<ul>
<li>前端请求获取员工信息   &#x2F;&#x2F; 根据id查询员工信息<br>当你点击编辑按钮时，前端会发起一个 HTTP GET 请求，从后端获取员工的详细信息。这些信息将被用来填充表单字段。</li>
<li>后端处理 GET 请求<br>后端需要提供一个接口来处理这个 GET 请求，并返回员工的详细信息。</li>
<li>前端处理响应并填充表单<br>前端接收到后端返回的员工信息后，将其填充到表单字段中</li>
</ul>
<pre><code class="java">/**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @GetMapping(&quot;&#123;/id&#125;&quot;)
    @ApiOperation(&quot;根据id查询员工信息&quot;)
    public Result&lt;Employee&gt; getById(@PathVariable Long id) &#123;
        log.info(&quot;根据id查询员工信息：&#123;&#125;&quot;, id);
        Employee employee = employeeService.getById(id);
        return Result.success(employee);
    &#125;
</code></pre>
<pre><code class="vue">&lt;script&gt;export default &#123;
  data() &#123;
    return &#123;
      employee: &#123;
        id: null,
        name: &#39;&#39;,
        username: &#39;&#39;,
        password: &#39;&#39;,
        phone: &#39;&#39;,
        sex: &#39;&#39;,
        idNumber: &#39;&#39;
      &#125;
    &#125;;
  &#125;,
  methods: &#123;
    async fetchEmployee(id) &#123;
      try &#123;
        const response = await this.$axios.get(`/employees/$&#123;id&#125;`);
        this.employee = response.data.data;
      &#125; catch (error) &#123;
        console.error(&#39;获取员工信息失败&#39;, error);
      &#125;
    &#125;,
    async updateEmployee() &#123;
      try &#123;
        await this.$axios.put(&#39;/employees&#39;, this.employee);
        alert(&#39;员工信息更新成功&#39;);
      &#125; catch (error) &#123;
        console.error(&#39;更新员工信息失败&#39;, error);
      &#125;
    &#125;
  &#125;,
  mounted() &#123;
    const id = this.$route.params.id; // 假设通过路由参数传递员工ID
    this.fetchEmployee(id);
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<ul>
<li>提交表单<br>当用户编辑完表单并点击保存按钮时，前端会发起一个 HTTP PUT 请求，将更新后的员工信息发送到后端进行处理</li>
</ul>
<p><strong>总结</strong><br>前端请求获取员工信息：点击编辑按钮时，前端发起 GET 请求获取员工的详细信息。<br>后端处理 GET 请求：后端提供一个接口处理 GET 请求，返回员工的详细信息。<br>前端处理响应并填充表单：前端接收到员工信息后，将其填充到表单字段中。<br>提交表单：用户编辑完表单并点击保存按钮，前端发起 PUT 请求，将更新后的员工信息发送到后端进行处理。</p>
</blockquote>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/default/%E5%91%98%E5%B7%A5%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/updateUsingPUT">http://localhost:8080/doc.html#/default/员工相关接口/updateUsingPUT</a>)</p>
<h4 id="导入分类管理功能代码"><a href="#导入分类管理功能代码" class="headerlink" title="导入分类管理功能代码"></a>导入分类管理功能代码</h4><h6 id="业务规则：-1"><a href="#业务规则：-1" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>分类名称必须是<strong>唯一</strong>的</li>
<li>分类按章类型可分为<strong>菜品分类</strong>和<strong>套餐分类</strong></li>
<li>新添加的分类状态默认认为 “<strong>禁用</strong>“</li>
</ul>
<h6 id="接口设计："><a href="#接口设计：" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li>新增分类</li>
<li>分类分页查询</li>
<li>根据id删除分类</li>
<li>修改分类</li>
<li>启用禁止分类</li>
<li>根据类型调查分类</li>
</ul>
<p><strong>数据库设计(category表)</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/CategoryController.java
package com.sky.controller.admin;

import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import com.sky.result.Result;
import com.sky.service.CategoryService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

/**
 * 分类管理
 */
@RestController
@RequestMapping(&quot;/admin/category&quot;)
@Api(tags = &quot;分类相关接口&quot;)
@Slf4j
public class CategoryController &#123;

    @Autowired
    private CategoryService categoryService;

    /**
     * 新增分类
     * @param categoryDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增分类&quot;)
    public Result&lt;String&gt; save(@RequestBody CategoryDTO categoryDTO)&#123;
        log.info(&quot;新增分类：&#123;&#125;&quot;, categoryDTO);
        categoryService.save(categoryDTO);
        return Result.success();
    &#125;

    /**
     * 分类分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;分类分页查询&quot;)
    public Result&lt;PageResult&gt; page(CategoryPageQueryDTO categoryPageQueryDTO)&#123;
        log.info(&quot;分页查询：&#123;&#125;&quot;, categoryPageQueryDTO);
        PageResult pageResult = categoryService.pageQuery(categoryPageQueryDTO);
        return Result.success(pageResult);
    &#125;

    /**
     * 删除分类
     * @param id
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;删除分类&quot;)
    public Result&lt;String&gt; deleteById(Long id)&#123;
        log.info(&quot;删除分类：&#123;&#125;&quot;, id);
        categoryService.deleteById(id);
        return Result.success();
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改分类&quot;)
    public Result&lt;String&gt; update(@RequestBody CategoryDTO categoryDTO)&#123;
        categoryService.update(categoryDTO);
        return Result.success();
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;启用禁用分类&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id)&#123;
        categoryService.startOrStop(status,id);
        return Result.success();
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据类型查询分类&quot;)
    public Result&lt;List&lt;Category&gt;&gt; list(Integer type)&#123;
        List&lt;Category&gt; list = categoryService.list(type);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/CategoryService.java
package com.sky.service;

import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增分类
     * @param categoryDTO
     */
    void save(CategoryDTO categoryDTO);

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    void deleteById(Long id);

    /**
     * 修改分类
     * @param categoryDTO
     */
    void update(CategoryDTO categoryDTO);

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/CategoryServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.context.BaseContext;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.CategoryMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 分类业务层
 */
@Service
@Slf4j
public class CategoryServiceImpl implements CategoryService &#123;

    @Autowired
    private CategoryMapper categoryMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 新增分类
     * @param categoryDTO
     */
    public void save(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        //属性拷贝
        BeanUtils.copyProperties(categoryDTO, category);

        //分类状态默认为禁用状态0
        category.setStatus(StatusConstant.DISABLE);

        //设置创建时间、修改时间、创建人、修改人
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContext.getCurrentId());
        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.insert(category);
    &#125;

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123;
        PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());
        //下一条sql进行分页，自动加入limit关键字分页
        Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 根据id删除分类
     * @param id
     */
    public void deleteById(Long id) &#123;
        //查询当前分类是否关联了菜品，如果关联了就抛出业务异常
        Integer count = dishMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
        &#125;

        //查询当前分类是否关联了套餐，如果关联了就抛出业务异常
        count = setmealMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);
        &#125;

        //删除分类数据
        categoryMapper.deleteById(id);
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     */
    public void update(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO,category);

        //设置修改时间、修改人
        category.setUpdateTime(LocalDateTime.now());
        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.update(category);
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        Category category = Category.builder()
                .id(id)
                .status(status)
                .updateTime(LocalDateTime.now())
                .updateUser(BaseContext.getCurrentId())
                .build();
        categoryMapper.update(category);
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    public List&lt;Category&gt; list(Integer type) &#123;
        return categoryMapper.list(type);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/CategoryMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.enumeration.OperationType;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;

@Mapper
public interface CategoryMapper &#123;

    /**
     * 插入数据
     * @param category
     */
    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +
            &quot; VALUES&quot; +
            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)
    void insert(Category category);

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    Page&lt;Category&gt; pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    @Delete(&quot;delete from category where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);

    /**
     * 根据id修改分类
     * @param category
     */
    void update(Category category);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  mapper/CategoryMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.CategoryMapper&quot;&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Category&quot;&gt;
        select * from category
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;type != null&quot;&gt;
                and type = #&#123;type&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by sort asc , create_time desc
    &lt;/select&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;Category&quot;&gt;
        update category
        &lt;set&gt;
            &lt;if test=&quot;type != null&quot;&gt;
                type = #&#123;type&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;sort != null&quot;&gt;
                sort = #&#123;sort&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;Category&quot;&gt;
        select * from category
        where status = 1
        &lt;if test=&quot;type != null&quot;&gt;
            and type = #&#123;type&#125;
        &lt;/if&gt;
        order by sort asc,create_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface DishMapper &#123;

    /**
     * 根据分类id查询菜品数量
     * @param categoryId
     * @return
     */
    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long categoryId);

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface SetmealMapper &#123;

    /**
     * 根据分类id查询套餐的数量
     * @param id
     * @return
     */
    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long id);

&#125;
</code></pre>
<h2 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h2><h4 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h4><p>业务表中的公共字段：(后期会很多[菜品&#x2F;套餐管理])</p>
<h6 id="问题：代码冗余不利于后期维护"><a href="#问题：代码冗余不利于后期维护" class="headerlink" title="问题：代码冗余不利于后期维护"></a>问题：代码冗余不利于后期维护</h6><table>
<thead>
<tr>
<th>序号</th>
<th>字段名</th>
<th>含义</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>create_time</td>
<td>创建时间</td>
<td>datetime</td>
</tr>
<tr>
<td>2</td>
<td>create_user</td>
<td>创建人id</td>
<td>bigint</td>
</tr>
<tr>
<td>3</td>
<td>update_time</td>
<td>修改时间</td>
<td>datetime</td>
</tr>
<tr>
<td>4</td>
<td>update_user</td>
<td>修改人id</td>
<td>bigint</td>
</tr>
</tbody></table>
<h6 id="解决：技术点-→-枚举、注解、AOP、反射"><a href="#解决：技术点-→-枚举、注解、AOP、反射" class="headerlink" title="解决：技术点 → 枚举、注解、AOP、反射"></a>解决：技术点 → 枚举、注解、AOP、反射</h6><table>
<thead>
<tr>
<th>序号</th>
<th>字段名</th>
<th>含义</th>
<th>数据类型</th>
<th>操作类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>create_time</td>
<td>创建时间</td>
<td>datetime</td>
<td>insert</td>
</tr>
<tr>
<td>2</td>
<td>create_user</td>
<td>创建人id</td>
<td>bigint</td>
<td>insert</td>
</tr>
<tr>
<td>3</td>
<td>update_time</td>
<td>修改时间</td>
<td>datetime</td>
<td>insert、update</td>
</tr>
<tr>
<td>4</td>
<td>update_user</td>
<td>修改人id</td>
<td>bigint</td>
<td>insert、update</td>
</tr>
</tbody></table>
<ul>
<li>自定义注解 <strong>AutoFill</strong>，用于标识需要进行公共字段自动填充的方法</li>
<li>自定义切面 <strong>AutoFillAspect</strong>，统一拦截加入了 <strong>AutoFill</strong> 注解的方法，通过反射为公共字段赋值</li>
<li>在 <strong>Mapper</strong> 的方法上加入 <strong>AutoFill</strong> 注解</li>
</ul>
<h4 id="代码开发1"><a href="#代码开发1" class="headerlink" title="代码开发1"></a>代码开发1</h4><pre><code class="java">sky-server  com/sky/annotation/AutoFill.java
package com.sky.annotation;

import com.sky.enumeration.OperationType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill &#123;
// 枚举数据库操作类型：UPDATE INSERT [只要在这情况才有必要设置]
    OperationType value();
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/aspect/AutoFillAspect.java
package com.sky.aspect;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
//只在update和insert里加
@Mapper
public interface EmployeeMapper &#123;
 /**
     * 插入员工数据
     * @param employee
     */
    @Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user,status) &quot; +
            &quot;values &quot; +
            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)
    @AutoFill(value = OperationType.INSERT)
    void insert(Employee employee);
/**
     * 分页查询 [动态sql 不用注解了 写道 EmployeeMapper.xml]
     * @param employeePageQueryDTO
     * @return
     */
    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
    @AutoFill(value = OperationType.UPDATE)
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/CategoryMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.annotation.AutoFill;
import com.sky.enumeration.OperationType;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;
@Mapper
public interface CategoryMapper &#123;

    /**
     * 插入数据
     * @param category
     */
    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +
            &quot; VALUES&quot; +
            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)
    void insert(Category category);

    /**
     * 根据id修改分类
     * @param category
     */
    void update(Category category);
&#125;
</code></pre>
<p><span style = "color:orange"><strong>详细讲解@AutoFill</strong></span></p>
<blockquote>
<p><strong><u>@Target(ElementType.<em>METHOD</em>)</u></strong><br>使用<code>@Target</code>注解指定自定义注解@AutoFill可以应用的目标元素类，这里指定了<code>ElementType.METHOD</code>，表示@AutoFill**<u>只能应用于方法上</u>**</p>
<p><strong><u>@Retention(RetentionPolicy.RUNTIME)</u></strong><br>使用 <code>@Retention</code> 注解指定自定义注解 @AutoFill 的保留策略。这里指定了 <code>RetentionPolicy.RUNTIME</code>，表示 @AutoFill 注解会在运行时保留，可以通过反射获取到。</p>
<p><strong><u>public @interface AutoFill {…}</u></strong><br>@interface：关键字，用于定义一个新的注解类型。<br>AutoFill：注解的名称，表示这个注解就叫做AutoFill</p>
<p>区分普通接口：<code>@interface</code> 与普通的 <code>interface</code> 不同，普通的interface用于定义接口，而@interface用于定义注解，@符号帮助编译器区分这两者</p>
<pre><code class="java">package com.sky.enumeration;

/**
 * 数据库操作类型
 */
public enum OperationType &#123;
    /**
     * 更新操作
     */
    UPDATE,

    /**
     * 插入操作
     */
    INSERT
&#125;
</code></pre>
<hr>
<p>@<strong><u>Aspect</u></strong><br>使用<code>@Aspect</code>注解将这个类标记为一个切面，切面是AOP(面向切面编程)，用于定义切面关注点(日志记录、事务管理)</p>
<p>@<strong><u>Component</u></strong><br>使用<code>@Component</code>注解将这个类标记为Spring管理的Bean，这样Spring容器会自动扫描并管理这个类的实例</p>
<p>@<strong><u>Slf4j</u></strong><br>使用 <code>@Slf4j</code> 注解生成一个日志记录器（Logger）实例。这个注解来自 Lombok 库，可以简化日志记录器的创建</p>
<pre><code class="java">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;
</code></pre>
<p>使用<code>@Pointcut</code>注解定义一个切入点<code>autoFillPointCut</code></p>
<ul>
<li><code>execution(* com.sky.mapper.*.*(..))</code>：匹配<code>com.sky.mapper</code>包下所有类的所有方法</li>
<li><code>&amp;&amp; @annotation(com.sky.annotation.AutoFill)</code>：并且这些方法必须带有<code>@AutoFill</code>注解</li>
<li>public void autoFillPointCut()：定义一个空的方法，用于标识这个切入点</li>
</ul>
<pre><code class="java">/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);
    &#125;
&#125;
</code></pre>
<p>使用<code>@Before</code>注解定义一个前置通知<code>autoFill</code>，这个通知会在切入点方法执行前被调用</p>
<ul>
<li><code>@Before(&quot;autoFillPointCut()&quot;)</code>：指定这个通知应用于<code>autoFillPointCut</code>切入点</li>
<li><code>public void autoFill(JoinPoint joinPoint)</code>：定义通知方法，接收一个<code>JoinPoint</code>参数，<code>JoinPoint</code>包含了连接点的信息，如被拦截的方法、参数等</li>
</ul>
</blockquote>
<h4 id="代码开发2"><a href="#代码开发2" class="headerlink" title="代码开发2"></a>代码开发2</h4><blockquote>
<p>公共属性赋值后 Service里的 save(Employee employee) → employee.setCreateUser(BaseContext.getCurrentId())就不用再去赋值了</p>
</blockquote>
<h6 id="这个写完后-就可以把Service里的一些employee-setXXX的删除了-因为公共属性只需要加-AutoFill"><a href="#这个写完后-就可以把Service里的一些employee-setXXX的删除了-因为公共属性只需要加-AutoFill" class="headerlink" title="这个写完后 就可以把Service里的一些employee.setXXX的删除了 因为公共属性只需要加@AutoFill"></a>这个写完后 就可以把Service里的一些employee.setXXX的删除了 因为公共属性只需要加@AutoFill</h6><pre><code class="java">sky-server  com/sky/annotation/AutoFill.java 不变
sky-server  com/sky/aspect/AutoFillAspect.java
package com.sky.aspect;

import com.sky.annotation.AutoFill;
import com.sky.constant.AutoFillConstant;
import com.sky.context.BaseContext;
import com.sky.enumeration.OperationType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;

/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);

        // 获取当前被拦截的方法上的数据库操作类型(Update/Insert)
        MethodSignature signature = (MethodSignature)joinPoint.getSignature(); //方法签名对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class); //获得方法上的注解对象
        OperationType operationType = autoFill.value();//获得数据库操作类型

        // 获取当当前被拦截的方法的参数--实体对象 (Employee employee)
        Object[] args = joinPoint.getArgs();
        if (args == null || args.length == 0) &#123; //没有参数不执行
            return;
        &#125;
        Object entity = args[0]; //获得第一个

        // 准备赋值数据
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();

        // 根据当前不同的操作类型，对对应的属性通过反射来赋值
        if (operationType == OperationType.INSERT) &#123;
            // 为4个公共字段赋值
            Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
            Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);


            //通过反射对对象赋值属性
            setCreateTime.invoke(entity,now);
            setCreateUser.invoke(entity,currentId);
            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        &#125; else if (operationType == OperationType.UPDATE) &#123;
            // 为2个公共字段赋值
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

            //通过反射对对象赋值属性
            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h3><h6 id="业务规则：-2"><a href="#业务规则：-2" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>菜品名称必须是唯一的</li>
<li>菜品必须属于某个分类下，不能单独存在</li>
<li>新增菜品时可以根据选择情况菜品的口味</li>
<li>每个菜品必须对应一张图片</li>
</ul>
<h6 id="接口设计：-1"><a href="#接口设计：-1" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>根据类型查询分类(已完成) <code>/admin/category/list    GET</code></p>
<p><u>这里要注意数据返回 因为它里面的口味算一个集合</u></p>
</li>
<li><p>文件上传 <code>/admin/common/upload    POST</code>   </p>
</li>
<li><p>新增菜品 <code>/admin/dish    POST</code></p>
</li>
</ul>
<h6 id="数据库设计："><a href="#数据库设计：" class="headerlink" title="数据库设计："></a>数据库设计：</h6><ul>
<li>dish菜品表 [一个菜品对应着多种口味]</li>
<li>dish_flavour口味表</li>
</ul>
<h6 id="开发文件上传接口："><a href="#开发文件上传接口：" class="headerlink" title="开发文件上传接口："></a>开发文件上传接口：</h6><p>浏览器 → 后端服务 → 阿里云OSS</p>
<pre><code class="java">sky-common  com/sky/utils/AliOssUtil.java
package com.sky.utils;

import com.aliyun.oss.ClientException;
import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.OSSException;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;


import java.io.ByteArrayInputStream;

@Data
@AllArgsConstructor
@Slf4j
public class AliOssUtil &#123;
// 通过配置类初始化这些数据
    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;

    /**
     * 文件上传
     *
     * @param bytes
     * @param objectName
     * @return
     */
    public String upload(byte[] bytes, String objectName) &#123;

 // 创建OSSClient实例。 将字节数组转换为输入流，并将其上传到指定的bucket和objectName
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

        try &#123;
            // 创建PutObject请求。
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));
        &#125; catch (OSSException oe) &#123;
            System.out.println(&quot;Caught an OSSException, which means your request made it to OSS, &quot;
                    + &quot;but was rejected with an error response for some reason.&quot;);
            System.out.println(&quot;Error Message:&quot; + oe.getErrorMessage());
            System.out.println(&quot;Error Code:&quot; + oe.getErrorCode());
            System.out.println(&quot;Request ID:&quot; + oe.getRequestId());
            System.out.println(&quot;Host ID:&quot; + oe.getHostId());
        &#125; catch (ClientException ce) &#123;
            System.out.println(&quot;Caught an ClientException, which means the client encountered &quot;
                    + &quot;a serious internal problem while trying to communicate with OSS, &quot;
                    + &quot;such as not being able to access the network.&quot;);
            System.out.println(&quot;Error Message:&quot; + ce.getMessage());
        &#125; finally &#123;
            if (ossClient != null) &#123;
                ossClient.shutdown();
            &#125;
        &#125;

        //文件访问路径规则 https://BucketName.Endpoint/ObjectName
        StringBuilder stringBuilder = new StringBuilder(&quot;https://&quot;);
        stringBuilder
                .append(bucketName)
                .append(&quot;.&quot;)
                .append(endpoint)
                .append(&quot;/&quot;)
                .append(objectName);
        log.info(&quot;文件上传成功，访问路径：&#123;&#125;&quot;, stringBuilder);

        return stringBuilder.toString();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-common  com/sky/constant/AutoFillConstant.java
package com.sky.constant;

/**
 * 公共字段自动填充相关常量
 */
public class AutoFillConstant &#123;
    /**
     * 实体类中的方法名称
     */
    public static final String SET_CREATE_TIME = &quot;setCreateTime&quot;;
    public static final String SET_UPDATE_TIME = &quot;setUpdateTime&quot;;
    public static final String SET_CREATE_USER = &quot;setCreateUser&quot;;
    public static final String SET_UPDATE_USER = &quot;setUpdateUser&quot;;
&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
sky:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    host: localhost
    port: 3306
    database: sky_take_out
    username: root
    password: root
  alioss:
    endpoint: XXXXXXXXX
    access-key-id: XXXXXXXXXXXX
    access-key-secret: XXXXXXXXXXX
    bucketName: XXXXXXXXX
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/CommonController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.utils.AliOssUtil;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.UUID;

/**
 * 通用接口
 */
@RestController
@RequestMapping(&quot;/admin/common&quot;)
@Api(tags = &quot;通用接口&quot;)
@Slf4j
public class CommonController &#123;
    @Autowired
    private AliOssUtil aliOssUtil;
    @PostMapping(&quot;/upload&quot;)
    @ApiOperation(&quot;文件上传&quot;)
    // 如果要测试文件上传 只能用postman或者前后端联调
    public Result&lt;String&gt; upload(MultipartFile file) &#123;
        log.info(&quot;文件上传：&#123;&#125;&quot;, file);
        // 防止重名覆盖
        try &#123;
            // 原始文件名
            String filename = file.getOriginalFilename();
            // 截取原始文件名的后缀
            String extension = filename.substring(filename.lastIndexOf(&quot;.&quot;));
            // 构造新文件名UUID
            String objectName = UUID.randomUUID().toString() + extension;

            // 文件的请求路径
            String filepath = aliOssUtil.upload(file.getBytes(), objectName);
            log.info(&quot;文件上传成功，访问路径：&#123;&#125;&quot;, filepath);
            return Result.success(filepath);
        &#125; catch (IOException e) &#123;
            log.error(&quot;文件上传失败：&#123;&#125;&quot;, e);
        &#125;
        return Result.error(MessageConstant.UPLOAD_FAILED);
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>如何让application.yml识别到我在application-dev.yml里设置的值呢？</strong></span></p>
<pre><code class="yaml">server:
  port: 8080

spring:
  profiles:
    active: dev

你已经在 application.yml 中指定了 spring.profiles.active: dev，这样在启动应用程序时，Spring Boot 会自动加载 application-dev.yml 中的配置

如果你使用的是 IDE（如 IntelliJ IDEA 或 Eclipse），你可以在运行配置中指定激活的环境配置文件。例如，在 IntelliJ IDEA 中：
打开 Run -&gt; Edit Configurations。
选择你的应用程序配置。
在 VM options 中添加 -Dspring.profiles.active=dev。

# 在 VM options 中配置的原理：
在 VM options 中添加 -Dspring.profiles.active=dev 的原理是通过 Java 虚拟机（JVM）的系统属性来设置 Spring Boot 应用程序的活动配置文件。以下是详细的解释：
原理
JVM 系统属性：
JVM 提供了一种机制，允许你在启动时通过命令行参数传递系统属性。这些系统属性可以在应用程序中通过 System.getProperty 方法访问。
-D 前缀用于设置系统属性。例如，-Dkey=value 会将 key 设置为 value。
Spring Boot 配置：
Spring Boot 会读取 spring.profiles.active 系统属性来确定当前激活的配置文件。
当你通过 -Dspring.profiles.active=dev 设置系统属性时，Spring Boot 会在启动时读取这个属性，并根据其值加载相应的配置文件（如 application-dev.yml）。
</code></pre>
<h6 id="新增菜品重要代码"><a href="#新增菜品重要代码" class="headerlink" title="新增菜品重要代码"></a>新增菜品重要代码</h6><pre><code class="java">sky-pojo  com/sky/dto/DishDTO.java
package com.sky.dto;

import com.sky.entity.DishFlavor;
import lombok.Data;
import java.io.Serializable;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Data
public class DishDTO implements Serializable &#123;
    //dish属性封装成dto

    private Long id;
    //菜品名称
    private String name;
    //菜品分类id
    private Long categoryId;
    //菜品价格
    private BigDecimal price;
    //图片
    private String image;
    //描述信息
    private String description;
    //0 停售 1 起售
    private Integer status;
    //口味[因为有多种口味要区分]
    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();

&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/entity/DishFlavor.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 菜品口味
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DishFlavor implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;
    //菜品id
    private Long dishId;

    //口味名称
    private String name;

    //口味数据list
    private String value;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
package com.sky.controller.admin;

import com.sky.dto.DishDTO;
import com.sky.result.Result;
import com.sky.service.DishService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 菜品管理
 */
@RestController
@RequestMapping(&quot;/admin/dish&quot;)
@Api(tags = &quot;菜品相关接口&quot;)
@Slf4j
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @PostMapping
    @ApiOperation(&quot;新增菜品&quot;)
    //@RequestBody 封装JSON格式的数据
    public Result save(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);
        dishService.saveWithFlavour(dishDTO);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);
&#125;
</code></pre>
<pre><code class="java">com/sky/service/impl/DishServiceImpl.java
package com.sky.service.impl;

import com.sky.dto.DishDTO;
import com.sky.entity.Dish;
import com.sky.entity.DishFlavor;
import com.sky.mapper.DishFlavorMapper;
import com.sky.mapper.DishMapper;
import com.sky.service.DishService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@Slf4j

public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    @Override
    @Transactional //保证事务一致性
    public void saveWithFlavour(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        //直接new出来是空的需要先赋值 属性拷贝[属性命名要一致]
        BeanUtils.copyProperties(dishDTO,dish);

        // 向菜品表插入1条数据
        dishMapper.insert(dish);
        // 前端无法传 要获取dishId
// &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; 获取主键值
        Long dishId = dish.getId();

        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishId);
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
package com.sky.mapper;

import com.sky.annotation.AutoFill;
import com.sky.entity.Dish;
import com.sky.enumeration.OperationType;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface DishMapper &#123;

    /**
     * 根据分类id查询菜品数量
     * @param categoryId
     * @return
     */
    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long categoryId);

    /**
     * 插入菜品数据
     */
    @AutoFill(value = OperationType.INSERT)
    void insert(Dish dish);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/DishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;
    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,
                          update_user, status)
        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;,
                #&#123;updateUser&#125;, #&#123;status&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
package com.sky.mapper;

import com.sky.entity.DishFlavor;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface DishFlavorMapper &#123;
    /**
     * 批量插入口味数据
     */
    void insertBatch(List&lt;DishFlavor&gt; flavors);
&#125;
</code></pre>
<pre><code class="java">sky-server  mapper/DishFlavorMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishFlavorMapper&quot;&gt;

    &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish_flavor (dish_id, name, value) values
        &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;
            (#&#123;df.dishId&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="菜品分页查询"><a href="#菜品分页查询" class="headerlink" title="菜品分页查询"></a>菜品分页查询</h3><blockquote>
<p>菜品名称[         ]     菜品分类[         ]     售卖状态[         ]         [搜索]<br>菜品名称、图片、菜品分类、售价、售卖状态、最后操作事件、操作[修改 删除 启售,停售]<br>                                                                                                                            右下角 分页操作</p>
</blockquote>
<h6 id="业务规则：-3"><a href="#业务规则：-3" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>根据页码展示菜品信息</li>
<li>每页展示10条数据</li>
<li>分页查询时可以根据需要输入<strong>菜品名称、菜品分类、菜品状态</strong>进行查询</li>
</ul>
<h6 id="接口设计：-2"><a href="#接口设计：-2" class="headerlink" title="接口设计："></a>接口设计：</h6><p><strong>Path</strong>：&#x2F;admin&#x2F;dish&#x2F;page<br><strong>Method</strong>：GET</p>
<h6 id="代码开发："><a href="#代码开发：" class="headerlink" title="代码开发："></a>代码开发：</h6><p>根据菜品分页查询接口定义设计对应的<strong>DTO</strong><br>根据菜品分页查询接口定义设计对应的<strong>VO</strong>[转成Json数据给前端]</p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
@GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;菜品分页查询&quot;)
    public Result&lt;PageResult&gt; page(DishPageQueryDTO dishPageQueryDTO)&#123;
        log.info(&quot;菜品分页查询：&#123;&#125;&quot;, dishPageQueryDTO);
        PageResult pageResult = dishService.pageQuery(dishPageQueryDTO);
        return Result.success(pageResult);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.result.PageResult;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
@Service
@Slf4j
public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
 @Override
    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;
  // 1. 开启分页功能，设置当前页和每页显示的数量
        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
 // 2. 调用 dishMapper 的 pageQuery 方法进行分页查询，返回一个 Page&lt;DishVO&gt; 对象
        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);
     // 3. 创建并返回 PageResult 对象，包含总记录数和查询结果列表
        return new PageResult(page.getTotal(), page.getResult());
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    Page&lt;DishVO&gt; pageQuery(DishPageQueryDTO dishPageQueryDTO);
</code></pre>
<pre><code class="mysql">sky-server  mapper/DishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;
    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,
                          update_user, status)
        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;,
                #&#123;updateUser&#125;, #&#123;status&#125;)
    &lt;/insert&gt;
    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;
        select d.*, c.name as categoryName
        from dish d
            left join category c
                on d.category_id=c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and d.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and d.status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by d.update_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><span style="color:orange"><strong>分页查询SQL语句分析</strong></span></p>
<blockquote>
<pre><code class="mysql">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;
        select d.*, c.name as categoryName
        from dish d
            left join category c
                on d.category_id=c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and d.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and d.status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by d.update_time desc
    &lt;/select&gt;
</code></pre>
<p>从 dish 表中选择所有列，并从 category 表中选择 name 列，别名为 categoryName。<br>使用左连接 (left join) 将 dish 表和 category 表连接起来，连接条件是 d.category_id &#x3D; c.id。</p>
<p>动态生成WHERE子句，&lt; where &gt;标签会自动处理AND和OR关键字的添加，并且会忽略第一个条件前的ADN和OR</p>
</blockquote>
<h3 id="删除菜品"><a href="#删除菜品" class="headerlink" title="删除菜品"></a>删除菜品</h3><blockquote>
<p>单个删除、批量删除、先停售后删除</p>
</blockquote>
<h6 id="业务规则：-4"><a href="#业务规则：-4" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>可以一次删除一个菜品，也可以批量删除菜品</li>
</ul>
<blockquote>
<p><strong>Path</strong>: &#x2F;admin&#x2F;dish<br><strong>Method</strong>: DELETE<br><strong>数据库设计</strong>：<br>dish表 → id 【菜品】<br>dish_flavor表 → dish_id 【口味】<br>setmeal_dish表 → dish_id</p>
</blockquote>
<ul>
<li>起售中的菜品不能删除</li>
<li>被套餐关联的菜品不能删除</li>
<li>删除菜品后，关联的口味数据也需要删除</li>
</ul>
<h6 id="代码开发：-1"><a href="#代码开发：-1" class="headerlink" title="代码开发："></a>代码开发：</h6><pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除菜品&quot;)
    //@RequestParam MVC动态解析字符串 ids提取出来
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123; //ids
        log.info(&quot;批量删除菜品：&#123;&#125;&quot;, ids);
        dishService.deleteBatch(ids);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    void deleteBatch(List&lt;Long&gt; ids);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @Override
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        // 判断当前菜品是否能够删除--是否存在起售中的菜品？？ 取出id
        for (Long id : ids) &#123;
            Dish dish = dishMapper.getById(id);
            if (dish.getStatus() == StatusConstant.ENABLE) &#123;
                //当前菜品处于起售中，不能删除
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            &#125;
        &#125;

        // 判断当前菜品是否能够删除--是否被套餐关联了
        List&lt;Long&gt; setMealIds = setmealDishMapper.getSetmealIdsByDishId(ids);
        if (setMealIds != null &amp;&amp; setMealIds.size() &gt; 0) &#123; //存在不允许删除
            // 当前菜品被套餐关联了，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        &#125;
        // 删除菜品表中的菜品数据
        for (Long id : ids) &#123;
            dishMapper.deleteById(id);
            // 删除菜品关联的口味数据
            dishFlavorMapper.deleteByDishId(id);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 根据主键删除菜品数据
     */

    @Delete(&quot;delete from dish where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
/**
     * 根据菜品id删除对应的 口味数据
     * @param id
     */
    @Delete(&quot;delete from dish_flavor where dish_id = #&#123;id&#125;&quot;)
    void deleteByDishId(Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealDishMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface SetmealDishMapper &#123;
    /**
     * 根据菜品id查询对应的套餐id
     * @param dishIds
     * @return
     */
    // select setmeal_id from setmeal_dish where dish_id in (1,2,3)
    // 在mapper.xml中dishIds是形参  &lt;foreach collection=&quot;dishIds&quot;&gt;
    List&lt;Long&gt; getSetmealIdsByDishId(List&lt;Long&gt; dishIds);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealDishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealDishMapper&quot;&gt;

    &lt;select id=&quot;getSetmealIdsByDishId&quot; resultType=&quot;java.lang.Long&quot;&gt;
        SELECT setmeal_id
        FROM setmeal_dish
        WHERE dish_id IN
        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
           #&#123;dishId&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
&lt;/mapper&gt;

&lt;!--
★ foreach 标签用于遍历集合，并生成相应的 SQL 语句。
★ collection=&quot;dishIds&quot;：指定要遍历的集合名称，即传入的参数 dishIds。
★ item=&quot;dishId&quot;：指定集合中的每个元素的别名，即每次迭代时的变量名。
★ separator=&quot;,&quot;：指定每个元素之间的分隔符，这里是逗号 ,。
★ open=&quot;(&quot; 和 close=&quot;)&quot;：指定生成的 SQL 语句的开始和结束符号，这里是括号 ( 和 )。
--&gt;
</code></pre>
<p><span style="color:orange">@<strong>RequestParm详细分析</strong></span></p>
<blockquote>
<p><code>public Result delete(@RequestParam List&lt;Long&gt; ids)</code></p>
<p><code>@RequestParam</code>：注解用于将请求参数绑定到方法参数上。具体来说，它可以从请求的查询参数中提取出指定的参数值，并将其转换为方法参数的类型；在这个例子中，@RequestParam List<Long> ids 表示从请求的查询参数中提取 ids 参数，并将其转换为 List<Long> 类型。</p>
</blockquote>
<h3 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h3><h6 id="数据回显"><a href="#数据回显" class="headerlink" title="数据回显"></a>数据回显</h6><p><strong>接口设计：</strong></p>
<ul>
<li>根据id查询菜品</li>
</ul>
<blockquote>
<p>口味也要回显<br><strong>Path:</strong>  &#x2F;admin&#x2F;dish&#x2F;{id}<br><strong>Method：</strong>GET</p>
</blockquote>
<ul>
<li>根据类型查询分类(已实现)</li>
<li>文件上传(已实现)</li>
<li>修改菜品</li>
</ul>
<blockquote>
<p>根据ID修改<br><strong>Path：</strong>&#x2F;admin&#x2F;dish<br><strong>Method：</strong>PUT</p>
</blockquote>
<h6 id="代码开发：-2"><a href="#代码开发：-2" class="headerlink" title="代码开发："></a>代码开发：</h6><p><strong>根据id查询菜品进行信息回显</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询菜品&quot;)
//  @PathVariable 注解用于从 URL 路径中的占位符参数中提取值，并将其绑定到方法参数上
    public Result&lt;DishVO&gt; getById(@PathVariable long id) &#123;
        log.info(&quot;根据id查询菜品：&#123;&#125;&quot;, id);
        DishVO dishVO = dishService.getByIdWithFlavor(id);
        return Result.success(dishVO);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    DishVO getByIdWithFlavor(long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @Override
    public DishVO getByIdWithFlavor(long id) &#123;
        // 根据id查询菜品数据
        Dish dish = dishMapper.getById(id);
        // 根据菜品id查询口味数据
        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);

        // 将查询到的数据封装到VO
        DishVO dishVO = new DishVO();
            // 属性拷贝
        BeanUtils.copyProperties(dish,dishVO);
        dishVO.setFlavors(dishFlavors);

        return dishVO;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
/**
     * 根据菜品id查询对应的口味数据
     * @param id
     * @return
     */
    @Select(&quot;select * from dish_flavor where dish_id = #&#123;id&#125;&quot;)
    List&lt;DishFlavor&gt; getByDishId(long id);
</code></pre>
<p><strong>修改菜品接口</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改菜品&quot;)
    public Result update(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);
        dishService.updateWithFlavor(dishDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    void updateWithFlavor(DishDTO dishDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    @Override
    public void updateWithFlavor(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // 修改菜品表基本信息 只是基础信息噢
        dishMapper.update(dish);
        // 先删掉原先的
        dishFlavorMapper.deleteByDishId(dishDTO.getId());
        // 再重新插入新的
        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishDTO.getId());
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;
/*
这段代码中，将 dishDTO 的属性复制到 dish 对象的主要原因有以下几点：
数据模型分离：
dishDTO 通常用于数据传输，包含前端传来的所有数据。
dish 是数据库实体类，只包含数据库表中的字段。
安全性：
使用 BeanUtils.copyProperties 可以避免将不必要的字段（如前端传来的额外属性）写入数据库。
确保只有预期的字段被更新。
数据校验：
dishDTO 可以包含更多的验证逻辑或额外的属性，而 dish 对象则严格遵循数据库模型。
通过这种方式，可以在更新前对数据进行进一步校验。
事务管理：
添加 @Transactional 注解确保整个更新过程在一个事务中完成。
如果任何一步出错，整个事务都会回滚，保证数据一致性。
*/
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
 /**
     * 根据id修改菜品和对应的口味数据
     * @param dish
     */
    //有时间和修改人 不要忘记自动填充
    @AutoFill(value = OperationType.UPDATE)
    void update(Dish dish);
</code></pre>
<pre><code class="xml">sky-server  mapper/DishMapper.xml
&lt;update id=&quot;update&quot;&gt;
        update dish
        &lt;set&gt;
            &lt;if
                test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
</code></pre>
<h5 id="菜品起售停售"><a href="#菜品起售停售" class="headerlink" title="菜品起售停售"></a>菜品起售停售</h5><pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;菜品起售停售&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id) &#123;
        dishService.startOrStop(status, id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 菜品起售停售
     * @param status
     * @param id
     */
@Override
    public void startOrStop(Integer status, Long id) &#123;
        Dish dish = Dish.builder()
                .id(id)
                .status(status)
                .build();
        dishMapper.update(dish);

        if (status == StatusConstant.DISABLE) &#123;
            // 如果是停售操作，还需要将包含当前菜品的套餐也停售
            List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();
            dishIds.add(id);
            // select setmeal_id from setmeal_dish where dish_id in (?,?,?)
            List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);
            if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;
                for (Long setmealId : setmealIds) &#123;
                    Setmeal setmeal = Setmeal.builder()
                            .id(setmealId)
                            .status(StatusConstant.DISABLE)
                            .build();
                    setmealMapper.update(setmeal);
                &#125;
            &#125;

        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
/**
     * 根据id修改套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.UPDATE)
    void update(Setmeal setmeal);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java

    /**
     * 根据套餐id查询菜品
     * @param setmealId
     * @return
     */
    @Select(&quot;select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = #&#123;setmealId&#125;&quot;)
    List&lt;Dish&gt; getBySetmealId(Long setmealId);
/*
在 SQL 查询中添加筛选条件。
确保返回的结果集中，setmeal_dish 表中的 setmeal_id 字段值与传入的 setmealId 参数值相匹配，从而获取与指定套餐 ID 相关的菜品列表。
*/
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;
    &lt;resultMap id=&quot;setmealAndDishMap&quot; type=&quot;com.sky.vo.SetmealVO&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;setmealDishes&quot; ofType=&quot;SetmealDish&quot;&gt;
            &lt;result column=&quot;sd_id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;setmeal_id&quot; property=&quot;setmealId&quot;/&gt;
            &lt;result column=&quot;dish_id&quot; property=&quot;dishId&quot;/&gt;
            &lt;result column=&quot;sd_name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;sd_price&quot; property=&quot;price&quot;/&gt;
            &lt;result column=&quot;copies&quot; property=&quot;copies&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;
        update setmeal
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                category_id = #&#123;categoryId&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;price != null&quot;&gt;
                price = #&#123;price&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;description != null&quot;&gt;
                description = #&#123;description&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;image != null&quot;&gt;
                image = #&#123;image&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">@Mapper
public interface SetmealDishMapper &#123;
    /**
     * 根据菜品id查询对应的套餐id
     * @param dishIds
     * @return
     */
    // select setmeal_id from setmeal_dish where dish_id in (1,2,3)
    // 在mapper.xml中dishIds是形参  &lt;foreach collection=&quot;dishIds&quot;&gt;
    List&lt;Long&gt; getSetmealIdsByDishIds(List&lt;Long&gt; dishIds);
</code></pre>
<pre><code class="xml">SetmealDishMapper.xml
&lt;select id=&quot;getSetmealIdsByDishIds&quot; resultType=&quot;java.lang.Long&quot;&gt;
        select setmeal_id from setmeal_dish where dish_id in
        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
            #&#123;dishId&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
</code></pre>
<h4 id="修改套餐那些事"><a href="#修改套餐那些事" class="headerlink" title="修改套餐那些事"></a>修改套餐<del>那些事</del></h4><pre><code class="java">sky-server  com/sky/controller/admin/SetmealController.java
package com.sky.controller.admin;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.result.PageResult;
import com.sky.result.Result;
import com.sky.service.SetmealService;
import com.sky.vo.SetmealVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * 套餐管理
 */
@RestController
@RequestMapping(&quot;/admin/setmeal&quot;)
@Api(tags = &quot;套餐相关接口&quot;)
@Slf4j
public class SetmealController &#123;

    @Autowired
    private SetmealService setmealService;

    /**
     * 新增套餐
     *
     * @param setmealDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,key = &quot;#setmealDTO.categoryId&quot;)//key: setmealCache::100
    public Result save(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.saveWithDish(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;分页查询&quot;)
    public Result&lt;PageResult&gt; page(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        PageResult pageResult = setmealService.pageQuery(setmealPageQueryDTO);
        return Result.success(pageResult);
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;
        setmealService.deleteBatch(ids);
        return Result.success();
    &#125;

    /**
     * 根据id查询套餐，用于修改页面回显数据
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询套餐&quot;)
    public Result&lt;SetmealVO&gt; getById(@PathVariable Long id) &#123;
        SetmealVO setmealVO = setmealService.getByIdWithDish(id);
        return Result.success(setmealVO);
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result update(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.update(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 套餐起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;套餐起售停售&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result startOrStop(@PathVariable Integer status, Long id) &#123;
        setmealService.startOrStop(status, id);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/SetmealService.java
package com.sky.service;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.result.PageResult;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;

import java.util.List;

public interface SetmealService &#123;

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    void saveWithDish(SetmealDTO setmealDTO);

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询套餐和关联的菜品数据
     *
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    void update(SetmealDTO setmealDTO);

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    List&lt;DishItemVO&gt; getDishItemById(Long id);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/SetmealServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.SetmealDish;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.exception.SetmealEnableFailedException;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 套餐业务实现
 */
@Service
@Slf4j
public class SetmealServiceImpl implements SetmealService &#123;

    @Autowired
    private SetmealMapper setmealMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private DishMapper dishMapper;


    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    @Transactional
    public void saveWithDish(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //向套餐表插入数据
        setmealMapper.insert(setmeal);

        //获取生成的套餐id
        Long setmealId = setmeal.getId();

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);

        //保存套餐和菜品的关联关系
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        int pageNum = setmealPageQueryDTO.getPage();
        int pageSize = setmealPageQueryDTO.getPageSize();

        PageHelper.startPage(pageNum, pageSize);
        Page&lt;SetmealVO&gt; page = setmealMapper.pageQuery(setmealPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        ids.forEach(id -&gt; &#123;
            Setmeal setmeal = setmealMapper.getById(id);
            if (StatusConstant.ENABLE == setmeal.getStatus()) &#123;
                //起售中的套餐不能删除
                throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
            &#125;
        &#125;);

        ids.forEach(setmealId -&gt; &#123;
            //删除套餐表中的数据
            setmealMapper.deleteById(setmealId);
            //删除套餐菜品关系表中的数据
            setmealDishMapper.deleteBySetmealId(setmealId);
        &#125;);
    &#125;
/**
ids.forEach(id -&gt; &#123; ... &#125;)：对ids集合中的每个元素id执行大括号内的操作。
id -&gt; &#123; ... &#125;：定义了一个接受单个参数id的函数，并执行大括号内的逻辑。
在大括号内，根据id查询数据库获取套餐信息，并检查其状态，若状态符合启用条件，则抛出异常。
**/
    
    /**
     * 根据id查询套餐和套餐菜品关系
     *
     * @param id
     * @return
     */
    public SetmealVO getByIdWithDish(Long id) &#123;
        SetmealVO setmealVO = setmealMapper.getByIdWithDish(id);
        return setmealVO;
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    @Transactional
    public void update(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //1、修改套餐表，执行update
        setmealMapper.update(setmeal);

        //套餐id
        Long setmealId = setmealDTO.getId();

        //2、删除套餐和菜品的关联关系，操作setmeal_dish表，执行delete
        setmealDishMapper.deleteBySetmealId(setmealId);

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);
        //3、重新插入套餐和菜品的关联关系，操作setmeal_dish表，执行insert
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        //起售套餐时，判断套餐内是否有停售菜品，有停售菜品提示&quot;套餐内包含未启售菜品，无法启售&quot;
        if (status == StatusConstant.ENABLE) &#123;
            //select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = ?
            List&lt;Dish&gt; dishList = dishMapper.getBySetmealId(id);
            if (dishList != null &amp;&amp; dishList.size() &gt; 0) &#123;
                dishList.forEach(dish -&gt; &#123;
                    if (StatusConstant.DISABLE == dish.getStatus()) &#123;
                        throw new SetmealEnableFailedException(MessageConstant.SETMEAL_ENABLE_FAILED);
                    &#125;
                &#125;);
            &#125;
        &#125;

        Setmeal setmeal = Setmeal.builder()
                .id(id)
                .status(status)
                .build();
        setmealMapper.update(setmeal);
    &#125;

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    public List&lt;Setmeal&gt; list(Setmeal setmeal) &#123;
        List&lt;Setmeal&gt; list = setmealMapper.list(setmeal);
        return list;
    &#125;

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    public List&lt;DishItemVO&gt; getDishItemById(Long id) &#123;
        return setmealMapper.getDishItemBySetmealId(id);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.annotation.AutoFill;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.enumeration.OperationType;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;
import java.util.Map;

@Mapper
public interface SetmealMapper &#123;

    /**
     * 根据分类id查询套餐的数量
     *
     * @param id
     * @return
     */
    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long id);

    /**
     * 根据id修改套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.UPDATE)
    void update(Setmeal setmeal);

    /**
     * 新增套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.INSERT)
    void insert(Setmeal setmeal);

    /**
     * 分页查询
     * @param setmealPageQueryDTO
     * @return
     */
    Page&lt;SetmealVO&gt; pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 根据id查询套餐
     * @param id
     * @return
     */
    @Select(&quot;select * from setmeal where id = #&#123;id&#125;&quot;)
    Setmeal getById(Long id);

    /**
     * 根据id删除套餐
     * @param setmealId
     */
    @Delete(&quot;delete from setmeal where id = #&#123;id&#125;&quot;)
    void deleteById(Long setmealId);

    /**
     * 根据id查询套餐和套餐菜品关系
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 动态条件查询套餐
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据套餐id查询菜品选项
     * @param setmealId
     * @return
     */
    @Select(&quot;select sd.name, sd.copies, d.image, d.description &quot; +
            &quot;from setmeal_dish sd left join dish d on sd.dish_id = d.id &quot; +
            &quot;where sd.setmeal_id = #&#123;setmealId&#125;&quot;)
    List&lt;DishItemVO&gt; getDishItemBySetmealId(Long setmealId);

    /**
     * 根据条件统计套餐数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;
    &lt;resultMap id=&quot;setmealAndDishMap&quot; type=&quot;com.sky.vo.SetmealVO&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;setmealDishes&quot; ofType=&quot;SetmealDish&quot;&gt;
            &lt;result column=&quot;sd_id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;setmeal_id&quot; property=&quot;setmealId&quot;/&gt;
            &lt;result column=&quot;dish_id&quot; property=&quot;dishId&quot;/&gt;
            &lt;result column=&quot;sd_name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;sd_price&quot; property=&quot;price&quot;/&gt;
            &lt;result column=&quot;copies&quot; property=&quot;copies&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;
        update setmeal
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                category_id = #&#123;categoryId&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;price != null&quot;&gt;
                price = #&#123;price&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;description != null&quot;&gt;
                description = #&#123;description&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;image != null&quot;&gt;
                image = #&#123;image&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

&lt;!--
    &lt;insert&gt;：表示这是一个插入操作。
    id=&quot;insert&quot;：指定这个 SQL 语句的唯一标识符，通常用于在 MyBatis 映射文件中引用此 SQL 语句。
    parameterType=&quot;Setmeal&quot;：指定插入操作的参数类型为 Setmeal 类型。
    useGeneratedKeys=&quot;true&quot;：指示 MyBatis 在执行插入操作后自动获取自动生成的主键。
    keyProperty=&quot;id&quot;：指定将自动生成的主键值设置到对象的 id 属性上。
--&gt;
    &lt;insert id=&quot;insert&quot; parameterType=&quot;Setmeal&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into setmeal
        (category_id, name, price, status, description, image, create_time, update_time, create_user, update_user)
        values (#&#123;categoryId&#125;, #&#123;name&#125;, #&#123;price&#125;, #&#123;status&#125;, #&#123;description&#125;, #&#123;image&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;,
                #&#123;createUser&#125;, #&#123;updateUser&#125;)
    &lt;/insert&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.SetmealVO&quot;&gt;
        select
        s.*,c.name categoryName
        from
        setmeal s
        left join
        category c
        on
        s.category_id = c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                and s.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and s.status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and s.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by s.create_time desc
    &lt;/select&gt;

    &lt;select id=&quot;getByIdWithDish&quot; parameterType=&quot;long&quot; resultMap=&quot;setmealAndDishMap&quot;&gt;
        select a.*,
               b.id    sd_id,
               b.setmeal_id,
               b.dish_id,
               b.name  sd_name,
               b.price sd_price,
               b.copies
        from setmeal a
                 left join
             setmeal_dish b
             on
                 a.id = b.setmeal_id
        where a.id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;list&quot; parameterType=&quot;Setmeal&quot; resultType=&quot;Setmeal&quot;&gt;
        select * from setmeal
        &lt;where&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;

    &lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from setmeal
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="Redis入门-调整营业状态"><a href="#Redis入门-调整营业状态" class="headerlink" title="Redis入门 [调整营业状态]"></a>Redis入门 [调整营业状态]</h3><p>Redis是一个基于<strong>内存</strong>的 key-value 结构数据库</p>
<ul>
<li>基于内存存储，读写性能高</li>
<li>适合存储热点数据 (热点商品、资讯、新闻) 访问量较大</li>
<li>企业应用广泛</li>
</ul>
<h3 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h3><h5 id="Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型："><a href="#Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：" class="headerlink" title="Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型："></a>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</h5><ul>
<li>字符串 string：普通字符串</li>
<li>哈希 hash：散列，类似于java中的HashMap结构</li>
<li>列表 list：按照插入顺序排序，可以有重复元素，类似于java中的LinkedList</li>
<li>集合 set：无序集合，没有重复元素，类似于java中的HashSet</li>
<li>有序集合 sorted set &#x2F; zset：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素</li>
</ul>
<h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><ul>
<li><p><strong>字符串操作命令</strong></p>
<blockquote>
<p>ValueOperations valueOperations &#x3D; redisTemplate.opsForValue();</p>
</blockquote>
<ul>
<li>SET key value                      设置指定key的值</li>
<li>GET key                                获取指定key的值</li>
<li>SETEX key seconds value  设置指定key的值，并将key的过期时间设为 seconds秒</li>
<li>SETNX key value                 只有在key不存在时设置key的值</li>
</ul>
</li>
<li><p><strong>哈希操作命令</strong> [<strong>key → value(field1 value1,  field2 value2)</strong>]</p>
<blockquote>
<p>HashOperations hashOperations &#x3D; redisTemplate.opsForHash();</p>
</blockquote>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</p>
<ul>
<li>HSET key field value   将哈希表key中的字段field的值设为value</li>
<li>HGET key field             获取存储在哈希表中指定字段的值</li>
<li>HDEL key field             删除存储在哈希表中的指定字段</li>
<li>HKEYS key                    获取哈希表中所有字段</li>
<li>HVALS key                    获取哈希表中所有值</li>
</ul>
</li>
<li><p><strong>列表操作命令</strong></p>
<blockquote>
<p>ListOperations listOperations &#x3D; redisTemplate.opsForList();</p>
</blockquote>
<ul>
<li>LPUSH key value1 [value2]      将一个或多个值插入到列表头部</li>
<li>LRANGE key start stop             获取列表指定范围内的元素</li>
<li>RPOP key                                    移除并获取列表最后一个元素</li>
<li>LLEN key                                     获取列表长度</li>
</ul>
</li>
<li><p><strong>集合操作命令</strong></p>
<blockquote>
<p>SetOperations setOperations &#x3D; redisTemplate.opsForSet();</p>
</blockquote>
<p>Redis set是string类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据</p>
<ul>
<li>SADD key member1 [member2]           向集合添加一个或多个成员 [无序插入]</li>
<li>SMEMBERS key                                         返回集合中的所有成员</li>
<li>SCARD key                                                  获取集合的成员数</li>
<li>SINTER key1 [key2]                                   返回给定所有集合的交集</li>
<li>SUNION key1 [key2]                                 返回所有给定集合的并集</li>
<li>SREM key member1 [member2]            删除集合中一个或多个成员</li>
</ul>
</li>
<li><p><strong>有序列表操作命令</strong></p>
<blockquote>
<p>ZSetOperations zSetOperations &#x3D; redisTemplate.opsForZSet();</p>
</blockquote>
<p>Redis有序集合是string类型元素的集合，且不允许重复成员。每个元素都会关联一个double类型的分数</p>
<ul>
<li>ZADD key score1 member1 [score2 member2]  向有序集合添加一个或多个成员</li>
<li>ZRANGE key start stop [WITHSCORES]                 通过索引区间返回有序集合中指定区间内的成员</li>
<li>ZINCRBY key increment member                          有序集合中对指定成员的分数加上增量increment</li>
<li>ZREM key member [member …]                            移除有序集合中的一个或多个成员</li>
</ul>
</li>
<li><p><strong>通用命令</strong></p>
<p>Redis的通用命令是不分数据类型的，都可以使用的命令</p>
<ul>
<li>KEYS pattern            查找所有符合给定模式(pattern)的key</li>
<li>EXISTS key                检查给定key是否存在</li>
<li>TYPE key                   返回key所存储的值的类型</li>
<li>DEL key                     该命令用于在key存在是删除key</li>
</ul>
</li>
</ul>
<h3 id="在java中操作Redis-SpringDataRedis"><a href="#在java中操作Redis-SpringDataRedis" class="headerlink" title="在java中操作Redis_SpringDataRedis"></a>在java中操作Redis_SpringDataRedis</h3><p><span style = "color:red">序列化器：<strong>redisTemplate.setKeySerializer(new StringRedisSerializer());</strong></span></p>
<h6 id="Redis的Java客户端很多"><a href="#Redis的Java客户端很多" class="headerlink" title="Redis的Java客户端很多"></a>Redis的Java客户端很多</h6><ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Spring Data Redis</li>
</ul>
<p>Spring Data Redis 是 Spring 的一部分，对Redis底层开发包进行了高度封装<br>在Spring项目中，可以使用Spring Data Redis来简化操作</p>
<h5 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h5><ul>
<li><p>导入Spring Data Redis的maven坐标</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>配置Redis数据源</p>
<pre><code class="yaml">spring:
 redis:
  host: localhost
  port: 6379
  password:
</code></pre>
</li>
<li><p>编写配置类，创建RedisTemplate对象</p>
<pre><code class="java">package com.sky.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@Slf4j
public class RedisConfiguration &#123;

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
        log.info(&quot;开始创建redis模板对象...&quot;);
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis key的序列化器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    &#125;
&#125;
</code></pre>
</li>
<li><p>通过RedisTemplate对象操作Redis</p>
</li>
</ul>
<h6 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h6><pre><code class="yaml">application.yml
  redis:
    host: $&#123;sky.redis.host&#125;
    port: $&#123;sky.redis.port&#125;
    database: $&#123;sky.redis.database&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
  redis:
    host: localhost
    port: 6379
    database: 1
</code></pre>
<pre><code class="java">sky-server  com/sky/config/RedisConfiguration.java
package com.sky.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@Slf4j
public class RedisConfiguration &#123;
    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
        log.info(&quot;开始创建redis模板对象...&quot;);
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis key的序列化器 在图形化界面不出现乱码
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server【测试类】 com/sky/test/SpringDataRedisTest.java
package com.sky.test;

import com.mysql.cj.util.TimeUtil;
import net.sf.jsqlparser.statement.select.KSQLWindow;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.*;

import java.util.concurrent.TimeUnit;

@SpringBootTest //测试完记得注释 不然每次启动类就会运行这个测试类
public class SpringDataRedisTest &#123;
    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void testRedisTemplate()&#123;
        System.out.println(redisTemplate);
        //创建根据字符串、哈希、列表、集合、有序列表、通用命令的代码
        ValueOperations valueOperations = redisTemplate.opsForValue();
        HashOperations hashOperations = redisTemplate.opsForHash();
        ListOperations listOperations = redisTemplate.opsForList();
        SetOperations setOperations = redisTemplate.opsForSet();
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();
    &#125;

    /**
     * 操作字符串类型的数据
     */
    @Test
    public void testString()&#123;
        // set get setex setnx
        redisTemplate.opsForValue().set(&quot;city&quot;,&quot;北京&quot;);
        String city = (String) redisTemplate.opsForValue().get(&quot;city&quot;);
        System.out.println(city); // 北京

        redisTemplate.opsForValue().set(&quot;code&quot;, &quot;1234&quot;, 3, TimeUnit.MINUTES);
        // 第一次调用可以设置成功
        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1&quot;);
        // 第二次不可以成功
        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;2&quot;);
        Object lock = redisTemplate.opsForValue().get(&quot;lock&quot;);
        System.out.println(lock); // 1

        Object lock2 = redisTemplate.opsForValue().get(&quot;locwwk&quot;);
        System.out.println(lock2);// null
    &#125;
    
    /**
     * 操作哈希类型的数据
     */
    @Test
    public void testHash()&#123;
        //hset hget hdel hkeys havls
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.put(&quot;100&quot;,&quot;name&quot;,&quot;tom&quot;);
        hashOperations.put(&quot;100&quot;,&quot;age&quot;,&quot;20&quot;);

        String name = (String) hashOperations.get(&quot;100&quot;,&quot;name&quot;);
        System.out.println(name);

        Set keys = hashOperations.keys(&quot;100&quot;);
        System.out.println(keys);

        List values = hashOperations.values(&quot;100&quot;);
        System.out.println(values);

        hashOperations.delete(&quot;100&quot;,&quot;age&quot;);
/**
     * 操作列表类型的数据
     */
    @Test
    public void testList()&#123;
        //lpush lrange rpop llen
        ListOperations listOperations = redisTemplate.opsForList();

        listOperations.leftPushAll(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);
        listOperations.leftPush(&quot;mylist&quot;,&quot;d&quot;);

        List mylist = listOperations.range(&quot;mylist&quot;, 0, -1);
        System.out.println(mylist);

        listOperations.rightPop(&quot;mylist&quot;);

        Long size = listOperations.size(&quot;mylist&quot;);
        System.out.println(size);
    &#125;

    /**
     * 操作集合类型的数据
     */
    @Test
    public void testSet()&#123;
        //sadd smembers scard sinter sunion srem
        SetOperations setOperations = redisTemplate.opsForSet();

        setOperations.add(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
        setOperations.add(&quot;set2&quot;,&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;);

        Set members = setOperations.members(&quot;set1&quot;);
        System.out.println(members);

        Long size = setOperations.size(&quot;set1&quot;);
        System.out.println(size);

        Set intersect = setOperations.intersect(&quot;set1&quot;, &quot;set2&quot;);
        System.out.println(intersect);

        Set union = setOperations.union(&quot;set1&quot;, &quot;set2&quot;);
        System.out.println(union);

        setOperations.remove(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;);
    &#125;

    /**
     * 操作有序集合类型的数据
     */
    @Test
    public void testZset()&#123;
        //zadd zrange zincrby zrem
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();

        zSetOperations.add(&quot;zset1&quot;,&quot;a&quot;,10);
        zSetOperations.add(&quot;zset1&quot;,&quot;b&quot;,12);
        zSetOperations.add(&quot;zset1&quot;,&quot;c&quot;,9);

        Set zset1 = zSetOperations.range(&quot;zset1&quot;, 0, -1);
        System.out.println(zset1);

        zSetOperations.incrementScore(&quot;zset1&quot;,&quot;c&quot;,10);

        zSetOperations.remove(&quot;zset1&quot;,&quot;a&quot;,&quot;b&quot;);
    &#125;

    /**
     * 通用命令操作
     */
    @Test
    public void testCommon()&#123;
        //keys exists type del
        Set keys = redisTemplate.keys(&quot;*&quot;);
        System.out.println(keys);

        Boolean name = redisTemplate.hasKey(&quot;name&quot;);
        Boolean set1 = redisTemplate.hasKey(&quot;set1&quot;);

        for (Object key : keys) &#123;
            DataType type = redisTemplate.type(key);
            System.out.println(type.name());
        &#125;

        redisTemplate.delete(&quot;mylist&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="店铺营业状态设置-【存入Redis】"><a href="#店铺营业状态设置-【存入Redis】" class="headerlink" title="店铺营业状态设置 【存入Redis】"></a>店铺营业状态设置 【存入Redis】</h3><h6 id="接口设计：-3"><a href="#接口设计：-3" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>设置营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;admin&#x2F;shop&#x2F;{status}<br><strong>Method</strong>：PUT<br>status   1    店铺营业状态：1为营业，0为打样</p>
</blockquote>
</li>
<li><p>管理端查询营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;<strong>admin</strong>&#x2F;shop&#x2F;status<br><strong>Method</strong>：GET</p>
</blockquote>
</li>
<li><p>用户端查询营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;<strong>user</strong>&#x2F;shop&#x2F;status<br><strong>Method</strong>：GET</p>
</blockquote>
</li>
</ul>
<p>★ ★ <strong>本项目约定</strong> ★ ★</p>
<ul>
<li><strong>管理端</strong>发出的请求，统一使用**&#x2F;admin**作为前缀</li>
<li><strong>用户端</strong>发出的请求，统一使用**&#x2F;user**作为前缀</li>
</ul>
<p>营业状态数据存储方式：基于Redis的字符串来进行存储<br>key: SHOP_STATUS     value: 1                1为营业，0为打样</p>
<h6 id="代码开发：-3"><a href="#代码开发：-3" class="headerlink" title="代码开发："></a>代码开发：</h6><pre><code class="java">sky-server  com/sky/controller/admin/ShopController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;

@RestController(&quot;adminShopController&quot;)
@RequestMapping(&quot;/admin/shop&quot;)
@Api(tags = &quot;店铺相关接口&quot;)
@Slf4j
public class ShopController &#123;
    public static final String KEY = &quot;SHOP_STATUS&quot;;

    @Autowired
    private RedisTemplate redisTemplate;
    /**
     * 设置店铺营业状态
     * @param status
     * @return
     */
    @PutMapping(&quot;/&#123;status&#125;&quot;) //动态取到status
    @ApiOperation(&quot;设置店铺营业状态&quot;)
    public Result setStatus(@PathVariable Integer status) &#123;
        log.info(&quot;设置店铺的营业状态为：&#123;&#125;&quot;, status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        redisTemplate.opsForValue().set(KEY, status);
        return Result.success();
    &#125;

    /**
     * 获取店铺的营业状态
     * @return
     */
    @GetMapping(&quot;/status&quot;)
    @ApiOperation(&quot;获取店铺的营业状态&quot;)
    public Result&lt;Integer&gt; getStatus()&#123;
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info(&quot;获取到的店铺营业状态为：&#123;&#125;&quot;,status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        return Result.success(status);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/ShopController.java
package com.sky.controller.user;

import com.sky.result.Result;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;
//@RestController(&quot;userShopController&quot;) 指定了这个控制器的名称为 userShopController
//这有助于在应用中唯一标识这个控制器，便于管理和调用
@RestController(&quot;userShopController&quot;)
@RequestMapping(&quot;/user/shop&quot;)
@Api(tags = &quot;店铺相关接口&quot;)
@Slf4j
public class ShopController &#123;
    public static final String KEY = &quot;SHOP_STATUS&quot;;

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 获取店铺的营业状态
     * @return
     */
    @GetMapping(&quot;/status&quot;)
    @ApiOperation(&quot;获取店铺的营业状态&quot;)
    public Result&lt;Integer&gt; getStatus()&#123;
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info(&quot;获取到的店铺营业状态为：&#123;&#125;&quot;,status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        return Result.success(status);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
// 设置两个接口文档方便在前端文档处调试【管理端+用户端】
package com.sky.config;

import com.sky.interceptor.JwtTokenAdminInterceptor;
import com.sky.interceptor.JwtTokenUserInterceptor;
import com.sky.json.JacksonObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

import java.util.List;

/**
 * 配置类，注册web层相关组件
 */
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    @Autowired
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;
    @Autowired
    private JwtTokenUserInterceptor jwtTokenUserInterceptor;

    /**
     * 注册自定义拦截器
     * @param registry
     */
    protected void addInterceptors(InterceptorRegistry registry) &#123;
        log.info(&quot;开始注册自定义拦截器...&quot;);
        registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns(&quot;/admin/**&quot;)
                .excludePathPatterns(&quot;/admin/employee/login&quot;);

        registry.addInterceptor(jwtTokenUserInterceptor)
                .addPathPatterns(&quot;/user/**&quot;)
                .excludePathPatterns(&quot;/user/user/login&quot;)
                .excludePathPatterns(&quot;/user/shop/status&quot;);
    &#125;

    @Bean
    public Docket docket1()&#123;
        log.info(&quot;准备生成接口文档...&quot;);
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;管理端接口&quot;)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller.admin&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    @Bean
    public Docket docket2()&#123;
        log.info(&quot;准备生成接口文档...&quot;);
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;用户端接口&quot;)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller.user&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    /**
     * 设置静态资源映射，主要是访问接口文档（html、js、css）
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        log.info(&quot;开始设置静态资源映射...&quot;);
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;

    /**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        log.info(&quot;扩展消息转换器...&quot;);
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转化器加入容器中
        converters.add(0,converter);
    &#125;
&#125;
</code></pre>
<p><span style="color:orange"><strong>回顾拦截器原理</strong></span></p>
<h3 id="HttpClient-amp-微信小程序开发"><a href="#HttpClient-amp-微信小程序开发" class="headerlink" title="HttpClient &amp; 微信小程序开发"></a>HttpClient &amp; 微信小程序开发</h3><h5 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h5><p>HttpClient 是 Apache Jakarta Common下的子项目，可以用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
    &lt;version&gt;4.5.13&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>核心API：</p>
<ul>
<li>HttpClient</li>
<li><strong>HttpClients</strong></li>
<li>CloseableHttpClient</li>
<li>HttpGet</li>
<li>HttpPost</li>
</ul>
<p>发送请求步骤：</p>
<ul>
<li>创建HttpClient对象</li>
<li>创建Http请求对象</li>
<li>调用HttpClient的execute方法发送请求</li>
</ul>
<h5 id="发送GET方式请求-要先把项目跑起来"><a href="#发送GET方式请求-要先把项目跑起来" class="headerlink" title="发送GET方式请求 [要先把项目跑起来]"></a>发送GET方式请求 [要先把项目跑起来]</h5><pre><code class="java">sky-server  com/sky/test/HttpClientTest.java
package com.sky.test;

import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.IOException;

@SpringBootTest
public class HttpClientTest &#123;
    /**
     * 测试通过httpclient发送GET方式的请求
     */

    @Test
    public void testGET() throws IOException &#123;
        // 创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        // 创建请求对象接口 (GET请求方式+请求地址)
        HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/user/shop/status&quot;);

        // 发送请求，接受响应结果
        CloseableHttpResponse response = httpClient.execute(httpGet);

        // 获取服务端返回的状态码
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println(&quot;服务端返回的状态码为：&quot; + statusCode);


        HttpEntity entity = response.getEntity();// 获得请求体
        String body = EntityUtils.toString(entity);
        System.out.println(&quot;服务端返回的数据为：&quot; + body);

        // 关闭资源
        response.close();
        httpClient.close();
    &#125;

    /**
     * 测试通过httpclient发送POST方式的请求
     */
&#125;
--------------------------------------------------------------------------------
服务端返回的状态码为：200
服务端返回的数据为：&#123;&quot;code&quot;:1,&quot;msg&quot;:null,&quot;data&quot;:0&#125;
</code></pre>
<h5 id="发送POST方式请求-要先把项目跑起来"><a href="#发送POST方式请求-要先把项目跑起来" class="headerlink" title="发送POST方式请求 [要先把项目跑起来]"></a>发送POST方式请求 [要先把项目跑起来]</h5><pre><code class="java">sky-server   com/sky/test/HttpClientTest.java
/**
     * 测试通过httpclient发送POST方式的请求
     */
    @Test
    public void testPOST() throws Exception&#123;
        // 创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        // 创建请求对象
        HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/admin/employee/login&quot;);
        // 以json方式请求提交参数
        JSONObject jsonObject = new JSONObject();
        jsonObject.put(&quot;username&quot;,&quot;admin&quot;);
        jsonObject.put(&quot;password&quot;,&quot;123456&quot;);

        StringEntity entity = new StringEntity(jsonObject.toString());
        // 指定请求编码方式
        entity.setContentEncoding(&quot;utf-8&quot;);
        // 数据格式
        entity.setContentType(&quot;application/json&quot;);
        httpPost.setEntity(entity);

        // 发送请求
        CloseableHttpResponse response = httpClient.execute(httpPost);

        // 解析返回结果
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println(&quot;响应码为：&quot; + statusCode);

        HttpEntity entity1 = response.getEntity();
        String body = EntityUtils.toString(entity1);
        System.out.println(&quot;响应数据为：&quot; + body);

        // 关闭资源
        response.close();
        httpClient.close();
    &#125;
--------------------------------------------------------------------------------
响应码为：200
响应数据为：&#123;&quot;code&quot;:1,&quot;msg&quot;:null,&quot;data&quot;:&#123;&quot;id&quot;:1,&quot;userName&quot;:&quot;admin&quot;,&quot;name&quot;:&quot;管理员&quot;,&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI4MTMyMzczfQ.8M2nIkgtHx8wpORNfhKEWjbprBV6OwC82wgYjAMxe2I&quot;&#125;&#125;
</code></pre>
<h6 id="封装后的HttpClientUtil"><a href="#封装后的HttpClientUtil" class="headerlink" title="封装后的HttpClientUtil"></a>封装后的HttpClientUtil</h6><pre><code class="java">package com.sky.utils;

import com.alibaba.fastjson.JSONObject;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Http工具类
 */
public class HttpClientUtil &#123;

    static final  int TIMEOUT_MSEC = 5 * 1000;

    /**
     * 发送GET方式请求
     * @param url
     * @param paramMap
     * @return
     */
    public static String doGet(String url,Map&lt;String,String&gt; paramMap)&#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        String result = &quot;&quot;;
        CloseableHttpResponse response = null;

        try&#123;
            URIBuilder builder = new URIBuilder(url);
            if(paramMap != null)&#123;
                for (String key : paramMap.keySet()) &#123;
                    builder.addParameter(key,paramMap.get(key));
                &#125;
            &#125;
            URI uri = builder.build();

            //创建GET请求
            HttpGet httpGet = new HttpGet(uri);

            //发送请求
            response = httpClient.execute(httpGet);

            //判断响应状态
            if(response.getStatusLine().getStatusCode() == 200)&#123;
                result = EntityUtils.toString(response.getEntity(),&quot;UTF-8&quot;);
            &#125;
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            try &#123;
                response.close();
                httpClient.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return result;
    &#125;

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost(String url, Map&lt;String, String&gt; paramMap) throws IOException &#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;

        try &#123;
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            // 创建参数列表
            if (paramMap != null) &#123;
                List&lt;NameValuePair&gt; paramList = new ArrayList();
                for (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;
                    paramList.add(new BasicNameValuePair(param.getKey(), param.getValue()));
                &#125;
                // 模拟表单
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);
                httpPost.setEntity(entity);
            &#125;

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            try &#123;
                response.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return resultString;
    &#125;

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost4Json(String url, Map&lt;String, String&gt; paramMap) throws IOException &#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;

        try &#123;
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            if (paramMap != null) &#123;
                //构造json格式数据
                JSONObject jsonObject = new JSONObject();
                for (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;
                    jsonObject.put(param.getKey(),param.getValue());
                &#125;
                StringEntity entity = new StringEntity(jsonObject.toString(),&quot;utf-8&quot;);
                //设置请求编码
                entity.setContentEncoding(&quot;utf-8&quot;);
                //设置数据类型
                entity.setContentType(&quot;application/json&quot;);
                httpPost.setEntity(entity);
            &#125;

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            try &#123;
                response.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return resultString;
    &#125;
    private static RequestConfig builderRequestConfig() &#123;
        return RequestConfig.custom()
                .setConnectTimeout(TIMEOUT_MSEC)
                .setConnectionRequestTimeout(TIMEOUT_MSEC)
                .setSocketTimeout(TIMEOUT_MSEC).build();
    &#125;
&#125;
</code></pre>
<h3 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&token=244469372">小程序 (qq.com)</a></p>
<blockquote>
<p>详情 → 本地设置 → [取消勾选]不校验合法域名…</p>
</blockquote>
<h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ul>
<li><p>了解小程序目录结构</p>
<p>小程序包含一个<strong>描述整体程序</strong>的<u>app</u>和多个和<strong>描述各自页面</strong>的<u>page</u>，一个小程序主体部分由三个文件组村，必须放在项目的根目录</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>app.js</td>
<td>是</td>
<td>小程序逻辑</td>
</tr>
<tr>
<td>app.json</td>
<td>是</td>
<td>小程序公共配置</td>
</tr>
<tr>
<td>app.wxss</td>
<td>否</td>
<td>小程序公共样式表</td>
</tr>
</tbody></table>
<h6 id="一个小程序页面由四个文件组成-pages-→-index-→-…"><a href="#一个小程序页面由四个文件组成-pages-→-index-→-…" class="headerlink" title="一个小程序页面由四个文件组成 [pages → index → …]"></a>一个小程序页面由四个文件组成 [pages → index → …]</h6><table>
<thead>
<tr>
<th>文件类型</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>js</td>
<td>是</td>
<td>页面逻辑</td>
</tr>
<tr>
<td>wxml</td>
<td>是</td>
<td>页面结构</td>
</tr>
<tr>
<td>json</td>
<td>否</td>
<td>页面配置</td>
</tr>
<tr>
<td>wxss</td>
<td>否</td>
<td>页面样式表</td>
</tr>
</tbody></table>
</li>
<li><p>编写测试小程序代码</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23385943/article/details/142336381?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-142336381-blog-119914069.235%5Ev43%5Epc_blog_bottom_relevance_base6&spm=1001.2101.3001.4242.1&utm_relevant_index=3">微信getUserProfile不弹出授权框_wx.getuserprofile没有弹窗-CSDN博客</a></p>
<pre><code class="json">app.json 【外面一层】
&#123;
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;: &#123;
    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,
    &quot;navigationBarTitleText&quot;: &quot;Sky-Delivery&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;
  &#125;,
  &quot;style&quot;: &quot;v2&quot;,
  &quot;componentFramework&quot;: &quot;glass-easel&quot;,
  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;,
  &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;
&#125;
</code></pre>
<pre><code class="xml">pages/index/index.wxml
&lt;view class=&quot;container&quot;&gt;
  &lt;view&gt;
    &#123;&#123;msg&#125;&#125;
  &lt;/view&gt;

  &lt;view&gt;
    &lt;button bindtap=&quot;getUserInfo&quot; type=&quot;primary&quot;&gt;获取用户信息&lt;/button&gt;
    昵称：&#123;&#123;nickName&#125;&#125;
    &lt;image src=&quot;&#123;&#123;url&#125;&#125;&quot; style=&quot;width: 200px;height: 200px;&quot;&gt;&lt;/image&gt;
    &lt;button bindtap=&quot;wxLogin&quot; type=&quot;warn&quot;&gt;微信登录&lt;/button&gt;
    授权码：&#123;&#123;code&#125;&#125;
  &lt;/view&gt;

  &lt;view&gt;
    &lt;button bindtap=&quot;sendRequest&quot; type=&quot;default&quot;&gt;发送请求&lt;/button&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="js">pages/index/index.js
Page(&#123;
  data: &#123;
    msg: &#39;hello world&#39;,
    nickName: &#39;&#39;,
    url:&#39;&#39;,
    code:&#39;&#39;,
  &#125;,

  // 获取微信用户的头像和昵称
  getUserInfo(e)&#123;
    wx.getUserProfile(&#123;
      desc: &#39;获取用户信息&#39;,
      success: (res) =&gt; &#123;
        console.log(res.userInfo);
        // 为数据赋值
        this.setData(&#123;
          nickName: res.userInfo.nickName,
          url: res.userInfo.avatarUrl
        &#125;)
      &#125;,
      fail:(err) =&gt; &#123;
        console.error(&#39;获取用户信息失败&#39;, err);
      &#125;
    &#125;);
  &#125;,
  
  //微信登录，获取微信用户的授权码 
  //拿到后可以去请求微信服务器获得openId
  //授权码提交到后端去调用服务器
  wxLogin()&#123;
    wx.login(&#123;
      success: (res) =&gt; &#123;
        console.log(res.code)
        this.setData(&#123;
          code: res.code
        &#125;)
      &#125;
    &#125;)
  &#125;,

  //发送请求
  sendRequest()&#123;
    wx.request(&#123;
      url: &#39;http://localhost:8080/user/shop/status&#39;,
      method: &#39;GET&#39;,
      success: (res)=&gt;&#123;
        // data是后端响应回来的整个数据
        console.log(res.data)
      &#125;
    &#125;)
  &#125;
&#125;);
</code></pre>
</li>
<li><p>编译小程序</p>
</li>
</ul>
<h3 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h3><h5 id="导入小程序代码"><a href="#导入小程序代码" class="headerlink" title="导入小程序代码"></a>导入小程序代码</h5><blockquote>
<p>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day06\微信小程序代码\mp-weixin<br>【注意：导入后有很多包名错误common、components】</p>
</blockquote>
<h5 id="微信登录流程"><a href="#微信登录流程" class="headerlink" title="微信登录流程"></a>微信登录流程</h5><blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">开放能力 &#x2F; 用户信息 &#x2F; 小程序登录 (qq.com)</a><br><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg"></p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>appid</td>
<td>string</td>
<td></td>
<td>是</td>
<td>小程序 appId</td>
</tr>
<tr>
<td>secret</td>
<td>string</td>
<td></td>
<td>是</td>
<td>小程序 appSecret</td>
</tr>
<tr>
<td>js_code</td>
<td>string</td>
<td></td>
<td>是</td>
<td>登录时获取的 code</td>
</tr>
<tr>
<td>grant_type</td>
<td>string</td>
<td></td>
<td>是</td>
<td>授权类型，此处只需填写 authorization_code</td>
</tr>
</tbody></table>
<blockquote>
<p>PostMan测试 →<br>GET：<a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/jscode2session?appid=wxa33b4bae9165c5a5&amp;secret=c2d6fc237953d711146c4ad5db3ef947&amp;js_code=0f1hdA200TsYYS1ghD100c3GZJ1hdA2w&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/jscode2session?appid=wxa33b4bae9165c5a5&amp;secret=c2d6fc237953d711146c4ad5db3ef947&amp;js_code=0f1hdA200TsYYS1ghD100c3GZJ1hdA2w&amp;grant_type=authorization_code</a></p>
<p>返回：<br>{“session_key”:”HsYD32ryqarcnrCXbEyWhg&#x3D;&#x3D;”,”openid”:”obaex5N3w1_oAP6a4h-c-CkQBsZQ”}</p>
</blockquote>
<h6 id="需求分析和设计-3"><a href="#需求分析和设计-3" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h6><p>数据库设计(user表)</p>
<h6 id="代码开发-3"><a href="#代码开发-3" class="headerlink" title="代码开发"></a>代码开发</h6><pre><code class="yaml">sky-server  application.yml
sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 7200000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
    user-secret-key: itheima
    user-ttl: 7200000
    user-token-name: authentication
  alioss:
    endpoint: $&#123;sky.alioss.endpoint&#125;
    access-key-id: $&#123;sky.alioss.access-key-id&#125;
    access-key-secret: $&#123;sky.alioss.access-key-secret&#125;
    bucket: $&#123;sky.alioss.bucket&#125;
  wechat:
    appid: $&#123;sky.wechat.appid&#125;
    secret: $&#123;sky.wechat.secret&#125;
</code></pre>
<pre><code class="java">sky-server  application-dev.yml
  wechat:
    appid: xxxxxxx
    secret: xxxxxxx
</code></pre>
<pre><code class="java">sky-common  com/sky/properties/WeChatProperties.java
package com.sky.properties;

import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &quot;sky.wechat&quot;)
@Data
public class WeChatProperties &#123;

    private String appid; //小程序的appid
    private String secret; //小程序的秘钥
    private String mchid; //商户号
    private String mchSerialNo; //商户API证书的证书序列号
    private String privateKeyFilePath; //商户私钥文件
    private String apiV3Key; //证书解密的密钥
    private String weChatPayCertFilePath; //平台证书
    private String notifyUrl; //支付成功的回调地址
    private String refundNotifyUrl; //退款成功的回调地址
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/UserController.java
package com.sky.controller.user;

import com.sky.constant.JwtClaimsConstant;
import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;
import com.sky.properties.JwtProperties;
import com.sky.result.Result;
import com.sky.service.UserService;
import com.sky.utils.JwtUtil;
import com.sky.vo.UserLoginVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping(&quot;/user/user&quot;)
@Api(tags = &quot;C端用户相关接口&quot;)
@Slf4j
public class UserController &#123;
    @Autowired
    private UserService userService;
    @Autowired
    private JwtProperties jwtProperties;
    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    @PostMapping(&quot;/login&quot;)
    @ApiOperation(&quot;微信登录&quot;)
    public Result&lt;UserLoginVO&gt; login(@RequestBody UserLoginDTO userLoginDTO) &#123;
        log.info(&quot;微信登录：&#123;&#125;&quot;, userLoginDTO.getCode());
        //微信登录
        User user = userService.wxLogin(userLoginDTO);

        //为微信用户生成jwt令牌
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(JwtClaimsConstant.USER_ID, user.getId());
        String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(),jwtProperties.getUserTtl(),claims);
        UserLoginVO userLoginVO = UserLoginVO.builder()
                .id(user.getId())
                .openid(user.getOpenid())
                .token(token)
                .build();
        return Result.success(userLoginVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/UserService.java
package com.sky.service;

import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;

public interface UserService &#123;
    /**
     * 微信登录
     * @return
     */
    User wxLogin(UserLoginDTO userLoginDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/UserServiceImpl.java
package com.sky.service.impl;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.sky.constant.MessageConstant;
import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;
import com.sky.exception.LoginFailedException;
import com.sky.mapper.UserMapper;
import com.sky.properties.WeChatProperties;
import com.sky.service.UserService;
import com.sky.utils.HttpClientUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class UserServiceImpl implements UserService &#123;
    // 微信服务接口地址
    public static final String WX_LOGIN = &quot;https://api.weixin.qq.com/sns/jscode2session&quot;;

    @Autowired
    private WeChatProperties weChatProperties;
    @Autowired
    private UserMapper userMapper;
    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    @Override
    public User wxLogin(UserLoginDTO userLoginDTO) &#123;
        String openid = getOpenid(userLoginDTO.getCode());
        // 判断openId是否真的获取到 如果为空代表失败 业务异常
        if (openid == null)&#123;
            throw new LoginFailedException(MessageConstant.LOGIN_FAILED);
        &#125;
        // openId是否在表里 可判断是否为新用户
        User user = userMapper.getByOpenid(openid);
        // 如果是新用户，自动完成注册
        if (user == null) &#123;
            user = User.builder()
                    .openid(openid)
                    .createTime(LocalDateTime.now())
                    .build();
            userMapper.insert(user);
        &#125;
        // 返回这个用户对象
        return user;
    &#125;

    /**
     * 调用微信接口服务，获取微信用户的openid
     * @param code
     * @return
     */
    //只有当前类用到
    private String getOpenid(String code) &#123;
        // 调用微信服务器接口 获得当前用户的openid
        // 四个请求参数
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;appid&quot;, weChatProperties.getAppid());
        map.put(&quot;secret&quot;, weChatProperties.getSecret());
        map.put(&quot;js_code&quot;, code);
        map.put(&quot;grant_type&quot;, &quot;authorization_code&quot;);
        String json = HttpClientUtil.doGet(WX_LOGIN, map);

        // 获得json对象
        JSONObject jsonObject = JSON.parseObject(json);
        String openid = jsonObject.getString(&quot;openid&quot;);
        return openid;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
package com.sky.mapper;

import com.sky.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface UserMapper &#123;
    /**
     * 根据openid查询用户
     * @param openid
     * @return
     */
    @Select(&quot;select * from user where openid = #&#123;openid&#125;&quot;)
    User getByOpenid(String openid);

    /**
     * 新增用户
     * @param user
     */
    void insert(User user);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.UserMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into user (openid, name, phone, sex, id_number, avatar, create_time)
        values (#&#123;openid&#125;, #&#123;name&#125;, #&#123;phone&#125;, #&#123;sex&#125;, #&#123;idNumber&#125;, #&#123;avatar&#125;, #&#123;createTime&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">【检测小程序用户是否登陆性】
sky-server  com/sky/interceptor/JwtTokenUserInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenUserInterceptor implements HandlerInterceptor &#123;

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getUserTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);
            Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());
            log.info(&quot;当前用户的id：&quot;, userId);
            BaseContext.setCurrentId(userId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java 【增加jwtTokenUserInterceptor】
/**
 * 配置类，注册web层相关组件
 */
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    @Autowired
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;
    @Autowired
    private JwtTokenUserInterceptor jwtTokenUserInterceptor;

    /**
     * 注册自定义拦截器
     * @param registry
     */
    protected void addInterceptors(InterceptorRegistry registry) &#123;
        log.info(&quot;开始注册自定义拦截器...&quot;);
        registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns(&quot;/admin/**&quot;)
                .excludePathPatterns(&quot;/admin/employee/login&quot;);

        registry.addInterceptor(jwtTokenUserInterceptor)
                .addPathPatterns(&quot;/user/**&quot;)
                .excludePathPatterns(&quot;/user/user/login&quot;)
                .excludePathPatterns(&quot;/user/shop/status&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="导入商品浏览功能代码"><a href="#导入商品浏览功能代码" class="headerlink" title="导入商品浏览功能代码"></a>导入商品浏览功能代码</h4><h6 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h6><ul>
<li><p>查询分类</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;category&#x2F;list<br>Method：GET<br>请求参数<br>Type： 分类类型→1.菜品分类  2.套餐分类</p>
</blockquote>
</li>
<li><p>根据分类id查询菜品</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;dish&#x2F;list<br>Method：GET<br>请求参数<br>categoryId 分类id</p>
</blockquote>
</li>
<li><p>根据分类id查询套餐</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;setmeal&#x2F;list?category&#x3D;111<br>Method：GET<br>请求参数<br>categoryId 分类id</p>
</blockquote>
</li>
<li><p>根据套餐id查询包含的菜品</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;setmeal&#x2F;dish&#x2F;10<br>Method：GET<br>请求参数<br>id 套餐id<br>返回数据：<br>copies 份数<br>description 菜品描述<br>image 菜品图片<br>name 菜品名称</p>
</blockquote>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/user/DishController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Dish;
import com.sky.result.Result;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userDishController&quot;)
@RequestMapping(&quot;/user/dish&quot;)
@Slf4j
@Api(tags = &quot;C端-菜品浏览接口&quot;)
public class DishController &#123;
    @Autowired
    private DishService dishService;

    /**
     * 根据分类id查询菜品
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询菜品&quot;)
    public Result&lt;List&lt;DishVO&gt;&gt; list(Long categoryId) &#123;
        Dish dish = new Dish();
        dish.setCategoryId(categoryId);
        dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品

        List&lt;DishVO&gt; list = dishService.listWithFlavor(dish);

        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.result.PageResult;
import com.sky.vo.DishVO;

import java.util.List;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);

    /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    DishVO getByIdWithFlavor(long id);

    /**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    void updateWithFlavor(DishDTO dishDTO);

    /**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据分类id查询菜品
     * @param categoryId
     * @return
     */
    List&lt;Dish&gt; list(Long categoryId);

    /**
     * 条件查询菜品和口味
     * @param dish
     * @return
     */
    List&lt;DishVO&gt; listWithFlavor(Dish dish);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.DishFlavor;
import com.sky.entity.Setmeal;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.DishFlavorMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

@Service
@Slf4j

public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private SetmealMapper setmealMapper;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    @Override
    @Transactional //保证事务一致性
    public void saveWithFlavour(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        //直接new出来是空的需要先赋值 属性拷贝[属性命名要一致]
        BeanUtils.copyProperties(dishDTO,dish);

        // 向菜品表插入1条数据
        dishMapper.insert(dish);
        // 前端无法传 要获取dishId
// &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; 获取主键值
        Long dishId = dish.getId();

        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishId);
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    @Override
    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;
        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        // 判断当前菜品是否能够删除--是否存在起售中的菜品？？ 取出id
        for (Long id : ids) &#123;
            Dish dish = dishMapper.getById(id);
            if (dish.getStatus() == StatusConstant.ENABLE) &#123;
                //当前菜品处于起售中，不能删除
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            &#125;
        &#125;

        // 判断当前菜品是否能够删除--是否被套餐关联了
        List&lt;Long&gt; setMealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);
        if (setMealIds != null &amp;&amp; setMealIds.size() &gt; 0) &#123; //存在不允许删除
            // 当前菜品被套餐关联了，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        &#125;
        // 删除菜品表中的菜品数据
        for (Long id : ids) &#123;
            dishMapper.deleteById(id);
            // 删除菜品关联的口味数据
            dishFlavorMapper.deleteByDishId(id);
        &#125;
    &#125;

    /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @Override
    public DishVO getByIdWithFlavor(long id) &#123;
        // 根据id查询菜品数据
        Dish dish = dishMapper.getById(id);
        // 根据菜品id查询口味数据
        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);

        // 将查询到的数据封装到VO
        DishVO dishVO = new DishVO();
            // 属性拷贝
        BeanUtils.copyProperties(dish,dishVO);
        dishVO.setFlavors(dishFlavors);

        return dishVO;
    &#125;



    /**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    @Override
    public void updateWithFlavor(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // 修改菜品表基本信息 只是基础信息噢
        dishMapper.update(dish);
        // 先删掉原先的
        dishFlavorMapper.deleteByDishId(dishDTO.getId());
        // 再重新插入新的
        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishDTO.getId());
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;

    /**
     * 菜品起售停售
     * @param status
     * @param id
     */
    @Override
    public void startOrStop(Integer status, Long id) &#123;
        Dish dish = Dish.builder()
                .id(id)
                .status(status)
                .build();
        dishMapper.update(dish);

        if (status == StatusConstant.DISABLE) &#123;
            // 如果是停售操作，还需要将包含当前菜品的套餐也停售
            List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();
            dishIds.add(id);
            // select setmeal_id from setmeal_dish where dish_id in (?,?,?)
            List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);
            if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;
                for (Long setmealId : setmealIds) &#123;
                    Setmeal setmeal = Setmeal.builder()
                            .id(setmealId)
                            .status(StatusConstant.DISABLE)
                            .build();
                    setmealMapper.update(setmeal);
                &#125;
            &#125;

        &#125;
    &#125;

    /**
     * 根据分类id查询菜品
     * @param categoryId
     * @return
     */
    public List&lt;Dish&gt; list(Long categoryId) &#123;
        Dish dish = Dish.builder()
                .categoryId(categoryId)
                .status(StatusConstant.ENABLE)
                .build();
        return dishMapper.list(dish);
    &#125;

    /**
     * 条件查询菜品和口味
     * @param dish
     * @return
     */
    public List&lt;DishVO&gt; listWithFlavor(Dish dish) &#123;
        List&lt;Dish&gt; dishList = dishMapper.list(dish);

        List&lt;DishVO&gt; dishVOList = new ArrayList&lt;&gt;();

        for (Dish d : dishList) &#123;
            DishVO dishVO = new DishVO();
            BeanUtils.copyProperties(d,dishVO);

            //根据菜品id查询对应的口味
            List&lt;DishFlavor&gt; flavors = dishFlavorMapper.getByDishId(d.getId());

            dishVO.setFlavors(flavors);
            dishVOList.add(dishVO);
        &#125;

        return dishVOList;
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">sky-server  com/sky/controller/user/SetmealController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Setmeal;
import com.sky.result.Result;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userSetmealController&quot;)
@RequestMapping(&quot;/user/setmeal&quot;)
@Api(tags = &quot;C端-套餐浏览接口&quot;)
public class SetmealController &#123;
    @Autowired
    private SetmealService setmealService;

    /**
     * 条件查询
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询套餐&quot;)
    public Result&lt;List&lt;Setmeal&gt;&gt; list(Long categoryId) &#123;
        Setmeal setmeal = new Setmeal();
        setmeal.setCategoryId(categoryId);
        setmeal.setStatus(StatusConstant.ENABLE);

        List&lt;Setmeal&gt; list = setmealService.list(setmeal);
        return Result.success(list);
    &#125;

    /**
     * 根据套餐id查询包含的菜品列表
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/dish/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据套餐id查询包含的菜品列表&quot;)
    public Result&lt;List&lt;DishItemVO&gt;&gt; dishList(@PathVariable(&quot;id&quot;) Long id) &#123;
        List&lt;DishItemVO&gt; list = setmealService.getDishItemById(id);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/SetmealService.java
package com.sky.service;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.result.PageResult;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;

import java.util.List;

public interface SetmealService &#123;

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    void saveWithDish(SetmealDTO setmealDTO);

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询套餐和关联的菜品数据
     *
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    void update(SetmealDTO setmealDTO);

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    List&lt;DishItemVO&gt; getDishItemById(Long id);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/SetmealServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.SetmealDish;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.exception.SetmealEnableFailedException;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 套餐业务实现
 */
@Service
@Slf4j
public class SetmealServiceImpl implements SetmealService &#123;

    @Autowired
    private SetmealMapper setmealMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private DishMapper dishMapper;


    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    @Transactional
    public void saveWithDish(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //向套餐表插入数据
        setmealMapper.insert(setmeal);

        //获取生成的套餐id
        Long setmealId = setmeal.getId();

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);

        //保存套餐和菜品的关联关系
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        int pageNum = setmealPageQueryDTO.getPage();
        int pageSize = setmealPageQueryDTO.getPageSize();

        PageHelper.startPage(pageNum, pageSize);
        Page&lt;SetmealVO&gt; page = setmealMapper.pageQuery(setmealPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        ids.forEach(id -&gt; &#123;
            Setmeal setmeal = setmealMapper.getById(id);
            if (StatusConstant.ENABLE == setmeal.getStatus()) &#123;
                //起售中的套餐不能删除
                throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
            &#125;
        &#125;);

        ids.forEach(setmealId -&gt; &#123;
            //删除套餐表中的数据
            setmealMapper.deleteById(setmealId);
            //删除套餐菜品关系表中的数据
            setmealDishMapper.deleteBySetmealId(setmealId);
        &#125;);
    &#125;

    /**
     * 根据id查询套餐和套餐菜品关系
     *
     * @param id
     * @return
     */
    public SetmealVO getByIdWithDish(Long id) &#123;
        SetmealVO setmealVO = setmealMapper.getByIdWithDish(id);
        return setmealVO;
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    @Transactional
    public void update(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //1、修改套餐表，执行update
        setmealMapper.update(setmeal);

        //套餐id
        Long setmealId = setmealDTO.getId();

        //2、删除套餐和菜品的关联关系，操作setmeal_dish表，执行delete
        setmealDishMapper.deleteBySetmealId(setmealId);

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);
        //3、重新插入套餐和菜品的关联关系，操作setmeal_dish表，执行insert
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        //起售套餐时，判断套餐内是否有停售菜品，有停售菜品提示&quot;套餐内包含未启售菜品，无法启售&quot;
        if (status == StatusConstant.ENABLE) &#123;
            //select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = ?
            List&lt;Dish&gt; dishList = dishMapper.getBySetmealId(id);
            if (dishList != null &amp;&amp; dishList.size() &gt; 0) &#123;
                dishList.forEach(dish -&gt; &#123;
                    if (StatusConstant.DISABLE == dish.getStatus()) &#123;
                        throw new SetmealEnableFailedException(MessageConstant.SETMEAL_ENABLE_FAILED);
                    &#125;
                &#125;);
            &#125;
        &#125;

        Setmeal setmeal = Setmeal.builder()
                .id(id)
                .status(status)
                .build();
        setmealMapper.update(setmeal);
    &#125;

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    public List&lt;Setmeal&gt; list(Setmeal setmeal) &#123;
        List&lt;Setmeal&gt; list = setmealMapper.list(setmeal);
        return list;
    &#125;

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    public List&lt;DishItemVO&gt; getDishItemById(Long id) &#123;
        return setmealMapper.getDishItemBySetmealId(id);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">sky-server  com/sky/controller/user/CategoryController.java
package com.sky.controller.user;

import com.sky.entity.Category;
import com.sky.result.Result;
import com.sky.service.CategoryService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userCategoryController&quot;)
@RequestMapping(&quot;/user/category&quot;)
@Api(tags = &quot;C端-分类接口&quot;)
public class CategoryController &#123;

    @Autowired
    private CategoryService categoryService;

    /**
     * 查询分类
     * @param type
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;查询分类&quot;)
    public Result&lt;List&lt;Category&gt;&gt; list(Integer type) &#123;
        List&lt;Category&gt; list = categoryService.list(type);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/CategoryService.java
package com.sky.service;

import com.sky.annotation.AutoFill;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增分类
     * @param categoryDTO
     */
    void save(CategoryDTO categoryDTO);
    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    void deleteById(Long id);

    /**
     * 修改分类
     * @param categoryDTO
     */
    void update(CategoryDTO categoryDTO);

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/CategoryServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.context.BaseContext;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.CategoryMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 分类业务层
 */
@Service
@Slf4j
public class CategoryServiceImpl implements CategoryService &#123;

    @Autowired
    private CategoryMapper categoryMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 新增分类
     * @param categoryDTO
     */
    public void save(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        //属性拷贝
        BeanUtils.copyProperties(categoryDTO, category);

        //分类状态默认为禁用状态0
        category.setStatus(StatusConstant.DISABLE);
/**  公共属性
        //设置创建时间、修改时间、创建人、修改人
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContext.getCurrentId());
        category.setUpdateUser(BaseContext.getCurrentId());
 **/

        categoryMapper.insert(category);
    &#125;

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123;
        PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());
        //下一条sql进行分页，自动加入limit关键字分页
        Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 根据id删除分类
     * @param id
     */
    public void deleteById(Long id) &#123;
        //查询当前分类是否关联了菜品，如果关联了就抛出业务异常
        Integer count = dishMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
        &#125;

        //查询当前分类是否关联了套餐，如果关联了就抛出业务异常
        count = setmealMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);
        &#125;

        //删除分类数据
        categoryMapper.deleteById(id);
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     */
    public void update(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO,category);

        //设置修改时间、修改人 (公共属性)
//        category.setUpdateTime(LocalDateTime.now());
//        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.update(category);
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        Category category = Category.builder()
                .id(id)
                .status(status) // 下面注释是公共属性AOP有写
//                .updateTime(LocalDateTime.now())
//                .updateUser(BaseContext.getCurrentId())
                .build();
        categoryMapper.update(category);
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    public List&lt;Category&gt; list(Integer type) &#123;
        return categoryMapper.list(type);
    &#125;
&#125;
</code></pre>
<h3 id="缓存菜品-【redis】"><a href="#缓存菜品-【redis】" class="headerlink" title="缓存菜品 【redis】"></a>缓存菜品 【redis】</h3><h5 id="问题说明："><a href="#问题说明：" class="headerlink" title="问题说明："></a>问题说明：</h5><p>用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问压力随之增大</p>
<h5 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h5><p>通过Redis来缓存菜品数据，减少数据库查询操作</p>
<p>开始→(查询菜品)→后端服务→缓存是否存在→(是)→读取缓存<br>                                                                               (否)→查询数据库→载入缓存</p>
<h5 id="缓存逻辑分析："><a href="#缓存逻辑分析：" class="headerlink" title="缓存逻辑分析："></a>缓存逻辑分析：</h5><ul>
<li><p>每个分类下的菜品保存一份缓存数据</p>
<p><strong>key</strong>：dish_1<br><strong>value</strong>：string(…) [List集合]</p>
</li>
</ul>
<pre><code class="java">sky-server com/sky/controller/user/DishController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Dish;
import com.sky.result.Result;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userDishController&quot;)
@RequestMapping(&quot;/user/dish&quot;)
@Slf4j
@Api(tags = &quot;C端-菜品浏览接口&quot;)
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 根据分类id查询菜品
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询菜品&quot;)
    public Result&lt;List&lt;DishVO&gt;&gt; list(Long categoryId) &#123;

        //构造redis中的key，规则：dish_分类id
        String key = &quot;dish_&quot; + categoryId;

        //查询redis中是否存在菜品数据
        List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);
        if(list != null &amp;&amp; list.size() &gt; 0)&#123;
            //如果存在，直接返回，无须查询数据库
            return Result.success(list);
        &#125;

        Dish dish = new Dish();
        dish.setCategoryId(categoryId);
        dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品

        //如果不存在，查询数据库，将查询到的数据放入redis中
        list = dishService.listWithFlavor(dish);
        redisTemplate.opsForValue().set(key, list);

        return Result.success(list);
    &#125;
&#125;
</code></pre>
<h5 id="清理缓存数据"><a href="#清理缓存数据" class="headerlink" title="清理缓存数据"></a>清理缓存数据</h5><h6 id="防止-新增-x2F-更改-x2F-删除-x2F-起售停售-后无法及时在用户手机端接收"><a href="#防止-新增-x2F-更改-x2F-删除-x2F-起售停售-后无法及时在用户手机端接收" class="headerlink" title="防止 新增&#x2F;更改&#x2F;删除&#x2F;起售停售 后无法及时在用户手机端接收"></a>防止 <u>新增&#x2F;更改&#x2F;删除&#x2F;起售停售</u> 后无法及时在用户手机端接收</h6><p>修改管理端接口 <code>DishController</code> 加入清理缓存的逻辑 (新增菜品、修改菜品、批量删除菜品、起售停售菜品)</p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
 * 菜品管理
 */
@RestController
@RequestMapping(&quot;/admin/dish&quot;)
@Api(tags = &quot;菜品相关接口&quot;)
@Slf4j
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @Autowired
    private RedisTemplate redisTemplate;
    @PostMapping
    @ApiOperation(&quot;新增菜品&quot;)
    //@RequestBody 封装JSON格式的数据
    public Result save(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);
        dishService.saveWithFlavour(dishDTO);

        //清理缓存数据(精确查询)
        String key = &quot;dish_&quot; + dishDTO.getCategoryId();
        cleanCache(key);
        return Result.success();
    &#125;
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除菜品&quot;)
    //@RequestParam MVC动态解析字符串 ids提取出来
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123; //ids
        log.info(&quot;批量删除菜品：&#123;&#125;&quot;, ids);
        dishService.deleteBatch(ids);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);
        return Result.success();
    &#125;
/**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改菜品&quot;)
    public Result update(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);
        dishService.updateWithFlavor(dishDTO);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);;
        return Result.success();
    &#125;
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;菜品起售停售&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id) &#123;
        dishService.startOrStop(status, id);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);

        return Result.success();
    &#125;
private void cleanCache(String pattern)&#123;
        /** 因为单独清理每个菜品可能会有关联套餐 就直接清理全部
         * 1. 先获取到所有的key
         * 2. 遍历key，判断是否以pattern开头
         * 3. 删除所有的key
         */
        Set keys = redisTemplate.keys(pattern);
        redisTemplate.delete(keys);
    &#125;
&#125;
</code></pre>
<h2 id="缓存套餐-【SpringCache】"><a href="#缓存套餐-【SpringCache】" class="headerlink" title="缓存套餐 【SpringCache】"></a>缓存套餐 【SpringCache】</h2><p>Spring Cache 是一个框架，实现了基于<strong>注解</strong>的缓存功能，只需要简单地加一个<strong>注解</strong>，就能实现缓存功能<br>Spring Cache 提供了一层抽象，底层可以切换不同的缓存实现</p>
<ul>
<li>EHCache</li>
<li>Caffeine</li>
<li>Redis</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h6><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span style="color:red">@<strong>EnableCaching</strong></span></td>
<td>开启缓存注解功能，通常加在<strong>启动类</strong>上</td>
</tr>
<tr>
<td><span style="color:red">@<strong>Cacheable</strong></span></td>
<td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td>
</tr>
<tr>
<td><span style="color:red">@<strong>CachePut</strong></span></td>
<td>将方法的返回值放到缓存中</td>
</tr>
<tr>
<td><span style="color:red">@<strong>CacheEvict</strong></span></td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
</tbody></table>
<pre><code class="java">@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;

     @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#user.id&quot;)
// 将方法的返回值放到缓存中
    // 如果使用Spring Cache缓存数据，key的生成&quot;#user.id&quot;
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    @CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    @CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;

    @GetMapping
    @Cacheable(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
// 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;
</code></pre>
<h5 id="SpringCache入门案例"><a href="#SpringCache入门案例" class="headerlink" title="SpringCache入门案例"></a>SpringCache入门案例</h5><h6 id="初始资源："><a href="#初始资源：" class="headerlink" title="初始资源："></a>初始资源：</h6><pre><code class="java">package com.itheima.controller;

import com.itheima.entity.User;
import com.itheima.mapper.UserMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;

    @Autowired
    private UserMapper userMapper;

    @PostMapping
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;

    @GetMapping
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;

&#125;
</code></pre>
<pre><code class="java">package com.itheima.mapper;

import com.itheima.entity.User;
import org.apache.ibatis.annotations.*;

@Mapper
public interface UserMapper&#123;

    @Insert(&quot;insert into user(name,age) values (#&#123;name&#125;,#&#123;age&#125;)&quot;)
    @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)
    void insert(User user);

    @Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);

    @Delete(&quot;delete from user&quot;)
    void deleteAll();

    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)
    User getById(Long id);
&#125;
</code></pre>
<pre><code class="java">package com.itheima.entity;

import lombok.Data;
import java.io.Serializable;

@Data
public class User implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    private String name;

    private int age;

&#125;
</code></pre>
<pre><code class="java">package com.itheima.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    /**
     * 生成接口文档配置
     * @return
     */
    @Bean
    public Docket docket()&#123;
        log.info(&quot;准备生成接口文档...&quot;);

        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.itheima.controller&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    /**
     * 设置静态资源映射
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        log.info(&quot;开始设置静态资源映射...&quot;);
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">application.yml
server:
  port: 8888
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/spring_cache_demo?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true
      username: root
      password: root
  redis:
    host: localhost
    port: 6379
    database: 1
logging:
  level:
    com:
      itheima:
        mapper: debug
        service: info
        controller: info
</code></pre>
<pre><code class="sql">springcachedemo.sql
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(45) DEFAULT NULL,
  `age` int DEFAULT NULL,
  PRIMARY KEY (`id`)
);
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.3&lt;/version&gt;
        &lt;relativePath/&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;springcache-demo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.20&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.76&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-lang&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.2.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.7.3&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<hr>
<hr>
<h5 id="开始调试咯"><a href="#开始调试咯" class="headerlink" title="开始调试咯"></a>开始调试咯</h5><pre><code class="java">com/itheima/CacheDemoApplication.java
package com.itheima;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
//@EnableCaching 放在 Application 类上，这样整个应用就启用了缓存支持
@Slf4j
@SpringBootApplication
@EnableCaching
public class CacheDemoApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(CacheDemoApplication.class,args);
        log.info(&quot;项目启动成功...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/controller/UserController.java
package com.itheima.controller;

import com.itheima.entity.User;
import com.itheima.mapper.UserMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;
    /*
    set a:b:c:d: itheima 这个就是树形结构在Redis里面 文件夹包着文件夹
    */
    @Autowired
    private UserMapper userMapper;

    @PostMapping
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#result.id&quot;) 对象导航
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#p0.id&quot;)
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#root.args[0]&quot;)
    @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#user.id&quot;)
// 将方法的返回值放到缓存中
    // 如果使用Spring Cache缓存数据，key的生成&quot;#user.id&quot;
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    @CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    @CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;


    @GetMapping
    @Cacheable(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
// 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;
&#125;
</code></pre>
<h4 id="缓存套餐-代码开发"><a href="#缓存套餐-代码开发" class="headerlink" title="缓存套餐_代码开发"></a>缓存套餐_代码开发</h4><h6 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h6><ul>
<li>导入 <strong>Spring Cache</strong> 和 <strong>Redis</strong> 相关maven坐标</li>
<li>在<u><strong>启动类</strong></u>上加入 <strong>@EnableCaching</strong> 注解，开启缓存注解功能</li>
<li>在<u><strong>用户端</strong></u>接口 <strong>SetmealController</strong> 的 <strong>list</strong> 方法上加入 <strong>@Cacheable</strong> 注解</li>
<li>在<u><strong>管理端</strong></u>接口 <strong>SetmealController</strong> 的 <strong>save、delete、update、startOrStop</strong> 等方法上<br>加入**@CacheEvict** 注解<del>保证数据一致性</del></li>
</ul>
<pre><code class="java">com/sky/SkyApplication.java
package com.sky;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication
@EnableTransactionManagement //开启注解方式的事务管理
@Slf4j
@EnableCaching //开启缓存注解
public class SkyApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SkyApplication.class, args);
        log.info(&quot;server started&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/SetmealController.java
@RestController(&quot;userSetmealController&quot;)
@RequestMapping(&quot;/user/setmeal&quot;)
@Api(tags = &quot;C端-套餐浏览接口&quot;)
public class SetmealController &#123;
    @Autowired
    private SetmealService setmealService;

    /**
     * 条件查询
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询套餐&quot;)
    @Cacheable(cacheNames = &quot;setmealCache&quot;,key = &quot;#categoryId&quot;) //key: setmealCache::100
    public Result&lt;List&lt;Setmeal&gt;&gt; list(Long categoryId) &#123;
        Setmeal setmeal = new Setmeal();
        setmeal.setCategoryId(categoryId);
        setmeal.setStatus(StatusConstant.ENABLE);

        List&lt;Setmeal&gt; list = setmealService.list(setmeal);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/SetmealController.java

/**
 * 套餐管理
 */
@RestController
@RequestMapping(&quot;/admin/setmeal&quot;)
@Api(tags = &quot;套餐相关接口&quot;)
@Slf4j
public class SetmealController &#123;

    @Autowired
    private SetmealService setmealService;

    /**
     * 新增套餐
     *
     * @param setmealDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,key = &quot;#setmealDTO.categoryId&quot;)//key: setmealCache::100
    public Result save(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.saveWithDish(setmealDTO);
        return Result.success();
    &#125;
 /**
     * 批量删除套餐
     *
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;
        setmealService.deleteBatch(ids);
        return Result.success();
    &#125;
/**
     * 修改套餐
     *
     * @param setmealDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result update(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.update(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 套餐起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;套餐起售停售&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result startOrStop(@PathVariable Integer status, Long id) &#123;
        setmealService.startOrStop(status, id);
        return Result.success();
    &#125;
&#125;
</code></pre>
<h3 id="添加购物车"><a href="#添加购物车" class="headerlink" title="添加购物车"></a>添加购物车</h3><blockquote>
<p>套餐直接点击加号<br>菜品＋ 或者有口味数据的选择后才可以加入购物车</p>
</blockquote>
<h6 id="接口设计：-4"><a href="#接口设计：-4" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li>请求方式：<strong>POST</strong></li>
<li>请求路径：&#x2F;user&#x2F;shoppingCart&#x2F;add</li>
<li>请求参数：<strong>菜品id</strong>(dish_id)、<strong>口味</strong>(dish_flavor) 或 <strong>套餐id</strong>(setmeal_id) (JSON请求体)</li>
<li>返回结果：code、data、msg</li>
</ul>
<h6 id="数据库设计-shopping-cart表-设置冗余字段可提高数据库效率"><a href="#数据库设计-shopping-cart表-设置冗余字段可提高数据库效率" class="headerlink" title="数据库设计(shopping_cart表):设置冗余字段可提高数据库效率"></a>数据库设计(shopping_cart表):<del>设置冗余字段可提高数据库效率</del></h6><ul>
<li>作用：暂时存放所选商品的地方</li>
<li>选的什么商品</li>
<li>每个商品都买了几个</li>
<li>不同用户的购物车需要区分开</li>
</ul>
<pre><code class="java">sky-pojo  com/sky/dto/ShoppingCartDTO.java
package com.sky.dto;

import lombok.Data;
import java.io.Serializable;

@Data
public class ShoppingCartDTO implements Serializable &#123;

    private Long dishId;
    private Long setmealId;
    private String dishFlavor;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
package com.sky.controller.user;

import com.sky.dto.ShoppingCartDTO;
import com.sky.result.Result;
import com.sky.service.ShoppingCartService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/user/shoppingCart&quot;)
@Slf4j
@Api(tags = &quot;C端添加购物车接口&quot;)
public class ShoppingCartController &#123;
    @Autowired
    private ShoppingCartService shoppingCartService;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     * @return
     */
    @PostMapping(&quot;/add&quot;)
    @ApiOperation(&quot;添加购物车&quot;)
    public Result add(@RequestBody ShoppingCartDTO shoppingCartDTO)&#123;
        log.info(&quot;添加购物车，商品信息为：&#123;&#125;&quot;,shoppingCartDTO);
        shoppingCartService.addShoppingCart(shoppingCartDTO);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
package com.sky.service;

import com.sky.dto.ShoppingCartDTO;
import org.springframework.stereotype.Service;

public interface ShoppingCartService &#123;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     */
    void addShoppingCart(ShoppingCartDTO shoppingCartDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
package com.sky.service.impl;

import com.sky.context.BaseContext;
import com.sky.dto.ShoppingCartDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.ShoppingCart;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.ShoppingCartService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
@Service
@Slf4j
public class ShoppingCartServiceImpl implements ShoppingCartService &#123;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     */
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;
    @Override
    public void addShoppingCart(ShoppingCartDTO shoppingCartDTO) &#123;
        // 判断当前加入购物车中的商品是否已经存在了 (user_id + setmeal_id)
        ShoppingCart shoppingCart = new ShoppingCart();
        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
        Long userId = BaseContext.getCurrentId();
        shoppingCart.setUserId(userId);

        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);

        // 如果已经存在了，只需要将数量+1
        if (list != null &amp;&amp; list.size() &gt; 0) &#123;
            ShoppingCart cart = list.get(0);
            cart.setNumber(cart.getNumber() + 1);
            // update shopping_cart set number = ? where id = ?
            shoppingCartMapper.updateNumberById(cart);
        &#125; else &#123;
            // 如果不存在，需要插入一条购物车数据
            // [先确定套餐or菜品]
            // 判断本次添加到购物车的是菜品还是套餐
            Long dishId = shoppingCartDTO.getDishId();
            if (dishId != null) &#123;
                //本次添加到购物车的是菜品
                Dish dish = dishMapper.getById(dishId);
                shoppingCart.setName(dish.getName());
                shoppingCart.setImage(dish.getImage());
                shoppingCart.setAmount(dish.getPrice());
            &#125; else &#123;
                //本次添加到购物车的是套餐 查菜品表
                Long setmealId = shoppingCartDTO.getSetmealId();
                Setmeal setmeal = setmealMapper.getById(setmealId);
                shoppingCart.setName(setmeal.getName());
                shoppingCart.setImage(setmeal.getImage());
                shoppingCart.setAmount(setmeal.getPrice());

            &#125;
            shoppingCart.setNumber(1);
            shoppingCart.setCreateTime(LocalDateTime.now());
            shoppingCartMapper.insert(shoppingCart);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
package com.sky.mapper;

import com.sky.entity.ShoppingCart;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Update;

import java.util.List;

@Mapper
public interface ShoppingCartMapper &#123;
    List&lt;ShoppingCart&gt; list(ShoppingCart shoppingCart);

    /**
     * 根据id修改商品数量
     * @param shoppingCart
     */
    @Update(&quot;update shopping_cart set number = #&#123;number&#125; where id = #&#123;id&#125;&quot;)
    void updateNumberById(ShoppingCart shoppingCart);

    /**
     * 插入购物车数据
     * @param shoppingCart
     */
    @Insert(&quot;insert into shopping_cart (name, user_id, dish_id, setmeal_id, dish_flavor, number, amount, image, create_time) &quot; +
            &quot; values (#&#123;name&#125;,#&#123;userId&#125;,#&#123;dishId&#125;,#&#123;setmealId&#125;,#&#123;dishFlavor&#125;,#&#123;number&#125;,#&#123;amount&#125;,#&#123;image&#125;,#&#123;createTime&#125;)&quot;)
    void insert(ShoppingCart shoppingCart);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/ShoppingCartMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.ShoppingCartMapper&quot;&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;com.sky.entity.ShoppingCart&quot;&gt;
        select * from shopping_cart
        &lt;where&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;dishId != null&quot;&gt;
                and dish_id = #&#123;dishId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;setmealId != null&quot;&gt;
                and setmeal_id = #&#123;setmealId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;dishFlavor != null&quot;&gt;
                and dish_flavor = #&#123;dishFlavor&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="删除购物车"><a href="#删除购物车" class="headerlink" title="删除购物车"></a>删除购物车</h3><pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 删除购物车
     * @param shoppingCartDTO
     * @return
     */
    @PostMapping(&quot;/sub&quot;)
    @ApiOperation(&quot;删除购物车&quot;)
    public Result sub(@RequestBody ShoppingCartDTO shoppingCartDTO)&#123;
        log.info(&quot;删除购物车，商品信息为：&#123;&#125;&quot;,shoppingCartDTO);
        shoppingCartService.subShoppingCart(shoppingCartDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
    /**
     * 删除购物车
     * @param shoppingCartDTO
     */
    void subShoppingCart(ShoppingCartDTO shoppingCartDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 删除购物车中的商品
     * @param shoppingCartDTO
     */
    @Override
    public void subShoppingCart(ShoppingCartDTO shoppingCartDTO) &#123;
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
        shoppingCart.setUserId(userId);

        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);
        if (list != null &amp;&amp; list.size() &gt; 0) &#123;
            ShoppingCart cart = list.get(0);
            if (cart.getNumber() &gt; 1) &#123;
                // 如果 number &gt;1， 则需要将 number - 1
                cart.setNumber(cart.getNumber() - 1);
                shoppingCartMapper.updateNumberById(cart);
            &#125; else &#123;
                // 如果 number &lt;=1，则直接删除该购物车数据
                shoppingCartMapper.deleteById(cart.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
/**
     * 根据id删除购物车数据
     * @param id
     */
    @Delete(&quot;delete from shopping_cart where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);
</code></pre>
<h3 id="查看购物车"><a href="#查看购物车" class="headerlink" title="查看购物车"></a>查看购物车</h3><blockquote>
<p>名称、价格、商品、数量<br>Path：&#x2F;user&#x2F;shoppingCart&#x2F;list<br>            PUT</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 查看购物车
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;查看购物车&quot;)
    public Result&lt;List&lt;ShoppingCart&gt;&gt; list()&#123;
       List&lt;ShoppingCart&gt; list = shoppingCartService.showShoppingCart();
       return Result.success(list);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
    /**
     * 查看购物车
     * @return
     */
    List&lt;ShoppingCart&gt; showShoppingCart();
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 查看购物车
     * @return
     */
    @Override
    public List&lt;ShoppingCart&gt; showShoppingCart() &#123;
        // 获取到当前微信用户的id
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = ShoppingCart.builder()
                .userId(userId)
                .build();
        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);
        return list;
    &#125;
</code></pre>
<h3 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h3><blockquote>
<p>Path：user&#x2F;shoppingCart&#x2F;clean<br>Method：DELETE<br>返回：code <strong>date</strong> msg</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 清空购物车
     * @return
     */
    @DeleteMapping(&quot;/clean&quot;)
    @ApiOperation(&quot;清空购物车&quot;)
    public Result clean() &#123;
        shoppingCartService.cleanShoppingCart();
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
/**
     * 清空购物车 删除自己的购物车
     */
    void cleanShoppingCart();
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 清空购物车
     */
    @Override
    public void cleanShoppingCart() &#123;
        //获取到当前用户的id
        Long userId = BaseContext.getCurrentId();
        shoppingCartMapper.deleteByUserId(userId);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
/**
     * 根据用户id清空购物车
     * @param userId
     */
    @Delete(&quot;delete from shopping_cart where user_id = #&#123;userId&#125;&quot;)
    void deleteByUserId(Long userId);
</code></pre>
<h3 id="支付接口"><a href="#支付接口" class="headerlink" title="支付接口"></a>支付接口</h3><h5 id="导入地址簿功能代码"><a href="#导入地址簿功能代码" class="headerlink" title="导入地址簿功能代码"></a>导入地址簿功能代码</h5><p><strong>业务功能：</strong></p>
<ul>
<li><p>查询地址列表</p>
</li>
<li><p>新增地址</p>
</li>
<li><p>修改地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook<br>Method：PUT</p>
</blockquote>
</li>
<li><p>删除地址</p>
</li>
<li><p>设置默认地址</p>
</li>
<li><p>查询默认地址</p>
</li>
</ul>
<p><strong>接口设计：</strong></p>
<ul>
<li><p>新增地址</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;addressBook<br>Method: POST</p>
</blockquote>
</li>
<li><p>查询当前登录用户的所有地址信息</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;addressBook&#x2F;list<br>Method: GET</p>
</blockquote>
</li>
<li><p>查询默认地址</p>
</li>
<li><p>根据id修改地址</p>
</li>
<li><p>根据id删除地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook<br>Method：DELETE</p>
</blockquote>
</li>
<li><p>根据id查询地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook&#x2F;{id}<br>Method：GET</p>
</blockquote>
</li>
<li><p>设置默认地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook&#x2F;default<br>Method：PUT</p>
</blockquote>
</li>
</ul>
<h6 id="数据库设计-address-book表"><a href="#数据库设计-address-book表" class="headerlink" title="数据库设计(address_book表)"></a>数据库设计(address_book表)</h6><h4 id="用户下单"><a href="#用户下单" class="headerlink" title="用户下单"></a>用户下单</h4><h6 id="在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货"><a href="#在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货" class="headerlink" title="在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货"></a>在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货</h6><p>用户下单后会产生订单相关数据，订单数据需要体现信息：</p>
<ul>
<li><strong>订单总金额是多少</strong>？</li>
<li><strong>哪个用户下的单</strong>？</li>
<li><strong>买的哪些商品</strong>？</li>
<li><strong>每个商品数量是多少</strong>？</li>
<li><strong>收货地址是哪</strong>？</li>
<li><strong>用户手机号是多少</strong>？</li>
</ul>
<p>餐盒费：用数量算</p>
<h5 id="用户下单接口设计"><a href="#用户下单接口设计" class="headerlink" title="用户下单接口设计"></a>用户下单接口设计</h5><blockquote>
<p><strong>请求方式</strong>：POST<br><strong>请求路径：</strong>&#x2F;user&#x2F;order&#x2F;submit</p>
<p><strong>参数：</strong></p>
<ul>
<li>地址簿id<del>addressBookId</del></li>
<li>配送状态(立即送出、选择送出时间)<del>deliveryStatus</del></li>
<li>打包费<del>packAmount</del></li>
<li>总金额<del>amount</del></li>
<li>备注<del>remark</del></li>
<li>餐具数量<del>tablewareNumber</del></li>
</ul>
</blockquote>
<h5 id="支付订单接口设计"><a href="#支付订单接口设计" class="headerlink" title="支付订单接口设计"></a>支付订单接口设计</h5><blockquote>
<p><strong>返回数据：</strong></p>
<ul>
<li>下单时间</li>
<li>订单总金额</li>
<li>订单号</li>
<li>订单id</li>
</ul>
</blockquote>
<h5 id="数据库设计订单表orders、订单明细表order-detail"><a href="#数据库设计订单表orders、订单明细表order-detail" class="headerlink" title="数据库设计订单表orders、订单明细表order_detail"></a>数据库设计<del>订单表orders、订单明细表order_detail</del></h5><ul>
<li>订单表 <strong>orders</strong><ul>
<li>谁的订单？</li>
<li>送哪去？</li>
<li>打哪个电话联系？</li>
<li>多少钱？</li>
<li>什么时间下的单？</li>
<li>什么时间支付的？</li>
<li>订单的状态？</li>
<li>订单号是多少？</li>
</ul>
</li>
<li>订单明细表 <strong>order_detail</strong><ul>
<li>当前明细属于哪个订单？</li>
<li>具体点的是什么商品？</li>
<li>这个商品点了几份？</li>
</ul>
</li>
</ul>
<h4 id="代码开发-4"><a href="#代码开发-4" class="headerlink" title="代码开发"></a>代码开发</h4><h6 id="用户下单1"><a href="#用户下单1" class="headerlink" title="用户下单1"></a>用户下单1</h6><h5 id="根据用户下单接口的参数设计DTO："><a href="#根据用户下单接口的参数设计DTO：" class="headerlink" title="根据用户下单接口的参数设计DTO："></a>根据用户下单接口的参数设计DTO：</h5><pre><code class="java">sky-pojo  com/sky/dto/OrdersSubmitDTO.java
package com.sky.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
public class OrdersSubmitDTO implements Serializable &#123;
    //地址簿id
    private Long addressBookId;
    //付款方式
    private int payMethod;
    //备注
    private String remark;
    //预计送达时间
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime estimatedDeliveryTime;
    //配送状态  1立即送出  0选择具体时间
    private Integer deliveryStatus;
    //餐具数量
    private Integer tablewareNumber;
    //餐具数量状态  1按餐量提供  0选择具体数量
    private Integer tablewareStatus;
    //打包费
    private Integer packAmount;
    //总金额
    private BigDecimal amount;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/vo/OrdersSubmitVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderSubmitVO implements Serializable &#123;
    //订单id
    private Long id;
    //订单号
    private String orderNumber;
    //订单金额
    private BigDecimal orderAmount;
    //下单时间
    private LocalDateTime orderTime;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/OrderController.java
package com.sky.controller.user;

import com.sky.dto.OrdersSubmitDTO;
import com.sky.result.Result;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController(&quot;userOrderController&quot;)
@RequestMapping(&quot;/user/order&quot;)
@Api(tags = &quot;用户订单相关接口&quot;)
@Slf4j
public class OrderController &#123;
    @Autowired
    private OrderService orderService;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @PostMapping(&quot;/submit&quot;)
    @ApiOperation(&quot;用户下单&quot;)
    public Result&lt;OrderSubmitVO&gt; submit(@RequestBody OrdersSubmitDTO ordersSubmitDTO) &#123;
        log.info(&quot;用户下单,参数为：&#123;&#125;&quot;, ordersSubmitDTO);
        OrderSubmitVO orderSubmitVO = orderService.submitOrder(ordersSubmitDTO);
        return Result.success(orderSubmitVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/OrderService.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderSubmitVO implements Serializable &#123;
    //订单id
    private Long id;
    //订单号
    private String orderNumber;
    //订单金额
    private BigDecimal orderAmount;
    //下单时间
    private LocalDateTime orderTime;
&#125;
</code></pre>
<h6 id="用户下单2"><a href="#用户下单2" class="headerlink" title="用户下单2"></a>用户下单2</h6><pre><code class="java">sky-pojo  com/sky/entity/AddressBook.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 地址簿
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AddressBook implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    //用户id
    private Long userId;

    //收货人
    private String consignee;

    //手机号
    private String phone;

    //性别 0 女 1 男
    private String sex;

    //省级区划编号
    private String provinceCode;

    //省级名称
    private String provinceName;

    //市级区划编号
    private String cityCode;

    //市级名称
    private String cityName;

    //区级区划编号
    private String districtCode;

    //区级名称
    private String districtName;

    //详细地址
    private String detail;

    //标签
    private String label;

    //是否默认 0否 1是
    private Integer isDefault;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.MessageConstant;
import com.sky.context.BaseContext;
import com.sky.dto.OrdersSubmitDTO;
import com.sky.entity.AddressBook;
import com.sky.entity.Orders;
import com.sky.entity.ShoppingCart;
import com.sky.exception.AddressBookBusinessException;
import com.sky.exception.ShoppingCartBusinessException;
import com.sky.mapper.AddressBookMapper;
import com.sky.mapper.OrderDetailMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private OrderDetailMapper orderDetailMapper;
    @Autowired
    private AddressBookMapper addressBookMapper;
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @Override
    public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) &#123;

        // 1.处理各种业务异常(地址簿为空，购物车数据为空)
        AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
        if (addressBook == null) &#123;
            // 抛出业务异常
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        &#125;
        // 查询当前用户购物车信息
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        shoppingCart.setUserId(userId);
        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);
        if (shoppingCartList == null || shoppingCartList.size() == 0) &#123;
            // 抛出业务异常
            throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        &#125;

        // 2.向订单表插入1条数据
        Orders orders = new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO, orders);
        orders.setOrderTime(LocalDateTime.now());
        orders.setPayStatus(Orders.UN_PAID);
        orders.setStatus(Orders.PENDING_PAYMENT);
        orders.setNumber(String.valueOf(System.currentTimeMillis()));//订单号
        orders.setPhone(addressBook.getPhone());
        orders.setConsignee(addressBook.getConsignee());
        orders.setUserId(userId);
        orderMapper.insert(orders);

        // 3.向订单明细表插入n条数据

        // 4,清空当前用户的购物车数据

        // 5.封装VO返回结果
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
package com.sky.mapper;

import com.sky.entity.Orders;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface OrderMapper &#123;
    /**
     * 用户下单
     * @param orders
     */
    void insert(Orders orders);
&#125;
</code></pre>
<h5 id="代码开发3"><a href="#代码开发3" class="headerlink" title="代码开发3"></a>代码开发3</h5><pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.MessageConstant;
import com.sky.context.BaseContext;
import com.sky.dto.OrdersSubmitDTO;
import com.sky.entity.AddressBook;
import com.sky.entity.OrderDetail;
import com.sky.entity.Orders;
import com.sky.entity.ShoppingCart;
import com.sky.exception.AddressBookBusinessException;
import com.sky.exception.ShoppingCartBusinessException;
import com.sky.mapper.AddressBookMapper;
import com.sky.mapper.OrderDetailMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private OrderDetailMapper orderDetailMapper;
    @Autowired
    private AddressBookMapper addressBookMapper;
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @Transactional
    public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) &#123;

        // 1.处理各种业务异常(地址簿为空，购物车数据为空)
        AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
        if (addressBook == null) &#123;
            // 抛出业务异常
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        &#125;
        // 查询当前用户购物车信息
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        shoppingCart.setUserId(userId);
        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);
        if (shoppingCartList == null || shoppingCartList.size() == 0) &#123;
            // 抛出业务异常
            throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        &#125;

        // 2.向订单表插入1条数据
        Orders orders = new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO, orders);
        orders.setOrderTime(LocalDateTime.now());
        orders.setPayStatus(Orders.UN_PAID);
        orders.setStatus(Orders.PENDING_PAYMENT);
        orders.setNumber(String.valueOf(System.currentTimeMillis()));//订单号
        orders.setPhone(addressBook.getPhone());
        orders.setConsignee(addressBook.getConsignee());
        orders.setUserId(userId);
        orderMapper.insert(orders);

        //批量插入订单明细数据
        List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;();
        // 3.向订单明细表插入n条数据
        for (ShoppingCart cart : shoppingCartList) &#123;
            OrderDetail orderDetail = new OrderDetail(); //订单明细
            BeanUtils.copyProperties(cart, orderDetail);
            orderDetail.setOrderId(orders.getId()); //设置当前订单明细关联的订单id
            orderDetailList.add(orderDetail);
        &#125;
        orderDetailMapper.insertBatch(orderDetailList);
        // 4.清空当前用户的购物车数据
        shoppingCartMapper.deleteByUserId(userId);
        // 5.封装VO返回结果
        OrderSubmitVO ordersubmitVO = OrderSubmitVO.builder()
                .id(orders.getId())
                .orderNumber(orders.getNumber())
                .orderAmount(orders.getAmount())
                .orderTime(orders.getOrderTime())
                .build();
        return ordersubmitVO;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderDetailMapper.java
package com.sky.mapper;

import com.sky.entity.OrderDetail;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface OrderDetailMapper &#123;
    /**
     * 批量插入订单明细数据
     */
    void insertBatch(List&lt;OrderDetail&gt; orderDetailList);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderDetailMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderDetailMapper&quot;&gt;

    &lt;insert id=&quot;insertBatch&quot;&gt;
        insert into order_detail (name, image, order_id, dish_id, setmeal_id, dish_flavor, number, amount)
        values
        &lt;foreach collection=&quot;orderDetailList&quot; item=&quot;od&quot; separator=&quot;,&quot;&gt;
            (#&#123;od.name&#125;,#&#123;od.image&#125;,#&#123;od.orderId&#125;,#&#123;od.dishId&#125;,#&#123;od.setmealId&#125;,#&#123;od.dishFlavor&#125;,#&#123;od.number&#125;,#&#123;od.amount&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="订单支付"><a href="#订单支付" class="headerlink" title="订单支付"></a>订单支付</h3><h5 id="微信支付产品-微信支付"><a href="#微信支付产品-微信支付" class="headerlink" title="微信支付产品 + 微信支付"></a>微信支付产品 + 微信支付</h5><p>参考：<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/static/product/product_index.shtml">https://pay.weixin.qq.com/static/product/product_index.shtml</a></p>
<h5 id="微信支付接入流程："><a href="#微信支付接入流程：" class="headerlink" title="微信支付接入流程："></a>微信支付接入流程：</h5><p>提交资料 → 签署协议 → 绑定场景</p>
<h6 id="微信小程序支付时序图："><a href="#微信小程序支付时序图：" class="headerlink" title="微信小程序支付时序图："></a>微信小程序支付时序图：</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/a0ad040fbbc2a25f299e2b9b93c5386ced4068ea/data/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg"></p>
<p><strong>JSAPI下单：</strong>商户系统调用该接口在微信支付服务后台生成预支付交易单</p>
<blockquote>
<p><strong>请求URL</strong>：<a target="_blank" rel="noopener" href="https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi">https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi</a></p>
</blockquote>
<h5 id="获取微信支付平台证书、商户私钥文件："><a href="#获取微信支付平台证书、商户私钥文件：" class="headerlink" title="获取微信支付平台证书、商户私钥文件："></a>获取微信支付平台证书、商户私钥文件：</h5><h4 id="内网穿透工具"><a href="#内网穿透工具" class="headerlink" title="内网穿透工具"></a>内网穿透工具</h4><blockquote>
<p>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day08\安装包<code>cpolar_amd64.msi</code></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://dashboard.cpolar.com/auth">cpolar - secure introspectable tunnels to localhost</a><br>验证<br>你的隧道<br>[复制token] → 在cpolar文件里&#x2F;cmd[C:\Program Files\cpolar] → cpolar.exe authtoken xxxx[Authtoken：这个是在网站验证里复制的] → cpolar.exe http 8080</p>
<p>cpolar by @bestexpresser                                                                                (Ctrl+C to quit)</p>
<p>Tunnel Status       online<br>Account             Pluminary (Plan: Free)<br>Version             2.86.16&#x2F;3.18<br>Web Interface       127.0.0.1:4042<br>Forwarding          <a target="_blank" rel="noopener" href="http://22d34b67.r9.cpolar.top/">http://22d34b67.r9.cpolar.top</a> -&gt; <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a><br>Forwarding          <a target="_blank" rel="noopener" href="https://22d34b67.r9.cpolar.top/">https://22d34b67.r9.cpolar.top</a> -&gt; <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a></p>
<p>Conn              0</p>
<p>Avg Conn Time       0.00ms</p>
<p>启动穿透地址：[22d34b67.r9.cpolar.top&#x2F;doc.html] (<a target="_blank" rel="noopener" href="https://22d34b67.r9.cpolar.top/doc.html">https://22d34b67.r9.cpolar.top/doc.html</a>)</p>
<p>此时正在下载资源<br>HTTP Requests</p>
<hr>
<p>GET &#x2F;v2&#x2F;api-docs              200<br>GET &#x2F;swagger-resources        200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-3b888a6 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-589faee 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-2d0bd79 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-0fd6771 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-0c58d94 200<br>GET &#x2F;webjars&#x2F;css&#x2F;chunk-62d2fe 200<br>GET &#x2F;webjars&#x2F;js&#x2F;app.0f2f48b5. 200</p>
<p>随后就可以访问到接口文档了！！<br><strong>原理：使用内网穿透工具临时获得一个域名</strong></p>
</blockquote>
<blockquote>
<p><strong>CPolar</strong> 和 <strong>SwitchHosts</strong> 是两种不同类型的软件，它们的功能和用途有所区别。</p>
<p>CPolar 是一款内网穿透软件，主要用于将本地运行的服务暴露到公网上，使得外网可以访问。它通过在本地和公网服务器之间建立一个安全的隧道，使得用户可以在任何地方通过互联网访问到本地的服务，比如网站、SSH、数据库等。</p>
<p>SwitchHosts 则是一款用于管理和切换本地hosts文件的软件。Hosts文件是操作系统用于将一些域名解析到特定的IP地址的一个文本文件。SwitchHosts 允许用户方便地添加、切换、备份不同的hosts规则，对于开发者来说，这在开发过程中进行域名映射和测试非常有用。</p>
<p>总结来说，CPolar主要用于内网穿透，而SwitchHosts用于hosts文件管理。两者解决的问题和适用场景不同，不是同一种软件。</p>
<hr>
<p>内网、公网、外网和CPolar这几个概念在网络通信中扮演着不同的角色，以下是它们的定义和它们之间的联系：</p>
<ol>
<li>内网（Local Network 或 Intranet）： 内网是指一个私有网络，通常是在家庭、办公室或企业内部使用。内网中的设备通常通过路由器连接，并使用私有IP地址（如192.168.x.x或10.x.x.x）。内网中的设备一般不能直接从外部互联网访问，它们之间的通信受到防火墙和NAT（网络地址转换）的保护。</li>
<li>公网（Public Network 或 Internet）： 公网是指全球范围内的开放网络，即互联网。公网上的设备使用公网IP地址，这些地址是全球唯一的，可以通过互联网被其他设备访问。网站、电子邮件服务器和其他在线服务都部署在公网上。</li>
<li>外网（External Network）： 外网通常是指相对于内网而言的任何外部网络，特别是指互联网。当说“外网”时，通常是指从内网之外访问的资源或服务。</li>
<li>CPolar： CPolar是一款内网穿透工具，它的主要作用是帮助内网中的设备暴露服务到公网上，使得这些服务可以被外网访问。以下是CPolar与内网、公网、外网之间的联系：</li>
</ol>
<ul>
<li>内网到公网：CPolar在本地设备上运行一个客户端，该客户端与CPolar的服务器建立连接。当外部网络（公网）尝试访问CPolar服务器上配置的特定端口时，CPolar服务器会将这些请求转发到运行CPolar客户端的内网设备上。</li>
<li>公网访问：通过CPolar，内网中的服务可以被赋予一个公网可访问的地址（通常是CPolar服务器的一个子域名或自定义域名），这样外网的任何用户都可以通过这个地址访问到内网的服务。</li>
</ul>
<p>简而言之，CPolar是实现内网服务与公网之间通信的桥梁，它使得原本只能在局域网内部访问的服务能够被外网的用户访问。这对于远程工作、调试、以及需要在公网上提供服务的内网应用来说非常有用</p>
</blockquote>
<h5 id="导入功能代码【由于没有微信凭证-此接口未能正常开发-但代码均可学习】"><a href="#导入功能代码【由于没有微信凭证-此接口未能正常开发-但代码均可学习】" class="headerlink" title="导入功能代码【由于没有微信凭证 此接口未能正常开发 但代码均可学习】"></a>导入功能代码【由于没有微信凭证 此接口未能正常开发 但代码均可学习】</h5><pre><code class="yaml">sky-server  application-dev.yml
 wechat:
    appid: wxffb3637a228223b8
    secret: 84311df9199ecacdf4f12d27b6b9522d
    mchid : 1561414331
    mchSerialNo: 4B3B3DC35414AD50B1B755BAF8DE9CC7CF407606
    privateKeyFilePath: D:\pay\apiclient_key.pem
    apiV3Key: CZBK51236435wxpay435434323FFDuv3
    weChatPayCertFilePath: D:\pay\wechatpay_166D96F876F45C7D07CE98952A96EC980368ACFC.pem
    notifyUrl: https://58869fb.r2.cpolar.top/notify/paySuccess
    refundNotifyUrl: https://58869fb.r2.cpolar.top/notify/refundSuccess
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/OrderController.java
/**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    @PutMapping(&quot;/payment&quot;)
    @ApiOperation(&quot;订单支付&quot;)
    public Result&lt;OrderPaymentVO&gt; payment(@RequestBody OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        log.info(&quot;订单支付：&#123;&#125;&quot;, ordersPaymentDTO);
        OrderPaymentVO orderPaymentVO = orderService.payment(ordersPaymentDTO);
        log.info(&quot;生成预支付交易单：&#123;&#125;&quot;, orderPaymentVO);
        return Result.success(orderPaymentVO);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/OrderService.java
/**
     * 订单支付
     * @param ordersPaymentDTO
     * @return
     */
    OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception;

    /**
     * 支付成功，修改订单状态
     * @param outTradeNo
     */
    void paySuccess(String outTradeNo);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
 @Autowired
    private UserMapper userMapper;
 @Autowired
    private WeChatPayUtil weChatPayUtil;

    
    /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        // 查询订单
        Orders order = orderMapper.getByOrderNumber(ordersPaymentDTO.getOrderNumber());
        if (order == null) &#123;
            throw new OrderBusinessException(&quot;订单不存在&quot;);
        &#125;

        // 检查订单支付状态
        if (order.getPayStatus() == 1) &#123; // 1 表示已支付
            throw new OrderBusinessException(&quot;该订单已支付&quot;);
        &#125;
        order.setPayStatus(1);

        // 更新订单支付状态为已支付
        order.setPayStatus(Orders.PAID);
        order.setCheckoutTime(LocalDateTime.now());
        order.setPayMethod(ordersPaymentDTO.getPayMethod());
        order.setStatus(Orders.CONFIRMED);

        orderMapper.update(order);

        // 构造并返回支付结果对象
        OrderPaymentVO orderPaymentVO = new OrderPaymentVO();
        orderPaymentVO.setOrderNumber(order.getNumber()); // 订单号
        orderPaymentVO.setPaymentTime(new Date());
        orderPaymentVO.setPaymentStatus(&quot;SUCCESS&quot;);

        return orderPaymentVO;
    &#125;
    /**
     * 支付成功，修改订单状态
     *
     * @param outTradeNo
     */
    public void paySuccess(String outTradeNo) &#123;
        // 当前登录用户id
        Long userId = BaseContext.getCurrentId();

        // 根据订单号查询当前用户的订单
        Orders ordersDB = orderMapper.getByNumberAndUserId(outTradeNo, userId);

        // 根据订单id更新订单的状态、支付方式、支付状态、结账时间
        Orders orders = Orders.builder()
                .id(ordersDB.getId())
                .status(Orders.TO_BE_CONFIRMED)
                .payStatus(Orders.PAID)
                .checkoutTime(LocalDateTime.now())
                .build();

        orderMapper.update(orders);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.dto.GoodsSalesDTO;
import com.sky.dto.OrdersPageQueryDTO;
import com.sky.entity.Orders;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Mapper
public interface OrderMapper &#123;
    /**
     * 插入订单数据
     * @param order
     */
    void insert(Orders order);

    /**
     * 根据订单号和用户id查询订单
     * @param orderNumber
     * @param userId
     */
    @Select(&quot;select * from orders where number = #&#123;orderNumber&#125; and user_id= #&#123;userId&#125;&quot;)
    Orders getByNumberAndUserId(String orderNumber, Long userId);

    /**
     * 修改订单信息
     * @param orders
     */
    void update(Orders orders);
    /**
     * 根据id查询订单
     * @param id
     */
    @Select(&quot;select * from orders where id = #&#123;id&#125;&#125;&quot;)
    Orders getById(Long id);
&#125;
</code></pre>
<pre><code class="xml">resources/mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;Orders&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into orders
        (number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark,
         phone, address, consignee, estimated_delivery_time, delivery_status, pack_amount, tableware_number,
         tableware_status)
        values (#&#123;number&#125;, #&#123;status&#125;, #&#123;userId&#125;, #&#123;addressBookId&#125;, #&#123;orderTime&#125;, #&#123;checkoutTime&#125;, #&#123;payMethod&#125;,
                #&#123;payStatus&#125;, #&#123;amount&#125;, #&#123;remark&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;consignee&#125;,
                #&#123;estimatedDeliveryTime&#125;, #&#123;deliveryStatus&#125;, #&#123;packAmount&#125;, #&#123;tablewareNumber&#125;, #&#123;tablewareStatus&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.sky.entity.Orders&quot;&gt;
        update orders
        &lt;set&gt;
            &lt;if test=&quot;cancelReason != null and cancelReason!=&#39;&#39; &quot;&gt;
                cancel_reason=#&#123;cancelReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;rejectionReason != null and rejectionReason!=&#39;&#39; &quot;&gt;
                rejection_reason=#&#123;rejectionReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;cancelTime != null&quot;&gt;
                cancel_time=#&#123;cancelTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payStatus != null&quot;&gt;
                pay_status=#&#123;payStatus&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payMethod != null&quot;&gt;
                pay_method=#&#123;payMethod&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;checkoutTime != null&quot;&gt;
                checkout_time=#&#123;checkoutTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;deliveryTime != null&quot;&gt;
                delivery_time = #&#123;deliveryTime&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
        
        &lt;!-- 根据订单号查询订单 --&gt;
    &lt;select id=&quot;getByOrderNumber&quot; parameterType=&quot;String&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders where number = #&#123;orderNumber&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
  @Select(&quot;select * from user where id = #&#123;id&#125;&#125;&quot;)
    User getById(Long userId);
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/notify/PayNotifyController.java
package com.sky.controller.notify;

import com.alibaba.druid.support.json.JSONUtils;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
//import com.sky.annotation.IgnoreToken;
import com.sky.properties.WeChatProperties;
import com.sky.service.OrderService;
import com.wechat.pay.contrib.apache.httpclient.util.AesUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.entity.ContentType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;

/**
 * 支付回调相关接口
 */
@RestController
@RequestMapping(&quot;/notify&quot;)
@Slf4j
public class PayNotifyController &#123;
    @Autowired
    private OrderService orderService;
    @Autowired
    private WeChatProperties weChatProperties;

    /**
     * 支付成功回调
     *
     * @param request
     */
//  @IgnoreToken
    @RequestMapping(&quot;/paySuccess&quot;)
    public void paySuccessNotify(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        //读取数据
        String body = readData(request);
        log.info(&quot;支付成功回调：&#123;&#125;&quot;, body);

        //数据解密
        String plainText = decryptData(body);
        log.info(&quot;解密后的文本：&#123;&#125;&quot;, plainText);

        JSONObject jsonObject = JSON.parseObject(plainText);
        String outTradeNo = jsonObject.getString(&quot;out_trade_no&quot;);//商户平台订单号
        String transactionId = jsonObject.getString(&quot;transaction_id&quot;);//微信支付交易号

        log.info(&quot;商户平台订单号：&#123;&#125;&quot;, outTradeNo);
        log.info(&quot;微信支付交易号：&#123;&#125;&quot;, transactionId);

        //业务处理，修改订单状态、来单提醒
        orderService.paySuccess(outTradeNo);

        //给微信响应
        responseToWeixin(response);
    &#125;

    /**
     * 读取数据
     *
     * @param request
     * @return
     * @throws Exception
     */
    private String readData(HttpServletRequest request) throws Exception &#123;
        BufferedReader reader = request.getReader();
        StringBuilder result = new StringBuilder();
        String line = null;
        while ((line = reader.readLine()) != null) &#123;
            if (result.length() &gt; 0) &#123;
                result.append(&quot;\n&quot;);
            &#125;
            result.append(line);
        &#125;
        return result.toString();
    &#125;

    /**
     * 数据解密
     *
     * @param body
     * @return
     * @throws Exception
     */
    private String decryptData(String body) throws Exception &#123;
        JSONObject resultObject = JSON.parseObject(body);
        JSONObject resource = resultObject.getJSONObject(&quot;resource&quot;);
        String ciphertext = resource.getString(&quot;ciphertext&quot;);
        String nonce = resource.getString(&quot;nonce&quot;);
        String associatedData = resource.getString(&quot;associated_data&quot;);

        AesUtil aesUtil = new AesUtil(weChatProperties.getApiV3Key().getBytes(StandardCharsets.UTF_8));
        //密文解密
        String plainText = aesUtil.decryptToString(associatedData.getBytes(StandardCharsets.UTF_8),
                nonce.getBytes(StandardCharsets.UTF_8),
                ciphertext);

        return plainText;
    &#125;

    /**
     * 给微信响应
     * @param response
     */
    private void responseToWeixin(HttpServletResponse response) throws Exception&#123;
        response.setStatus(200);
        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, &quot;SUCCESS&quot;);
        map.put(&quot;message&quot;, &quot;SUCCESS&quot;);
        response.setHeader(&quot;Content-type&quot;, ContentType.APPLICATION_JSON.toString());
        response.getOutputStream().write(JSONUtils.toJSONString(map).getBytes(StandardCharsets.UTF_8));
        response.flushBuffer();
    &#125;
&#125;
</code></pre>
<h3 id="查询历史订单"><a href="#查询历史订单" class="headerlink" title="查询历史订单"></a>查询历史订单</h3><p>业务规则</p>
<ul>
<li>分页查询历史订单</li>
<li>可以根据订单状态查询</li>
<li>展示订单数据时，需要展示的数据包括：下单时间、订单状态、订单金额、订单明细（商品名称、图片）</li>
</ul>
<p>接口设计：参见接口文档</p>
<h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><h4 id="1-2-1-user-x2F-OrderController"><a href="#1-2-1-user-x2F-OrderController" class="headerlink" title="1.2.1 user&#x2F;OrderController"></a>1.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 历史订单查询
     *
     * @param page
     * @param pageSize
     * @param status   订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
     * @return
     */
    @GetMapping(&quot;/historyOrders&quot;)
    @ApiOperation(&quot;历史订单查询&quot;)
    public Result&lt;PageResult&gt; page(int page, int pageSize, Integer status) &#123;
        PageResult pageResult = orderService.pageQuery4User(page, pageSize, status);
        return Result.success(pageResult);
    &#125;
</code></pre>
<h4 id="1-2-2-OrderService"><a href="#1-2-2-OrderService" class="headerlink" title="1.2.2 OrderService"></a>1.2.2 OrderService</h4><pre><code class="java">    /**
     * 用户端订单分页查询
     * @param page
     * @param pageSize
     * @param status
     * @return
     */
    PageResult pageQuery4User(int page, int pageSize, Integer status);
</code></pre>
<h4 id="1-2-3-OrderServiceImpl"><a href="#1-2-3-OrderServiceImpl" class="headerlink" title="1.2.3 OrderServiceImpl"></a>1.2.3 OrderServiceImpl</h4><pre><code class="java">/**
     * 用户端订单分页查询
     *
     * @param pageNum
     * @param pageSize
     * @param status
     * @return
     */
    public PageResult pageQuery4User(int pageNum, int pageSize, Integer status) &#123;
        // 设置分页
        PageHelper.startPage(pageNum, pageSize);

        OrdersPageQueryDTO ordersPageQueryDTO = new OrdersPageQueryDTO();
        ordersPageQueryDTO.setUserId(BaseContext.getCurrentId());
        ordersPageQueryDTO.setStatus(status);

        // 分页条件查询
        Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);

        List&lt;OrderVO&gt; list = new ArrayList();

        // 查询出订单明细，并封装入OrderVO进行响应
        if (page != null &amp;&amp; page.getTotal() &gt; 0) &#123;
            for (Orders orders : page) &#123;
                Long orderId = orders.getId();// 订单id

                // 查询订单明细
                List&lt;OrderDetail&gt; orderDetails = orderDetailMapper.getByOrderId(orderId);

                OrderVO orderVO = new OrderVO();
                BeanUtils.copyProperties(orders, orderVO);
                orderVO.setOrderDetailList(orderDetails);

                list.add(orderVO);
            &#125;
        &#125;
        return new PageResult(page.getTotal(), list);
    &#125;
</code></pre>
<h4 id="1-2-4-OrderMapper"><a href="#1-2-4-OrderMapper" class="headerlink" title="1.2.4 OrderMapper"></a>1.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 分页条件查询并按下单时间排序
     * @param ordersPageQueryDTO
     */
    Page&lt;Orders&gt; pageQuery(OrdersPageQueryDTO ordersPageQueryDTO);
</code></pre>
<h4 id="1-2-5-OrderMapper-xml"><a href="#1-2-5-OrderMapper-xml" class="headerlink" title="1.2.5 OrderMapper.xml"></a>1.2.5 OrderMapper.xml</h4><pre><code class="xml">    &lt;select id=&quot;pageQuery&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders
        &lt;where&gt;
            &lt;if test=&quot;number != null and number!=&#39;&#39;&quot;&gt;
                and number like concat(&#39;%&#39;,#&#123;number&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;phone != null and phone!=&#39;&#39;&quot;&gt;
                and phone like concat(&#39;%&#39;,#&#123;phone&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;beginTime != null&quot;&gt;
                and order_time &amp;gt;= #&#123;beginTime&#125;
            &lt;/if&gt;
            &lt;if test=&quot;endTime != null&quot;&gt;
                and order_time &amp;lt;= #&#123;endTime&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by order_time desc
    &lt;/select&gt;
</code></pre>
<h4 id="1-2-6-OrderDetailMapper"><a href="#1-2-6-OrderDetailMapper" class="headerlink" title="1.2.6 OrderDetailMapper"></a>1.2.6 OrderDetailMapper</h4><pre><code class="java">    /**
     * 根据订单id查询订单明细
     * @param orderId
     * @return
     */
    @Select(&quot;select * from order_detail where order_id = #&#123;orderId&#125;&quot;)
    List&lt;OrderDetail&gt; getByOrderId(Long orderId);
</code></pre>
<h3 id="查询订单详情"><a href="#查询订单详情" class="headerlink" title="查询订单详情"></a>查询订单详情</h3><h4 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h4><h6 id="2-2-1-user-x2F-OrderController"><a href="#2-2-1-user-x2F-OrderController" class="headerlink" title="2.2.1 user&#x2F;OrderController"></a>2.2.1 user&#x2F;OrderController</h6><pre><code class="java">    /**
     * 查询订单详情
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/orderDetail/&#123;id&#125;&quot;)
    @ApiOperation(&quot;查询订单详情&quot;)
    public Result&lt;OrderVO&gt; details(@PathVariable(&quot;id&quot;) Long id) &#123;
        OrderVO orderVO = orderService.details(id);
        return Result.success(orderVO);
    &#125;
</code></pre>
<h4 id="2-2-2-OrderService"><a href="#2-2-2-OrderService" class="headerlink" title="2.2.2 OrderService"></a>2.2.2 OrderService</h4><pre><code class="java">    /**
     * 查询订单详情
     * @param id
     * @return
     */
    OrderVO details(Long id);
</code></pre>
<h4 id="2-2-3-OrderServiceImpl"><a href="#2-2-3-OrderServiceImpl" class="headerlink" title="2.2.3 OrderServiceImpl"></a>2.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 查询订单详情
     *
     * @param id
     * @return
     */
    public OrderVO details(Long id) &#123;
        // 根据id查询订单
        Orders orders = orderMapper.getById(id);

        // 查询该订单对应的菜品/套餐明细
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());

        // 将该订单及其详情封装到OrderVO并返回
        OrderVO orderVO = new OrderVO();
        BeanUtils.copyProperties(orders, orderVO);
        orderVO.setOrderDetailList(orderDetailList);

        return orderVO;
    &#125;
</code></pre>
<h4 id="2-2-4-OrderMapper"><a href="#2-2-4-OrderMapper" class="headerlink" title="2.2.4 OrderMapper"></a>2.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 根据id查询订单
     * @param id
     */
    @Select(&quot;select * from orders where id=#&#123;id&#125;&quot;)
    Orders getById(Long id);
</code></pre>
<h3 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h3><p>业务规则：</p>
<ul>
<li>待支付和待接单状态下，用户可直接取消订单</li>
<li>商家已接单状态下，用户取消订单需电话沟通商家</li>
<li>派送中状态下，用户取消订单需电话沟通商家</li>
<li>如果在待接单状态下取消订单，需要给用户退款</li>
<li>取消订单后需要将订单状态修改为“已取消”</li>
</ul>
<h4 id="3-2-1-user-x2F-OrderController"><a href="#3-2-1-user-x2F-OrderController" class="headerlink" title="3.2.1 user&#x2F;OrderController"></a>3.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 用户取消订单
     *
     * @return
     */
    @PutMapping(&quot;/cancel/&#123;id&#125;&quot;)
    @ApiOperation(&quot;取消订单&quot;)
    public Result cancel(@PathVariable(&quot;id&quot;) Long id) throws Exception &#123;
        orderService.userCancelById(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="3-2-2-OrderService"><a href="#3-2-2-OrderService" class="headerlink" title="3.2.2 OrderService"></a>3.2.2 OrderService</h4><pre><code class="java">    /**
     * 用户取消订单
     * @param id
     */
    void userCancelById(Long id) throws Exception;
</code></pre>
<h4 id="3-2-3-OrderServiceImpl"><a href="#3-2-3-OrderServiceImpl" class="headerlink" title="3.2.3 OrderServiceImpl"></a>3.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 用户取消订单
     *
     * @param id
     */
    public void userCancelById(Long id) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在
        if (ordersDB == null) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_NOT_FOUND);
        &#125;

        //订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
        if (ordersDB.getStatus() &gt; 2) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());

        // 订单处于待接单状态下取消，需要进行退款
        if (ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;
            //调用微信支付退款接口
            weChatPayUtil.refund(
                    ordersDB.getNumber(), //商户订单号
                    ordersDB.getNumber(), //商户退款单号
                    new BigDecimal(0.01),//退款金额，单位 元
                    new BigDecimal(0.01));//原订单金额

            //支付状态修改为 退款
            orders.setPayStatus(Orders.REFUND);
        &#125;

        // 更新订单状态、取消原因、取消时间
        orders.setStatus(Orders.CANCELLED);
        orders.setCancelReason(&quot;用户取消&quot;);
        orders.setCancelTime(LocalDateTime.now());
        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="再来一单"><a href="#再来一单" class="headerlink" title="再来一单"></a>再来一单</h3><h4 id="4-2-1-user-x2F-OrderController"><a href="#4-2-1-user-x2F-OrderController" class="headerlink" title="4.2.1 user&#x2F;OrderController"></a>4.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     * @return
     */
    @PostMapping(&quot;/repetition/&#123;id&#125;&quot;)
    @ApiOperation(&quot;再来一单&quot;)
    public Result repetition(@PathVariable Long id) &#123;
        orderService.repetition(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="4-2-2-OrderService"><a href="#4-2-2-OrderService" class="headerlink" title="4.2.2 OrderService"></a>4.2.2 OrderService</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     */
    void repetition(Long id);
</code></pre>
<h4 id="4-2-3-OrderServiceImpl"><a href="#4-2-3-OrderServiceImpl" class="headerlink" title="4.2.3 OrderServiceImpl"></a>4.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     */
   @Override
    public void repetition(Long id) &#123;
        //查询当前用户id
        Long userId = BaseContext.getCurrentId();
        //根据订单id查询当前订单详情
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(id);

        // 将订单详情对象转换为购物车对象
        // 这一行使用 map 方法对每个 OrderDetail 对象进行转换操作，x 是当前遍历的 OrderDetail 对象
        List&lt;ShoppingCart&gt; shoppingCartList = orderDetailList.stream().map(x -&gt; &#123;
            //表示一个函数，该函数接受一个参数 x 并返回一个新对象
            ShoppingCart shoppingCart = new ShoppingCart();

            // 将原订单详情里面的菜品信息重新复制到购物车对象中
            BeanUtils.copyProperties(x, shoppingCart, &quot;id&quot;);
            shoppingCart.setUserId(userId);
            shoppingCart.setCreateTime(LocalDateTime.now());

            return shoppingCart;
        &#125;).collect(Collectors.toList());
// 使用 collect 方法将转换后的 ShoppingCart 对象收集到一个新的 List&lt;ShoppingCart&gt; 列表中
        // 将购物车对象批量添加到数据库
        shoppingCartMapper.insertBatch(shoppingCartList);
    &#125;
</code></pre>
<h4 id="4-2-4-ShoppingCartMapper"><a href="#4-2-4-ShoppingCartMapper" class="headerlink" title="4.2.4 ShoppingCartMapper"></a>4.2.4 ShoppingCartMapper</h4><pre><code class="java">    /**
     * 批量插入购物车数据
     *
     * @param shoppingCartList
     */
    void insertBatch(List&lt;ShoppingCart&gt; shoppingCartList);
</code></pre>
<h4 id="4-2-5-ShoppingCartMapper-xml"><a href="#4-2-5-ShoppingCartMapper-xml" class="headerlink" title="4.2.5 ShoppingCartMapper.xml"></a>4.2.5 ShoppingCartMapper.xml</h4><pre><code class="xml">&lt;insert id=&quot;insertBatch&quot; parameterType=&quot;list&quot;&gt;
        insert into shopping_cart
        (name, image, user_id, dish_id, setmeal_id, dish_flavor, number, amount, create_time)
        values
        &lt;foreach collection=&quot;shoppingCartList&quot; item=&quot;sc&quot; separator=&quot;,&quot;&gt;
            
        &lt;/foreach&gt;
&lt;/insert&gt;
</code></pre>
<h3 id="订单搜索"><a href="#订单搜索" class="headerlink" title="订单搜索"></a>订单搜索</h3><h4 id="1-2-1-admin-x2F-OrderController"><a href="#1-2-1-admin-x2F-OrderController" class="headerlink" title="1.2.1 admin&#x2F;OrderController"></a>1.2.1 admin&#x2F;OrderController</h4><p>在admin包下创建OrderController</p>
<pre><code class="java">/**
 * 订单管理
 */
@RestController(&quot;adminOrderController&quot;)
@RequestMapping(&quot;/admin/order&quot;)
@Slf4j
@Api(tags = &quot;订单管理接口&quot;)
public class OrderController &#123;

    @Autowired
    private OrderService orderService;

    /**
     * 订单搜索
     *
     * @param ordersPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/conditionSearch&quot;)
    @ApiOperation(&quot;订单搜索&quot;)
    public Result&lt;PageResult&gt; conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO) &#123;
        PageResult pageResult = orderService.conditionSearch(ordersPageQueryDTO);
        return Result.success(pageResult);
    &#125;
&#125;
</code></pre>
<h4 id="1-2-2-OrderService-1"><a href="#1-2-2-OrderService-1" class="headerlink" title="1.2.2 OrderService"></a>1.2.2 OrderService</h4><pre><code class="java">    /**
     * 条件搜索订单
     * @param ordersPageQueryDTO
     * @return
     */
    PageResult conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO);
</code></pre>
<h4 id="1-2-3-OrderServiceImpl-1"><a href="#1-2-3-OrderServiceImpl-1" class="headerlink" title="1.2.3 OrderServiceImpl"></a>1.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 订单搜索
     *
     * @param ordersPageQueryDTO
     * @return
     */
    public PageResult conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO) &#123;
        PageHelper.startPage(ordersPageQueryDTO.getPage(), ordersPageQueryDTO.getPageSize());

        Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);

        // 部分订单状态，需要额外返回订单菜品信息，将Orders转化为OrderVO
        List&lt;OrderVO&gt; orderVOList = getOrderVOList(page);

        return new PageResult(page.getTotal(), orderVOList);
    &#125;

    private List&lt;OrderVO&gt; getOrderVOList(Page&lt;Orders&gt; page) &#123;
        // 需要返回订单菜品信息，自定义OrderVO响应结果
        List&lt;OrderVO&gt; orderVOList = new ArrayList&lt;&gt;();

        List&lt;Orders&gt; ordersList = page.getResult();
        if (!CollectionUtils.isEmpty(ordersList)) &#123;
            for (Orders orders : ordersList) &#123;
                // 将共同字段复制到OrderVO
                OrderVO orderVO = new OrderVO();
                BeanUtils.copyProperties(orders, orderVO);
                String orderDishes = getOrderDishesStr(orders);

                // 将订单菜品信息封装到orderVO中，并添加到orderVOList
                orderVO.setOrderDishes(orderDishes);
                orderVOList.add(orderVO);
            &#125;
        &#125;
        return orderVOList;
    &#125;

    /**
     * 根据订单id获取菜品信息字符串
     *
     * @param orders
     * @return
     */
    private String getOrderDishesStr(Orders orders) &#123;
        // 查询订单菜品详情信息（订单中的菜品和数量）
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());

        // 将每一条订单菜品信息拼接为字符串（格式：宫保鸡丁*3；）
        List&lt;String&gt; orderDishList = orderDetailList.stream().map(x -&gt; &#123;
            String orderDish = x.getName() + &quot;*&quot; + x.getNumber() + &quot;;&quot;;
            return orderDish;
        &#125;).collect(Collectors.toList());

        // 将该订单对应的所有菜品信息拼接在一起
        return String.join(&quot;&quot;, orderDishList);
    &#125;
</code></pre>
<h3 id="各个状态的订单数量统计"><a href="#各个状态的订单数量统计" class="headerlink" title="各个状态的订单数量统计"></a>各个状态的订单数量统计</h3><h4 id="2-2-1-admin-x2F-OrderController"><a href="#2-2-1-admin-x2F-OrderController" class="headerlink" title="2.2.1 admin&#x2F;OrderController"></a>2.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     *
     * @return
     */
    @GetMapping(&quot;/statistics&quot;)
    @ApiOperation(&quot;各个状态的订单数量统计&quot;)
    public Result&lt;OrderStatisticsVO&gt; statistics() &#123;
        OrderStatisticsVO orderStatisticsVO = orderService.statistics();
        return Result.success(orderStatisticsVO);
    &#125;
</code></pre>
<h4 id="2-2-2-OrderService-1"><a href="#2-2-2-OrderService-1" class="headerlink" title="2.2.2 OrderService"></a>2.2.2 OrderService</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     * @return
     */
    OrderStatisticsVO statistics();
</code></pre>
<h4 id="2-2-3-OrderServiceImpl-1"><a href="#2-2-3-OrderServiceImpl-1" class="headerlink" title="2.2.3 OrderServiceImpl"></a>2.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     *
     * @return
     */
    public OrderStatisticsVO statistics() &#123;
        // 根据状态，分别查询出待接单、待派送、派送中的订单数量
        Integer toBeConfirmed = orderMapper.countStatus(Orders.TO_BE_CONFIRMED);
        Integer confirmed = orderMapper.countStatus(Orders.CONFIRMED);
        Integer deliveryInProgress = orderMapper.countStatus(Orders.DELIVERY_IN_PROGRESS);

        // 将查询出的数据封装到orderStatisticsVO中响应
        OrderStatisticsVO orderStatisticsVO = new OrderStatisticsVO();
        orderStatisticsVO.setToBeConfirmed(toBeConfirmed);
        orderStatisticsVO.setConfirmed(confirmed);
        orderStatisticsVO.setDeliveryInProgress(deliveryInProgress);
        return orderStatisticsVO;
    &#125;
</code></pre>
<h4 id="2-2-4-OrderMapper-1"><a href="#2-2-4-OrderMapper-1" class="headerlink" title="2.2.4 OrderMapper"></a>2.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 根据状态统计订单数量
     * @param status
     */
    @Select(&quot;select count(id) from orders where status = #&#123;status&#125;&quot;)
    Integer countStatus(Integer status);
</code></pre>
<h3 id="查询订单详情-1"><a href="#查询订单详情-1" class="headerlink" title="查询订单详情"></a>查询订单详情</h3><p>业务规则：</p>
<ul>
<li>订单详情页面需要展示订单基本信息（状态、订单号、下单时间、收货人、电话、收货地址、金额等）</li>
<li>订单详情页面需要展示订单明细数据（商品名称、数量、单价）</li>
</ul>
<h4 id="3-2-1-admin-x2F-OrderController"><a href="#3-2-1-admin-x2F-OrderController" class="headerlink" title="3.2.1 admin&#x2F;OrderController"></a>3.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 订单详情
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/details/&#123;id&#125;&quot;)
    @ApiOperation(&quot;查询订单详情&quot;)
    public Result&lt;OrderVO&gt; details(@PathVariable(&quot;id&quot;) Long id) &#123;
        OrderVO orderVO = orderService.details(id);
        return Result.success(orderVO);
    &#125;
</code></pre>
<h3 id="接单"><a href="#接单" class="headerlink" title="接单"></a>接单</h3><p>业务规则：</p>
<ul>
<li>商家接单其实就是将订单的状态修改为“已接单”</li>
</ul>
<h4 id="4-2-1-admin-x2F-OrderController"><a href="#4-2-1-admin-x2F-OrderController" class="headerlink" title="4.2.1 admin&#x2F;OrderController"></a>4.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 接单
     *
     * @return
     */
    @PutMapping(&quot;/confirm&quot;)
    @ApiOperation(&quot;接单&quot;)
    public Result confirm(@RequestBody OrdersConfirmDTO ordersConfirmDTO) &#123;
        orderService.confirm(ordersConfirmDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="4-2-2-OrderService-1"><a href="#4-2-2-OrderService-1" class="headerlink" title="4.2.2 OrderService"></a>4.2.2 OrderService</h4><pre><code class="java">    /**
     * 接单
     *
     * @param ordersConfirmDTO
     */
    void confirm(OrdersConfirmDTO ordersConfirmDTO);
</code></pre>
<h4 id="4-2-3-OrderServiceImpl-1"><a href="#4-2-3-OrderServiceImpl-1" class="headerlink" title="4.2.3 OrderServiceImpl"></a>4.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 接单
     *
     * @param ordersConfirmDTO
     */
    public void confirm(OrdersConfirmDTO ordersConfirmDTO) &#123;
        Orders orders = Orders.builder()
                .id(ordersConfirmDTO.getId())
                .status(Orders.CONFIRMED)
                .build();

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="拒单"><a href="#拒单" class="headerlink" title="拒单"></a>拒单</h3><p>业务规则：</p>
<ul>
<li>商家拒单其实就是将订单状态修改为“已取消”</li>
<li>只有订单处于“待接单”状态时可以执行拒单操作</li>
<li>商家拒单时需要指定拒单原因</li>
<li>商家拒单时，如果用户已经完成了支付，需要为用户退款</li>
</ul>
<h4 id="5-2-1-admin-x2F-OrderController"><a href="#5-2-1-admin-x2F-OrderController" class="headerlink" title="5.2.1 admin&#x2F;OrderController"></a>5.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 拒单
     *
     * @return
     */
    @PutMapping(&quot;/rejection&quot;)
    @ApiOperation(&quot;拒单&quot;)
    public Result rejection(@RequestBody OrdersRejectionDTO ordersRejectionDTO) throws Exception &#123;
        orderService.rejection(ordersRejectionDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="5-2-2-OrderService"><a href="#5-2-2-OrderService" class="headerlink" title="5.2.2 OrderService"></a>5.2.2 OrderService</h4><pre><code class="java">    /**
     * 拒单
     *
     * @param ordersRejectionDTO
     */
    void rejection(OrdersRejectionDTO ordersRejectionDTO) throws Exception;
</code></pre>
<h4 id="5-2-3-OrderServiceImpl"><a href="#5-2-3-OrderServiceImpl" class="headerlink" title="5.2.3 OrderServiceImpl"></a>5.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 拒单
     *
     * @param ordersRejectionDTO
     */
    public void rejection(OrdersRejectionDTO ordersRejectionDTO) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(ordersRejectionDTO.getId());

        // 订单只有存在且状态为2（待接单）才可以拒单
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        //支付状态
        Integer payStatus = ordersDB.getPayStatus();
        if (payStatus == Orders.PAID) &#123;
            //用户已支付，需要退款
            String refund = weChatPayUtil.refund(
                    ordersDB.getNumber(),
                    ordersDB.getNumber(),
                    new BigDecimal(0.01),
                    new BigDecimal(0.01));
            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);
        &#125;

        // 拒单需要退款，根据订单id更新订单状态、拒单原因、取消时间
        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        orders.setStatus(Orders.CANCELLED);
        orders.setRejectionReason(ordersRejectionDTO.getRejectionReason());
        orders.setCancelTime(LocalDateTime.now());

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="取消订单-1"><a href="#取消订单-1" class="headerlink" title="取消订单"></a>取消订单</h3><h4 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h4><h4 id="6-2-1-admin-x2F-OrderController"><a href="#6-2-1-admin-x2F-OrderController" class="headerlink" title="6.2.1 admin&#x2F;OrderController"></a>6.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 取消订单
     *
     * @return
     */
    @PutMapping(&quot;/cancel&quot;)
    @ApiOperation(&quot;取消订单&quot;)
    public Result cancel(@RequestBody OrdersCancelDTO ordersCancelDTO) throws Exception &#123;
        orderService.cancel(ordersCancelDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="6-2-2-OrderService"><a href="#6-2-2-OrderService" class="headerlink" title="6.2.2 OrderService"></a>6.2.2 OrderService</h4><pre><code class="java">    /**
     * 商家取消订单
     *
     * @param ordersCancelDTO
     */
    void cancel(OrdersCancelDTO ordersCancelDTO) throws Exception;
</code></pre>
<h4 id="6-2-3-OrderServiceImpl"><a href="#6-2-3-OrderServiceImpl" class="headerlink" title="6.2.3 OrderServiceImpl"></a>6.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 取消订单
     *
     * @param ordersCancelDTO
     */
    public void cancel(OrdersCancelDTO ordersCancelDTO) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(ordersCancelDTO.getId());

        //支付状态
        Integer payStatus = ordersDB.getPayStatus();
        if (payStatus == 1) &#123;
            //用户已支付，需要退款
            String refund = weChatPayUtil.refund(
                    ordersDB.getNumber(),
                    ordersDB.getNumber(),
                    new BigDecimal(0.01),
                    new BigDecimal(0.01));
            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);
        &#125;

        // 管理端取消订单需要退款，根据订单id更新订单状态、取消原因、取消时间
        Orders orders = new Orders();
        orders.setId(ordersCancelDTO.getId());
        orders.setStatus(Orders.CANCELLED);
        orders.setCancelReason(ordersCancelDTO.getCancelReason());
        orders.setCancelTime(LocalDateTime.now());
        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="派送订单"><a href="#派送订单" class="headerlink" title="派送订单"></a>派送订单</h3><p>业务规则：</p>
<ul>
<li>派送订单其实就是将订单状态修改为“派送中”</li>
<li>只有状态为“待派送”的订单可以执行派送订单操作</li>
</ul>
<h4 id="7-2-1-admin-x2F-OrderController"><a href="#7-2-1-admin-x2F-OrderController" class="headerlink" title="7.2.1 admin&#x2F;OrderController"></a>7.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @return
     */
    @PutMapping(&quot;/delivery/&#123;id&#125;&quot;)
    @ApiOperation(&quot;派送订单&quot;)
    public Result delivery(@PathVariable(&quot;id&quot;) Long id) &#123;
        orderService.delivery(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="7-2-2-OrderService"><a href="#7-2-2-OrderService" class="headerlink" title="7.2.2 OrderService"></a>7.2.2 OrderService</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @param id
     */
    void delivery(Long id);
</code></pre>
<h4 id="7-2-3-OrderServiceImpl"><a href="#7-2-3-OrderServiceImpl" class="headerlink" title="7.2.3 OrderServiceImpl"></a>7.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @param id
     */
    public void delivery(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在，并且状态为3
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.CONFIRMED)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        // 更新订单状态,状态转为派送中
        orders.setStatus(Orders.DELIVERY_IN_PROGRESS);

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="完成订单"><a href="#完成订单" class="headerlink" title="完成订单"></a>完成订单</h3><p>业务规则：</p>
<ul>
<li>完成订单其实就是将订单状态修改为“已完成”</li>
<li>只有状态为“派送中”的订单可以执行订单完成操作</li>
</ul>
<h4 id="8-2-1-admin-x2F-OrderController"><a href="#8-2-1-admin-x2F-OrderController" class="headerlink" title="8.2.1 admin&#x2F;OrderController"></a>8.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @return
     */
    @PutMapping(&quot;/complete/&#123;id&#125;&quot;)
    @ApiOperation(&quot;完成订单&quot;)
    public Result complete(@PathVariable(&quot;id&quot;) Long id) &#123;
        orderService.complete(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="8-2-2-OrderService"><a href="#8-2-2-OrderService" class="headerlink" title="8.2.2 OrderService"></a>8.2.2 OrderService</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @param id
     */
    void complete(Long id);
</code></pre>
<h4 id="8-2-3-OrderServiceImpl"><a href="#8-2-3-OrderServiceImpl" class="headerlink" title="8.2.3 OrderServiceImpl"></a>8.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @param id
     */
    public void complete(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在，并且状态为4
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.DELIVERY_IN_PROGRESS)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        // 更新订单状态,状态转为完成
        orders.setStatus(Orders.COMPLETED);
        orders.setDeliveryTime(LocalDateTime.now());

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="校验收货地址是否超出配送范围"><a href="#校验收货地址是否超出配送范围" class="headerlink" title="校验收货地址是否超出配送范围"></a>校验收货地址是否超出配送范围</h3><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>注册账号：<a target="_blank" rel="noopener" href="https://passport.baidu.com/v2/?reg&amp;tt=1671699340600&amp;overseas=&amp;gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&amp;tpl=pp&amp;u=https://lbsyun.baidu.com/index.php?title=%E9%A6%96%E9%A1%B5">https://passport.baidu.com/v2/?reg&amp;tt=1671699340600&amp;overseas=&amp;gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&amp;tpl=pp&amp;u=https%3A%2F%2Flbsyun.baidu.com%2Findex.php%3Ftitle%3D%E9%A6%96%E9%A1%B5</a></p>
<p>登录百度地图开放平台：<a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/">https://lbsyun.baidu.com/</a></p>
<p>进入控制台，创建应用，获取AK：</p>
<p>![image-20221222170049729](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170049729.png)</p>
<p>![image-20221222170256927](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170256927.png)</p>
<p>相关接口:</p>
<p><a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding">https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding</a></p>
<p><a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1">https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1</a></p>
<h2 id="2-代码开发"><a href="#2-代码开发" class="headerlink" title="2. 代码开发"></a>2. 代码开发</h2><h3 id="2-1-application-yml"><a href="#2-1-application-yml" class="headerlink" title="2.1 application.yml"></a>2.1 application.yml</h3><p>配置外卖商家店铺地址和百度地图的AK：</p>
<p>![image-20221222170819582](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170819582.png)</p>
<h3 id="2-2-OrderServiceImpl"><a href="#2-2-OrderServiceImpl" class="headerlink" title="2.2 OrderServiceImpl"></a>2.2 OrderServiceImpl</h3><p>改造OrderServiceImpl，注入上面的配置项：</p>
<pre><code class="java">com/sky/properties/BaiDuProperties.java
package com.sky.properties;

import lombok.Data;
import lombok.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
// 多个prefix
@ConfigurationProperties(prefix = &quot;sky.baidu&quot;)
@Data
public class BaiDuProperties &#123;
    private String shopAddress;
    private String ak;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
  baidu:
    ak: $&#123;sky.baidu.ak&#125;
    shopAddress: $&#123;sky.baidu.shopAddress&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
  baidu:
    ak: xxxxxxxxx
    shopAddress: 河北省唐山市丰润区燕山路街道美景花园
</code></pre>
<p>在OrderServiceImpl中提供校验方法：</p>
<pre><code class="java">/**
     * 检查客户的收货地址是否超出配送范围
     * @param address
     */
    private void checkOutOfRange(String address) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;address&quot;, baiDuProperties.getShopAddress());
        map.put(&quot;output&quot;, &quot;json&quot;);
        map.put(&quot;ak&quot;, baiDuProperties.getAk());

        //获取店铺的经纬度坐标
        String shopCoordinate = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/geocoding/v3&quot;, map);

        JSONObject jsonObject = JSON.parseObject(shopCoordinate);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;店铺地址解析失败&quot;);
        &#125;

        //数据解析
        JSONObject location = jsonObject.getJSONObject(&quot;result&quot;).getJSONObject(&quot;location&quot;);
        String lat = location.getString(&quot;lat&quot;);
        String lng = location.getString(&quot;lng&quot;);
        //店铺经纬度坐标
        String shopLngLat = lat + &quot;,&quot; + lng;

        map.put(&quot;address&quot;,address);
        //获取用户收货地址的经纬度坐标
        String userCoordinate = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/geocoding/v3&quot;, map);

        jsonObject = JSON.parseObject(userCoordinate);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;收货地址解析失败&quot;);
        &#125;

        //数据解析
        location = jsonObject.getJSONObject(&quot;result&quot;).getJSONObject(&quot;location&quot;);
        lat = location.getString(&quot;lat&quot;);
        lng = location.getString(&quot;lng&quot;);
        //用户收货地址经纬度坐标
        String userLngLat = lat + &quot;,&quot; + lng;

        map.put(&quot;origin&quot;,shopLngLat);
        map.put(&quot;destination&quot;,userLngLat);
        map.put(&quot;steps_info&quot;,&quot;0&quot;);

        //路线规划
        String json = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/directionlite/v1/driving&quot;, map);

        jsonObject = JSON.parseObject(json);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;配送路线规划失败&quot;);
        &#125;

        //数据解析
        JSONObject result = jsonObject.getJSONObject(&quot;result&quot;);
        JSONArray jsonArray = (JSONArray) result.get(&quot;routes&quot;);
        Integer distance = (Integer) ((JSONObject) jsonArray.get(0)).get(&quot;distance&quot;);

        if(distance &gt; 5000)&#123;
            //配送距离超过5000米
            throw new OrderBusinessException(&quot;超出配送范围&quot;);
        &#125;
    &#125;
</code></pre>
<p>在OrderServiceImpl的submitOrder方法中调用上面的校验方法：</p>
<pre><code class="java">   // 检查用户的收获地址是否超出配送范围
        checkOutOfRange(addressBook.getCityName() + addressBook.getDistrictName() + addressBook.getDetail());
</code></pre>
<p>![image-20221222171444981](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222171444981.png)</p>
<h3 id="SpringTask-定时任务-定时自动执行某段Java代码"><a href="#SpringTask-定时任务-定时自动执行某段Java代码" class="headerlink" title="SpringTask[定时任务]定时自动执行某段Java代码"></a>SpringTask[定时任务]<del>定时自动执行某段Java代码</del></h3><p>SpringTask是Spring框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ul>
<li>信用卡每月还款提醒</li>
<li>银行贷款每月还款提醒</li>
<li>火车票售票系统处理未支付订单</li>
<li>入职纪念日为用户发送通知</li>
</ul>
<h5 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h5><p>cron表达式其实就是一个字符串，通过cron表达式可以<strong>定义任务触发时间</strong><br>构成规则：分为6或7个域，由空格分隔开，每个域代表一个含义<br>每个域的含义分别为：<u>秒、分钟、小时、日、月、周、年</u>(可选)</p>
<h6 id="2022年10月12日上午9点整-对应的cron表达式（日-和-周-不能同时定义）"><a href="#2022年10月12日上午9点整-对应的cron表达式（日-和-周-不能同时定义）" class="headerlink" title="2022年10月12日上午9点整 对应的cron表达式（日 和 周 不能同时定义）"></a>2022年10月12日上午9点整 对应的cron表达式（日 和 周 不能同时定义）</h6><p>0 0 9 12 10 ？ 2022<br><a target="_blank" rel="noopener" href="https://cron.qqe2.com/">https://cron.qqe2.com</a></p>
<table>
<thead>
<tr>
<th>秒</th>
<th>分钟</th>
<th>小时</th>
<th>日</th>
<th>月</th>
<th>周</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>9</td>
<td>12</td>
<td>10</td>
<td>？</td>
</tr>
</tbody></table>
<h6 id="SpringTask使用步骤："><a href="#SpringTask使用步骤：" class="headerlink" title="SpringTask使用步骤："></a>SpringTask使用步骤：</h6><ul>
<li>导入maven坐标 spring-context（已存在）</li>
<li>启动类添加注解 <code>@EnableScheduling</code> 开启任务调度</li>
<li><strong>自定义定时任务类</strong></li>
</ul>
<pre><code class="java">sky-server  com/sky/task/MyTask.java
package com.sky.task;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import java.util.Date;

/**
 * 自定义定时任务类
 */
@Component
@Slf4j
public class MyTask &#123;

    /**
     * 定时任务 每隔5秒触发一次
     */
    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)
    public void executeTask()&#123;
        log.info(&quot;定时任务开始执行：&#123;&#125;&quot;, new Date());
    &#125;
&#125;
</code></pre>
<h3 id="订单状态定时处理"><a href="#订单状态定时处理" class="headerlink" title="订单状态定时处理"></a>订单状态定时处理</h3><h6 id="用户下单后可能存在的情况："><a href="#用户下单后可能存在的情况：" class="headerlink" title="用户下单后可能存在的情况："></a>用户下单后可能存在的情况：</h6><ul>
<li>下单后未支付，订单一直处于”<strong>待支付</strong>“状态</li>
<li>用户收获后管理端未点击完成按钮，订单一直处于<strong>“派送中”</strong>状态<ul>
<li>通过定时任务<strong>每分钟检查一次</strong>是否存在支付超时订单(超过15min)，如果存在则修改订单状态为”已取消”</li>
<li>通过定时任务<strong>每天凌晨1点检查一次</strong>是否存在”派送中”的订单，如果存在则修改订单状态为”已完成”</li>
</ul>
</li>
</ul>
<h5 id="代码开发：-4"><a href="#代码开发：-4" class="headerlink" title="代码开发："></a>代码开发：</h5><pre><code class="java">sky-server  com/sky/task/OrderTask.java
package com.sky.task;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

@Component
@Slf4j
public class OrderTask &#123;
    @Autowired
    private OrderMapper orderMapper;

    /**
     * 处理超时订单的方法
     */
    @Scheduled(cron = &quot;0 * * * * ?&quot;)//每分钟触发一次
    public void processTimeoutOrder()&#123;
        log.info(&quot;定时处理超时订单&quot;);
        // select * from orders where status = ? and order_time = (当前时间 - 15分钟)
        LocalDateTime time = LocalDateTime.now().plusMinutes(-15);
        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.PENDING_PAYMENT, time);
        if (ordersList != null &amp;&amp; ordersList.size() &gt; 0) &#123;
            for (Orders orders : ordersList) &#123;
                orders.setStatus(Orders.CANCELLED);
                orders.setCancelReason(&quot;订单超时，自动取消&quot;);
                orders.setCancelTime(LocalDateTime.now());
                orderMapper.update(orders);
            &#125;
        &#125;
    &#125;

    /**
     * 处理一直处于派送中状态的订单
     */
    @Scheduled(cron = &quot;0 0 1 * * ?&quot;)//每天凌晨一点
    public void processDeliveryOrder() &#123;
        log.info(&quot;定时处理处于派送中的订单&quot;);
        LocalDateTime time = LocalDateTime.now().plusMinutes(-60);
        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.DELIVERY_IN_PROGRESS, time);
        if (ordersList != null &amp;&amp; ordersList.size() &gt; 0) &#123;
            for (Orders orders : ordersList) &#123;
                orders.setStatus(Orders.COMPLETED);
                orderMapper.update(orders);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
    /**
     *
     * 根据订单状态和下单时间查询订单
     * @param status
     * @param orderTime
     * @return
     */
    @Select(&quot;select * from orders where status = #&#123;status&#125; and order_time &lt; #&#123;orderTime&#125;&quot;)
    List&lt;Orders&gt; getByStatusAndOrderTimeLT(Integer status, LocalDateTime orderTime);
</code></pre>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是基于TCP的一种新的<strong>网络协议</strong>，它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持续性</strong>连接，并进行<strong>双向</strong>数据传输</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/edb75e96dfbeebfac80f0c08ad92001201b8754c/data/WebSocket.png"></p>
<h6 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h6><ul>
<li>视频弹幕</li>
<li>网页聊天</li>
<li>体育实况更新</li>
<li>股票基金报价实时更新</li>
</ul>
<h5 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h5><p><strong>实现步骤：</strong></p>
<ul>
<li>直接使用<strong>websocket.html</strong>页面坐位WebSocket客户端</li>
<li>导入<strong>WebSocket</strong>的maven坐标</li>
<li>导入<strong>WebSocket</strong>服务端组件<strong>WebSocketServer</strong>，用于和客户端通信</li>
<li>导入配置类<strong>WebSocketConfiguration</strong>，注册WebSocket的服务端组件</li>
<li>导入定时人物类<strong>WebSocketTask</strong>，定时向客户端推送数据</li>
</ul>
<pre><code class="html">websocket.html
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;WebSocket Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;
    &lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt;
    &lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭连接&lt;/button&gt;
    &lt;div id=&quot;message&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var websocket = null;
    var clientId = Math.random().toString(36).substr(2);

    //判断当前浏览器是否支持WebSocket
    if(&#39;WebSocket&#39; in window)&#123;
        //连接WebSocket节点
        websocket = new WebSocket(&quot;ws://localhost:8080/ws/&quot;+clientId);
    &#125;
    else&#123;
        alert(&#39;Not support websocket&#39;)
    &#125;

    //连接发生错误的回调方法
    websocket.onerror = function()&#123;
        setMessageInnerHTML(&quot;error&quot;);
    &#125;;

    //连接成功建立的回调方法
    websocket.onopen = function()&#123;
        setMessageInnerHTML(&quot;连接成功&quot;);
    &#125;

    //接收到消息的回调方法
    websocket.onmessage = function(event)&#123;
        setMessageInnerHTML(event.data);
    &#125;

    //连接关闭的回调方法
    websocket.onclose = function()&#123;
        setMessageInnerHTML(&quot;close&quot;);
    &#125;

    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
    window.onbeforeunload = function()&#123;
        websocket.close();
    &#125;

    //将消息显示在网页上
    function setMessageInnerHTML(innerHTML)&#123;
        document.getElementById(&#39;message&#39;).innerHTML += innerHTML + &#39;&lt;br/&gt;&#39;;
    &#125;

    //发送消息
    function send()&#123;
        var message = document.getElementById(&#39;text&#39;).value;
        websocket.send(message);
    &#125;
    
    //关闭连接
    function closeWebSocket() &#123;
        websocket.close();
    &#125;
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/sky/websocket/WebSocketServer.java
package com.sky.websocket;

import org.springframework.stereotype.Component;
import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * WebSocket服务
 */
@Component //交给spring容器管理
@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)
public class WebSocketServer &#123;

    //存放会话对象
    private static Map&lt;String, Session&gt; sessionMap = new HashMap();

    /**
     * 连接建立成功调用的方法
     */
    @OnOpen
    public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;客户端：&quot; + sid + &quot;建立连接&quot;);
        sessionMap.put(sid, session);
    &#125;

    /**
     * 收到客户端消息后调用的方法
     *
     * @param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, @PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;收到来自客户端：&quot; + sid + &quot;的信息:&quot; + message);
    &#125;

    /**
     * 连接关闭调用的方法
     *
     * @param sid
     */
    @OnClose
    public void onClose(@PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;连接断开:&quot; + sid);
        sessionMap.remove(sid);
    &#125;

    /**
     * 群发
     *
     * @param message
     */
    public void sendToAllClient(String message) &#123;
        Collection&lt;Session&gt; sessions = sessionMap.values();
        for (Session session : sessions) &#123;
            try &#123;
                //服务器向客户端发送消息
                session.getBasicRemote().sendText(message);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/config/WebSocketConfiguration.java
package com.sky.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

/**
 * WebSocket配置类，用于注册WebSocket的Bean
 */
@Configuration
public class WebSocketConfiguration &#123;

    @Bean
    public ServerEndpointExporter serverEndpointExporter() &#123;
        return new ServerEndpointExporter();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/task/WebSocketTask.java
package com.sky.task;

import com.sky.websocket.WebSocketServer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Component
public class WebSocketTask &#123;
    @Autowired
    private WebSocketServer webSocketServer;

    /**
     * 通过WebSocket每隔5秒向客户端发送消息
     */
    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)
    public void sendMessageToClient() &#123;
        webSocketServer.sendToAllClient(&quot;这是来自服务端的消息：&quot; + DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;).format(LocalDateTime.now()));
    &#125;
&#125;
</code></pre>
<h3 id="来单提醒"><a href="#来单提醒" class="headerlink" title="来单提醒"></a>来单提醒</h3><p>用户下单并且支付成功后，需要第一时间通知外卖商家</p>
<ul>
<li><strong>语音播报</strong></li>
<li><strong>弹出提示框</strong></li>
</ul>
<h6 id="设计："><a href="#设计：" class="headerlink" title="设计："></a>设计：</h6><ul>
<li>通过WebSocket实现管理端页面和服务端保持长连接状态</li>
<li>当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息</li>
<li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报</li>
<li>约定服务器发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content<ul>
<li>type 为消息类型，1为来单提醒  2为客户催单</li>
<li>orderId 为订单id</li>
<li>content 为消息内容</li>
</ul>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
 /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        // 查询订单
        Orders order = orderMapper.getByOrderNumber(ordersPaymentDTO.getOrderNumber());
        if (order == null) &#123;
            throw new OrderBusinessException(&quot;订单不存在&quot;);
        &#125;

        // 检查订单支付状态
        if (order.getPayStatus() == 1) &#123; // 1 表示已支付
            throw new OrderBusinessException(&quot;该订单已支付&quot;);
        &#125;
        order.setPayStatus(1);

        // 更新订单支付状态为已支付
        order.setPayStatus(Orders.PAID);
        order.setCheckoutTime(LocalDateTime.now());
        order.setPayMethod(ordersPaymentDTO.getPayMethod());
        order.setStatus(Orders.TO_BE_CONFIRMED);

        // 支付成功后通过 WebSocket 向客户端推送消息
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;type&quot;, 1); // 1 表示来单提醒
        map.put(&quot;orderId&quot;, order.getId());
        map.put(&quot;content&quot;, &quot;订单号：&quot; + ordersPaymentDTO.getOrderNumber());

        webSocketServer.sendToAllClient(JSON.toJSONString(map));


        orderMapper.update(order);

        // 构造并返回支付结果对象
        OrderPaymentVO orderPaymentVO = new OrderPaymentVO();
        orderPaymentVO.setOrderNumber(order.getNumber()); // 订单号
        orderPaymentVO.setPaymentTime(new Date());
        orderPaymentVO.setPaymentStatus(&quot;SUCCESS&quot;);

        return orderPaymentVO;

    &#125;
</code></pre>
<h3 id="用户催单"><a href="#用户催单" class="headerlink" title="用户催单"></a>用户催单</h3><pre><code class="java">com/sky/controller/user/OrderController.java 
/**
     * 客户催单
     * @param id
     * @return
     */
    @GetMapping(&quot;/reminder/&#123;id&#125;&quot;)
    @ApiOperation(&quot;客户催单&quot;)
    public Result reminder(@PathVariable(&quot;id&quot;) Long id)&#123;
        orderService.reminder(id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">com/sky/service/OrderService.java
 /**
     * 用户催单
     * @param id
     */
    void reminder(Long id);
</code></pre>
<pre><code class="java">com/sky/service/impl/OrderServiceImpl.java
/**
     * 客户催单
     * @param id
     */
    public void reminder(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在
        if (ordersDB == null) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Map map = new HashMap();
        map.put(&quot;type&quot;,2); //1表示来单提醒 2表示客户催单
        map.put(&quot;orderId&quot;,id);
        map.put(&quot;content&quot;,&quot;订单号：&quot; + ordersDB.getNumber());

        //通过websocket向客户端浏览器推送消息
        webSocketServer.sendToAllClient(JSON.toJSONString(map));
    &#125;
</code></pre>
<h3 id="ApacheECharts"><a href="#ApacheECharts" class="headerlink" title="ApacheECharts"></a>ApacheECharts</h3><p><a target="_blank" rel="noopener" href="http://echarts.apache.org/zh/index.html">http://echarts.apache.org/zh/index.html</a></p>
<ul>
<li><strong>柱形图</strong> bar</li>
<li><strong>饼形图</strong></li>
<li><strong>折线图</strong></li>
</ul>
<p>使用Echarts，重点在于研究当前图标所需<strong>数据格式</strong>，通常是需要后端提供符合格式要求的动态数据，然后相应给前端来展示图表</p>
<h3 id="营业额统计"><a href="#营业额统计" class="headerlink" title="营业额统计"></a>营业额统计</h3><h6 id="业务规则"><a href="#业务规则" class="headerlink" title="业务规则"></a>业务规则</h6><ul>
<li>营业额指订单状态为已完成的订单金额合计</li>
<li>基于可视化报表的折线图展示营业额数据，x轴为日期，y轴为营业额</li>
<li>根据时间选择区间，展示每天的营业额数据</li>
</ul>
<h5 id="根据接口定义设计对应的vo："><a href="#根据接口定义设计对应的vo：" class="headerlink" title="根据接口定义设计对应的vo："></a>根据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/TurnoverReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TurnoverReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03 [开始到结束的每一天]
    private String dateList;

    //营业额，以逗号分隔，例如：406.0,1520.0,75.0 [营业额一一对应]
    private String turnoverList;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
 * 数据统计相关接口
 */
@RestController
@RequestMapping(&quot;/admin/report&quot;)
@Api(tags = &quot;数据统计接口&quot;)
@Slf4j
public class ReportController &#123;
    @Autowired
    private ReportService reportService;

    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/turnoverStatistics&quot;)
    public Result&lt;TurnoverReportVO&gt; turnoverStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate end) &#123;
        log.info(&quot;营业额统计:&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getTurnoverStatistics(begin,end));
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    TurnoverReportVO getTurnoverStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@Slf4j
public class ReportServiceImpl implements ReportService &#123;
    @Autowired
    private OrderMapper orderMapper;
    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    @Override
    public TurnoverReportVO getTurnoverStatistics(LocalDate begin, LocalDate end) &#123;
        // 当前集合用于存放从begin到end范围内的每天的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();
        dateList.add(begin);

        while (!begin.equals(end)) &#123;
            //日期计算，计算指定日期的后一天对应的日期
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        // 存放每天的营业额
        List&lt;Double&gt; turnoverList = new ArrayList&lt;&gt;();
        for (LocalDate date : dateList) &#123; //LocalDate只是年月日 而下单的Order有时分秒
            // 查询Date日期对应的营业额数据，数据额是指：订单状态为“已完成”的订单金额合计
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
        // select sum(count) from orders where order_time &gt; ? and order_time &lt; ? and status = 5
            Map map = new HashMap&lt;&gt;();
            map.put(&quot;begin&quot;, beginTime);
            map.put(&quot;end&quot;, endTime);
            map.put(&quot;status&quot;, Orders.COMPLETED);
            Double turnover = orderMapper.sumByMap(map);
            turnover = turnover == null ? 0.0 : turnover;//没有营业额则默认为0
            turnoverList.add(turnover);
        &#125;

        return TurnoverReportVO.builder()
                .dateList(StringUtils.join(dateList, &quot;,&quot;))
                .turnoverList(StringUtils.join(turnoverList, &quot;,&quot;))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
/**
     * 根据动态条件统计营业额数据
     * @param map
     * @return
     */
    Double sumByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;Orders&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into orders
        (number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark,
         phone, address, consignee, estimated_delivery_time, delivery_status, pack_amount, tableware_number,
         tableware_status)
        values (#&#123;number&#125;, #&#123;status&#125;, #&#123;userId&#125;, #&#123;addressBookId&#125;, #&#123;orderTime&#125;, #&#123;checkoutTime&#125;, #&#123;payMethod&#125;,
                #&#123;payStatus&#125;, #&#123;amount&#125;, #&#123;remark&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;consignee&#125;,
                #&#123;estimatedDeliveryTime&#125;, #&#123;deliveryStatus&#125;, #&#123;packAmount&#125;, #&#123;tablewareNumber&#125;, #&#123;tablewareStatus&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.sky.entity.Orders&quot;&gt;
        update orders
        &lt;set&gt;
            &lt;if test=&quot;cancelReason != null and cancelReason!=&#39;&#39; &quot;&gt;
                cancel_reason=#&#123;cancelReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;rejectionReason != null and rejectionReason!=&#39;&#39; &quot;&gt;
                rejection_reason=#&#123;rejectionReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;cancelTime != null&quot;&gt;
                cancel_time=#&#123;cancelTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payStatus != null&quot;&gt;
                pay_status=#&#123;payStatus&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payMethod != null&quot;&gt;
                pay_method=#&#123;payMethod&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;checkoutTime != null&quot;&gt;
                checkout_time=#&#123;checkoutTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;deliveryTime != null&quot;&gt;
                delivery_time = #&#123;deliveryTime&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders
        &lt;where&gt;
            &lt;if test=&quot;number != null and number!=&#39;&#39;&quot;&gt;
                and number like concat(&#39;%&#39;,#&#123;number&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;phone != null and phone!=&#39;&#39;&quot;&gt;
                and phone like concat(&#39;%&#39;,#&#123;phone&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;beginTime != null&quot;&gt;
                and order_time &amp;gt;= #&#123;beginTime&#125;
            &lt;/if&gt;
            &lt;if test=&quot;endTime != null&quot;&gt;
                and order_time &amp;lt;= #&#123;endTime&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by order_time desc
    &lt;/select&gt;
    &lt;!-- 根据订单号查询订单 --&gt;
    &lt;select id=&quot;getByOrderNumber&quot; parameterType=&quot;String&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders where number = #&#123;orderNumber&#125;
    &lt;/select&gt;
    &lt;select id=&quot;sumByMap&quot; resultType=&quot;java.lang.Double&quot;&gt;
        select sum(amount) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="用户统计"><a href="#用户统计" class="headerlink" title="用户统计"></a>用户统计</h3><p>业务规则：</p>
<ul>
<li>根据时间选择区间，展示每天的用户总量和新增用户量数据</li>
</ul>
<h5 id="据接口定义设计对应的vo："><a href="#据接口定义设计对应的vo：" class="headerlink" title="据接口定义设计对应的vo："></a>据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/UserReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //用户总量，以逗号分隔，例如：200,210,220
    private String totalUserList;

    //新增用户，以逗号分隔，例如：20,21,10
    private String newUserList;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
     * 用户统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/userStatistics&quot;)
    @ApiOperation(&quot;用户统计&quot;)
    public Result&lt;UserReportVO&gt; userStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate end)&#123;
        log.info(&quot;用户数据统计:&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getUserStatistics(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
   /**
     * 用户统计
     * @param begin
     * @param end
     * @return
     */
    UserReportVO getUserStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@Slf4j
public class ReportServiceImpl implements ReportService &#123;
    /**
     * 统计指定时间区间内的用户数据
     * @param begin
     * @param end
     * @return
     */
    @Override
    public UserReportVO getUserStatistics(LocalDate begin, LocalDate end) &#123;
        // 存放从begin 到 end之间的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();
        dateList.add(begin);
        while (!begin.equals(end)) &#123;
            //日期计算，计算指定日期的后一天的日期
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        // 存放每天新增用户数量 select count(id) from user where create_time &gt; ? and create_time &lt; ?
        List&lt;Integer&gt; newUserList = new ArrayList&lt;&gt;();
        // 存放每天的总用户数量 select count(id) from user where create_time &lt;= ?
        List&lt;Integer&gt; totalUserList = new ArrayList&lt;&gt;();

        for (LocalDate date : dateList) &#123;
        // 遍历每一天的用户总量和数量
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);

            Map map = new HashMap&lt;&gt;();
            map.put(&quot;end&quot;, endTime);

            // 总用户数量
            Integer integer = userMapper.countByMap(map);

            map.put(&quot;begin&quot;, beginTime);
            //新增用户数量
            Integer newUser = userMapper.countByMap(map);
            totalUserList.add(integer);
            newUserList.add(newUser);
        &#125;
        return UserReportVO.builder()
                .dateList(StringUtils.join(dateList, &quot;,&quot;))
                .totalUserList(StringUtils.join(totalUserList, &quot;,&quot;))
                .newUserList(StringUtils.join(newUserList, &quot;,&quot;))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
/**
     * 根据动态条件统计用户数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="订单统计"><a href="#订单统计" class="headerlink" title="订单统计"></a>订单统计</h3><h6 id="业务规则-1"><a href="#业务规则-1" class="headerlink" title="业务规则"></a>业务规则</h6><ul>
<li>根据时间选择区间，展示每天的订单总数和有效订单数</li>
<li>展示所选时间区间内的有效订单数、总订单数、订单完成率</li>
<li>订单完成率 &#x3D; 有效订单数 &#x2F; 总订单数 * 100%</li>
</ul>
<h6 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h6><ul>
<li>dataList 日期列表以逗号分隔</li>
<li>orderCompletionRate 订单完成率</li>
<li>orderCountList 订单数列表以逗号分隔</li>
<li>totalOrderCount 订单总数</li>
<li>validOrderCount 有效订单数</li>
<li>validOrderCountList 有效订单数列表以逗号分隔</li>
</ul>
<h5 id="据接口定义设计对应的vo：-1"><a href="#据接口定义设计对应的vo：-1" class="headerlink" title="据接口定义设计对应的vo："></a>据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/OrderReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //每日订单数，以逗号分隔，例如：260,210,215
    private String orderCountList;

    //每日有效订单数，以逗号分隔，例如：20,21,10
    private String validOrderCountList;

    //订单总数
    private Integer totalOrderCount;

    //有效订单数
    private Integer validOrderCount;

    //订单完成率
    private Double orderCompletionRate;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
     * 订单统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/ordersStatistics&quot;)
    @ApiOperation(&quot;订单统计&quot;)
    public Result&lt;OrderReportVO&gt; ordersStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)  LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end)&#123;
        log.info(&quot;订单数据统计：&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getOrderStatistics(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
 /**
     * 统计指定时间区间内的订单数据
     * @param begin
     * @param end
     * @return
     */
    OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

 /**
     * 统计指定时间区间内的订单数据
     * @param begin
     * @param end
     * @return
     */
    public OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end) &#123;
        //存放从begin到end之间的每天对应的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();

        dateList.add(begin);

        while (!begin.equals(end)) &#123;
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        //存放每天的订单总数
        List&lt;Integer&gt; orderCountList = new ArrayList&lt;&gt;();
        //存放每天的有效订单数
        List&lt;Integer&gt; validOrderCountList = new ArrayList&lt;&gt;();

        //遍历dateList集合，查询每天的有效订单数和订单总数
        for (LocalDate date : dateList) &#123;
            //查询每天的订单总数 select count(id) from orders where order_time &gt; ? and order_time &lt; ?
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
            Integer orderCount = getOrderCount(beginTime, endTime, null);

            //查询每天的有效订单数 select count(id) from orders where order_time &gt; ? and order_time &lt; ? and status = 5
            Integer validOrderCount = getOrderCount(beginTime, endTime, Orders.COMPLETED);

            orderCountList.add(orderCount);
            validOrderCountList.add(validOrderCount);
        &#125;

        //计算时间区间内的订单总数量
        Integer totalOrderCount = orderCountList.stream().reduce(Integer::sum).get();

        //计算时间区间内的有效订单数量
        Integer validOrderCount = validOrderCountList.stream().reduce(Integer::sum).get();

        Double orderCompletionRate = 0.0;
        if(totalOrderCount != 0)&#123;
            //计算订单完成率
            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
        &#125;

        return  OrderReportVO.builder()
                .dateList(StringUtils.join(dateList,&quot;,&quot;))
                .orderCountList(StringUtils.join(orderCountList,&quot;,&quot;))
                .validOrderCountList(StringUtils.join(validOrderCountList,&quot;,&quot;))
                .totalOrderCount(totalOrderCount)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .build();
    &#125;
    /**
     * 根据条件统计订单数量
     * @param begin
     * @param end
     * @param status
     * @return
     */
    private Integer getOrderCount(LocalDateTime begin, LocalDateTime end, Integer status)&#123;
        Map map = new HashMap();
        map.put(&quot;begin&quot;,begin);
        map.put(&quot;end&quot;,end);
        map.put(&quot;status&quot;,status);

        return orderMapper.countByMap(map);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
/**
     * 根据动态条件统计用户数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="销量排名Top10"><a href="#销量排名Top10" class="headerlink" title="销量排名Top10"></a>销量排名Top10</h3><h6 id="产品原型-查已完成的数据"><a href="#产品原型-查已完成的数据" class="headerlink" title="产品原型 (查已完成的数据)"></a>产品原型 (查已完成的数据)</h6><ul>
<li>此处的销量为商品销售的份数</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
/**
     * 销量排名统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/top10&quot;)
    @ApiOperation(&quot;销量排名top10&quot;)
    public Result&lt;SalesTop10ReportVO&gt; top10(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end)&#123;
        log.info(&quot;销量排名top10：&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getSalesTop10(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
/**
     * 销量排名统计
     * @param begin
     * @param end
     * @return
     */
    SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
    /**
     * 统计指定时间区间内的销量排名前10
     * @param begin
     * @param end
     * @return
     */
    @Override
    public SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end) &#123;
        LocalDateTime beginTime = LocalDateTime.of(begin, LocalTime.MIN);
        LocalDateTime endTime = LocalDateTime.of(end, LocalTime.MAX);

        List&lt;GoodsSalesDTO&gt; salesTop10 = orderMapper.getSalesTop10(beginTime, endTime);
        List&lt;String&gt; names = salesTop10.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList());
        String nameList = StringUtils.join(names, &quot;,&quot;);

        List&lt;Integer&gt; numbers = salesTop10.stream().map(GoodsSalesDTO::getNumber).collect(Collectors.toList());
        String numberList = StringUtils.join(numbers, &quot;,&quot;);

        //封装返回结果数据
        return SalesTop10ReportVO
                .builder()
                .nameList(nameList)
                .numberList(numberList)
                .build();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
  /**
     * 统计指定时间内的销量排名
     * @return
     */
    List&lt;GoodsSalesDTO&gt; getSalesTop10(LocalDateTime begin,LocalDateTime end);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;select id=&quot;getSalesTop10&quot; resultType=&quot;com.sky.dto.GoodsSalesDTO&quot;&gt;
        select od.name, sum(od.number) number
        from order_detail od,orders o
        where od.order_id = o.id and o.status = 5
        &lt;if test=&quot;begin != null&quot;&gt;
            and o.order_time &amp;gt; #&#123;begin&#125;
        &lt;/if&gt;
        &lt;if test=&quot;end != null&quot;&gt;
            and o.order_time &amp;lt; #&#123;end&#125;
        &lt;/if&gt;
        group by od.name
        order by number desc
        limit 0,10
    &lt;/select&gt;
</code></pre>
<h6 id="重装数据库"><a href="#重装数据库" class="headerlink" title="重装数据库"></a>重装数据库</h6><pre><code class="mysql">C:\Windows\System32&gt;cd D:\MySQL\MySQL Server 8.0\bin

C:\Windows\System32&gt;mysqld --install MySQL80
Service successfully installed.

C:\Windows\System32&gt;sc query | findstr MySQL

C:\Windows\System32&gt;net start MySQL80
MySQL80 服务正在启动 .
MySQL80 服务已经启动成功。
服务里的MySQL80是Mysql服务
-----------------------------------------------------------------------------------------

C:\Windows\System32&gt;cd D:\MariaDB 11.0\bin

C:\Windows\System32&gt;mysqld --install MariaDB
Service successfully installed.

C:\Windows\System32&gt;net start MariaDB
MariaDB 服务正在启动 .
MariaDB 服务无法启动。
服务里的MariaDB是MariaDB服务
</code></pre>
<h3 id="工作台"><a href="#工作台" class="headerlink" title="工作台"></a>工作台</h3><h5 id="工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率"><a href="#工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率" class="headerlink" title="工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率"></a>工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率</h5><p>功能工作台展示的数据：</p>
<ul>
<li>今日数据</li>
<li>订单管理</li>
<li>菜品总览</li>
<li>套餐总览</li>
<li>订单信息</li>
</ul>
<h6 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h6><ul>
<li>营业额：已完成订单的总金额</li>
<li>有效订单：已完成订单的数量</li>
<li>订单完成率：有效订单数 &#x2F; 总订单数 * 100%</li>
<li>平均客单价：营业额 &#x2F; 有效订单数</li>
<li>新增用户：新增用户的数量</li>
</ul>
<h6 id="接口设计：-5"><a href="#接口设计：-5" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>今日数据接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;businessData<br>Method: Get</p>
</blockquote>
</li>
<li><p>订单管理接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewOrders<br>Method: Get</p>
</blockquote>
</li>
<li><p>菜品总览接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewDishes<br>Method: Get</p>
</blockquote>
</li>
<li><p>套餐总览接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewSetmeals<br>Method: Get</p>
</blockquote>
</li>
<li><p>订单搜索(已完成)</p>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/admin/WorkSpaceController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.WorkspaceService;
import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * 工作台
 */
@RestController
@RequestMapping(&quot;/admin/workspace&quot;)
@Slf4j
@Api(tags = &quot;工作台相关接口&quot;)
public class WorkSpaceController &#123;

    @Autowired
    private WorkspaceService workspaceService;

    /**
     * 工作台今日数据查询
     * @return
     */
    @GetMapping(&quot;/businessData&quot;)
    @ApiOperation(&quot;工作台今日数据查询&quot;)
    public Result&lt;BusinessDataVO&gt; businessData()&#123;
        //获得当天的开始时间
        LocalDateTime begin = LocalDateTime.now().with(LocalTime.MIN);
        //获得当天的结束时间
        LocalDateTime end = LocalDateTime.now().with(LocalTime.MAX);

        BusinessDataVO businessDataVO = workspaceService.getBusinessData(begin, end);
        return Result.success(businessDataVO);
    &#125;

    /**
     * 查询订单管理数据
     * @return
     */
    @GetMapping(&quot;/overviewOrders&quot;)
    @ApiOperation(&quot;查询订单管理数据&quot;)
    public Result&lt;OrderOverViewVO&gt; orderOverView()&#123;
        return Result.success(workspaceService.getOrderOverView());
    &#125;

    /**
     * 查询菜品总览
     * @return
     */
    @GetMapping(&quot;/overviewDishes&quot;)
    @ApiOperation(&quot;查询菜品总览&quot;)
    public Result&lt;DishOverViewVO&gt; dishOverView()&#123;
        return Result.success(workspaceService.getDishOverView());
    &#125;

    /**
     * 查询套餐总览
     * @return
     */
    @GetMapping(&quot;/overviewSetmeals&quot;)
    @ApiOperation(&quot;查询套餐总览&quot;)
    public Result&lt;SetmealOverViewVO&gt; setmealOverView()&#123;
        return Result.success(workspaceService.getSetmealOverView());
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/WorkspaceService.java
package com.sky.service;

import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import java.time.LocalDateTime;

public interface WorkspaceService &#123;

    /**
     * 根据时间段统计营业数据
     * @param begin
     * @param end
     * @return
     */
    BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end);

    /**
     * 查询订单管理数据
     * @return
     */
    OrderOverViewVO getOrderOverView();

    /**
     * 查询菜品总览
     * @return
     */
    DishOverViewVO getDishOverView();

    /**
     * 查询套餐总览
     * @return
     */
    SetmealOverViewVO getSetmealOverView();

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/WorkspaceServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.StatusConstant;
import com.sky.entity.Orders;
import com.sky.mapper.DishMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.mapper.UserMapper;
import com.sky.service.WorkspaceService;
import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class WorkspaceServiceImpl implements WorkspaceService &#123;

    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private UserMapper userMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 根据时间段统计营业数据
     * @param begin
     * @param end
     * @return
     */
    public BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end) &#123;
        /**
         * 营业额：当日已完成订单的总金额
         * 有效订单：当日已完成订单的数量
         * 订单完成率：有效订单数 / 总订单数
         * 平均客单价：营业额 / 有效订单数
         * 新增用户：当日新增用户的数量
         */

        Map map = new HashMap();
        map.put(&quot;begin&quot;,begin);
        map.put(&quot;end&quot;,end);

        //查询总订单数
        Integer totalOrderCount = orderMapper.countByMap(map);

        map.put(&quot;status&quot;, Orders.COMPLETED);
        //营业额
        Double turnover = orderMapper.sumByMap(map);
        turnover = turnover == null? 0.0 : turnover;

        //有效订单数
        Integer validOrderCount = orderMapper.countByMap(map);

        Double unitPrice = 0.0;

        Double orderCompletionRate = 0.0;
        if(totalOrderCount != 0 &amp;&amp; validOrderCount != 0)&#123;
            //订单完成率
            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
            //平均客单价
            unitPrice = turnover / validOrderCount;
        &#125;

        //新增用户数
        Integer newUsers = userMapper.countByMap(map);

        return BusinessDataVO.builder()
                .turnover(turnover)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .unitPrice(unitPrice)
                .newUsers(newUsers)
                .build();
    &#125;


    /**
     * 查询订单管理数据
     *
     * @return
     */
    public OrderOverViewVO getOrderOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;begin&quot;, LocalDateTime.now().with(LocalTime.MIN));
        map.put(&quot;status&quot;, Orders.TO_BE_CONFIRMED);

        //待接单
        Integer waitingOrders = orderMapper.countByMap(map);

        //待派送
        map.put(&quot;status&quot;, Orders.CONFIRMED);
        Integer deliveredOrders = orderMapper.countByMap(map);

        //已完成
        map.put(&quot;status&quot;, Orders.COMPLETED);
        Integer completedOrders = orderMapper.countByMap(map);

        //已取消
        map.put(&quot;status&quot;, Orders.CANCELLED);
        Integer cancelledOrders = orderMapper.countByMap(map);

        //全部订单
        map.put(&quot;status&quot;, null);
        Integer allOrders = orderMapper.countByMap(map);

        return OrderOverViewVO.builder()
                .waitingOrders(waitingOrders)
                .deliveredOrders(deliveredOrders)
                .completedOrders(completedOrders)
                .cancelledOrders(cancelledOrders)
                .allOrders(allOrders)
                .build();
    &#125;

    /**
     * 查询菜品总览
     *
     * @return
     */
    public DishOverViewVO getDishOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;status&quot;, StatusConstant.ENABLE);
        Integer sold = dishMapper.countByMap(map);

        map.put(&quot;status&quot;, StatusConstant.DISABLE);
        Integer discontinued = dishMapper.countByMap(map);

        return DishOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    &#125;

    /**
     * 查询套餐总览
     *
     * @return
     */
    public SetmealOverViewVO getSetmealOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;status&quot;, StatusConstant.ENABLE);
        Integer sold = setmealMapper.countByMap(map);

        map.put(&quot;status&quot;, StatusConstant.DISABLE);
        Integer discontinued = setmealMapper.countByMap(map);

        return SetmealOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 根据条件统计菜品数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="java">sky-server  mapper/DishMapper.xml
&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from dish
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
/**
     * 根据条件统计套餐数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="java">sky-server  mapper/SetmealMapper.xml
&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from setmeal
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<h3 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h3><h6 id="在Java中操控Excel文件-读写操作"><a href="#在Java中操控Excel文件-读写操作" class="headerlink" title="在Java中操控Excel文件 [读写操作]"></a>在Java中操控Excel文件 [读写操作]</h6><p>Apache POI 是一个处理Miscrosoft Office各种文件格式的开源项目，POI都是用于操作Excel文件</p>
<h6 id="Apache-POI应用场景："><a href="#Apache-POI应用场景：" class="headerlink" title="Apache POI应用场景："></a>Apache POI应用场景：</h6><ul>
<li><strong>银行网银系统</strong>导出交易明细</li>
<li>各种业务系统到出Excel报表</li>
<li>批量导入业务数据</li>
</ul>
<pre><code class="java">sky-server  com/sky/test/POITest.java
package com.sky.test;

import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

public class POITest &#123;
    /**
     * 通过POI创建Excel文件并且写入文件内容
     */
    public static void write() throws Exception &#123;
        // 在内存中创建一个Excel文件
        XSSFWorkbook excel = new XSSFWorkbook();
        // 在Excel文件中创建一个sheet页
        XSSFSheet sheet = excel.createSheet(&quot;info&quot;);
        // 在Sheet中创建行对象, rownum编号从0开始
        XSSFRow row = sheet.createRow(1);
        // 创建单元格并写入文件内容
        row.createCell(1).setCellValue(&quot;姓名&quot;);
        row.createCell(2).setCellValue(&quot;城市&quot;);

        // 创建一个新行
        row = sheet.createRow(2);
        row.createCell(1).setCellValue(&quot;张三&quot;);
        row.createCell(2).setCellValue(&quot;北京&quot;);

        row = sheet.createRow(3);
        row.createCell(1).setCellValue(&quot;李四&quot;);
        row.createCell(2).setCellValue(&quot;南京&quot;);

        // 通过输出流将内存中的Excel文件写入到磁盘
        FileOutputStream out = new FileOutputStream(new File(&quot;C:\\Users\\Pluminary\\Desktop\\itcast.xlsx&quot;));
        excel.write(out);

        // 关闭资源
        out.close();
        excel.close();
    &#125;

    public static void main(String[] args) throws Exception &#123;
        write();
    &#125;
&#125;
</code></pre>
<h3 id="导出运营数据Excel报表"><a href="#导出运营数据Excel报表" class="headerlink" title="导出运营数据Excel报表"></a>导出运营数据Excel报表</h3><h6 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h6><ul>
<li>设计Excel模板文件</li>
<li>查询近30天的运营数据</li>
<li>将查询到的运营数据写入模板文件</li>
<li>通过输出流将Excel文件下载到客户端浏览器</li>
</ul>
<pre><code class="java">sky-pojo  com/sky/vo/BusinessDataVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 数据概览
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BusinessDataVO implements Serializable &#123;

    private Double turnover;//营业额

    private Integer validOrderCount;//有效订单数

    private Double orderCompletionRate;//订单完成率

    private Double unitPrice;//平均客单价

    private Integer newUsers;//新增用户数

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
/**
     * 导出运营数据报表
     * @param response
     */
    @GetMapping(&quot;/export&quot;)
    @ApiOperation(&quot;导出运营数据报表&quot;)
    public void export(HttpServletResponse response) &#123;
        reportService.exportBusinessData(response);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
 /**
     * 导出运营数据报表
     * @param response
     */
    void exportBusinessData(HttpServletResponse response);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
/**
     * 导出运营数据报表
     * @param response
     */
    @Override
    public void exportBusinessData(HttpServletResponse response) &#123;
        // 查询数据库 获取营业数据 -- 查询最近30天的营业数据
        LocalDate dateBegin = LocalDate.now().minusDays(30);
        LocalDate dateEnd = LocalDate.now().minusDays(1);
        // 查询概览数据
        BusinessDataVO businessDataVO = workspaceService.getBusinessData(LocalDateTime.of(dateBegin, LocalTime.MIN),LocalDateTime.of(dateEnd, LocalTime.MAX));

        // 查询的数据通过POI写入Excel文件中 (获得对象 获得类加载器 类加载器读取资源)
        InputStream in = this.getClass().getClassLoader().getResourceAsStream(&quot;template/运营数据报表模板.xlsx&quot;);
        try &#123;
            // 基于模板文件创建一个新的Excel文件
            XSSFWorkbook excel = new XSSFWorkbook();

            // 填充数据 [获取标签页]

            XSSFSheet sheet = excel.getSheet(&quot;Sheet1&quot;);
            // 获取第二行[索引是从0开始]
            sheet.getRow(1).createCell(1).setCellValue(&quot;时间：&quot; + dateBegin + &quot;至&quot; + dateEnd);

            // 获得第四行
            XSSFRow row = sheet.getRow(3);
            row.getCell(2).setCellValue(businessDataVO.getTurnover());//营业额
            row.getCell(4).setCellValue(businessDataVO.getOrderCompletionRate());//订单完成率
            row.getCell(6).setCellValue(businessDataVO.getNewUsers());//新增用户数

            // 获得第五行
            row = sheet.getRow(4);
            row.getCell(2).setCellValue(businessDataVO.getValidOrderCount());//有效订单数
            row.getCell(4).setCellValue(businessDataVO.getUnitPrice());//平均单品价格

            // 填充明细数据
            for (int i = 0; i &lt; 30; i++) &#123;
                LocalDate date = dateBegin.plusDays(i);
                // 查询某一天的营业数据
                workspaceService.getBusinessData(LocalDateTime.of(date, LocalTime.MIN), LocalDateTime.of(date, LocalTime.MAX));
                // 获得某一行
                row = sheet.getRow(7 + i);// 利用循环 超越循环
                row.getCell(1).setCellValue(date.toString());
                row.getCell(2).setCellValue(businessDataVO.getTurnover());
                row.getCell(3).setCellValue(businessDataVO.getValidOrderCount());
                row.getCell(6).setCellValue(businessDataVO.getOrderCompletionRate());
                row.getCell(4).setCellValue(businessDataVO.getUnitPrice());
                row.getCell(5).setCellValue(businessDataVO.getNewUsers());
            &#125;

            // 通过输出流将Excel文件下载到客户端浏览器
            ServletOutputStream out = response.getOutputStream();
            excel.write(out);

            // 关闭资源
            out.close();
            excel.close();
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/09/28/后端/苍穹外卖/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/07/03/前端/Vue/">
        <h2>
            Vue
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/7/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Vue快速入门"><a href="#Vue快速入门" class="headerlink" title="Vue快速入门"></a>Vue快速入门</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>MVVM</strong>响应式编程模型，避免直接操作<strong>DOM</strong>，降低<strong>DOM</strong>操作的复杂性</p>
<p>安装Vscode 安装nodejs<br>检测是否安装成功 <code>cmd →  node -v  →  npm -v</code></p>
<h6 id="npm设置镜像-cmd"><a href="#npm设置镜像-cmd" class="headerlink" title="npm设置镜像[cmd]"></a>npm设置镜像[cmd]</h6><pre><code class="java">C:\Users\Pluminary&gt;npm config set registry https://registry.npmmirror.com
C:\Users\Pluminary&gt;npm config ls
C:\Users\Pluminary&gt;npm config get registry
</code></pre>
<pre><code class="java">在Vscode里的终端输入 
PS C:\Users\Pluminary\Desktop\vue2&gt; npm init -y
PS C:\Users\Pluminary\Desktop\vue2&gt; npm install vue
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/c327127960/article/details/108853046">Vue Chrome调试工具 Vue.js devtools 5.3.3 安装包及教程_vuedevtool.crx百度网盘-CSDN博客</a></p>
<h4 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h4><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 这个就没有被挂载--&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;!--在对话框里输入的时候改变下面的次数--&gt;
        &lt;button v-on:click=&quot;num++&quot;&gt;登录&lt;/button&gt; &lt;!--实现当点击按钮的时候num数值++--&gt;
        &lt;button v-on:click=&quot;loginout()&quot;&gt;登出&lt;/button&gt;
        &lt;h1&gt;&#123;&#123;name&#125;&#125;, 欢迎您,当前登录第&#123;&#123;num&#125;&#125;次,当前登录时间：&#123;&#123;nowDate()&#125;&#125;&lt;/h1&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;

    &lt;script&gt;
        // 1. new vue实例 每个Vue应用都是通过Vue函数创建一个新的Vue实例开始的
        new Vue(&#123;
            el:&quot;#app&quot;, // 挂载的模板
            data()&#123; // 绑定的数据 把data对象中的所有属性 加到相应视图里
                return&#123;
                    name : &quot;图灵学院&quot;,
                    num:1
                &#125;
            &#125;,
            methods: &#123;
                nowDate()&#123;
                    return new Date().toLocaleDateString()
                &#125;,
                loginout()&#123;
                    this.num--; //当调用实例时要加this
                &#125;
            &#125;,
        &#125;);
        // 双向绑定：数据发生改变 视图也要随之改变；在谷歌浏览器的Vue调试中
        // 指令：简化对Dom的频繁操作
        // 方法：声明方法可以实现更复杂的操作，声明methods属性中
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-text、v-html"><a href="#指令-v-text、v-html" class="headerlink" title="指令 v-text、v-html"></a>指令 v-text、v-html</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div v-text=&quot;message&quot;&gt;&lt;/div&gt;&#123;&#123;message&#125;&#125;
        &lt;!-- &#123;&#123;&#125;&#125;在网络延迟情况下会出现暂时显示的情况 --&gt;
        &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    // 1.实例Vue
    var vm = new Vue(&#123;
        el:&#39;#app&#39;,
        data:&#123;
            message: &quot;&lt;a href = &#39;#&#39;&gt;Hello&lt;/a&gt;&quot;
        &#125;,
    &#125;)
// v-text 用于绑定数据，语法v-text=&quot;属性&quot;，会直接将值作为文本显示
// v-html 会将值进行编译再显示
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-bind"><a href="#指令-v-bind" class="headerlink" title="指令 v-bind"></a>指令 v-bind</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .red&#123;
            background-color: red;
        &#125; 
        .yellow&#123;
            background-color: yellow;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;    &lt;!--:style=&quot;font-size: &#123;&#123;bigFont&#125;&#125;; 错误写法--&gt;
        &lt;div v-bind:title=&quot;title&quot; :class=&quot;red&quot; :style=&quot;&#123;fontSize:bigFont&#125;&quot;&gt;
            鼠标悬停查看信息！
        &lt;/div&gt;
        &lt;div :class=&quot;&#123;yellow:isyellow&#125;&quot;&gt;
            &lt;a :href=&quot;href&quot; :style=&quot;&#123;fontSize:bigFont&#125;&quot;&gt;图灵学院&lt;/a&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;img :src=&quot;src&quot;/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;button v-bind:disabled=&quot;disabled&quot;&gt;禁用按钮&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue(&#123;
        el: &quot;#app&quot;,
        data:&#123;
            red:&quot;red&quot;,
            isyellow:true,
            bigFont:&quot;50px&quot;,
            title: &quot;您好，本网站可以学到更多的知识&quot;,
            href: &quot;https://www.pronhub.com/&quot;,
            scr: &#39;../Imooc_Cat.jpg&#39;,
            disabled: true
        &#125;
    &#125;)

    // 绑定元素属性 -- v-bind
    // 语法：v-bind:元素属性=&quot;vue的属性&quot;
    // 简写：v-bind:title 简写成 :title
    /*
       针对样式的特殊用法：
         动态控制class是否添加 :class=&quot;&#123;red:isred&#125;&quot;
           语法 &#123;red:isred&#125; : &#123;需要动态控制的class样式:vue的属性(需要是boolean类型)&#125;

         动态设置style的样式   :style=&quot;&#123;fontSize:bigFont&#125;&quot;
           语法 &#123;fontSize: bigFont&#125; : &#123;css样式的驼峰命名方法:&#125; font-size=fontSize
    */
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-model"><a href="#指令-v-model" class="headerlink" title="指令 v-model"></a>指令 v-model</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;
            &lt;label&gt;年龄：&lt;/label&gt;
            &lt;input v-model=&quot;age&quot;/&gt;
        &lt;/div&gt;
        &lt;div&gt;当前输入的年龄是：&#123;&#123;age&#125;&#125;&lt;/div&gt;
        &lt;button @click=&quot;add&quot;&gt;加一岁&lt;/button&gt; &lt;!--  @click = v-on:click  --&gt;
        &lt;button @click=&quot;alertYear&quot;&gt;弹出年龄&lt;/button&gt;

    &lt;hr&gt;
        &lt;label&gt;课程：&lt;/label&gt;
        &lt;select v-model=&quot;course&quot;&gt;
            &lt;option value=&quot;javascript&quot;&gt;javascript&lt;/option&gt;
            &lt;option value=&quot;java&quot;&gt;java&lt;/option&gt;
            &lt;option value=&quot;c++&quot;&gt;c++&lt;/option&gt;
        &lt;/select&gt;

        &lt;div&gt;
            &lt;input v-model=&quot;course&quot; type=&quot;radio&quot; name=&quot;course&quot; value=&quot;javascript&quot;&gt;javascript
            &lt;input v-model=&quot;course&quot; type=&quot;radio&quot; name=&quot;course&quot; value=&quot;java&quot;&gt;java
            &lt;input v-model=&quot;course&quot; type=&quot;radio&quot; name=&quot;course&quot; value=&quot;c++&quot;&gt;c++
        &lt;/div&gt;

        &lt;div&gt;当前课程是：&#123;&#123;course&#125;&#125;&lt;/div&gt;
    &lt;/div&gt;
    
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el:&quot;#app&quot;,
    data:&#123;
        age:10,
        course:&#39;java&#39;
    &#125;,
    methods: &#123;
        add()&#123;
            this.age++;
        &#125;,
        alertYear()&#123;
            alert(this.age)
        &#125;
    &#125;
&#125;)

//v-model 用于实现双向绑定 一般用在表单元素
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-on"><a href="#指令-v-on" class="headerlink" title="指令 v-on"></a>指令 v-on</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button v-on:click=&quot;hello(&#39;hello&#39;)&quot;&gt;hello&lt;/button&gt;
        &lt;button @click=&quot;hello(&#39;world&#39;)&quot;&gt;world&lt;/button&gt;
        &lt;button @click=&quot;num++&quot;&gt;数据：&lt;/button&gt;&#123;&#123;num&#125;&#125;
&lt;!-- 不让事件传播 禁止默认a标签事件 
 @click.stop 不让事件传播
 @click.self 需要自己点击[不会参与传播]
 @click.prevent 组织默认事件
 @click.once 事件只会触发一次
 --&gt;
        &lt;div @click=&quot;hello(1)&quot; style=&quot;background-color: red; width: 800px; height: 500px;padding: 50px;&quot;&gt;
            1
            &lt;div @click.stop=&quot;hello(2)&quot; style=&quot;background-color: blue; width: 400px; height: 200px;padding: 50px;&quot;&gt;
                2
                &lt;a @click.stop.prevent=&quot;hello(3)&quot; style=&quot;background-color: yellow; width: 200px; height: 100px; display: block;padding: 50px;&quot; href=&quot;www.baidu.com&quot;&gt;3&lt;/a&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;input v-on:keyup.enter=&quot;hello(&#39;enter&#39;)&quot;&gt; &lt;!--键盘按回车触发--&gt;&lt;br&gt;
        &lt;input v-on:keyup.space=&quot;hello(&#39;enter&#39;)&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue(&#123;
        el: &quot;#app&quot;,
        data:&#123;
            num: 0
        &#125;,
        methods: &#123;
            hello(str)&#123;
                alert(str)
            &#125;
        &#125;
    &#125;)

/*
 v-on用于绑定事件
 语法  v-on:事件名
 简写方式 v-on:click =&gt; @click
 只能调用vue中的函数和数据
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-for"><a href="#指令-v-for" class="headerlink" title="指令 v-for"></a>指令 v-for</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        循环数组
        &lt;ul&gt;
            &lt;li v-for=&quot;(item, index) in music&quot;&gt;&#123;&#123;item.name&#125;&#125;---&#123;&#123;index+1&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
        循环对象
        &lt;ul&gt;
            &lt;li v-for=&quot;(item, index) in obj&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el: &#39;#app&#39;,
    data:&#123;
        // 要循环的数组
        music:[
            &#123;name: &#39;青花瓷&#39;&#125;,
            &#123;name: &#39;阳光总在风雨后&#39;&#125;,
            &#123;name: &#39;十年&#39;&#125;
        ],
        // 要循环的对象
        obj:&#123;
            name: &#39;句号&#39;,
            age: 18,
            sex: &#39;男&#39;
        &#125;
    &#125;
&#125;)
/*
v-for循环，可以循环数组和对象
v-for=&quot;(item, index) in intems
语法：v-for=&quot;(每次循环接收的变量, 当前循环的索引) in 需要循环的变量&quot;
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-if-与-v-show"><a href="#指令-v-if-与-v-show" class="headerlink" title="指令 v-if 与 v-show"></a>指令 v-if 与 v-show</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button @click=&quot;vif=!vif&quot;&gt;切换显示隐藏&lt;/button&gt;
        &lt;div v-if=&quot;vif&quot; style=&quot;background-color: red; width: 200px; height: 200px;&quot;&gt;
            v-if
        &lt;/div&gt;
        &lt;hr&gt;
        &lt;button @click=&quot;vshow=!vshow&quot;&gt;切换显示隐藏&lt;/button&gt;
        &lt;div v-show=&quot;vshow&quot; style=&quot;background-color: yellow; width: 200px; height: 200px;&quot;&gt;
            v-show
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el: &quot;#app&quot;,
    data:&#123;
        vif: true,
        vshow: true
    &#125;
&#125;)
/*
    v-if 和 v-show 用于控制元素显示隐藏
    语法 v-if = &quot;指定Boolean值&quot; v-show一样
    
    v-if 控制元素是否生成
    v-show 控制元素是否显示隐藏
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-else-与-v-else-if"><a href="#指令-v-else-与-v-else-if" class="headerlink" title="指令 v-else 与 v-else-if"></a>指令 v-else 与 v-else-if</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div v-if=&quot;number == 1&quot;&gt;
            A
        &lt;/div&gt;
        &lt;div v-else-if=&quot;number == 2&quot;&gt;
            B
        &lt;/div&gt;
        &lt;div v-else&gt;
            C
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el: &#39;#app&#39;,
    data() &#123;
        return &#123;
            number: 1
        &#125;
    &#125;,
&#125;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;计算属性和侦听器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 实现一个购物车功能 
            1. 数据初始化处理
            2. 选择商品数量：当商品数量超过库存做提示
            3. 计算商品总价
        --&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;(item, index) in car&quot;&gt;
                &#123;&#123;item.pname&#125;&#125; --- 商品价格：&#123;&#123;item.price&#125;&#125; --- 库存：&#123;&#123;item.stock&#125;&#125;
                数量：&lt;input type=&quot;number&quot; v-model=&quot;item.num&quot; style=&quot;width: 30px;&quot;/&gt;
            &lt;/li&gt;
            &lt;li&gt;&lt;strong&gt;总价：&lt;/strong&gt;&#123;&#123;calcSum&#125;&#125;&lt;/li&gt;
            &lt;!-- &lt;li v-html=&quot;warn()&quot;&gt;&lt;/li&gt; --&gt;
            &lt;li v-html=&quot;message&quot;&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
 new Vue(&#123;
    el:&quot;#app&quot;,
    data:&#123;
        car:[
            &#123;pname:&#39;IPhone 12&#39;,price:10000,stock:10,num:1&#125;,
            &#123;pname:&#39;Mate40 pro&#39;,price:7000,stock:3,num:1&#125;,
        ],
        message:&quot;&quot;,
    &#125;,
    // methods：当方法中的数据发生改变，方法会自动调用 所以当数量增加时会自动计算总价
    methods: &#123;
        // calcSum()&#123;
        //     let sum=0;
        //     this.car.forEach(item =&gt; &#123;
        //         sum+=item.price*item.num;
        //     &#125;);
        //     return sum;
        // &#125;

        // warn()&#123;
        //     let message=&quot;&quot;;
        //     this.car.forEach(item =&gt; &#123;
        //         if(item.num&gt;item.stock)&#123;
        //             message+=`$&#123;item.pname&#125;的库存超出限制&lt;br/&gt;`
        //         &#125;
        //     &#125;);
        //     return message;
        // &#125;
    &#125;,
    // 计算属性 上面就不加大括号  &lt;li&gt;&lt;strong&gt;总价：&lt;/strong&gt;&#123;&#123;calcSum&#125;&#125;&lt;/li&gt;
    computed:&#123;
        calcSum()&#123;
            let sum=0;
            this.car.forEach(item =&gt; &#123;
                sum+=item.price*item.num;
            &#125;);
            return sum;
        &#125;
    &#125;,
    // 侦听器 专门用于侦听某些数据的变化，当数据发生变化会自动调节方法 不能像方法那样调用
    watch:&#123;
        // 要侦听的数据 
        car:&#123;
            handler(newvalue,oldvalue)&#123;
                this.message=&quot;&quot;;
                this.car.forEach(item =&gt; &#123;
                    if(item.num&gt;item.stock)&#123;
                        this.message+=`$&#123;item.pname&#125;的库存超出限制&lt;br/&gt;`
                    &#125;
                &#125;);
            &#125;,
            deep:true
        &#125;,
        //侦听message 基础类型的侦听 将侦听数据作为函数就可以了
        message(newvalue,oldvalue)&#123;
            console.info(newvalue,oldvalue)
        &#125;
    &#125;
 &#125;);
 /*
    方法和计算属性的区别：
    声明方式不一样，调用不一样方法要用&quot;()&quot;, 计算属性调用不要加&quot;()&quot;
 */
/*
    方法和侦听器的区别：
        方法：方法中任意数据发生改变了就会自动调用方法 
            可以调用，进行返回值

        侦听器：需要指定具体的侦听数据，只有被具体指定的侦听数据发生了改变才会触发
            不能像方法那样去调用，而是靠vue自动触发 如果初始情况就数量就大于库存是不改变的
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;过滤器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    

    &lt;div id=&quot;app&quot;&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;user in userList&quot;&gt;
                姓名：&#123;&#123;user.name&#125;&#125;; 性别：&#123;&#123;user.gender==1?"男":"女"&#125;&#125;
                &#123;&#123;user.gender | filterGender&#125;&#125;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    let vm = new Vue(&#123;
        el: &quot;#app&quot;,
        data:&#123;
            userList:[
                &#123;id:1, name:&#39;xushu&#39;, gender:1&#125;,
                &#123;id:2, name:&#39;zhuge&#39;, gender:0&#125;
            ]
        &#125;,
        //针对数据过滤的
        methods:&#123;
            formateGender(gender)&#123;
                if(gender==1)&#123;
                    return &quot;~男&quot;
                &#125;else&#123;
                    return &quot;~女&quot;
                &#125;
            &#125;
        &#125;,
        filters:&#123;
            filterGender(gender)&#123;
                if(gender==1)&#123;
                    return &quot;!男&quot;
                &#125;else&#123;
                    return &quot;!女&quot;
                &#125;
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Vue-组件化"><a href="#Vue-组件化" class="headerlink" title="Vue-组件化"></a>Vue-组件化</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;组件化&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- &lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; --&gt;
        &lt;!-- &lt;xushu&gt;&lt;/xushu&gt; --&gt;
        &lt;xushu :num=&quot;numxx&quot;&gt;&lt;/xushu&gt; &lt;!--传递属性--&gt;  &lt;!--输出50--&gt;
        &lt;app-xushu&gt;&lt;/app-xushu&gt; &lt;!--输出66--&gt;
    &lt;/div&gt;

    &lt;div id=&quot;app2&quot;&gt;
        &lt;!-- &lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; --&gt;
        &lt;!-- &lt;xushu&gt;&lt;/xushu&gt; --&gt;
        &lt;xushu :num=&quot;numxx&quot;&gt;&lt;/xushu&gt; &lt;!--传递属性--&gt; &lt;!--输出100--&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // 1.全局组件 在所有的Vue实例中使用
        /*
            1.1 命名：不要使用驼峰命名法 可以用中划线命名
            1.2 模板：必须的
            1.3 数据：一定要函数的方式声明
        */
        Vue.component(&quot;xushu&quot;, &#123;
            template: `&lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;`,
            //1.在自己的字方法中声明  
            // data() &#123;
            //     return &#123;
            //         num:10
            //     &#125;
            // &#125;,

            //2.在下方父方法中声明并传递过来
            props: [&quot;num&quot;]
        &#125;);

        // 2.局部组件 //自己定义下面引用
        const appXushu = &#123;
            template: `&lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;`,
            data() &#123;
                return &#123;
                    num: 66
                &#125;
            &#125;
        &#125;;

        new Vue(&#123;
            el: &quot;#app&quot;,
            data: &#123;
                numxx: 50
            &#125;,
            components: &#123;
                &quot;app-xushu&quot;: appXushu
            &#125;
        &#125;);

        new Vue(&#123;
            el: &quot;#app2&quot;,
            data: &#123;
                numxx: 100
            &#125;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="生命周期和钩子函数"><a href="#生命周期和钩子函数" class="headerlink" title="生命周期和钩子函数"></a>生命周期和钩子函数</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;span id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;
        &lt;button @click=&quot;updateName&quot;&gt;更新&lt;/button&gt;
        &lt;button @click=&quot;destroyInstance&quot;&gt;销毁&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue(&#123;
        el: &#39;#app&#39;,
        data:&#123;
            name: &#39;hello !&#39;
        &#125;,
        methods: &#123;
            updateName()&#123;
                console.log(&#39;准备改名字啦！&#39;)
                this.name = &#39;hello 图灵！&#39;
            &#125;,
            destroyInstance()&#123;
                console.log(&#39;销毁实例&#39;)
                vm.$destroy()
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><pre><code class="vue">npm install vue-router@3
npm install vue-router@3 --legacy-peer-deps

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;!-- 1.安装vue-router路由
     2.引入vue-router文件
     3.根据不同url连接到不同的页面，需要使用模板实现，将模板绑定对应的路由地址
--&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;nav&gt;
            &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;
            &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
        &lt;/nav&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-router@3.5.1/dist/vue-router.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
                // 定义组件：原本应该是在外面定义HomeComponent.vue [创建一些组件]
        const HomeComponent = &#123;
            template: `&lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;p&gt;Welcome to the Home page!&lt;/p&gt;&lt;/div&gt;`
        &#125;;
              // 定义组件：原本应该是在外面定义AboutComponent.vue [创建一些组件]
        const AboutComponent = &#123;
            template: `&lt;div&gt;&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;Learn more about us on this page.&lt;/p&gt;&lt;/div&gt;`
        &#125;;

        // 定义路由：原本应该是外面定义router.js文件来定义路由。
        const routes = [
            &#123; path: &#39;/&#39;, component: HomeComponent &#125;,
            &#123; path: &#39;/about&#39;, component: AboutComponent &#125;
        ];

        // 创建路由实例
        const router = new VueRouter(&#123;
            routes
        &#125;);

        // 创建并挂载根实例
        const app = new Vue(&#123;
            router// 挂载路由
        &#125;).$mount(&#39;#app&#39;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Vue with Axios Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h1&gt;Data from API&lt;/h1&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;post in posts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/li&gt;
        &lt;!-- 使用 Vue 的 v-for 指令遍历 posts 数组，并生成列表项，每个列表项显示 post.title。 --&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;!-- 引入 Vue.js --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 引入 Axios --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // 创建 Vue 实例
        let vm = new Vue(&#123;
            el: &quot;#app&quot;, // Vue 实例绑定到 HTML 中的 id=&quot;app&quot; 的元素
            data: &#123;
                posts: [] // 初始化一个空数组用于存储从 API 获取的数据
            &#125;,
            created() &#123;
                // Vue 实例创建时调用的生命周期钩子
                axios.get(&#39;https://jsonplaceholder.typicode.com/posts&#39;) // 使用 Axios 发送 GET 请求
                    .then(response =&gt; &#123; // 请求成功后的处理
                        this.posts = response.data; // 将响应数据赋值给 posts 数组
                    &#125;)
                    .catch(error =&gt; &#123; // 请求失败后的处理
                        console.error(&#39;Error fetching data:&#39;, error); // 输出错误信息到控制台
                    &#125;);
            &#125;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h3><h5 id="CLI文档，开箱即用！"><a href="#CLI文档，开箱即用！" class="headerlink" title="CLI文档，开箱即用！"></a>CLI文档，开箱即用！</h5><pre><code class="vue">cmd全局安装：
npm install -g @vue/cli         或者
npm install -g @vue/cli-init

去想要的文件夹里面：C:\Users\Pluminary\Desktop\vue_cli&gt;vue init webpack tuling
vue init webpack 项目名

? Project name tuling
? Project description A Vue.js project
? Author pcy
? Vue build standalone
? Install vue-router? Yes
? Use ESLint to lint your code? No //严格检验Javascript语法的
? Set up unit tests No
? Setup e2e tests with Nightwatch? No
? Should we run `npm install` for you after the project has been created? (recommended) npm

完成后需要开启：
cd tuling
npm run dev

DONE  Compiled successfully in 1780ms 18:41:21
I  Your application is running here: http://localhost:8080
</code></pre>
<h3 id="运用element-ui创建一个简易的登录界面"><a href="#运用element-ui创建一个简易的登录界面" class="headerlink" title="运用element-ui创建一个简易的登录界面"></a>运用element-ui创建一个简易的登录界面</h3><pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;hello-world&quot;&gt;
    &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;showAlert&quot;&gt;Click Me&lt;/el-button&gt;
  &lt;/div&gt;

  &lt;div class=&quot;app&quot;&gt;
    &lt;h3&gt;&#123;&#123;passage&#125;&#125;&lt;/h3&gt;
    &lt;h4&gt;&#123;&#123;getVal()&#125;&#125;&lt;/h4&gt;
  &lt;/div&gt;

   &lt;!-- 使用Element UI的Table组件展示empList --&gt;
  &lt;el-table :data=&quot;empList&quot; style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column prop=&quot;name&quot; label=&quot;Name&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;salary&quot; label=&quot;Salary&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;
  &lt;/el-table&gt;

   &lt;!-- 登录表单 --&gt;
  &lt;el-form ref=&quot;loginForm&quot; :model=&quot;loginForm&quot; class=&quot;loginForm&quot; label-width=&quot;80px&quot;&gt;
    &lt;h2 class=&quot;loginTitle&quot;&gt;人事后台管理系统&lt;/h2&gt;
    &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;
      &lt;el-input v-model=&quot;loginForm.username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;
      &lt;el-input v-model=&quot;loginForm.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item label=&quot;验证码&quot; prop=&quot;code&quot;&gt;
      &lt;el-input v-model=&quot;loginForm.code&quot; placeholder=&quot;请输入验证码&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item style=&quot;width:100%;&quot;&gt;
      &lt;el-button type=&quot;primary&quot; @click=&quot;handleLogin&quot;&gt;登录&lt;/el-button&gt;
    &lt;/el-form-item&gt;
  &lt;/el-form&gt;
   

&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    name: &#39;app&#39;,
    data()&#123;
      return&#123;
        passage: &#39;Oh?&#39;,
        message: &#39;Hello World!&#39;,
        empList:[
          &#123; name: &#39;Peter&#39;, salary: &#39;20000&#39; &#125;,
          &#123; name: &#39;Mike&#39;, salary: &#39;16000&#39; &#125;,
          &#123; name: &#39;Tom&#39;, salary: &#39;17000&#39; &#125;
        ],
        loginForm:&#123;
          username:&#39;&#39;,
          password:&#39;&#39;,
          code:&#39;&#39;
        &#125;
      &#125;
    &#125;,
    methods: &#123;
      showAlert() &#123;
        this.$message(&#123;
          message: &#39;Hello from Element UI!&#39;,
          type: &#39;success&#39;
        &#125;);
      &#125;,
      getVal:function()&#123;
        return &quot;getVal的方法&quot;;
      &#125;,
      handleLogin() &#123;
      this.$message(&#123;
        message: `登录成功，用户名: $&#123;this.loginForm.username&#125;`,
        type: &#39;success&#39;
      &#125;);
     &#125;
    &#125;
  &#125;

&lt;/script&gt;

&lt;style scoped&gt;
    .hello-world &#123;
      text-align: center;
      margin-top: 20px;
    &#125;

    h1 &#123;
      font-size: 24px;
      margin-bottom: 20px;
    &#125;
    .app &#123;
      margin-top: 30px;
    &#125;
&lt;/style&gt;
</code></pre>
<pre><code class="java">在Vue项目中，Element UI需要正确引入CSS样式和JavaScript文件才能正常工作。如果你没有一个HTML模板文件（例如index.html），而是在Vue组件中直接编写代码，你需要通过一些方式来确保Element UI的样式和脚本被正确加载。

// 1. 创建index.html文件：
这个index.html文件通常放在public文件夹下，是你Vue应用的入口文件。Vue CLI自动生成的项目通常会有这个文件。

// 2. 为什么需要这个HTML文件？
这个index.html文件是Vue CLI或手动设置的Vue项目的入口页面。当你运行npm run serve时，Vue CLI会将所有内容注入到&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;中，这个HTML文件是项目的基本框架。

Element UI的CSS和JS资源：需要在HTML文件的&lt;head&gt;中引入Element UI的样式文件（CSS）和在&lt;body&gt;中引入JS库，这样才能确保Element UI组件在你的Vue组件中正确渲染和运行。
    
// 3. 直接在Vue组件中引入：
如果你不想使用外部HTML文件，Vue项目中可以直接在main.js中引入Element UI的样式和组件：
/*
    // main.js
    import Vue from &#39;vue&#39;;
    import App from &#39;./App.vue&#39;;
    import ElementUI from &#39;element-ui&#39;;
    import &#39;element-ui/lib/theme-chalk/index.css&#39;;

    Vue.config.productionTip = false;

    Vue.use(ElementUI);

    new Vue(&#123;
      render: h =&gt; h(App),
    &#125;).$mount(&#39;#app&#39;);
*/
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/前端" style=color:#879cff>
                前端
            </a>
        </span>
        
    </div>

    <a href="/2024/07/03/前端/Vue/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/05/12/后端/Cloud分布式微服务打造大型自媒体3大业务平台/">
        <h2>
            Cloud分布式微服务打造大型自媒体3大业务平台
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/5/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="自媒体项目"><a href="#自媒体项目" class="headerlink" title="自媒体项目"></a>自媒体项目</h1><h6 id="VM-CentOS7：数据库密码→Panchunyao123"><a href="#VM-CentOS7：数据库密码→Panchunyao123" class="headerlink" title="VM CentOS7：数据库密码→Panchunyao123!"></a>VM CentOS7：数据库密码→Panchunyao123!</h6><h5 id="开发思维与企业一致"><a href="#开发思维与企业一致" class="headerlink" title="开发思维与企业一致"></a>开发思维与企业一致</h5><ul>
<li>三端融合：门户+媒体+运营</li>
<li>4g自媒体辉煌时代</li>
<li>5g科技互联网风口</li>
<li>前后端分离式开发、代码动静分离、保证职</li>
<li>能解耦、功能模块互相协调</li>
</ul>
<h5 id="如何整合分布式中间件到项目中"><a href="#如何整合分布式中间件到项目中" class="headerlink" title="如何整合分布式中间件到项目中"></a>如何整合分布式中间件到项目中</h5><ul>
<li>整个流程会做到细致入微</li>
<li>帮助<span style = "color:red"><strong>迅速提升至少2年</strong></span>以上的项目经验</li>
</ul>
<h5 id="重点功能技术分析"><a href="#重点功能技术分析" class="headerlink" title="重点功能技术分析"></a>重点功能技术分析</h5><ul>
<li><strong>Redis</strong>：分布式会话、session共享、单点登录、防刷、计数</li>
<li><strong>Fastdfs+Nginx&#x2F;OSS&#x2F;GridFS</strong>：搭建分布式文件系统、单文件&#x2F;批量上传、人脸隐私保护拦截</li>
<li><strong>Maven</strong>：项目构建、聚合、分层、架构设计、面向对象</li>
<li><strong>阿里AI</strong>：人脸对比、文本&#x2F;图片自动审核、短信</li>
<li><strong>SpringCloud</strong>：业务分而治之、可伸缩、可扩展、接口服务化</li>
<li><strong>Freemarker</strong>：构建模块页，实现页面静态化</li>
</ul>
<h5 id="前置技能必备"><a href="#前置技能必备" class="headerlink" title="前置技能必备"></a>前置技能必备</h5><ul>
<li>Java基础</li>
<li>熟悉MySQL&#x2F;MariaDB</li>
<li>掌握Linux的基本命令</li>
</ul>
<h5 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h5><ul>
<li>前端构建与运行</li>
<li>后端手把手从0到1</li>
<li>中间件手把手部署</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/42c012bc7c8346dbe4070f43c67bfed16904e4a8/data/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%84%E6%9E%B6%E5%9B%BE.jpg" style="zoom: 80%;" />



<h3 id="前后端分离开发模式"><a href="#前后端分离开发模式" class="headerlink" title="前后端分离开发模式"></a>前后端分离开发模式</h3><h5 id="传统JavaWeb开发-与-前后端页面交互"><a href="#传统JavaWeb开发-与-前后端页面交互" class="headerlink" title="传统JavaWeb开发 与 前后端页面交互"></a>传统JavaWeb开发 与 前后端页面交互</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/1e5f4e27bd9ca7bf4ab7d4afebe373a9f06dc735/data/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F.png"></p>
<h3 id="运行前端项目"><a href="#运行前端项目" class="headerlink" title="运行前端项目"></a>运行前端项目</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bugu_hhh/article/details/130625482?ops_request_misc=%7B%22request_id%22:%22171930111016800178595350%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171930111016800178595350&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-130625482-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=linux%E4%B8%8B%E5%AE%89%E8%A3%85mysql&spm=1018.2226.3001.4187">Linux 安装 MySQL【CentOS】_linux 安装mysql-CSDN博客</a></p>
<pre><code class="java">前端代码在压缩包中 启动D:\apache-tomcat-8.5.93\bin\startup.bat
将里面的imooc-news放到D:\apache-tomcat-8.5.93\webapps中
去浏览器中启动 http://localhost:9090/imooc-news/portal/index.html
</code></pre>
<h5 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h5><blockquote>
<p><a target="_blank" rel="noopener" href="https://oldj.github.io/SwitchHosts/">https://oldj.github.io/SwitchHosts/</a><br>在本地把域名和对应的IP給联系绑定起来 [相当于在云服务买了域名后绑定]</p>
<p> #imooc-news 127.0.0.1<br>[这东西需要关闭代理才可以用]</p>
<p>127.0.0.1 <a target="_blank" rel="noopener" href="http://www.imoocnews.com/">www.imoocnews.com</a><br>127.0.0.1 writer.imoocnews.com<br>127.0.0.1 admin.imoocnews.com</p>
<p>127.0.0.1 article.imoocnews.com<br>127.0.0.1 user.imoocnews.com<br>127.0.0.1 files.imoocnews.com</p>
</blockquote>
<h6 id="D-apache-tomcat-8-5-93-webapps-imooc-news-portal-js-app-js"><a href="#D-apache-tomcat-8-5-93-webapps-imooc-news-portal-js-app-js" class="headerlink" title="D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\js\app.js"></a>D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\js\app.js</h6><pre><code class="java">window.app = &#123;
    /* 
    portalIndexUrl: &quot;http://localhost:8080/imooc-news/portal/index.html&quot;,           // 门户首页地址
    writerIndexUrl: &quot;http://localhost:8080/imooc-news/writer/contentMng.html&quot;,      // 作家中心首页
    writerInfoUrl: &quot;http://localhost:8080/imooc-news/writer/accountInfo.html&quot;,     // 用户信息完善页面
    userServerUrl: &quot;http://192.168.1.5:8003&quot;,   // 用户服务后端接口地址
    */

    portalIndexUrl: &quot;http://www.imoocnews.com:9090/imooc-news/portal/index.html&quot;,           // 门户首页地址
    writerLoginUrl: &quot;http://writer.imoocnews.com:9090/imooc-news/writer/passport.html&quot;,      // 登录页面
    writerIndexUrl: &quot;http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html&quot;,      // 作家中心首页
    writerInfoUrl: &quot;http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html&quot;,     // 用户信息完善页面
    adminCenterUrl: &quot;http://admin.imoocnews.com:9090/imooc-news/admin/contentReview.html&quot;,     // 运营管理平台主页

    userServerUrl: &quot;http://user.imoocnews.com:8003&quot;,        // 用户服务后端接口地址
    fsServerUrl: &quot;http://files.imoocnews.com:8004&quot;,         // 文件服务后端接口地址
    adminServerUrl: &quot;http://admin.imoocnews.com:8005&quot;,      // 运营管理服务后端接口地址
    articleServerUrl: &quot;http://article.imoocnews.com:8001&quot;,      // 文章服务后端接口地址

    /**
     * 如果本地使用localhost测试可以不使用，如果是ip或者域名测试，cookieDomain改为对应的ip或者域名
     * 例：
     *    ip：  192.168.1.111
     *    域名：   .imooc.com
     */
    cookieDomain: &quot;.imoocnews.com&quot;,  
    ......
&#125;
</code></pre>
<h3 id="数据库选型与数据导入"><a href="#数据库选型与数据导入" class="headerlink" title="数据库选型与数据导入"></a>数据库选型与数据导入</h3><ul>
<li>MySql 5.6&#x2F;5.7</li>
<li><strong>MariaDB</strong></li>
<li>Mysql 8.0</li>
</ul>
<pre><code class="java">表名                             注释
admin_user                      运营管理平台的admin级别用户    
app_user                      网站用户
article                          文章资讯表
category                      新闻资讯文章的分类(或称之为领域)
comments                      评论表
fans                          粉丝表，用户与粉丝的关联关系，粉丝本质也是用户
</code></pre>
<h3 id="构建Maven聚合工程"><a href="#构建Maven聚合工程" class="headerlink" title="构建Maven聚合工程"></a>构建Maven聚合工程</h3><blockquote>
<p>创建一个 imooc-news-dev 的Maven项目作为一个顶级工程项目</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5fa77f452f8588a132ccd5a461663d1f8cc8b353/data/%E6%9E%84%E5%BB%BAmaven%E8%81%9A%E5%90%88%E5%B7%A5%E7%A8%8B.png"></p>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
&lt;!--
    1.聚合工程可以分为顶级项目(顶级工程,父工程) 与子工程(子modele模块)
      这两者的关系其实就是父子继承关系, 子工程在maven中可以称为module,
      模块与模块之间是平级的,是可以相互依赖的
    2.子模块可以使用顶级工程中所有的资源(依赖), 子模块之间如果有要使用资源的话
      必须构建依赖(构建关系)
    3.一个顶级工程是可以由多个不同的子工程共同组合而成
--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt; &lt;!--SpringBoot是和后续的SpringCLoud版本联系的--&gt;
    &lt;/parent&gt;

    &lt;properties&gt; &lt;!--属性文件参数 如果mysql是8以上 需要修改mysql的版本号--&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;

        &lt;mysql-connector-java.version&gt;8.0.33&lt;/mysql-connector-java.version&gt;
        &lt;mybatis-spring-boot-starter.version&gt;2.1.0&lt;/mybatis-spring-boot-starter.version&gt;
        &lt;mapper-spring-boot-starter.version&gt;2.1.5&lt;/mapper-spring-boot-starter.version&gt;
        &lt;pagehelper-spring-boot-starter.version&gt;1.2.12&lt;/pagehelper-spring-boot-starter.version&gt;

        &lt;okhttp.version&gt;4.2.2&lt;/okhttp.version&gt;
        &lt;jackson.version&gt;2.10.2&lt;/jackson.version&gt;

        &lt;commons-codec.version&gt;1.11&lt;/commons-codec.version&gt;
        &lt;commons-lang3.version&gt;3.4&lt;/commons-lang3.version&gt;
        &lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;
        &lt;google-guava.version&gt;28.2-jre&lt;/google-guava.version&gt;

        &lt;springfox-swagger2.version&gt;2.4.0&lt;/springfox-swagger2.version&gt;
        &lt;swagger-bootstrap-ui.version&gt;1.6&lt;/swagger-bootstrap-ui.version&gt;
        &lt;fastdfs.version&gt;1.27.2&lt;/fastdfs.version&gt;

        &lt;slf4j.version&gt;1.7.21&lt;/slf4j.version&gt;
        &lt;joda-time.version&gt;2.10.6&lt;/joda-time.version&gt;
    &lt;/properties&gt;

    &lt;!--
        使用dependencyManagement的目的是为了保证父工程的干净，
        也就是说父工程他只负责管理依赖，以及依赖的版本，而不会导入额外的jar依赖。
        如此一来父工程的职责就很单一了，而且也符合了面向对象开发的父子继承关系，
        依赖的导入只有在各自的子工程中才会进行导入。
    --&gt;
&lt;!--  ↓ 管理依赖 不会从外网下载具体jar包 只有在后续子模块配置的时候才会去配置
      为了保证父工程的干净,父工程中只负责管理依赖,以及依赖的版本,而不会导入额外的jar依赖
      如此一来父工程的职责就很单一了,而且也符合了面向对象开发的父子继承关系
      依赖的导入只有在各自的子工程中才会导入
 --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- SpringCloud 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR3&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- 引入 mongodb 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
                &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
                &lt;!--mongodb-driver.version--&gt;
                &lt;version&gt;3.11.1&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mysql 驱动  这样引用方便以后jar包依赖的升级--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mybatis --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mybatis-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- 通用mapper逆向工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mapper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--pagehelper --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
                &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;pagehelper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--服务和服务之间的请求--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
                &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
                &lt;version&gt;$&#123;okhttp.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- jackson --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- apache 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-codec&lt;/groupId&gt;
                &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
                &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- google 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
                &lt;artifactId&gt;guava&lt;/artifactId&gt;
                &lt;version&gt;$&#123;google-guava.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- swagger2 配置 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
                &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;swagger-bootstrap-ui.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- 文件上传fdfs工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
                &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
                &lt;version&gt;$&#123;fastdfs.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- joda-time 时间工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;joda-time&lt;/groupId&gt;
                &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
                &lt;version&gt;$&#123;joda-time.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;!-- Java 编译 --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-common"><a href="#imooc-news-dev-common" class="headerlink" title="imooc-news-dev-common"></a>imooc-news-dev-common</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-common:
    通用工程
    包含了一些工具类,枚举类,封装的一些公共方法以及一些第三方组件等
--&gt;
    &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-model"><a href="#imooc-news-dev-model" class="headerlink" title="imooc-news-dev-model"></a>imooc-news-dev-model</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-model
    模型工程, 所有的子工程以及微服务中所涉及到的模型实体类都在此管理
    可以包含一些 *pojo,*Bean,*Entity,vo,bo,dto等
--&gt;

    &lt;artifactId&gt;imooc-news-dev-model&lt;/artifactId&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
&lt;!--  子工程依赖common --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-service-api"><a href="#imooc-news-dev-service-api" class="headerlink" title="imooc-news-dev-service-api"></a>imooc-news-dev-service-api</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;!--    imooc-news-dev-service-api
            接口工程,集中管理所有的controller中的接口,为了更好的统一管理微服务
    --&gt;
    &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-service-user"><a href="#imooc-news-dev-service-user" class="headerlink" title="imooc-news-dev-service-user"></a>imooc-news-dev-service-user</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-user&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--    引入SpringBoot依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-父"><a href="#imooc-news-dev-父" class="headerlink" title="imooc-news-dev [父]"></a>imooc-news-dev [父]</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;modules&gt;
    &lt;!-- 这里是子模块[自动创建] 如果物理删除了子工程 这个不会自动删除的要手动删除--&gt;
        &lt;module&gt;imooc-news-dev-common&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-model&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-service-api&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-service-user&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-service-user&lt;/module&gt;
    &lt;/modules&gt;
    &lt;!--
        1.聚合工程可以分为顶级项目(顶级工程,父工程) 与子工程(子modele模块)
          这两者的关系其实就是父子继承关系, 子工程在maven中可以称为module,
          模块与模块之间是平级的,是可以相互依赖的
        2.子模块可以使用顶级工程中所有的资源(依赖), 子模块之间如果有要使用资源的话
          必须构建依赖(构建关系)
        3.一个顶级工程是可以由多个不同的子工程共同组合而成
    --&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt; &lt;!--SpringBoot是和后续的SpringCLoud版本联系的--&gt;
    &lt;/parent&gt;

    &lt;properties&gt; &lt;!--属性文件参数 如果mysql是8以上 需要修改mysql的版本号--&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;

        &lt;mysql-connector-java.version&gt;8.0.33&lt;/mysql-connector-java.version&gt;
        &lt;mybatis-spring-boot-starter.version&gt;2.1.0&lt;/mybatis-spring-boot-starter.version&gt;
        &lt;mapper-spring-boot-starter.version&gt;2.1.5&lt;/mapper-spring-boot-starter.version&gt;
        &lt;pagehelper-spring-boot-starter.version&gt;1.2.12&lt;/pagehelper-spring-boot-starter.version&gt;

        &lt;okhttp.version&gt;4.2.2&lt;/okhttp.version&gt;
        &lt;jackson.version&gt;2.10.2&lt;/jackson.version&gt;

        &lt;commons-codec.version&gt;1.11&lt;/commons-codec.version&gt;
        &lt;commons-lang3.version&gt;3.4&lt;/commons-lang3.version&gt;
        &lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;
        &lt;google-guava.version&gt;28.2-jre&lt;/google-guava.version&gt;

        &lt;springfox-swagger2.version&gt;2.4.0&lt;/springfox-swagger2.version&gt;
        &lt;swagger-bootstrap-ui.version&gt;1.6&lt;/swagger-bootstrap-ui.version&gt;
        &lt;fastdfs.version&gt;1.27.2&lt;/fastdfs.version&gt;

        &lt;slf4j.version&gt;1.7.21&lt;/slf4j.version&gt;
        &lt;joda-time.version&gt;2.10.6&lt;/joda-time.version&gt;
    &lt;/properties&gt;

    &lt;!--
        使用dependencyManagement的目的是为了保证父工程的干净，
        也就是说父工程他只负责管理依赖，以及依赖的版本，而不会导入额外的jar依赖。
        如此一来父工程的职责就很单一了，而且也符合了面向对象开发的父子继承关系，
        依赖的导入只有在各自的子工程中才会进行导入。
    --&gt;
&lt;!--  ↓ 管理依赖 不会从外网下载具体jar包 只有在后续子模块配置的时候才会去配置
      为了保证父工程的干净,夫工程中只负责管理依赖,以及依赖的版本,而不会导入额外的jar依赖
      如此一来父工程的职责就很单一了,而且也符合了面向对象开发的父子继承关系
      依赖的导入只有在各自的子工程中才会导入
 --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- SpringCloud 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR3&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- 引入 mongodb 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
                &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
                &lt;!--mongodb-driver.version--&gt;
                &lt;version&gt;3.11.1&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- mysql 驱动  这样引用方便以后jar包依赖的升级--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mybatis --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mybatis-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- 通用mapper逆向工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mapper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--pagehelper --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
                &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;pagehelper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--服务和服务之间的请求--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
                &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
                &lt;version&gt;$&#123;okhttp.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- jackson --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- apache 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-codec&lt;/groupId&gt;
                &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
                &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- google 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
                &lt;artifactId&gt;guava&lt;/artifactId&gt;
                &lt;version&gt;$&#123;google-guava.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- swagger2 配置 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
                &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;swagger-bootstrap-ui.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- 文件上传fdfs工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
                &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
                &lt;version&gt;$&#123;fastdfs.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- joda-time 时间工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;joda-time&lt;/groupId&gt;
                &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
                &lt;version&gt;$&#123;joda-time.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;!-- Java 编译 --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;
    @GetMapping(&quot;/hello&quot;)
    public Object hello()&#123;
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
  port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: service-user
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
</code></pre>
<pre><code class="java">SwitchHosts【一定要先关闭代理 因为它会固定静态ip】
127.0.0.1 user.imoocnews.com

http://user.imoocnews.com:8003/hello
</code></pre>
<h3 id="api接口暴露"><a href="#api接口暴露" class="headerlink" title="api接口暴露"></a>api接口暴露</h3><h6 id="所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内"><a href="#所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内" class="headerlink" title="所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内"></a>所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内</h6><pre><code class="xml">把imooc-news-dev-service-user中的pom.xml中的关于SpringBoot的依赖
全部放入imooc-news-dev-service-api中
并且在imooc-news-dev-service-user中写入引用依赖
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">【服务层依赖api层】
更改把user项目的HelloController 复制到dev-service-api 创建一个接口

...api
com/imooc/api/controller/user/HelloControllerApi.java
package com.imooc.api.controller.user;
import org.springframework.web.bind.annotation.GetMapping;

public interface HelloControllerApi &#123;
    /**
     * api的作用：
     * api就相当于企业的领导,老板,部门经理
     * 其他的服务层都是实现,他们就相当于员工,只做事情
     * 老板(开发人员)来看一下每个人(服务)的进度,做什么事
     * 老板不会去问员工,他只会对接部门经理
     * 这里所有的api接口就是统一在这里管理和调度的,微服务也如此
     */

    /**
     * 运作：
     * 现在的所有接口都在此暴露,实现都是在各自的微服务中
     * 本项目只写项目,不写实现,实现在各自的微服务工程中,因为以业务来划分的微服务有很多
     * Controller也会分散在各个微服务工程中,一旦多了就很难统一管理和查看
     *
     * 其次,微服务之间的调用都是基于接口的
     * 如果不这样做,微服务之间的调用就需要互相依赖了
     * 耦合对也就很高,接口的目的是为了能够提供解耦
     *
     * 此外,本项目的接口其实就是一套规范.实现都是由各自的工程去做的处理
     * 目前我们使用springboot作为接口的实现的
     * 如果未来以后出现新的java web框架,那么我们不需要修改接口
     * 只需要去修改对应的实现就可以了,这其实也是解耦的一个体现
     *
     * Swagger2, 基于接口的自动文档生成
     * 所有的配置文件只需要一份,就能再当前项目中去构建了
     * 管理起来很方便
     * 
     * 综上所述,这样做法可以提高多服务的项目可扩展性
     */
    @GetMapping(&quot;/hello&quot;)
    public Object hello();
&#125;


...user
com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    public Object hello()&#123;
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="配置logback日志与多环境profile"><a href="#配置logback日志与多环境profile" class="headerlink" title="配置logback日志与多环境profile"></a>配置logback日志与多环境profile</h3><h6 id="imooc-news-dev-service-user-1"><a href="#imooc-news-dev-service-user-1" class="headerlink" title="imooc-news-dev-service-user"></a>imooc-news-dev-service-user</h6><blockquote>
<p>先添加一个logback-spring.xml</p>
</blockquote>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-admin&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-dev&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/service-user.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        logger.debug(&quot;debug: hello~&quot;);
        logger.info(&quot;info: hello~&quot;);
        logger.warn(&quot;warn: hello~&quot;);
        logger.error(&quot;error: hello~&quot;);

        return &quot;hello&quot;;
    &#125;
&#125;
//重新启动后去页面刷新一下
......
29:22.373 [main] INFO  com.imooc.user.Application - Started Application in 1.061 seconds (JVM running for 1.543)
29:40.693 [http-nio-8003-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
29:40.694 [http-nio-8003-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet &#39;dispatcherServlet&#39;
29:40.696 [http-nio-8003-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 2 ms
29:40.707 [http-nio-8003-exec-1] INFO  c.i.user.controller.HelloController - info: hello~
29:40.707 [http-nio-8003-exec-1] WARN  c.i.user.controller.HelloController - warn: hello~
29:40.707 [http-nio-8003-exec-1] ERROR c.i.user.controller.HelloController - error: hello~
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-user
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
</code></pre>
<pre><code class="java">application-dev.yml
server:
  port: 8003


application-prod.yml
server:
  port: 8130
</code></pre>
<h3 id="优雅的返回封装结果"><a href="#优雅的返回封装结果" class="headerlink" title="优雅的返回封装结果"></a>优雅的返回封装结果</h3><pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.IMOOCJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        logger.debug(&quot;debug: hello~&quot;);
        logger.info(&quot;info: hello~&quot;);
        logger.warn(&quot;warn: hello~&quot;);
        logger.error(&quot;error: hello~&quot;);

//        return &quot;hello&quot;;
//        return IMOOCJSONResult.ok();
//        return IMOOCJSONResult.ok(&quot;hello!&quot;);
        return IMOOCJSONResult.errorMsg(&quot;您的信息有误&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/IMOOCJSONResult.java
package com.imooc.grace.result;

/**
 * 
 * @Title: IMOOCJSONResult.java
 * @Package com.imooc.utils
 * @Description: 自定义响应数据结构
 *                 本类可提供给 H5/ios/安卓/公众号/小程序 使用
 *                 前端接受此类数据（json object)后，可自行根据业务去实现相关功能
 * 
 *                 200：表示成功
 *                 500：表示错误，错误信息在msg字段中
 *                 501：bean验证错误，不管多少个错误都以map形式返回
 *                 502：拦截器拦截到用户token出错
 *                 555：异常抛出信息
 *                 556: 用户qq校验异常
 *                 557: 校验用户是否在CAS登录，用户门票的校验
 * @Copyright: Copyright (c) 2020
 * @Company: www.imooc.com
 * @author 慕课网 - 风间影月
 * @version V1.0
 * 这样太麻烦了 直接用枚举类
 */
public class IMOOCJSONResult &#123;

    // 响应业务状态
    private Integer status;

    // 响应消息
    private String msg;

    // 响应中的数据
    private Object data;
    
    private String ok;    // 不使用

    public static IMOOCJSONResult build(Integer status, String msg, Object data) &#123;
        return new IMOOCJSONResult(status, msg, data);
    &#125;

    public static IMOOCJSONResult build(Integer status, String msg, Object data, String ok) &#123;
        return new IMOOCJSONResult(status, msg, data, ok);
    &#125;
    
    public static IMOOCJSONResult ok(Object data) &#123;
        return new IMOOCJSONResult(data);
    &#125;

    public static IMOOCJSONResult ok() &#123;
        return new IMOOCJSONResult(null);
    &#125;
    
    public static IMOOCJSONResult errorMsg(String msg) &#123;
        return new IMOOCJSONResult(500, msg, null);
    &#125;

    public static IMOOCJSONResult errorUserTicket(String msg) &#123;
        return new IMOOCJSONResult(557, msg, null);
    &#125;
    
    public static IMOOCJSONResult errorMap(Object data) &#123;
        return new IMOOCJSONResult(501, &quot;error&quot;, data);
    &#125;
    
    public static IMOOCJSONResult errorTokenMsg(String msg) &#123;
        return new IMOOCJSONResult(502, msg, null);
    &#125;
    
    public static IMOOCJSONResult errorException(String msg) &#123;
        return new IMOOCJSONResult(555, msg, null);
    &#125;
    
    public static IMOOCJSONResult errorUserQQ(String msg) &#123;
        return new IMOOCJSONResult(556, msg, null);
    &#125;

    public IMOOCJSONResult() &#123;

    &#125;

    public IMOOCJSONResult(Integer status, String msg, Object data) &#123;
        this.status = status;
        this.msg = msg;
        this.data = data;
    &#125;
    
    public IMOOCJSONResult(Integer status, String msg, Object data, String ok) &#123;
        this.status = status;
        this.msg = msg;
        this.data = data;
        this.ok = ok;
    &#125;

    public IMOOCJSONResult(Object data) &#123;
        this.status = 200;
        this.msg = &quot;OK&quot;;
        this.data = data;
    &#125; Getter+Setter
</code></pre>
<h6 id="这样太麻烦而且观察起来不方便-升级一下变成枚举类-更加优雅！"><a href="#这样太麻烦而且观察起来不方便-升级一下变成枚举类-更加优雅！" class="headerlink" title="这样太麻烦而且观察起来不方便 升级一下变成枚举类 更加优雅！"></a>这样太麻烦而且观察起来不方便 升级一下变成枚举类 更加优雅！</h6><pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.IMOOCJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        logger.debug(&quot;debug: hello~&quot;);
        logger.info(&quot;info: hello~&quot;);
        logger.warn(&quot;warn: hello~&quot;);
        logger.error(&quot;error: hello~&quot;);

//        return &quot;hello&quot;;
//        return IMOOCJSONResult.ok();
//        return IMOOCJSONResult.ok(&quot;hello!&quot;);
//        return IMOOCJSONResult.errorMsg(&quot;您的信息有误&quot;);
        return GraceJSONResult.errorCustom(ResponseStatusEnum.NO_AUTH);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/GraceJSONResult.java
package com.imooc.grace.result;

import java.util.Map;

/**
 * 自定义响应数据类型枚举升级版本
 *
 * @Title: IMOOCJSONResult.java
 * @Package com.imooc.utils
 * @Description: 自定义响应数据结构
 *                 本类可提供给 H5/ios/安卓/公众号/小程序 使用
 *                 前端接受此类数据（json object)后，可自行根据业务去实现相关功能
 *
 * @Copyright: Copyright (c) 2020
 * @Company: www.imooc.com
 * @author 慕课网 - 风间影月
 * @version V2.0
 */
public class GraceJSONResult &#123;

    // 响应业务状态码
    private Integer status;

    // 响应消息
    private String msg;

    // 是否成功
    private Boolean success;

    // 响应数据，可以是Object，也可以是List或Map等
    private Object data;

    /**
     * 成功返回，带有数据的，直接往OK方法丢data数据即可
     * @param data
     * @return
     */
    public static GraceJSONResult ok(Object data) &#123;
        return new GraceJSONResult(data);
    &#125;
    /**
     * 成功返回，不带有数据的，直接调用ok方法，data无须传入（其实就是null）
     * @return
     */
    public static GraceJSONResult ok() &#123;
        return new GraceJSONResult(ResponseStatusEnum.SUCCESS);
    &#125;
    public GraceJSONResult(Object data) &#123;
        this.status = ResponseStatusEnum.SUCCESS.status();
        this.msg = ResponseStatusEnum.SUCCESS.msg();
        this.success = ResponseStatusEnum.SUCCESS.success();
        this.data = data;
    &#125;


    /**
     * 错误返回，直接调用error方法即可，当然也可以在ResponseStatusEnum中自定义错误后再返回也都可以
     * @return
     */
    public static GraceJSONResult error() &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED);
    &#125;

    /**
     * 错误返回，map中包含了多条错误信息，可以用于表单验证，把错误统一的全部返回出去
     * @param map
     * @return
     */
    public static GraceJSONResult errorMap(Map map) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, map);
    &#125;

    /**
     * 错误返回，直接返回错误的消息
     * @param msg
     * @return
     */
    public static GraceJSONResult errorMsg(String msg) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, msg);
    &#125;

    /**
     * 错误返回，token异常，一些通用的可以在这里统一定义
     * @return
     */
    public static GraceJSONResult errorTicket() &#123;
        return new GraceJSONResult(ResponseStatusEnum.TICKET_INVALID);
    &#125;

    /**
     * 自定义错误范围，需要传入一个自定义的枚举，可以到[ResponseStatusEnum.java[中自定义后再传入
     * @param responseStatus
     * @return
     */
    public static GraceJSONResult errorCustom(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;
    public static GraceJSONResult exception(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;

    public GraceJSONResult(ResponseStatusEnum responseStatus) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, Object data) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
        this.data = data;
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, String msg) &#123;
        this.status = responseStatus.status();
        this.msg = msg;
        this.success = responseStatus.success();
    &#125;Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/ResponseStatusEnum.java
package com.imooc.grace.result;

/**
 * 响应结果枚举，用于提供给GraceJSONResult返回给前端的
 * 本枚举类中包含了很多的不同的状态码供使用，可以自定义
 * 便于更优雅的对状态码进行管理，一目了然
 */
public enum ResponseStatusEnum &#123;

    SUCCESS(200, true, &quot;操作成功！&quot;),
    FAILED(500, false, &quot;操作失败！&quot;),

    // 50x
    UN_LOGIN(501,false,&quot;请登录后再继续操作！&quot;),
    TICKET_INVALID(502,false,&quot;会话失效，请重新登录！&quot;),
    NO_AUTH(503,false,&quot;您的权限不足，无法继续操作！&quot;),
    MOBILE_ERROR(504,false,&quot;短信发送失败，请稍后重试！&quot;),
    SMS_NEED_WAIT_ERROR(505,false,&quot;短信发送太快啦~请稍后再试！&quot;),
    SMS_CODE_ERROR(506,false,&quot;验证码过期或不匹配，请稍后再试！&quot;),
    USER_FROZEN(507,false,&quot;用户已被冻结，请联系管理员！&quot;),
    USER_UPDATE_ERROR(508,false,&quot;用户信息更新失败，请联系管理员！&quot;),
    USER_INACTIVE_ERROR(509,false,&quot;请前往[账号设置]修改信息激活后再进行后续操作！&quot;),
    FILE_UPLOAD_NULL_ERROR(510,false,&quot;文件不能为空，请选择一个文件再上传！&quot;),
    FILE_UPLOAD_FAILD(511,false,&quot;文件上传失败！&quot;),
    FILE_FORMATTER_FAILD(512,false,&quot;文件图片格式不支持！&quot;),
    FILE_MAX_SIZE_ERROR(513,false,&quot;仅支持500kb大小以下的图片上传！&quot;),
    FILE_NOT_EXIST_ERROR(514,false,&quot;你所查看的文件不存在！&quot;),
    USER_STATUS_ERROR(515,false,&quot;用户状态参数出错！&quot;),
    USER_NOT_EXIST_ERROR(516,false,&quot;用户不存在！&quot;),

    // 自定义系统级别异常 54x
    SYSTEM_INDEX_OUT_OF_BOUNDS(541, false, &quot;系统错误，数组越界！&quot;),
    SYSTEM_ARITHMETIC_BY_ZERO(542, false, &quot;系统错误，无法除零！&quot;),
    SYSTEM_NULL_POINTER(543, false, &quot;系统错误，空指针！&quot;),
    SYSTEM_NUMBER_FORMAT(544, false, &quot;系统错误，数字转换异常！&quot;),
    SYSTEM_PARSE(545, false, &quot;系统错误，解析异常！&quot;),
    SYSTEM_IO(546, false, &quot;系统错误，IO输入输出异常！&quot;),
    SYSTEM_FILE_NOT_FOUND(547, false, &quot;系统错误，文件未找到！&quot;),
    SYSTEM_CLASS_CAST(548, false, &quot;系统错误，类型强制转换错误！&quot;),
    SYSTEM_PARSER_ERROR(549, false, &quot;系统错误，解析出错！&quot;),
    SYSTEM_DATE_PARSER_ERROR(550, false, &quot;系统错误，日期解析出错！&quot;),

    // admin 管理系统 56x
    ADMIN_USERNAME_NULL_ERROR(561, false, &quot;管理员登录名不能为空！&quot;),
    ADMIN_USERNAME_EXIST_ERROR(562, false, &quot;管理员登录名已存在！&quot;),
    ADMIN_NAME_NULL_ERROR(563, false, &quot;管理员负责人不能为空！&quot;),
    ADMIN_PASSWORD_ERROR(564, false, &quot;密码不能为空后者两次输入不一致！&quot;),
    ADMIN_CREATE_ERROR(565, false, &quot;添加管理员失败！&quot;),
    ADMIN_PASSWORD_NULL_ERROR(566, false, &quot;密码不能为空！&quot;),
    ADMIN_NOT_EXIT_ERROR(567, false, &quot;管理员不存在或密码错误！&quot;),
    ADMIN_FACE_NULL_ERROR(568, false, &quot;人脸信息不能为空！&quot;),
    ADMIN_FACE_LOGIN_ERROR(569, false, &quot;人脸识别失败，请重试！&quot;),
    CATEGORY_EXIST_ERROR(570, false, &quot;文章分类已存在，请换一个分类名！&quot;),

    // 媒体中心 相关错误 58x
    ARTICLE_COVER_NOT_EXIST_ERROR(580, false, &quot;文章封面不存在，请选择一个！&quot;),
    ARTICLE_CATEGORY_NOT_EXIST_ERROR(581, false, &quot;请选择正确的文章领域！&quot;),
    ARTICLE_CREATE_ERROR(582, false, &quot;创建文章失败，请重试或联系管理员！&quot;),
    ARTICLE_QUERY_PARAMS_ERROR(583, false, &quot;文章列表查询参数错误！&quot;),
    ARTICLE_DELETE_ERROR(584, false, &quot;文章删除失败！&quot;),
    ARTICLE_WITHDRAW_ERROR(585, false, &quot;文章撤回失败！&quot;),
    ARTICLE_REVIEW_ERROR(585, false, &quot;文章审核出错！&quot;),
    ARTICLE_ALREADY_READ_ERROR(586, false, &quot;文章重复阅读！&quot;),

    // 人脸识别错误代码
    FACE_VERIFY_TYPE_ERROR(600, false, &quot;人脸比对验证类型不正确！&quot;),
    FACE_VERIFY_LOGIN_ERROR(601, false, &quot;人脸登录失败！&quot;),

    // 系统错误，未预期的错误 555
    SYSTEM_ERROR(555, false, &quot;系统繁忙，请稍后再试！&quot;),
    SYSTEM_OPERATION_ERROR(556, false, &quot;操作失败，请重试或联系管理员&quot;),
    SYSTEM_RESPONSE_NO_INFO(557, false, &quot;&quot;);


    // 响应业务状态
    private Integer status;
    // 调用是否成功
    private Boolean success;
    // 响应消息，可以为成功或者失败的消息
    private String msg;

    ResponseStatusEnum(Integer status, Boolean success, String msg) &#123;
        this.status = status;
        this.success = success;
        this.msg = msg;
    &#125;

    public Integer status() &#123;
        return status;
    &#125;
    public Boolean success() &#123;
        return success;
    &#125;
    public String msg() &#123;
        return msg;
    &#125;
&#125;
</code></pre>
<pre><code class="java">&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: null
&#125;
</code></pre>
<h3 id="配置数据库逆向生成实体类"><a href="#配置数据库逆向生成实体类" class="headerlink" title="配置数据库逆向生成实体类"></a>配置数据库逆向生成实体类</h3><h6 id="引入mybatis-generator-database-新建工程项目"><a href="#引入mybatis-generator-database-新建工程项目" class="headerlink" title="引入mybatis-generator-database[新建工程项目]"></a>引入mybatis-generator-database[新建工程项目]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-generator-database&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;


    &lt;dependencies&gt;

        &lt;!-- 引入log4j日志依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;
            &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 阿里开源数据源 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.41&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mapper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--pagehelper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- mybatis 逆向生成工具  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoheihai666/article/details/125936493">dependencymanagement 无法引入包依赖-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/stKAnic/article/details/121380871?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-121380871-blog-121295199.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-121380871-blog-121295199.235%5Ev43%5Epc_blog_bottom_relevance_base6">关于Maven依赖dependency无法引入的问题_<dependencymanagement> 无法引入包-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46411355/article/details/131312807">Maven配置仓库、阿里云镜像、环境变量（史上最全最详细）_maven配置阿里云镜像-CSDN博客</a></p>
<pre><code class="java">将mybatis-generator-database中的pojo[AppUser+Fans]复制转移到imooc-news-dev-model com/imooc/pojo中
将mybatis-generator-database中的com/imooc/user/mapper[AppUserMapper、FansMapper]复制转移到imooc-news-service-user com/imooc/user/mapper中
所有的服务都是要实现API的
将mybatis-generator-database中的com/imooc/my/mapper[MyMapper]复制转移到imooc-news-dev-service-api com/imooc/my/mapper中
将..database中的resources的mapper[AppUserMapper.xml、FansMapper.xml]转移到...service-user的resources的mapper中
</code></pre>
<pre><code class="yaml">imooc-news-dev-service-user中的resources的application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-user
  datasource: # 数据源的相关配置
    type: com.zaxxer.hikari.HikariDataSource          # 数据源类型：HikariCP
    driver-class-name: com.mysql.jdbc.Driver          # mysql驱动
    url: jdbc:mysql://localhost:3306/imooc-news-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true
    username: root
    password: root
    hikari:
      connection-timeout: 30000       # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 默认:30秒
      minimum-idle: 5                 # 最小连接数
      maximum-pool-size: 20           # 最大连接数
      auto-commit: true               # 自动提交
      idle-timeout: 600000            # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟
      pool-name: DateSourceHikariCP     # 连接池名字
      max-lifetime: 1800000           # 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟 1800000ms
      connection-test-query: SELECT 1
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
############################################################
#
# mybatis 配置
#
############################################################
mybatis:
  type-aliases-package: com.imooc.pojo          # 所有POJO类所在包路径
  mapper-locations: classpath:mapper/*.xml      # mapper映射文件

############################################################
#
# mybatis mapper 配置
#
############################################################
# 通用 Mapper 配置
mapper:
  mappers: com.imooc.my.mapper.MyMapper
  not-empty: false    # 在进行数据库操作的的时候，判断表达式 username != null, 是否追加 username != &#39;&#39;
  identity: MYSQL
# 分页插件配置
pagehelper:
  helperDialect: mysql
  supportMethodsArguments: true
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hkdhkdhkd/article/details/113869035">【解决】SLF4J: Class path contains multiple SLF4J bindings._启动metastore时slf4j: class path contains multiple sl-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huifeidezhuzai/p/16352608.html">整合MongoDB踩坑记录及解决方法 - 会飞的猪仔 - 博客园 (cnblogs.com)</a></p>
<pre><code class="java">com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(&quot;com.imooc&quot;)
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="Swagger2接口文檔工具的使用"><a href="#Swagger2接口文檔工具的使用" class="headerlink" title="Swagger2接口文檔工具的使用"></a>Swagger2接口文檔工具的使用</h3><h6 id="imooc-news-dev-service-api-1"><a href="#imooc-news-dev-service-api-1" class="headerlink" title="imooc-news-dev-service-api"></a>imooc-news-dev-service-api</h6><pre><code class="xml">&lt;!-- swagger2 配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
            &lt;version&gt;$&#123;swagger-bootstrap-ui.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/api/config/Swagger2.java
package com.imooc.api.config;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.RequestHandler;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration //Springboot啓動的時候會被掃描到并且加載
@EnableSwagger2
public class Swagger2 &#123;

    //    http://localhost:8088/swagger-ui.html     原路径
//http://user.imoocnews.com:8003/swagger-ui.htm
    //    http://localhost:8088/doc.html            新路径
//http://user.imoocnews.com:8003/doc.html

    // 配置swagger2核心配置 docket
    @Bean
    public Docket createRestApi() &#123;
        Predicate&lt;RequestHandler&gt; adminPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.admin.controller&quot;);
//        Predicate&lt;RequestHandler&gt; articlePredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.article.controller&quot;);
        Predicate&lt;RequestHandler&gt; userPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.user.controller&quot;);
        Predicate&lt;RequestHandler&gt; filesPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.files.controller&quot;);

        return new Docket(DocumentationType.SWAGGER_2)  // 指定api类型为swagger2
                .apiInfo(apiInfo())                 // 用于定义api文档汇总信息
                .select()
                .apis(Predicates.or(userPredicate, adminPredicate, filesPredicate))
//                .apis(Predicates.or(adminPredicate, articlePredicate, userPredicate, filesPredicate))
                .paths(PathSelectors.any())         // 所有controller
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕课新闻·自媒体接口api&quot;)                       // 文档页标题
                .contact(new Contact(&quot;imooc&quot;,
                        &quot;https://www.imooc.com&quot;,
                        &quot;abc@imooc.com&quot;))                   // 联系人信息
                .description(&quot;专为慕课新闻·自媒体平台提供的api文档&quot;)      // 详细信息
                .version(&quot;1.0.1&quot;)                               // 文档版本号
                .termsOfServiceUrl(&quot;https://www.imooc.com&quot;)     // 网站地址
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/HelloControllerApi.java
package com.imooc.api.controller.user;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;

@Api(value = &quot;controller的標題&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
public interface HelloControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/hello&quot;)
    public Object hello();
&#125;
</code></pre>
<p>[maven-之Lifecycle详解_maven lifecycle-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39505065/article/details/102915403#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86">https://blog.csdn.net/qq_39505065/article/details/102915403#第三部分</a> PS)</p>
<blockquote>
<p>Maven中的Lifecycle的install是什麽 ？<br>将包安装到本地存储库中，作为本地其他项目的依赖项</p>
</blockquote>
<h3 id="梳理短信登錄注冊流程"><a href="#梳理短信登錄注冊流程" class="headerlink" title="梳理短信登錄注冊流程"></a>梳理短信登錄注冊流程</h3><ul>
<li>短信登录注册</li>
<li>短信验证码发送与限制</li>
<li>分布式会话</li>
<li>用户信息完善，OSS&#x2F;FastDFS文件上传</li>
<li>AOP日志监控</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/87e42b65e3e64f84efebcf347d7bd0180b448627/data/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e4dcd13c468e5883cfd3187c6c2800cf2bc4168f/data/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C2.png"></p>
<pre><code class="xml">aliyun.properties
#这里需要去阿里云上购买短信验证 [电脑aliyun_Key.txt有]
aliyun.accessKeyID=
aliyun.accessKeySecret=
</code></pre>
<p><a target="_blank" rel="noopener" href="https://next.api.aliyun.com/api/Dysmsapi/2017-05-25/SendSms?params=%7B%22SignName%22:%22%E5%B0%8F%E6%BD%98%E7%A7%91%E6%8A%80%22,%22TemplateCode%22:%22SMS_467115116%22,%22PhoneNumbers%22:%2215027597319%22,%22TemplateParam%22:%22%7B%22code%22:%221234%22%7D%22%7D">SendSms_短信服务_API调试-阿里云OpenAPI开发者门户 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://next.api.aliyun.com/api-tools/demo/Dysmsapi/db7e1211-14e0-4b7b-9011-037dfb85d42e">短信发送并查询示例_短信服务_示例中心-阿里云OpenAPI开发者门户 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://ram.console.aliyun.com/manage/ak">RAM 访问控制 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://dysms.console.aliyun.com/overview">短信服务 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/i-bp1dssknxftmjczbtpnd/detail?regionId=cn-hangzhou">云服务器管理控制台 (aliyun.com)</a></p>
<pre><code class="xml">【imooc-news-dev-common】
pom.xml
加入springboot依赖包
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-common:
    通用工程
    包含了一些工具类,枚举类,封装的一些公共方法以及一些第三方组件等
--&gt;
    &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--    引入SpringBoot依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--  第三方云厂商相关依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/utils/extend/AliyunResource.java
package com.imooc.utils.extend;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(&quot;classpath:aliyun.properties&quot;)
@ConfigurationProperties(prefix = &quot;aliyun&quot;) //这里是前缀
public class AliyunResource &#123;
    private String accessKeyID;
    private String accessKeySecret;

    public String getAccessKeyID() &#123;
        return accessKeyID;
    &#125;

    public void setAccessKeyID(String accessKeyID) &#123;
        this.accessKeyID = accessKeyID;
    &#125;

    public String getAccessKeySecret() &#123;
        return accessKeySecret;
    &#125;

    public void setAccessKeySecret(String accessKeySecret) &#123;
        this.accessKeySecret = accessKeySecret;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/utils/SMSUtils.java
package com.imooc.utils;

import com.aliyuncs.CommonRequest;
import com.aliyuncs.CommonResponse;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.exceptions.ServerException;
import com.aliyuncs.http.MethodType;
import com.aliyuncs.profile.DefaultProfile;
import com.imooc.utils.extend.AliyunResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component //工具类 可以作为组件
public class SMSUtils &#123;
    @Autowired
    public AliyunResource aliyunResource;
    final static Logger logger = LoggerFactory.getLogger(SMSUtils.class);
    public void sendSMS(String mobile, String code) &#123;
        DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;,
                aliyunResource.getAccessKeyID(),
                aliyunResource.getAccessKeySecret());
        IAcsClient client = new DefaultAcsClient(profile);

        CommonRequest request = new CommonRequest();
        request.setSysMethod(MethodType.POST);
        request.setSysDomain(&quot;dysmsapi.aliyuncs.com&quot;);
        request.setSysVersion(&quot;2017-05-25&quot;);
        request.setSysAction(&quot;SendSms&quot;);
        request.putQueryParameter(&quot;RegionId&quot;, &quot;cn-hangzhou&quot;);
        //给对方发送的手机号
        request.putQueryParameter(&quot;PhoneNumbers&quot;, mobile);
        request.putQueryParameter(&quot;SignName&quot;, &quot;小潘科技&quot;);//控制台可以添加签名
        request.putQueryParameter(&quot;TemplateCode&quot;, &quot;SMS_467115116&quot;);
        request.putQueryParameter(&quot;TemplateParam&quot;, &quot;&#123;\&quot;code\&quot;:\&quot;&quot; + code + &quot;\&quot;&#125;&quot;);//JSON对象字符串
        try &#123;
            CommonResponse response = client.getCommonResponse(request);
            System.out.println(response.getData());
            // 打印阿里云API的响应结果
            logger.info(&quot;Aliyun SMS API response: &quot; + response.getData());
        &#125; catch (ServerException e) &#123;
            e.printStackTrace();
            logger.error(&quot;ServerException: &quot; + e.getMessage());
        &#125; catch (ClientException e) &#123;
            e.printStackTrace();
            logger.error(&quot;ClientException: &quot; + e.getMessage());
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/PassportControllerApi.java[接口]
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode();
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.SMSUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode()&#123;
        // 生成6位随机验证码
        String random = String.valueOf((int)((Math.random() * 9 + 1) * 100000));
        // 打印生成的验证码以便调试
        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
        logger.info(&quot;SMS sent to 15027597000 with code: &quot; + random);

        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/GraceJSONResult.java
package com.imooc.grace.result;

import java.util.Map;

/**
 * 自定义响应数据类型枚举升级版本
 *
 * @Title: IMOOCJSONResult.java
 * @Package com.imooc.utils
 * @Description: 自定义响应数据结构
 *                 本类可提供给 H5/ios/安卓/公众号/小程序 使用
 *                 前端接受此类数据（json object)后，可自行根据业务去实现相关功能
 *
 * @Copyright: Copyright (c) 2020
 * @Company: www.imooc.com
 * @author 慕课网 - 风间影月
 * @version V2.0
 */
public class GraceJSONResult &#123;

    // 响应业务状态码
    private Integer status;

    // 响应消息
    private String msg;

    // 是否成功
    private Boolean success;

    // 响应数据，可以是Object，也可以是List或Map等
    private Object data;

    /**
     * 成功返回，带有数据的，直接往OK方法丢data数据即可
     * @param data
     * @return
     */
    public static GraceJSONResult ok(Object data) &#123;
        return new GraceJSONResult(data);
    &#125;
    /**
     * 成功返回，不带有数据的，直接调用ok方法，data无须传入（其实就是null）
     * @return
     */
    public static GraceJSONResult ok() &#123;
        return new GraceJSONResult(ResponseStatusEnum.SUCCESS);
    &#125;
    public GraceJSONResult(Object data) &#123;
        this.status = ResponseStatusEnum.SUCCESS.status();
        this.msg = ResponseStatusEnum.SUCCESS.msg();
        this.success = ResponseStatusEnum.SUCCESS.success();
        this.data = data;
    &#125;


    /**
     * 错误返回，直接调用error方法即可，当然也可以在ResponseStatusEnum中自定义错误后再返回也都可以
     * @return
     */
    public static GraceJSONResult error() &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED);
    &#125;

    /**
     * 错误返回，map中包含了多条错误信息，可以用于表单验证，把错误统一的全部返回出去
     * @param map
     * @return
     */
    public static GraceJSONResult errorMap(Map map) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, map);
    &#125;

    /**
     * 错误返回，直接返回错误的消息
     * @param msg
     * @return
     */
    public static GraceJSONResult errorMsg(String msg) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, msg);
    &#125;

    /**
     * 错误返回，token异常，一些通用的可以在这里统一定义
     * @return
     */
    public static GraceJSONResult errorTicket() &#123;
        return new GraceJSONResult(ResponseStatusEnum.TICKET_INVALID);
    &#125;

    /**
     * 自定义错误范围，需要传入一个自定义的枚举，可以到[ResponseStatusEnum.java[中自定义后再传入
     * @param responseStatus
     * @return
     */
    public static GraceJSONResult errorCustom(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;
    public static GraceJSONResult exception(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;

    public GraceJSONResult(ResponseStatusEnum responseStatus) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, Object data) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
        this.data = data;
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, String msg) &#123;
        this.status = responseStatus.status();
        this.msg = msg;
        this.success = responseStatus.success();
    &#125;

    public GraceJSONResult() &#123;
    &#125;

    public Integer getStatus() &#123;
        return status;
    &#125;

    public void setStatus(Integer status) &#123;
        this.status = status;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;

    public Object getData() &#123;
        return data;
    &#125;

    public void setData(Object data) &#123;
        this.data = data;
    &#125;

    public Boolean getSuccess() &#123;
        return success;
    &#125;

    public void setSuccess(Boolean success) &#123;
        this.success = success;
    &#125;
&#125;
</code></pre>
<h3 id="安装配置整合Redis"><a href="#安装配置整合Redis" class="headerlink" title="安装配置整合Redis"></a>安装配置整合Redis</h3><pre><code class="mysql">通过Xftp7把redis-5.0.7.tar.gz传入到服务器
[root@iZbp1dssknxftmjczbtpndZ ~]# tar -zxvf redis-5.0.7.tar.gz 
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
apache-zookeeper-3.6.0-bin         rabbitmq-server-3.8.2-1.el7.noarch.rpm
apache-zookeeper-3.6.0-bin.tar.gz  redis-5.0.7
erlang-22.3-1.el7.x86_64.rpm       redis-5.0.7.tar.gz
[root@iZbp1dssknxftmjczbtpndZ ~]# cd redis-5.0.7
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# ll
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# yum install gcc-c++
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# make
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# cd /usr/local/ ★
[root@iZbp1dssknxftmjczbtpndZ local]# ll
[root@iZbp1dssknxftmjczbtpndZ local]# pwd
/usr/local
[root@iZbp1dssknxftmjczbtpndZ local]# cd redis/ ★
[root@iZbp1dssknxftmjczbtpndZ redis]# ll
total 4
drwxr-xr-x 2 root root 4096 May 15 11:19 bin
[root@iZbp1dssknxftmjczbtpndZ redis]# cd bin ★
[root@iZbp1dssknxftmjczbtpndZ bin]# ll
total 32772
-rwxr-xr-x 1 root root 4366880 May 15 11:04 redis-benchmark
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-aof
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-rdb
-rwxr-xr-x 1 root root 4807952 May 15 11:04 redis-cli
-rw-r--r-- 1 root root       0 May 15 11:19 redis.conf
lrwxrwxrwx 1 root root      12 May 15 11:04 redis-sentinel -&gt; redis-server
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-server
[root@iZbp1dssknxftmjczbtpndZ redis]# cd
[root@iZbp1dssknxftmjczbtpndZ ~]# cd redis-5.0.7
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# ls
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# cp redis.conf /usr/local/redis/bin/
cp: overwrite ‘/usr/local/redis/bin/redis.conf’? y
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# cd /usr/local/redis/bin/
[root@iZbp1dssknxftmjczbtpndZ bin]# ll
total 32836
-rwxr-xr-x 1 root root 4366880 May 15 11:04 redis-benchmark
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-aof
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-rdb
-rwxr-xr-x 1 root root 4807952 May 15 11:04 redis-cli
-rw-r--r-- 1 root root   61797 May 15 11:28 redis.conf
lrwxrwxrwx 1 root root      12 May 15 11:04 redis-sentinel -&gt; redis-server
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-server
[root@iZbp1dssknxftmjczbtpndZ bin]# vim redis.conf
在里面 /bind 直接搜索
把bind 127.0.0.1修改成 0.0.0.0在任何地方都可以进行操作修改
在里面 /dae
把daemonize no 改成 daemonize yes[后台启动]
在里面 /require
把requirepass foobared 这里是设置密码 requirepass XXXX
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-server redis.conf ★
32421:C 15 May 2024 11:35:36.687 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
32421:C 15 May 2024 11:35:36.687 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=32421, just started
32421:C 15 May 2024 11:35:36.687 # Configuration loaded
[root@iZbp1dssknxftmjczbtpndZ bin]# ps -ef|grep redis
root     32422     1  0 11:35 ?        00:00:00 ./redis-server 0.0.0.0:6379
root     32456 25226  0 11:35 pts/0    00:00:00 grep --color=auto redis
【此时说明已经成功启动Redis】
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-cli ★
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; keys *
(empty list or set)
127.0.0.1:6379&gt; set name imooc
OK
127.0.0.1:6379&gt; get name
&quot;imooc&quot;
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-cli -p 6379 shutdown

★直接进入redis文件内★
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/local/redis/bin       //进入文件内
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-server redis.conf   //启动
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-cli                 //测试
★★
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hu4545/article/details/126174419">Linux下Redis服务启动与关闭_linux 关闭redis-CSDN博客</a></p>
<h3 id="安装配置整合Redis-2"><a href="#安装配置整合Redis-2" class="headerlink" title="安装配置整合Redis-2"></a>安装配置整合Redis-2</h3><blockquote>
<p>下载并安装好 Redis Desktop Manager<br>新连接设置<br>名字：redis-imooc-news 47.98.225.105<br>地址：47.98.225.105：6379</p>
</blockquote>
<pre><code class="xml">加一下redis的依赖
imooc-news-dev-common
pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-common:
    通用工程
    包含了一些工具类,枚举类,封装的一些公共方法以及一些第三方组件等
--&gt;
    &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--    引入SpringBoot依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 引入 redis 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
            &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- jackson --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- apache 工具类 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-codec&lt;/groupId&gt;
            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- google 工具类 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
            &lt;artifactId&gt;guava&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- joda-time 时间工具 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;joda-time&lt;/groupId&gt;
            &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--  第三方云厂商相关依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/utils/RedisOperator.java
package com.imooc.utils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.connection.StringRedisConnection;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * @Title: Redis 工具类
 * @author 风间影月
 */
@Component
public class RedisOperator &#123;
    
    @Resource
    private StringRedisTemplate redisTemplate;

    // Key（键），简单的key-value操作

    /**
     * 判断key是否存在
     * @param key
     * @return
     */
    public boolean keyIsExist(String key) &#123;
        return redisTemplate.hasKey(key);
    &#125;

    /**
     * 实现命令：TTL key，以秒为单位，返回给定 key的剩余生存时间(TTL, time to live)。
     * 
     * @param key
     * @return
     */
    public long ttl(String key) &#123;
        return redisTemplate.getExpire(key);
    &#125;
    
    /**
     * 实现命令：expire 设置过期时间，单位秒
     * 
     * @param key
     * @return
     */
    public void expire(String key, long timeout) &#123;
        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);
    &#125;
    
    /**
     * 实现命令：increment key，增加key一次
     * 
     * @param key
     * @return
     */
    public long increment(String key, long delta) &#123;
        return redisTemplate.opsForValue().increment(key, delta);
    &#125;

    /**
     * 实现命令：decrement key，减少key一次
     *
     * @param key
     * @return
     */
    public long decrement(String key, long delta) &#123;
        return redisTemplate.opsForValue().decrement(key, delta);
    &#125;

    /**
     * 实现命令：KEYS pattern，查找所有符合给定模式 pattern的 key
     */
    public Set&lt;String&gt; keys(String pattern) &#123;
        return redisTemplate.keys(pattern);
    &#125;

    /**
     * 实现命令：DEL key，删除一个key
     * 
     * @param key
     */
    public void del(String key) &#123;
        redisTemplate.delete(key);
    &#125;

    // String（字符串）

    /**
     * 实现命令：SET key value，设置一个key-value（将字符串值 value关联到 key）
     * 
     * @param key
     * @param value
     */
    public void set(String key, String value) &#123;
        redisTemplate.opsForValue().set(key, value);
    &#125;

    /**
     * 实现命令：SET key value EX seconds，设置key-value和超时时间（秒）
     * 
     * @param key
     * @param value
     * @param timeout
     *            （以秒为单位）
     */
    public void set(String key, String value, long timeout) &#123;
        redisTemplate.opsForValue().set(key, value, timeout, TimeUnit.SECONDS);
    &#125;

    /**
     * 如果key不存在，则设置，如果存在，则报错
     * @param key
     * @param value
     */
    public void setnx60s(String key, String value) &#123;
        redisTemplate.opsForValue().setIfAbsent(key, value, 60, TimeUnit.SECONDS);
    &#125;

    /**
     * 如果key不存在，则设置，如果存在，则报错
     * @param key
     * @param value
     */
    public void setnx(String key, String value) &#123;
        redisTemplate.opsForValue().setIfAbsent(key, value);
    &#125;

    /**
     * 实现命令：GET key，返回 key所关联的字符串值。
     * 
     * @param key
     * @return value
     */
    public String get(String key) &#123;
        return (String)redisTemplate.opsForValue().get(key);
    &#125;

    /**
     * 批量查询，对应mget
     * @param keys
     * @return
     */
    public List&lt;String&gt; mget(List&lt;String&gt; keys) &#123;
        return redisTemplate.opsForValue().multiGet(keys);
    &#125;

    /**
     * 批量查询，管道pipeline
     * @param keys
     * @return
     */
    public List&lt;Object&gt; batchGet(List&lt;String&gt; keys) &#123;

//        nginx -&gt; keepalive
//        redis -&gt; pipeline

        List&lt;Object&gt; result = redisTemplate.executePipelined(new RedisCallback&lt;String&gt;() &#123;
            @Override
            public String doInRedis(RedisConnection connection) throws DataAccessException &#123;
                StringRedisConnection src = (StringRedisConnection)connection;

                for (String k : keys) &#123;
                    src.get(k);
                &#125;
                return null;
            &#125;
        &#125;);

        return result;
    &#125;


    // Hash（哈希表）

    /**
     * 实现命令：HSET key field value，将哈希表 key中的域 field的值设为 value
     * 
     * @param key
     * @param field
     * @param value
     */
    public void hset(String key, String field, Object value) &#123;
        redisTemplate.opsForHash().put(key, field, value);
    &#125;

    /**
     * 实现命令：HGET key field，返回哈希表 key中给定域 field的值
     * 
     * @param key
     * @param field
     * @return
     */
    public String hget(String key, String field) &#123;
        return (String) redisTemplate.opsForHash().get(key, field);
    &#125;

    /**
     * 实现命令：HDEL key field [field ...]，删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。
     * 
     * @param key
     * @param fields
     */
    public void hdel(String key, Object... fields) &#123;
        redisTemplate.opsForHash().delete(key, fields);
    &#125;

    /**
     * 实现命令：HGETALL key，返回哈希表 key中，所有的域和值。
     * 
     * @param key
     * @return
     */
    public Map&lt;Object, Object&gt; hgetall(String key) &#123;
        return redisTemplate.opsForHash().entries(key);
    &#125;

    // List（列表）

    /**
     * 实现命令：LPUSH key value，将一个值 value插入到列表 key的表头
     * 
     * @param key
     * @param value
     * @return 执行 LPUSH命令后，列表的长度。
     */
    public long lpush(String key, String value) &#123;
        return redisTemplate.opsForList().leftPush(key, value);
    &#125;

    /**
     * 实现命令：LPOP key，移除并返回列表 key的头元素。
     * 
     * @param key
     * @return 列表key的头元素。
     */
    public String lpop(String key) &#123;
        return (String)redisTemplate.opsForList().leftPop(key);
    &#125;

    /**
     * 实现命令：RPUSH key value，将一个值 value插入到列表 key的表尾(最右边)。
     * 
     * @param key
     * @param value
     * @return 执行 LPUSH命令后，列表的长度。
     */
    public long rpush(String key, String value) &#123;
        return redisTemplate.opsForList().rightPush(key, value);
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337066868">Spring Boot集成Redis的坑，踩了！ - 知乎 (zhihu.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45590494/article/details/114444371">@Autowired和@Resource注解的区别和联系（十分详细，不看后悔）_为什么@resource和@autowired 注入的对象不一样-CSDN博客</a></p>
<blockquote>
<p>妈的有个超级大bug 整我一下午，<br>@Component public class RedisOperator {<br>@Autowired private StringRedisTemplate redisTemplate;}<br> 报错信息 Could not autowire. No beans of ‘StringRedisTemplate’ type found.</p>
<p>在这里不要本末倒置 回归最原始的报错 那就是pom.xml中的导包依赖问题<br>有的时候直接复制的项目中的成熟依赖 根据时代的不同可能会导致丢失无法下载依赖<br>这时要去百度Maven库手动下载 并且手动添加 然后手动导入Project Structure → Libraries 手动导入自己需要的包[记住包的版本 也要在依赖里面体现 &lt; version &gt;]，而且如果有红色波浪线的包可以删除 再重新导入即可</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/arjelarxfc/article/details/78806384">Spring里遇到的一个问题，autowired时报找不到bean定义_autowired找不到bean-CSDN博客</a></p>
<h3 id="完善发送短信接口"><a href="#完善发送短信接口" class="headerlink" title="完善发送短信接口"></a>完善发送短信接口</h3><pre><code class="java">com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;

import javax.servlet.http.HttpServletRequest;

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request);
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.controller.user.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.RedisOperator;
import com.imooc.utils.SMSUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.imooc.utils.IPUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
// 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
//    @Autowired
//    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        String userIp = IPUtil.getRequestIp(request);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
//        redis.setnx60s(&quot;smscode&quot;+ip);
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot;+userIp,userIp);

        //生成随机验证码并且发送短信
        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替

        //把验证码存入redis,用于后续进行验证
        redis.set(MOBILE_SMSCODE+&quot;:&quot;+mobile, random, 30*60);
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/BaseController.java
package com.imooc.api.controller.user;

import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;

public class BaseController &#123;
   @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;

&#125;
</code></pre>
<pre><code class="java">com/imooc/utils/IPUtil.java
package com.imooc.utils;

import javax.servlet.http.HttpServletRequest;

/**
 * 用户获得用户ip的工具类
 */
public class IPUtil &#123;

    /**
     * 获取请求IP:
     * 用户的真实IP不能使用request.getRemoteAddr()
     * 这是因为可能会使用一些代理软件，这样ip获取就不准确了
     * 此外我们如果使用了多级（LVS/Nginx）反向代理的话，ip需要从X-Forwarded-For中获得第一个非unknown的IP才是用户的有效ip。
     * @param request
     * @return
     */
    public static String getRequestIp(HttpServletRequest request) &#123;
        String ip = request.getHeader(&quot;x-forwarded-for&quot;);
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getRemoteAddr();
        &#125;
        return ip;
    &#125;
&#125;
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/sms/getting-started/use-sms-console-1?spm=a2c4g.11186623.0.0.70707f5cATZOcJ">快速使用 在控制台发送短信_短信服务(SMS)-阿里云帮助中心 (aliyun.com)</a></p>
</blockquote>
<h3 id="联调前端发送短信-解决跨域问题"><a href="#联调前端发送短信-解决跨域问题" class="headerlink" title="联调前端发送短信, 解决跨域问题"></a>联调前端发送短信, 解决跨域问题</h3><pre><code class="java">http://writer.imoocnews.com:9090/imooc-news/writer/passport.html
因为后台写死了手机号 所以在输入手机号可以随便 点击发送验证码后 会在浏览器控制台输出跨域问题 在后端要設置允許跨域請求
-----------------------------------------------------------------------------------
passport.html:1  Access to XMLHttpRequest at &#39;http://user.imoocnews.com:8003/passport/getSMSCode?mobile=123334323&#39; from origin &#39;http://writer.imoocnews.com:9090&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.

GET http://user.imoocnews.com:8003/passport/getSMSCode?mobile=123334323 net::ERR_FAILED 200 (OK)
axios.min.js:2  Uncaught (in promise) Error: Network Error
    at e.exports (axios.min.js:2:9633)
    at l.onerror (axios.min.js:2:8398)
</code></pre>
<pre><code class="java">...service-api  com/imooc/api/config/CorsConfig.java
package com.imooc.api.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration //SpringBoot可以加载该信息
public class CorsConfig &#123;

    public CorsConfig() &#123;
    &#125;

    @Bean
    public CorsFilter corsFilter() &#123;
        // 1. 添加cors配置信息
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOrigin(&quot;*&quot;);
        // 设置是否发送cookie信息
        config.setAllowCredentials(true);
        // 设置允许请求的方式
        config.addAllowedMethod(&quot;*&quot;);
        // 设置允许的header
        config.addAllowedHeader(&quot;*&quot;);
        // 2. 为url添加映射路径
        UrlBasedCorsConfigurationSource corsSource = new UrlBasedCorsConfigurationSource();
        corsSource.registerCorsConfiguration(&quot;/**&quot;, config);
        // 3. 返回重新定义好的corsSource
        return new CorsFilter(corsSource);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.SMSUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        //获取用户ip
        String userIp = IPUtil.getRequestIp(request);
        logger.info(&quot;User ip:&quot;, userIp);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot; + userIp, userIp);

        // 生成6位随机验证码
        String random = (int)((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        // 打印生成的验证码以便调试
//        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
//        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
//        logger.info(&quot;SMS sent to 15027597319 with code: &quot; + random);
        redis.set(MOBILE_SMSCODE + &quot;:&quot; + mobile, random, 30 * 60);
   //记得如果要发送到redis中 则需要先用application-dev.yml导入RedisDesktopManager正确的网络地址127.0.0.1 
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);
&#125;
</code></pre>
<h3 id="拦截并限制60秒用户短信发送"><a href="#拦截并限制60秒用户短信发送" class="headerlink" title="拦截并限制60秒用户短信发送"></a>拦截并限制60秒用户短信发送</h3><pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/password/getSMSCode&quot;); //拦截PassportControllerApi里的信息
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/interceptors/PassportInterceptor.java
package com.imooc.api.interceptors;

import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

    public class PassportInterceptor implements HandlerInterceptor &#123;

        @Autowired
        public RedisOperator redis;

        public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;

        /**
         * 拦截请求，访问controller之前
         * @param request
         * @param response
         * @param handler
         * @return
         * @throws Exception
         */
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

            // 获得用户ip
            String userIp = IPUtil.getRequestIp(request);

            boolean keyIsExist = redis.keyIsExist(MOBILE_SMSCODE + &quot;:&quot; + userIp);

            if (keyIsExist) &#123;
                GraceException.display(ResponseStatusEnum.SMS_NEED_WAIT_ERROR);
//            System.out.println(&quot;短信发送频率太大！&quot;);
                return false;
            &#125;

            /**
             * false：请求被拦截
             * true：请求通过验证，放行
             */
            return true;
        &#125;


        /**
         * 请求访问到controller之后，渲染视图之前
         * @param request
         * @param response
         * @param handler
         * @param modelAndView
         * @throws Exception
         */
        @Override
        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

        &#125;

        /**
         * 请求访问到controller之后，渲染视图之后
         * @param request
         * @param response
         * @param handler
         * @param ex
         * @throws Exception
         */
        @Override
        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

        &#125;
    &#125;
</code></pre>
<pre><code class="java">dev-common com/imooc/exception/GraceException.java
package com.imooc.exception;

import com.imooc.grace.result.ResponseStatusEnum;

/**
 * 优雅的处理异常，统一封装
 */
public class GraceException &#123;

    public static void display(ResponseStatusEnum responseStatusEnum) &#123;
        throw new MyCustomException(responseStatusEnum);
    &#125;

&#125;
</code></pre>
<pre><code class="java">com/imooc/exception/MyCustomException.java
package com.imooc.exception;

import com.imooc.grace.result.ResponseStatusEnum;

/**
 * 自定义异常
 * 目的：统一处理异常信息
 *      便于解耦，service与controller错误的解耦，不会被service返回的类型而限制
 */
public class MyCustomException extends RuntimeException &#123;

    private ResponseStatusEnum responseStatusEnum;

    public MyCustomException(ResponseStatusEnum responseStatusEnum) &#123;
        super(&quot;异常状态码为：&quot; + responseStatusEnum.status()
                + &quot;；具体异常信息为：&quot; + responseStatusEnum.msg());
        this.responseStatusEnum = responseStatusEnum;
    &#125;

    public ResponseStatusEnum getResponseStatusEnum() &#123;
        return responseStatusEnum;
    &#125;

    public void setResponseStatusEnum(ResponseStatusEnum responseStatusEnum) &#123;
        this.responseStatusEnum = responseStatusEnum;
    &#125;
&#125;
</code></pre>
<h3 id="自定义异常-返回错误信息"><a href="#自定义异常-返回错误信息" class="headerlink" title="自定义异常, 返回错误信息"></a>自定义异常, 返回错误信息</h3><h6 id="接上方GraceException、MyCustomException、PassportInterceptor"><a href="#接上方GraceException、MyCustomException、PassportInterceptor" class="headerlink" title="[接上方GraceException、MyCustomException、PassportInterceptor]"></a>[接上方GraceException、MyCustomException、PassportInterceptor]</h6><pre><code class="java">dev-common  com/imooc/grace/result/ResponseStatusEnum.java
package com.imooc.grace.result;

/**
 * 响应结果枚举，用于提供给GraceJSONResult返回给前端的
 * 本枚举类中包含了很多的不同的状态码供使用，可以自定义
 * 便于更优雅的对状态码进行管理，一目了然
 */
public enum ResponseStatusEnum &#123;

    SUCCESS(200, true, &quot;操作成功！&quot;),
    FAILED(500, false, &quot;操作失败！&quot;),

    // 50x
    UN_LOGIN(501,false,&quot;请登录后再继续操作！&quot;),
    TICKET_INVALID(502,false,&quot;会话失效，请重新登录！&quot;),
    NO_AUTH(503,false,&quot;您的权限不足，无法继续操作！&quot;),
    MOBILE_ERROR(504,false,&quot;短信发送失败，请稍后重试！&quot;),
    SMS_NEED_WAIT_ERROR(505,false,&quot;短信发送太快啦~请稍后再试！&quot;),
    SMS_CODE_ERROR(506,false,&quot;验证码过期或不匹配，请稍后再试！&quot;),
    USER_FROZEN(507,false,&quot;用户已被冻结，请联系管理员！&quot;),
    USER_UPDATE_ERROR(508,false,&quot;用户信息更新失败，请联系管理员！&quot;),
    USER_INACTIVE_ERROR(509,false,&quot;请前往[账号设置]修改信息激活后再进行后续操作！&quot;),
    FILE_UPLOAD_NULL_ERROR(510,false,&quot;文件不能为空，请选择一个文件再上传！&quot;),
    FILE_UPLOAD_FAILD(511,false,&quot;文件上传失败！&quot;),
    FILE_FORMATTER_FAILD(512,false,&quot;文件图片格式不支持！&quot;),
    FILE_MAX_SIZE_ERROR(513,false,&quot;仅支持500kb大小以下的图片上传！&quot;),
    FILE_NOT_EXIST_ERROR(514,false,&quot;你所查看的文件不存在！&quot;),
    USER_STATUS_ERROR(515,false,&quot;用户状态参数出错！&quot;),
    USER_NOT_EXIST_ERROR(516,false,&quot;用户不存在！&quot;),

    // 自定义系统级别异常 54x
    SYSTEM_INDEX_OUT_OF_BOUNDS(541, false, &quot;系统错误，数组越界！&quot;),
    SYSTEM_ARITHMETIC_BY_ZERO(542, false, &quot;系统错误，无法除零！&quot;),
    SYSTEM_NULL_POINTER(543, false, &quot;系统错误，空指针！&quot;),
    SYSTEM_NUMBER_FORMAT(544, false, &quot;系统错误，数字转换异常！&quot;),
    SYSTEM_PARSE(545, false, &quot;系统错误，解析异常！&quot;),
    SYSTEM_IO(546, false, &quot;系统错误，IO输入输出异常！&quot;),
    SYSTEM_FILE_NOT_FOUND(547, false, &quot;系统错误，文件未找到！&quot;),
    SYSTEM_CLASS_CAST(548, false, &quot;系统错误，类型强制转换错误！&quot;),
    SYSTEM_PARSER_ERROR(549, false, &quot;系统错误，解析出错！&quot;),
    SYSTEM_DATE_PARSER_ERROR(550, false, &quot;系统错误，日期解析出错！&quot;),

    // admin 管理系统 56x
    ADMIN_USERNAME_NULL_ERROR(561, false, &quot;管理员登录名不能为空！&quot;),
    ADMIN_USERNAME_EXIST_ERROR(562, false, &quot;管理员登录名已存在！&quot;),
    ADMIN_NAME_NULL_ERROR(563, false, &quot;管理员负责人不能为空！&quot;),
    ADMIN_PASSWORD_ERROR(564, false, &quot;密码不能为空后者两次输入不一致！&quot;),
    ADMIN_CREATE_ERROR(565, false, &quot;添加管理员失败！&quot;),
    ADMIN_PASSWORD_NULL_ERROR(566, false, &quot;密码不能为空！&quot;),
    ADMIN_NOT_EXIT_ERROR(567, false, &quot;管理员不存在或密码错误！&quot;),
    ADMIN_FACE_NULL_ERROR(568, false, &quot;人脸信息不能为空！&quot;),
    ADMIN_FACE_LOGIN_ERROR(569, false, &quot;人脸识别失败，请重试！&quot;),
    CATEGORY_EXIST_ERROR(570, false, &quot;文章分类已存在，请换一个分类名！&quot;),

    // 媒体中心 相关错误 58x
    ARTICLE_COVER_NOT_EXIST_ERROR(580, false, &quot;文章封面不存在，请选择一个！&quot;),
    ARTICLE_CATEGORY_NOT_EXIST_ERROR(581, false, &quot;请选择正确的文章领域！&quot;),
    ARTICLE_CREATE_ERROR(582, false, &quot;创建文章失败，请重试或联系管理员！&quot;),
    ARTICLE_QUERY_PARAMS_ERROR(583, false, &quot;文章列表查询参数错误！&quot;),
    ARTICLE_DELETE_ERROR(584, false, &quot;文章删除失败！&quot;),
    ARTICLE_WITHDRAW_ERROR(585, false, &quot;文章撤回失败！&quot;),
    ARTICLE_REVIEW_ERROR(585, false, &quot;文章审核出错！&quot;),
    ARTICLE_ALREADY_READ_ERROR(586, false, &quot;文章重复阅读！&quot;),

    // 人脸识别错误代码
    FACE_VERIFY_TYPE_ERROR(600, false, &quot;人脸比对验证类型不正确！&quot;),
    FACE_VERIFY_LOGIN_ERROR(601, false, &quot;人脸登录失败！&quot;),

    // 系统错误，未预期的错误 555
    SYSTEM_ERROR(555, false, &quot;系统繁忙，请稍后再试！&quot;),
    SYSTEM_OPERATION_ERROR(556, false, &quot;操作失败，请重试或联系管理员&quot;),
    SYSTEM_RESPONSE_NO_INFO(557, false, &quot;&quot;);


    // 响应业务状态
    private Integer status;
    // 调用是否成功
    private Boolean success;
    // 响应消息，可以为成功或者失败的消息
    private String msg;

    ResponseStatusEnum(Integer status, Boolean success, String msg) &#123;
        this.status = status;
        this.success = success;
        this.msg = msg;
    &#125;

    public Integer status() &#123;
        return status;
    &#125;
    public Boolean success() &#123;
        return success;
    &#125;
    public String msg() &#123;
        return msg;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/exception/GraceExceptionHandler.java
package com.imooc.exception;

import com.imooc.grace.result.GraceJSONResult;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 统一异常拦截处理
 * 可以针对异常的类型进行捕获 然后返回json信息到前端
 */
@ControllerAdvice //本质上是实现AOP的管理
public class GraceExceptionHandler &#123;
    @ExceptionHandler(MyCustomException.class)
    //只要是这个类的异常都会进入下面的方法
    @ResponseBody
    public GraceJSONResult returnMyException(MyCustomException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.exception(e.getResponseStatusEnum());
    &#125;
&#125;
</code></pre>
<h3 id="验证BO信息-注册登录接口"><a href="#验证BO信息-注册登录接口" class="headerlink" title="验证BO信息(注册登录接口)"></a>验证BO信息(注册登录接口)</h3><pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/RegistLoginBO.java
package com.imooc.pojo.bo;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;

//加上@data 会自动生成getter+setter
public class RegistLoginBO &#123;
    //不为空 空的话可以返回 不用NOTNULL因为无法校验空字符串 用NotBlank
    @NotBlank(message = &quot;手机号不能为空&quot;) 
    private String mobile;
    @NotBlank(message = &quot;短信验证码不能为空&quot;)
    private String smsCode;

    @Override
    public String toString() &#123;
        return &quot;RegistLoginBO&#123;&quot; +
                &quot;mobile=&#39;&quot; + mobile + &#39;\&#39;&#39; +
                &quot;, smsCode=&#39;&quot; + smsCode + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    public String getMobile() &#123;
        return mobile;
    &#125;

    public void setMobile(String mobile) &#123;
        this.mobile = mobile;
    &#125;

    public String getSmsCode() &#123;
        return smsCode;
    &#125;

    public void setSmsCode(String smsCode) &#123;
        this.smsCode = smsCode;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.utils.IPUtil;
import com.imooc.utils.SMSUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        //获取用户ip
        String userIp = IPUtil.getRequestIp(request);
        logger.info(&quot;User ip:&quot;, userIp);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot; + userIp, userIp);

        // 生成6位随机验证码
        String random = (int)((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        // 打印生成的验证码以便调试
//        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
//        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
//        logger.info(&quot;SMS sent to 15027597319 with code: &quot; + random);
        redis.set(MOBILE_SMSCODE + &quot;:&quot; + mobile, random, 30 * 60);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
package com.imooc.api;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class BaseController &#123;
   @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;

    /**可以公用 就放到BaseController里面
     * 在任何controller中都可以调用和使用
     * 获取BO中的错误信息
     *
     * @param result
     * @return
     */
    public Map&lt;String, String&gt; getErrors(BindingResult result)&#123;
        //对应着RegistLoginBO的信息
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList)&#123;
            //发生验证错误所对应的某个属性
            String field = error.getField();
            //验证的错误信息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;
&#125;
</code></pre>
<pre><code class="java">http://writer.imoocnews.com:8003/doc.html   打开校验
POST：/passport/doLogin

&#123;
    &quot;mobile&quot;:&quot;&quot;,
    &quot;smsCode&quot;:&quot;&quot;
&#125;

&#123;
&quot;status&quot;: 500,
&quot;msg&quot;: &quot;操作失败！&quot;,
&quot;success&quot;: false,
-&quot;data&quot;: &#123;
&quot;smsCode&quot;: &quot;短信验证码不能为空&quot;,
&quot;mobile&quot;: &quot;手机号不能为空&quot;
&#125;
&#125;
--------------------------------------------------------
 //不为空 空的话可以返回 不用NOTNULL因为无法校验空字符串 用NotBlank
    @NotBlank(message = &quot;手机号不能为空&quot;) 
    private String mobile;
    @NotBlank(message = &quot;短信验证码不能为空&quot;)
    private String smsCode;
// 要注意上面的为NotBlank 不然它验证的结果会跳过手机号判断 直接说验证码错误 
// 因为NotNull在处理&quot;mobile&quot;:&quot;&quot;, &quot;smsCode&quot;:&quot;&quot;的时候空字符串也算入不为空
//NotBlank兼顾NotNull
</code></pre>
<h3 id="通过数据库-查询老用户-老用户添加"><a href="#通过数据库-查询老用户-老用户添加" class="headerlink" title="通过数据库 查询老用户_老用户添加"></a>通过数据库 查询老用户_老用户添加</h3><pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.enums.UserStatus;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.IPUtil;
import com.imooc.utils.SMSUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;

    @Autowired
    private UserService userService;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        //获取用户ip
        String userIp = IPUtil.getRequestIp(request);
        logger.info(&quot;User ip:&quot;, userIp);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot; + userIp, userIp);

        // 生成6位随机验证码
        String random = (int)((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        // 打印生成的验证码以便调试
//        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
//        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
//        logger.info(&quot;SMS sent to 15027597319 with code: &quot; + random);
        redis.set(MOBILE_SMSCODE + &quot;:&quot; + mobile, random, 30 * 60);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;

        //2.查询数据库,判断该用户注册
        AppUser user = userService.queryMobileIsExist(mobile);
        if (user != null &amp;&amp; user.getActiveStatus() == UserStatus.FROZEN.type)&#123;
            //如果用户不为空，并且状态为冻结，则直接抛出异常，禁止登录
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_FROZEN);
        &#125;else if (user == null)&#123;
            //如果用户没有注册过，则为null，需要注册信息入库
            user = userService.createUser(mobile);
        &#125;
        return GraceJSONResult.ok(user);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/UserService.java[接口]
package com.imooc.user.service.impl;

import com.imooc.pojo.AppUser;

public interface UserService &#123;
    /**
     * 判断用户是否存在，如果存在返回user信息
     */
    public AppUser queryMobileIsExist(String mobile);

    /**
     * 创建用户，新增用户记录到数据库
     */
    public AppUser createUser(String mobile);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java
package com.imooc.user.service;

import com.imooc.enums.Sex;
import com.imooc.enums.UserStatus;
import com.imooc.pojo.AppUser;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.DesensitizationUtil;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;
import com.imooc.utils.DateUtil;

import java.util.Date;

@Service
public class UserServiceimpl implements UserService &#123;
    @Autowired
    public AppUserMapper appUserMapper; //基本的CRUD都可以

    @Autowired
    public Sid sid;

    private static final String USER_FACE0 = &quot;https://raw.githubusercontent.com/P-luminary/images/10d94134b65e13cc8ec9b8a9aeae4f958921cab7/data/Imooc_Cat.jpg&quot;;
    private static final String USER_FACE1 = &quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;;
    @Override
    public AppUser queryMobileIsExist(String mobile) &#123;
        Example userExample = new Example(AppUser.class);
        Example.Criteria userCriteria = userExample.createCriteria();
        userCriteria.andEqualTo(&quot;mobile&quot;, mobile);
        AppUser user = appUserMapper.selectOneByExample(userExample);
        return null;
    &#125;

    @Transactional //对整个类的方法，事务起作用。无异常时正常提交，有异常时数据回滚
    @Override
    public AppUser createUser(String mobile) &#123;
        /**
         * 互联网项目都要考虑可扩展性
         * 如果未来的业务激增，那么就需要分表分库
         * 那么数据库表主键id必须保证全局(全库)唯一,不得重复
         */
        String userId = sid.nextShort();
        AppUser user = new AppUser();
        user.setId(userId);
        user.setMobile(mobile);
        user.setNickname(&quot;用户：&quot; + DesensitizationUtil.commonDisplay(mobile)); //給手机号加** 是脱敏操作
        user.setFace(USER_FACE1);
        user.setBirthday(DateUtil.stringToDate(&quot;2024-06-29&quot;)); //字符串转换Date类型
        user.setSex(Sex.secret.type);
        user.setActiveStatus(UserStatus.INACTIVE.type);//是否激活
        user.setTotalIncome(0);//收入
        user.setCreatedTime(new Date());
        user.setUpdatedTime(new Date());
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/AppUser.java
package com.imooc.pojo;

import javax.persistence.Column;
import javax.persistence.Id;
import javax.persistence.Table;
import java.util.Date;

@Table(name = &quot;app_user&quot;)
public class AppUser &#123;
    @Id
    private String id;

    /**
     * 手机号
     */
    private String mobile;

    /**
     * 昵称，媒体号
     */
    private String nickname;

    /**
     * 头像
     */
    private String face;

    /**
     * 真实姓名
     */
    private String realname;

    /**
     * 邮箱地址
     */
    private String email;

    /**
     * 性别 1:男  0:女  2:保密
     */
    private Integer sex;

    /**
     * 生日
     */
    private Date birthday;

    /**
     * 省份
     */
    private String province;

    /**
     * 城市
     */
    private String city;

    /**
     * 区县
     */
    private String district;

    /**
     * 用户状态：0：未激活。 1：已激活：基本信息是否完善，真实姓名，邮箱地址，性别，生日，住址等，如果没有完善，则用户不能发表评论，不能点赞，不能关注。2：已冻结。
     */
    @Column(name = &quot;active_status&quot;)
    private Integer activeStatus;

    /**
     * 累计已结算的收入金额，也就是已经打款的金额，每次打款后再此累加
     */
    @Column(name = &quot;total_income&quot;)
    private Integer totalIncome;

    /**
     * 创建时间 创建时间
     */
    @Column(name = &quot;created_time&quot;)
    private Date createdTime;

    /**
     * 更新时间 更新时间
     */
    @Column(name = &quot;updated_time&quot;)
    private Date updatedTime;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-user  com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;com.imooc.utils&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">【来自Chatgpt】
java.sql.SQLException: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;READ&#39; at line 1
    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readErrorPacket(AbstractQueryProtocol.java:1594)
    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readPacket(AbstractQueryProtocol.java:1453)
    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.getResult(AbstractQueryProtocol.java:1415)

这个新的错误信息表明在设置 tx_isolation 时，语法存在问题。我们需要确保设置事务隔离级别的语法是正确的。以下是一些更具体的步骤来解决这个问题：

1. 确认MariaDB版本支持的语法
在MariaDB中，设置事务隔离级别的正确语法可能与MySQL略有不同。确保使用MariaDB支持的正确语法。

2. 确认正确的事务隔离级别语法
根据MariaDB的官方文档，设置事务隔离级别的正确方法是使用以下语法：

sql
复制代码
SET SESSION tx_isolation = &#39;READ-COMMITTED&#39;;
3. 修改连接URL
在连接URL中正确设置事务隔离级别：

yaml
复制代码
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/imooc-news-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;sessionVariables=tx_isolation=&#39;READ-COMMITTED&#39;
4. 确认数据源属性配置
确保数据源属性配置正确：

yaml
复制代码
spring:
  datasource:
    hikari:
      connection-timeout: 30000
      minimum-idle: 5
      maximum-pool-size: 20
      auto-commit: true
      idle-timeout: 600000
      pool-name: DateSourceHikariCP
      max-lifetime: 1800000
      connection-test-query: SELECT 1
      data-source-properties:
        tx_isolation: &#39;READ-COMMITTED&#39;
5. 确认使用MariaDB JDBC驱动
确保使用MariaDB的JDBC驱动：

Maven
xml
复制代码
&lt;dependency&gt;
    &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
    &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
    &lt;version&gt;2.7.2&lt;/version&gt;
&lt;/dependency&gt;
Gradle
groovy
复制代码
implementation &#39;org.mariadb.jdbc:mariadb-java-client:2.7.2&#39;
6. 测试事务隔离设置
在MariaDB中手动测试设置事务隔离级别，确保语法正确：

sql
复制代码
SET SESSION tx_isolation = &#39;READ-COMMITTED&#39;;
如果这条命令可以成功执行，那么它也应该能在你的连接URL中正确设置。

7. 确认Spring配置
确保Spring Boot配置正确，可以通过显式设置数据源属性来避免问题：

yaml
复制代码
spring:
  datasource:
    hikari:
      data-source-properties:
        tx_isolation: &#39;READ-COMMITTED&#39;
总结
通过上述步骤，你应该能够解决 tx_isolation 变量设置的问题，并确保连接到MariaDB数据库时没有语法错误。如果问题依然存在，请提供更多的错误日志和配置文件信息，以便进一步诊断。
</code></pre>
<pre><code class="java">http://writer.imoocnews.com:8003/doc.html 先接收验证码 通过redis获得 再测试登录接口
&#123;
    &quot;mobile&quot;:&quot;15027597319&quot;,
    &quot;smsCode&quot;:&quot;815850&quot;
&#125;

相应内容：
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    -&quot;data&quot;: &#123;
    &quot;id&quot;: &quot;240629F0PD4PZANC&quot;,
    &quot;mobile&quot;: &quot;15027597319&quot;,
    &quot;nickname&quot;: &quot;用户：15******319&quot;,
    &quot;face&quot;: &quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;,
    &quot;realname&quot;: null,
    &quot;email&quot;: null,
    &quot;sex&quot;: 2,
    &quot;birthday&quot;: &quot;2024-06-29 00:00:00&quot;,
    &quot;province&quot;: null,
    &quot;city&quot;: null,
    &quot;district&quot;: null,
    &quot;activeStatus&quot;: 0,
    &quot;totalIncome&quot;: 0,
    &quot;createdTime&quot;: &quot;2024-06-29 19:39:10&quot;,
    &quot;updatedTime&quot;: &quot;2024-06-29 19:39:10&quot;
    &#125;
&#125;

此时去数据库imooc-news-dev的app_user中发现并未有数据新增进入
再UserServiceimpl.java中
appUserMapper.insert(user);

当如果把app_user数据库离的active_status 的0变成2 就会被冻结【UserStatus】
&#123;
&quot;status&quot;: 507,
&quot;msg&quot;: &quot;用户已被冻结，请联系管理员！&quot;,
&quot;success&quot;: false,
&quot;data&quot;: null
&#125;
</code></pre>
<h3 id="设置会话与cookie信息【注册登录】"><a href="#设置会话与cookie信息【注册登录】" class="headerlink" title="设置会话与cookie信息【注册登录】"></a>设置会话与cookie信息【注册登录】</h3><pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
...
 // 3.保存用户分布式会话的相关操作
        int userActiveStatus = user.getActiveStatus();
        if (userActiveStatus != UserStatus.FROZEN.type)&#123;
            String uToken = UUID.randomUUID().toString();
            redis.set(REDIS_USER_TOKEN+&quot;:&quot;+user.getId(),uToken);//BaseController里面 保存token到redis
            //保存用户id和token到cookie中 设计一个request response 回到PassportControllerApi

        &#125;
        return GraceJSONResult.ok(user);
    &#125;
...
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java [增加一个setCookie]
package com.imooc.api;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class BaseController &#123;
   @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;

    /**可以公用 就放到BaseController里面
     * 在任何controller中都可以调用和使用
     * 获取BO中的错误信息
     *
     * @param result
     * @return
     */
    public Map&lt;String, String&gt; getErrors(BindingResult result)&#123;
        //对应着RegistLoginBO的信息
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList)&#123;
            //发生验证错误所对应的某个属性
            String field = error.getField();
            //验证的错误信息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;

/*    public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge)&#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
            Cookie cookie = new Cookie(cookieName,cookieValue);
            cookie.setMaxAge(maxAge);
            cookie.setDomain(&quot;imoocnews.com&quot;);
            cookie.setPath(&quot;/&quot;);//都用cookie
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125; */

   public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge)&#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
//            Cookie cookie = new Cookie(cookieName,cookieValue);
//            cookie.setMaxAge(maxAge);
//            cookie.setDomain(&quot;imoocnews.com&quot;);
//            cookie.setPath(&quot;/&quot;);//都用cookie
            setCookieValue(request, response, cookieName, cookieValue, maxAge);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void setCookieValue(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge)&#123;
            Cookie cookie = new Cookie(cookieName,cookieValue);
            cookie.setMaxAge(maxAge);
            cookie.setDomain(&quot;imoocnews.com&quot;);
            cookie.setPath(&quot;/&quot;);//都用cookie
            response.addCookie(cookie);//把cookie传入
        &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO
            , BindingResult result, HttpServletRequest request, HttpServletResponse response);
    //完成之后 去BaseController里面写一个setCookie()方便都可以用
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
    @Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result, HttpServletRequest request, HttpServletResponse response) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;

        //2.查询数据库,判断该用户注册
        AppUser user = userService.queryMobileIsExist(mobile);
        if (user != null &amp;&amp; user.getActiveStatus() == UserStatus.FROZEN.type)&#123;
            //如果用户不为空，并且状态为冻结，则直接抛出异常，禁止登录
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_FROZEN);
        &#125;else if (user == null)&#123;
            //如果用户没有注册过，则为null，需要注册信息入库
            user = userService.createUser(mobile);
        &#125;

        // 3.保存用户分布式会话的相关操作
        int userActiveStatus = user.getActiveStatus();
        if (userActiveStatus != UserStatus.FROZEN.type)&#123;
            String uToken = UUID.randomUUID().toString();
            redis.set(REDIS_USER_TOKEN+&quot;:&quot;+user.getId(),uToken);//BaseController里面 保存token到redis

            //保存用户id和token到cookie中 设计一个request response 回到PassportControllerApi
            setCookie(request, response,&quot;uToken&quot;,uToken,COOKIE_MONTH);
            setCookie(request, response,&quot;uid&quot;,user.getId(),COOKIE_MONTH);
        &#125;
        // 4.用户登录或注册成功以后，需要删除redis中的短信验证码，验证码只能使用一次，用过则作废
        redis.del(MOBILE_SMSCODE + &quot;:&quot; + mobile);
        // 5.返回用户状态 返回前端看
        return GraceJSONResult.ok(userActiveStatus);
    &#125;
</code></pre>
<h3 id="资源属性与常量绑定-优雅"><a href="#资源属性与常量绑定-优雅" class="headerlink" title="资源属性与常量绑定 [优雅]"></a>资源属性与常量绑定 [优雅]</h3><pre><code class="java">把这种属性放到常量文件里进行绑定  cookie.setDomain(&quot;imoocnews.com&quot;);
service-api  com/imooc/api/BaseController.java
public abstract class BaseController &#123;
    @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;
 ★ @Value(&quot;$&#123;website.domain-name&#125;&quot;) ★★
 ★ public String DOMAIN_NAME; ★★
...
 public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge) &#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
//            Cookie cookie = new Cookie(cookieName,cookieValue);
//            cookie.setMaxAge(maxAge);
//            cookie.setDomain(&quot;imoocnews.com&quot;);
//            cookie.setPath(&quot;/&quot;);//都用cookie
            setCookieValue(request, response, cookieName, cookieValue, maxAge);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void setCookieValue(HttpServletRequest request,
                               HttpServletResponse response,
                               String cookieName,
                               String cookieValue,
                               Integer maxAge) &#123;
        Cookie cookie = new Cookie(cookieName, cookieValue);
        cookie.setMaxAge(maxAge);
//        cookie.setDomain(&quot;imoocnews.com&quot;);
        cookie.setDomain(DOMAIN_NAME);
        cookie.setPath(&quot;/&quot;);//都用cookie
        response.addCookie(cookie);//把cookie传入
    &#125;
...
================================================================================
application-dev.yml
server:
  port: 8003

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379

# setup CN from java, This is resource
website:
  domain-name: imoocnews.com
</code></pre>
<h3 id="查询用户账户信息"><a href="#查询用户账户信息" class="headerlink" title="查询用户账户信息"></a>查询用户账户信息</h3><pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.api.controller.user.UserControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.vo.UserAccountInfoVO;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@RestController
public class UserController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    @Override
    public GraceJSONResult getAccountInfo(String userId) &#123;
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;

        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        UserAccountInfoVO accountInfoVO = new UserAccountInfoVO();
        BeanUtils.copyProperties(user, accountInfoVO); //拷贝信息
        return GraceJSONResult.ok(accountInfoVO);
    &#125;
    private AppUser getUser(String userId)&#123;
        // TODO 本方法后续公用，并且扩展
        AppUser user = userService.getUser(userId);
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/UserService.java
package com.imooc.user.service.impl;

import com.imooc.pojo.AppUser;

public interface UserService &#123;
    /**
     * 判断用户是否存在，如果存在返回user信息
     */
    public AppUser queryMobileIsExist(String mobile);

    /**
     * 创建用户，新增用户记录到数据库
     */
    public AppUser createUser(String mobile);

    /**
     * 根据用户主键id查询用户信息
     * @param userId
     * @return
     */
    public AppUser getUser(String userId);
&#125;
====================================================================
service-user  com/imooc/user/service/UserServiceimpl.java
     @Override
    public AppUser getUser(String userId) &#123;
        return appUserMapper.selectByPrimaryKey(userId);
    &#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/UserAccountInfoVO.java
public class UserAccountInfoVO &#123;
    private String id;
    private String mobile;
    private String nickname;
    private String face;
    private String realname;
    private String email;
    private Integer sex;
    private Date birthday;
    private String province;
    private String city;
    private String district;
&#125;Getter + Setter
</code></pre>
<h3 id="信息校验"><a href="#信息校验" class="headerlink" title="信息校验"></a>信息校验</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.api.controller.user.UserControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.pojo.vo.UserAccountInfoVO;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Map;

@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    @Override
    public GraceJSONResult getAccountInfo(String userId) &#123;
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;

        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        UserAccountInfoVO accountInfoVO = new UserAccountInfoVO();
        BeanUtils.copyProperties(user, accountInfoVO); //拷贝信息
        return GraceJSONResult.ok(accountInfoVO);
    &#125;

    private AppUser getUser(String userId)&#123;
        // TODO 本方法后续公用，并且扩展
        AppUser user = userService.getUser(userId);
        return user;
    &#125;

    @Override
    public GraceJSONResult updateUserInfo(UpdateUserInfoBO updateUserInfoBO, BindingResult result) &#123;
        // 0.校验BO
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        // 1.执行更新操作
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
                                          BindingResult result);
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/UpdateUserInfoBO.java
public class UpdateUserInfoBO &#123;

    @NotBlank(message = &quot;用户ID不能为空&quot;)
    private String id;

    @NotBlank(message = &quot;用户昵称不能为空&quot;)
    @Length(max = 12, message = &quot;用户昵称不能超过12位&quot;)
    private String nickname;

    @NotBlank(message = &quot;用户头像不能为空&quot;)
    private String face;

    @NotBlank(message = &quot;真实姓名不能为空&quot;)
    private String realname;

    @Email
    @NotBlank(message = &quot;邮件不能为空&quot;)
    private String email;

    @NotNull(message = &quot;请选择一个性别&quot;)
    @Min(value = 0, message = &quot;性别选择不正确&quot;)
    @Max(value = 1, message = &quot;性别选择不正确&quot;)
    private Integer sex;

    @NotNull(message = &quot;请选择生日日期&quot;)
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd&quot;) // 解决前端日期字符串传到后端后，转换为Date类型
    private Date birthday;

    @NotBlank(message = &quot;请选择所在城市&quot;)
    private String province;

    @NotBlank(message = &quot;请选择所在城市&quot;)
    private String city;

    @NotBlank(message = &quot;请选择所在城市&quot;)
    private String district;
&#125;
</code></pre>
<h3 id="激活用户信息入库"><a href="#激活用户信息入库" class="headerlink" title="激活用户信息入库"></a>激活用户信息入库</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@Override
    public GraceJSONResult updateUserInfo(UpdateUserInfoBO updateUserInfoBO, BindingResult result) &#123;
        // 0.校验BO
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        // 1.执行更新操作
        userService.updateUserInfo(updateUserInfoBO);
        return GraceJSONResult.ok();
        //调用UserService把独有信息传入
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/UserService.java
package com.imooc.user.service.impl;

import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;

public interface UserService &#123;
    /**
     * 判断用户是否存在，如果存在返回user信息
     */
    public AppUser queryMobileIsExist(String mobile);

    /**
     * 创建用户，新增用户记录到数据库
     */
    public AppUser createUser(String mobile);

    /**
     * 根据用户主键id查询用户信息
     * @param userId
     * @return
     */
    public AppUser getUser(String userId);

    /**
     * 用户修改信息，完善资料，并且激活
     * @param updateUserInfoBO
     */
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java
@Override
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO)&#123;
        String userId = updateUserInfoBO.getId();
        AppUser userInfo = new AppUser();
        BeanUtils.copyProperties(updateUserInfoBO, userInfo);
        userInfo.setUpdatedTime(new Date());
        userInfo.setActiveStatus(UserStatus.ACTIVE.type);
        //appUserMapper.updateByPrimaryKey()//数据中现有的数据覆盖为空的
        int result = appUserMapper.updateByPrimaryKeySelective(userInfo);
        if (result != 1)&#123;
            //更新操作有问题
            GraceException.display(ResponseStatusEnum.USER_UPDATE_ERROR);
        &#125;
    &#125;
</code></pre>
<h3 id="查询并展示用户基本信息"><a href="#查询并展示用户基本信息" class="headerlink" title="查询并展示用户基本信息"></a>查询并展示用户基本信息</h3><pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,BindingResult result);
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/AppUserVO.java
public class AppUserVO &#123;
    private String id;
    private String nickname;
    private String face;
    private Integer activeStatus;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    @Override
    public GraceJSONResult getUserInfo(String userId) &#123;
        //重写接口进行解耦!!
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;
        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        AppUserVO userVO = new AppUserVO();
        BeanUtils.copyProperties(user, userVO); //拷贝信息
        return GraceJSONResult.ok(userVO);
    &#125;
&#125;
</code></pre>
<h3 id="浏览器存储介质"><a href="#浏览器存储介质" class="headerlink" title="浏览器存储介质"></a>浏览器存储介质</h3><ul>
<li><h6 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h6></li>
<li><h6 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a><span style = "color:red">SessionStorage</span></h6></li>
<li><h6 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h6></li>
</ul>
<h3 id="缓存用户信息-用Redis减轻数据库压力"><a href="#缓存用户信息-用Redis减轻数据库压力" class="headerlink" title="缓存用户信息 [用Redis减轻数据库压力]"></a>缓存用户信息 [用Redis减轻数据库压力]</h3><pre><code class="java">service-api  com/imooc/api/BaseController.java
//REDIS_USER_INFO添加进来
public abstract class BaseController &#123;
    @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_USER_INFO = &quot;redis_user_info&quot;;//ctrl+shift+u直接大写
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;
    @Value(&quot;$&#123;website.domain-name&#125;&quot;)
    public String DOMAIN_NAME;

    /**
     * 可以公用 就放到BaseController里面
     * 在任何controller中都可以调用和使用
     * 获取BO中的错误信息
     *
     * @param result
     * @return
     */
    public Map&lt;String, String&gt; getErrors(BindingResult result) &#123;
        //对应着RegistLoginBO的信息
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList) &#123;
            //发生验证错误所对应的某个属性
            String field = error.getField();
            //验证的错误信息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;

    public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge) &#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
//            Cookie cookie = new Cookie(cookieName,cookieValue);
//            cookie.setMaxAge(maxAge);
//            cookie.setDomain(&quot;imoocnews.com&quot;);
//            cookie.setPath(&quot;/&quot;);//都用cookie
            setCookieValue(request, response, cookieName, cookieValue, maxAge);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void setCookieValue(HttpServletRequest request,
                               HttpServletResponse response,
                               String cookieName,
                               String cookieValue,
                               Integer maxAge) &#123;
        Cookie cookie = new Cookie(cookieName, cookieValue);
        cookie.setMaxAge(maxAge);
//        cookie.setDomain(&quot;imoocnews.com&quot;);
        cookie.setDomain(DOMAIN_NAME);
        cookie.setPath(&quot;/&quot;);//都用cookie
        response.addCookie(cookie);//把cookie传入
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
 private AppUser getUser(String userId)&#123;
        //查询判断redis中是否包含用户信息 若有则直接返回就不去查询数据库了
        String userJson = redis.get(REDIS_USER_INFO + &quot;:&quot; + userId);
        AppUser user = null;
        if (StringUtils.isNotBlank(userJson))&#123;
            //字符串转换成json对象  要提取user 所以要一开始赋值null
            user = JsonUtils.jsonToPojo(userJson, AppUser.class);
        &#125; else &#123;
            // TODO 本方法后续公用，并且扩展
            user = userService.getUser(userId);
            // 由于用户信息不怎么会变动,对于一些千万级别网站来说,这类信息不会直接去查询数据库
            // 可以完全依靠Redis,直接把查询后的数据存入到Redis中
            // set里面设置一个key去BaseController里设置  ↓user变成jason转换类
            redis.set(REDIS_USER_INFO + &quot;:&quot; + userId, JsonUtils.objectToJson(user));
        &#125;

        return user;
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java
package com.imooc.user.service;

import com.imooc.enums.Sex;
import com.imooc.enums.UserStatus;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.DesensitizationUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;
import org.n3r.idworker.Sid;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;
import com.imooc.utils.DateUtil;

import java.util.Date;

@Service
public class UserServiceimpl implements UserService &#123;
    @Autowired
    public AppUserMapper appUserMapper; //基本的CRUD都可以

    @Autowired
    public Sid sid;
    public static final String REDIS_USER_INFO = &quot;redis_user_info&quot;;//ctrl+shift+u直接大写


    @Autowired
    public RedisOperator redis;

    private static final String USER_FACE0 = &quot;https://raw.githubusercontent.com/P-luminary/images/10d94134b65e13cc8ec9b8a9aeae4f958921cab7/data/Imooc_Cat.jpg&quot;;
    private static final String USER_FACE1 = &quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;;
    @Override
    public AppUser queryMobileIsExist(String mobile) &#123;
        Example userExample = new Example(AppUser.class);
        Example.Criteria userCriteria = userExample.createCriteria();
        userCriteria.andEqualTo(&quot;mobile&quot;, mobile);
        AppUser user = appUserMapper.selectOneByExample(userExample);
        return user;
    &#125;

    @Transactional //对整个类的方法，事务起作用。无异常时正常提交，有异常时数据回滚
    @Override
    public AppUser createUser(String mobile) &#123;
        /**
         * 互联网项目都要考虑可扩展性
         * 如果未来的业务激增，那么就需要分表分库
         * 那么数据库表主键id必须保证全局(全库)唯一,不得重复
         */
        String userId = sid.nextShort();
        AppUser user = new AppUser();
        user.setId(userId);
        user.setMobile(mobile);
        user.setNickname(&quot;用户：&quot; + DesensitizationUtil.commonDisplay(mobile)); //給手机号加** 是脱敏操作
        user.setFace(USER_FACE1);
        user.setBirthday(DateUtil.stringToDate(&quot;2024-06-29&quot;)); //字符串转换Date类型
        user.setSex(Sex.secret.type);
        user.setActiveStatus(UserStatus.INACTIVE.type);//是否激活
        user.setTotalIncome(0);//收入
        user.setCreatedTime(new Date());
        user.setUpdatedTime(new Date());
        appUserMapper.insert(user);
        return user;
    &#125;

    @Override
    public AppUser getUser(String userId) &#123;
        return appUserMapper.selectByPrimaryKey(userId);
    &#125;

    @Override
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO)&#123;
        String userId = updateUserInfoBO.getId();
        AppUser userInfo = new AppUser();
        BeanUtils.copyProperties(updateUserInfoBO, userInfo);

        userInfo.setUpdatedTime(new Date());
        userInfo.setActiveStatus(UserStatus.ACTIVE.type);
        //appUserMapper.updateByPrimaryKey()//数据中现有的数据覆盖为空的
        int result = appUserMapper.updateByPrimaryKeySelective(userInfo);
        if (result != 1)&#123;
            //更新操作有问题
            GraceException.display(ResponseStatusEnum.USER_UPDATE_ERROR);
        &#125;
        // 再次查询用户的最新信息,放入redis中
        AppUser user = getUser(userId);
        redis.set(REDIS_USER_INFO + &quot;:&quot; + userId, JsonUtils.objectToJson(user));

    &#125;
&#125;
</code></pre>
<pre><code class="java">Redis里面 redis_user_info
&#123;&quot;id&quot;:&quot;240629F21AK1BHX4&quot;,&quot;mobile&quot;:&quot;15027597319&quot;,&quot;nickname&quot;:&quot;15027597319&quot;,&quot;face&quot;:&quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;,&quot;realname&quot;:&quot;小宝宝的小潘潘2&quot;,&quot;email&quot;:&quot;390415030@qq.com&quot;,&quot;sex&quot;:1,&quot;birthday&quot;:1720195200000,&quot;province&quot;:&quot;河北&quot;,&quot;city&quot;:&quot;唐山市&quot;,&quot;district&quot;:&quot;丰润区&quot;,&quot;activeStatus&quot;:1,&quot;totalIncome&quot;:0,&quot;createdTime&quot;:1719661387000,&quot;updatedTime&quot;:1720281759000&#125;
</code></pre>
<h3 id="双写数据不一致的情况-redis故障没有写入新数据"><a href="#双写数据不一致的情况-redis故障没有写入新数据" class="headerlink" title="双写数据不一致的情况 [redis故障没有写入新数据]"></a>双写数据不一致的情况 [redis故障没有写入新数据]</h3><h6 id="如何双写一致-缓存双删"><a href="#如何双写一致-缓存双删" class="headerlink" title="如何双写一致 缓存双删"></a>如何双写一致 缓存双删</h6><blockquote>
<p>用户先把老Redis中的数据删除 然后再把修改值放入数据库 然后数据库再导入redis 就可以保证双写一致<br>但是要保证数据库放入Redis之前 后期用户请求要再其之后 [进行休眠] &#x3D;&gt;缓存双删</p>
</blockquote>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java  @Override
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO)&#123;
        String userId = updateUserInfoBO.getId();
        // 保证双写一致,先删除redis中的数据,后更新数据库
//        redis.del(REDIS_USER_INFO + &quot;:&quot; + userId);

        AppUser userInfo = new AppUser();
        BeanUtils.copyProperties(updateUserInfoBO, userInfo);

        userInfo.setUpdatedTime(new Date());
        userInfo.setActiveStatus(UserStatus.ACTIVE.type);
        //appUserMapper.updateByPrimaryKey()//数据中现有的数据覆盖为空的
        int result = appUserMapper.updateByPrimaryKeySelective(userInfo);
        if (result != 1)&#123;
            //更新操作有问题
            GraceException.display(ResponseStatusEnum.USER_UPDATE_ERROR);
        &#125;
        // 再次查询用户的最新信息,放入redis中
        AppUser user = getUser(userId);
        redis.set(REDIS_USER_INFO + &quot;:&quot; + userId, JsonUtils.objectToJson(user));

        // 缓存双删策略 [不处理可能会缓存击穿]
        try &#123;
            Thread.sleep(100);
            redis.del(REDIS_USER_INFO + &quot;:&quot; + userId);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
</code></pre>
<h3 id="CAP理论-只能满足其中一、二"><a href="#CAP理论-只能满足其中一、二" class="headerlink" title="CAP理论 [只能满足其中一、二]"></a>CAP理论 [只能满足其中一、二]</h3><h5 id="分布式系统都存在CAP情况"><a href="#分布式系统都存在CAP情况" class="headerlink" title="分布式系统都存在CAP情况"></a>分布式系统都存在CAP情况</h5><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><h5 id="CAP的重要性"><a href="#CAP的重要性" class="headerlink" title="CAP的重要性"></a>CAP的重要性</h5><p>分布式不可能同时满足三个条件 【先满足P再去考虑A或C】</p>
<h5 id="CAP理论是什么？"><a href="#CAP理论是什么？" class="headerlink" title="CAP理论是什么？"></a>CAP理论是什么？</h5><ul>
<li><span style = "color:red"><strong>C</strong>(Consistency, 一致性)</span>：读操作是否总能读到前一个写操作的结果 [某节点获得的数据都是一样的] 在本项目中一致性位于Session Storage</li>
<li><span style = "color:red"><strong>A</strong>(Availability, 可用性)</span>：非故障节点应该在合理的时间内作出合理的响应(不是错误或超时的响应),但是可能<strong>不是最新的数据</strong>。 [某个挂掉了 其他还可以用]</li>
<li><span style = "color:red"><strong>P</strong>(Partition tolerance, 分区容错)</span>：当出现网络分区现象后，系统能够继续运行。分区容错性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/793eb4ab3003af82869b186bcc016fcb8c2c2f5b/data/CAP%E5%AE%9A%E7%90%86.jpg"></p>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
<li><strong>CP</strong>：Redis【保证数据一致性 一定要满足C】</li>
<li><strong>AP</strong>：会采用弱一致性 淘宝下单只需要知道下单就好 数量一致性商家可以慢慢调整</li>
<li><strong>CA</strong>：单体存在架构、关系型架构</li>
</ul>
<p>在本项目中如果采用弱一致性：可以不把用户存到session Storage 直接显示</p>
<h3 id="集群、分布式、微服务的区别"><a href="#集群、分布式、微服务的区别" class="headerlink" title="集群、分布式、微服务的区别"></a>集群、分布式、微服务的区别</h3><h5 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h5><ul>
<li>分布式：一个业务分拆<strong>多个子业务</strong>，部署在不同的服务器上 [服务器之间要通信]</li>
<li>集群：<strong>同一个</strong>业务，部署在多个服务器上 [五台机器可以不通信]</li>
</ul>
<h5 id="集群和微服务的区别"><a href="#集群和微服务的区别" class="headerlink" title="集群和微服务的区别"></a>集群和微服务的区别</h5><ul>
<li>集群：分散<strong>压力</strong></li>
<li>微服务：分散<strong>压力</strong></li>
</ul>
<h5 id="微服务和分布式的区别"><a href="#微服务和分布式的区别" class="headerlink" title="微服务和分布式的区别"></a>微服务和分布式的区别</h5><ul>
<li><p>微服务是<strong>架构设计</strong>方式 [逻辑架构]</p>
</li>
<li><p>分布式是<strong>系统部署</strong>方式 [物理架构]</p>
</li>
<li><p>微服务：是一种架构方式 [大的服务拆成小的服务 每个服务独立开发测试]</p>
</li>
<li><p>分布式：主要强调部署的方式</p>
</li>
</ul>
<h3 id="用户会话拦截器-必须用户登陆后才可以用其他界面"><a href="#用户会话拦截器-必须用户登陆后才可以用其他界面" class="headerlink" title="用户会话拦截器 [必须用户登陆后才可以用其他界面]"></a>用户会话拦截器 [必须用户登陆后才可以用其他界面]</h3><pre><code class="java">service-api  com/imooc/api/interceptors/UserTokenInterceptor.java
package com.imooc.api.interceptors;

import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class UserTokenInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    /**
     * 拦截请求，访问controller之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 有些接口同时会給安卓 H5等 所以不去cookie拿
        String userId = request.getHeader(&quot;headerUserId&quot;);
        String userToken = request.getHeader(&quot;headerUserToken&quot;);

        // 判断是否放行
        boolean run = verifyUserIdToken(userId, userToken, REDIS_USER_TOKEN);

        /**
         * false：请求被拦截
         * true：请求通过验证，放行
         */
        return true;
    &#125;


    /**
     * 请求访问到controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    /**
     * 请求访问到controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.api.interceptors;

import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;

public class BaseInterceptor &#123;
    @Autowired
    private RedisOperator redis;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写

    public boolean verifyUserIdToken(String id,
                                     String token,
                                     String redisKeyPrefix)&#123; //redis..前缀
        if (StringUtils.isNotBlank(id) &amp;&amp; StringUtils.isNotBlank(token))&#123;
            String redisToken = redis.get(redisKeyPrefix + &quot;:&quot; + id);
            if (StringUtils.isBlank(id))&#123;
                GraceException.display(ResponseStatusEnum.UN_LOGIN);
                return false;
            &#125; else &#123;
                if (!redisToken.equalsIgnoreCase(token))&#123;//是否和传入token一致
                    GraceException.display(ResponseStatusEnum.TICKET_INVALID);
                    return false;
                &#125;
            &#125;
        &#125;else &#123;
            GraceException.display(ResponseStatusEnum.UN_LOGIN);
            return false;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;);
    &#125;
&#125;
/*
在你的 Spring 应用程序中，InterceptorConfig 类中的 @Bean 注解用于定义 PassportInterceptor 和 UserTokenInterceptor 的 bean。这使这些拦截器对象在 Spring 上下文中可用，以便进行依赖注入。

删除 @Bean 注解后会出现错误 Autowired members must be defined in valid Spring bean (@Component|@Service|...)，这是因为 BaseInterceptor 类中有一个需要由 Spring 注入的依赖 (RedisOperator redis)。要让 Spring 执行依赖注入，包含 @Autowired 注解的类必须是一个由 Spring 管理的 bean，可以通过 @Component、@Service、@Controller 等注解或在配置类中通过 @Bean 来定义。

这里是对 @Bean 的作用以及为什么删除它会导致错误的详细解释：

使用 @Bean 定义 Bean：
在 InterceptorConfig 类中，@Bean 注解定义了 PassportInterceptor 和 UserTokenInterceptor 作为 Spring 的 bean。这使得它们在整个应用程序中可用于依赖注入。

依赖注入的要求：
BaseInterceptor 类中使用了 @Autowired 注解来注入 RedisOperator。要使这个注入有效，BaseInterceptor 必须是一个 Spring 管理的 bean。而 @Bean 注解在配置类中定义了这些拦截器，使得 Spring 可以管理它们，并在需要时进行依赖注入。

如果删除了 @Bean 注解，PassportInterceptor 和 UserTokenInterceptor 将不再是 Spring 管理的 bean，从而导致在它们内部或相关联的类（如 BaseInterceptor）中的依赖无法被注入。这就是为什么删除 @Bean 注解后会出现 Autowired members must be defined in valid Spring bean (@Component|@Service|...) 错误的原因。
*/
</code></pre>
<h3 id="用户状态激活拦截器"><a href="#用户状态激活拦截器" class="headerlink" title="用户状态激活拦截器"></a>用户状态激活拦截器</h3><pre><code class="java">service-api  com/imooc/api/interceptors/UseActiveInterceptor.java
package com.imooc.api.interceptors;

import com.imooc.enums.UserStatus;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.utils.JsonUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 用户激活状态检测拦截器
 * 发文章，修改文章，删除文章，发表评论，查看评论等
 * 这些接口都是要在用户激活后才能进行操作
 * 否则需要提示用户前往[账号设置]去修改信息
 */
    public class UseActiveInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    /**
     * 拦截请求，访问controller之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 有些接口同时会給安卓 H5等 所以不去cookie拿
        String userId = request.getHeader(&quot;headerUserId&quot;);
        String userJson = redis.get(REDIS_USER_INFO + &quot;:&quot; + userId);
        AppUser user = null;
        if (StringUtils.isNotBlank(userJson))&#123;
            user = JsonUtils.jsonToPojo(userJson, AppUser.class);
        &#125; else &#123;
            GraceException.display(ResponseStatusEnum.UN_LOGIN);
        &#125;
        if (user.getActiveStatus() == null || user.getActiveStatus() != UserStatus.ACTIVE.type)&#123;
            GraceException.display(ResponseStatusEnum.USER_INACTIVE_ERROR);
            return false;
            //随后去拦截器里进行@Bean注册 [下下个代码就是]
        &#125;

        /**
         * false：请求被拦截
         * true：请求通过验证，放行
         */
        return true;
    &#125;

    /**
     * 请求访问到controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
    &#125;
    /**
     * 请求访问到controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
//[加一行redis.set(REDIS_USER_INFO+&quot;:&quot;+user.getId(), JsonUtils.objectToJson(user));]
@Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result, HttpServletRequest request, HttpServletResponse response) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;

        //2.查询数据库,判断该用户注册
        AppUser user = userService.queryMobileIsExist(mobile);
        if (user != null &amp;&amp; user.getActiveStatus() == UserStatus.FROZEN.type)&#123;
            //如果用户不为空，并且状态为冻结，则直接抛出异常，禁止登录
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_FROZEN);
        &#125;else if (user == null)&#123;
            //如果用户没有注册过，则为null，需要注册信息入库
            user = userService.createUser(mobile);
        &#125;

        // 3.保存用户分布式会话的相关操作
        int userActiveStatus = user.getActiveStatus();
        if (userActiveStatus != UserStatus.FROZEN.type)&#123;
            String uToken = UUID.randomUUID().toString();
            redis.set(REDIS_USER_TOKEN+&quot;:&quot;+user.getId(),uToken);//BaseController里面 保存token到redis
            redis.set(REDIS_USER_INFO+&quot;:&quot;+user.getId(), JsonUtils.objectToJson(user));

            //保存用户id和token到cookie中 设计一个request response 回到PassportControllerApi
            setCookie(request, response,&quot;utoken&quot;,uToken,COOKIE_MONTH);
            setCookie(request, response,&quot;uid&quot;,user.getId(),COOKIE_MONTH);
        &#125;
        // 4.用户登录或注册成功以后，需要删除redis中的短信验证码，验证码只能使用一次，用过则作废
//        redis.del(MOBILE_SMSCODE + &quot;:&quot; + mobile);
        // 5.返回用户状态 返回前端看
        return GraceJSONResult.ok(userActiveStatus);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UseActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UseActiveInterceptor useActiveInterceptor()&#123;
        return new UseActiveInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;);
//        registry.addInterceptor(userTokenInterceptor())
//                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="AOP警告日志监控与sql打印-切面AOP通知编程"><a href="#AOP警告日志监控与sql打印-切面AOP通知编程" class="headerlink" title="AOP警告日志监控与sql打印 [切面AOP通知编程]"></a>AOP警告日志监控与sql打印 [切面AOP通知编程]</h3><pre><code class="xml">dev-common 引入aop依赖
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/aspect/ServiceLogAspect.java
package com.imooc.api.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class ServiceLogAspect &#123;
    final static Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);
    /**
     * AOP通知：
     * 1.前置通知
     * 2.后置通知
     * 3.环绕通知 ★★
     * 4.异常通知
     * 5.最终通知
     */
    //*是返回所有类型 匹配包的位置 *.* = 任意文件.任意后缀  (..)是任意类和任意方法
    @Around(&quot;execution(* com.imooc.*.service.impl..*.*(..))&quot;)
    public Object recordTimeOfService(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        logger.info(&quot;==== 开始执行 &#123;&#125;.&#123;&#125; ====&quot;,
                joinPoint.getTarget().getClass(),
                joinPoint.getSignature().getName());
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long end = System.currentTimeMillis();
        long takeTime = end - start;
        if (takeTime &gt; 3000)&#123;
            logger.error(&quot;当前执行耗时：&#123;&#125;&quot;,takeTime);
        &#125;else if (takeTime &gt; 2000)&#123;
            logger.warn(&quot;当前执行耗时：&#123;&#125;&quot;,takeTime);
        &#125;else &#123;
            logger.info(&quot;当前执行耗时：&#123;&#125;&quot;,takeTime);
        &#125;
        return result;
    &#125;
&#125;
====================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html
提交信息 看后台Terminal
</code></pre>
<pre><code class="yml">service-user  application-dev.yml #增加一个open mybatis log in dev
  server:
  port: 8003

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
# open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# setup CN from java, This is resource
website:
  domain-name: imoocnews.com

===================================================================
如果在未来发生sql错误可以通过sql输出来找到sql语句从而放入运行检查错误 (21 28行)
JDBC Connection [HikariProxyConnection@2054571226 wrapping org.mariadb.jdbc.MariaDbConnection@4b4b68f8] will not be managed by Spring
==&gt;  Preparing: UPDATE app_user SET nickname = ?,face = ?,realname = ?,email = ?,sex = ?,birthday = ?,province = ?,city = ?,district = ?,active_status = ?,updated_time = ? WHERE id = ? 
==&gt; Parameters: 15027597319(String), https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg(String), 小宝宝的小潘潘(String), 390415030@qq.com(String), 1(Integer), 2024-07-06 00:00:00.0(Timestamp), 河北(String), 唐山市(String), 丰润区(String), 1(Integer), 2024-07-07 22:41:09.862(Timestamp), 240629F21AK1BHX4(String)
&lt;==    Updates: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@9176eb0]
Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@65bd9477] was not registered for synchronization because synchronization is not active
JDBC Connection [HikariProxyConnection@1798162927 wrapping org.mariadb.jdbc.MariaDbConnection@4b4b68f8] will not be managed by Spring
==&gt;  Preparing: SELECT id,mobile,nickname,face,realname,email,sex,birthday,province,city,district,active_status,total_income,created_time,updated_time FROM app_user WHERE id = ? 
==&gt; Parameters: 240629F21AK1BHX4(String)
&lt;==    Columns: id, mobile, nickname, face, realname, email, sex, birthday, province, city, district, active_status, total_income, created_time, updated_time
&lt;==        Row: 240629F21AK1BHX4, 15027597319, 15027597319, https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg, 小宝宝的小潘潘, 390415030@qq.com, 1, 2024-07-06, 河北, 唐山市, 丰润区, 1, 0, 2024-06-29 19:43:07.0, 2024-07-07 22:41:09.0
&lt;==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@65bd9477]
41:10.009 [http-nio-8003-exec-3] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
41:10.010 [http-nio-8003-exec-3] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
41:10.460 [http-nio-8003-exec-3] INFO  c.imooc.api.aspect.ServiceLogAspect - 当前执行耗时：601
</code></pre>
<h3 id="退出登录、注销会话"><a href="#退出登录、注销会话" class="headerlink" title="退出登录、注销会话"></a>退出登录、注销会话</h3><pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
//用户登录信息的redis和cookies清除
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO
            , BindingResult result, HttpServletRequest request, HttpServletResponse response);
    //完成之后 去BaseController里面写一个setCookie()方便都可以用

    @ApiOperation(value = &quot;用户退出登录&quot;,notes = &quot;用户退出登录&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/logout&quot;)
    public GraceJSONResult logout(@RequestParam String userId,
                                  HttpServletRequest request,
                                  HttpServletResponse response);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
@Override
    public GraceJSONResult logout(String userId,
                                  HttpServletRequest request,
                                  HttpServletResponse response)&#123;
        redis.del(REDIS_USER_TOKEN + &quot;:&quot; + userId);
        //USER_INFO可以不用删 可能后面会查询 没有清除cookie只有重新设置时间为0
        setCookie(request, response, &quot;utoken&quot;,&quot;&quot;,COOKIE_DELETE);
        setCookie(request, response, &quot;uid&quot;,&quot;&quot;,COOKIE_DELETE);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<h3 id="FastDFS架构原理与上传下载流程解析"><a href="#FastDFS架构原理与上传下载流程解析" class="headerlink" title="FastDFS架构原理与上传下载流程解析"></a>FastDFS架构原理与上传下载流程解析</h3><h5 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h5><ul>
<li><p>传统服务器存储</p>
</li>
<li><h5 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h5></li>
<li><p>OSS</p>
</li>
<li><p>GridFS</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/584d8cb5b41ffa10cb9b5303c13b5782e1130889/data/FastDFS%E6%9E%B6%E6%9E%84.png"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f4d7477aa2b6843ddfb11af2cbbe2424a25e4b39/data/FastDFS%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="配置FastDFS环境准备工作"><a href="#配置FastDFS环境准备工作" class="headerlink" title="配置FastDFS环境准备工作"></a>配置FastDFS环境准备工作</h3><h6 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h6><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Centos</td>
<td>7.x</td>
</tr>
<tr>
<td>libfastcommon-1.0.42.tar.gz</td>
<td>FastDFS分离出的一些公用函数包</td>
</tr>
<tr>
<td>FastDFS</td>
<td>FastDFS本体</td>
</tr>
<tr>
<td>fastdfs-nginx-module-1.22.tar.gz</td>
<td>FastDFS和nginx的关联模块</td>
</tr>
<tr>
<td>nginx</td>
<td>nginx1.15.4</td>
</tr>
</tbody></table>
<h6 id="它跟我说要准备两个虚拟机-tracker-和-storage-版本都是CentOS-7-x"><a href="#它跟我说要准备两个虚拟机-tracker-和-storage-版本都是CentOS-7-x" class="headerlink" title="它跟我说要准备两个虚拟机[tracker 和 storage 版本都是CentOS 7.x]"></a>它跟我说要准备两个虚拟机[tracker 和 storage 版本都是CentOS 7.x]</h6><pre><code class="java">//创建一个FastDFS文件夹
[imooc@imooc FastDFS]$ ll
总用量 1980
-rw-rw-r--. 1 imooc imooc  800157 7月   9 15:53 fastdfs-6.04.tar.gz
-rw-rw-r--. 1 imooc imooc   19952 7月   9 15:53 fastdfs-nginx-module-1.22.tar.gz
-rw-rw-r--. 1 imooc imooc  164704 7月   9 15:53 libfastcommon-1.0.42.tar.gz
-rw-rw-r--. 1 imooc imooc 1032630 7月   9 15:53 nginx-1.16.1.tar.gz
[imooc@imooc FastDFS]$ tar -zxvf libfastcommon-1.0.42.tar.gz 
[imooc@imooc FastDFS]$ cd libfastcommon-1.0.42/
[imooc@imooc libfastcommon-1.0.42]$ ll
总用量 32
drwxrwxr-x. 2 imooc imooc   114 12月  5 2019 doc
-rw-rw-r--. 1 imooc imooc 10054 12月  5 2019 HISTORY
-rw-rw-r--. 1 imooc imooc   674 12月  5 2019 INSTALL
-rw-rw-r--. 1 imooc imooc  1607 12月  5 2019 libfastcommon.spec
-rwxrwxr-x. 1 imooc imooc  3253 12月  5 2019 make.sh
drwxrwxr-x. 2 imooc imooc   191 12月  5 2019 php-fastcommon
-rw-rw-r--. 1 imooc imooc  2776 12月  5 2019 README
drwxrwxr-x. 3 imooc imooc  4096 12月  5 2019 src
[imooc@imooc libfastcommon-1.0.42]$ ./make.sh
[imooc@imooc libfastcommon-1.0.42]$ sudo ./make.sh install
//安装解压包的本体
[imooc@imooc FastDFS]$ tar -zxvf fastdfs-6.04.tar.gz 
[imooc@imooc FastDFS]$ cd fastdfs-6.04/
[imooc@imooc fastdfs-6.04]$ ./make.sh
[imooc@imooc fastdfs-6.04]$ sudo ./make.sh install
[imooc@imooc fastdfs-6.04]$ cd /usr/bin
[imooc@imooc bin]$ ls fdfs_*
fdfs_appender_test   fdfs_download_file        fdfs_test
fdfs_appender_test1  fdfs_file_info            fdfs_test1
fdfs_append_file     fdfs_monitor              fdfs_trackerd
fdfs_crc32           fdfs_regenerate_filename  fdfs_upload_appender
fdfs_delete_file     fdfs_storaged             fdfs_upload_file
[imooc@imooc bin]$ cd /etc/fdfs/
[imooc@imooc fdfs]$ ll
总用量 28 //这些都是配置文件 如果要修改则需要拷贝一份新鲜的
-rw-r--r--. 1 root root  1834 7月   9 16:02 client.conf.sample
-rw-r--r--. 1 root root 10085 7月   9 16:02 storage.conf.sample
-rw-r--r--. 1 root root   527 7月   9 16:02 storage_ids.conf.sample
-rw-r--r--. 1 root root  8038 7月   9 16:02 tracker.conf.sample

[imooc@imooc FastDFS]$ cd fastdfs-6.04/
[imooc@imooc fastdfs-6.04]$ cd conf/
[imooc@imooc conf]$ ll
总用量 88
-rw-rw-r--. 1 imooc imooc 23981 12月  5 2019 anti-steal.jpg
-rw-rw-r--. 1 imooc imooc  1834 12月  5 2019 client.conf
-rw-rw-r--. 1 imooc imooc   955 12月  5 2019 http.conf
-rw-rw-r--. 1 imooc imooc 31172 12月  5 2019 mime.types
-rw-rw-r--. 1 imooc imooc 10085 12月  5 2019 storage.conf
-rw-rw-r--. 1 imooc imooc   527 12月  5 2019 storage_ids.conf
-rw-rw-r--. 1 imooc imooc  8038 12月  5 2019 tracker.conf
//拷贝到etc下  安装前的准备工作
[imooc@imooc conf]$ sudo cp * /etc/fdfs/
[imooc@imooc conf]$ cd /etc/fdfs
[imooc@imooc fdfs]$ ll
总用量 116
-rw-r--r--. 1 root root 23981 7月   9 16:06 anti-steal.jpg
-rw-r--r--. 1 root root  1834 7月   9 16:06 client.conf
-rw-r--r--. 1 root root  1834 7月   9 16:02 client.conf.sample
-rw-r--r--. 1 root root   955 7月   9 16:06 http.conf
-rw-r--r--. 1 root root 31172 7月   9 16:06 mime.types
-rw-r--r--. 1 root root 10085 7月   9 16:06 storage.conf
-rw-r--r--. 1 root root 10085 7月   9 16:02 storage.conf.sample
-rw-r--r--. 1 root root   527 7月   9 16:06 storage_ids.conf
-rw-r--r--. 1 root root   527 7月   9 16:02 storage_ids.conf.sample
-rw-r--r--. 1 root root  8038 7月   9 16:06 tracker.conf
-rw-r--r--. 1 root root  8038 7月   9 16:02 tracker.conf.sample
</code></pre>
<h3 id="配置tracker服务-一个虚拟机"><a href="#配置tracker服务-一个虚拟机" class="headerlink" title="配置tracker服务 [一个虚拟机]"></a>配置tracker服务 [一个虚拟机]</h3><pre><code class="java">//根据配置文件去区分是哪个服务
[imooc@imooc fdfs]$ cd /etc/fdfs
[imooc@imooc fdfs]$ ll
总用量 116
-rw-r--r--. 1 root root 23981 7月   9 16:06 anti-steal.jpg
-rw-r--r--. 1 root root  1834 7月   9 16:06 client.conf
-rw-r--r--. 1 root root  1834 7月   9 16:02 client.conf.sample
-rw-r--r--. 1 root root   955 7月   9 16:06 http.conf
-rw-r--r--. 1 root root 31172 7月   9 16:06 mime.types
-rw-r--r--. 1 root root 10085 7月   9 16:06 storage.conf
-rw-r--r--. 1 root root 10085 7月   9 16:02 storage.conf.sample
-rw-r--r--. 1 root root   527 7月   9 16:06 storage_ids.conf
-rw-r--r--. 1 root root   527 7月   9 16:02 storage_ids.conf.sample
-rw-r--r--. 1 root root  8038 7月   9 16:06 tracker.conf
-rw-r--r--. 1 root root  8038 7月   9 16:02 tracker.conf.sample
[imooc@imooc fdfs]$ sudo vim tracker.conf  
//里面的port=22122 bind_addr= 计算机节点 这些不动
//修改里面的base_path=/home/yuqing/fastdfs 
    //修改为→ /usr/local/fastdfs/tracker
[imooc@imooc fdfs]$ mkdir /usr/local/fastdfs/tracker -p //-p后面文件夹做递归创建
[imooc@imooc fdfs]$ sudo /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf //当成配置文件加进去 ★★★★★★★★★★★★★★★★★★
[imooc@imooc fdfs]$ ps -ef|grep tracker
root       6254      1  0 18:31 ?        00:00:00 /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf
imooc      6268   3011  0 18:31 pts/0    00:00:00 grep --color=auto tracker
</code></pre>
<h3 id="配置storage服务-另一个虚拟机"><a href="#配置storage服务-另一个虚拟机" class="headerlink" title="配置storage服务 [另一个虚拟机]"></a>配置storage服务 [另一个虚拟机]</h3><pre><code class="java">[storage@imooc fdfs]$ cd /etc/fdfs/
[storage@imooc fdfs]$ sudo vim storage.conf
//[修改后] group_name=imooc 
//[修改后] bath_path=/usr/local/fastdfs/storage
[storage@imooc fdfs]$ sudo mkdir /usr/local/fastdfs/storage -p
[storage@imooc fdfs]$ cd /usr/local/
[storage@imooc local]$ ll
[storage@imooc local]$ cd fastdfs/
[storage@imooc fastdfs]$ ll
[storage@localhost fastdfs]$ ll
总用量 0
drwxr-xr-x. 2 root root 6 7月   9 18:38 storage
[storage@localhost fastdfs]$ cd /etc/fdfs/  //接着修改storage
[storage@imooc fdfs]$ sudo vim storage.conf
//[修改后] store_path0=/usr/local/fastdfs/storage
//配置到tracker的ip地址[修改后] tracker_server=192.168.170.135:22122
/ ‘/8888’  http.server_port=8888 是web的相关端口号
[storage@localhost fdfs]$ sudo /usr/bin/fdfs_storaged /etc/fdfs/storage.conf //★★★★
★一定要先启动tracker 再去启动storage 不然service发不过去★
</code></pre>
<pre><code class="java">//配置客户端做上传动作
[imooc@imooc ~]$ cd /etc/fdfs
[storage@localhost fdfs]$ pwd
/etc/fdfs
[storage@localhost fdfs]$ sudo vim client.conf
//[修改后]base_path=/usr/local/fastdfs/client
[storage@localhost fdfs]$ sudo mkdir /usr/local/fastdfs/client
[storage@localhost fdfs]$ cd /usr/local/fastdfs
[storage@localhost fastdfs]$ ll
总用量 0
drwxr-xr-x. 2 root root  6 7月   9 19:26 client
drwxr-xr-x. 4 root root 30 7月   9 19:04 storage
[storage@localhost fastdfs]$ cd /etc/fdfs/
[storage@localhost fdfs]$ sudo vim client.conf
//[修改后]tracker_server=192.168.170.135:22122
[storage@localhost fdfs]$ cd /usr/bin
[storage@localhost bin]$ ls fdfs*
fdfs_appender_test   fdfs_download_file        fdfs_test
fdfs_appender_test1  fdfs_file_info            fdfs_test1
fdfs_append_file     fdfs_monitor              fdfs_trackerd
fdfs_crc32           fdfs_regenerate_filename  fdfs_upload_appender
fdfs_delete_file     fdfs_storaged             fdfs_upload_file
//fdfs_test在命令行去测试
[storage@localhost bin]$ cd /home/
[storage@localhost home]$ cd /usr/local/fastdfs/storage/
[storage@localhost storage]$ cd data
[storage@localhost data]$ cd 00
[storage@localhost data]$ ll   【里面很多十六进制数据】
[storage@localhost data]$ cd 00 
[storage@localhost data]$ ll   //【里面没有数据 上传图片到这里查看是否成功】
///home/storage 这里有一张测试图片log.png [自行添加]
[storage@localhost 00]$ pwd
/usr/local/fastdfs/storage/data/00/00
[storage@localhost 00]$ cd /etc/fdfs
[storage@localhost ~]$ cd /etc/fdfs/
[storage@localhost fdfs]$ cd /usr/bin/
[storage@localhost bin]$ ls fdfs*
fdfs_appender_test   fdfs_download_file      //fdfs_test
fdfs_appender_test1  fdfs_file_info            fdfs_test1
fdfs_append_file     fdfs_monitor              fdfs_trackerd
fdfs_crc32           fdfs_regenerate_filename  fdfs_upload_appender
fdfs_delete_file     fdfs_storaged             fdfs_upload_file
[storage@localhost bin]$ ./fdfs_test /etc/fdfs/client.conf upload /home/storage/log.png 
/*
This is FastDFS client test program v6.04

Copyright (C) 2008, Happy Fish / YuQing

FastDFS may be copied only under the terms of the GNU General
Public License V3, which may be found in the FastDFS source kit.
Please visit the FastDFS Home Page http://www.fastken.com/ 
for more detail.

[2024-07-09 19:39:25] DEBUG - base_path=/usr/local/fastdfs/client, connect_timeout=10, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0

tracker_query_storage_store_list_without_group: 
    server 1. group_name=, ip_addr=192.168.170.136, port=23000

group_name=imooc【企业简写】, ip_addr=192.168.170.136, port=23000
storage_upload_by_filename
group_name=imooc, remote_filename=M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png 
【remote_filename：重组路径】【因为还没有发布文件服务 所以无法直接查看文件】
source ip address: 192.168.170.136
file timestamp=2024-07-09 19:39:25
file size=12618
file crc32=630904148
example file url: http://192.168.170.136/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
storage_upload_slave_by_filename
group_name=imooc, remote_filename=M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
source ip address: 192.168.170.136
file timestamp=2024-07-09 19:39:25
file size=12618
file crc32=630904148
example file url: http://192.168.170.136/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
 */
[storage@localhost bin]$ cd /usr/local/fastdfs/storage/data/
[storage@localhost data]$ cd 00
[storage@localhost 00]$ cd 00
[storage@localhost 00]$ ll
总用量 40
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png-m
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png-m
</code></pre>
<h3 id="安装Nginx提供Web服务-通过浏览器访问到文件"><a href="#安装Nginx提供Web服务-通过浏览器访问到文件" class="headerlink" title="安装Nginx提供Web服务 [通过浏览器访问到文件]"></a>安装Nginx提供Web服务 [通过浏览器访问到文件]</h3><h6 id="Nginx是反向代理服务器可以做集群-也可以控制多个虚拟主机"><a href="#Nginx是反向代理服务器可以做集群-也可以控制多个虚拟主机" class="headerlink" title="Nginx是反向代理服务器可以做集群 也可以控制多个虚拟主机"></a>Nginx是反向代理服务器可以做集群 也可以控制多个虚拟主机</h6><pre><code class="java">-rw-rw-r--. 1 storage storage 142245547 7月  10 15:32 jdk-7u75-linux-x64.tar.gz
-rw-rw-r--. 1 storage storage   1032630 7月  10 15:33 nginx-1.16.1.tar.gz
//[storage@localhost ~]$ sudo yum install gcc-c++
已加载插件：fastestmirror, langpacks
Determining fastest mirrors
//[storage@localhost ~]$ sudo yum install -y pcre pcre-devel
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
//[storage@localhost ~]$ sudo yum install -y zlib zlib-devel
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
//[storage@localhost ~]$ sudo yum install -y openssl openssl-devel
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
//[storage@localhost ~]$ tar -zxvf nginx-1.16.1.tar.gz
nginx-1.16.1.tar.gz
//[storage@localhost ~]$ cd nginx-1.16.1.tar.gz
[storage@localhost nginx-1.16.1]$ sudo mkdir /var/temp/nginx -p
//创建所需的临时目录：
sudo mkdir -p /var/temp/nginx/client
sudo mkdir -p /var/temp/nginx/proxy
sudo mkdir -p /var/temp/nginx/fastcgi
sudo mkdir -p /var/temp/nginx/uwsgi
sudo mkdir -p /var/temp/nginx/scgi
[storage@localhost nginx-1.16.1]$ ./configure \  //【预配置】
&gt; --prefix=/usr/local/nginx \
&gt; --pid-path=/var/run/nginx/nginx.pid \
&gt; --lock-path=/var/lock/nginx.lock \
&gt; --error-log-path=/var/log/nginx/error.log \
&gt; --http-log-path=/var/log/nginx/access.log \
&gt; --with-http_gzip_static_module \
&gt; --http-client-body-temp-path=/var/temp/nginx/client \
&gt; --http-proxy-temp-path=/var/temp/nginx/proxy \
&gt; --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
&gt; --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
&gt; --http-scgi-temp-path=/var/temp/nginx/scgi
[storage@localhost nginx-1.16.1]$ make  //【编译】
/* linux中的网络不可达
如果镜像出了问题 一定要换一下镜像配置
1. 编辑 CentOS 的 YUM 配置文件：
编辑 /etc/yum.repos.d/CentOS-Base.repo 文件：

复制代码
sudo vi /etc/yum.repos.d/CentOS-Base.repo

2. 使用以下内容更新 CentOS-Base.repo 文件：
复制代码
[base]
name=CentOS-$releasever - Base
baseurl=http://vault.centos.org/7.9.2009/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

[updates]
name=CentOS-$releasever - Updates
baseurl=http://vault.centos.org/7.9.2009/updates/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

[extras]
name=CentOS-$releasever - Extras
baseurl=http://vault.centos.org/7.9.2009/extras/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
*/
[storage@localhost nginx-1.16.1]$ sudo make install
[storage@localhost nginx-1.16.1]$ cd /usr/local
[storage@localhost local]$ ll
总用量 0
drwxr-xr-x. 2 root root  6 4月  11 2018 bin
drwxr-xr-x. 2 root root  6 4月  11 2018 etc
drwxr-xr-x. 4 root root 35 7月   9 19:26 fastdfs
drwxr-xr-x. 2 root root  6 4月  11 2018 games
drwxr-xr-x. 2 root root  6 4月  11 2018 include
drwxr-xr-x. 2 root root  6 4月  11 2018 lib
drwxr-xr-x. 2 root root  6 4月  11 2018 lib64
drwxr-xr-x. 2 root root  6 4月  11 2018 libexec
drwxr-xr-x. 5 root root 42 7月  10 16:55 nginx
drwxr-xr-x. 2 root root  6 4月  11 2018 sbin
drwxr-xr-x. 5 root root 49 7月   9 17:16 share
drwxr-xr-x. 2 root root  6 4月  11 2018 src
[storage@localhost local]$ cd nginx/
[storage@localhost nginx]$ ll
总用量 4
drwxr-xr-x. 2 root root 4096 7月  10 16:55 conf
drwxr-xr-x. 2 root root   40 7月  10 16:55 html
drwxr-xr-x. 2 root root   19 7月  10 16:55 sbin
[storage@localhost nginx]$ cd sbin/
[storage@localhost sbin]$ ll
总用量 3768
-rwxr-xr-x. 1 root root 3857144 7月  10 16:55 nginx
[storage@localhost sbin]$ sudo ./nginx
[storage@localhost sbin]$ ps -ef|grep nginx
root       6642      1  0 16:58 ?        00:00:00 nginx: master process ./nginx
nobody     6643   6642  0 16:58 ?        00:00:00 nginx: worker process
storage    6651   2975  0 16:58 pts/0    00:00:00 grep --color=auto nginx

// 在浏览器输入：http://192.168.170.136/ 【如果没显示应该是虚拟机的防火墙拦截 可以禁止防火墙】
Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.

For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.

Thank you for using nginx.

[storage@localhost nginx]$ cd html
[storage@localhost html]$ ll
总用量 8
-rw-r--r--. 1 root root 494 7月  10 16:55 50x.html
-rw-r--r--. 1 root root 612 7月  10 16:55 index.html

[storage@localhost html]$ sudo ../sbin/nginx -t //【测试刚刚的步骤是否正确】
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
</code></pre>
<h3 id="整合Nginx实现文件服务器"><a href="#整合Nginx实现文件服务器" class="headerlink" title="整合Nginx实现文件服务器"></a>整合Nginx实现文件服务器</h3><pre><code class="java">[storage@localhost FastDFS]$ tar -zxvf fastdfs-nginx-module-1.22.tar.gz 
fastdfs-nginx-module-1.22/
fastdfs-nginx-module-1.22/HISTORY
fastdfs-nginx-module-1.22/INSTALL
fastdfs-nginx-module-1.22/src/
fastdfs-nginx-module-1.22/src/common.c
fastdfs-nginx-module-1.22/src/common.h
fastdfs-nginx-module-1.22/src/config
fastdfs-nginx-module-1.22/src/mod_fastdfs.conf
fastdfs-nginx-module-1.22/src/ngx_http_fastdfs_module.c
[storage@localhost FastDFS]$ cd fastdfs-nginx-module-1.22/
[storage@localhost fastdfs-nginx-module-1.22]$ ll
总用量 8
-rw-rw-r--. 1 storage storage 3036 11月 19 2019 HISTORY
-rw-rw-r--. 1 storage storage 2001 11月 19 2019 INSTALL
drwxrwxr-x. 2 storage storage  109 11月 19 2019 src
[storage@localhost fastdfs-nginx-module-1.22]$ cd src/
[storage@localhost src]$ sudo cp mod_fastdfs.conf /etc/fdfs/
[storage@localhost ~]$ cd /etc/fdfs/
[storage@localhost fdfs]$ sudo vim mod_fastdfs.conf 
//【布置存储路径】
/*
store_path0=/usr/local/fastdfs/storage
tracker_server=192.168.170.135:22122
group_name=imooc
url_have_group_name = true
base_path=/usr/local/fastdfs/tmp
*/
[storage@localhost FastDFS]$ cd fastdfs-nginx-module-1.22/
[storage@localhost fastdfs-nginx-module-1.22]$ cd src/
[storage@localhost src]$ vim config
/local 把带有local的都删掉
[storage@localhost ~]$ cd nginx-1.16.1/
 [storage@localhost nginx-1.16.1]$ 
./configure \
&gt; --prefix=/usr/local/nginx \
&gt; --pid-path=/var/run/nginx/nginx.pid \
&gt; --lock-path=/var/lock/nginx.lock \
&gt; --error-log-path=/var/log/nginx/error.log \
&gt; --http-log-path=/var/log/nginx/access.log \
&gt; --with-http_gzip_static_module \
&gt; --http-client-body-temp-path=/var/temp/nginx/client \
&gt; --http-proxy-temp-path=/var/temp/nginx/proxy \
&gt; --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
&gt; --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
&gt; --http-scgi-temp-path=/var/temp/nginx/scgi \
&gt; --add-module=/home/storage/FastDFS/fastdfs-nginx-module-1.22/src
[storage@localhost nginx-1.16.1]$ sudo make &amp;&amp; sudo make install
[storage@localhost nginx-1.16.1]$ cd /usr/local/nginx/
[storage@localhost nginx]$ cd conf/
[storage@localhost conf]$ sudo vim nginx.conf
/*
server &#123;
        listen       8888;
        server_name  localhost;
        location ~/group[0-9]/ &#123;
        ngx_fastdfs_module;
        &#125;
        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / &#123;
            root   html;
            index  index.html index.htm;
        &#125;

*/
[storage@localhost conf]$ vim /etc/fdfs/tracker.conf
/http.service_port:8080
[storage@localhost conf]$ sudo vim nginx.conf //★★★★★★
/*
server &#123;
        listen       8888;
        server_name  localhost;
        location /imooc/M00 &#123;
            ngx_fastdfs_module;
        &#125;
        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / &#123;
            root   html;
            index  index.html index.htm;
        &#125;
&#125;
*/
[storage@localhost conf]$ sudo ../sbin/nginx -t //测试一下有无问题
ngx_http_fastdfs_set pid=6143
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
[storage@localhost conf]$ sudo ../sbin/nginx -s reload //重新加载
ngx_http_fastdfs_set pid=6436

[storage@localhost conf]$ cd /usr/local/fastdfs/storage/
[storage@localhost storage]$ cd data
[storage@localhost data]$ cd 00/00
总用量 40
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png-m
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png-m
http://192.168.170.136:8888/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png


//查看错误日志 ★★★【sudo tail -n 50 /var/log/nginx/error.log】★★★
/*
2. 重新加载 systemd 并启动 Nginx
重新加载 systemd：
复制代码
sudo systemctl daemon-reload
启动 Nginx：

sh
复制代码
sudo systemctl start nginx
设置开机自启动：

sh
复制代码
sudo systemctl enable nginx
检查 Nginx 服务状态：

sh
复制代码
sudo systemctl status nginx
*/
[storage@localhost conf]$ sudo vim /etc/fdfs/tracker.conf
[storage@localhost conf]$ sudo vim /etc/fdfs/storage.conf

[storage@localhost conf]$ cd /usr/local/nginx/conf/
[storage@localhost conf]$ sudo ../sbin/nginx -s stop
ngx_http_fastdfs_set pid=12586
[storage@localhost conf]$ sudo ../sbin/nginx
ngx_http_fastdfs_set pid=12605
[storage@localhost conf]$ sudo ../sbin/nginx -s reload

/*
FastDFS输出报告位置：
sudo tail -n 50 /usr/local/fastdfs/storage/logs/storaged.log


启动 Tracker 服务器：
sudo systemctl start fdfs_trackerd
检查 Tracker 服务器状态：
sudo systemctl status fdfs_trackerd
确认 Tracker 服务器监听端口：
sudo netstat -tuln | grep :22122
*/
//草！好几个小时的含泪史 一定要先开tracker端！！！
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★

/*
首先，重新启动 FastDFS 的 tracker 和 storage 服务：

bash
复制代码
# 重启 tracker 服务
sudo systemctl restart fdfs_trackerd

# 重启 storage 服务
sudo systemctl restart fdfs_storaged
2. 重启 Nginx 服务
接下来，重新启动 Nginx 服务，确保它能够加载新的配置并生效：

bash
复制代码
sudo systemctl restart nginx
3. 验证服务状态
重新启动服务后，可以通过以下方式验证它们的运行状态：

检查 FastDFS 服务状态：

bash
复制代码
sudo systemctl status fdfs_trackerd
sudo systemctl status fdfs_storaged
检查 Nginx 服务状态：

bash
复制代码
sudo systemctl status nginx
*/

http://192.168.170.136:8888/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
</code></pre>
<h3 id="创建文件服务module-文件上传"><a href="#创建文件服务module-文件上传" class="headerlink" title="创建文件服务module [文件上传]"></a>创建文件服务module [文件上传]</h3><pre><code class="xml">【新建一个module imooc-news-dev-service-files】
pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-files&lt;/artifactId&gt;
&lt;!--
    imooc-news-dev-service-files
    文件服务，文件相关的操作都在此文件中进行
    文件上传   文件下载
    fastdfs  oss  gridfs
--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 文件上传fdfs工具包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
            &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
            &lt;version&gt;1.27.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;



    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yaml">application.yuml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-file
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 512000 #请求文件大小限制为500kb
      max-request-size: 512000
</code></pre>
<pre><code class="yaml">application-dev.yuml
server:
  port: 8004

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/HelloController.java
package com.imooc.files.controller;


import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello()&#123;
        return GraceJSONResult.ok(&quot;Hello World!&quot;);
    &#125;
&#125;




service-files  com/imooc/files/Application.java
package com.imooc.files;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //排除数据源
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
-----------------------------------------------------------------------
http://localhost:8004/hello
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: &quot;Hello World!&quot;
&#125;
</code></pre>
<h3 id="整合fdfs与service实现-文件上传"><a href="#整合fdfs与service实现-文件上传" class="headerlink" title="整合fdfs与service实现 [文件上传]"></a>整合fdfs与service实现 [文件上传]</h3><pre><code class="java">service-api  com/imooc/files/service/impl/UploaderServiceImpl.java
package com.imooc.files.service.impl;

import com.github.tobato.fastdfs.domain.fdfs.StorePath;
import com.github.tobato.fastdfs.service.FastFileStorageClient;
import com.imooc.files.service.UploaderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

@Service
public class UploaderServiceImpl implements UploaderService &#123;
    //注入客户端
    @Autowired
    public FastFileStorageClient fastFileStorageClient;

    @Override
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException &#123;
        StorePath storePath = fastFileStorageClient.uploadFile(file.getInputStream(), file.getSize(), fileExtName, null);
        return storePath.getFullPath();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/files/service/UploaderService.java
package com.imooc.files.service;

import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

public interface UploaderService &#123;
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-file
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 512000 #请求文件大小限制为500kb
      max-request-size: 512000

############################################################
#
# fdfs配置信息
#
############################################################
fdfs:
  connect-timeout: 30
  so-timeout: 30
  tracker-list: 192.168.170.135:22122
</code></pre>
<h3 id="实现fastdfs图片存储-文件上传"><a href="#实现fastdfs图片存储-文件上传" class="headerlink" title="实现fastdfs图片存储 [文件上传]"></a>实现fastdfs图片存储 [文件上传]</h3><pre><code class="java">service-api  com/imooc/api/controller/files/FileUploadControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploadControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // 执行上传
                path = uploaderService.uploadFdfs(file, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);
        return GraceJSONResult.ok(path);
    &#125;
&#125;
//此时去上传图片会报错 报跨域异常错误
//需要在用户service-user里的Application 
//@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
//贴到com/imooc/files/Application.java

此时再次 http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html
提交头像
Console：
06:09.827 [http-nio-8004-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
06:09.827 [http-nio-8004-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet &#39;dispatcherServlet&#39;
06:09.832 [http-nio-8004-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 5 ms
06:09.882 [http-nio-8004-exec-2] INFO  c.imooc.api.aspect.ServiceLogAspect - ==== 开始执行 class com.imooc.files.service.impl.UploaderServiceImpl.uploadFdfs ====
06:09.937 [http-nio-8004-exec-2] INFO  c.imooc.api.aspect.ServiceLogAspect - 当前执行耗时：55
06:09.937 [http-nio-8004-exec-2] INFO  c.i.f.c.FileUploadController - path = imooc/M00/00/00/wKiqiGaPrpKAEt22AAAeb3kUsrg507.png

http://192.168.170.136:8888/imooc/M00/00/00/wKiqiGaPrpKAEt22AAAeb3kUsrg507.png
此时就可以看到Cat的图片了！
</code></pre>
<h3 id="完善用户头像上传"><a href="#完善用户头像上传" class="headerlink" title="完善用户头像上传"></a>完善用户头像上传</h3><pre><code class="java">【在用户返回的时候写死路径+path】
return GraceJSONResult.ok(&quot;http://192.168.170.136:8888/&quot;path);

给它包装一下 FileResource写一下
service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.files.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // 执行上传
                path = uploaderService.uploadFdfs(file, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
            finalPath = fileResource.getHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
        return GraceJSONResult.ok(finalPath);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/FileResource.java
package com.imooc.files;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(&quot;classpath:file-$&#123;spring.profiles.active&#125;.properties &quot;) //这个是在application.yml里面的 自动匹配
@ConfigurationProperties(prefix = &quot;file&quot;)
public class FileResource &#123;
    private String host;

    public String getHost() &#123;
        return host;
    &#125;

    public void setHost(String host) &#123;
        this.host = host;
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">file-dev.properties
# fastdfs storage 节点地址(nginx整合的web服务)
file.host=http://192.168.170.136:8888/


application.yml
############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-file
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 512000 #请求文件大小限制为500kb
      max-request-size: 512000
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
此时拦截器也要加一层
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UseActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UseActiveInterceptor useActiveInterceptor()&#123;
        return new UseActiveInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);
//        registry.addInterceptor(userTokenInterceptor())
//                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="图片大小控制的统一异常处理"><a href="#图片大小控制的统一异常处理" class="headerlink" title="图片大小控制的统一异常处理"></a>图片大小控制的统一异常处理</h3><pre><code class="java">dev-common  com/imooc/exception/GraceExceptionHandler.java
package com.imooc.exception;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MaxUploadSizeExceededException;

/**
 * 统一异常拦截处理
 * 可以针对异常的类型进行捕获 然后返回json信息到前端
 */
@ControllerAdvice
public class GraceExceptionHandler &#123;
    @ExceptionHandler(MyCustomException.class)
    //只要是这个类的异常都会进入下面的方法
    @ResponseBody
    public GraceJSONResult returnMyException(MyCustomException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.exception(e.getResponseStatusEnum());
    &#125;

    @ExceptionHandler(MaxUploadSizeExceededException.class)
    @ResponseBody
    public GraceJSONResult returnMaxUploadSizeExceededException(MaxUploadSizeExceededException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_MAX_SIZE_ERROR);
    &#125;
&#125;
</code></pre>
<h3 id="第三方云存储解决方案-【阿里OSS】"><a href="#第三方云存储解决方案-【阿里OSS】" class="headerlink" title="第三方云存储解决方案 【阿里OSS】"></a>第三方云存储解决方案 【阿里OSS】</h3><h5 id="FastDFS-中小型公司使用"><a href="#FastDFS-中小型公司使用" class="headerlink" title="FastDFS [中小型公司使用]"></a>FastDFS [中小型公司使用]</h5><ul>
<li>水平扩容</li>
<li>运维复杂</li>
<li>开发复杂【增加图片效果 &amp; 人脸识别等】</li>
</ul>
<h5 id="云存储阿里OSS"><a href="#云存储阿里OSS" class="headerlink" title="云存储阿里OSS"></a><span style = "color:red">云存储阿里OSS</span></h5><ul>
<li>SDK使用简单 [Java对接]</li>
<li>提供强大的文件处理功能</li>
<li>零运维成本</li>
<li>图形化管理控制台</li>
<li>CDN加速</li>
<li>降低风险管理成本</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://common-buy.aliyun.com/?commodityCode=ossbag&spm=5176.28061389.commonbuy2container.oss_rc_dp_cn_ZjqTabLinks_2.3949778b3uJsQM&regionId=cn-inland-common&accounttraceid=f8f4fe13a682404d8cab9b0254ae864ddivk">对象存储 OSS 资源包 (aliyun.com)</a>[购买 <strong><u>标准-本地冗余存储</u></strong> ＋ <u><strong>下行流量</strong></u> ]</p>
<h3 id="控制台的基本配置使用-【阿里OSS】"><a href="#控制台的基本配置使用-【阿里OSS】" class="headerlink" title="控制台的基本配置使用 【阿里OSS】"></a>控制台的基本配置使用 【阿里OSS】</h3><p><a target="_blank" rel="noopener" href="https://oss.console.aliyun.com/overview">OSS管理控制台 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://billing-cost.console.aliyun.com/home/myfreetier?spm=5176.29188366.free-tier.4.47553e4dvJ4jbs">费用与成本 (aliyun.com)我的试用</a></p>
<ul>
<li>对象存储OSS → Bucket列表 → 创建Bucket → 存储冗余类型:<u>本地冗余存储</u> → 读写权限:<u>公共读</u></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://oss.console.aliyun.com/bucket/oss-cn-shanghai/iimooc-news-dev/object">OSS管理控制台 (aliyun.com)</a></p>
<ul>
<li>创建成功后进入<u>iimooc-news-dev&#x2F;object</u> → 文件管理 → 文件列表 →<br><a target="_blank" rel="noopener" href="https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/log.png">https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/log.png</a></li>
</ul>
<pre><code class="xml">dev-common  pom.xml
&lt;dependency&gt;
  &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
  &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
  &lt;version&gt;3.10.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>对象存储OSS → SDK文档 → <strong>上传网络流</strong></li>
<li>对象存储OSS → iimooc-news-dev → 概览 → 访问端口: 外网访问 <u>oss-cn-shanghai.aliyuncs.com</u></li>
</ul>
<h3 id="SDK的使用与项目整合"><a href="#SDK的使用与项目整合" class="headerlink" title="SDK的使用与项目整合"></a>SDK的使用与项目整合</h3><pre><code class="java">service-file  com/imooc/files/service/UploaderService.java
package com.imooc.files.service;

import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

public interface UploaderService &#123;
    /**
     * 使用fastdfs 上传文件
     */
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException;

    /**
     * 使用OSS 上传文件
     */
    public String uploadOSS(MultipartFile file,String userId, String fileExtName) throws IOException;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/service/impl/UploaderServiceImpl.java
package com.imooc.files.service.impl;

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.github.tobato.fastdfs.domain.fdfs.StorePath;
import com.github.tobato.fastdfs.service.FastFileStorageClient;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.utils.extend.AliyunResource;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;

@Service
public class UploaderServiceImpl implements UploaderService &#123;
    //注入客户端
    @Autowired
    public FastFileStorageClient fastFileStorageClient;
    @Autowired
    public FileResource fileResource;
    @Autowired
    public AliyunResource aliyunResource;
    @Autowired
    public Sid sid;

    @Override
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException &#123;
        StorePath storePath = fastFileStorageClient.uploadFile(file.getInputStream(), file.getSize(), fileExtName, null);
        return storePath.getFullPath();
    &#125;

    @Override
    public String uploadOSS(MultipartFile file, String userId, String fileExtName) throws IOException &#123;
        // Endpoint以杭州为例，其它Region请按实际情况填写。
        // 外网访问：oss-cn-shanghai.aliyuncs.com
        String endpoint = fileResource.getEndpoint();
        // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。
        String accessKeyId = aliyunResource.getAccessKeyID();
        String accessKeySecret = aliyunResource.getAccessKeySecret();

        // 创建OSSClient实例。
        OSS ossClient = new OSSClientBuilder().build(endpoint,
                accessKeyId,
                accessKeySecret);
        //  images/abc/10010/cat.png  路径不全 所以需要myObjectName拼接
        String fileName = sid.nextShort();
        String myObjectName = fileResource.getObjectName()
                + &quot;/&quot; + userId + &quot;/&quot; + fileName + &quot;.&quot; + fileExtName;

        // 上传网络流。
        InputStream inputStream = file.getInputStream();
        ossClient.putObject(fileResource.getBucketName(),
                myObjectName,
                inputStream);

        // 关闭OSSClient。
        ossClient.shutdown();
        return myObjectName;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/resource/FileResource.java
package com.imooc.files.resource;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(&quot;classpath:file-$&#123;spring.profiles.active&#125;.properties &quot;) //这个是在application.yml里面的 自动匹配
@ConfigurationProperties(prefix = &quot;file&quot;)
public class FileResource &#123;
    private String host;
    private String endpoint;
    private String BucketName;
    private String objectName;
&#125;Getter + Setter
</code></pre>
<pre><code class="mysql">file-dev.properties
# fastdfs storage ????(nginx???web??)
file.host=http://192.168.170.136:8888/

# aliyun OSS
file.endpoint=oss-cn-shanghai.aliyuncs.com

file.BucketName=iimooc-news-dev

# url name
file.objectName=images/abc
</code></pre>
<h3 id="OSS整合实现文件上传"><a href="#OSS整合实现文件上传" class="headerlink" title="OSS整合实现文件上传"></a>OSS整合实现文件上传</h3><pre><code class="java"> // OSS执行上传
//  path = uploaderService.uploadOSS(file, userId, suffix);

service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // fdfs执行上传
//                path = uploaderService.uploadFdfs(file, suffix);
                // OSS执行上传
                path = uploaderService.uploadOSS(file, userId, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
            finalPath = fileResource.getHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
        return GraceJSONResult.ok(finalPath);
    &#125;
&#125;

=================================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html
此时更改头像上传后 头像会在OSS服务器的文件里面显示
</code></pre>
<pre><code class="mysql">file-dev.properties / file-prod.properties
# fastdfs storage ????(nginx???web??)
file.host=http://192.168.170.136:8888/

# aliyun OSS
file.endpoint=oss-cn-shanghai.aliyuncs.com

file.BucketName=iimooc-news-dev

# url name
file.objectName=images/abc

file.ossHost=https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/
</code></pre>
<pre><code class="java">service-files  com/imooc/files/resource/FileResource.java
@Component
@PropertySource(&quot;classpath:file-$&#123;spring.profiles.active&#125;.properties &quot;) //这个是在application.yml里面的 自动匹配
@ConfigurationProperties(prefix = &quot;file&quot;)
public class FileResource &#123;
    private String host;
    private String endpoint;
    private String BucketName;
    private String objectName;
    private String OssHost;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
    //用OSS执行上传 而不是 fdfs执行上传
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // fdfs执行上传
//                path = uploaderService.uploadFdfs(file, suffix);
                // OSS执行上传
                path = uploaderService.uploadOSS(file, userId, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
//            finalPath = fileResource.getHost() + path;
            finalPath = fileResource.getOssHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
        return GraceJSONResult.ok(finalPath);
    &#125;
&#125;
</code></pre>
<h3 id="图片自动审核-【阿里内容安全】"><a href="#图片自动审核-【阿里内容安全】" class="headerlink" title="图片自动审核 【阿里内容安全】"></a>图片自动审核 【阿里内容安全】</h3><h6 id="多媒体内容风险智能识别服务，降低色情、暴力、恐怖-由于太贵了就不买了-1000多呢"><a href="#多媒体内容风险智能识别服务，降低色情、暴力、恐怖-由于太贵了就不买了-1000多呢" class="headerlink" title="多媒体内容风险智能识别服务，降低色情、暴力、恐怖 (由于太贵了就不买了 1000多呢)"></a>多媒体内容风险智能识别服务，降低色情、暴力、恐怖 (<u>由于太贵了就不买了 1000多呢</u>)</h6><pre><code class="xml">dev-common  pom.xml
 &lt;!-- 第三方云厂商相关的依赖 --&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
            &lt;version&gt;3.10.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-green&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.51&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-codec&lt;/groupId&gt;
            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
            &lt;version&gt;1.10&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/extend/AliImageReviewUtils.java
package com.imooc.utils.extend;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.green.model.v20180509.ImageSyncScanRequest;
import com.aliyuncs.http.FormatType;
import com.aliyuncs.http.HttpResponse;
import com.aliyuncs.http.MethodType;
import com.aliyuncs.http.ProtocolType;
import com.aliyuncs.profile.DefaultProfile;
import com.aliyuncs.profile.IClientProfile;
import com.imooc.enums.ArticleReviewLevel;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Date;
import java.util.UUID;

@Component
public class AliImageReviewUtils &#123;

//    文档地址：https://help.aliyun.com/document_detail/70292.html?spm=a2c4g.11186623.2.49.6f9c75fdjaW30p#reference-fzy-ztm-v2b

    @Autowired
    private AliyunResource aliyunResource;

    public boolean reviewImage(String imgUrl) throws Exception &#123;
        IClientProfile profile = DefaultProfile
                .getProfile(&quot;cn-shanghai&quot;, &quot;&quot;, &quot;&quot;);
        DefaultProfile
                .addEndpoint(&quot;cn-shanghai&quot;, &quot;cn-shanghai&quot;, &quot;Green&quot;, &quot;green.cn-shanghai.aliyuncs.com&quot;);
        IAcsClient client = new DefaultAcsClient(profile);

        ImageSyncScanRequest imageSyncScanRequest = new ImageSyncScanRequest();
        // 指定api返回格式
        imageSyncScanRequest.setAcceptFormat(FormatType.JSON);
        // 指定请求方法
        imageSyncScanRequest.setMethod(MethodType.POST);
        imageSyncScanRequest.setEncoding(&quot;utf-8&quot;);
        //支持http和https
        imageSyncScanRequest.setProtocol(ProtocolType.HTTP);


        JSONObject httpBody = new JSONObject();
        /**
         * 设置要检测的场景, 计费是按照该处传递的场景进行
         * 一次请求中可以同时检测多张图片，每张图片可以同时检测多个风险场景，计费按照场景计算
         * 例如：检测2张图片，场景传递porn、terrorism，计费会按照2张图片鉴黄，2张图片暴恐检测计算
         * porn: porn表示色情场景检测
         * logo: 商标
         * 其他详见官方文档
         */
        httpBody.put(&quot;scenes&quot;, Arrays.asList(&quot;terrorism&quot;));

        /**
         * 设置待检测图片， 一张图片一个task
         * 多张图片同时检测时，处理的时间由最后一个处理完的图片决定
         * 通常情况下批量检测的平均rt比单张检测的要长, 一次批量提交的图片数越多，rt被拉长的概率越高
         * 这里以单张图片检测作为示例, 如果是批量图片检测，请自行构建多个task
         */
        JSONObject task = new JSONObject();
        task.put(&quot;dataId&quot;, UUID.randomUUID().toString());

        //设置图片链接
        task.put(&quot;url&quot;, imgUrl);
        task.put(&quot;time&quot;, new Date());
        httpBody.put(&quot;tasks&quot;, Arrays.asList(task));

        imageSyncScanRequest.setHttpContent(org.apache.commons.codec.binary.StringUtils.getBytesUtf8(httpBody.toJSONString()),
                &quot;UTF-8&quot;, FormatType.JSON);

        /**
         * 请设置超时时间, 服务端全链路处理超时时间为10秒，请做相应设置
         * 如果您设置的ReadTimeout小于服务端处理的时间，程序中会获得一个read timeout异常
         */
        imageSyncScanRequest.setConnectTimeout(3000);
        imageSyncScanRequest.setReadTimeout(10000);
        HttpResponse httpResponse = null;
        try &#123;
            httpResponse = client.doAction(imageSyncScanRequest);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        //服务端接收到请求，并完成处理返回的结果
        if (httpResponse != null &amp;&amp; httpResponse.isSuccess()) &#123;
            JSONObject scrResponse = JSON.parseObject(org.apache.commons.codec.binary.StringUtils.newStringUtf8(httpResponse.getHttpContent()));
            System.out.println(JSON.toJSONString(scrResponse, true));
            int requestCode = scrResponse.getIntValue(&quot;code&quot;);
            //每一张图片的检测结果
            JSONArray taskResults = scrResponse.getJSONArray(&quot;data&quot;);
            if (200 == requestCode) &#123;
                for (Object taskResult : taskResults) &#123;
                    //单张图片的处理结果
                    int taskCode = ((JSONObject) taskResult).getIntValue(&quot;code&quot;);
                    //图片要检测的场景的处理结果, 如果是多个场景，则会有每个场景的结果
                    JSONArray sceneResults = ((JSONObject) taskResult).getJSONArray(&quot;results&quot;);
                    if (200 == taskCode) &#123;
                        Object sceneResult = sceneResults.get(0);
//                        for (Object sceneResult : sceneResults) &#123;
                        String scene = ((JSONObject) sceneResult).getString(&quot;scene&quot;);
                        String suggestion = ((JSONObject) sceneResult).getString(&quot;suggestion&quot;);
                        //根据scene和suggetion做相关处理
                        //do something
                        System.out.println(&quot;scene = [&quot; + scene + &quot;]&quot;);
                        System.out.println(&quot;suggestion = [&quot; + suggestion + &quot;]&quot;);

                        return suggestion.equalsIgnoreCase(ArticleReviewLevel.PASS.type) ? true : false;
//                        &#125;
                    &#125; else &#123;
                        //单张图片处理失败, 原因视具体的情况详细分析
                        System.out.println(&quot;task process fail. task response:&quot; + JSON.toJSONString(taskResult));
                        return false;
                    &#125;
                &#125;
            &#125; else &#123;
                /**
                 * 表明请求整体处理失败，原因视具体的情况详细分析
                 */
                System.out.println(&quot;the whole image scan request failed. response:&quot; + JSON.toJSONString(scrResponse));
                return false;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/crisschan/article/details/136866137">解决github Push rejected报错 remote: error: GH013: Repository rule violations found for refs&#x2F;heads&#x2F;maste_github push declined due to repository rule violat-CSDN博客</a></p>
<pre><code class="java">dev-common  com/imooc/enums/ArticleReviewLevel.java
package com.imooc.enums;

/**
 * @Desc: 文章自动审核结果 枚举
 */
public enum ArticleReviewLevel &#123;
    PASS(&quot;pass&quot;, &quot;自动审核通过&quot;),
    BLOCK(&quot;block&quot;, &quot;自动审核不通过&quot;),
    REVIEW(&quot;review&quot;, &quot;建议人工复审&quot;);

    public final String type;
    public final String value;

    ArticleReviewLevel(String type, String value) &#123;
        this.type = type;
        this.value = value;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;

import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.extend.AliImageReviewUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Autowired
    private AliImageReviewUtils aliImageReviewUtils;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // fdfs执行上传     要让外面得以访问 ①需要把内网的环境发布到公网 [内网穿透]  ②路由器端口映射到外网  ③fastdfs安装到公网里
//                path = uploaderService.uploadFdfs(file, suffix);
                // OSS执行上传
                path = uploaderService.uploadOSS(file, userId, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
//            finalPath = fileResource.getHost() + path;
            finalPath = fileResource.getOssHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
           return GraceJSONResult.ok(finalPath);
       // return GraceJSONResult.ok(doAliImageReview(finalPath)); //这里加了图片审核咯
    &#125;

    /**
     * fastdfs 默认存在于内网，无法被阿里云内容管理服务检查到
     * 需要配置到公网才行：
     * 1. 内网穿透，natppp/花生壳/ngrok
     * 2. 路由配置端口映射
     * 3. fdfs 发布到云服务器
     */

   /* 功能实现不了图片识别 因为没有开通内容安全需要企业认证
     public static final String FAILED_IMAGE_URL = &quot;https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/240629F21AK1BHX4/Review_Failed.png&quot;; //这里保存审核失败的照片 提前上传到Oss里直接用
    private String doAliImageReview(String pendingImageUrl)&#123;
        boolean result = false;
        try &#123;
            result = aliImageReviewUtils.reviewImage(pendingImageUrl);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        if (!result)&#123;
            return FAILED_IMAGE_URL;
        &#125;
        return pendingImageUrl;
    &#125;
&#125;
*/
</code></pre>
<h3 id="创建阿里云子账号-【阿里内容安全】"><a href="#创建阿里云子账号-【阿里内容安全】" class="headerlink" title="创建阿里云子账号 【阿里内容安全】"></a>创建阿里云子账号 【阿里内容安全】</h3><p><a target="_blank" rel="noopener" href="https://ram.console.aliyun.com/users">RAM访问控制 → 用户</a><br>[实在不行了 凑合着搞一下吧 功能实现不了图片识别 因为没有开通内容安全需要企业认证]</p>
<blockquote>
<p>登录名称：imooc-news-dev<br>显示名称：用于内容审核<br>√  OpenAPI访问调用<br>AccessKey ID：<br>AccessKeySeret：</p>
<p>点击左侧列表下方 授权 → 新增授权 【授权主体：用于内容审核      权限策略：搜：green   … 管理内容安全的权限】</p>
</blockquote>
<h3 id="构建admin服务"><a href="#构建admin服务" class="headerlink" title="构建admin服务"></a>构建admin服务</h3><ul>
<li>构建admin管理服务</li>
<li>文章分类管理</li>
<li>友情连接管理</li>
<li>用户账号管理</li>
<li>文章内容人工审核 [放在文章上传后的自动审核]</li>
<li>admin管理人员账号分配 [用户人脸]</li>
</ul>
<pre><code class="xml">service-admin  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-admin&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;


&lt;/project&gt;
</code></pre>
<pre><code class="xml">service-admin  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-admin&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-admin&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/service-admin.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">service-admin:8005
package com.imooc.admin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/HelloController.java
package com.imooc.admin.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
----------------------------------------------------------------------------
http://admin.imoocnews.com:8005/hello

application-dev.yml
server:
  port: 8005

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
</code></pre>
<h3 id="表设计与账号预分配-【admin账号】"><a href="#表设计与账号预分配-【admin账号】" class="headerlink" title="表设计与账号预分配 【admin账号】"></a>表设计与账号预分配 【admin账号】</h3><pre><code class="xml">service-admin  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
            &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/PWDTest.java
package com.imooc.admin.controller;

import org.springframework.security.crypto.bcrypt.BCrypt;

public class PWDTest &#123;
    public static void main(String[] args) &#123;
        String pwd = BCrypt.hashpw(&quot;admin&quot;, BCrypt.gensalt());//加盐
        System.out.println(pwd);
    &#125;
&#125;
</code></pre>
<h3 id="持久层查询管理员-【admin账号】"><a href="#持久层查询管理员-【admin账号】" class="headerlink" title="持久层查询管理员 【admin账号】"></a>持久层查询管理员 【admin账号】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/login.html">http://admin.imoocnews.com:9090/imooc-news/admin/login.html</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">Windows下如何查看某个端口被谁占用 | 菜鸟教程 (runoob.com)</a></p>
<pre><code class="java">//更改一下mybatis-generator-database里面的generatorConfig-admin.xml
数据库表为：admin_user
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;!-- 通用mapper所在目录 --&gt;
        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;com.imooc.my.mapper.MyMapper&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/imooc-news-dev&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 对应生成的pojo所在包 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.imooc.pojo&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot;/&gt;

        &lt;!-- 对应生成的mapper所在目录 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper.admin&quot; targetProject=&quot;mybatis-generator-database/src/main/resources&quot;/&gt;

        &lt;!-- 配置mapper对应的java映射 --&gt;
        &lt;javaClientGenerator targetPackage=&quot;com.imooc.admin.mapper&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt;

        &lt;!-- 数据库表 --&gt;
        &lt;table tableName=&quot;admin_user&quot;&gt;&lt;/table&gt;

    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="java">mybatis-generator-database的把AdminUser拷贝到dev-model的com/imooc/pojo下
mybatis-generator-database的把AdminUserMapper拷贝到service-admin的resources mapper/AdminUserMapper.xml
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);
&#125;



service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.service.AdminUserService;
import com.imooc.pojo.AdminUser;
import org.springframework.beans.factory.annotation.Autowired;
import tk.mybatis.mapper.entity.Example;

public class AdminUserServiceImpl implements AdminUserService &#123;
    @Autowired
    public AdminUserMapper adminUserMapper;
    @Override
    public AdminUser queryAdminByUsername(String username) &#123;
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria Criteria = adminExample.createCriteria();
        Criteria.andEqualTo(&quot;username&quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/mapper/AdminUserMapper.java
package com.imooc.admin.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.AdminUser;
import org.springframework.stereotype.Repository;

@Repository
public interface AdminUserMapper extends MyMapper&lt;AdminUser&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">service-admin  mapper/AdminUserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.admin.mapper.AdminUserMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.AdminUser&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;face_id&quot; property=&quot;faceId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;admin_name&quot; property=&quot;adminName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;updated_time&quot; property=&quot;updatedTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="用户名密码登录-【admin账号】"><a href="#用户名密码登录-【admin账号】" class="headerlink" title="用户名密码登录 【admin账号】"></a>用户名密码登录 【admin账号】</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/arjelarxfc/article/details/78806384">Spring里遇到的一个问题，autowired时报找不到bean定义_autowired找不到bean-CSDN博客</a></p>
<h6 id="其次上述问题一定要去找Controller-Service-ServiceImpl-和-启动类里面的有没有正确扫描包-MapperScan-basePackages-x3D-“com-imooc-admin-mapper”"><a href="#其次上述问题一定要去找Controller-Service-ServiceImpl-和-启动类里面的有没有正确扫描包-MapperScan-basePackages-x3D-“com-imooc-admin-mapper”" class="headerlink" title="其次上述问题一定要去找Controller Service ServiceImpl 和 启动类里面的有没有正确扫描包@MapperScan(basePackages &#x3D; “com.imooc.admin.mapper”)"></a>其次上述问题一定要去找Controller Service ServiceImpl 和 启动类里面的有没有正确扫描包@MapperScan(basePackages &#x3D; “com.imooc.admin.mapper”)</h6><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.AdminUserService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.AdminMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AdminMngController.class);

    @Autowired
    private AdminUserService adminUserService;

    @Autowired
    private RedisOperator redis;

    @Override
    public Object adminLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1.查询admin用户的信息
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        // 2.判断admin不为空，如果为空则登录失败
        if (admin == null) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
        // 3.判断密码是否匹配
        boolean isPwdMath = BCrypt.checkpw(adminLoginBO.getPassword(), admin.getPassword());
        if (isPwdMath)&#123;
            doLoginSettings(admin,request,response);
            return GraceJSONResult.ok();
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
    &#125;

    /**
     * 用于admin用户登录过后的基本信息设置
     */
    private void doLoginSettings(AdminUser admin, HttpServletRequest request, HttpServletResponse response)&#123;
        // 保存token放入到redis中
        String token = UUID.randomUUID().toString();
        redis.set(REDIS_ADMIN_TOKEN + &quot;:&quot; + admin.getId(),token);

        // 保存admin登录基本token信息到cookie中
        setCookie(request, response, &quot;atoken&quot;, token, COOKIE_MONTH);
        setCookie(request, response, &quot;aid&quot;, admin.getId(), COOKIE_MONTH);
        setCookie(request, response, &quot;aname&quot;, admin.getAdminName(), COOKIE_MONTH);
    &#125;
&#125;
---------------------------------------------------------------------------------
http://admin.imoocnews.com:9090/imooc-news/admin/login.html
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.service.AdminUserService;
import com.imooc.pojo.AdminUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

@Service
public class AdminUserServiceImpl implements AdminUserService &#123;
    @Autowired
    public AdminUserMapper adminUserMapper;
    @Override
    public AdminUser queryAdminByUsername(String username) &#123;
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria Criteria = adminExample.createCriteria();
        Criteria.andEqualTo(&quot;username&quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/mapper/AdminUserMapper.java
package com.imooc.admin.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.AdminUser;
import org.springframework.stereotype.Repository;

@Repository
public interface AdminUserMapper extends MyMapper&lt;AdminUser&gt; &#123;
&#125;


service-admin  resources/mapper/AdminUserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.admin.mapper.AdminUserMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.AdminUser&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;face_id&quot; property=&quot;faceId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;admin_name&quot; property=&quot;adminName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;updated_time&quot; property=&quot;updatedTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/Application.java
package com.imooc.admin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.admin.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">service-admin  application-dev.yml
server:
  port: 8005

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
## setup CN from java, This is resource
website:
  domain-name: imoocnews.com

## open mybatis log in dev
#mybatis:
#  configuration:
#    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
#
</code></pre>
<h3 id="校验admin账号唯一-【admin账号】"><a href="#校验admin账号唯一-【admin账号】" class="headerlink" title="校验admin账号唯一 【admin账号】"></a>校验admin账号唯一 【admin账号】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html</a></p>
<pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java

  @Override
    public Object adminLogin(String username) &#123;
        checkAdminExist(username);
        return GraceJSONResult.ok();
    &#125;
    private void checkAdminExist(String username)&#123;
        AdminUser admin = adminUserService.queryAdminByUsername(username);
        if (admin != null)&#123;
            GraceException.display(ResponseStatusEnum.ADMIN_USERNAME_EXIST_ERROR);
        &#125;

    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.pojo.bo.AdminLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;,tags = &#123;&quot;管理员admin维护的Controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public Object adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                             HttpServletRequest request,
                             HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;,notes = &quot;查询admin用户名是否存在&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public Object adminLogin(@RequestParam String username); //传回来
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UseActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UseActiveInterceptor useActiveInterceptor()&#123;
        return new UseActiveInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);

        //        registry.addInterceptor(userTokenInterceptor())
//                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="创建admin账号-【admin账号】"><a href="#创建admin账号-【admin账号】" class="headerlink" title="创建admin账号 【admin账号】"></a>创建admin账号 【admin账号】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/userList.html">用户管理 | 运营管理平台 (imoocnews.com)</a><br><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html</a></p>
<pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.AdminUserService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.AdminMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AdminMngController.class);

    @Autowired
    private AdminUserService adminUserService;

    @Autowired
    private RedisOperator redis;

    @Override
    public GraceJSONResult adminLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1.查询admin用户的信息
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        // 2.判断admin不为空，如果为空则登录失败
        if (admin == null) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
        // 3.判断密码是否匹配
        boolean isPwdMath = BCrypt.checkpw(adminLoginBO.getPassword(), admin.getPassword());
        if (isPwdMath)&#123;
            doLoginSettings(admin,request,response);
            return GraceJSONResult.ok();
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
    &#125;


    /**
     * 用于admin用户登录过后的基本信息设置
     */
    private void doLoginSettings(AdminUser admin, HttpServletRequest request, HttpServletResponse response)&#123;
        // 保存token放入到redis中
        String token = UUID.randomUUID().toString();
        redis.set(REDIS_ADMIN_TOKEN + &quot;:&quot; + admin.getId(),token);

        // 保存admin登录基本token信息到cookie中
        setCookie(request, response, &quot;atoken&quot;, token, COOKIE_MONTH);
        setCookie(request, response, &quot;aid&quot;, admin.getId(), COOKIE_MONTH);
        setCookie(request, response, &quot;aname&quot;, admin.getAdminName(), COOKIE_MONTH);
    &#125;


    @Override
    public GraceJSONResult adminLogin(String username) &#123;
        checkAdminExist(username);
        return GraceJSONResult.ok();
    &#125;

    private void checkAdminExist(String username)&#123;
        AdminUser admin = adminUserService.queryAdminByUsername(username);
        if (admin != null)&#123;
            GraceException.display(ResponseStatusEnum.ADMIN_USERNAME_EXIST_ERROR);
        &#125;

    &#125;

    @Override
    public GraceJSONResult addNewAdmin(NewAdminBO newAdminBO,HttpServletRequest request,HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1. base64不为空，则代表人脸入库，否则需要用户输入密码和确认密码
        if (StringUtils.isBlank(newAdminBO.getImg64()))&#123;
            if (StringUtils.isBlank(newAdminBO.getPassword()) || StringUtils.isBlank(newAdminBO.getConfirmPassword()))&#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_NULL_ERROR);
            &#125;
        &#125;
        // 2. 密码不为空，则必须判断两次输入一致
        if (StringUtils.isNotBlank(newAdminBO.getPassword())) &#123;
            if (!newAdminBO.getPassword().equalsIgnoreCase(newAdminBO.getConfirmPassword())) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_ERROR);
            &#125;
        &#125;
        // 3. 校验用户名唯一
        checkAdminExist(newAdminBO.getUsername());

        // 4.调用service存入admin信息
        adminUserService.createAdminUser(newAdminBO);
        return GraceJSONResult.ok();
    &#125;

&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;,tags = &#123;&quot;管理员admin维护的Controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public GraceJSONResult adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;,notes = &quot;查询admin用户名是否存在&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public GraceJSONResult adminLogin(@RequestParam String username); //传回来

    @ApiOperation(value = &quot;创建admin&quot;,notes = &quot;创建admin&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/addNewAdmin&quot;)
    public GraceJSONResult addNewAdmin(@RequestBody NewAdminBO newAdminBO,HttpServletRequest request,HttpServletResponse response); //传回来
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.service.AdminUserService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;

@Service
public class AdminUserServiceImpl implements AdminUserService &#123;
    @Autowired
    public AdminUserMapper adminUserMapper;
    @Autowired
    public Sid sid;
    @Override
    public AdminUser queryAdminByUsername(String username) &#123;
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria Criteria = adminExample.createCriteria();
        Criteria.andEqualTo(&quot;username&quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    &#125;

    @Override
    public void createAdminUser(NewAdminBO newAdminBO) &#123;
        String adminId = sid.nextShort(); //获得主键
        AdminUser adminUser = new AdminUser();
        adminUser.setId(adminId);
        adminUser.setUsername(newAdminBO.getUsername());
        adminUser.setAdminName(newAdminBO.getAdminName());
        // 如果密码不为空 则密码需要加密 存入数据库
        if (StringUtils.isNotBlank(newAdminBO.getPassword()))&#123;
            String pwd = BCrypt.hashpw(newAdminBO.getPassword(), BCrypt.gensalt());
            adminUser.setPassword(pwd);
        &#125;

        // 如果人脸上传以后，则有faceId，需要和admin信息关联存储入库
        if (StringUtils.isNotBlank(newAdminBO.getFaceId()))&#123;
            adminUser.setFaceId(newAdminBO.getFaceId());
        &#125;
        adminUser.setCreatedTime(new Date());
        adminUser.setUpdatedTime(new Date());

        int insert = adminUserMapper.insert(adminUser);
        if (insert != 1)&#123;
            GraceException.display(ResponseStatusEnum.ADMIN_CREATE_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);

    /**
     * 新增管理员
     *
     * @param newAdminBO
     */
    public void createAdminUser(NewAdminBO newAdminBO);
&#125;
</code></pre>
<h3 id="查看admin列表-【admin账号】-分页查询"><a href="#查看admin列表-【admin账号】-分页查询" class="headerlink" title="查看admin列表 【admin账号】(分页查询)"></a>查看admin列表 【admin账号】(分页查询)</h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
 @Override
    public GraceJSONResult getAdminList(Integer page, Integer pageSize) &#123;
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;//由于是固定数值 可以去basecontroller加一下
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        adminUserService.queryAdminList(page, pageSize);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);

    /**
     * 新增管理员
     *
     * @param newAdminBO
     */
    public void createAdminUser(NewAdminBO newAdminBO);


    /**
     * 分页查询admin列表
     * @param page
     * @param pageSize
     */
    public void queryAdminList(Integer page, Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
@Override
    public void queryAdminList(Integer page, Integer pageSize) &#123;
        Example adminExample = new Example(AdminUser.class);
        adminExample.orderBy(&quot;createdTime&quot;).asc();
        PageHelper.startPage(page, pageSize);
        List&lt;AdminUser&gt; adminUserList = adminUserMapper.selectByExample(adminExample);
        System.out.println(adminUserList);
    &#125; //下面一节会有改动
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/Swagger2.java
package com.imooc.api.config;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.RequestHandler;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration //Springboot啓動的時候會被掃描到并且加載
@EnableSwagger2
public class Swagger2 &#123;

    //    http://localhost:8088/swagger-ui.html     原路径
    //    http://localhost:8088/doc.html            新路径

    // 配置swagger2核心配置 docket
    @Bean
    public Docket createRestApi() &#123;
        Predicate&lt;RequestHandler&gt; adminPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.admin.controller&quot;);
//        Predicate&lt;RequestHandler&gt; articlePredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.article.controller&quot;);
        Predicate&lt;RequestHandler&gt; userPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.user.controller&quot;);
        Predicate&lt;RequestHandler&gt; filesPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.files.controller&quot;);

        return new Docket(DocumentationType.SWAGGER_2)  // 指定api类型为swagger2
                .apiInfo(apiInfo())                 // 用于定义api文档汇总信息
                .select()
                .apis(Predicates.or(userPredicate, adminPredicate, filesPredicate))
//                .apis(Predicates.or(adminPredicate, articlePredicate, userPredicate, filesPredicate))
                .paths(PathSelectors.any())         // 所有controller
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕课新闻·自媒体接口api&quot;)                       // 文档页标题
                .contact(new Contact(&quot;imooc&quot;,
                        &quot;https://www.imooc.com&quot;,
                        &quot;abc@imooc.com&quot;))                   // 联系人信息
                .description(&quot;专为慕课新闻·自媒体平台提供的api文档&quot;)      // 详细信息
                .version(&quot;1.0.1&quot;)                               // 文档版本号
                .termsOfServiceUrl(&quot;https://www.imooc.com&quot;)     // 网站地址
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;,tags = &#123;&quot;管理员admin维护的Controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public GraceJSONResult adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;,notes = &quot;查询admin用户名是否存在&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public GraceJSONResult adminLogin(@RequestParam String username); //传回来

    @ApiOperation(value = &quot;创建admin&quot;,notes = &quot;创建admin&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/addNewAdmin&quot;)
    public GraceJSONResult addNewAdmin(@RequestBody NewAdminBO newAdminBO,HttpServletRequest request,HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin列表&quot;,notes = &quot;查询admin列表&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAdminList&quot;)
    public GraceJSONResult getAdminList(@ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;,  required = false) @RequestParam Integer page,
                                        @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页查询每一页显示的条数&quot;, required = false) @RequestParam Integer pageSize);
&#125;

-----------------------------------------------------------------
http://admin.imoocnews.com:8005/doc.html
</code></pre>
<h3 id="封装PagedGridResult分页数据-调试分页接口-【admin账号】"><a href="#封装PagedGridResult分页数据-调试分页接口-【admin账号】" class="headerlink" title="封装PagedGridResult分页数据_调试分页接口 【admin账号】"></a><span style = "color:red">封装<del>PagedGridResult</del></span>分页数据_调试分页接口 【admin账号】</h3><pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
    @Override
    public PagedGridResult queryAdminList(Integer page, Integer pageSize) &#123;
        Example adminExample = new Example(AdminUser.class);
        adminExample.orderBy(&quot;createdTime&quot;).asc();
        PageHelper.startPage(page, pageSize);
        List&lt;AdminUser&gt; adminUserList = adminUserMapper.selectByExample(adminExample);
        return setterPagedGrid(adminUserList, page);
    &#125;

    private PagedGridResult setterPagedGrid( List&lt;?&gt; adminUserList, Integer page)&#123; //类型是? 后期不确定是什么泛型
        PageInfo&lt;?&gt; pageList = new PageInfo&lt;&gt;(adminUserList);
        PagedGridResult gridResult = new PagedGridResult();
        gridResult.setRows(adminUserList);
        gridResult.setPage(page);
        gridResult.setRecords(pageList.getPages());
        gridResult.setTotal(pageList.getTotal());
        return gridResult;

    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.utils.PagedGridResult;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);

    /**
     * 新增管理员
     *
     * @param newAdminBO
     */
    public void createAdminUser(NewAdminBO newAdminBO);


    /**
     * 分页查询admin列表
     * @param page
     * @param pageSize
     */
    public PagedGridResult queryAdminList(Integer page, Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/PagedGridResult.java
package com.imooc.utils;

import java.util.List;

/**
 * 
 * @Title: PagedGridResult.java
 * @Package com.imooc.utils
 * @Description: 用来返回分页Grid的数据格式
 * Copyright: Copyright (c) 2019
 */
public class PagedGridResult &#123;
    
    private int page;            // 当前页数
    private long total;            // 总页数
    private long records;        // 总记录数
    private List&lt;?&gt; rows;        // 每行显示的内容
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
//拦截器新增地址
package com.imooc.api.config;

import com.imooc.api.interceptors.AdminTokenInterceptor;
import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);
        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;);

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/interceptors/AdminTokenInterceptor.java
package com.imooc.api.interceptors;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import static com.imooc.api.BaseController.REDIS_ADMIN_TOKEN;

public class AdminTokenInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    /**
     * 拦截请求，在访问controller调用之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        String adminUserId = request.getHeader(&quot;adminUserId&quot;);
        String adminUserToken = request.getHeader(&quot;adminUserToken&quot;);

        System.out.println(&quot;=====================================================================&quot;);
        System.out.println(&quot;AdminTokenInterceptor - adminUserId = &quot; + adminUserId);
        System.out.println(&quot;AdminTokenInterceptor - adminUserToken = &quot; + adminUserToken);
        System.out.println(&quot;=====================================================================&quot;);

        boolean run = verifyUserIdToken(adminUserId, adminUserToken, REDIS_ADMIN_TOKEN);
        return run;
    &#125;

    /**
     * 请求访问controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    /**
     * 请求访问controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<h3 id="账号注销-【admin账号】-删掉redis和cookie数据"><a href="#账号注销-【admin账号】-删掉redis和cookie数据" class="headerlink" title="账号注销 【admin账号】(删掉redis和cookie数据)"></a>账号注销 【admin账号】(删掉redis和cookie数据)</h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.AdminUserService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.AdminMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.enums.FaceVerifyType;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.utils.FaceVerifyUtils;
import com.imooc.utils.PagedGridResult;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.kafka.KafkaProperties;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(AdminMngController.class);

    @Autowired
    private RedisOperator redis;

    @Autowired
    private AdminUserService adminUserService;

    @Autowired
    private FaceVerifyUtils faceVerifyUtils;

    @Override
    public GraceJSONResult adminLogin(AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1. 查询admin用户的信息
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        // 2. 判断admin不为空，如果为空则登录失败
        if (admin == null) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;

        // 3. 判断密码是否匹配
        boolean isPwdMatch = BCrypt.checkpw(adminLoginBO.getPassword(), admin.getPassword());
        if (isPwdMatch) &#123;
            doLoginSettings(admin, request, response);
            return GraceJSONResult.ok();
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
    &#125;


    /**
     * 用于admin用户登录过后的基本信息设置
     * @param admin
     * @param request
     * @param response
     */
    private void doLoginSettings(AdminUser admin,
                                 HttpServletRequest request,
                                 HttpServletResponse response) &#123;
        // 保存token放入到redis中
        String token = UUID.randomUUID().toString();
        redis.set(REDIS_ADMIN_TOKEN + &quot;:&quot; + admin.getId(), token);

        // 保存admin登录基本token信息到cookie中
        setCookie(request, response, &quot;atoken&quot;, token, COOKIE_MONTH);
        setCookie(request, response, &quot;aid&quot;, admin.getId(), COOKIE_MONTH);
        setCookie(request, response, &quot;aname&quot;, admin.getAdminName(), COOKIE_MONTH);
    &#125;

    @Override
    public GraceJSONResult adminIsExist(String username) &#123;
        checkAdminExist(username);
        return GraceJSONResult.ok();
    &#125;

    private void checkAdminExist(String username) &#123;
        AdminUser admin = adminUserService.queryAdminByUsername(username);

        if (admin != null) &#123;
            GraceException.display(ResponseStatusEnum.ADMIN_USERNAME_EXIST_ERROR);
        &#125;
    &#125;

    @Override
    public GraceJSONResult addNewAdmin(NewAdminBO newAdminBO,
                                       HttpServletRequest request,
                                       HttpServletResponse response) &#123;

        // 0. TODO 验证BO中的用户名和密码不为空

        // 1. base64不为空，则代表人脸入库，否则需要用户输入密码和确认密码
        if (StringUtils.isBlank(newAdminBO.getImg64())) &#123;
            if (StringUtils.isBlank(newAdminBO.getPassword()) ||
                    StringUtils.isBlank(newAdminBO.getConfirmPassword())
            ) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_NULL_ERROR);
            &#125;
        &#125;

        // 2. 密码不为空，则必须判断两次输入一致
        if (StringUtils.isNotBlank(newAdminBO.getPassword())) &#123;
            if (!newAdminBO.getPassword()
                    .equalsIgnoreCase(newAdminBO.getConfirmPassword())) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_ERROR);
            &#125;
        &#125;

        // 3. 校验用户名唯一
        checkAdminExist(newAdminBO.getUsername());

        // 4. 调用service存入admin信息
        adminUserService.createAdminUser(newAdminBO);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult getAdminList(Integer page, Integer pageSize) &#123;

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult result = adminUserService.queryAdminList(page, pageSize);
        return GraceJSONResult.ok(result);
    &#125;

    @Override
    public GraceJSONResult adminLogout(String adminId,
                                       HttpServletRequest request,
                                       HttpServletResponse response) &#123;

        // 从redis中删除admin的会话token
        redis.del(REDIS_ADMIN_TOKEN + &quot;:&quot; + adminId);

        // 从cookie中清理adming登录的相关信息
        deleteCookie(request, response, &quot;atoken&quot;);
        deleteCookie(request, response, &quot;aid&quot;);
        deleteCookie(request, response, &quot;aname&quot;);

        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;, tags = &#123;&quot;管理员admin维护的controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;

    @ApiOperation(value = &quot;hello方法的接口&quot;, notes = &quot;hello方法的接口&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public GraceJSONResult adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;, notes = &quot;查询admin用户名是否存在&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public GraceJSONResult adminIsExist(@RequestParam String username);

    @ApiOperation(value = &quot;创建admin&quot;, notes = &quot;创建admin&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/addNewAdmin&quot;)
    public GraceJSONResult addNewAdmin(@RequestBody NewAdminBO newAdminBO,
                                       HttpServletRequest request,
                                       HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin列表&quot;, notes = &quot;查询admin列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAdminList&quot;)
    public GraceJSONResult getAdminList(
            @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
            @RequestParam Integer page,
            @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页查询每一页显示的条数&quot;, required = false)
            @RequestParam Integer pageSize);

    @ApiOperation(value = &quot;admin退出登录&quot;, notes = &quot;admin退出登录&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogout&quot;)
    public GraceJSONResult adminLogout(@RequestParam String adminId,
                                       HttpServletRequest request,
                                       HttpServletResponse response);
                                        HttpServletResponse response);
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public void setCookieValue(HttpServletRequest request,
                               HttpServletResponse response,
                               String cookieName,
                               String cookieValue,
                               Integer maxAge) &#123;
        Cookie cookie = new Cookie(cookieName, cookieValue);
        cookie.setMaxAge(maxAge);
//        cookie.setDomain(&quot;imoocnews.com&quot;);
        cookie.setDomain(DOMAIN_NAME);
        cookie.setPath(&quot;/&quot;);//都用cookie
        response.addCookie(cookie);//把cookie传入
    &#125;

    public void deleteCookie(HttpServletRequest request,HttpServletResponse response,String cookieName)&#123;
        try &#123;
            String deleteValue = URLEncoder.encode(&quot;&quot;, &quot;utf-8&quot;);
            setCookieValue(request, response, cookieName, deleteValue, COOKIE_DELETE);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>
<h3 id="人脸业务流程图梳理"><a href="#人脸业务流程图梳理" class="headerlink" title="人脸业务流程图梳理"></a>人脸业务流程图梳理</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/fa7fae40efa428b638a2589c3203204ff0479b04/data/%E4%BA%BA%E8%84%B8%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h3 id="Chrome开启视频调试模式"><a href="#Chrome开启视频调试模式" class="headerlink" title="Chrome开启视频调试模式"></a>Chrome开启视频调试模式</h3><blockquote>
<p>在谷歌浏览器中打开【每一次重启电脑都要操作】<br>chrome:&#x2F;&#x2F;flags&#x2F;#unsafely-treat-insecure-origin-as-secure<br>|————————————————————————————————|<br>|  <a href="http://admin.imoocnews.com:9090,http://admin.imoocnews.com">http://admin.imoocnews.com:9090,http://admin.imoocnews.com</a> |<br>|—— ——————————————————————————————|<br><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html</a><br>可以获取人脸</p>
</blockquote>
<h3 id="MongoDB概念-人脸数据存储-可以存储JSON数据"><a href="#MongoDB概念-人脸数据存储-可以存储JSON数据" class="headerlink" title="MongoDB概念 [人脸数据存储]可以存储JSON数据"></a>MongoDB概念 [人脸数据存储]<del>可以存储JSON数据</del></h3><ul>
<li>NoSql 数据库</li>
<li>内存级别查询</li>
<li>不支持事务</li>
<li>非并发读写 请求并发数据量大</li>
<li>GridFS 小文件存储</li>
</ul>
<h4 id="MongoDB术语"><a href="#MongoDB术语" class="headerlink" title="MongoDB术语"></a>MongoDB术语</h4><table>
<thead>
<tr>
<th align="center">数据库</th>
<th align="center">ElasticSearch</th>
<th align="center">MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">database</td>
<td align="center">es库</td>
<td align="center">database</td>
</tr>
<tr>
<td align="center">table表</td>
<td align="center">index索引</td>
<td align="center">collection数据集合</td>
</tr>
<tr>
<td align="center">row行 (记录)</td>
<td align="center">document文档 (json)</td>
<td align="center">document文档 (json)</td>
</tr>
<tr>
<td align="center">column 字段列</td>
<td align="center">field域</td>
<td align="center">field域</td>
</tr>
<tr>
<td align="center">index索引</td>
<td align="center">-</td>
<td align="center">index索引</td>
</tr>
<tr>
<td align="center">join表关联查询</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">pk主键</td>
<td align="center">_id</td>
<td align="center">_id</td>
</tr>
</tbody></table>
<h5 id="MongoDB数据结构"><a href="#MongoDB数据结构" class="headerlink" title="MongoDB数据结构"></a>MongoDB数据结构</h5><pre><code class="vue">UserList:[
    &#123;
        userId: &quot;1001&quot;,
        username: &quot;lee&quot;,
        age: 18
    &#125;,
    &#123;
        userId: &quot;1002&quot;,
        username: &quot;jay&quot;,
        age: 20,
        sex: &quot;boy&quot;
    &#125;
]

----------------------------------------------------------

UserList --&gt;   collection
&#123;&#125;       --&gt;   document
属性        --&gt;   column
</code></pre>
<h3 id="MogoDB安装与配置使用"><a href="#MogoDB安装与配置使用" class="headerlink" title="MogoDB安装与配置使用"></a>MogoDB安装与配置使用</h3><p><a target="_blank" rel="noopener" href="https://www.mongodb.com/try/download/enterprise">https://www.mongodb.com/try/download/enterprise</a></p>
<pre><code class="mysql">将mongodb-linux-x86_64-rhel70-4.2.8传入虚拟机
[imooc@imooc ~]$ tar -zxvf mongodb-linux-x86_64-rhel70-4.2.8.tgz 
[imooc@imooc ~]$ sudo mv mongodb-linux-x86_64-rhel70-4.2.8 /usr/local/mongodb
[imooc@imooc ~]$ cd /usr/local/
[imooc@imooc local]$ ll
drwxrwxr-x. 3 imooc imooc      135 7月  16 19:46 mongodb
[imooc@imooc local]$ cd mongodb/
[imooc@imooc mongodb]$ ll
总用量 312
drwxrwxr-x. 2 imooc imooc    231 7月  16 19:46 bin
-rw-r--r--. 1 imooc imooc  30608 6月  12 2020 LICENSE-Community.txt
-rw-r--r--. 1 imooc imooc  16726 6月  12 2020 MPL-2
-rw-r--r--. 1 imooc imooc   2617 6月  12 2020 README
-rw-r--r--. 1 imooc imooc  75405 6月  12 2020 THIRD-PARTY-NOTICES
-rw-r--r--. 1 imooc imooc 183512 6月  12 2020 THIRD-PARTY-NOTICES.gotools
[imooc@imooc mongodb]$ cd bin/
[imooc@imooc bin]$ pwd
/usr/local/mongodb/bin

[imooc@imooc bin]$ sudo vim /etc/profile
最下面添加：
export JAVA_HOME=/usr/java/jdk1.8.0_222-ea
export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin
#set mogodb config
export PATH=/usr/local/mongodb/bin:$PATH

#修改 /etc/profile 文件后，需要重新加载这个文件才能使新配置生效。你可以执行以下命令：
[imooc@imooc bin]$ source /etc/profile

[imooc@imooc bin]$ mongo --version
MongoDB shell version v4.2.8
git version: 43d25964249164d76d5e04dd6cf38f6111e21f5f
OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013
allocator: tcmalloc
modules: none
build environment:
    distmod: rhel70
    distarch: x86_64
    target_arch: x86_64

[imooc@imooc bin]$ cd /usr/local/mongodb/
[imooc@imooc mongodb]$ pwd
/usr/local/mongodb

#创建数据存储目录
[imooc@imooc mongodb]$ mkdir data/db -p #出来一个data
[imooc@imooc mongodb]$ ll
总用量 312
drwxrwxr-x. 2 imooc imooc    231 7月  16 19:46 bin
drwxrwxr-x. 3 imooc imooc     16 7月  16 20:00 data
[imooc@imooc mongodb]$ cd data
[imooc@imooc data]$ ll
总用量 0
drwxrwxr-x. 2 imooc imooc 6 7月  16 20:00 db
[imooc@imooc data]$ mkdir logs
[imooc@imooc data]$ ll
总用量 0
drwxrwxr-x. 2 imooc imooc 6 7月  16 20:00 db
drwxrwxr-x. 2 imooc imooc 6 7月  16 20:00 logs
[imooc@imooc data]$ cd logs/
[imooc@imooc logs]$ pwd
/usr/local/mongodb/data/logs
[imooc@imooc logs]$ touch mongodb.log
[imooc@imooc logs]$ ll
总用量 0
-rw-rw-r--. 1 imooc imooc 0 7月  16 20:01 mongodb.log
[imooc@imooc logs]$ cd ..
[imooc@imooc logs]$ cd ..

[imooc@imooc mongodb]$ vim mongodb.conf
port=27017
# datasource path
dbpath=/user/local/mongodb/data/db
# log path
logpath=/usr/local/mongodb/data/logs/mongodb.log
# append log
logappend=true
# cut useless log
quiet=true
# back desktop auto run
fork=true
# Maxcontect
maxConns=100
# Not open Verify permissions
noauth=true
# open Verify permissions
# auth=true
# open log =&gt; true
journal=true
# clash
bind_ip=0.0.0.0

[imooc@imooc mongodb]$ sudo yum install net-snmp
 
#错误：软件包：1:net-snmp-agent-libs-5.7.2-49.el7_9.4.x86_64 (updates)
          需要：libmysqlclient.so.18(libmysqlclient_18)(64bit)
#错误：软件包：1:net-snmp-5.7.2-49.el7_9.4.x86_64 (updates)
          需要：libmysqlclient.so.18()(64bit)
#错误：软件包：1:net-snmp-agent-libs-5.7.2-49.el7_9.4.x86_64 (updates)
          需要：libmysqlclient.so.18()(64bit)
# cd /usr/local/mongodb/
[imooc@imooc mongodb]$ mongod -f mongodb.conf
about to fork child process, waiting until server is ready for connections.
forked process: 4989
child process started successfully, parent exiting

[imooc@imooc mongodb]$ ps aux | grep mongod
imooc      4989  1.8  4.2 1550916 78280 ?       Sl   20:39   0:00 mongod -f mongodb.conf
imooc      5105  0.0  0.0 112824   988 pts/0    S+   20:40   0:00 grep --color=auto mongod

[imooc@imooc mongodb]$ ps -ef|grep mongodb
imooc      4989      1  0 20:39 ?        00:00:02 mongod -f mongodb.conf
imooc      5201   2948  0 20:44 pts/0    00:00:00 grep --color=auto mongodb


尝试连接到 MongoDB 实例： 
[imooc@imooc mongodb]$ mongo --port 27017
</code></pre>
<h3 id="可视化管理工具【MongoDB】"><a href="#可视化管理工具【MongoDB】" class="headerlink" title="可视化管理工具【MongoDB】"></a>可视化管理工具【MongoDB】</h3><pre><code class="mysql">在Navicat里新建链接MongoDB
主机：192.168.170.135
右键新建数据库school → 集合 → 右键新建 左上角保存student
[imooc@imooc mongodb]$ vim mongodb.conf
##### 启用用户账号权限
# Not open Verify permissions
# noauth=true
# open Verify permissions
  auth=true
#重启服务
[imooc@imooc mongodb]$ ps -ef|grep mongodb
imooc      4989      1  0 20:39 ?        00:00:05 mongod -f mongodb.conf
imooc      5380   2948  0 20:54 pts/0    00:00:00 grep --color=auto mongodb
[imooc@imooc mongodb]$ kill -2 4989
[imooc@imooc mongodb]$ ps -ef|grep mongodb
imooc      5395   2948  0 20:54 pts/0    00:00:00 grep --color=auto mongodb
[imooc@imooc mongodb]$ mongod -f mongodb.conf
about to fork child process, waiting until server is ready for connections.
forked process: 5419
child process started successfully, parent exiting

[imooc@imooc mongodb]$ mongo
MongoDB shell version v4.2.8
connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb
Implicit session: session &#123; &quot;id&quot; : UUID(&quot;c87ffbd9-69cd-4e29-badd-5b86a314f428&quot;) &#125;
MongoDB server version: 4.2.8
&gt; use admin
switched to db admin
&gt; db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[&quot;root&quot;]&#125;)
Successfully added user: &#123; &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;root&quot; ] &#125;
&gt; db.auth(&quot;root&quot;,&quot;root&quot;)
1
&gt; show users
&#123;
    &quot;_id&quot; : &quot;admin.root&quot;,
    &quot;userId&quot; : UUID(&quot;2ced1f0a-8de4-4fab-9cb8-8e420fe9dcba&quot;),
    &quot;user&quot; : &quot;root&quot;,
    &quot;db&quot; : &quot;admin&quot;,
    &quot;roles&quot; : [
        &#123;
            &quot;role&quot; : &quot;root&quot;,
            &quot;db&quot; : &quot;admin&quot;
        &#125;
    ],
    &quot;mechanisms&quot; : [
        &quot;SCRAM-SHA-1&quot;,
        &quot;SCRAM-SHA-256&quot;
    ]
&#125;
&gt; 
#后面关闭连接 编辑数据库 新增密码登录 root root
</code></pre>
<h3 id="整合SpringBoot-【GridFS】"><a href="#整合SpringBoot-【GridFS】" class="headerlink" title="整合SpringBoot 【GridFS】"></a>整合SpringBoot 【GridFS】</h3><pre><code class="xml">&lt;!-- 引入 mongodb 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
            &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploadControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploadControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的
    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;
&#125;
</code></pre>
<pre><code class="yaml">service-files  application.yml
  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
</code></pre>
<h3 id="实现人脸入库-【GridFS】"><a href="#实现人脸入库-【GridFS】" class="headerlink" title="实现人脸入库 【GridFS】"></a>实现人脸入库 【GridFS】</h3><pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java

...
 @Autowired
    private GridFSBucket gridFSBucket;
...

 @Override
    public GraceJSONResult uploadToGridFS(NewAdminBO newAdminBO) throws Exception &#123;
        // 获得图片的base64字符串
        String file64 = newAdminBO.getImg64();
        // 将base64字符串转换为byte数组
        byte[] bytes = new BASE64Decoder().decodeBuffer(file64.trim());
        // 转换为输入流
        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
        //上传到gridfs中
        ObjectId fileId = gridFSBucket.uploadFromStream(newAdminBO.getUsername() + &quot;.png&quot;, inputStream);
        // 获取文件在gridfs中的主键id
        String fileIdStr = fileId.toString();
        // 下次提交的时候会提交到后端
        return GraceJSONResult.ok(fileIdStr);
    &#125;

http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html
注册并且提交人脸信息
去Navicat → MongoDB → imooc-news → GridFS存储桶 → fs → admin456.png
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
...
    @Override
    public GraceJSONResult uploadToGridFS(NewAdminBO newAdminBO) throws Exception &#123;
        // 获得图片的base64字符串
        String file64 = newAdminBO.getImg64();
        // 将base64字符串转换为byte数组
        byte[] bytes = new BASE64Decoder().decodeBuffer(file64.trim());
        // 转换为输入流
        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
        //上传到gridfs中
        ObjectId fileId = gridFSBucket.uploadFromStream(newAdminBO.getUsername() + &quot;.png&quot;, inputStream);
        // 获取文件在gridfs中的主键id
        String fileIdStr = fileId.toString();
        // 下次提交的时候会提交到后端
        return GraceJSONResult.ok(fileIdStr);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploadControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploadControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的

    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/GridFSConfig.java
package com.imooc.files;

import com.mongodb.MongoClient;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.client.gridfs.GridFSBuckets;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

@Component //可以被容器访问到
public class GridFSConfig &#123;
    @Value(&quot;$&#123;spring.data.mongodb.database&#125;&quot;)
    private String mongodb;

    @Bean
    public GridFSBucket gridFSBucket(MongoClient mongoClient)&#123;
        MongoDatabase mongoDatabase = mongoClient.getDatabase(mongodb);
        GridFSBucket bucket = GridFSBuckets.create(mongoDatabase);//存入mongodatabase
        return bucket;
    &#125;
&#125;
</code></pre>
<h3 id="查看admin人脸信息-【GridFS】"><a href="#查看admin人脸信息-【GridFS】" class="headerlink" title="查看admin人脸信息 【GridFS】"></a>查看admin人脸信息 【GridFS】</h3><pre><code class="java">service-files  com/imooc/files/controller/FileUploaderController.java
 @Override
    public GraceJSONResult uploadToGridFS(NewAdminBO newAdminBO)
            throws Exception &#123;

        // 获得图片的base64字符串
        String file64 = newAdminBO.getImg64();

        // 将base64字符串转换为byte数组
        byte[] bytes = new BASE64Decoder().decodeBuffer(file64.trim());

        // 转换为输入流
        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);

        // 上传到gridfs中
        ObjectId fileId = gridFSBucket.uploadFromStream(newAdminBO.getUsername() + &quot;.png&quot;, inputStream);

        // 获得文件在gridfs中的主键id
        String fileIdStr = fileId.toString();

        return GraceJSONResult.ok(fileIdStr);
    &#125;

    @Override
    public void readInGridFS(String faceId,
                             HttpServletRequest request,
                             HttpServletResponse response) throws Exception &#123;

        // 0. 判断参数
        if (StringUtils.isBlank(faceId) || faceId.equalsIgnoreCase(&quot;null&quot;)) &#123;
            GraceException.display(ResponseStatusEnum.FILE_NOT_EXIST_ERROR);
        &#125;

        // 1. 从gridfs中读取
        File adminFace = readGridFSByFaceId(faceId);

        // 2. 把人脸图片输出到浏览器
        FileUtils.downloadFileByStream(response, adminFace);
    &#125;

    private File readGridFSByFaceId(String faceId) throws Exception &#123;

        GridFSFindIterable gridFSFiles
                = gridFSBucket.find(Filters.eq(&quot;_id&quot;, new ObjectId(faceId)));

        GridFSFile gridFS = gridFSFiles.first();

        if (gridFS == null) &#123;
            GraceException.display(ResponseStatusEnum.FILE_NOT_EXIST_ERROR);
        &#125;

        String fileName = gridFS.getFilename();
        System.out.println(fileName);

        // 获取文件流，保存文件到本地或者服务器的临时目录
        File fileTemp = new File(&quot;/workspace/temp_face&quot;);
        if (!fileTemp.exists()) &#123;
            fileTemp.mkdirs();
        &#125;

        File myFile = new File(&quot;/workspace/temp_face/&quot; + fileName);

        // 创建文件输出流
        OutputStream os = new FileOutputStream(myFile);
        // 下载到服务器或者本地
        gridFSBucket.downloadToStream(new ObjectId(faceId), os);

        return myFile;
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploaderControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploaderControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的

    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;

    @GetMapping(&quot;/readInGridFS&quot;)
    public void readInGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception;
&#125;

//AdminCookieToken也可以获得faceId
</code></pre>
<h3 id="阿里AI人脸识别介绍"><a href="#阿里AI人脸识别介绍" class="headerlink" title="阿里AI人脸识别介绍"></a>阿里AI人脸识别介绍</h3><p><a target="_blank" rel="noopener" href="https://vision.aliyun.com/facebody?spm=5176.21213303.J_qCOwPWspKEuWcmp8qiZNQ.20.f1892f3dvI78tU&scm=20140722.S_card@@%E5%95%86%E5%93%81@@143873.S_card0.ID_card@@%E5%95%86%E5%93%81@@143873-RL_%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-LOC_search~UND~card~UND~item-OR_ser-V_3-RE_cardOld-P0_0">人脸人体-阿里云视觉智能开放平台 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://vision.console.aliyun.com/cn-shanghai/detail/facebody?spm=5176.6660585.viapi_facebody_public_cn-top.i0.7bbf7992dXgogs">视觉智能开放平台-控制台 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://vision.aliyun.com/experience/detail?tagName=facebody&children=CompareFace">能力展示-阿里云视觉智能开放平台 (aliyun.com)</a></p>
<h3 id="获得人脸faceId【人脸登录】"><a href="#获得人脸faceId【人脸登录】" class="headerlink" title="获得人脸faceId【人脸登录】"></a>获得人脸faceId【人脸登录】</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
@ApiOperation(value = &quot;admin管理员的人脸登录&quot;, notes = &quot;admin管理员的人脸登录&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminFaceLogin&quot;)
    public GraceJSONResult adminFaceLogin(@RequestBody AdminLoginBO adminLoginBO,
                                          HttpServletRequest request,
                                          HttpServletResponse response);
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
 @Override
    public GraceJSONResult adminFaceLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. 判断用户名和人脸信息不能为空
        if(StringUtils.isBlank(adminLoginBO.getUsername()))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_USERNAME_NULL_ERROR);
        &#125;
        String tempFace64 = adminLoginBO.getImg64();
        if (StringUtils.isBlank(tempFace64))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 1. 从数据库中查询出faceId
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        String adminFaceId = admin.getFaceId();
        if (StringUtils.isBlank(adminFaceId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 2. 请求文件服务，获得人懒数据的base64数据

        // 3. 调用阿里ai进行人脸对比识别，判断可信度，从而实现人脸登录

        // 4. admin登录后的数据设置，redis与cookie

        return null;
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploaderControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploaderControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的

    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;

    @GetMapping(&quot;/readInGridFS&quot;)
    public void readInGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception;

    /**
     * 从gridfs中读取图片内容 返回base64数据
     * @param faceId
     * @param request
     * @param response
     * @return
     * @throws Exception
     */
    @GetMapping(&quot;/readFace64InGridFS&quot;)
    public GraceJSONResult readFace64InGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploaderController.java
@Override
    public GraceJSONResult readFace64InGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        // 0. 获得gridfs中人脸文件
        File myface = readGridFSByFaceId(faceId);

        // 1. 转换人脸为base64
        String base64Face = FileUtils.fileToBase64(myface);
        return GraceJSONResult.ok(base64Face);
    &#125;
</code></pre>
<h3 id="整合RestTemplate服务通信-【人脸登录】"><a href="#整合RestTemplate服务通信-【人脸登录】" class="headerlink" title="整合RestTemplate服务通信 【人脸登录】"></a>整合RestTemplate服务通信 【人脸登录】</h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;

@Autowired
    private RestTemplate restTemplate;

@Override
    public GraceJSONResult adminFaceLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. 判断用户名和人脸信息不能为空
        if(StringUtils.isBlank(adminLoginBO.getUsername()))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_USERNAME_NULL_ERROR);
        &#125;
        String tempFace64 = adminLoginBO.getImg64();
        if (StringUtils.isBlank(tempFace64))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 1. 从数据库中查询出faceId
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        String adminFaceId = admin.getFaceId();
        if (StringUtils.isBlank(adminFaceId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 2. 请求文件服务，获得人懒数据的base64数据
        String fileServerUrlExecute = &quot;http://files.imoocnews.com:8004/fs/readFace64InGridFS?faceId=&quot; + adminFaceId;
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity = restTemplate.getForEntity(fileServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        String base64DB = (String)bodyResult.getData();
        // 3. 调用阿里ai进行人脸对比识别，判断可信度，从而实现人脸登录

        // 4. admin登录后的数据设置，redis与cookie

        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;

    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    public RestTemplate restTemplate() &#123;

        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<h3 id="实现人脸对比进行登录【人脸对比】没买人脸识别服务-简单写了一下"><a href="#实现人脸对比进行登录【人脸对比】没买人脸识别服务-简单写了一下" class="headerlink" title="实现人脸对比进行登录【人脸对比】没买人脸识别服务,简单写了一下"></a>实现人脸对比进行登录【人脸对比】<del>没买人脸识别服务,简单写了一下</del></h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
@Override
    public GraceJSONResult adminFaceLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. 判断用户名和人脸信息不能为空
        if(StringUtils.isBlank(adminLoginBO.getUsername()))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_USERNAME_NULL_ERROR);
        &#125;
        String tempFace64 = adminLoginBO.getImg64();
        if (StringUtils.isBlank(tempFace64))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 1. 从数据库中查询出faceId
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        String adminFaceId = admin.getFaceId();
        if (StringUtils.isBlank(adminFaceId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 2. 请求文件服务，获得人懒数据的base64数据
        String fileServerUrlExecute = &quot;http://files.imoocnews.com:8004/fs/readFace64InGridFS?faceId=&quot; + adminFaceId;
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity = restTemplate.getForEntity(fileServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        String base64DB = (String)bodyResult.getData();
        // 3. 调用阿里ai进行人脸对比识别，判断可信度，从而实现人脸登录
        boolean result = faceVerifyUtils.faceVerify(FaceVerifyType.BASE64.type,
                tempFace64,
                base64DB,
                60);
        if (!result)&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_LOGIN_ERROR);
        &#125;
        // 4. admin登录后的数据设置，redis与cookie
        doLoginSettings(admin,request,response);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/FaceVerifyUtils.java
package com.imooc.utils;

import com.aliyuncs.utils.Base64Helper;
import com.imooc.enums.FaceVerifyType;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.extend.AliyunResource;
import org.apache.tomcat.util.codec.binary.Base64;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.security.MessageDigest;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.SimpleTimeZone;

@Component
public class FaceVerifyUtils &#123;

    final static Logger logger = LoggerFactory.getLogger(FaceVerifyUtils.class);

    @Autowired
    private AliyunResource aliyunResource;

    //网关地址
    private static final String gateway = &quot;https://dtplus-cn-shanghai.data.aliyuncs.com/face/verify&quot;;

    /*
     * 计算MD5+BASE64
     */
    public static String MD5Base64(String s) &#123;
        if (s == null)
            return null;
        String encodeStr = &quot;&quot;;
        byte[] utfBytes = s.getBytes();
        MessageDigest mdTemp;
        try &#123;
            mdTemp = MessageDigest.getInstance(&quot;MD5&quot;);
            mdTemp.update(utfBytes);
            byte[] md5Bytes = mdTemp.digest();
            Base64Helper b64Encoder = new Base64Helper();
            encodeStr = b64Encoder.encode(md5Bytes);
        &#125; catch (Exception e) &#123;
            throw new Error(&quot;Failed to generate MD5 : &quot; + e.getMessage());
        &#125;
        return encodeStr;
    &#125;

    /*
     * 计算 HMAC-SHA1
     */
    public static String HMACSha1(String data, String key) &#123;
        String result;
        try &#123;
            SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), &quot;HmacSHA1&quot;);
            Mac mac = Mac.getInstance(&quot;HmacSHA1&quot;);
            mac.init(signingKey);
            byte[] rawHmac = mac.doFinal(data.getBytes());
            result = (new Base64Helper()).encode(rawHmac);
        &#125; catch (Exception e) &#123;
            throw new Error(&quot;Failed to generate HMAC : &quot; + e.getMessage());
        &#125;
        return result;
    &#125;

    /*
     * 等同于javaScript中的 new Date().toUTCString();
     */
    public static String toGMTString(Date date) &#123;
        SimpleDateFormat df = new SimpleDateFormat(&quot;E, dd MMM yyyy HH:mm:ss z&quot;, Locale.UK);
        df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
        return df.format(date);
    &#125;

    /**
     * 发送POST请求 进行两张图的人脸对比
     * @param type
     *          0: 通过url识别，参数image_url不为空；1: 通过图片content识别，参数content不为空
     * @param face1
     *          type为0，则传入图片url，为1则传入base64
     * @param face2
     *          type为0，则传入图片url，为1则传入base64
     * @return
     */
    //如果发送的是转换为base64编码后后面加请求参数type为1，如果请求的是图片的url则不用加type参数。
    public String sendPostVerifyFace(int type, String face1, String face2) throws Exception &#123;
        String body = &quot;&quot;;
        if (type == FaceVerifyType.BASE64.type) &#123;
            body = &quot;&#123;\&quot;content_1\&quot;: \&quot;&quot; + face1 + &quot;\&quot;, \&quot;content_2\&quot;:\&quot;&quot; + face2 + &quot;\&quot;, \&quot;type\&quot;:\&quot;&quot; + type + &quot;\&quot;&#125;&quot;;
        &#125; else if (type == FaceVerifyType.IMAGE_URL.type) &#123;
            body = &quot;&#123;\&quot;image_url_1\&quot;: \&quot;&quot; + face1 + &quot;\&quot;, \&quot;image_url_2\&quot;:\&quot;&quot; + face2 + &quot;\&quot;, \&quot;type\&quot;:\&quot;&quot; + type + &quot;\&quot;&#125;&quot;;
        &#125; else &#123;
            GraceException.display(ResponseStatusEnum.FACE_VERIFY_TYPE_ERROR);
        &#125;
//        String body = &quot;&#123;\&quot;content_1\&quot;: \&quot;&quot; + face1 + &quot;\&quot;, \&quot;content_2\&quot;:\&quot;&quot; + face2 + &quot;\&quot;, \&quot;type\&quot;:\&quot;&quot; + &quot;1&quot; + &quot;\&quot;&#125;&quot;;
        PrintWriter out = null;
        BufferedReader in = null;
        String result = &quot;&quot;;
        int statusCode = 200;
        try &#123;
            URL realUrl = new URL(gateway);
            /*
             * http header 参数
             */
            String method = &quot;POST&quot;;
            // 返回值类型
            String accept = &quot;application/json&quot;;
            // 请求内容类型
            String content_type = &quot;application/json&quot;;
            String path = realUrl.getFile();
            // GMT时间
            String date = toGMTString(new Date());
            // 1.对body做MD5+BASE64加密
            String bodyMd5 = MD5Base64(body);
            String stringToSign = method + &quot;\n&quot; + accept + &quot;\n&quot; + bodyMd5 + &quot;\n&quot; + content_type + &quot;\n&quot; + date + &quot;\n&quot;
                    + path;
            // 2.计算 HMAC-SHA1
            String signature = HMACSha1(stringToSign, aliyunResource.getAccessKeySecret());
            // 3.得到 authorization header
            String authHeader = &quot;Dataplus &quot; + aliyunResource.getAccessKeyID() + &quot;:&quot; + signature;
            // 打开和URL之间的连接
            URLConnection conn = realUrl.openConnection();
            // 设置通用的请求属性
            conn.setRequestProperty(&quot;Accept&quot;, accept);
            conn.setRequestProperty(&quot;Content-type&quot;, content_type);
            conn.setRequestProperty(&quot;Date&quot;, date);
            // 认证信息
            conn.setRequestProperty(&quot;Authorization&quot;, authHeader);
            // 发送POST请求必须设置如下两行
            conn.setDoOutput(true);
            conn.setDoInput(true);
            // 获取URLConnection对象对应的输出流
            out = new PrintWriter(conn.getOutputStream());
            // 发送请求参数
            out.print(body);
            // flush输出流的缓冲
            out.flush();
            // 定义BufferedReader输入流来读取URL的响应
            statusCode = ((HttpURLConnection) conn).getResponseCode();
            if (statusCode != 200) &#123;
                in = new BufferedReader(new InputStreamReader(((HttpURLConnection) conn).getErrorStream()));
            &#125; else &#123;
                in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            &#125;
            String line;
            while ((line = in.readLine()) != null) &#123;
                result += line;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (out != null) &#123;
                    out.close();
                &#125;
                if (in != null) &#123;
                    in.close();
                &#125;
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
        if (statusCode != 200) &#123;
            throw new IOException(&quot;\nHttp StatusCode: &quot; + statusCode + &quot;\nErrorMessage: &quot; + result);
        &#125;
        return result;
    &#125;

    /**
     *
     * @param type
     * @param face1
     * @param face2
     * @param targetConfidence
     *          目标可信度，自定义阈值
     * @return
     */
    public boolean faceVerify(int type, String face1, String face2, double targetConfidence) &#123;

        String response = null;
        try &#123;
            response = sendPostVerifyFace(type, face1, face2);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        Map&lt;String, String&gt; map = JsonUtils.jsonToPojo(response, Map.class);
        Object confidenceStr = map.get(&quot;confidence&quot;);
        Double responseConfidence = (Double)confidenceStr;

        logger.info(&quot;人脸对比结果：&#123;&#125;&quot;, responseConfidence);

//        System.out.println(response.toString());
//        System.out.println(map.toString());

        if (responseConfidence &gt; targetConfidence) &#123;
            return true;
        &#125; else &#123;
            return false;
        &#125;
    &#125;

    /**
     *
     * 将图片转换为Base64
     * 将base64编码字符串解码成img图片
     * @param imgUrl
     * @return
     */
    public String getImgBase64(String imgUrl)&#123;
        ByteArrayOutputStream data = new ByteArrayOutputStream();
        try &#123;
            // 创建URL
            URL url = new URL(imgUrl);
            byte[] by = new byte[1024];
            // 创建链接
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod(&quot;GET&quot;);
            conn.setConnectTimeout(5000);
            InputStream is = conn.getInputStream();
            // 将内容放到内存中
            int len = -1;
            while ((len = is.read(by)) != -1) &#123;
                data.write(by, 0, len);
            &#125;
            is.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        // 对字节数组Base64编码
        return Base64.encodeBase64String(data.toByteArray());
    &#125;

//    public static void main(String[] args) &#123;
//        String face3 = &quot;http://122.152.205.72:88/group1/M00/00/05/CpoxxF5MvvGAfnLXAAIHiv37wNk363.jpg&quot;;
//        String face4 = &quot;http://122.152.205.72:88/group1/M00/00/05/CpoxxF5Mv3yAH74mAACOiTd9pO4462.jpg&quot;;
//
//        boolean result = new FaceVerifyUtils().faceVerify(FaceVerifyType.IMAGE_URL.type, face3, face4, 60);
//
//        logger.info(&quot;人脸对比是否成功：&#123;&#125;&quot;, result);
//    &#125;
&#125;
</code></pre>
<h3 id="MongoDB使用场景-【分担数据库的大数据量】"><a href="#MongoDB使用场景-【分担数据库的大数据量】" class="headerlink" title="MongoDB使用场景 【分担数据库的大数据量】"></a>MongoDB使用场景 【分担数据库的大数据量】</h3><ul>
<li><strong>GridFS小文件存储</strong></li>
<li><strong>历史数据快照</strong> [买的东西涨价后 还是原来的价格] 【数据量大存入MongoDB】</li>
<li><strong>用户浏览记录</strong></li>
<li><strong>客服聊天记录</strong> [不是核心数据 可以剥离]</li>
</ul>
<h6 id="这些不建议放在Redis里-因为Redis是存储在内存里的-内存很贵-成本很大"><a href="#这些不建议放在Redis里-因为Redis是存储在内存里的-内存很贵-成本很大" class="headerlink" title="这些不建议放在Redis里 因为Redis是存储在内存里的 [内存很贵 成本很大]"></a>这些不建议放在Redis里 因为Redis是存储在内存里的 [内存很贵 成本很大]</h6><h3 id="友情连接保存与更新-【MongoDB】"><a href="#友情连接保存与更新-【MongoDB】" class="headerlink" title="友情连接保存与更新 【MongoDB】"></a>友情连接保存与更新 【MongoDB】</h3><h6 id="对连接的一些逻辑校验"><a href="#对连接的一些逻辑校验" class="headerlink" title="对连接的一些逻辑校验"></a>对连接的一些逻辑校验</h6><pre><code class="yaml">service-admin  application.yml 【加上mongodb配置】
  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
</code></pre>
<pre><code class="java">service-admin  Application 【注释exclude 把mongodb配置进来】
package com.imooc.admin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication  //(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.admin.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<p>dev-model  com&#x2F;imooc&#x2F;pojo&#x2F;bo&#x2F;SaveFriendLinkBO.java<br>package com.imooc.pojo.bo;</p>
<p>import com.imooc.validate.CheckUrl;</p>
<p>import javax.validation.constraints.NotBlank;<br>import javax.validation.constraints.NotNull;</p>
<p>public class SaveFriendLinkBO {<br>    private String id;<br>    @NotBlank(message &#x3D; “友情链接名不能为空”)<br>    private String linkName;<br>    @NotBlank(message &#x3D; “友情链接地址不能为空”)<br>    @CheckUrl 【ctrl+左键 显示↓ CheckUrl接口】<br>    @CheckName 【 &#x2F;&#x2F;不能有空格 不能为空 字符串长度要在6-12位】<br>    private String linkUrl;<br>    @NotNull(message &#x3D; “请选择保留或删除”)<br>    private Integer isDelete;<br>}Getter+Setter</p>
<pre><code class="java">dev-model  com/imooc/validate/CheckUrl.java
package com.imooc.validate;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CheckUrlValidate.class)
public @interface CheckUrl &#123;

    String message() default &quot;Url不正确&quot;;
    Class&lt;?&gt;[] groups() default &#123;&#125;;
    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/validate/CheckName.java
package com.imooc.validate;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CheckUrlValidate.class)
public @interface CheckName &#123;

    String message() default &quot;Name不正确&quot;;
    Class&lt;?&gt;[] groups() default &#123;&#125;;
    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/validate/CheckUrlValidate.java
package com.imooc.validate;

import com.imooc.utils.UrlUtil;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class CheckUrlValidate implements ConstraintValidator&lt;CheckUrl, String&gt; &#123;

    @Override
    public boolean isValid(String url, ConstraintValidatorContext context) &#123;
        return UrlUtil.verifyUrl(url.trim());
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/validate/CheckNameValidate.java
package com.imooc.validate;

import com.imooc.utils.UrlUtil;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class CheckNameValidate implements ConstraintValidator&lt;CheckName, String&gt; &#123;

    @Override
    public boolean isValid(String name, ConstraintValidatorContext context) &#123;
        return UrlUtil.verifyName(name.trim());
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/UrlUtil.java 【Url+Name校验标准】
package com.imooc.utils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class UrlUtil &#123;

    /**
     * 验证是否是URL
     * @param url
     * @return
     */
    public static boolean verifyUrl(String url)&#123;

        // URL验证规则
//        String regEx =&quot;[A-Za-z]+://[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_%&amp;\\?\\/.=]+&quot;;
        String regEx = &quot;^([hH][tT]&#123;2&#125;[pP]:/*|[hH][tT]&#123;2&#125;[pP][sS]:/*|[fF][tT][pP]:/*)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~\\/])+(\\?&#123;0,1&#125;(([A-Za-z0-9-~]+\\=&#123;0,1&#125;)([A-Za-z0-9-~]*)\\&amp;&#123;0,1&#125;)*)$&quot;;
        // 编译正则表达式
        Pattern pattern = Pattern.compile(regEx);
        // 忽略大小写的写法
        // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(url);
        // 字符串是否与正则表达式相匹配
        boolean rs = matcher.matches();
        return rs;

    &#125;
    //不能有空格 不能为空 字符串长度要在6-12位
    public static boolean verifyName(String name)&#123;
        // Name验证规则
        String nameEx = &quot;^[^\\s]&#123;6,12&#125;$&quot;;
        // 编译正则表达式
        Pattern pattern = Pattern.compile(nameEx);
        // 忽略大小写的写法
        // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(name);
        // 字符串是否与正则表达式相匹配
        boolean rs = matcher.matches();
        return rs;
    &#125;

    public static void main(String[] args) &#123;
        boolean res = verifyUrl(&quot;http://admin.imoocnews.com:9090/imooc-news/admin/friendLinks.html&quot;);
        boolean nres = verifyName(&quot;Jerry&quot;);
        System.out.println(nres);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">dev-model  pom.xml
 &lt;!-- 引入 mongodb 依赖 --&gt; 【springboot整合mongodb】
        &lt;dependency&gt;
            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
            &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;2.7.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h6 id="真正的友链保存接口"><a href="#真正的友链保存接口" class="headerlink" title="真正的友链保存接口"></a>真正的友链保存接口</h6><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
package com.imooc.admin.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.FriendLinkControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import com.imooc.pojo.mo.FriendLinkMO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.Map;

@RestController
public class FriendLinkController extends BaseController implements FriendLinkControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FriendLinkController.class);


    @Override
    public GraceJSONResult saveOrUpdateFriendLink(SaveFriendLinkBO saveFriendLinkBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;

//      saveFriendLinkBO -&gt; ***Mo  MongoDB校验的对象
        FriendLinkMO friendLinkMO = new FriendLinkMO();
        BeanUtils.copyProperties(saveFriendLinkBO,friendLinkMO);
        friendLinkMO.setCreateTime(new Date());
        friendLinkMO.setUpdateTime(new Date());
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/mo/FriendLinkMO.java
//这些都是设置到MongoDB数据库的名字
//@Document(&quot;FriendLink&quot;) //MongoDB文件起别名
public class FriendLinkMO &#123;
    @Id //作为MongDB的主键了
    private String id;
    @Field(&quot;link_name&quot;)
    private String linkName;
    @Field(&quot;link_url&quot;)
    private String linkUrl;
    @Field(&quot;is_delete&quot;)
    private Integer isDelete;
    @Field(&quot;create_time&quot;)
    private Date createTime;
    @Field(&quot;update_time&quot;)
    private Date updateTime;
&#125;Getter + Setter
</code></pre>
<h3 id="Repository持久层操作保存记录"><a href="#Repository持久层操作保存记录" class="headerlink" title="Repository持久层操作保存记录"></a>Repository持久层操作保存记录</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
package com.imooc.admin.controller;

import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.FriendLinkControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import com.imooc.pojo.mo.FriendLinkMO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.Map;

@RestController
public class FriendLinkController extends BaseController implements FriendLinkControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FriendLinkController.class);
    @Autowired
    private FriendLinkService friendLinkService;

    @Override
    public GraceJSONResult saveOrUpdateFriendLink(SaveFriendLinkBO saveFriendLinkBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;

//      saveFriendLinkBO -&gt; ***Mo  MongoDB校验的对象
        FriendLinkMO friendLinkMO = new FriendLinkMO();
        BeanUtils.copyProperties(saveFriendLinkBO,friendLinkMO);
        friendLinkMO.setCreateTime(new Date());
        friendLinkMO.setUpdateTime(new Date());

        friendLinkService.saveOrUpdateFriendLink(friendLinkMO);
        return GraceJSONResult.ok();
    &#125;
&#125;
// http://admin.imoocnews.com:9090/imooc-news/admin/friendLinks.html
/* 友情连接 → 
链接名称：慕课网
链接地址：www.imooc.com
[新增/添加]

打开检查→Console
&#123;&quot;status&quot;:200,&quot;msg&quot;:&quot;操作成功！&quot;,&quot;success&quot;:true,&quot;data&quot;:null&#125;

打开数据库查看MongoDB→friendLinkMO有存入的数据即操作成功
*/
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;

public interface FriendLinkService &#123;
    /**
     * 新增或者更新友情链接
     */
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/FriendLinkServiceImpl.java
package com.imooc.admin.service.impl;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.AdminUserService;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class FriendLinkServiceImpl implements FriendLinkService &#123;

    @Autowired
    private FriendLinkRepository friendLinkRepository;
    @Override
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO) &#123;
        friendLinkRepository.save(friendLinkMO); //有id更新 无id直接保存
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/repository/FriendLinkRepository.java
package com.imooc.admin.repository;

import com.imooc.pojo.mo.FriendLinkMO;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface FriendLinkRepository extends MongoRepository&lt;FriendLinkMO, String&gt; &#123; //持久层
    // 内置提供了很多方法 find.. delete...
&#125;
</code></pre>
<h3 id="友情链接查询列表-【MongoDB】"><a href="#友情链接查询列表-【MongoDB】" class="headerlink" title="友情链接查询列表 【MongoDB】"></a>友情链接查询列表 【MongoDB】</h3><h6 id="Document-“FriendLink”-x2F-x2F-文件起别名-记得要在MongoDB里面找这个-下面搜索的都在这个文件里面"><a href="#Document-“FriendLink”-x2F-x2F-文件起别名-记得要在MongoDB里面找这个-下面搜索的都在这个文件里面" class="headerlink" title="@Document(“FriendLink”) &#x2F;&#x2F;文件起别名 记得要在MongoDB里面找这个 下面搜索的都在这个文件里面"></a>@Document(“FriendLink”) &#x2F;&#x2F;文件起别名 记得要在MongoDB里面找这个 下面搜索的都在这个文件里面</h6><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
    @ApiOperation(value = &quot;查询改友情连接列表&quot;, notes = &quot;查询改友情连接列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getFriendLinkList&quot;)
    public GraceJSONResult getFriendLinkList();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
package com.imooc.admin.controller;

import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.FriendLinkControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import com.imooc.pojo.mo.FriendLinkMO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.Map;

@RestController
public class FriendLinkController extends BaseController implements FriendLinkControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FriendLinkController.class);
    @Autowired
    private FriendLinkService friendLinkService;

    @Override
    public GraceJSONResult saveOrUpdateFriendLink(SaveFriendLinkBO saveFriendLinkBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;

//      saveFriendLinkBO -&gt; ***Mo  MongoDB校验的对象
        FriendLinkMO friendLinkMO = new FriendLinkMO();
        BeanUtils.copyProperties(saveFriendLinkBO,friendLinkMO);
        friendLinkMO.setCreateTime(new Date());
        friendLinkMO.setUpdateTime(new Date());

        friendLinkService.saveOrUpdateFriendLink(friendLinkMO);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult getFriendLinkList() &#123; 
//【用了FriendLinkRepository里面的】extends MongoRepository 中的简单增删改查 
// 里面的删除是逻辑删除
        return GraceJSONResult.ok(friendLinkService.queryAllFriendLinkList());
    &#125;
&#125;
// http://admin.imoocnews.com:9090/imooc-news/admin/friendLinks.html
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;

import java.util.List;

public interface FriendLinkService &#123;
    /**
     * 新增或者更新友情链接
     */
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO);

    /**
     * 查询友情链接
     */
    public List&lt;FriendLinkMO&gt; queryAllFriendLinkList();

&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/FriendLinkServiceImpl.java
package com.imooc.admin.service.impl;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.AdminUserService;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class FriendLinkServiceImpl implements FriendLinkService &#123;

    @Autowired
    private FriendLinkRepository friendLinkRepository;
    @Override
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO) &#123;
        friendLinkRepository.save(friendLinkMO); //有id更新 无id直接保存
    &#125;

    @Override
    public List&lt;FriendLinkMO&gt; queryAllFriendLinkList() &#123;
//        Pageable pageable = PageRequest.of(1,10);
//        friendLinkRepository.findAll(pageable);
        return friendLinkRepository.findAll();
    &#125;
&#125;
</code></pre>
<h3 id="友情链接删除-【MongoDB】-增加真实删除"><a href="#友情链接删除-【MongoDB】-增加真实删除" class="headerlink" title="友情链接删除 【MongoDB】[增加真实删除]"></a>友情链接删除 【MongoDB】[增加真实删除]</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
...
/*
@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
    @ApiOperation(value = &quot;查询改友情连接列表&quot;, notes = &quot;查询改友情连接列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getFriendLinkList&quot;)
    public GraceJSONResult getFriendLinkList();
*/
    @ApiOperation(value = &quot;删除改友情连接列表&quot;, notes = &quot;删除改友情连接列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/delete&quot;)
    public GraceJSONResult delete(@RequestParam String linkId);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
@Override
    public GraceJSONResult delete(String linkId) &#123;
        friendLinkService.delete(linkId);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
    /**
     * 删除友情链接
     */
    public void delete(String linkId);
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
@Override
    public void delete(String linkId) &#123;
        friendLinkRepository.deleteById(linkId);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java 【增加友链拦截器】
/*
package com.imooc.api.config;

import com.imooc.api.interceptors.AdminTokenInterceptor;
import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);
        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;)
                .addPathPatterns(&quot;/fs/uploadToGridFS&quot;)
*/
                .addPathPatterns(&quot;/friendLinkMng/saveOrUpdateFriendLink&quot;)
                .addPathPatterns(&quot;/friendLinkMng/getFriendLinkList&quot;)
                .addPathPatterns(&quot;/friendLinkMng/delete&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="【作业】文章分类管理-新增或修改分类、查询分类列表、用户端查询分类列表"><a href="#【作业】文章分类管理-新增或修改分类、查询分类列表、用户端查询分类列表" class="headerlink" title="【作业】文章分类管理 [新增或修改分类、查询分类列表、用户端查询分类列表]"></a>【作业】文章分类管理 <del>[新增或修改分类、查询分类列表、用户端查询分类列表]</del></h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/categoryMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/categoryMng.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/80972817">@RequestBody的使用-CSDN博客</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/admin/CategoryMngControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveCatrgoryBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@Api(value = &quot;文章分类维护&quot;, tags = &#123;&quot;文章分类维护controller&quot;&#125;)
@RequestMapping(&quot;categoryMng&quot;)
public interface CategoryMngControllerApi &#123;
    @PostMapping(&quot;saveOrUpdateCategory&quot;)
    @ApiOperation(value = &quot;新增或修改分类&quot;, notes = &quot;新增或修改分类&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult saveOrUpdateCategory(@RequestBody @Valid SaveCatrgoryBO saveCatrgoryBO,
                                                BindingResult result);
    @PostMapping(&quot;getCatList&quot;)
    @ApiOperation(value = &quot;查询分类列表&quot;, notes = &quot;查询分类列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult getCatList();

    @GetMapping(&quot;getCats&quot;)
    @ApiOperation(value = &quot;用户端查询分类列表&quot;, notes = &quot;用户端查询分类列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult getCats();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/CategoryMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.CategoryService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.CategoryMngControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Category;
import com.imooc.pojo.bo.SaveCatrgoryBO;
import com.imooc.utils.JsonUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
public class CategoryMngController extends BaseController implements CategoryMngControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(CategoryMngController.class);

    @Autowired
    private CategoryService categoryService;

    @Override
    public GraceJSONResult saveOrUpdateCategory(SaveCatrgoryBO saveCatrgoryBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
        // 判断BindingResult是否保存错误的验证信息，如果有，则直接return
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;
        Category newCat = new Category();
        BeanUtils.copyProperties(saveCatrgoryBO,newCat);
        // id为空新增，不为空修改
        if (saveCatrgoryBO.getId() == null)&#123;
            //查询新增的分类名称不能重复存在
            boolean isExist = categoryService.queryCatIsExist(newCat.getName(), null);
            if (!isExist)&#123;
                //新增到数据库
                categoryService.createCategory(newCat);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.CATEGORY_EXIST_ERROR);
            &#125;
        &#125;else &#123;
            //查询修改的分类名称不能重复存在
            boolean isExist = categoryService.queryCatIsExist(newCat.getName(), saveCatrgoryBO.getOldName());
            if (!isExist)&#123;
                //修改到数据库
                categoryService.modifyCategory(newCat);
            &#125; else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.CATEGORY_EXIST_ERROR);
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult getCatList() &#123;
        List&lt;Category&gt; categoryList = categoryService.queryCategoryList();
        return GraceJSONResult.ok(categoryList);
    &#125;

    @Override
    public GraceJSONResult getCats() &#123;
        // 先从redis中查询，如果有，则返回，如果没有，则查询数据库库后先放缓存，放返回
        String allCatJson = redis.get(REDIS_ALL_CATEGORY);

        List&lt;Category&gt; categoryList = null;
        if (StringUtils.isBlank(allCatJson)) &#123;
            categoryList = categoryService.queryCategoryList();
            redis.set(REDIS_ALL_CATEGORY, JsonUtils.objectToJson(categoryList));
        &#125; else &#123;
            categoryList = JsonUtils.jsonToList(allCatJson, Category.class);
        &#125;

        return GraceJSONResult.ok(categoryList);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/CategoryService.java
package com.imooc.admin.service;

import com.imooc.pojo.Category;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增文章分类
     */
    public void createCategory(Category category);

    /**
     * 修改文章分类列表
     */
    public void modifyCategory(Category category);

    /**
     * 查询分类名是否已经存在
     */
    public boolean queryCatIsExist(String catName, String oldCatName);

    /**
     * 获得文章分类列表
     */
    public List&lt;Category&gt; queryCategoryList();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/CategoryServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.CategoryMapper;
import com.imooc.admin.service.CategoryService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Category;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.List;

import static com.imooc.api.BaseController.REDIS_ALL_CATEGORY;


@Service
public class CategoryServiceImpl implements CategoryService &#123;
    @Autowired
    public CategoryMapper categoryMapper;
    @Autowired
    public RedisOperator redis;

    @Transactional
    @Override
    public void createCategory(Category category) &#123;
// 分类不会很多，所以id不需要自增，这个表的数据也不会多到几万甚至分表，数据都会集中在一起
        int result = categoryMapper.insert(category);
        if (result != 1)&#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
            /**
             * 不建议如下做法：
             * 1. 查询redis中的categoryList
             * 2. 转化categoryList为list类型
             * 3. 在categoryList中add一个当前的category
             * 4. 再次转换categoryList为json，并存入redis中
             */
            // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
            redis.del(REDIS_ALL_CATEGORY);
        &#125;
    &#125;

    @Transactional
    @Override
    public void modifyCategory(Category category) &#123;
        int result = categoryMapper.updateByPrimaryKey(category);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125;
        // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
        redis.del(REDIS_ALL_CATEGORY);
    &#125;

    @Override
    public boolean queryCatIsExist(String catName, String oldCatName) &#123;
        Example example = new Example(Category.class);
        Example.Criteria catCriteria = example.createCriteria();
        catCriteria.andEqualTo(&quot;name&quot;, catName);
        if (StringUtils.isNotBlank(oldCatName)) &#123;
            catCriteria.andNotEqualTo(&quot;name&quot;, oldCatName);
        &#125;

        List&lt;Category&gt; catList = categoryMapper.selectByExample(example);

        boolean isExist = false;
        if (catList != null &amp;&amp; !catList.isEmpty() &amp;&amp; catList.size() &gt; 0) &#123;
            isExist = true;
        &#125;

        return isExist;
    &#125;

    @Override
    public List&lt;Category&gt; queryCategoryList() &#123;
        return categoryMapper.selectAll();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/mapper/CategoryMapper.java
package com.imooc.admin.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Category;
import org.springframework.stereotype.Repository;

@Repository
public interface CategoryMapper extends MyMapper&lt;Category&gt; &#123;
&#125;
</code></pre>
<pre><code class="xml">service-admin  resources/mapper/CategoryMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.admin.mapper.CategoryMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Category&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;tag_color&quot; property=&quot;tagColor&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public abstract class BaseController &#123;
    @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_USER_INFO = &quot;redis_user_info&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_ADMIN_TOKEN = &quot;redis_admin_token&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_ALL_CATEGORY = &quot;redis_all_category&quot;;

    public static final String REDIS_WRITER_FANS_COUNTS = &quot;redis_writer_fans_counts&quot;;
    public static final String REDIS_MY_FOLLOW_COUNTS = &quot;redis_my_follow_counts&quot;;

    public static final String REDIS_ARTICLE_READ_COUNTS = &quot;redis_article_read_counts&quot;;
    public static final String REDIS_ALREADY_READ = &quot;redis_already_read&quot;;

    public static final String REDIS_ARTICLE_COMMENT_COUNTS = &quot;redis_article_comment_counts&quot;;

    @Value(&quot;$&#123;website.domain-name&#125;&quot;)
    public String DOMAIN_NAME;
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;
    public static final Integer COOKIE_DELETE = 0;

    public static final Integer COMMON_START_PAGE = 1;
    public static final Integer COMMON_PAGE_SIZE = 10;
&#125;...
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Category.java
package com.imooc.pojo;

import javax.persistence.Column;
import javax.persistence.Id;

public class Category &#123;
    @Id
    private Integer id;

    /**
     * 分类名，比如：科技，人文，历史，汽车等等
     */
    private String name;

    /**
     * 标签颜色
     */
    @Column(name = &quot;tag_color&quot;)
    private String tagColor;
&#125;Getter + Setter
</code></pre>
<h3 id="查询用户列表-设置时间日期转换配置-【用户管理】"><a href="#查询用户列表-设置时间日期转换配置-【用户管理】" class="headerlink" title="查询用户列表_设置时间日期转换配置 【用户管理】"></a>查询用户列表_设置时间日期转换配置 【用户管理】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/AppUserMngControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.Date;

@Api(value = &quot;用户管理相关的接口定义&quot;,tags = &#123;&quot;用户管理相关功能的controller&quot;&#125;)
@RequestMapping(&quot;appUser&quot;)
public interface AppUserMngControllerApi &#123;
    @ApiOperation(value = &quot;查询所有网站用户&quot;,notes = &quot;查询所有网站用户&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;queryAll&quot;)
    public GraceJSONResult queryAll(@RequestParam String nickname,
                                    @RequestParam Integer status,
                                    @RequestParam Date startDate,
                                    @RequestParam Date endDate,
                                    @RequestParam Integer page,
                                    @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/AppUserMngController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.AppUserMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;

@RestController
public class AppUserMngController extends BaseController implements AppUserMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AppUserMngController.class);
// 字符串无法直接转换成Date类型 需要工具类转换 DateConverterConfig com/imooc/api/config/DateConverterConfig.java

    @Override
    public GraceJSONResult queryAll(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        System.out.println(startDate);
        System.out.println(endDate);
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        return GraceJSONResult.ok();
    &#125;
&#125;
// http://admin.imoocnews.com:9090/imooc-news/admin/userList.html
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/DateConverterConfig.java
package com.imooc.api.config;


import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * 请求路径url中的参数进行时间日期类型的转换，字符串-&gt;日期Date
 */
@Configuration
public class DateConverterConfig implements Converter&lt;String, Date&gt; &#123;

    private static final List&lt;String&gt; formatterList = new ArrayList&lt;&gt;(4);
    static&#123;
        formatterList.add(&quot;yyyy-MM&quot;);
        formatterList.add(&quot;yyyy-MM-dd&quot;);
        formatterList.add(&quot;yyyy-MM-dd hh:mm&quot;);
        formatterList.add(&quot;yyyy-MM-dd hh:mm:ss&quot;);
    &#125;

    @Override
    public Date convert(String source) &#123;
        String value = source.trim();
        if (&quot;&quot;.equals(value)) &#123;
            return null;
        &#125;
        if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(0));
        &#125;else if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(1));
        &#125;else if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; &#123;1&#125;\\d&#123;1,2&#125;:\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(2));
        &#125;else if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; &#123;1&#125;\\d&#123;1,2&#125;:\\d&#123;1,2&#125;:\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(3));
        &#125;else &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_DATE_PARSER_ERROR);
        &#125;
        return null;
    &#125;

    /**
     * 日期转换方法
     * @param dateStr
     * @param formatter
     * @return
     */
    public Date parseDate(String dateStr, String formatter) &#123;
        Date date=null;
        try &#123;
            DateFormat dateFormat = new SimpleDateFormat(formatter);
            date = dateFormat.parse(dateStr);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return date;
    &#125;
&#125;
</code></pre>
<h3 id="查询用户列表-实现service与联调-【用户管理】"><a href="#查询用户列表-实现service与联调-【用户管理】" class="headerlink" title="查询用户列表_实现service与联调 【用户管理】"></a>查询用户列表_实现service与联调 【用户管理】</h3><pre><code class="java">service-user  com/imooc/user/service/AppUserMngService.java
package com.imooc.user.service;

import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;

public interface AppUserMngService &#123;
    /**
     * 查询管理员列表
     * @param nickname
     * @param status
     * @param startDate
     * @param endDate
     * @param page
     * @param pageSize
     * @return
     */
    public PagedGridResult queryAllUserList(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/service/BaseService.java
package com.imooc.api.service;

import com.github.pagehelper.PageInfo;
import com.imooc.utils.PagedGridResult;

import java.util.List;

public class BaseService &#123;
    public PagedGridResult setterPagedGrid(List&lt;?&gt; list, Integer page)&#123; //类型是? 后期不确定是什么泛型
        PageInfo&lt;?&gt; pageList = new PageInfo&lt;&gt;(list);
        PagedGridResult gridResult = new PagedGridResult();
        gridResult.setRows(list);
        gridResult.setPage(page);
        gridResult.setRecords(pageList.getTotal());
        gridResult.setTotal(pageList.getPages());
        return gridResult;

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/AppUserMngServiceImpl.java
package com.imooc.user.service.impl;

import com.github.pagehelper.PageHelper;
import com.imooc.api.service.BaseService;
import com.imooc.enums.Sex;
import com.imooc.enums.UserStatus;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.service.AppUserMngService;
import com.imooc.user.service.UserService;
import com.imooc.utils.*;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class AppUserMngServiceImpl extends BaseService implements AppUserMngService &#123;
    @Autowired
    public AppUserMapper appUserMapper;

    @Override
    public PagedGridResult queryAllUserList(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        Example example = new Example(AppUser.class);
        example.orderBy(&quot;createdTime&quot;).desc();
        Example.Criteria criteria = example.createCriteria();
        if (StringUtils.isNotBlank(nickname)) &#123;
            criteria.andLike(&quot;nickname&quot;, &quot;%&quot; + nickname + &quot;%&quot;);
        &#125;
        if (UserStatus.isUserStatusValid(status))&#123;
            criteria.andEqualTo(&quot;activeStatus&quot;, status); //对比状态
        &#125;
        if (startDate != null)&#123;
            criteria.andGreaterThanOrEqualTo(&quot;createdTime&quot;, startDate);//数据库和传入参数对比
        &#125;
        if (endDate != null)&#123;
            criteria.andLessThanOrEqualTo(&quot;endTime&quot;, endDate);//数据库和传入参数对比
        &#125;
        PageHelper.startPage(page, pageSize);
        List&lt;AppUser&gt; list = appUserMapper.selectByExample(example);

        return setterPagedGrid(list,page);
    &#125;
&#125;
</code></pre>
<h3 id="查询用户账户-冻结与解封-【用户管理】"><a href="#查询用户账户-冻结与解封-【用户管理】" class="headerlink" title="查询用户账户_冻结与解封 【用户管理】"></a>查询用户账户_冻结与解封 【用户管理】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/AppUserMngControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.Date;

@Api(value = &quot;用户管理相关的接口定义&quot;,tags = &#123;&quot;用户管理相关功能的controller&quot;&#125;)
@RequestMapping(&quot;appUser&quot;)
public interface AppUserMngControllerApi &#123;
    @ApiOperation(value = &quot;查询所有网站用户&quot;,notes = &quot;查询所有网站用户&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;queryAll&quot;)
    public GraceJSONResult queryAll(@RequestParam String nickname,
                                    @RequestParam Integer status,
                                    @RequestParam Date startDate,
                                    @RequestParam Date endDate,
                                    @RequestParam Integer page,
                                    @RequestParam Integer pageSize);

    @ApiOperation(value = &quot;查看用户详情&quot;,notes = &quot;查看用户详情&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;userDetail&quot;)
    public GraceJSONResult userDetail(@RequestParam String userId);

    @ApiOperation(value = &quot;冻结用户或者解冻用户&quot;,notes = &quot;冻结用户或者解冻用户&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;freezeUserOrNot&quot;)
    public GraceJSONResult freezeUserOrNot(@RequestParam String userId,@RequestParam Integer doStatus);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/AppUserMngController.java
@RestController
public class AppUserMngController extends BaseController implements AppUserMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AppUserMngController.class);
    
    @Autowired
    private AppUserMngService appUserMngService;
    @Autowired
    private UserService userService;
......
    
     @Override
    public GraceJSONResult freezeUserOrNot(String userId, Integer doStatus) &#123;
        if (!UserStatus.isUserStatusValid(doStatus))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_STATUS_ERROR);
        &#125;
        appUserMngService.freezeUserOrNot(userId, doStatus);
        //若冻结后 用户处于登录状态 还可以进行操作 所以要刷新用户状态
        //方法①：删除用户会话，从而保证用户需要重新登陆以后再来刷新她的会话状态
        redis.del(REDIS_USER_INFO + &quot;:&quot; + userId);
        //方法②：查询最新用户的信息，重新放入redis中，做一次更新
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/AppUserMngService.java
package com.imooc.user.service;

import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;

public interface AppUserMngService &#123;
    /**
     * 查询管理员列表
     */
    public PagedGridResult queryAllUserList(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

    /**
     * 冻结用户账号或者解除冻结
     */
    public void freezeUserOrNot(String userId, Integer doStatus);

&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/AppUserMngServiceImpl.java
    @Transactional
    @Override
    public void freezeUserOrNot(String userId, Integer doStatus) &#123;
        AppUser user = new AppUser();
        user.setId(userId);
        user.setActiveStatus(doStatus);
        appUserMapper.updateByPrimaryKeySelective(user);
    &#125;
</code></pre>
<h3 id="梳理文章article表结构-【文章服务】"><a href="#梳理文章article表结构-【文章服务】" class="headerlink" title="梳理文章article表结构 【文章服务】"></a>梳理文章article表结构 【文章服务】</h3><ul>
<li><strong>构建文章服务</strong></li>
<li><strong>作者中心发表文章</strong></li>
<li><strong>作者中心内容管理</strong></li>
<li><strong>自动审核<del>[阿里客户端]</del>，手动审核</strong></li>
</ul>
<h3 id="构建文章服务工程-【文章服务】"><a href="#构建文章服务工程-【文章服务】" class="headerlink" title="构建文章服务工程 【文章服务】"></a>构建文章服务工程 【文章服务】</h3><blockquote>
<p>新创建一个Module<br>GroupId：com.imooc<br>ArtifactId：imooc-news-dev-service-article<br>pom参考service-admin移植  resources里的所有文件(除mapper)也要移植</p>
</blockquote>
<pre><code class="xml">service-article  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-article&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">resources logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-article&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-article&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/service-article.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java
package com.imooc.article;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;

========================================================================
http://localhost:8001/hello
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: null
&#125;
</code></pre>
<pre><code class="yaml">service-article  application-dev
server:
  port: 8001

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
## setup CN from java, This is resource
website:
  domain-name: imoocnews.com

## open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<pre><code class="yaml">############################################################
#
# admin用户微服务
# web访问端口号  约定：8001
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-article
  datasource: # 数据源的相关配置
    type: com.zaxxer.hikari.HikariDataSource          # 数据源类型：HikariCP
    driver-class-name: org.mariadb.jdbc.Driver       # mysql驱动
    url: jdbc:mysql://localhost:3306/imooc-news-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;sessionVariables=tx_isolation=&#39;READ-COMMITTED&#39;
    username: root
    password: root
    hikari:
      connection-timeout: 30000       # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 默认:30秒
      minimum-idle: 5                 # 最小连接数
      maximum-pool-size: 20           # 最大连接数
      auto-commit: true               # 自动提交
      idle-timeout: 600000            # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟
      pool-name: DateSourceHikariCP     # 连接池名字
      max-lifetime: 1800000           # 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟 1800000ms
      connection-test-query: SELECT 1
      data-source-properties:
        tx_isolation: &#39;READ-COMMITTED&#39;
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8

  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
############################################################
#
# mybatis 配置
#
############################################################
mybatis:
  type-aliases-package: com.imooc.pojo          # 所有POJO类所在包路径
  mapper-locations: classpath:mapper/*.xml      # mapper映射文件

############################################################
#
# mybatis mapper 配置
#
############################################################
# 通用 Mapper 配置
mapper:
  mappers: com.imooc.my.mapper.MyMapper
  not-empty: false    # 在进行数据库操作的的时候，判断表达式 username != null, 是否追加 username != &#39;&#39;
  identity: MYSQL
# 分页插件配置
pagehelper:
  helperDialect: mysql
  supportMethodsArguments: true
</code></pre>
<h3 id="summernote与多文件上传需求-【发头条】"><a href="#summernote与多文件上传需求-【发头条】" class="headerlink" title="summernote与多文件上传需求 【发头条】"></a>summernote与多文件上传需求 【发头条】</h3><p><a target="_blank" rel="noopener" href="https://summernote.org/">https://summernote.org/</a></p>
<pre><code class="html">【前端工程里面的】createArticle.html
...
&lt;script src=&quot;libs/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;libs/axios.min.js&quot;&gt;&lt;/script&gt;

&lt;link href=&quot;./libs/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script src=&quot;./libs/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;libs/layDate-v5.0.9/laydate/laydate.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./libs/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;link href=&quot;./libs/summernote/dist/summernote.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script src=&quot;./libs/summernote/dist/summernote.js&quot;&gt;&lt;/script&gt;
&lt;!-- 中文汉化 --&gt;
&lt;script src=&quot;libs/summernote/lang/summernote-zh-CN.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

......
&lt;!-- 富文本编辑器 --&gt;
        &lt;div id=&quot;editor2&quot; class=&quot;editor-container&quot;&gt;

            &lt;div class=&quot;article-title-wrapper&quot;&gt;
                &lt;input id=&quot;title&quot; class=&quot;article-title&quot; placeholder=&quot;请输入文字标题（6-30长度）&quot; v-model=&quot;articleTitle&quot; maxlength=&quot;30&quot;/&gt;
            &lt;/div&gt;

            &lt;div class=&quot;article-content-wrapper&quot;&gt;
                &lt;div id=&quot;summernote&quot; class=&quot;summernote&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;other-info&quot;&gt;
                &lt;div class=&quot;cover-wrapper&quot;&gt;
                    &lt;div class=&quot;cover&quot;&gt;文章领域&lt;/div&gt;
                    &lt;div class=&quot;choose-type&quot;&gt;
                        &lt;!-- &lt;select v-model=&quot;articleCategory&quot;&gt;
                            &lt;option value=&quot;0&quot;&gt;请选择&lt;/option&gt;
                            &lt;option value=&quot;1&quot;&gt;汽车&lt;/option&gt;
                            &lt;option value=&quot;2&quot;&gt;科技&lt;/option&gt;
                            &lt;option value=&quot;3&quot;&gt;历史&lt;/option&gt;
                        &lt;/select&gt; --&gt;

                        &lt;select v-model=&quot;articleCategory&quot;&gt;
                            &lt;option :value=&quot;cat.id&quot; v-for=&quot;(cat, index) in catList&quot; v-key=&quot;index&quot;&gt;&#123;&#123;cat.name&#125;&#125;&lt;/option&gt;
                        &lt;/select&gt;
                        
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;cover-wrapper&quot;&gt;
                    &lt;div class=&quot;cover&quot;&gt;文章封面&lt;/div&gt;
                    &lt;div class=&quot;choose-type&quot;&gt;
                        &lt;div&gt;&lt;input type=&quot;radio&quot; name=&quot;articleType&quot; v-model=&quot;articleType&quot; value=&quot;1&quot; checked/&gt;&lt;span class=&quot;choose-words&quot;&gt;单封面&lt;/span&gt;&lt;/div&gt;
                        &lt;div style=&quot;margin-left: 30px;&quot;&gt;&lt;input type=&quot;radio&quot; v-model=&quot;articleType&quot; value=&quot;2&quot; name=&quot;articleType&quot;/&gt;&lt;span class=&quot;choose-words&quot;&gt;无封面&lt;/span&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;cover-wrapper&quot; v-show=&quot;articleType==1&quot;&gt;
                    &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;choose-cover&quot;&gt;
                        &lt;div class=&quot;uploader-comp&quot;&gt;
                            &lt;div id=&quot;block-choose&quot; class=&quot;block-choose&quot; :style=&quot;coverStyle&quot;&gt;
                                &lt;img src=&quot;./img/icon-go-upload.png&quot; style=&quot;width: 20px; height: 20px; align-self: center;&quot; v-show=&quot;articleCover == &#39;&#39; || articleCover == null&quot;/&gt;
                            &lt;/div&gt;
                            &lt;input type=&quot;file&quot; @change=&quot;uploadCover&quot; @mouseover=&quot;mouseOver&quot; @mouseout=&quot;mouseOut&quot; id=&quot;inputPic&quot; class=&quot;inputPic&quot; accept=&quot;image/jpeg,image/jpg,image/png&quot;&gt;
                        &lt;/div&gt;
                        &lt;div style=&quot;margin-top: 10px; color: #9b9d9e;&quot;&gt;请上传JPG、JPEG、PNG格式的封面图噢~&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;publish-bottom&quot;&gt;
                &lt;div class=&quot;buttons&quot;&gt;
                    &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;goBack&quot;&gt;返回&lt;/button&gt;
                    &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;preview&quot;&gt;预览&lt;/button&gt;
                    &lt;!-- &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;save&quot;&gt;保存草稿&lt;/button&gt; --&gt;
                    &lt;!-- FIXME: 计算剩余时间，使用RMQ延时队列，或分布式定时任务 --&gt;
                    &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;doTiming&quot;&gt;&#123;&#123;appointWords&#125;&#125;&lt;/button&gt;
                    
                    &lt;input type=&quot;text&quot; class=&quot;timing-date-picker&quot; placeholder=&quot;定时日期&quot; id=&quot;choose-date&quot; v-show=&quot;isAppoint==1&quot; readonly&gt;

                    &lt;button class=&quot;red-btn&quot; type=&quot;button&quot; @click=&quot;publish&quot;&gt;发布文章&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

......
// 初始化编辑器
            $(&#39;#summernote&#39;).summernote(&#123;
                placeholder: &#39;请输入正文...&#39;,
                lang: &#39;zh-CN&#39;,
                height: 600,
                width: 800,
                border: 0,
                // disableDragAndDrop: true, // 禁止文件拖放
                toolbar: [
                    [&#39;style&#39;, [&#39;style&#39;]],
                    [&#39;font&#39;, [&#39;bold&#39;, &#39;underline&#39;, &#39;clear&#39;]],
                    [&#39;color&#39;, [&#39;color&#39;]],
                    [&#39;para&#39;, [&#39;ul&#39;, &#39;ol&#39;, &#39;paragraph&#39;]],
                    [&#39;table&#39;, [&#39;table&#39;]],
                    [&#39;insert&#39;, [&#39;link&#39;, &#39;picture&#39;]],
                    [&#39;view&#39;, [&#39;fullscreen&#39;, &#39;codeview&#39;, &#39;help&#39;]]
                ],
</code></pre>
<h3 id="实现多文件上传uploadSomeFiles-【发头条】"><a href="#实现多文件上传uploadSomeFiles-【发头条】" class="headerlink" title="实现多文件上传uploadSomeFiles 【发头条】"></a>实现多文件上传<del>uploadSomeFiles</del> 【发头条】</h3><p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html">媒体号作家中心 | 发文章 (imoocnews.com)</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploaderControllerApi.java
package com.imooc.api.controller.files;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploaderControllerApi &#123;
    /**
     * 上传单文件
     * @param userId
     * @param file
     * @return
     * @throws Exception
     */
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;上传用户头像&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    /**
     * 上传多文件
     * @param userId
     * @param files
     * @return
     * @throws Exception
     */
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;上传用户头像&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadSomeFiles&quot;)  //因为前端createArticle.html 178行 multiForm.append(&#39;files&#39;,f,f.name);
    public GraceJSONResult uploadSomeFiles(@RequestParam String userId, MultipartFile[] files) throws Exception;
......
&#125;
</code></pre>
<pre><code class="java">service-file  com/imooc/files/controller/FileUploaderController.java
......
@Override
    public GraceJSONResult uploadSomeFiles(String userId, MultipartFile[] files) throws Exception &#123;
        // 声明一个list，用于存放多个图片的地址路径，返回到前端
        List&lt;String&gt; imageUrlList = new ArrayList&lt;&gt;();
        if (files != null &amp;&amp; files.length &gt; 0)&#123;
            for (MultipartFile file: files)&#123;
                String path = &quot;&quot;;
                if (file != null)&#123;
                    // 获得文件上传的名称
                    String fileName = file.getOriginalFilename();
                    //判断文件名不能为空
                    if (StringUtils.isNotBlank(fileName))&#123;
                        String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                        //获得后缀名
                        String suffix = fileNameArr[fileNameArr.length - 1];
                        //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                        if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                                !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                                !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                        )&#123;
                           continue;
                        &#125;
                        // fdfs执行上传     要让外面得以访问 ①需要把内网的环境发布到公网 [内网穿透]  ②路由器端口映射到外网  ③fastdfs安装到公网里
                        // path = uploaderService.uploadFdfs(file, suffix);
                        // OSS执行上传
                        path = uploaderService.uploadOSS(file, userId, suffix);
                    &#125;else &#123;
                        continue;
                    &#125;
                &#125;else &#123;
                    continue;
                &#125;
                String finalPath = &quot;&quot;;
                if (StringUtils.isNotBlank(path))&#123;
//            finalPath = fileResource.getHost() + path;
                    finalPath = fileResource.getOssHost() + path;
                    // FIXME: 放入到imageUrlList之前，需要对图片做一次审核 [doAliImageReview]
                    imageUrlList.add(finalPath);
                &#125;  else&#123;
                    continue;
                &#125;
//                return GraceJSONResult.ok(finalPath);
//        return GraceJSONResult.ok(doAliImageReview(finalPath)); //这里加了图片审核咯
            &#125;
        &#125;
        return GraceJSONResult.ok(imageUrlList);
    &#125;
......
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java 
package com.imooc.api.config;
//【增加拦截uploadSomeFiles】
@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;)
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;);

        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;)
                .addPathPatterns(&quot;/fs/uploadToGridFS&quot;)
                .addPathPatterns(&quot;/friendLinkMng/saveOrUpdateFriendLink&quot;)
                .addPathPatterns(&quot;/friendLinkMng/getFriendLinkList&quot;)
                .addPathPatterns(&quot;/friendLinkMng/delete&quot;)
                .addPathPatterns(&quot;/categoryMng/saveOrUpdateCategory&quot;)
                .addPathPatterns(&quot;/categoryMng/getCatList&quot;);

        registry.addInterceptor(userActiveInterceptor())
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="获得列表-业务接口解耦与Redis缓存应用-【文章领域】"><a href="#获得列表-业务接口解耦与Redis缓存应用-【文章领域】" class="headerlink" title="获得列表_业务接口解耦与Redis缓存应用 【文章领域】"></a>获得列表_业务接口解耦与Redis缓存应用 【文章领域】</h3><blockquote>
<p>getCatList 和 getCats 一个是用户端一个是admin 业务体系不一样 所以同样是查询分类列表<br>但是还是应该拆开 使耦合减少 得到高效解耦<br>查询放在Redis里面 效率变高</p>
<p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html">媒体号作家中心 | 发文章 (imoocnews.com)</a><br>刷新一下 文章领域就可以找到那些分类<br>Redis里面会有信息 redis_all_category<br>[{“id”:2,”name”:”汽车”,”tagColor”:”#8939bd”},{“id”:3,”name”:”娱乐”,”tagColor”:”#c939aa”},{“id”:5,”name”:”地理”,”tagColor”:”#57394a”},{“id”:6,”name”:”历史”,”tagColor”:”#29ab4a”},{“id”:7,”name”:”科技”,”tagColor”:”#2467bc”},{“id”:9,”name”:”体育”,”tagColor”:”#c98f4a”},{“id”:10,”name”:”搞笑”,”tagColor”:”#68b84a”},{“id”:11,”name”:”技术”,”tagColor”:”#c9394a”},{“id”:12,”name”:”慕课”,”tagColor”:”#682aa8”},{“id”:13,”name”:”技能”,”tagColor”:”#c9394a”},{“id”:14,”name”:”课网”,”tagColor”:”#c9a24a”}]</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/admin/CategoryMngControllerApi.java
// 【getCasts】
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveCatrgoryBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@Api(value = &quot;文章分类维护&quot;, tags = &#123;&quot;文章分类维护controller&quot;&#125;)
@RequestMapping(&quot;categoryMng&quot;)
public interface CategoryMngControllerApi &#123;
    @PostMapping(&quot;saveOrUpdateCategory&quot;)
    @ApiOperation(value = &quot;新增或修改分类&quot;, notes = &quot;新增或修改分类&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult saveOrUpdateCategory(@RequestBody @Valid SaveCatrgoryBO saveCatrgoryBO,
                                                BindingResult result);
    @PostMapping(&quot;getCatList&quot;)
    @ApiOperation(value = &quot;查询分类列表&quot;, notes = &quot;查询分类列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult getCatList();

    @GetMapping(&quot;getCats&quot;)
    @ApiOperation(value = &quot;用户端查询分类列表&quot;, notes = &quot;用户端查询分类列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult getCats();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/CategoryMngController.java
@Override
    public GraceJSONResult getCats() &#123;
        // 先从redis中查询，如果有，则返回，如果没有，则查询数据库库后先放缓存，放返回
        String allCatJson = redis.get(REDIS_ALL_CATEGORY);

        List&lt;Category&gt; categoryList = null;
        if (StringUtils.isBlank(allCatJson)) &#123;
            categoryList = categoryService.queryCategoryList();
            redis.set(REDIS_ALL_CATEGORY, JsonUtils.objectToJson(categoryList));
        &#125; else &#123;
            categoryList = JsonUtils.jsonToList(allCatJson, Category.class);
        &#125;

        return GraceJSONResult.ok(categoryList);
    &#125;
</code></pre>
<h3 id="admin端维护数据缓存-【文章领域】"><a href="#admin端维护数据缓存-【文章领域】" class="headerlink" title="admin端维护数据缓存 【文章领域】"></a>admin端维护数据缓存 【文章领域】</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/categoryMng.html">文章分类 | 运营管理平台 (imoocnews.com)</a><br>在管理员修改文章类型后 【课网 → 课课】<br><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html">媒体号作家中心 | 发文章 (imoocnews.com)</a><br>回到用户发文章的文章领域类型也会一起修改<br><a target="_blank" rel="noopener" href="http://www.imoocnews.com:9090/imooc-news/portal/index.html">慕课新闻 | 风间影月 (imoocnews.com)</a><br>同时首页上方的栏目框也会修改</p>
</blockquote>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/CategoryServiceImpl.java
@Service
public class CategoryServiceImpl extends BaseService implements CategoryService &#123;
    @Autowired
    public CategoryMapper categoryMapper;

    @Transactional
    @Override
    public void createCategory(Category category) &#123;
// 分类不会很多，所以id不需要自增，这个表的数据也不会多到几万甚至分表，数据都会集中在一起
        int result = categoryMapper.insert(category);
        if (result != 1)&#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
            /**
             * 不建议如下做法：
             * 1. 查询redis中的categoryList
             * 2. 转化categoryList为list类型
             * 3. 在categoryList中add一个当前的category
             * 4. 再次转换categoryList为json，并存入redis中
             */
            // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
            redis.del(REDIS_ALL_CATEGORY);
        &#125;
    &#125;

    @Transactional
    @Override
    public void modifyCategory(Category category) &#123;
        int result = categoryMapper.updateByPrimaryKey(category);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125;
        // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
        redis.del(REDIS_ALL_CATEGORY);
    &#125;
......
</code></pre>
<h3 id="发布文章入库Controller及验证【发头条】"><a href="#发布文章入库Controller及验证【发头条】" class="headerlink" title="发布文章入库Controller及验证【发头条】"></a>发布文章入库Controller及验证【发头条】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
package com.imooc.api.controller.article;

@Api(value = &quot;文章业务的controller&quot;, tags = &#123;&quot;文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article&quot;)
public interface ArticleControllerApi &#123;
    @PostMapping(&quot;createArticle&quot;)
    @ApiOperation(value = &quot;用户发文&quot;, notes = &quot;用户发文&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult createArticle(@RequestBody @Valid NewArticleBO newArticleBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
package com.imooc.article.controller;

@RestController
public class ArticleController extends BaseController implements ArticleControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(ArticleController.class);

    @Override
    public GraceJSONResult createArticle(NewArticleBO newArticleBO, BindingResult result) &#123;
            if (result.hasErrors())&#123;
                // 判断BindingResult是否保存错误的验证信息，如果有，则直接return
                Map&lt;String, String&gt; errorMap = getErrors(result);
                return GraceJSONResult.errorMap(errorMap);
            &#125;
            // 判断文章封面类型，单图必填，纯文字则设置为空
            if (newArticleBO.getArticleType() == ArticleCoverType.ONE_IMAGE.type)&#123;
                if (StringUtils.isBlank(newArticleBO.getArticleCover()))&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_CATEGORY_NOT_EXIST_ERROR);
                &#125;
            &#125; else if (newArticleBO.getArticleType() == ArticleCoverType.WORDS.type) &#123;
                newArticleBO.setArticleCover(&quot;&quot;);
            &#125;

        // 判断分类id是否存在
        String allCatJson = redis.get(REDIS_ALL_CATEGORY);
        Category temp = null;
        if (StringUtils.isBlank(allCatJson)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125; else &#123;
            List&lt;Category&gt; catList =
                    JsonUtils.jsonToList(allCatJson, Category.class);
            for (Category c : catList) &#123;
                if(c.getId() == newArticleBO.getCategoryId()) &#123;
                    temp = c;
                    break;
                &#125;
            &#125;
            if (temp == null) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_CATEGORY_NOT_EXIST_ERROR);
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
&#125;
http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/NewArticleBO.java
package com.imooc.pojo.bo;

import com.fasterxml.jackson.annotation.JsonFormat;
import org.hibernate.validator.constraints.Length;

import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import java.util.Date;
/**
 * 用户发文的BO
 */
public class NewArticleBO &#123;

    @NotBlank(message = &quot;文章标题不能为空&quot;)
    @Length(max = 30, message = &quot;文章标题长度不能超过30&quot;)
    private String title;

    @NotBlank(message = &quot;文章内容不能为空&quot;)
    @Length(max = 9999, message = &quot;文章内容长度不能超过10000&quot;)
    private String content;

    @NotNull(message = &quot;请选择文章领域&quot;)
    private Integer categoryId;

    @NotNull(message = &quot;请选择正确的文章封面类型&quot;)
    @Min(value = 1, message = &quot;请选择正确的文章封面类型&quot;)
    @Max(value = 2, message = &quot;请选择正确的文章封面类型&quot;)
    private Integer articleType;
    private String articleCover;

    @NotNull(message = &quot;文章发布类型不正确&quot;)
    @Min(value = 0, message = &quot;文章发布类型不正确&quot;)
    @Max(value = 1, message = &quot;文章发布类型不正确&quot;)
    private Integer isAppoint;

    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) // 前端日期字符串传到后端后，转换为Date类型
    private Date publishTime;

    @NotBlank(message = &quot;用户未登录&quot;)
    private String publishUserId;
&#125;Getter + Setter
</code></pre>
<h3 id="发布文章入库Service及联调【也可以定时发布】"><a href="#发布文章入库Service及联调【也可以定时发布】" class="headerlink" title="发布文章入库Service及联调【也可以定时发布】"></a>发布文章入库Service及联调【也可以定时发布】</h3><p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html">http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html</a><br>发布完成后去数据库article中就会存在数据了</p>
<pre><code class="xml">generator-datebase  generatorConfig-article.xml [逆向生成]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;!-- 通用mapper所在目录 --&gt;
        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;com.imooc.my.mapper.MyMapper&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/imooc-news-dev&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 对应生成的pojo所在包 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.imooc.pojo&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot;/&gt;

        &lt;!-- 对应生成的mapper所在目录 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper.article&quot; targetProject=&quot;mybatis-generator-database/src/main/resources&quot;/&gt;

        &lt;!-- 配置mapper对应的java映射 --&gt;
        &lt;javaClientGenerator targetPackage=&quot;com.imooc.article.mapper&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt;

        &lt;!-- 数据库表 --&gt;
        &lt;table tableName=&quot;comments&quot;&gt;&lt;/table&gt;

    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="java">generator-datebase  com/imooc/mybatis/utils/ArticleGenerator.java
//[运行时候就会自动生成对应文件 目录是上面的generatorConfig-article.xml]
package com.imooc.mybatis.utils;

import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;


public class ArticleGenerator &#123;

    public void generator() throws Exception &#123;

        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        //指定 逆向工程配置文件
        File configFile = new File(&quot;mybatis-generator-database&quot;
                                            + File.separator
                                            + &quot;generatorConfig-article.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);

    &#125; 
    
    public static void main(String[] args) throws Exception &#123;
        try &#123;
            ArticleGenerator generatorSqlmap = new ArticleGenerator();
            generatorSqlmap.generator();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  mapper/ArticleMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.ArticleMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Article&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;title&quot; property=&quot;title&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;category_id&quot; property=&quot;categoryId&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;article_type&quot; property=&quot;articleType&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; property=&quot;articleCover&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;is_appoint&quot; property=&quot;isAppoint&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;article_status&quot; property=&quot;articleStatus&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;publish_user_id&quot; property=&quot;publishUserId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;publish_time&quot; property=&quot;publishTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;read_counts&quot; property=&quot;readCounts&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;comment_counts&quot; property=&quot;commentCounts&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;mongo_file_id&quot; property=&quot;mongoFileId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;content&quot; property=&quot;content&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;

import java.util.List;

public interface ArticleService &#123;
    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
package com.imooc.article.service.impl;

import com.imooc.api.service.BaseService;
import com.imooc.article.mapper.ArticleMapper;
import com.imooc.article.service.ArticleService;
import com.imooc.enums.ArticleAppointType;
import com.imooc.enums.ArticleReviewStatus;
import com.imooc.enums.YesOrNo;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Article;
import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.DateUtil;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

import static com.imooc.api.BaseController.REDIS_ALL_CATEGORY;


@Service
public class ArticleServiceImpl extends BaseService implements ArticleService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository
    @Autowired
    private Sid sid;

    @Transactional
    @Override
    public void createArticle(NewArticleBO newArticleBO, Category category) &#123;
        String articleId = sid.nextShort();

        Article article = new Article();
        BeanUtils.copyProperties(newArticleBO, article);

        article.setId(articleId);
        article.setCategoryId(category.getId());
        article.setArticleStatus(ArticleReviewStatus.REVIEWING.type);
        article.setCommentCounts(0);
        article.setReadCounts(0);

        article.setIsDelete(YesOrNo.NO.type);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());

        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;
            article.setPublishTime(newArticleBO.getPublishTime()); //用户可以在前端选择定时发布
        &#125; else if (article.getIsAppoint() == ArticleAppointType.IMMEDIATELY.type) &#123;
            article.setPublishTime(new Date());
        &#125;

        int res = articleMapper.insert(article);
        if (res != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_CREATE_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Article.java
package com.imooc.pojo;

import javax.persistence.Column;
import javax.persistence.Id;
import java.util.Date;

public class Article &#123;
    @Id
    private String id;

    /**
     * 文章标题
     */
    private String title;

    /**
     * 文章所属分类id
     */
    @Column(name = &quot;category_id&quot;)
    private Integer categoryId;

    /**
     * 文章类型，1：图文（1张封面），2：纯文字
     */
    @Column(name = &quot;article_type&quot;)
    private Integer articleType;

    /**
     * 文章封面图，article_type=1 的时候展示
     */
    @Column(name = &quot;article_cover&quot;)
    private String articleCover;

    /**
     * 是否是预约定时发布的文章，1：预约（定时）发布，0：即时发布    在预约时间到点的时候，把1改为0，则发布
     */
    @Column(name = &quot;is_appoint&quot;)
    private Integer isAppoint;

    /**
     * 文章状态，1：审核中（用户已提交），2：机审结束，等待人工审核，3：审核通过（已发布），4：审核未通过；5：文章撤回（已发布的情况下才能撤回和删除）
     */
    @Column(name = &quot;article_status&quot;)
    private Integer articleStatus;

    /**
     * 发布者用户id
     */
    @Column(name = &quot;publish_user_id&quot;)
    private String publishUserId;

    /**
     * 文章发布时间（也是预约发布的时间）
     */
    @Column(name = &quot;publish_time&quot;)
    private Date publishTime;

    /**
     * 用户累计点击阅读数（喜欢数）（点赞） - 放redis
     */
    @Column(name = &quot;read_counts&quot;)
    private Integer readCounts;

    /**
     * 文章评论总数。评论防刷，距离上次评论需要间隔时间控制几秒
     */
    @Column(name = &quot;comment_counts&quot;)
    private Integer commentCounts;

    @Column(name = &quot;mongo_file_id&quot;)
    private String mongoFileId;

    /**
     * 逻辑删除状态，非物理删除，1：删除，0：未删除
     */
    @Column(name = &quot;is_delete&quot;)
    private Integer isDelete;

    /**
     * 文章的创建时间
     */
    @Column(name = &quot;create_time&quot;)
    private Date createTime;

    /**
     * 文章的修改时间
     */
    @Column(name = &quot;update_time&quot;)
    private Date updateTime;

    /**
     * 文章内容，长度不超过9999，需要在前后端判断
     */
    private String content;
</code></pre>
<h3 id="构建定时任务-定时发布文章【定时任务】"><a href="#构建定时任务-定时发布文章【定时任务】" class="headerlink" title="构建定时任务 定时发布文章【定时任务】"></a>构建定时任务 定时发布文章【定时任务】</h3><p><a target="_blank" rel="noopener" href="https://cron.qqe2.com/">在线Cron表达式生成器 (qqe2.com)</a></p>
<pre><code class="java">service-article  com/imooc/article/task/TaskPublishArticles.java
package com.imooc.article.task;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.LocalDateTime;

@Configuration  // 1.标记配置类，使得springboot容器扫描到
@EnableScheduling // 2.开启定时任务
public class TaskPublishArticles &#123;
    @Scheduled(cron = &quot;0/3 * * * * ? &quot;)
    private void publishArticles()&#123;
        System.out.println(&quot;执行定时任务：&quot; + LocalDateTime.now());
    &#125;
&#125;

=================================================================
执行定时任务：2024-07-22T14:34:54.009
执行定时任务：2024-07-22T14:34:57.013
执行定时任务：2024-07-22T14:35:00.012
执行定时任务：2024-07-22T14:35:03.002
执行定时任务：2024-07-22T14:35:06.001
执行定时任务：2024-07-22T14:35:09.006
</code></pre>
<pre><code class="java">service-article  com/imooc/article/task/TaskPublishArticles.java
package com.imooc.article.task;

import com.imooc.article.service.ArticleService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.LocalDateTime;

@Configuration  // 1.标记配置类，使得springboot容器扫描到
@EnableScheduling // 2.开启定时任务
public class TaskPublishArticles &#123;
    @Autowired
    private ArticleService articleService;
    // 添加定时任务，注明定时任务的表达式
    // 【若文章数量庞大 需要RabbitMQ去做优化 后面会讲！】
    @Scheduled(cron = &quot;0/3 * * * * ? &quot;)
    private void publishArticles()&#123;
        System.out.println(&quot;执行定时任务：&quot; + LocalDateTime.now());
        // 4. 调用文章service，把当前时间应该发布的定时文章，状态改为即时
        articleService.updateAppointToPublish();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/ArticleMapperCustom.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Article;
import org.springframework.stereotype.Repository;

@Repository
public interface ArticleMapperCustom extends MyMapper&lt;Article&gt; &#123;
    public void updateAppointToPublish();
&#125;
</code></pre>
<pre><code class="java">service-article resources/mapper/ArticleMapperCustom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.ArticleMapperCustom&quot; &gt;
    &lt;update id=&quot;updateAppointToPublish&quot;&gt;
        update
            article
        set
            is_appoint = 0
        where
            publish_time &amp;lt;= NOW()
        and
            is_appoint = 1
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;

import java.util.List;

public interface ArticleService &#123;

    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

    /**
     * 更新定时发布为即使发布
     */
    public void updateAppointToPublish();

&#125;
</code></pre>
<pre><code class="java">service-article   com/imooc/article/service/impl/ArticleServiceImpl.java

@Transactional //添加事务[更新操作]
    @Override
    public void updateAppointToPublish() &#123;
        articleMapperCustom.updateAppointToPublish();
    &#125;
</code></pre>
<h3 id="文章列表展示-【内容管理】"><a href="#文章列表展示-【内容管理】" class="headerlink" title="文章列表展示 【内容管理】"></a>文章列表展示 【内容管理】</h3><p>[mybatis中关于example类详解mybatis的Example</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/suizhikuo/p/13191209.html">Criteria]的使用 - 万事俱备就差个程序员 - 博客园 (cnblogs.com)</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
@Api(value = &quot;文章业务的controller&quot;, tags = &#123;&quot;文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article&quot;)
public interface ArticleControllerApi &#123;

    @PostMapping(&quot;createArticle&quot;)
    @ApiOperation(value = &quot;用户发文&quot;, notes = &quot;用户发文&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult createArticle(@RequestBody @Valid NewArticleBO newArticleBO, BindingResult result);

    @PostMapping(&quot;queryMyList&quot;) //对应着前端contentMng.html 340行
    @ApiOperation(value = &quot;查询用户的所有文章列表&quot;, notes = &quot;查询用户的所有文章列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult queryMyList(@RequestParam String userId,
                                       @RequestParam String keyword,
                                       @RequestParam Integer status,
                                       @RequestParam Date startDate,
                                       @RequestParam Date endDate,
                                       @RequestParam Integer page,
                                       @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult queryMyList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_QUERY_PARAMS_ERROR);
        &#125;
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        // 查询我的列表，调用service
        PagedGridResult grid =  articleService.queryMyArticleList(userId, keyword, status, startDate, endDate, page, pageSize);
        return GraceJSONResult.ok(grid);
    &#125;
=========================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;
import java.util.List;

public interface ArticleService &#123;

    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

    /**
     * 更新定时发布为即使发布
     */
    public void updateAppointToPublish();

    /**
     * 用户中心-查询我的文章列表
     */
    public PagedGridResult queryMyArticleList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
@Service
public class ArticleServiceImpl extends BaseService implements ArticleService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository
    @Autowired
    private ArticleMapperCustom articleMapperCustom;
    @Autowired
    private Sid sid;
     //匹配到前端的一种显示方法
    @Override
    public PagedGridResult queryMyArticleList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        Example example = new Example(Article.class);
        example.orderBy(&quot;createTime&quot;).desc();
        Example.Criteria criteria = example.createCriteria();
        criteria.andEqualTo(&quot;publishUserId&quot;, userId);
        if (StringUtils.isNotBlank(keyword))&#123;
            //模糊查询
            criteria.andLike(&quot;title&quot;, &quot;%&quot;+keyword+&quot;%&quot;);
        &#125;
        if (ArticleReviewStatus.isArticleStatusValid(status))&#123;
            // 有效就匹配 无效就查询所有
            criteria.andEqualTo(&quot;articleStatus&quot;, status);
        &#125;
        // 12是在前端显示审核中
        if (status != null &amp;&amp; status == 12)&#123;
            criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.REVIEWING.type)
                    .orEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125;
        // 逻辑删除
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        if (startDate != null)&#123; //大于等于
            criteria.andGreaterThanOrEqualTo(&quot;publishTime&quot;, startDate);
        &#125;
        if (startDate != null)&#123; //小于等于
            criteria.andLessThanOrEqualTo(&quot;publishTime&quot;,endDate);
        &#125;
        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(example);
        return setterPagedGrid(list,page);
    &#125;
/*
ArticleMapper 可以实现 selectByExample 是因为它继承了 MyMapper 接口，而 MyMapper 提供了一些通用的 CRUD 操作，这些操作包括 selectByExample。

selectByExample 是 MyBatis 提供的一种动态查询方法。它允许你根据条件动态地生成 SQL 查询，而不需要手动编写复杂的 SQL 语句。这在实际开发中非常方便，因为你可以通过构建 Example 对象来动态设置查询条件。

ArticleMapper 继承了 MyMapper&lt;Article&gt;，这意味着它自动获得了 MyMapper 中定义的所有方法，包括 selectByExample。MyMapper 是一个通用的 Mapper 接口，封装了常用的数据库操作方法。

Example 和 Criteria
Example: 用于构建查询条件的对象。在这里，我们创建了一个 Example 对象，用于设置查询的表（Article.class）和排序规则（按 createTime 降序）。

Criteria: 用于添加具体的查询条件。在 Example 对象中创建 Criteria 对象，并使用它来添加各种条件（例如 publishUserId、title、articleStatus、isDelete 等）。

selectByExample
selectByExample 方法使用 Example 对象中的条件动态生成 SQL 查询，并从数据库中获取符合条件的记录。在这个例子中，我们使用了 articleMapper.selectByExample(example) 来根据构建的 Example 对象进行查询。

Example 详细用法
Example 和 Criteria 的使用使得我们可以非常灵活地构建查询条件，而不需要直接拼接 SQL 语句。这不仅提高了代码的可读性，还减少了 SQL 注入的风险。
*/
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/ArticleMapper.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Article;
import org.springframework.stereotype.Repository;

@Repository
public interface ArticleMapper extends MyMapper&lt;Article&gt; &#123;
&#125;
</code></pre>
<h3 id="阿里AI文本检测【内容审核】-机器审核"><a href="#阿里AI文本检测【内容审核】-机器审核" class="headerlink" title="阿里AI文本检测【内容审核】[机器审核]"></a>阿里AI文本检测【内容审核】<del>[机器审核]</del></h3><pre><code class="xml">dev-common pom.xml 
       &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
            &lt;version&gt;3.10.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-green&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.51&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/extend/AliTextReviewUtils.java
package com.imooc.utils.extend;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.green.model.v20180509.TextScanRequest;
import com.aliyuncs.http.FormatType;
import com.aliyuncs.http.HttpResponse;
import com.aliyuncs.profile.DefaultProfile;
import com.aliyuncs.profile.IClientProfile;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.util.*;

@Component
public class AliTextReviewUtils &#123;

    @Autowired
    private AliyunResource aliyunResource;

    public String reviewTextContent(String content) &#123;
        IClientProfile profile = DefaultProfile.getProfile(&quot;cn-shanghai&quot;,
                aliyunResource.getAccessKeyID(),
                aliyunResource.getAccessKeySecret());
        IAcsClient client = new DefaultAcsClient(profile);
        TextScanRequest textScanRequest = new TextScanRequest();
        textScanRequest.setAcceptFormat(FormatType.JSON); // 指定api返回格式
        textScanRequest.setHttpContentType(FormatType.JSON);
        textScanRequest.setMethod(com.aliyuncs.http.MethodType.POST); // 指定请求方法
        textScanRequest.setEncoding(&quot;UTF-8&quot;);
        textScanRequest.setRegionId(&quot;cn-shanghai&quot;);
        List&lt;Map&lt;String, Object&gt;&gt; tasks = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();
        Map&lt;String, Object&gt; task1 = new LinkedHashMap&lt;String, Object&gt;();
        task1.put(&quot;dataId&quot;, UUID.randomUUID().toString());
        /**
         * 待检测的文本，长度不超过10000个字符
         */
//        抵制毒品交易
//          尼玛
        task1.put(&quot;content&quot;, content);
        tasks.add(task1);
        JSONObject data = new JSONObject();

        /**
         * 检测场景，文本垃圾检测传递：antispam
         **/
        data.put(&quot;scenes&quot;, Arrays.asList(&quot;antispam&quot;));
        data.put(&quot;tasks&quot;, tasks);
        System.out.println(JSON.toJSONString(data, true));

        try &#123;
            textScanRequest.setHttpContent(data.toJSONString().getBytes(&quot;UTF-8&quot;), &quot;UTF-8&quot;, FormatType.JSON);
            // 请务必设置超时时间
            textScanRequest.setConnectTimeout(3000);
            textScanRequest.setReadTimeout(6000);

            HttpResponse httpResponse = client.doAction(textScanRequest);
            if(httpResponse.isSuccess())&#123;
                JSONObject scrResponse = JSON.parseObject(new String(httpResponse.getHttpContent(), &quot;UTF-8&quot;));
                System.out.println(JSON.toJSONString(scrResponse, true));
                if (200 == scrResponse.getInteger(&quot;code&quot;)) &#123;
                    JSONArray taskResults = scrResponse.getJSONArray(&quot;data&quot;);
                    for (Object taskResult : taskResults) &#123;
                        if(200 == ((JSONObject)taskResult).getInteger(&quot;code&quot;))&#123;
                            JSONArray sceneResults = ((JSONObject)taskResult).getJSONArray(&quot;results&quot;);
                            JSONObject sceneResult = (JSONObject)sceneResults.get(0);
        //                            for (Object sceneResult : sceneResults) &#123;
                                String scene = sceneResult.getString(&quot;scene&quot;);
                                String suggestion = sceneResult.getString(&quot;suggestion&quot;);
                                //根据scene和suggetion做相关处理
                                //suggestion == pass 未命中垃圾  suggestion == block 命中了垃圾，可以通过label字段查看命中的垃圾分类
                                System.out.println(&quot;args = [&quot; + scene + &quot;]&quot;);
                                System.out.println(&quot;args = [&quot; + suggestion + &quot;]&quot;);

        //                            suggestion=pass：文本正常，文章状态改为发布通过
        //                            review：需要人工审核，需要在后台管理系统中进行人工审核（很多自媒体平台都会采用机审+人工审的方式）
        //                            block：文本违规，可以直接删除或者做限制处理，审核不通过
        //                            &#125;
                                return suggestion;
                        &#125;else&#123;
                            System.out.println(&quot;task process fail:&quot; + ((JSONObject)taskResult).getInteger(&quot;code&quot;));
                            return null;
                        &#125;
                    &#125;
                &#125; else &#123;
                    System.out.println(&quot;detect not success. code:&quot; + scrResponse.getInteger(&quot;code&quot;));
                    return null;
                &#125;
            &#125;else&#123;
                System.out.println(&quot;response not success. status:&quot; + httpResponse.getStatus());
                return null;
            &#125;
        &#125; catch (UnsupportedEncodingException e) &#123;
            e.printStackTrace();
        &#125; catch (ClientException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<h3 id="实现阿里AI自动审核文章【内容审核】"><a href="#实现阿里AI自动审核文章【内容审核】" class="headerlink" title="实现阿里AI自动审核文章【内容审核】"></a>实现阿里AI自动审核文章【内容审核】</h3><pre><code class="java">【沿用上面的AliTextReviewUtils】
@Service
public class ArticleServiceImpl extends BaseService implements ArticleService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository
    @Autowired
    private ArticleMapperCustom articleMapperCustom;
    @Autowired
    private AliTextReviewUtils aliTextReviewUtils;
    @Autowired
    private Sid sid;

    @Transactional
    @Override
    public void createArticle(NewArticleBO newArticleBO, Category category) &#123;
        String articleId = sid.nextShort();

        Article article = new Article();
        BeanUtils.copyProperties(newArticleBO, article);

        article.setId(articleId);
        article.setCategoryId(category.getId());
        article.setArticleStatus(ArticleReviewStatus.REVIEWING.type);
        article.setCommentCounts(0);
        article.setReadCounts(0);

        article.setIsDelete(YesOrNo.NO.type);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());

        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;
            article.setPublishTime(newArticleBO.getPublishTime()); //用户可以在前端选择定时发布
        &#125; else if (article.getIsAppoint() == ArticleAppointType.IMMEDIATELY.type) &#123;
            article.setPublishTime(new Date());
        &#125;

        int res = articleMapper.insert(article);
        if (res != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_CREATE_ERROR);
        &#125;

        /**
         * FIXME: 我们只检测正常的词汇，非正常词汇大家课后去检测
         */
        // 通过阿里智能AI实现对文章文本的自动检测（自动审核）
//        String reviewTextResult = aliTextReviewUtils.reviewTextContent(newArticleBO.getContent());
        String reviewTextResult = ArticleReviewLevel.REVIEW.type;

        if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.PASS.type)) &#123;
            // 修改当前的文章，状态标记为审核通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.SUCCESS.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.REVIEW.type)) &#123;
            // 修改当前的文章，状态标记为需要人工审核
            this.updateArticleStatus(articleId, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.BLOCK.type)) &#123;
            // 修改当前的文章，状态标记为审核未通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.FAILED.type);
        &#125;
    &#125;
......
......
    @Transactional
    @Override
    public void updateArticleStatus(String articleId, Integer pendingStatus) &#123;
        Example example = new Example(Article.class);
        Example.Criteria criteria = example.createCriteria();
        criteria.andEqualTo(&quot;id&quot;,articleId);

        Article pendingArticle = new Article();
        pendingArticle.setArticleStatus(pendingStatus);
        int res = articleMapper.updateByExampleSelective(pendingArticle, example);
        if (res != 1)&#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;
import java.util.List;

public interface ArticleService &#123;

    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

    /**
     * 更新定时发布为即使发布
     */
    public void updateAppointToPublish();

    /**
     * 用户中心-查询我的文章列表
     */
    public PagedGridResult queryMyArticleList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

    /**
     * 更改文章的状态
     * @param articleId
     * @param pendingStatus
     */
    public void updateArticleStatus(String articleId, Integer pendingStatus);
&#125;
</code></pre>
<h3 id="admin文章管理列表【内容审核】【作业】"><a href="#admin文章管理列表【内容审核】【作业】" class="headerlink" title="admin文章管理列表【内容审核】【作业】"></a>admin文章管理列表【内容审核】<del>【作业】</del></h3><h5 id="管理员查询用户的所有文章列表"><a href="#管理员查询用户的所有文章列表" class="headerlink" title="管理员查询用户的所有文章列表"></a>管理员查询用户的所有文章列表</h5><pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
@PostMapping(&quot;queryAllList&quot;)
    @ApiOperation(value = &quot;管理员查询用户的所有文章列表&quot;, notes = &quot;管理员查询用户的所有文章列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult queryAllList(@RequestParam Integer status,
                                        @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                        @RequestParam Integer page,
                                        @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                        @RequestParam Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult queryAllList(Integer status, Integer page, Integer pageSize) &#123;
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        PagedGridResult gridResult = articleService.queryAllArticleListAdmin(status,page,pageSize);

        return GraceJSONResult.ok(gridResult);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
    /**
     * 管理员查询文章列表
     */
    public PagedGridResult queryAllArticleListAdmin(Integer status, Integer page, Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
@Override
    public PagedGridResult queryAllArticleListAdmin(Integer status, Integer page, Integer pageSize) &#123;
        Example articleExample = new Example(Article.class);
        articleExample.orderBy(&quot;createTime&quot;).desc();
        Example.Criteria criteria = articleExample.createCriteria();
        //这里是检测文章状态 与前端做匹配
        if (ArticleReviewStatus.isArticleStatusValid(status)) &#123;
            criteria.andEqualTo(&quot;articleStatus&quot;, status);
        &#125;

        // 审核中是机审和人审核的两个状态，所以需要单独判断
        if (status != null &amp;&amp; status == 12) &#123;
            criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.REVIEWING.type)
                    .orEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125;
        //isDelete必须是0
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        /**
         * page: 第几页
         * pageSize: 每页显示条数
         */
        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        return setterPagedGrid(list, page);
    &#125;
</code></pre>
<h3 id="人工审核-【内容审核】"><a href="#人工审核-【内容审核】" class="headerlink" title="人工审核 【内容审核】"></a>人工审核 【内容审核】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/contentReview.html">内容审核 | 运营管理平台 (imoocnews.com)</a> 【[待审核]手动审核通过】</p>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
    @PostMapping(&quot;doReview&quot;)
    @ApiOperation(value = &quot;管理员对文章进行审核通过或者失败&quot;, notes = &quot;管理员对文章进行审核通过或者失败&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult doReview(@RequestParam String articleId,
                                    @RequestParam Integer passOrNot);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<h3 id="撤回-删除文章作业-【内容管理】"><a href="#撤回-删除文章作业-【内容管理】" class="headerlink" title="撤回_删除文章作业 【内容管理】"></a>撤回_删除文章作业 【内容管理】</h3><p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html">媒体号作家中心 | 内容管理 (imoocnews.com)</a><br>[这个是用户撤回和删除噢 而不是管理员的撤回与删除]<br><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html">用户：媒体号作家中心 | 内容管理 (imoocnews.com)</a><br><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/contentReview.html">管理员：内容审核 | 运营管理平台 (imoocnews.com)</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
    @PostMapping(&quot;/delete&quot;)
    @ApiOperation(value = &quot;用户删除文章&quot;, notes = &quot;用户删除文章&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult delete(@RequestParam String userId,
                                  @RequestParam String articleId);

    @PostMapping(&quot;/withdraw&quot;)
    @ApiOperation(value = &quot;用户撤回文章&quot;, notes = &quot;用户撤回文章&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult withdraw(@RequestParam String userId,
                                    @RequestParam String articleId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult delete(String userId, String articleId) &#123;
        articleService.deleteArticle(userId,articleId);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult withdraw(String userId, String articleId) &#123;
        articleService.withdrawArticle(userId, articleId);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;
import java.util.List;

public interface ArticleService &#123;

   /**
     * 删除文章
     */
    public void deleteArticle(String userId, String articleId);

    /**
     * 撤回文章
     */
    public void withdrawArticle(String userId, String articleId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
 @Transactional
    @Override
    public void deleteArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setIsDelete(YesOrNo.YES.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_DELETE_ERROR);
        &#125;
    &#125;

    @Transactional
    @Override
    public void withdrawArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setArticleStatus(ArticleReviewStatus.WITHDRAW.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_WITHDRAW_ERROR);
        &#125;
//        deleteHTML(articleId);
    &#125;

    private Example makeExampleCriteria(String userId, String articleId) &#123;
        Example articleExample = new Example(Article.class);
        Example.Criteria criteria = articleExample.createCriteria();
        criteria.andEqualTo(&quot;publishUserId&quot;, userId);
        criteria.andEqualTo(&quot;id&quot;, articleId);
        return articleExample;
    &#125;
</code></pre>
<h2 id="首页-作者页面介绍【章节描述】"><a href="#首页-作者页面介绍【章节描述】" class="headerlink" title="首页_作者页面介绍【章节描述】"></a>首页_作者页面介绍【章节描述】</h2><ul>
<li><strong>开发首页与作家个人展示页</strong></li>
<li><strong>文章列表、友情链接查询</strong></li>
<li><strong>粉丝关注与取关</strong></li>
<li><strong>我的粉丝与粉丝画像</strong></li>
</ul>
<h3 id="根据MongoDB字段查询友情链接"><a href="#根据MongoDB字段查询友情链接" class="headerlink" title="根据MongoDB字段查询友情链接"></a>根据MongoDB字段查询友情链接</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
    @ApiOperation(value = &quot;门户端查询友情链接列表&quot;, notes = &quot;门户端查询友情链接列表&quot;, httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;portal/list&quot;)
    public GraceJSONResult queryPortalAllFriendLinkList();
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
    @Override
    public GraceJSONResult queryPortalAllFriendLinkList() &#123;
        List&lt;FriendLinkMO&gt; list = friendLinkService.queryPortalAllFriendLinkList();
        return GraceJSONResult.ok(list);
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
    /**
     * 首页查询友情链接
     */
    public List&lt;FriendLinkMO&gt; queryPortalAllFriendLinkList();
</code></pre>
<pre><code class="java">service-admin com/imooc/admin/service/impl/FriendLinkServiceImpl.java 
@Override
    public List&lt;FriendLinkMO&gt; queryPortalAllFriendLinkList() &#123;
        return friendLinkRepository.getAllByIsDelete(YesOrNo.NO.type);
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/repository/FriendLinkRepository.java
@Repository
public interface FriendLinkRepository extends MongoRepository&lt;FriendLinkMO, String&gt; &#123; //持久层
    // 内置提供了很多方法 find.. delete...
    public List&lt;FriendLinkMO&gt; getAllByIsDelete(Integer isDelete); //后面可以加ANDID
&#125;
</code></pre>
<h3 id="搜索并展示文章列表【首页】"><a href="#搜索并展示文章列表【首页】" class="headerlink" title="搜索并展示文章列表【首页】"></a>搜索并展示文章列表【首页】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@Api(value = &quot;门户端文章业务的controller&quot;, tags = &#123;&quot;门户端文章业务的controller&quot;&#125;)
@RequestMapping(&quot;portal/article&quot;)
public interface ArticlePortalControllerApi &#123;
    @ApiOperation(value = &quot;首页查询文章列表&quot;, notes = &quot;首页查询文章列表&quot;, httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;list&quot;)
    public GraceJSONResult list(@RequestParam String keyword,
                                @RequestParam Integer category,
                                @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                @RequestParam Integer page,
                                @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
@Service
public class ArticlePortalServiceImpl extends BaseService implements ArticlePortalService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository


    @Override
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 Integer pageSize) &#123;

        Example articleExample = new Example(Article.class);
        articleExample.orderBy(&quot;publishTime&quot;).desc();//使用时间进行排序
        Example.Criteria criteria = articleExample.createCriteria();

        /**
         * 查询首页文章的自带隐性查询条件：
         * isAppoint=即使发布，表示文章已经直接发布的，或者定时任务到点发布的
         * isDelete=未删除，表示文章只能够显示未删除
         * articleStatus=审核通过，表示只有文章经过机审/人工审核之后才能展示
         */
        criteria.andEqualTo(&quot;isAppoint&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.SUCCESS.type);

        if (StringUtils.isNotBlank(keyword)) &#123;
            criteria.andLike(&quot;title&quot;, &quot;%&quot; + keyword + &quot;%&quot;);
        &#125;
        if (category != null) &#123;
            criteria.andEqualTo(&quot;categoryId&quot;, category);
        &#125;

        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        System.out.println(keyword);
        System.out.println(category);
        return setterPagedGrid(list, page);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
public interface ArticlePortalService &#123;

    /**
     * 首页查询文章列表
     */
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 &#125;
</code></pre>
<pre><code class="html">index.html
&lt;!-- 中间容器 --&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;!-- 文章列表 --&gt;
            &lt;div id=&quot;articleList&quot; class=&quot;article-list&quot;&gt;
                &lt;ul&gt;
                    &lt;li class=&quot;single-article-wrapper&quot; v-for=&quot;(article, index) in articleList&quot; :key=&quot;index&quot;&gt;
                        &lt;img :src=&quot;article.articleCover&quot; class=&quot;article-cover&quot; v-show=&quot;article.articleType == 1&quot;&gt;

                        &lt;div class=&quot;single-article&quot;&gt;
                            &lt;div class=&quot;article-title&quot;&gt;
                                &lt;!-- TODO: 后期改为静态页面跳转 --&gt;
                                &lt;a :href=&quot;&#39;detail.html?articleId=&#39;+article.id&quot; target=&quot;_blank&quot; class=&quot;link-article-title&quot;&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;
                            &lt;/div&gt;
                            &lt;div class=&quot;publisher&quot;&gt;
                                &lt;div class=&quot;category-tag&quot; :style=&quot;&#123;color: getCatTagColor(article.categoryId), borderColor: getCatTagColor(article.categoryId) &#125;&quot;&gt;&#123;&#123;getCatName(article.categoryId)&#125;&#125;&lt;/div&gt;
                                &lt;!-- TODO: 这里需要显示用户的昵称以及用户头像 --&gt;
                                    &lt;img src=&quot;img/face1.png&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publishUserId&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                
                                
                                    &lt;img :src=&quot;article.publisherVO.face&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;
                                &lt;!--
                                    &lt;a :href=&quot;&#39;writer.html?writerId=&#39;+article.publisherVO.id&quot; target=&quot;_blank&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publisherVO.nickname&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                &lt;/a&gt;
                                    --&gt;

                                &lt;div class=&quot;article-name&quot;&gt;&amp;nbsp;&#123;&#123;article.readCounts&#125;&#125;阅读&amp;nbsp;⋅&lt;/div&gt;
                                
                                &lt;!-- &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;formatData(article.publishTime)&#125;&#125;&lt;/div&gt; --&gt;
                                &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;getDateBeforeNow(article.publishTime)&#125;&#125;&lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
</code></pre>
<h3 id="文章列表展示发布者需求【首页】"><a href="#文章列表展示发布者需求【首页】" class="headerlink" title="文章列表展示发布者需求【首页】"></a>文章列表展示发布者需求【首页】</h3><pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
[其他不变加上点代码]
package com.imooc.article.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.article.ArticleControllerApi;
import com.imooc.api.controller.article.ArticlePortalControllerApi;
import com.imooc.article.service.ArticlePortalService;
import com.imooc.article.service.ArticleService;
import com.imooc.enums.ArticleCoverType;
import com.imooc.enums.ArticleReviewStatus;
import com.imooc.enums.YesOrNo;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Article;
import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import java.util.*;

@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
   //START
        List&lt;Article&gt; list = (List&lt;Article&gt;) gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idset = new HashSet&lt;&gt;();
        for (Article a : list)&#123;
//            System.out.println(a.getPublishUserId());
            idset.add(a.getPublishUserId());
        &#125;
        System.out.println(idset.toString());
        // 2. 发起远程调用(restTemplate)，请求用户服务获得用户(idSet 发布者)列表

        // 3. 拼接两个list，重组文章列表
   //END
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;
</code></pre>
<h3 id="发起restTemplate请求查询用户服务获得发布者列表【首页】二级用户"><a href="#发起restTemplate请求查询用户服务获得发布者列表【首页】二级用户" class="headerlink" title="发起restTemplate请求查询用户服务获得发布者列表【首页】二级用户"></a>发起restTemplate请求查询用户服务获得发布者列表【首页】<del>二级用户</del></h3><pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
   //START 用户量大就双表关联查询      单表双查询 → 【首页不会显示发布者的用户id 和 头像】
        List&lt;Article&gt; list = (List&lt;Article&gt;) gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idset = new HashSet&lt;&gt;();
        for (Article a : list)&#123;
//            System.out.println(a.getPublishUserId());
            idset.add(a.getPublishUserId());
        &#125;
        System.out.println(idset.toString());
        // 2. 发起远程调用(restTemplate)，请求用户服务获得用户(idSet 发布者)列表
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idset);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity =
        restTemplate.getForEntity(userServerUrlExecute,GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200)&#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        for (AppUserVO u : publisherList)&#123;
            System.out.println(u.toString());
        &#125;
        // 3. 拼接两个list，重组文章列表
   //END
        return GraceJSONResult.ok(gridResult);
    &#125;
===================成功输出二级用户基本信息===============================
AppUserVO&#123;id=&#39;240629F21AK1BHX4&#39;, nickname=&#39;15027597319&#39;, face=&#39;https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/240629F21AK1BHX4/240712FM0G1WMZHH.png&#39;, activeStatus=1&#125;
AppUserVO&#123;id=&#39;200628AFYM7AGWPH&#39;, nickname=&#39;我是慕课网&#39;, face=&#39;https://imooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/200628AFYM7AGWPH/2007088XH2WT7GXP.png&#39;, activeStatus=1&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/AppUserVO.java
public class AppUserVO &#123;
    private String id;
    private String nickname;
    private String face;
    private Integer activeStatus;
&#125;Getter + Setter + ToString
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
@Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;

    private AppUserVO getBasicUserInfo(String userId)&#123;
        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        AppUserVO userVO = new AppUserVO();
        BeanUtils.copyProperties(user, userVO); //拷贝信息
        return userVO;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
                                          BindingResult result);

    @ApiOperation(value = &quot;根据用户的ids查询用户列表&quot;,notes = &quot;根据用户的ids查询用户列表&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/queryByids&quot;)
    public GraceJSONResult queryByIds(@RequestParam String userIds);
&#125;
</code></pre>
<h3 id="重组文章列表并且渲染【首页】"><a href="#重组文章列表并且渲染【首页】" class="headerlink" title="重组文章列表并且渲染【首页】"></a>重组文章列表并且渲染【首页】</h3><pre><code class="html">index.html
&lt;!-- 中间容器 --&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;!-- 文章列表 --&gt;
            &lt;div id=&quot;articleList&quot; class=&quot;article-list&quot;&gt;
                &lt;ul&gt;
                    &lt;li class=&quot;single-article-wrapper&quot; v-for=&quot;(article, index) in articleList&quot; :key=&quot;index&quot;&gt;
                        &lt;img :src=&quot;article.articleCover&quot; class=&quot;article-cover&quot; v-show=&quot;article.articleType == 1&quot;&gt;

                        &lt;div class=&quot;single-article&quot;&gt;
                            &lt;div class=&quot;article-title&quot;&gt;
                                &lt;!-- TODO: 后期改为静态页面跳转 --&gt;
                                &lt;a :href=&quot;&#39;detail.html?articleId=&#39;+article.id&quot; target=&quot;_blank&quot; class=&quot;link-article-title&quot;&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;
                            &lt;/div&gt;
                            &lt;div class=&quot;publisher&quot;&gt;
                                &lt;div class=&quot;category-tag&quot; :style=&quot;&#123;color: getCatTagColor(article.categoryId), borderColor: getCatTagColor(article.categoryId) &#125;&quot;&gt;&#123;&#123;getCatName(article.categoryId)&#125;&#125;&lt;/div&gt;
          &lt;!-- ★★★★★ TODO: 这里需要显示用户的昵称以及用户头像 ★★★★★ --&gt;
                                    &lt;img src=&quot;img/face1.png&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publishUserId&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                    &lt;img :src=&quot;article.publisherVO.face&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;
                                
                                    &lt;a :href=&quot;&#39;writer.html?writerId=&#39;+article.publisherVO.id&quot; target=&quot;_blank&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publisherVO.nickname&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                &lt;/a&gt;            
                                &lt;div class=&quot;article-name&quot;&gt;&amp;nbsp;&#123;&#123;article.readCounts&#125;&#125;阅读&amp;nbsp;⋅&lt;/div&gt;
                                &lt;!-- &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;formatData(article.publishTime)&#125;&#125;&lt;/div&gt; --&gt;
                                &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;getDateBeforeNow(article.publishTime)&#125;&#125;&lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/IndexArticleVO.java
public class IndexArticleVO &#123;

    private String id;
    private String title;
    private Integer categoryId;
    private Integer articleType;
    private String articleCover;
    private Integer isAppoint;
    private Integer articleStatus;
    private String publishUserId;
    private Date publishTime;
    private Integer readCounts;
    private Integer commentCounts;
    private String mongoFileId;
    private Integer isDelete;
    private Date createTime;
    private Date updateTime;
    private String content;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
package com.imooc.article.controller;
......
import java.util.*;

@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
   //START 用户量大就双表关联查询      单表双查询 → 【首页不会显示发布者的用户id 和 头像】
        List&lt;Article&gt; list = (List&lt;Article&gt;) gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idset = new HashSet&lt;&gt;();
        for (Article a : list)&#123;
//            System.out.println(a.getPublishUserId());
            idset.add(a.getPublishUserId());
        &#125;
        System.out.println(idset.toString());
        // 2. 发起远程调用(restTemplate)，请求用户服务获得用户(idSet 发布者)列表
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idset);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity =
        restTemplate.getForEntity(userServerUrlExecute,GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200)&#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
//        for (AppUserVO u : publisherList)&#123;
//            System.out.println(u.toString());
//        &#125;
        // 3. 拼接两个list，重组文章列表
        List&lt;IndexArticleVO&gt; indexArticleList = new ArrayList&lt;&gt;();
        for (Article a : list)&#123;
            IndexArticleVO indexArticleVO = new IndexArticleVO();
            BeanUtils.copyProperties(a, indexArticleVO);

            // 3.1 从publisherList中获得发布者的基本信息
            AppUserVO publisher = getUserIfPublisher(a.getPublishUserId(), publisherList);
            indexArticleVO.setPublisherVO(publisher);
            indexArticleList.add(indexArticleVO);
        &#125;
        gridResult.setRows(indexArticleList);
   //END
        return GraceJSONResult.ok(gridResult);
    &#125;
    // 用于获得publish
    private AppUserVO getUserIfPublisher(String publisherId, List&lt;AppUserVO&gt; publisherList)&#123;
        for (AppUserVO user : publisherList)&#123;
            if (user.getId().equalsIgnoreCase(publisherId))&#123;
                return user;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<h3 id="查询热闻【首页】阅读数从最新新闻进行排名"><a href="#查询热闻【首页】阅读数从最新新闻进行排名" class="headerlink" title="查询热闻【首页】阅读数从最新新闻进行排名"></a>查询热闻【首页】<del>阅读数从最新新闻进行排名</del></h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@Api(value = &quot;门户端文章业务的controller&quot;, tags = &#123;&quot;门户端文章业务的controller&quot;&#125;)
@RequestMapping(&quot;portal/article&quot;)
public interface ArticlePortalControllerApi &#123;
 @GetMapping(&quot;hotList&quot;)
    @ApiOperation(value = &quot;首页查询新闻列表&quot;, notes = &quot;首页查询新闻列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult hotList();
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
public interface ArticlePortalService &#123;

    /**
     * 首页查询文章列表
     */
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 Integer pageSize);
    /**
     * 首页查询热闻列表
     */
    public List&lt;Article&gt; queryHotList();
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
@Override
    public List&lt;Article&gt; queryHotList() &#123;
        Example articleExample = new Example(Article.class);
        Example.Criteria criteria = setDefualArticleExample(articleExample);

        PageHelper.startPage(1, 5);
        List&lt;Article&gt; list  = articleMapper.selectByExample(articleExample);
        return list;
    &#125;

    private Example.Criteria setDefualArticleExample(Example articleExample) &#123;
        articleExample.orderBy(&quot;publishTime&quot;).desc();
        Example.Criteria criteria = articleExample.createCriteria();

        /**
         * 查询首页文章的自带隐性查询条件：
         * isAppoint=即使发布，表示文章已经直接发布的，或者定时任务到点发布的
         * isDelete=未删除，表示文章只能够显示未删除
         * articleStatus=审核通过，表示只有文章经过机审/人工审核之后才能展示
         */
        criteria.andEqualTo(&quot;isAppoint&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.SUCCESS.type);

        return criteria;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult hotList() &#123;
        return GraceJSONResult.ok(articlePortalService.queryHotList());
    &#125;
</code></pre>
<h3 id="基本信息展示-历史文章列表【作者主页】"><a href="#基本信息展示-历史文章列表【作者主页】" class="headerlink" title="基本信息展示_历史文章列表【作者主页】"></a>基本信息展示_历史文章列表【作者主页】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
 package com.imooc.api.controller.article;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewArticleBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import java.util.Date;

@Api(value = &quot;门户端文章业务的controller&quot;, tags = &#123;&quot;门户端文章业务的controller&quot;&#125;)
@RequestMapping(&quot;portal/article&quot;)
public interface ArticlePortalControllerApi &#123;

    @GetMapping(&quot;list&quot;)
    @ApiOperation(value = &quot;首页查询文章列表&quot;, notes = &quot;首页查询文章列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult list(@RequestParam String keyword,
                                @RequestParam Integer category,
                                @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                @RequestParam Integer page,
                                @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                @RequestParam Integer pageSize);

    @GetMapping(&quot;hotList&quot;)
    @ApiOperation(value = &quot;首页查询新闻列表&quot;, notes = &quot;首页查询新闻列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult hotList();

    /**
     * 查询作家发布的所有文章列表
     */
    @GetMapping(&quot;queryArticleListOfWriter&quot;)
    @ApiOperation(value = &quot;查询作家发布的所有文章列表&quot;, notes = &quot;查询作家发布的所有文章列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult queryArticleListOfWriter(@RequestParam String writerId,
                                                    @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                                        @RequestParam Integer page,
                                                    @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                                        @RequestParam Integer pageSize);

    @GetMapping(&quot;queryGoodArticleListOfWriter&quot;)
    @ApiOperation(value = &quot;作家页面查询近期佳文&quot;, notes = &quot;作家页面查询近期佳文&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult queryGoodArticleListOfWriter(@RequestParam String writerId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult queryArticleListOfWriter(String writerId, Integer page, Integer pageSize) &#123;

        System.out.println(&quot;writerId=&quot; + writerId);

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult = articlePortalService.queryArticleListOfWriter(writerId, page, pageSize);
        gridResult = rebuildArticleGrid(gridResult);
        return GraceJSONResult.ok(gridResult);
    &#125;

    @Override
    public GraceJSONResult queryGoodArticleListOfWriter(String writerId) &#123;
        PagedGridResult gridResult = articlePortalService.queryGoodArticleListOfWriter(writerId);
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;
</code></pre>
<pre><code class="java">/* 完全版ArticlePortalController
package com.imooc.article.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.article.ArticlePortalControllerApi;
import com.imooc.article.service.ArticlePortalService;
import com.imooc.article.service.ArticleService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.Article;
import com.imooc.pojo.vo.AppUserVO;
import com.imooc.pojo.vo.IndexArticleVO;
import com.imooc.utils.IPUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
        gridResult = rebuildArticleGrid(gridResult);
        return GraceJSONResult.ok(gridResult);
    &#125;

    private PagedGridResult rebuildArticleGrid(PagedGridResult gridResult) &#123;
        // START

        List&lt;Article&gt; list = (List&lt;Article&gt;)gridResult.getRows();

        // 1. 构建发布者id列表
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        List&lt;String&gt; idList = new ArrayList&lt;&gt;();
        for (Article a : list) &#123;
//            System.out.println(a.getPublishUserId());
            // 1.1 构建发布者的set
            idSet.add(a.getPublishUserId());
            // 1.2 构建文章id的list
            idList.add(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + a.getId());
        &#125;
        System.out.println(idSet.toString());
        // 发起redis的mget批量查询api，获得对应的值
        List&lt;String&gt; readCountsRedisList = redis.mget(idList);
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        // 3. 拼接两个list，重组文章列表
        List&lt;IndexArticleVO&gt; indexArticleList = new ArrayList&lt;&gt;();
        for (int i = 0 ; i &lt; list.size() ; i ++) &#123;
            IndexArticleVO indexArticleVO = new IndexArticleVO();
            Article a = list.get(i);
            BeanUtils.copyProperties(a, indexArticleVO);

            // 3.1 从publisherList中获得发布者的基本信息
            AppUserVO publisher  = getUserIfPublisher(a.getPublishUserId(), publisherList);
            indexArticleVO.setPublisherVO(publisher);

            // 3.2 重新组装设置文章列表中的阅读量
            String redisCountsStr = readCountsRedisList.get(i);
            int readCounts = 0;
            if (StringUtils.isNotBlank(redisCountsStr)) &#123;
                readCounts = Integer.valueOf(redisCountsStr);
            &#125;
            indexArticleVO.setReadCounts(readCounts);

            indexArticleList.add(indexArticleVO);
        &#125;


        gridResult.setRows(indexArticleList);
// END
        return gridResult;
    &#125;

    private AppUserVO getUserIfPublisher(String publisherId,
                                         List&lt;AppUserVO&gt; publisherList) &#123;
        for (AppUserVO user : publisherList) &#123;
            if (user.getId().equalsIgnoreCase(publisherId)) &#123;
                return user;
            &#125;
        &#125;
        return null;
    &#125;

    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;

    @Override
    public GraceJSONResult hotList() &#123;
        return GraceJSONResult.ok(articlePortalService.queryHotList());
    &#125;

    @Override
    public GraceJSONResult queryArticleListOfWriter(String writerId, Integer page, Integer pageSize) &#123;

        System.out.println(&quot;writerId=&quot; + writerId);

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult = articlePortalService.queryArticleListOfWriter(writerId, page, pageSize);
        gridResult = rebuildArticleGrid(gridResult);
        return GraceJSONResult.ok(gridResult);
    &#125;

    @Override
    public GraceJSONResult queryGoodArticleListOfWriter(String writerId) &#123;
        PagedGridResult gridResult = articlePortalService.queryGoodArticleListOfWriter(writerId);
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;

*/
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
public interface ArticlePortalService &#123;

    /**
     * 首页查询文章列表
     */
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 Integer pageSize);
    /**
     * 首页查询热闻列表
     */
    public List&lt;Article&gt; queryHotList();

    /**
     * 查询作家发布的所有文章列表
     */
    public PagedGridResult queryArticleListOfWriter(String writerId,
                                                    Integer page,
                                                    Integer pageSize);

    /**
     * 作家页面查询近期佳文
     */
    public PagedGridResult queryGoodArticleListOfWriter(String writerId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java

@Override
    public PagedGridResult queryArticleListOfWriter(String writerId, Integer page, Integer pageSize) &#123;
        Example articleExample = new Example(Article.class);

        Example.Criteria criteria = setDefualArticleExample(articleExample);
        criteria.andEqualTo(&quot;publishUserId&quot;, writerId);

        /**
         * page: 第几页
         * pageSize: 每页显示条数
         */
        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        return setterPagedGrid(list, page);
    &#125;

    @Override
    public PagedGridResult queryGoodArticleListOfWriter(String writerId) &#123;
        Example articleExample = new Example(Article.class);
        articleExample.orderBy(&quot;publishTime&quot;).desc();

        Example.Criteria criteria = setDefualArticleExample(articleExample);
        criteria.andEqualTo(&quot;publishUserId&quot;, writerId);

        /**
         * page: 第几页
         * pageSize: 每页显示条数
         */
        PageHelper.startPage(1, 5);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        return setterPagedGrid(list, 1);
    &#125;

    private Example.Criteria setDefualArticleExample(Example articleExample) &#123;
        articleExample.orderBy(&quot;publishTime&quot;).desc();
        Example.Criteria criteria = articleExample.createCriteria();

        /**
         * 查询首页文章的自带隐性查询条件：
         * isAppoint=即使发布，表示文章已经直接发布的，或者定时任务到点发布的
         * isDelete=未删除，表示文章只能够显示未删除
         * articleStatus=审核通过，表示只有文章经过机审/人工审核之后才能展示
         */
        criteria.andEqualTo(&quot;isAppoint&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.SUCCESS.type);

        return criteria;
    &#125;
</code></pre>
<h4 id="关注与取关-redis单线程计数统计-【粉丝关注】"><a href="#关注与取关-redis单线程计数统计-【粉丝关注】" class="headerlink" title="关注与取关_redis单线程计数统计 【粉丝关注】"></a>关注与取关_redis单线程计数统计 【粉丝关注】</h4><blockquote>
<p>阅读数可以用数据库COUNT* 但是压力会很大 若很多人一起刷新会音响很大<br>用redis 数量累加累减 单线程安全<br>减少数据库压力</p>
</blockquote>
<pre><code class="mysql">【注意 redis我安装到了本地计算机里面 D:\Redis-x64-3.0.504】
打开redis-cli.exe
127.0.0.1:6379&gt; keys *
1) &quot;redis_all_category&quot;
2) &quot;redis_admin_token:1001&quot;
3) &quot;redis_user_info:1001&quot;
4) &quot;redis_user_info:200628AFYM7AGWPH&quot;
5) &quot;redis_user_token:240629F21AK1BHX4&quot;
6) &quot;redis_user_info:240629F21AK1BHX4&quot;
7) &quot;redis_user_token:200628AFYM7AGWPH&quot;
127.0.0.1:6379&gt; INCR 1001:fans #【增加】
(integer) 1
127.0.0.1:6379&gt; INCR 1001:fans
(integer) 2
127.0.0.1:6379&gt; INCR 1001:fans
(integer) 3
127.0.0.1:6379&gt; get 1001:fans #【获取】
&quot;3&quot;
127.0.0.1:6379&gt; DECR 1001:fans #【减少】
(integer) 2
127.0.0.1:6379&gt; DECR 1001:fans
(integer) 1
127.0.0.1:6379&gt; incr 1001:follows #【关注的粉丝】
(integer) 1
127.0.0.1:6379&gt; get 1001:follows
&quot;1&quot;
</code></pre>
<h3 id="查询用户关注状态【粉丝关注】"><a href="#查询用户关注状态【粉丝关注】" class="headerlink" title="查询用户关注状态【粉丝关注】"></a>查询用户关注状态【粉丝关注】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
    @ApiOperation(value = &quot;查询当前用户是否关注作家&quot;,notes = &quot;查询当前用户是否关注作家&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/isMeFollowThisWriter&quot;)
    public GraceJSONResult isMeFollowThisWriter(@RequestParam String writerId, @RequestParam String fanId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.api.controller.user.MyFansControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.user.service.MyFansService;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(MyFansController.class);

    @Autowired
    private MyFansService myFansService;

    @Override
    public GraceJSONResult isMeFollowThisWriter(String writerId, String fanId) &#123;
        boolean res = myFansService.isMeFollowThisWriter(writerId,fanId);
        return GraceJSONResult.ok(res);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

import java.util.Date;

public interface MyFansService &#123;
    /**
     * 查询当前用户是否关注作家
     */
    public boolean isMeFollowThisWriter(String writerId, String fanId);

&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
package com.imooc.user.service.impl;

import com.github.pagehelper.PageHelper;
import com.imooc.api.service.BaseService;
import com.imooc.enums.UserStatus;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.Fans;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.mapper.FansMapper;
import com.imooc.user.service.AppUserMngService;
import com.imooc.user.service.MyFansService;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
    @Autowired
    public FansMapper fansMapper;


    @Override
    public boolean isMeFollowThisWriter(String writerId, String fanId) &#123;
        Fans fan = new Fans();
        fan.setFanId(fanId);
        fan.setWriterId(writerId);
        int count = fansMapper.selectCount(fan); //前期先放在数据库里
        return count &gt; 0 ? true : false;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/mapper/FansMapper.java
package com.imooc.user.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Fans;
import org.springframework.stereotype.Repository;

@Repository
public interface FansMapper extends MyMapper&lt;Fans&gt; &#123;
&#125;
</code></pre>
<h3 id="用户关注-粉丝累加-amp-amp-粉丝累减"><a href="#用户关注-粉丝累加-amp-amp-粉丝累减" class="headerlink" title="用户关注_粉丝累加 &amp;&amp; 粉丝累减"></a>用户关注_粉丝累加 &amp;&amp; 粉丝累减</h3><pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
    @ApiOperation(value = &quot;用户关注作家，成为粉丝&quot;,notes = &quot;用户关注作家，成为粉丝&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/follow&quot;)
    public GraceJSONResult follow(@RequestParam String writerId, @RequestParam String fanId);
    
    @ApiOperation(value = &quot;取消关注，作家损失粉丝&quot;,notes = &quot;取消关注，作家损失粉丝&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/unfollow&quot;)
    public GraceJSONResult unfollow(@RequestParam String writerId, @RequestParam String fanId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.MyFansControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.user.service.MyFansService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(MyFansController.class);

    @Autowired
    private MyFansService myFansService;

    @Override
    public GraceJSONResult isMeFollowThisWriter(String writerId, String fanId) &#123;
        boolean res = myFansService.isMeFollowThisWriter(writerId,fanId);
        return GraceJSONResult.ok(res);
    &#125;

    @Override
    public GraceJSONResult follow(String writerId, String fanId) &#123;
        myFansService.follow(writerId,fanId);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult unfollow(String writerId, String fanId) &#123;
        myFansService.unfollow(writerId, fanId);
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

public interface MyFansService &#123;
    /**
     * 查询当前用户是否关注作家
     */
    public boolean isMeFollowThisWriter(String writerId, String fanId);

    /**
     * 关注成为粉丝
     */
    public void follow(String writerId, String fanId);
    
    /**
     * 粉丝取消关注
     */
    public void unfollow(String writerId, String fanId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
package com.imooc.user.service.impl;

import com.github.pagehelper.PageHelper;
import com.imooc.api.service.BaseService;
import com.imooc.enums.UserStatus;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.Fans;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.mapper.FansMapper;
import com.imooc.user.service.AppUserMngService;
import com.imooc.user.service.MyFansService;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
    @Autowired
    public FansMapper fansMapper;
    @Override
    public boolean isMeFollowThisWriter(String writerId, String fanId) &#123;
        Fans fan = new Fans();
        fan.setFanId(fanId);
        fan.setWriterId(writerId);
        int count = fansMapper.selectCount(fan); //前期先放在数据库里
        return count &gt; 0 ? true : false;
    &#125;
    
    @Transactional
    @Override
    public void follow(String writerId, String fanId) &#123;
        // 获得粉丝用户的信息
        AppUser fanInfo = userService.getUser(fanId);

        String fanPkId = sid.nextShort();

        Fans fans = new Fans();
        fans.setId(fanPkId);
        fans.setFanId(fanId);
        fans.setWriterId(writerId);

        fans.setFace(fanInfo.getFace());
        fans.setFanNickname(fanInfo.getNickname());
        fans.setSex(fanInfo.getSex());
        fans.setProvince(fanInfo.getProvince());

        fansMapper.insert(fans);

        // redis 作家粉丝数累加
        redis.increment(REDIS_WRITER_FANS_COUNTS + &quot;:&quot; + writerId, 1);  //增加key一次
        // redis 当前用户的(我的)关注数累加
        redis.increment(REDIS_MY_FOLLOW_COUNTS + &quot;:&quot; + fanId, 1);  //增加key一次
    &#125;
    
    @Transactional
    @Override
    public void unfollow(String writerId, String fanId) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);
        fans.setFanId(fanId);

        fansMapper.delete(fans);

        // redis 作家粉丝数累减
        redis.decrement(REDIS_WRITER_FANS_COUNTS + &quot;:&quot; + writerId, 1);  //增加key一次
        // redis 当前用户的(我的)关注数累减
        redis.decrement(REDIS_MY_FOLLOW_COUNTS + &quot;:&quot; + fanId, 1);  //增加key一次
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/service/BaseService.java
package com.imooc.api.service;

import com.github.pagehelper.PageInfo;
import com.imooc.utils.PagedGridResult;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;

public class BaseService &#123;
    public static final String REDIS_ALL_CATEGORY = &quot;redis_all_category&quot;;

    public static final String REDIS_WRITER_FANS_COUNTS = &quot;redis_writer_fans_counts&quot;;
    public static final String REDIS_MY_FOLLOW_COUNTS = &quot;redis_my_follow_counts&quot;;

    public static final String REDIS_ARTICLE_COMMENT_COUNTS = &quot;redis_article_comment_counts&quot;;

    @Autowired
    public RedisOperator redis;
    public PagedGridResult setterPagedGrid(List&lt;?&gt; list, Integer page)&#123; //类型是? 后期不确定是什么泛型
        PageInfo&lt;?&gt; pageList = new PageInfo&lt;&gt;(list);
        PagedGridResult gridResult = new PagedGridResult();
        gridResult.setRows(list);
        gridResult.setPage(page);
        gridResult.setRecords(pageList.getTotal());
        gridResult.setTotal(pageList.getPages());
        return gridResult;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java //增加粉丝接口的拦截
package com.imooc.api.config;

import com.imooc.api.interceptors.AdminTokenInterceptor;
import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;)
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;)
                .addPathPatterns(&quot;/fans/follow&quot;)
                .addPathPatterns(&quot;/fans/unfollow&quot;);

        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;)
                .addPathPatterns(&quot;/fs/uploadToGridFS&quot;)
                .addPathPatterns(&quot;/friendLinkMng/saveOrUpdateFriendLink&quot;)
                .addPathPatterns(&quot;/friendLinkMng/getFriendLinkList&quot;)
                .addPathPatterns(&quot;/friendLinkMng/delete&quot;)
                .addPathPatterns(&quot;/categoryMng/saveOrUpdateCategory&quot;)
                .addPathPatterns(&quot;/categoryMng/getCatList&quot;);

        registry.addInterceptor(userActiveInterceptor())
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;)
                .addPathPatterns(&quot;/fans/follow&quot;)
                .addPathPatterns(&quot;/fans/unfollow&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="粉丝数与关注数页面显示【粉丝关注】"><a href="#粉丝数与关注数页面显示【粉丝关注】" class="headerlink" title="粉丝数与关注数页面显示【粉丝关注】"></a>粉丝数与关注数页面显示【粉丝关注】</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
 @Override
    public GraceJSONResult getUserInfo(String userId) &#123;
        //接口进行解耦!!
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;
        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        AppUserVO userVO = new AppUserVO();
        BeanUtils.copyProperties(user, userVO); //拷贝信息
        // 3. 查询redis中用户的关注数和粉丝数，放入userVO放入前端渲染
        userVO.setMyFansCounts(getCountsFromRedis(REDIS_WRITER_FANS_COUNTS + &quot;:&quot; + userId));
        userVO.setMyFollowCounts(getCountsFromRedis(REDIS_MY_FOLLOW_COUNTS + &quot;:&quot; + userId));
        return GraceJSONResult.ok(userVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public abstract class BaseController &#123;
public Integer getCountsFromRedis(String key)&#123;
        String countsStr = redis.get(key);
        if (StringUtils.isBlank(countsStr)) &#123;
            countsStr = &quot;0&quot;;
        &#125;
        return Integer.valueOf(countsStr);
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/AppUserVO.java
public class AppUserVO &#123;
    private String id;
    private String nickname;
    private String face;
    private Integer activeStatus;

    private Integer myFollowCounts;
    private Integer myFansCounts;
&#125;Getter + Setter
</code></pre>
<h3 id="我的粉丝列表-后端分页查询【粉丝管理】"><a href="#我的粉丝列表-后端分页查询【粉丝管理】" class="headerlink" title="我的粉丝列表_后端分页查询【粉丝管理】"></a>我的粉丝列表_后端分页查询【粉丝管理】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
@ApiOperation(value = &quot;查询我的所有粉丝列表&quot;, notes = &quot;查询我的所有粉丝列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/queryAll&quot;)
    public GraceJSONResult queryAll(
            @RequestParam String writerId,
            @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
            @RequestParam Integer page,
            @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页查询每一页显示的条数&quot;, required = false)
            @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
 @Override
    public GraceJSONResult queryAll(String writerId, Integer page, Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        return GraceJSONResult.ok(myFansService.queryMyFansList(writerId, page, pageSize));
    &#125;
&#125;
===================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/myFans.html
数据库中fans表
weiter_id
可以改成登录的cookie里面的 uid：240629F21AK1BHX4
就可以测试用户粉丝数量
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

public interface MyFansService &#123;
    /**
     * 查询当前用户是否关注作家
     */
    public boolean isMeFollowThisWriter(String writerId, String fanId);

    /**
     * 关注成为粉丝
     */
    public void follow(String writerId, String fanId);

    /**
     * 粉丝取消关注
     */
    public void unfollow(String writerId, String fanId);

    /**
     * 查询我的粉丝
     */
    public PagedGridResult queryMyFansList(String writerId, Integer page, Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
@Override
    public PagedGridResult queryMyFansList(String writerId, Integer page, Integer pageSize) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);

        PageHelper.startPage(page,pageSize); //进行分页
        List&lt;Fans&gt; list = fansMapper.select(fans);
        return setterPagedGrid(list,page);
    &#125;
&#125;
</code></pre>
<h3 id="男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts"><a href="#男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts" class="headerlink" title="男女比例柱状图_饼状图显示【数据可视化-粉丝画像】Echarts"></a>男女比例柱状图_饼状图显示【数据可视化-粉丝画像】<del>Echarts</del></h3><p><a target="_blank" rel="noopener" href="https://echarts.apache.org/zh/index.html">Apache ECharts</a> + 前端 [myFansCharts-static.html + myFansCharts.html]</p>
<pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
@ApiOperation(value = &quot;查询男女粉丝数量&quot;, notes = &quot;查询男女粉丝数量&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/queryRatio&quot;)
    public GraceJSONResult queryRatio(@RequestParam String writerId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
 @Override
    public GraceJSONResult queryRatio(String writerId) &#123;
        int manCount = myFansService.queryFansCounts(writerId, Sex.man);
        int womanCount = myFansService.queryFansCounts(writerId, Sex.woman);

        FansCountsVO fansCountsVO = new FansCountsVO();
        fansCountsVO.setManCounts(manCount);
        fansCountsVO.setWomanCounts(womanCount);
        return GraceJSONResult.ok(fansCountsVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

public interface MyFansService &#123;
     /**
     * 查询粉丝数
     */
    public Integer queryFansCounts(String writerId, Sex sex);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
@Override
    public Integer queryFansCounts(String writerId, Sex sex) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);
        fans.setSex(sex.type);

        int count = fansMapper.selectCount(fans);
        return count;
    &#125;
&#125;
</code></pre>
<h3 id="中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】"><a href="#中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】" class="headerlink" title="中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】"></a>中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】</h3><h3 id="男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts-1"><a href="#男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts-1" class="headerlink" title="男女比例柱状图_饼状图显示【数据可视化-粉丝画像】Echarts"></a>男女比例柱状图_饼状图显示【数据可视化-粉丝画像】<del>Echarts</del></h3><p><a target="_blank" rel="noopener" href="https://echarts.apache.org/zh/index.html">Apache ECharts</a> + 前端 [myFansCharts-static.html + myFansCharts.html]</p>
<pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
@ApiOperation(value = &quot;根据地域查询粉丝数量&quot;, notes = &quot;根据地域查询粉丝数量&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/queryRatioByRegion&quot;)
    public GraceJSONResult queryRatioByRegion(@RequestParam String writerId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
  @Override
    public GraceJSONResult queryRatioByRegion(String writerId) &#123;
        return GraceJSONResult.ok(myFansService.queryRegionRatioCounts(writerId));
    &#125;
&#125;
=====================================================================
将fans里的writer_id【自己的cookie里的uid 属于自己的属性 对应着右面的province省份】
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

public interface MyFansService &#123;
     /**
     * 查询粉丝数
     */
    public List&lt;RegionRatioVO&gt; queryRegionRatioCounts(String writerId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
@Override
    public List&lt;RegionRatioVO&gt; queryRegionRatioCounts(String writerId) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);

        List&lt;RegionRatioVO&gt; list = new ArrayList&lt;&gt;();
        for (String r : regions) &#123;
            fans.setProvince(r);
            Integer count = fansMapper.selectCount(fans);

            RegionRatioVO regionRatioVO = new RegionRatioVO();
            regionRatioVO.setName(r);
            regionRatioVO.setValue(count);

            list.add(regionRatioVO);
        &#125;
        return list;
    &#125;

    public static final String[] regions = &#123;&quot;北京&quot;, &quot;天津&quot;, &quot;上海&quot;, &quot;重庆&quot;,
            &quot;河北&quot;, &quot;山西&quot;, &quot;辽宁&quot;, &quot;吉林&quot;, &quot;黑龙江&quot;, &quot;江苏&quot;, &quot;浙江&quot;, &quot;安徽&quot;, &quot;福建&quot;, &quot;江西&quot;, &quot;山东&quot;,
            &quot;河南&quot;, &quot;湖北&quot;, &quot;湖南&quot;, &quot;广东&quot;, &quot;海南&quot;, &quot;四川&quot;, &quot;贵州&quot;, &quot;云南&quot;, &quot;陕西&quot;, &quot;甘肃&quot;, &quot;青海&quot;, &quot;台湾&quot;,
            &quot;内蒙古&quot;, &quot;广西&quot;, &quot;西藏&quot;, &quot;宁夏&quot;, &quot;新疆&quot;,
            &quot;香港&quot;, &quot;澳门&quot;&#125;;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/RegionRatioVO.java
package com.imooc.pojo.vo;

public class RegionRatioVO &#123;

    private String name;
    private Integer value;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Integer getValue() &#123;
        return value;
    &#125;

    public void setValue(Integer value) &#123;
        this.value = value;
    &#125;
&#125;
</code></pre>
<h2 id="开发文章详情接口-【章节概述】detail-html"><a href="#开发文章详情接口-【章节概述】detail-html" class="headerlink" title="开发文章详情接口 【章节概述】detail.html"></a>开发文章详情接口 【章节概述】<del>detail.html</del></h2><ul>
<li><strong>文章详情页</strong></li>
<li><strong>文章评论模块</strong></li>
<li><strong>评论管理</strong></li>
</ul>
<h3 id="文章详情页"><a href="#文章详情页" class="headerlink" title="文章详情页"></a>文章详情页</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
 @GetMapping(&quot;detail&quot;)
    @ApiOperation(value = &quot;文章详情查询&quot;, notes = &quot;文章详情查询&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult detail(@RequestParam String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
 @Override
    public GraceJSONResult detail(String articleId) &#123;
        ArticleDetailVO detailVO = articlePortalService.queryDetail(articleId);

        Set&lt;String&gt; idSet = new HashSet();
        idSet.add(detailVO.getPublishUserId());
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        if (!publisherList.isEmpty()) &#123;
            detailVO.setPublishUserName(publisherList.get(0).getNickname());
        &#125;

        detailVO.setReadCounts(
                getCountsFromRedis(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId));

        return GraceJSONResult.ok(detailVO);
    &#125;
==================================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=240721DDAHBPWG0H
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
    /**
     * 查询文章详情
     */
    public ArticleDetailVO queryDetail(String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
    @Override
    public ArticleDetailVO queryDetail(String articleId) &#123;
        Article article = new Article();
        article.setId(articleId);
        article.setIsAppoint(YesOrNo.NO.type);
        article.setIsDelete(YesOrNo.NO.type);
        article.setArticleStatus(ArticleReviewStatus.SUCCESS.type);

        Article result = articleMapper.selectOne(article);
        ArticleDetailVO detailVO = new ArticleDetailVO();
        BeanUtils.copyProperties(result, detailVO);
        return detailVO;
    &#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/ArticleDetailVO.java
package com.imooc.pojo.vo;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.util.Date;

public class ArticleDetailVO &#123;

    private String id;
    private String title;
    private String cover;
    private Integer categoryId;
    private String categoryName;
    private String publishUserId;
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date publishTime;
    private String content;

    private String publishUserName;
    private Integer readCounts;
&#125;Getter + Setter
</code></pre>
<h3 id="阅读文章-阅读量redis累加【详情页】"><a href="#阅读文章-阅读量redis累加【详情页】" class="headerlink" title="阅读文章_阅读量redis累加【详情页】"></a>阅读文章_阅读量redis累加【详情页】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@PostMapping(&quot;readArticle&quot;)
    @ApiOperation(value = &quot;阅读文章，文章阅读量累加&quot;, notes = &quot;阅读文章，文章阅读量累加&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult readArticle(@RequestParam String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
  @Override
    public GraceJSONResult detail(String articleId) &#123;
        ArticleDetailVO detailVO = articlePortalService.queryDetail(articleId);

        Set&lt;String&gt; idSet = new HashSet();
        idSet.add(detailVO.getPublishUserId());
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        if (!publisherList.isEmpty()) &#123;
            detailVO.setPublishUserName(publisherList.get(0).getNickname());
        &#125;

        detailVO.setReadCounts( //去redis获取值 关联到前端阅读量增加 关联！！！
                getCountsFromRedis(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId));

        return GraceJSONResult.ok(detailVO);
    &#125;

    @Override
    public GraceJSONResult readArticle(String articleId) &#123;
        redis.increment(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId, 1);
        return GraceJSONResult.ok();
    &#125;
==================================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=240721DDAHBPWG0H
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
public class ArticleDetailVO &#123;

    private String id;
    private String title;
    private String cover;
    private Integer categoryId;
    private String categoryName;
    private String publishUserId;
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date publishTime;
    private String content;

    private String publishUserName;
    private Integer readCounts;
&#125;Getter + Setter
</code></pre>
<h3 id="文章阅读数防刷策略【详情页】"><a href="#文章阅读数防刷策略【详情页】" class="headerlink" title="文章阅读数防刷策略【详情页】"></a>文章阅读数防刷策略【详情页】</h3><blockquote>
<p>限定id去做增加 readArticle中增加拦截器<br>在ArticlePortalControllerApi.java中的readArticle接口 增加 HttpServletRequest request</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@PostMapping(&quot;readArticle&quot;)
    @ApiOperation(value = &quot;阅读文章，文章阅读量累加&quot;, notes = &quot;阅读文章，文章阅读量累加&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult readArticle(@RequestParam String articleId, HttpServletRequest request);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult readArticle(String articleId, HttpServletRequest request) &#123;
        String userIp = IPUtil.getRequestIp(request);
        // 设置针对当前用户ip的永久存在的key，存入redis，表示该ip的用户已经阅读过了 防刷策略
        redis.setnx(REDIS_ALREADY_READ + &quot;:&quot; + articleId + &quot;:&quot; + userIp, userIp);

        redis.increment(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId, 1);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/interceptors/ArticleReadInterceptor.java //【增加拦截器】
package com.imooc.api.interceptors;

import com.imooc.utils.IPUtil;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ArticleReadInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    @Autowired
    public RedisOperator redis;
    public static final String REDIS_ALREADY_READ = &quot;redis_already_read&quot;;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        String articleId = request.getParameter(&quot;articleId&quot;);

        String userIp = IPUtil.getRequestIp(request);
        boolean isExist = redis.keyIsExist(REDIS_ALREADY_READ + &quot;:&quot; +  articleId + &quot;:&quot; + userIp);

        if (isExist) &#123;
            return false;
        &#125;
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
...
    @Bean
    public ArticleReadInterceptor articleReadInterceptor()&#123;
        return new ArticleReadInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
...
        registry.addInterceptor(articleReadInterceptor())
                .addPathPatterns(&quot;/portal/article/readArticle&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="Redis-mget-批量查询组装阅读量并展示【文章列表】"><a href="#Redis-mget-批量查询组装阅读量并展示【文章列表】" class="headerlink" title="Redis mget 批量查询组装阅读量并展示【文章列表】"></a>Redis mget 批量查询组装阅读量并展示【文章列表】</h3><h5 id="Redis-get单个读取-amp-amp-Redis-mget批量读取"><a href="#Redis-get单个读取-amp-amp-Redis-mget批量读取" class="headerlink" title="Redis get单个读取 &amp;&amp; Redis mget批量读取"></a>Redis get单个读取 &amp;&amp; Redis mget批量读取</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/9d581a6e864d203ffb7157e6edd621ef947c4775/data/Redis_mget%E6%89%B9%E9%87%8F%E6%9F%A5%E8%AF%A2.png"></p>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
 private PagedGridResult rebuildArticleGrid(PagedGridResult gridResult) &#123;
        // START
        List&lt;Article&gt; list = (List&lt;Article&gt;)gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        List&lt;String&gt; idList = new ArrayList&lt;&gt;();
        for (Article a : list) &#123;
//            System.out.println(a.getPublishUserId());
            // 1.1 构建发布者的set
            idSet.add(a.getPublishUserId());
            // 1.2 构建文章id的list 包含所有key的值
            idList.add(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + a.getId());
        &#125;
        System.out.println(idSet.toString());
        // 发起redis的mget批量查询api，获得对应的值
        List&lt;String&gt; readCountsRedisList = redis.mget(idList);
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        // 3. 拼接两个list，重组文章列表
        List&lt;IndexArticleVO&gt; indexArticleList = new ArrayList&lt;&gt;();
        for (int i = 0 ; i &lt; list.size() ; i ++) &#123;
            IndexArticleVO indexArticleVO = new IndexArticleVO();
            Article a = list.get(i); //属性值拷贝
            BeanUtils.copyProperties(a, indexArticleVO);

            // 3.1 从publisherList中获得发布者的基本信息
            AppUserVO publisher  = getUserIfPublisher(a.getPublishUserId(), publisherList);
            indexArticleVO.setPublisherVO(publisher);

            // 3.2 重新组装设置文章列表中的阅读量
            String redisCountsStr = readCountsRedisList.get(i);
            int readCounts = 0;
            if (StringUtils.isNotBlank(redisCountsStr)) &#123;
                readCounts = Integer.valueOf(redisCountsStr);
            &#125;
            indexArticleVO.setReadCounts(readCounts);

            indexArticleList.add(indexArticleVO);
        &#125;
        gridResult.setRows(indexArticleList);
// END
        return gridResult;
    &#125;
</code></pre>
<h3 id="用户发表评论【文章评论】"><a href="#用户发表评论【文章评论】" class="headerlink" title="用户发表评论【文章评论】"></a>用户发表评论【文章评论】</h3><pre><code class="xml">mybatis-generator-database generatorConfig-article.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;!-- 通用mapper所在目录 --&gt;
        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;com.imooc.my.mapper.MyMapper&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/imooc-news-dev&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 对应生成的pojo所在包 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.imooc.pojo&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot;/&gt;

        &lt;!-- 对应生成的mapper所在目录 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper.article&quot; targetProject=&quot;mybatis-generator-database/src/main/resources&quot;/&gt;

        &lt;!-- 配置mapper对应的java映射 --&gt;
        &lt;javaClientGenerator targetPackage=&quot;com.imooc.article.mapper&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt;

        &lt;!-- 数据库表 --&gt;
        &lt;table tableName=&quot;comments&quot;&gt;&lt;/table&gt;

    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="java">mybatis-generator-database  com/imooc/mybatis/utils/ArticleGenerator.java //【运行】
package com.imooc.mybatis.utils;

import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;


public class ArticleGenerator &#123;

    public void generator() throws Exception &#123;

        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        //指定 逆向工程配置文件
        File configFile = new File(&quot;mybatis-generator-database&quot;
                                            + File.separator
                                            + &quot;generatorConfig-article.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);

    &#125; 
    
    public static void main(String[] args) throws Exception &#123;
        try &#123;
            ArticleGenerator generatorSqlmap = new ArticleGenerator();
            generatorSqlmap.generator();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/CommentsMapper.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Comments;

public interface CommentsMapper extends MyMapper&lt;Comments&gt; &#123;
&#125;

================================================================

</code></pre>
<pre><code class="java">service-article  resources/mapper/CommentsMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapper&quot;&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot;&gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;writerId&quot; /&gt;
    &lt;result column=&quot;father_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fatherId&quot; /&gt;
    &lt;result column=&quot;article_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleId&quot; /&gt;
    &lt;result column=&quot;article_title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleTitle&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleCover&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserId&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserNickname&quot; /&gt;
    &lt;result column=&quot;comment_user_face&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserFace&quot; /&gt;
    &lt;result column=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot;&gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;writerId&quot; /&gt;
    &lt;result column=&quot;father_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fatherId&quot; /&gt;
    &lt;result column=&quot;article_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleId&quot; /&gt;
    &lt;result column=&quot;article_title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleTitle&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleCover&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserId&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserNickname&quot; /&gt;
    &lt;result column=&quot;comment_user_face&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserFace&quot; /&gt;
    &lt;result column=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot;&gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;writerId&quot; /&gt;
    &lt;result column=&quot;father_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fatherId&quot; /&gt;
    &lt;result column=&quot;article_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleId&quot; /&gt;
    &lt;result column=&quot;article_title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleTitle&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleCover&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserId&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserNickname&quot; /&gt;
    &lt;result column=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
@Api(value = &quot;评论相关业务的controller&quot;, tags = &#123;&quot;评论相关业务的controller&quot;&#125;)
@RequestMapping(&quot;comment&quot;)
public interface CommentControllerApi &#123;

    @PostMapping(&quot;createComment&quot;)
    @ApiOperation(value = &quot;用户评论&quot;, notes = &quot;用户评论&quot;, httpMethod = &quot;POST&quot;) //@Valid是做验证的
    public GraceJSONResult createArticle(@RequestBody @Valid CommentReplyBO commentReplyBO, BindingResult result);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
@RestController
public class CommentController extends BaseController implements CommentControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(CommentController.class);

    @Override
    public GraceJSONResult createArticle(@Valid CommentReplyBO commentReplyBO,
                                         BindingResult result) &#123;
        // 0. 判断BindingResult是否保存错误的验证信息，如果有，则直接return
        if (result.hasErrors()) &#123;
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;

        // 1. 根据留言用户的id查询他的昵称，用于存入到数据表进行字段的冗余处理，从而避免多表关联查询的性能影响
        String userId = commentReplyBO.getCommentUserId();

        // 2. 发起restTemplate调用用户服务，获得用户侧昵称
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        idSet.add(userId);
        String nickname = getBasicUserList(idSet).get(0).getNickname();
...[未完待续]
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public List&lt;AppUserVO&gt; getBasicUserList(Set idSet) &#123;
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; userVOList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            userVOList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return userVOList;
    &#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/CommentReplyBO.java
/**
 * 文章留言的BO
 */
public class CommentReplyBO &#123;

    @NotBlank(message = &quot;留言信息不完整&quot;)
    private String articleId;

    @NotBlank(message = &quot;留言信息不完整&quot;)
    private String fatherId;

    @NotBlank(message = &quot;当前用户信息不正确，请尝试重新登录&quot;)
    private String commentUserId;

    @NotBlank(message = &quot;留言内容不能为空&quot;)
    @Length(max = 50, message = &quot;文章内容长度不能超过50&quot;)
    private String content;
&#125;Getter + Setter + ToString
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Comments.java
public class Comments &#123;
    @Id
    private String id;

    /**
     * 评论的文章是哪个作者的关联id
     */
    @Column(name = &quot;writer_id&quot;)
    private String writerId;

    /**
     * 如果是回复留言，则本条为子留言，需要关联查询
     */
    @Column(name = &quot;father_id&quot;)
    private String fatherId;

    /**
     * 回复的那个文章id
     */
    @Column(name = &quot;article_id&quot;)
    private String articleId;

    /**
     * 冗余文章标题，宽表处理，非规范化的sql思维，对于几百万文章和几百万评论的关联查询来讲，性能肯定不行，所以做宽表处理，从业务角度来说，文章发布以后不能随便修改标题和封面的
     */
    @Column(name = &quot;article_title&quot;)
    private String articleTitle;

    /**
     * 文章封面
     */
    @Column(name = &quot;article_cover&quot;)
    private String articleCover;

    /**
     * 发布留言的用户id
     */
    @Column(name = &quot;comment_user_id&quot;)
    private String commentUserId;

    /**
     * 冗余用户昵称，非一致性字段，用户修改昵称后可以不用同步
     */
    @Column(name = &quot;comment_user_nickname&quot;)
    private String commentUserNickname;

    /**
     * 冗余的用户头像
     */
    @Column(name = &quot;comment_user_face&quot;)
    private String commentUserFace;

    /**
     * 留言内容
     */
    private String content;

    /**
     * 留言时间
     */
    @Column(name = &quot;create_time&quot;)
    private Date createTime;
</code></pre>
<h3 id="用户评论入库保存【文章评论】这里暂时把数据库的comment-user-face删除了"><a href="#用户评论入库保存【文章评论】这里暂时把数据库的comment-user-face删除了" class="headerlink" title="用户评论入库保存【文章评论】这里暂时把数据库的comment_user_face删除了"></a>用户评论入库保存【文章评论】<del>这里暂时把数据库的comment_user_face删除了</del></h3><pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
@Api(value = &quot;评论相关业务的controller&quot;, tags = &#123;&quot;评论相关业务的controller&quot;&#125;)
@RequestMapping(&quot;comment&quot;)
public interface CommentControllerApi &#123;

    @PostMapping(&quot;createComment&quot;)
    @ApiOperation(value = &quot;用户评论&quot;, notes = &quot;用户评论&quot;, httpMethod = &quot;POST&quot;) //@Valid是做验证的
    public GraceJSONResult createArticle(@RequestBody @Valid CommentReplyBO commentReplyBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
@RestController
public class CommentController extends BaseController implements CommentControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(CommentController.class);
    @Autowired
    private CommentPortalService commentPortalService;

    @Override
    public GraceJSONResult createArticle(@Valid CommentReplyBO commentReplyBO,
                                         BindingResult result) &#123;
        // 0. 判断BindingResult是否保存错误的验证信息，如果有，则直接return
        if (result.hasErrors()) &#123;
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;

        // 1. 根据留言用户的id查询他的昵称，用于存入到数据表进行字段的冗余处理，从而避免多表关联查询的性能影响
        String userId = commentReplyBO.getCommentUserId();

        // 2. 发起restTemplate调用用户服务，获得用户侧昵称
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        idSet.add(userId);
        String nickname = getBasicUserList(idSet).get(0).getNickname();

        // 3. 保存用户评论的信息到数据库
        commentPortalService.createComment(commentReplyBO.getArticleId(), commentReplyBO.getFatherId(), commentReplyBO.getContent(), userId, nickname);

        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java
public interface CommentPortalService &#123;
    /**
     * 发表评论
     */
    public void createComment(String articleId,
                              String fatherCommentId,
                              String content,
                              String userId,
                              String nickname);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
package com.imooc.article.service.impl;

import com.imooc.api.service.BaseService;
import com.imooc.article.mapper.CommentsMapper;
import com.imooc.article.service.ArticlePortalService;
import com.imooc.article.service.CommentPortalService;
import com.imooc.pojo.Comments;
import com.imooc.pojo.vo.ArticleDetailVO;
import com.imooc.utils.PagedGridResult;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;


@Service
public class CommentPortalServiceImpl extends BaseService implements CommentPortalService &#123;
    @Autowired
    private ArticlePortalService articlePortalService;
    @Autowired
    private Sid sid;
    @Autowired
    private CommentsMapper commentsMapper;

    @Transactional
    @Override
    public void createComment(String articleId, String fatherCommentId, String content, String userId, String nickname) &#123;
        String commentId = sid.nextShort();
        ArticleDetailVO article = articlePortalService.queryDetail(articleId);
        Comments comments = new Comments();
        comments.setId(commentId);

        comments.setWriterId(article.getPublishUserId());
        comments.setArticleTitle(article.getTitle());
        comments.setArticleCover(article.getCover());
        comments.setArticleId(articleId);

        comments.setFatherId(fatherCommentId);
        comments.setCommentUserId(userId);
        comments.setCommentUserNickname(nickname);

        comments.setContent(content);
        comments.setCreateTime(new Date());

        commentsMapper.insert(comments);

        // 评论数累加
        redis.increment(REDIS_ARTICLE_COMMENT_COUNTS + &quot;:&quot; + articleId, 1);
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Comments.java
public class Comments &#123;
    @Id
    private String id;

    /**
     * 评论的文章是哪个作者的关联id
     */
    @Column(name = &quot;writer_id&quot;)
    private String writerId;

    /**
     * 如果是回复留言，则本条为子留言，需要关联查询
     */
    @Column(name = &quot;father_id&quot;)
    private String fatherId;

    /**
     * 回复的那个文章id
     */
    @Column(name = &quot;article_id&quot;)
    private String articleId;

    /**
     * 冗余文章标题，宽表处理，非规范化的sql思维，对于几百万文章和几百万评论的关联查询来讲，性能肯定不行，所以做宽表处理，从业务角度来说，文章发布以后不能随便修改标题和封面的
     */
    @Column(name = &quot;article_title&quot;)
    private String articleTitle;

    /**
     * 文章封面
     */
    @Column(name = &quot;article_cover&quot;)
    private String articleCover;

    /**
     * 发布留言的用户id
     */
    @Column(name = &quot;comment_user_id&quot;)
    private String commentUserId;

    /**
     * 冗余用户昵称，非一致性字段，用户修改昵称后可以不用同步
     */
    @Column(name = &quot;comment_user_nickname&quot;)
    private String commentUserNickname;

//    /**
//     * 冗余的用户头像
//     */
//    @Column(name = &quot;comment_user_face&quot;)
//    private String commentUserFace;

    /**
     * 留言内容
     */
    private String content;

    /**
     * 留言时间
     */
    @Column(name = &quot;create_time&quot;)
    private Date createTime;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public List&lt;AppUserVO&gt; getBasicUserList(Set idSet) &#123;
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; userVOList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            userVOList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return userVOList;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/CommentsMapper.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Comments;
import org.springframework.stereotype.Repository;

@Repository
public interface CommentsMapper extends MyMapper&lt;Comments&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">service-article  resources/mapper/CommentsMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; property=&quot;writerId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;father_id&quot; property=&quot;fatherId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; property=&quot;articleCover&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; property=&quot;commentUserId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; property=&quot;commentUserNickname&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;content&quot; property=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="评论数累计与显示【文章评论】"><a href="#评论数累计与显示【文章评论】" class="headerlink" title="评论数累计与显示【文章评论】"></a>评论数累计与显示【文章评论】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
@Api(value = &quot;评论相关业务的controller&quot;, tags = &#123;&quot;评论相关业务的controller&quot;&#125;)
@RequestMapping(&quot;comment&quot;)
public interface CommentControllerApi &#123;
@GetMapping(&quot;counts&quot;)
    @ApiOperation(value = &quot;用户评论数查询&quot;, notes = &quot;用户评论数查询&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult commentCounts(@RequestParam String articleId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
 @Override
    public GraceJSONResult commentCounts(String articleId) &#123;
        Integer counts = getCountsFromRedis(REDIS_ARTICLE_COMMENT_COUNTS + &quot;:&quot; + articleId);
        return GraceJSONResult.ok(counts);
    &#125;

--------------------------------------------------------------------------
service-api  com/imooc/api/BaseController.java
public Integer getCountsFromRedis(String key)&#123;
        String countsStr = redis.get(key);
        if (StringUtils.isBlank(countsStr)) &#123;
            countsStr = &quot;0&quot;;
        &#125;
        return Integer.valueOf(countsStr);
    &#125;
</code></pre>
<h3 id="文章评论sql关联查询father-id…"><a href="#文章评论sql关联查询father-id…" class="headerlink" title="文章评论sql关联查询father_id…"></a>文章评论sql关联查询<del>father_id…</del></h3><pre><code class="mysql">【多表关联查询】
SELECT
    c.id as commentId,
    c.father_id as fatherId,
    c.comment_user_id as commentUserId,
    c.comment_user_nickname as commentUserNickname,
    c.article_id as articleId,
    c.content as content,
    c.create_time as createTime,
    f.comment_user_nickname as quoteUserNickname,
    f.content as quoteContent
FROM
    comments c
LEFT JOIN
    comments f
ON
    c.father_id = f.id
WHERE
    c.article_id = &#39;2006117B57WRZGHH&#39;
ORDER BY
    c.create_time
DESC
</code></pre>
<h3 id="显示评论列表【文章评论】"><a href="#显示评论列表【文章评论】" class="headerlink" title="显示评论列表【文章评论】"></a>显示评论列表【文章评论】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
com/imooc/api/controller/article/CommentControllerApi.java 
@GetMapping(&quot;list&quot;)
    @ApiOperation(value = &quot;查询文章的所有评论列表&quot;, notes = &quot;查询文章的所有评论列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult list(@RequestParam String articleId,
                                @RequestParam Integer page,
                                @RequestParam Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
@Override
    public GraceJSONResult list(String articleId, Integer page, Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        PagedGridResult gridResult = commentPortalService.queryArticleComments(articleId, page, pageSize);
        return GraceJSONResult.ok(gridResult);
    &#125;
==============================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=200816961ZYBXFRP
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java
/**
     * 查询文章评论列表
     */
    public PagedGridResult queryArticleComments(String articleId,
                                                Integer page,
                                                Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/CommentsMapperCustom.java
package com.imooc.article.mapper;

import com.imooc.pojo.vo.CommentsVO;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

@Repository
public interface CommentsMapperCustom &#123;

    /**
     * 查询文章评论
     */
    public List&lt;CommentsVO&gt; queryArticleCommentList(@Param(&quot;paramMap&quot;) Map&lt;String, Object&gt; map);

&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
@Override
    public PagedGridResult queryArticleComments(String articleId, Integer page, Integer pageSize) &#123;
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleId&quot;, articleId);

        PageHelper.startPage(page, pageSize);
        List&lt;CommentsVO&gt; list = commentsMapperCustom.queryArticleCommentList(map);
        return setterPagedGrid(list,page);
    &#125;
</code></pre>
<pre><code class="mysql">service-article  resources/mapper/CommentsMapperCustom.xml #【把关于face的字段都删掉】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapperCustom&quot; &gt;

  &lt;select id=&quot;queryArticleCommentList&quot;
          resultType=&quot;com.imooc.pojo.vo.CommentsVO&quot;
          parameterType=&quot;Map&quot;&gt;

    SELECT
      c.id as commentId,
      c.father_id as fatherId,
      c.comment_user_id as commentUserId,
      c.comment_user_nickname as commentUserNickname,
      c.article_id as articleId,
      c.content as content,
      c.create_time as createTime,
      f.comment_user_nickname as quoteUserNickname,
      f.content as quoteContent
    FROM
      comments c
        LEFT JOIN
      comments f
      ON
        c.father_id = f.id
    WHERE
      c.article_id = #&#123;paramMap.articleId&#125;
    ORDER BY
      c.create_time
            DESC

  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="作业-管理评论列表以及删除评论【评论管理】"><a href="#作业-管理评论列表以及删除评论【评论管理】" class="headerlink" title="(作业) 管理评论列表以及删除评论【评论管理】"></a>(作业) 管理评论列表以及删除评论【评论管理】</h3><blockquote>
<p>前端的commentMng.html的VUE有问题<br>需要增加定义userInfo<br>var mainPage &#x3D; new Vue({<br>        el: “#mainPage”,<br>data: {<br>            userInfo: {<br>                activeStatus: 0<br>            },<br>}…</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
    @PostMapping(&quot;mng&quot;)
    @ApiOperation(value = &quot;查询我的评论管理列表&quot;, notes = &quot;查询我的评论管理列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult mng(@RequestParam String writerId,
                               @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                               @RequestParam Integer page,
                               @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                               @RequestParam Integer pageSize);


    @PostMapping(&quot;/delete&quot;)
    @ApiOperation(value = &quot;作者删除评论&quot;, notes = &quot;作者删除评论&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult delete(@RequestParam String writerId,
                                  @RequestParam String commentId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
 @Override
    public GraceJSONResult mng(String writerId, Integer page, Integer pageSize) &#123;

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult = commentPortalService.queryWriterCommentsMng(writerId, page, pageSize);
        return GraceJSONResult.ok(gridResult);
    &#125;

    @Override
    public GraceJSONResult delete(String writerId, String commentId) &#123;
        commentPortalService.deleteComment(writerId, commentId);
        return GraceJSONResult.ok();
    &#125;
==============================================================
http://writer.imoocnews.com:9090/imooc-news/writer/commentMng.html
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java
     /**
     * 查询我的评论管理列表
     */
    public PagedGridResult queryWriterCommentsMng(String writerId, Integer page, Integer pageSize);

    /**
     * 删除评论
     */
    public void deleteComment(String writerId, String commentId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
@Override
    public PagedGridResult queryWriterCommentsMng(String writerId, Integer page, Integer pageSize) &#123;
        Comments comment = new Comments();
        comment.setWriterId(writerId);
        PageHelper.startPage(page, pageSize);
        List&lt;Comments&gt; list = commentsMapper.select(comment);
        return setterPagedGrid(list,page);
    &#125;

    @Override
    public void deleteComment(String writerId, String commentId) &#123;
        Comments comment = new Comments();
        comment.setId(commentId);
        comment.setWriterId(writerId);
        commentsMapper.delete(comment);
    &#125;
</code></pre>
<h3 id="增加评论者头像展示功能需求扩展【文章评论】增加需求字段comment-user-face"><a href="#增加评论者头像展示功能需求扩展【文章评论】增加需求字段comment-user-face" class="headerlink" title="增加评论者头像展示功能需求扩展【文章评论】增加需求字段comment_user_face"></a>增加评论者头像展示功能需求扩展【文章评论】<del>增加需求字段comment_user_face</del></h3><blockquote>
<p>[数据库添加一个新的字段comment_user_face 重新在mybatis-generator-database进行逆向生成覆盖]<br>涉及范围广</p>
<p>在数据库里也要加个字段  在前端需求也要改一下头像</p>
</blockquote>
<pre><code class="html">detail.html
&lt;div class=&quot;all-comments-list&quot; v-for=&quot;(comment,index) in commentList&quot; :key=&quot;index&quot;&gt;
        &lt;div class=&quot;single-comment-wrapper&quot;&gt;
        &lt;!--&lt;img src=&quot;./img/face1.png&quot; class=&quot;user-face&quot;/&gt;--&gt;
        &lt;img :src=&quot;comment.commentUserFace&quot; class=&quot;user-face&quot;/&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="mysql">service-article  resources/mapper/CommentsMapper.xml #【增加字段】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; property=&quot;writerId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;father_id&quot; property=&quot;fatherId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; property=&quot;articleCover&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; property=&quot;commentUserId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; property=&quot;commentUserNickname&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_face&quot; property=&quot;commentUserFace&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;content&quot; property=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="mysql">service-article  resources/mapper/CommentsMapperCustom.xml #【增加字段】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapperCustom&quot; &gt;

  &lt;select id=&quot;queryArticleCommentList&quot;
          resultType=&quot;com.imooc.pojo.vo.CommentsVO&quot;
          parameterType=&quot;Map&quot;&gt;

    SELECT
      c.id as commentId,
      c.father_id as fatherId,
      c.comment_user_id as commentUserId,
      c.comment_user_nickname as commentUserNickname,
      c.comment_user_face as commentUserFace,
      c.article_id as articleId,
      c.content as content,
      c.create_time as createTime,
      f.comment_user_nickname as quoteUserNickname,
      f.content as quoteContent
    FROM
      comments c
        LEFT JOIN
      comments f
      ON
        c.father_id = f.id
    WHERE
      c.article_id = #&#123;paramMap.articleId&#125;
    ORDER BY
      c.create_time
            DESC

  &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java //【增加字段】
 /**
     * 发表评论
     */
    public void createComment(String articleId,
                              String fatherCommentId,
                              String content,
                              String userId,
                              String nickname,
                              String face);
</code></pre>
<pre><code class="java">------------------------------------------------------------
dev-model  com/imooc/pojo/vo/CommentsVO.java //【增加字段属性】
private String commentUserFace;
    【Getter + Setter】

------------------------------------------------------------
dev-model  com/imooc/pojo/Comments.java
/**
     * 冗余的用户头像
     */
@Column(name = &quot;comment_user_face&quot;)
private String commentUserFace;
    【Getter + Setter】
------------------------------------------------------------
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java 
    //【增加 String face = getBasicUserList(idSet).get(0).getFace();】
@Override
    public GraceJSONResult createArticle(@Valid CommentReplyBO commentReplyBO,
                                         BindingResult result) &#123;
        // 0. 判断BindingResult是否保存错误的验证信息，如果有，则直接return
        if (result.hasErrors()) &#123;
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;

        // 1. 根据留言用户的id查询他的昵称，用于存入到数据表进行字段的冗余处理，从而避免多表关联查询的性能影响
        String userId = commentReplyBO.getCommentUserId();

        // 2. 发起restTemplate调用用户服务，获得用户侧昵称
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        idSet.add(userId);
        String nickname = getBasicUserList(idSet).get(0).getNickname();
        String face = getBasicUserList(idSet).get(0).getFace();

        // 3. 保存用户评论的信息到数据库
        commentPortalService.createComment(commentReplyBO.getArticleId(), commentReplyBO.getFatherId(), commentReplyBO.getContent(), userId, nickname,face);

        return GraceJSONResult.ok();
    &#125;
====================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=2006116Z3MAP8SW0
//下面有个评论：牛逼  带着自己上传的头像
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
    //【增加 comments.setCommentUserFace(face);】
@Transactional
    @Override
    public void createComment(String articleId, String fatherCommentId, String content, String userId, String nickname,String face) &#123;
        String commentId = sid.nextShort();
        ArticleDetailVO article = articlePortalService.queryDetail(articleId);
        Comments comments = new Comments();
        comments.setId(commentId);

        comments.setWriterId(article.getPublishUserId());
        comments.setArticleTitle(article.getTitle());
        comments.setArticleCover(article.getCover());
        comments.setArticleId(articleId);

        comments.setFatherId(fatherCommentId);
        comments.setCommentUserId(userId);
        comments.setCommentUserNickname(nickname);
        comments.setCommentUserFace(face);

        comments.setContent(content);
        comments.setCreateTime(new Date());

        commentsMapper.insert(comments);

        // 评论数累加
        redis.increment(REDIS_ARTICLE_COMMENT_COUNTS + &quot;:&quot; + articleId, 1);
    &#125;
</code></pre>
<h3 id="文章静态化技术与Freemarker【文章概述】"><a href="#文章静态化技术与Freemarker【文章概述】" class="headerlink" title="文章静态化技术与Freemarker【文章概述】"></a>文章静态化技术与Freemarker【文章概述】</h3><ul>
<li><strong>页面静态化</strong></li>
<li><strong>Freemarker静态化技术</strong></li>
<li><strong>渲染模板数据</strong></li>
<li><strong>生成并展示静态页面</strong></li>
</ul>
<h5 id="静态化趋势"><a href="#静态化趋势" class="headerlink" title="静态化趋势"></a>静态化趋势</h5><ul>
<li><strong>便于SEO</strong></li>
<li><strong>加速用户访问</strong></li>
<li><strong>降低数据库压力</strong></li>
</ul>
<h5 id="模板引擎技术"><a href="#模板引擎技术" class="headerlink" title="模板引擎技术"></a>模板引擎技术</h5><ul>
<li><strong>JSP</strong></li>
<li><strong>Freemarker</strong></li>
<li><strong>Thymeleaf</strong></li>
<li><strong>Velocity</strong></li>
</ul>
<h5 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/1f57d8e494be53fe2ee4745f819db41fe1e7173a/data/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96.png"></p>
<h3 id="创建并且显示模板ftl"><a href="#创建并且显示模板ftl" class="headerlink" title="创建并且显示模板ftl"></a>创建并且显示模板ftl</h3><pre><code class="xml">service-article  pom.xml
 &lt;!-- freemarker 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        // 定义输出到模板的内容
        // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);

        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;
&#125;
==================================================================
http://localhost:8001/free/hello
</code></pre>
<pre><code class="yaml">service-article  resources/application.yml 【suffix是模板后缀】
  freemarker:
    charset: UTF-8
    content-type: text/html
    suffix: .ftl
    template-loader-path: classpath:/templates/
</code></pre>
<pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Hello Freemarker&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;#-- 
        写完以后去模板页面配置 application.yml
        Freemarker 页面的语法构成：
        1. 注释
        2. 表达式 $&#123;...&#125;
        3. 普通文本，基本的html标签
        4. 指令
    --&gt;
        &lt;div&gt;
            hello $&#123;there&#125;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="输出对象【Freemarker语法】"><a href="#输出对象【Freemarker语法】" class="headerlink" title="输出对象【Freemarker语法】"></a>输出对象【Freemarker语法】</h3><pre><code class="java">dev-model  com/imooc/pojo/Stu.java
public class Stu &#123;
    private String uid;
    private String username;
    private Integer age;
    private Date birthday;
    private Float amount;
    private boolean haveChild;
    private Spouse spouse;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Spouse.java
public class Spouse &#123;
    private String username;
    private Integer age;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        // 定义输出到模板的内容
        // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);

        makeModel(model);
        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;

    private Model makeModel(Model model) &#123;
        Stu stu = new Stu();
        stu.setUid(&quot;10010&quot;);
        stu.setUsername(&quot;imooc&quot;);
        stu.setAmount(88.86f);
        stu.setAge(18);
        stu.setHaveChild(true);
        stu.setBirthday(new Date());

        Spouse spouse = new Spouse();
        spouse.setUsername(&quot;Lucy&quot;);
        spouse.setAge(25);
        stu.setSpouse(spouse);
        model.addAttribute(&quot;stu&quot;,stu);
        return model;
    &#125;
&#125;
==================================================================
http://localhost:8001/free/hello

Hello 慕课网 imooc.com

用户名uid: 10010
用户姓名: imooc
年龄：18
生日：2024-07-29 15:13:05
用户余额：88.86
已育：yes
伴侣：Lucy,25岁
</code></pre>
<pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello Freemarker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;#-- 写完以后去模板页面配置 application.yml
    Freemarker 页面的语法构成：
    1. 注释
    2. 表达式 $&#123;...&#125;
    3. 普通文本，基本的html标签
    4. 指令
--&gt;
    &lt;div&gt;
        hello $&#123;there&#125;
    &lt;/div&gt;
&lt;br&gt;

    &lt;div&gt;
        用户名uid: $&#123;stu.uid&#125;&lt;br&gt;
        用户姓名: $&#123;stu.username&#125;&lt;br&gt;
        年龄：$&#123;stu.age&#125;&lt;br&gt;
        生日：$&#123;stu.birthday?string(&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&lt;br&gt; &lt;#-- 日期转换 --&gt;
        用户余额：$&#123;stu.amount&#125;&lt;br&gt;
        已育：$&#123;stu.haveChild?string(&#39;yes&#39;, &#39;no&#39;)&#125;&lt;br&gt;
        伴侣：$&#123;stu.spouse.username&#125;,$&#123;stu.spouse.age&#125;岁

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="输出list与map【Freemarker语法】"><a href="#输出list与map【Freemarker语法】" class="headerlink" title="输出list与map【Freemarker语法】"></a>输出list与map【Freemarker语法】</h3><pre><code class="java">dev-model  com/imooc/pojo/Stu.java
public class Stu &#123;
    private String uid;
    private String username;
    private Integer age;
    private Date birthday;
    private Float amount;
    private boolean haveChild;

    private Spouse spouse;

    private List&lt;Article&gt; articleList;
    private Map&lt;String, String&gt; parents;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Spouse.java
public class Spouse &#123;
    private String username;
    private Integer age;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.Article;
import com.imooc.pojo.Spouse;
import com.imooc.pojo.Stu;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.*;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        // 定义输出到模板的内容
        // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);

        makeModel(model);
        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;

    private Model makeModel(Model model) &#123;
        Stu stu = new Stu();
        stu.setUid(&quot;10010&quot;);
        stu.setUsername(&quot;imooc&quot;);
        stu.setAmount(88.86f);
        stu.setAge(18);
        stu.setHaveChild(true);
        stu.setBirthday(new Date());

        Spouse spouse = new Spouse();
        spouse.setUsername(&quot;Lucy&quot;);
        spouse.setAge(25);

        stu.setSpouse(spouse);
        stu.setArticleList(getArticles());
        stu.setParents(getParents());

        model.addAttribute(&quot;stu&quot;,stu);
        return model;
    &#125;

    private List&lt;Article&gt; getArticles()&#123;
        Article article1 = new Article();
        article1.setId(&quot;1001&quot;);
        article1.setTitle(&quot;今天天气不错&quot;);

        Article article2 = new Article();
        article2.setId(&quot;1002&quot;);
        article2.setTitle(&quot;今天下雨了&quot;);

        Article article3 = new Article();
        article3.setId(&quot;1003&quot;);
        article3.setTitle(&quot;昨天下雨了&quot;);

        List&lt;Article&gt; list = new ArrayList&lt;&gt;();
        list.add(article1);
        list.add(article2);
        list.add(article3);
        return list;
    &#125;

    private Map&lt;String, String&gt; getParents()&#123;
        Map&lt;String, String&gt; parents = new HashMap&lt;&gt;();
        parents.put(&quot;father&quot;, &quot;XiaoMing&quot;);
        parents.put(&quot;mother&quot;, &quot;LiLi&quot;);
        return parents;
    &#125;
&#125;
==================================================================
http://localhost:8001/free/hello

hello 慕课网 imooc.com

用户名uid: 10010
用户姓名: imooc
年龄：18
生日：2024-07-29 15:39:07
用户余额：88.86
已育：yes
伴侣：Lucy,25岁

1001 今天天气不错
1002 今天下雨了
1003 昨天下雨了

LiLi
XiaoMing
</code></pre>
<pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello Freemarker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;#-- 写完以后去模板页面配置 application.yml
    Freemarker 页面的语法构成：
    1. 注释
    2. 表达式 $&#123;...&#125;
    3. 普通文本，基本的html标签
    4. 指令
--&gt;
    &lt;div&gt;
        hello $&#123;there&#125;
    &lt;/div&gt;
&lt;br&gt;

    &lt;div&gt;
        用户名uid: $&#123;stu.uid&#125;&lt;br&gt;
        用户姓名: $&#123;stu.username&#125;&lt;br&gt;
        年龄：$&#123;stu.age&#125;&lt;br&gt;
        生日：$&#123;stu.birthday?string(&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&lt;br&gt; &lt;#-- 日期转换 --&gt;
        用户余额：$&#123;stu.amount&#125;&lt;br&gt;
        已育：$&#123;stu.haveChild?string(&#39;yes&#39;, &#39;no&#39;)&#125;&lt;br&gt;
        伴侣：$&#123;stu.spouse.username&#125;,$&#123;stu.spouse.age&#125;岁
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.articleList as article&gt;
            &lt;div&gt;
                &lt;span&gt;$&#123;article.id&#125;&lt;/span&gt;
                &lt;span&gt;$&#123;article.title&#125;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.parents?keys as key&gt;
            &lt;div&gt;
                $&#123;stu.parents[key]&#125;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令if【Freemarker语法】"><a href="#指令if【Freemarker语法】" class="headerlink" title="指令if【Freemarker语法】"></a>指令if【Freemarker语法】</h3><pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello Freemarker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;#-- 
    写完以后去模板页面配置 application.yml
    Freemarker 页面的语法构成：
    1. 注释
    2. 表达式 $&#123;...&#125;
    3. 普通文本，基本的html标签
    4. 指令
--&gt;
    &lt;div&gt;
        hello $&#123;there&#125;
    &lt;/div&gt;
&lt;br&gt;

    &lt;div&gt;
        用户名uid: $&#123;stu.uid&#125;&lt;br&gt;
        用户姓名: $&#123;stu.username&#125;&lt;br&gt;
        年龄：$&#123;stu.age&#125;&lt;br&gt;
        生日：$&#123;stu.birthday?string(&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&lt;br&gt; &lt;#-- 日期转换 --&gt;
        用户余额：$&#123;stu.amount&#125;&lt;br&gt;
        已育：$&#123;stu.haveChild?string(&#39;yes&#39;, &#39;no&#39;)&#125;&lt;br&gt;
        &lt;#if stu.spouse??&gt;
            伴侣：$&#123;stu.spouse.username&#125;, $&#123;stu.spouse.age&#125;岁
        &lt;/#if&gt;
        &lt;#if !stu.spouse??&gt;
            单身狗
        &lt;/#if&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.articleList as article&gt;
            &lt;div&gt;
                &lt;span&gt;$&#123;article.id&#125;&lt;/span&gt;
                &lt;span&gt;$&#123;article.title&#125;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.parents?keys as key&gt;
            &lt;div&gt;
                $&#123;stu.parents[key]&#125;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#if stu.uid == &#39;10010&#39;&gt;
            用户id是10010
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if stu.username != &#39;imooc&#39;&gt;
            用户名不是imooc
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if (stu.age &gt;= 18) &gt;
            用户已成年
        &lt;/#if&gt;
        &lt;br&gt;
        &lt;#if (stu.age &gt; 18 || stu.age = 18) &gt;
            成年人
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if (stu.age &lt; 18) &gt;
            未成年
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if stu.haveChild &gt;
            已育
        &lt;/#if&gt;
        &lt;br&gt;
        &lt;#if !stu.haveChild &gt;
             未育
        &lt;/#if&gt;
     &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span style = "color:red">在这里特别注意一下 已经开始第二阶段的代码 进阶篇 所以前端的代码也是需要更新换代的 包括..&#x2F;js&#x2F;app.js里面多了 app.getPageName();</span><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/questiondetail/4daeRX4JGBRPnWEp.html">没有getPageName这个函数-慕课网 (imooc.com)</a><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/questiondetail/224939.html">生成的html调用app.js中getPageName()函数出错的问题-慕课网 (imooc.com)</a></p>
<h3 id="结合动态数据生成静态化HTML【Freemarker】"><a href="#结合动态数据生成静态化HTML【Freemarker】" class="headerlink" title="结合动态数据生成静态化HTML【Freemarker】"></a>结合动态数据生成静态化HTML【Freemarker】</h3><pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
【stu.ftl如上图不变增加java的整合代码】 俗称Java+ftl=HTML
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.Article;
import com.imooc.pojo.Spouse;
import com.imooc.pojo.Stu;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.*;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;

    @Value(&quot;$&#123;freemarker.html.target&#125;&quot;)
    private String htmlTarget;

    @GetMapping(&quot;/createHTML&quot;)
    @ResponseBody
    public String createHTML(Model model) throws IOException, TemplateException &#123;
        // 0. 配置freemarker基本环境
        Configuration cfg = new Configuration(Configuration.getVersion());
        // 声明freemarker模板所需要加载的目录的位置
            //resources/templates/stu.ftl
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File((classpath + &quot;templates&quot;)));

            // 测试打印
        System.out.println(htmlTarget);
        System.out.println(classpath + &quot;templates&quot;);
        /**
         * /workspace/freemarker_html
         * /C:/Users/Pluminary/Desktop/backup/imooc-news-dev/imooc-news-dev-service-article/target/classes/templates
         */
        // 1. 获得现有的模板ftl文件
        Template template = cfg.getTemplate(&quot;stu.ftl&quot;, &quot;utf-8&quot;);

        // 2. 获得动态数据
            // 定义输出到模板的内容
            // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);
        model = makeModel(model);

        // 3. 融合动态数据和ftl，生成html
        File tempDic = new File(htmlTarget);
        if (!tempDic.exists()) &#123;
            tempDic.mkdirs();
        &#125;
        Writer out = new FileWriter(htmlTarget + File.separator + &quot;10010&quot; + &quot;.html&quot;);
        template.process(model, out);
        out.close();
        return &quot;ok&quot;;
        // C:\workspace\freemarker_html\10010.html 里面的数据都是静态数据
    &#125;

    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        makeModel(model);
        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;

    private Model makeModel(Model model) &#123;
        Stu stu = new Stu();
        stu.setUid(&quot;10010&quot;);
        stu.setUsername(&quot;imooc&quot;);
        stu.setAmount(88.86f);
        stu.setAge(18);
        stu.setHaveChild(true);
        stu.setBirthday(new Date());

        Spouse spouse = new Spouse();
        spouse.setUsername(&quot;Lucy&quot;);
        spouse.setAge(25);

        stu.setSpouse(spouse);
        stu.setArticleList(getArticles());
        stu.setParents(getParents());

        model.addAttribute(&quot;stu&quot;,stu);
        return model;
    &#125;

    private List&lt;Article&gt; getArticles()&#123;
        Article article1 = new Article();
        article1.setId(&quot;1001&quot;);
        article1.setTitle(&quot;今天天气不错&quot;);

        Article article2 = new Article();
        article2.setId(&quot;1002&quot;);
        article2.setTitle(&quot;今天下雨了&quot;);

        Article article3 = new Article();
        article3.setId(&quot;1003&quot;);
        article3.setTitle(&quot;昨天下雨了&quot;);

        List&lt;Article&gt; list = new ArrayList&lt;&gt;();
        list.add(article1);
        list.add(article2);
        list.add(article3);
        return list;
    &#125;

    private Map&lt;String, String&gt; getParents()&#123;
        Map&lt;String, String&gt; parents = new HashMap&lt;&gt;();
        parents.put(&quot;father&quot;, &quot;XiaoMing&quot;);
        parents.put(&quot;mother&quot;, &quot;LiLi&quot;);
        return parents;
    &#125;
&#125;
</code></pre>
<h3 id="改写详情页为模板页ftl【页面静态化】"><a href="#改写详情页为模板页ftl【页面静态化】" class="headerlink" title="改写详情页为模板页ftl【页面静态化】"></a>改写详情页为模板页ftl【页面静态化】</h3><blockquote>
<p>地址页不是拼接   将detail.html 的路径都变成绝对路径</p>
<!--<link rel="shortcut icon" href="img/mu-toutiao.ico" />-->
<pre><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;../img/mu-toutiao.ico&quot; /&gt;
</code></pre>
<p>把其拷贝到 resources&#x2F;templates&#x2F;detail.ftl</p>
</blockquote>
<pre><code class="html">【放在d盘 tomcat/webapps中的】detail.ftl
&lt;div class=&quot;big-title&quot;&gt;
     $&#123;articleDetail.title&#125;
&lt;/div&gt;
    &lt;div class=&quot;read-counts&quot; v-show=&quot;articleDetail.readCounts != &#39;&#39; &amp;&amp; articleDetail.readCounts != null&quot;&gt;
     阅读量：$&#123;articleDetail.readCounts&#125;
    &lt;/div&gt;
......
&lt;div class=&quot;date-title&quot;&gt;
       &lt;span class=&quot;year&quot;&gt;$&#123;articleDetail.publishTime?string(&#39;yyyy&#39;)&#125;&lt;/span&gt;
 &lt;/div&gt;
      &lt;div class=&quot;back-year-line&quot;&gt;&lt;/div&gt;

      &lt;div class=&quot;date-md&quot;&gt;$&#123;articleDetail.publishTime?string(&#39;MM/dd&#39;)&#125;&lt;/div&gt;

      &lt;div class=&quot;date-times&quot;&gt;$&#123;articleDetail.publishTime?string(&#39;HH:mm:ss&#39;)&#125;&lt;/div&gt;

      &lt;div class=&quot;writer-name&quot; @click=&quot;showWriter(&#39;$&#123;articleDetail.publishUserId&#125;&#39;)&quot;&gt;
                        $&#123;articleDetail.publishUserName&#125;
                    &lt;/div&gt;
.....
&lt;div class=&quot;article-wrapper&quot;&gt;
   &lt;div class=&quot;content&quot;&gt;
        $&#123;articleDetail.content&#125;
   &lt;/div&gt;
&lt;div class=&quot;declare&quot;&gt;
      免责声明：本平台所有内容仅供测试，且文章来自互联网，不代表慕课网的观点和立场，如有不妥，请联系后删除。
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="文章详情ftl生成静态化页面【页面静态化】"><a href="#文章详情ftl生成静态化页面【页面静态化】" class="headerlink" title="文章详情ftl生成静态化页面【页面静态化】"></a>文章详情ftl生成静态化页面【页面静态化】</h3><pre><code class="yaml">freemarker:
  html:
    target: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
    article: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/ArticleDetailVO.java
public class ArticleDetailVO &#123;

    private String id;
    private String title;
    private String cover;
    private Integer categoryId;
    private String categoryName;
    private String publishUserId;
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date publishTime;
    private String content;

    private String publishUserName;
    private Integer readCounts;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
 @Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);
        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
                 createArticleHTML(articleId);
//                String articleMongoId = createArticleHTMLToGridF(articleId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;

    @Value(&quot;$&#123;freemarker.html.target&#125;&quot;)
    private String articlePath;
    @Autowired
    private RestTemplate restTemplate;
    // 文章生成HTML
    public void createArticleHTML(String articleId) throws IOException, TemplateException &#123;
        Configuration cfg = new Configuration(Configuration.getVersion());
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File(classpath + &quot;templates&quot;));

        Template template = cfg.getTemplate(&quot;detail.ftl&quot;, &quot;utf-8&quot;);

        // 获得文章的详情数据
        ArticleDetailVO detailVO = getArticleDetail(articleId);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleDetail&quot;, detailVO);

        File tempDic = new File(articlePath);
        if (!tempDic.exists()) &#123;
            tempDic.mkdirs();
        &#125;

        String path = articlePath + File.separator + detailVO.getId() + &quot;.html&quot;;

        Writer out = new FileWriter(path);
        template.process(map, out);
        out.close();
    &#125;
    // 发起远程调用rest，获得文章详情数据
    public ArticleDetailVO getArticleDetail(String articleId) &#123;
        String url
                = &quot;http://www.imoocnews.com:8001/portal/article/detail?articleId=&quot; + articleId;
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(url, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        ArticleDetailVO detailVO = null;
        if (bodyResult.getStatus() == 200) &#123;
            String detailJson = JsonUtils.objectToJson(bodyResult.getData());
            detailVO = JsonUtils.jsonToPojo(detailJson, ArticleDetailVO.class);
        &#125;
        return detailVO;
    &#125;
</code></pre>
<pre><code class="java">先去发表头条http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html
再去审核通过http://www.imoocnews.com:9090/imooc-news/admin/contentReview.html
此时运行后 就会有java+ftl=html静态页面在指定位置生成了
指定位置：D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\a
生成了一个文件：240729D9S8683XP0.html  这里面就是刚刚发表头条的内容
此时下面的两个网站都可以打开同样的头条内容
http://www.imoocnews.com:9090/imooc-news/portal/a/240729D9S8683XP0.html
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=240729D9S8683XP0

240729D9S8683XP0.html
&lt;div class=&quot;writer-name&quot; @click=&quot;showWriter(&#39;240629F21AK1BHX4&#39;)&quot;&gt;
      P_luminary
&lt;/div&gt;

// 跳转作家页面
showWriter(writerId) &#123;
    window.open(&quot;../writer.html?writerId=&quot; + writerId);
&#125;,
</code></pre>
<p><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/questiondetail/4daeRX4JGBRPnWEp.html">没有getPageName这个函数-慕课网 (imooc.com)</a></p>
<h3 id="文章阅读量detail单独获取并展示-【页面静态化】"><a href="#文章阅读量detail单独获取并展示-【页面静态化】" class="headerlink" title="文章阅读量detail单独获取并展示 【页面静态化】"></a>文章阅读量<del>detail</del>单独获取并展示 【页面静态化】</h3><p><a target="_blank" rel="noopener" href="http://www.imoocnews.com:9090/imooc-news/portal/a/240730FGXGSCRZ54.html">a5 (imoocnews.com)</a></p>
<pre><code class="java">【去前面代入阅读量】
 &lt;div class=&quot;read-counts&quot;&gt;
            阅读量：&#123;&#123;readCounts&#125;&#125;
        &lt;/div&gt;
【先定义readCounts初始量为0】
var articleList = new Vue(&#123;
        el: &quot;#detailContainer&quot;,
        data: &#123;
            nowReplyingFatherCommentId: 0,  // 根据当前用户正在回复的父commentId进行页面的留言看展示或隐藏
            userInfo: null,
            
            articleId: &quot;&quot;,
            articleDetail: &#123;&#125;,
            readCounts: 0,
        &#125;

// 获得文章阅读数
         this.getArticleReadCounts(articleId);

 // 获得文章阅读数
        getArticleReadCounts(articleId) &#123;
               var me = this;

               var articleServerUrl = app.articleServerUrl;
               axios.defaults.withCredentials = true;
               axios.get(articleServerUrl + &quot;/portal/article/readCounts?articleId=&quot; + articleId)
                .then(res =&gt; &#123;
                  // console.log(JSON.stringify(res.data));
                  this.readCounts = res.data;
                &#125;);
            &#125;,
//★★★★★★★★★★★★★★★★★★★★     ★★★★★★★★★★★★★★★★★★★★★★★\\
然后把这个临时页面修改的地方 移动到后端service-article  resources/templates/detail.ftl中
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public Integer readCounts(String articleId) &#123;
       return getCountsFromRedis(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@GetMapping(&quot;readCounts&quot;)
    @ApiOperation(value = &quot;获得文章阅读数&quot;, notes = &quot;获得文章阅读数&quot;, httpMethod = &quot;GET&quot;)
    public Integer readCounts(@RequestParam String articleId);
</code></pre>
<p><a target="_blank" rel="noopener" href="http://www.imoocnews.com:9090/imooc-news/portal/a/240730FP00HHCF14.html">在这里折腾一天终于好了 文章:a6 (imoocnews.com)</a></p>
<p>9-10</p>
<h3 id="梳理生产端消费端与中间gridfs关系"><a href="#梳理生产端消费端与中间gridfs关系" class="headerlink" title="梳理生产端消费端与中间gridfs关系"></a>梳理生产端消费端与中间gridfs关系</h3><h5 id="静态化高度耦合"><a href="#静态化高度耦合" class="headerlink" title="静态化高度耦合"></a>静态化高度耦合</h5><blockquote>
<p>在本地电脑&#x2F;同一台服务器     &#x3D;&gt;     生成静态页面HTML →<del>(发布)</del> 前端</p>
</blockquote>
<h5 id="解耦静态化"><a href="#解耦静态化" class="headerlink" title="解耦静态化"></a>解耦静态化</h5><blockquote>
<p>后端服务器(生成静态页面HTML)  &#x3D;&gt;  GridFS  &lt;&#x3D;  前端服务器(前端HTML)<br>同时  后端服务器(生成静态页面HTML)  →  前端服务器(前端HTML)</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e63aeac9b0694f2fced26f0349e630e42e51ae54/data/%E9%9D%99%E6%80%81%E5%8C%96%E9%AB%98%E5%BA%A6%E8%80%A6%E5%90%88%E4%B8%8E%E8%A7%A3%E8%80%A6.png"></p>
<pre><code class="java">创建一个新的module =&gt; imooc-news-dev-service-article-html
把service-article中resources的application.yml /dev+prod.yml logback-spring.xml拷贝到article-html模块的resources中

############################################################
http://localhost:8002/hello
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: null
&#125;
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# article文章静态化服务
# web访问端口号  约定：8002
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-article-html
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8

  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
  freemarker:
    charset: UTF-8
    content-type: text/html
    suffix: .ftl
    template-loader-path: classpath:/templates/

# 定义freemarker生成的HTML
freemarker:
  html:
    target: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
    article: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
</code></pre>
<pre><code class="yaml">application-dev.yml
server:
  port: 8002

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379

## setup CN from java, This is resource
website:
  domain-name: imoocnews.com




application-prod.yml
server:
  port: 8002

spring:
  redis:
    database: 0
    host: 47.98.225.105
    port: 6379
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/Application.java
package com.imooc.article.html;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/controller/HelloController.java
package com.imooc.article.html.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<h3 id="生产端存储html道gridfs并关联文章表【静态化解耦】"><a href="#生产端存储html道gridfs并关联文章表【静态化解耦】" class="headerlink" title="生产端存储html道gridfs并关联文章表【静态化解耦】"></a>生产端存储html道gridfs并关联文章表【静态化解耦】</h3><h5 id="静态化解耦步骤"><a href="#静态化解耦步骤" class="headerlink" title="静态化解耦步骤"></a>静态化解耦步骤</h5><ul>
<li><strong>生成html，并上传到gridfs中</strong></li>
<li><strong>获得mongoFileId，关联保存到文章表中</strong></li>
<li><strong>调用消费端，下载gridfs的html进行发布</strong></li>
</ul>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
 /**
     * 关联文章和gridfs的html文件id
     */
    public void updateArticleToGridFS(String articleId, String articleMongoId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
 @Transactional
    @Override
    public void updateArticleToGridFS(String articleId, String articleMongoId) &#123;
        Article pendingArticle = new Article();
        pendingArticle.setId(articleId);
        pendingArticle.setMongoFileId(articleMongoId);
        articleMapper.updateByPrimaryKeySelective(pendingArticle);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);

        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
//                 createArticleHTML(articleId);
                String articleMongoId = createArticleHTMLToGridFS(articleId);
                // 存储到对应的文章 进行关联保存
                articleService.updateArticleToGridFS(articleId, articleMongoId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
......
...
    @Value(&quot;$&#123;freemarker.html.target&#125;&quot;)
    private String articlePath;
    @Autowired
    private RestTemplate restTemplate;
    // 文章生成HTML
    public void createArticleHTML(String articleId) throws IOException, TemplateException &#123;
        Configuration cfg = new Configuration(Configuration.getVersion());
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File(classpath + &quot;templates&quot;));

        Template template = cfg.getTemplate(&quot;detail.ftl&quot;, &quot;utf-8&quot;);

        // 获得文章的详情数据
        ArticleDetailVO detailVO = getArticleDetail(articleId);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleDetail&quot;, detailVO);

        File tempDic = new File(articlePath);
        if (!tempDic.exists()) &#123;
            tempDic.mkdirs();
        &#125;

        String path = articlePath + File.separator + detailVO.getId() + &quot;.html&quot;;

        Writer out = new FileWriter(path);
        template.process(map, out);
        out.close();
    &#125;

    @Autowired
    private GridFSBucket gridFSBucket;
    public String createArticleHTMLToGridFS(String articleId) throws IOException, TemplateException &#123;
        Configuration cfg = new Configuration(Configuration.getVersion());
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File(classpath + &quot;templates&quot;));

        Template template = cfg.getTemplate(&quot;detail.ftl&quot;, &quot;utf-8&quot;);

        // 获得文章的详情数据
        ArticleDetailVO detailVO = getArticleDetail(articleId);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleDetail&quot;, detailVO);

        String htmlContent = FreeMarkerTemplateUtils.processTemplateIntoString(template, map);
//        System.out.println(htmlContent);

        InputStream inputStream = IOUtils.toInputStream(htmlContent);
        ObjectId fileId = gridFSBucket.uploadFromStream(detailVO.getId() + &quot;.html&quot;,inputStream);
        return fileId.toString();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/GridFSConfig.java
package com.imooc.article;

import com.mongodb.MongoClient;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.client.gridfs.GridFSBuckets;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

@Component //可以被容器访问到
public class GridFSConfig &#123;
    @Value(&quot;$&#123;spring.data.mongodb.database&#125;&quot;)
    private String mongodb;

    @Bean
    public GridFSBucket gridFSBucket(MongoClient mongoClient)&#123;
        MongoDatabase mongoDatabase = mongoClient.getDatabase(mongodb);
        GridFSBucket bucket = GridFSBuckets.create(mongoDatabase);//存入mongodatabase
        return bucket;
    &#125;
&#125;
</code></pre>
<h3 id="消费端从gridfs下载HTML到tomcat【静态化解耦】"><a href="#消费端从gridfs下载HTML到tomcat【静态化解耦】" class="headerlink" title="消费端从gridfs下载HTML到tomcat【静态化解耦】"></a>消费端从gridfs下载HTML到tomcat【静态化解耦】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticleHTMLControllerApi.java
package com.imooc.api.controller.article;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewArticleBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.Date;

@Api(value = &quot;静态化文章业务的controller&quot;, tags = &#123;&quot;静态化文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article/html&quot;)
public interface ArticleHTMLControllerApi &#123;

    @GetMapping(&quot;download&quot;)
    @ApiOperation(value = &quot;下载html&quot;, notes = &quot;下载html&quot;, httpMethod = &quot;GET&quot;)
    public Integer download(String articleId, String articleMongoId) throws Exception;
&#125;
</code></pre>
<pre><code class="java">article-html  com/imooc/article/html/controller/ArticleHTMLController.java
package com.imooc.article.html.controller;

import com.imooc.api.controller.article.ArticleHTMLControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.gridfs.GridFS;
import org.bson.types.ObjectId;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.RestController;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;

@RestController
public class ArticleHTMLController implements ArticleHTMLControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticleHTMLController.class);

    @Autowired //相应的下载
    private GridFSBucket gridFSBucket;

    @Value(&quot;$&#123;freemarker.html.article&#125;&quot;)
    private String articlePath;

    @Override
    public Integer download(String articleId, String articleMongoId)
            throws Exception &#123;

        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;

        // 获取文件流，定义存放的位置和名称
        File file = new File(path);
        // 创建输出流
        OutputStream outputStream = new FileOutputStream(file);
        // 执行下载
        gridFSBucket.downloadToStream(new ObjectId(articleMongoId), outputStream);

        return HttpStatus.OK.value();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);

        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
//                 createArticleHTML(articleId);
                String articleMongoId = createArticleHTMLToGridFS(articleId);
                // 存储到对应的文章 进行关联保存
                articleService.updateArticleToGridFS(articleId, articleMongoId);
                // 调用消费端，执行下载html
                doDownloadArticleHTML(articleId,articleMongoId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
    private void doDownloadArticleHTML(String articleId, String articleMongoId) &#123;
        String url = //去SwitchHost弄个新的端口映射
                &quot;http://html.imoocnews.com:8002/article/html/download?articleId=&quot;
                        + articleId +
                        &quot;&amp;articleMongoId=&quot;
                        + articleMongoId;
        ResponseEntity&lt;Integer&gt; responseEntity = restTemplate.getForEntity(url, Integer.class);
        int status = responseEntity.getBody();
        if (status != HttpStatus.OK.value()) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
      /**
     * 关联文章和gridfs的html文件id
     */
    public void updateArticleToGridFS(String articleId, String articleMongoId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
    @Transactional
    @Override
    public void updateArticleToGridFS(String articleId, String articleMongoId) &#123;
        Article pendingArticle = new Article();
        pendingArticle.setId(articleId);
        pendingArticle.setMongoFileId(articleMongoId);
        articleMapper.updateByPrimaryKeySelective(pendingArticle);
    &#125;
</code></pre>
<pre><code class="mysql">【SwitchHosts】
# imooc-news 192.168.1.3
127.0.0.1 www.imoocnews.com
127.0.0.1 writer.imoocnews.com
127.0.0.1 admin.imoocnews.com
```
127.0.0.1 article.imoocnews.com
127.0.0.1 user.imoocnews.com
127.0.0.1 files.imoocnews.com
127.0.0.1 html.imoocnews.com

发布文章后审核文章
此时会发现数据库MongoDB里面的GridFS存储桶有新建的html 包括在 前端也存在此文件
D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\a\240731CN3X1M56Y8.html
</code></pre>
<h3 id="撤回删除文章，删除gridfs文件以及html【静态化解耦】"><a href="#撤回删除文章，删除gridfs文件以及html【静态化解耦】" class="headerlink" title="撤回删除文章，删除gridfs文件以及html【静态化解耦】"></a>撤回删除文章，删除gridfs文件以及html【静态化解耦】</h3><blockquote>
<p>拿到mongodb_id  去删除 在service-html 写个删除接口 拼接删除方法</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleHTMLControllerApi.java
@Api(value = &quot;静态化文章业务的controller&quot;, tags = &#123;&quot;静态化文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article/html&quot;)
public interface ArticleHTMLControllerApi &#123;
@GetMapping(&quot;delete&quot;)
    @ApiOperation(value = &quot;删除html&quot;, notes = &quot;删除html&quot;, httpMethod = &quot;GET&quot;)
    public Integer delete(String articleId) throws Exception;
&#125;
</code></pre>
<pre><code class="java">article-html  com/imooc/article/html/controller/ArticleHTMLController.java
@Override
    public Integer delete(String articleId) throws Exception &#123;
        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;
        // 获取文件流，定义存放的位置和名称
        File file = new File(path);
        // 删除文件
        file.delete();
        return HttpStatus.OK.value();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
 @Override
    public GraceJSONResult delete(String userId, String articleId) &#123;
        articleService.deleteArticle(userId,articleId);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult withdraw(String userId, String articleId) &#123;
        articleService.withdrawArticle(userId, articleId);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
@Transactional
    @Override
    public void deleteArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setIsDelete(YesOrNo.YES.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_DELETE_ERROR);
        &#125;
        deleteHTML(articleId);
    &#125;

    @Transactional
    @Override
    public void withdrawArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setArticleStatus(ArticleReviewStatus.WITHDRAW.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_WITHDRAW_ERROR);
        &#125;
        deleteHTML(articleId);
    &#125;
...
...

    @Autowired
    private GridFSBucket gridFSBucket;
    /**
     * 文章撤回删除后，删除静态化的html
     */

    public void deleteHTML(String articleId) &#123;
        // 1. 查询文章的mongoFileId
        Article pending = articleMapper.selectByPrimaryKey(articleId);
        String articleMongoId = pending.getMongoFileId();

        // 2. 删除GridFS上的文件
        gridFSBucket.delete(new ObjectId(articleMongoId));

        // 3. 删除消费端的HTML文件
        doDeleteArticleHTML(articleId);
//        doDeleteArticleHTMLByMQ(articleId);
    &#125;

    @Autowired
    public RestTemplate restTemplate;
    private void doDeleteArticleHTML(String articleId) &#123;
        String url = &quot;http://html.imoocnews.com:8002/article/html/delete?articleId=&quot; + articleId;
        ResponseEntity&lt;Integer&gt; responseEntity = restTemplate.getForEntity(url, Integer.class);
        int status = responseEntity.getBody();
        if (status != HttpStatus.OK.value()) &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125;
    &#125;
</code></pre>
<h3 id="接口解耦需求【章节概述】"><a href="#接口解耦需求【章节概述】" class="headerlink" title="接口解耦需求【章节概述】"></a>接口解耦需求【章节概述】</h3><ul>
<li><strong>介绍RabbitMQ</strong></li>
<li><strong>RabbitMQ术语</strong></li>
<li><strong>安装与配置消息队列</strong></li>
<li><strong>实现接口调用解耦</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d5205be20fc0bac1de7cadbc9b34f6ff949df3d1/data/Rabbitmq.png"></p>
<h3 id="RabbitMQ概述-MQ模型"><a href="#RabbitMQ概述-MQ模型" class="headerlink" title="RabbitMQ概述_MQ模型"></a>RabbitMQ概述_MQ模型</h3><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><ul>
<li><strong>RabbitMQ</strong></li>
<li><strong>ActiveMQ</strong></li>
<li><strong>RocketMQ</strong></li>
<li><strong>Kafka</strong></li>
</ul>
<h5 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul>
<li><strong>erlang语言开发</strong></li>
<li><strong>AMQP</strong></li>
<li><strong>应用之间通信</strong></li>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></li>
</ul>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li><strong>异步任务</strong></li>
<li><strong>提速</strong></li>
<li><strong>接口解耦</strong></li>
<li><strong>削峰</strong></li>
</ul>
<h5 id="RabbitMQ模型"><a href="#RabbitMQ模型" class="headerlink" title="RabbitMQ模型"></a>RabbitMQ模型</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/d83d056479d71444c598865698d340e2ba01da96/data/RabbitMQ%E6%A8%A1%E5%9E%8B.png"></p>
<h3 id="RabbitMQ-3-8-5-安装与配置详细在”多线程与分布式-md“中有"><a href="#RabbitMQ-3-8-5-安装与配置详细在”多线程与分布式-md“中有" class="headerlink" title="RabbitMQ-3.8.5 安装与配置详细在”多线程与分布式.md“中有"></a>RabbitMQ-3.8.5 安装与配置<del>详细在”多线程与分布式.md“中有</del></h3><blockquote>
<p>E:\Java实例项目1-20套\第04套【项目实战】Spring Cloud分布式微服务实战，打造大型自媒体3大业务平台 分布式前后端分离项目分层聚合 养成应对复杂业务的综合技术能力\imooc-news\rabbitmq-server-3.8.5</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://packagecloud.io/rabbitmq/erlang/install#bash-rpm">rabbitmq&#x2F;erlang - Installation · packagecloud- Bash Scripts</a></p>
<pre><code class="mysql">[imooc@imooc ~]$ curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash
[imooc@imooc ~]$ sudo yum install erlang
[imooc@imooc ~]$ erl
Erlang/OTP 23 [erts-11.2.2.10] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:1] [hipe]

Eshell V11.2.2.10  (abort with ^G)
1&gt; 
[imooc@imooc ~]$ yum list | grep erlang
erlang.x86_64                               23.3.4.11-1.el7            @rabbitmq_erlang
erlang-debuginfo.x86_64                     23.3.4.11-1.el7            rabbitmq_erlang
[imooc@imooc ~]$ sudo rpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey
[imooc@imooc ~]$ sudo rpm --import https://packagecloud.io/gpg.key

将资源包里的文件拷贝过来 rabbitmq.conf 和 rabbitmq-server.rpm
#[先把两个依赖搞好 =&gt; 一个是key 一个是依赖]
[imooc@imooc ~]$ sudo rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
[imooc@imooc ~]$ sudo yum install socat
[imooc@imooc ~]$ sudo rpm -ivh rabbitmq-server-3.8.5-1.el7.noarch.rpm
[imooc@imooc ~]$ sudo vim rabbitmq.conf
#&#123;loopback_users, []&#125; 加上注释#
[imooc@imooc ~]$ cd /etc/rabbitmq/
#把conf移动到etc中
[imooc@imooc rabbitmq]$ sudo cp /home/imooc/rabbitmq.conf .
#重新启动rabbitmq
[imooc@imooc rabbitmq]$ sudo systemctl restart rabbitmq-server
#查看状态
[imooc@imooc rabbitmq]$ sudo systemctl status rabbitmq-server

● rabbitmq-server.service - RabbitMQ broker
   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)
   Active: active (running) since 四 2024-08-01 15:45:54 CST; 13s ago
 Main PID: 5843 (beam.smp)
   Status: &quot;Initialized&quot;
    Tasks: 86
   CGroup: /system.slice/rabbitmq-server.service
           ├─5843 /usr/lib64/erlang/erts-11.2.2.10/bin/beam.smp -W w -K true -A 64 -M...
           ├─5952 erl_child_setup 32768
           ├─6008 inet_gethost 4
           └─6009 inet_gethost 4
           
[imooc@imooc rabbitmq]$ sudo rabbitmq-plugins enable rabbitmq_management
[imooc@imooc rabbitmq]$ ll
总用量 40
-rw-r--r--. 1 root rabbitmq    23 8月   1 15:46 enabled_plugins
-rw-r--r--. 1 root rabbitmq 33325 8月   1 15:35 rabbitmq.conf

http://192.168.170.135:15672/
username: guest
password: guest
[imooc@imooc ~]$ sudo vim rabbitmq.conf #把这个取消注释
loopback_users.guest = false

http://192.168.170.135:15672/#/  #创建虚拟host节点
→ admin → Add a user
</code></pre>
<h3 id="引入依赖和配置【集成Rabbitmq】"><a href="#引入依赖和配置【集成Rabbitmq】" class="headerlink" title="引入依赖和配置【集成Rabbitmq】"></a>引入依赖和配置【集成Rabbitmq】</h3><pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<blockquote>
<p>模块 Module<br>imooc-news-dev-service-article 是生产者[发送消息]<br>→<br>imooc-news-dev-service-article-html 是消费者[处理消息]</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://192.168.170.135:15672/#/vhosts">RabbitMQ Management</a> 在Virtual Hosts → Add a new virtual host → Name: imooc-news-dev<br>退出再重新登陆一下rabbitmq → 账号密码：admin</p>
<pre><code class="yaml">service-article  application.yml
  rabbitmq:
    host: 192.168.170.135
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev
</code></pre>
<pre><code class="yaml">service-article-html  application.yml
  rabbitmq:
    host: 192.168.170.135
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev
</code></pre>
<h3 id="创建交换机和队列【集成Rabbitmq】"><a href="#创建交换机和队列【集成Rabbitmq】" class="headerlink" title="创建交换机和队列【集成Rabbitmq】"></a>创建交换机和队列【集成Rabbitmq】</h3><pre><code class="java">service-api  com/imooc/api/config/RabbitMQConfig.java
package com.imooc.api.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * RabbitMQ 的配置类
 */
@Configuration
public class RabbitMQConfig &#123;

    // 定义交换机的名字
    public static final String EXCHANGE_ARTICLE = &quot;exchange_article&quot;;

    // 定义队列的名字
    public static final String QUEUE_DOWNLOAD_HTML = &quot;queue_download_html&quot;;

    // 创建交换机
    @Bean(EXCHANGE_ARTICLE)
    public Exchange exchange()&#123;
        return ExchangeBuilder
                .topicExchange(EXCHANGE_ARTICLE)
                .durable(true)
                .build();
    &#125;

    // 创建队列
    @Bean(QUEUE_DOWNLOAD_HTML)
    public Queue queue()&#123;
        return new Queue(QUEUE_DOWNLOAD_HTML);
    &#125;

    // 队列绑定交换机
    @Bean
    public Binding binding(
            @Qualifier(QUEUE_DOWNLOAD_HTML) Queue queue,
            @Qualifier(EXCHANGE_ARTICLE) Exchange exchange)&#123;
        return BindingBuilder
                .bind(queue)
                .to(exchange)
                //.with(&quot;article.*&quot;) &quot;article.hello&quot;,  //类似于API的规则
                .with(&quot;article.#.do&quot;)
                .noargs();      // 执行绑定
    &#125;
&#125;
</code></pre>
<h3 id="创建生产者-配置路由规则【集成RabbitMQ】"><a href="#创建生产者-配置路由规则【集成RabbitMQ】" class="headerlink" title="创建生产者_配置路由规则【集成RabbitMQ】"></a>创建生产者_配置路由规则【集成RabbitMQ】</h3><p><a target="_blank" rel="noopener" href="http://localhost:8001/producer/hello">localhost:8001&#x2F;producer&#x2F;hello</a></p>
<blockquote>
<p>{<br>“status”: 200,<br>“msg”: “操作成功！”,<br>“success”: true,<br>“data”: null<br>}</p>
</blockquote>
<pre><code class="java">//如果队列规则改变 就需要把Exchanges里的RoutingKey解绑[Unbind] 否则还是会有以前的规则收到消息
//http://192.168.170.135:15672/#/exchanges/imooc-news-dev/exchange_article 
package com.imooc.article.controller;

import com.imooc.api.config.RabbitMQConfig;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController&#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
    /**
     * RabbitMQ的路由规则 routing key
     * display.*.*  →  * 代表一个占位符
     * .with(&quot;article.#.do&quot;)  //类似于API的规则
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done 不匹配
     *
     * display.# → # 代表任意多个占位符
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done.over 匹配
     */

        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.publish.download.do&quot;, //要绑定规则
                &quot;1001~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.success.do&quot;, //要绑定规则
                &quot;1002~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.play&quot;, //要绑定规则
                &quot;1003~&quot;);
        return GraceJSONResult.ok();
    &#125;
&#125;
http://localhost:8001/producer/hello
</code></pre>
<h3 id="消费者接受消息处理业务【集成RabbitMQ】"><a href="#消费者接受消息处理业务【集成RabbitMQ】" class="headerlink" title="消费者接受消息处理业务【集成RabbitMQ】"></a>消费者接受消息处理业务【集成RabbitMQ】</h3><p><a target="_blank" rel="noopener" href="http://192.168.170.135:15672/#/queues/imooc-news-dev/queue_download_html">RabbitMQ Management</a></p>
<blockquote>
<p>如果消息被消费掉后那么就 需要重新请求消息队列生成</p>
</blockquote>
<pre><code class="java">service-article-html  com/imooc/article/html/RabbitMQConsumer.java
package com.imooc.article.html;

import com.imooc.api.config.RabbitMQConfig;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
//打断点后 只要队列有消息 消费者监听到就会被消费
@Component
public class RabbitMQConsumer &#123;
    @RabbitListener(queues = &#123;RabbitMQConfig.QUEUE_DOWNLOAD_HTML&#125;)//监听哪个队列
    public void watchQueue(String payload, Message message)&#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        if (routingKey.equalsIgnoreCase(&quot;article.publish.download.do&quot;)) &#123;
            System.out.println(&quot;article.publish.download.do&quot;);
        &#125; else if (routingKey.equalsIgnoreCase(&quot;article.success.do&quot;)) &#123;
            System.out.println(&quot;article.success.do&quot;);
        &#125; else &#123;
            System.out.println(&quot;不符合的规则：&quot; + routingKey);
        &#125;
    &#125;
&#125;
==================================================================
// 如果消息被消费掉后那么就 需要重新请求消息队列生成
// 此时需要刷新 http://localhost:8001/producer/hello 重新提交一下消息就可以了
Console：
1001~
article.publish.download.do
1002~
article.success.do
1003~
不符合的规则：article.play
</code></pre>
<h3 id="文章静态化HTML与删除【异步解耦】"><a href="#文章静态化HTML与删除【异步解耦】" class="headerlink" title="文章静态化HTML与删除【异步解耦】"></a>文章静态化HTML与删除【异步解耦】</h3><pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
 @Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);

        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
//                 createArticleHTML(articleId);
                String articleMongoId = createArticleHTMLToGridFS(articleId);
                // 存储到对应的文章 进行关联保存
                articleService.updateArticleToGridFS(articleId, articleMongoId);
                // 调用消费端，执行下载html
//                doDownloadArticleHTML(articleId,articleMongoId);
            ★★  // 发送消息到mq队列，让消费者监听并且下载html  ★★
                doDownloadArticleHTMLByMQ(articleId,articleMongoId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
@Autowired
    private RabbitTemplate rabbitTemplate;
    private void doDownloadArticleHTMLByMQ(String articleId, String articleMongoId) &#123;

        rabbitTemplate.convertAndSend(
                RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.download.do&quot;,
                articleId + &quot;,&quot; + articleMongoId);
    &#125;
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/controller/ArticleHTMLComponent.java
package com.imooc.article.html.controller;

import com.mongodb.client.gridfs.GridFSBucket;
import org.bson.types.ObjectId;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;

@Component
public class ArticleHTMLComponent &#123;

    @Autowired
    private GridFSBucket gridFSBucket;

    @Value(&quot;$&#123;freemarker.html.article&#125;&quot;)
    private String articlePath;

    public Integer download(String articleId, String articleMongoId)
            throws Exception &#123;

        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;

        // 获取文件流，定义存放的位置和名称
        File file = new File(path);
        // 创建输出流
        OutputStream outputStream = new FileOutputStream(file);
        // 执行下载
        gridFSBucket.downloadToStream(new ObjectId(articleMongoId), outputStream);

        return HttpStatus.OK.value();
    &#125;

    public Integer delete(String articleId) throws Exception &#123;

        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;

        // 获取文件流，定义存放的位置和名称
        File file = new File(path);

        // 删除文件
        file.delete();

        return HttpStatus.OK.value();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/RabbitMQConsumer.java
package com.imooc.article.html;

import com.imooc.api.config.RabbitMQConfig;
import com.imooc.article.html.controller.ArticleHTMLComponent;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
//打断点后 只要队列有消息 消费者监听到就会被消费
@Component
public class RabbitMQConsumer &#123;
    @Autowired
    private ArticleHTMLComponent articleHTMLComponent;

    @RabbitListener(queues = &#123;RabbitMQConfig.QUEUE_DOWNLOAD_HTML&#125;)//监听哪个队列
    public void watchQueue(String payload, Message message)&#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        if (routingKey.equalsIgnoreCase(&quot;article.publish.download.do&quot;)) &#123;
            System.out.println(&quot;article.publish.download.do&quot;);
        &#125; else if (routingKey.equalsIgnoreCase(&quot;article.success.do&quot;)) &#123;
            System.out.println(&quot;article.success.do&quot;);
        &#125;else if (routingKey.equalsIgnoreCase(&quot;article.download.do&quot;)) &#123;
            String articleId = payload.split(&quot;,&quot;)[0];
            String articleMongoId = payload.split(&quot;,&quot;)[1];
            try &#123;
                articleHTMLComponent.download(articleId, articleMongoId);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

        &#125; else if (routingKey.equalsIgnoreCase(&quot;article.html.download.do&quot;)) &#123;
            String articleId = payload;
            try &#123;
                articleHTMLComponent.delete(articleId);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125; else &#123;
            System.out.println(&quot;不符合的规则：&quot; + routingKey);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">前端的index.html页面也需要修改成静态页面跳转
&lt;a :href=&quot;&#39;./a/&#39;+article.id+&#39;.html&#39;&quot; target=&quot;_blank&quot; class=&quot;link-article-title&quot;&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;
这样再次刷新 就可以让页面不是articleId=?...
http://www.imoocnews.com:9090/imooc-news/portal/a/240801D7S7PM63R4.html
</code></pre>
<h3 id="延迟队列的需求与安装配置【延迟队列】"><a href="#延迟队列的需求与安装配置【延迟队列】" class="headerlink" title="延迟队列的需求与安装配置【延迟队列】"></a>延迟队列的需求与安装配置【延迟队列】</h3><p>把这个<del>rabbitmq_delayed_message_exchange-3.8.0.ez</del>上传到Linux虚拟机</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/be9aa25974ee850399731a79b57f5cd8c4375356/data/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.jpg"></p>
<pre><code class="mysql">[imooc@imooc rabbitmq]$ cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.5/plugins
[imooc@imooc ~]$ sudo mv /home/imooc/rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.5/plugins
[imooc@imooc plugins]$ sudo systemctl restart rabbitmq-server
[imooc@imooc plugins]$ sudo rabbitmq-plugins list
Listing plugins with pattern &quot;.*&quot; ...
 Configured: E = explicitly enabled; e = implicitly enabled
 | Status: * = running on rabbit@imooc
 |/
[  ] rabbitmq_amqp1_0                  3.8.5
[  ] rabbitmq_auth_backend_cache       3.8.5
[  ] rabbitmq_auth_backend_http        3.8.5
[  ] rabbitmq_auth_backend_ldap        3.8.5
[  ] rabbitmq_auth_backend_oauth2      3.8.5
[  ] rabbitmq_auth_mechanism_ssl       3.8.5
[  ] rabbitmq_consistent_hash_exchange 3.8.5
[  ] rabbitmq_delayed_message_exchange 3.8.0
[  ] rabbitmq_event_exchange           3.8.5
[  ] rabbitmq_federation               3.8.5
[  ] rabbitmq_federation_management    3.8.5
[  ] rabbitmq_jms_topic_exchange       3.8.5
[E*] rabbitmq_management               3.8.5
[e*] rabbitmq_management_agent         3.8.5
[  ] rabbitmq_mqtt                     3.8.5
[  ] rabbitmq_peer_discovery_aws       3.8.5
[  ] rabbitmq_peer_discovery_common    3.8.5
[  ] rabbitmq_peer_discovery_consul    3.8.5
[  ] rabbitmq_peer_discovery_etcd      3.8.5
[  ] rabbitmq_peer_discovery_k8s       3.8.5
[  ] rabbitmq_prometheus               3.8.5
[  ] rabbitmq_random_exchange          3.8.5
[  ] rabbitmq_recent_history_exchange  3.8.5
[  ] rabbitmq_sharding                 3.8.5
[  ] rabbitmq_shovel                   3.8.5
[  ] rabbitmq_shovel_management        3.8.5
[  ] rabbitmq_stomp                    3.8.5
[  ] rabbitmq_top                      3.8.5
[  ] rabbitmq_tracing                  3.8.5
[  ] rabbitmq_trust_store              3.8.5
[e*] rabbitmq_web_dispatch             3.8.5
[  ] rabbitmq_web_mqtt                 3.8.5
[  ] rabbitmq_web_mqtt_examples        3.8.5
[  ] rabbitmq_web_stomp                3.8.5
[  ] rabbitmq_web_stomp_examples       3.8.5
[imooc@imooc plugins]$ service rabbitmq-server restart #[重启服务]
Redirecting to /bin/systemctl restart rabbitmq-server.service
</code></pre>
<h3 id="实现延迟队列【延迟队列】"><a href="#实现延迟队列【延迟队列】" class="headerlink" title="实现延迟队列【延迟队列】"></a>实现延迟队列【延迟队列】</h3><pre><code class="java">service-api  com/imooc/api/config/RabbitMQDelayConfig.java
package com.imooc.api.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * RabbitMQ 的配置类
 */
@Configuration
public class RabbitMQDelayConfig &#123;

    // 定义交换机的名字
    public static final String EXCHANGE_DELAY = &quot;exchange_delay&quot;;

    // 定义队列的名字
    public static final String QUEUE_DELAY = &quot;queue_delay&quot;;

    // 创建延迟交换机
    @Bean(EXCHANGE_DELAY)
    public CustomExchange delayExchange() &#123;
        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
        args.put(&quot;x-delayed-type&quot;, &quot;topic&quot;);
        return new CustomExchange(EXCHANGE_DELAY, &quot;x-delayed-message&quot;, true, false, args);
    &#125;

    // 创建队列
    @Bean(QUEUE_DELAY)
    public Queue queue()&#123;
        return new Queue(QUEUE_DELAY);
    &#125;

    // 队列绑定交换机 ↓ binding必须要唯一
    @Bean
    public Binding delayBinding(
            @Qualifier(QUEUE_DELAY) Queue queue,
            @Qualifier(EXCHANGE_DELAY) Exchange exchange)&#123;
        return BindingBuilder
                .bind(queue)
                .to(exchange)
                .with(&quot;delay.#&quot;)
                .noargs();      // 执行绑定
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/RabbitMQDelayConsumer.java
package com.imooc.article;

import com.imooc.api.config.RabbitMQDelayConfig;
import com.imooc.article.service.ArticleService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class RabbitMQDelayConsumer &#123;

    @Autowired
    private ArticleService articleService;

    @RabbitListener(queues = &#123;RabbitMQDelayConfig.QUEUE_DELAY&#125;)
    public void watchQueue(String payload, Message message) &#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        System.out.println(routingKey);

        System.out.println(&quot;消费者接受的延迟消息：&quot; + new Date());

//        // 消费者接收到定时发布的延迟消息，修改当前的文章状态为`即时发布`
//        String articleId = payload;
//        articleService.updateArticleToPublish(articleId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java
package com.imooc.article.controller;

import com.imooc.api.config.RabbitMQConfig;
import com.imooc.api.config.RabbitMQDelayConfig;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.AmqpException;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageDeliveryMode;
import org.springframework.amqp.core.MessagePostProcessor;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController&#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
    /**
     * RabbitMQ的路由规则 routing key
     * display.*.*  →  * 代表一个占位符
     * .with(&quot;article.#.do&quot;)  //类似于API的规则
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done 不匹配
     *
     * display.# → # 代表任意多个占位符
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done.over 匹配
     */

        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.publish.download.do&quot;, //要绑定规则
                &quot;1001~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.success.do&quot;, //要绑定规则
                &quot;1002~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.play&quot;, //要绑定规则
                &quot;1003~&quot;);
        return GraceJSONResult.ok();
    &#125;

    @GetMapping(&quot;/delay&quot;)
    public Object delay() &#123;
        //重写延迟方法  【生产者】
        MessagePostProcessor messagePostProcessor = new MessagePostProcessor() &#123;
            @Override
            public Message postProcessMessage(Message message) throws AmqpException &#123;
                // 设置消息的持久
                message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                // 设置消息延迟的时间 单位ms毫秒
                message.getMessageProperties().setDelay(5000);
                return message;
            &#125;
        &#125;;
        rabbitTemplate.convertAndSend(RabbitMQDelayConfig.EXCHANGE_DELAY,
                &quot;delay.demo&quot;, //要绑定规则
                &quot;这是一条延时消息~&quot;,
                messagePostProcessor);
        System.out.println(&quot;生产者发送的延迟消息：&quot; + new Date());
        return &quot;OK&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">确保 rabbitmq_delayed_message_exchange 插件正确启用：

复制代码
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
sudo systemctl restart rabbitmq-server

======================================================================
http://localhost:8001/producer/delay

生产者发送的延迟消息：Thu Aug 01 20:17:30 CST 2024

这是一条延时消息~
delay.demo
消费者接受的延迟消息：Thu Aug 01 20:17:35 CST 2024
</code></pre>
<h3 id="实现文章的定时延时发布【延迟队列】"><a href="#实现文章的定时延时发布【延迟队列】" class="headerlink" title="实现文章的定时延时发布【延迟队列】"></a>实现文章的定时延时发布【延迟队列】</h3><pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
/**
     * 更新定时发布为即使发布
     
    public void updateAppointToPublish(); **/

    /**
     * 更新单条文章为记时发布
     */
    public void updateArticleToPublish(String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
【32-64行  89-101行】
 @Transactional
    @Override
    public void createArticle(NewArticleBO newArticleBO, Category category) &#123;
        String articleId = sid.nextShort();

        Article article = new Article();
        BeanUtils.copyProperties(newArticleBO, article);

        article.setId(articleId);
        article.setCategoryId(category.getId());
        article.setArticleStatus(ArticleReviewStatus.REVIEWING.type);
        article.setCommentCounts(0);
        article.setReadCounts(0);

        article.setIsDelete(YesOrNo.NO.type);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());

        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;
            article.setPublishTime(newArticleBO.getPublishTime()); //用户可以在前端选择定时发布
        &#125; else if (article.getIsAppoint() == ArticleAppointType.IMMEDIATELY.type) &#123;
            article.setPublishTime(new Date());
        &#125;

        int res = articleMapper.insert(article);
        if (res != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_CREATE_ERROR);
        &#125;

        // 发送延迟消息到mq，计算定时发布时间和当前时间的时间差，则为往后延迟的时间
        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;

            Date endDate = newArticleBO.getPublishTime();
            Date startDate = new Date();

          int delayTimes = (int)(endDate.getTime() - startDate.getTime());

            System.out.println(DateUtil.timeBetween(startDate, endDate));

            // FIXME: 为了测试方便，写死10s
//            int delayTimes = 10 * 1000;

            MessagePostProcessor messagePostProcessor = new MessagePostProcessor() &#123;
                @Override
                public Message postProcessMessage(Message message) throws AmqpException &#123;
                    // 设置消息的持久
                    message.getMessageProperties()
                            .setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                    // 设置消息延迟的时间，单位ms毫秒
                    message.getMessageProperties()
                            .setDelay(delayTimes);
                    return message;
                &#125;
            &#125;;
            rabbitTemplate.convertAndSend(
                    RabbitMQDelayConfig.EXCHANGE_DELAY,
                    &quot;publish.delay.display&quot;,
                    articleId,
                    messagePostProcessor);

            System.out.println(&quot;延迟消息-定时发布文章：&quot; + new Date());
        &#125;


        /**
         * FIXME: 我们只检测正常的词汇，非正常词汇大家课后去检测
         */
        // 通过阿里智能AI实现对文章文本的自动检测（自动审核）
//        String reviewTextResult = aliTextReviewUtils.reviewTextContent(newArticleBO.getContent());
        String reviewTextResult = ArticleReviewLevel.REVIEW.type;

        if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.PASS.type)) &#123;
            // 修改当前的文章，状态标记为审核通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.SUCCESS.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.REVIEW.type)) &#123;
            // 修改当前的文章，状态标记为需要人工审核
            this.updateArticleStatus(articleId, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.BLOCK.type)) &#123;
            // 修改当前的文章，状态标记为审核未通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.FAILED.type);
        &#125;
    &#125;

@Transactional //添加事务[更新操作]
/** @Override
    public void updateAppointToPublish() &#123;
        articleMapperCustom.updateAppointToPublish();
    &#125; **/

    @Override
    public void updateArticleToPublish(String articleId) &#123;
        Article article = new Article();
        article.setId(articleId);
        article.setIsAppoint(ArticleAppointType.IMMEDIATELY.type);
        articleMapper.updateByPrimaryKeySelective(article);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/RabbitMQDelayConsumer.java
package com.imooc.article;

import com.imooc.api.config.RabbitMQDelayConfig;
import com.imooc.article.service.ArticleService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class RabbitMQDelayConsumer &#123;

    @Autowired
    private ArticleService articleService;

    @RabbitListener(queues = &#123;RabbitMQDelayConfig.QUEUE_DELAY&#125;)
    public void watchQueue(String payload, Message message) &#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        System.out.println(routingKey);

        System.out.println(&quot;消费者接受的延迟消息：&quot; + new Date());

        // 消费者接收到定时发布的延迟消息，修改当前的文章状态为`即时发布`
        String articleId = payload;
        articleService.updateArticleToPublish(articleId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/RabbitMQDelayConfig.java //【换一下绑定类型.with(...)】
package com.imooc.api.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * RabbitMQ 的配置类
 */
@Configuration
public class RabbitMQDelayConfig &#123;

    // 定义交换机的名字
    public static final String EXCHANGE_DELAY = &quot;exchange_delay&quot;;

    // 定义队列的名字
    public static final String QUEUE_DELAY = &quot;queue_delay&quot;;

    // 创建延迟交换机
    @Bean(EXCHANGE_DELAY)
    public CustomExchange delayExchange() &#123;
        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
        args.put(&quot;x-delayed-type&quot;, &quot;topic&quot;);
        return new CustomExchange(EXCHANGE_DELAY, &quot;x-delayed-message&quot;, true, false, args);
    &#125;

    // 创建队列
    @Bean(QUEUE_DELAY)
    public Queue queue()&#123;
        return new Queue(QUEUE_DELAY);
    &#125;

    // 队列绑定交换机 ↓ binding必须要唯一
    @Bean
    public Binding delayBinding(
            @Qualifier(QUEUE_DELAY) Queue queue,
            @Qualifier(EXCHANGE_DELAY) Exchange exchange)&#123;
        return BindingBuilder
                .bind(queue)
                .to(exchange)
                .with(&quot;publish.delay.#&quot;)
                .noargs();      // 执行绑定
    &#125;
&#125;
</code></pre>
<pre><code class="java">http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html 发布一篇定时文章
// 在数据库里面是article → is_appoint 是1 然后延迟3天后会变成0
Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15650472]
JDBC Connection [HikariProxyConnection@441638108 wrapping org.mariadb.jdbc.MariaDbConnection@159b2e33] will be managed by Spring
==&gt;  Preparing: INSERT INTO article ( id,title,category_id,article_type,article_cover,is_appoint,article_status,publish_user_id,publish_time,read_counts,comment_counts,mongo_file_id,is_delete,create_time,update_time,content ) VALUES( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? ) 
==&gt; Parameters: 240801FNS7M8G354(String), b10(String), 14(Integer), 2(Integer), (String), 1(Integer), 1(Integer), 240629F21AK1BHX4(String), 2024-08-04 00:00:00.0(Timestamp), 0(Integer), 0(Integer), null, 0(Integer), 2024-08-01 20:36:24.971(Timestamp), 2024-08-01 20:36:24.971(Timestamp), &lt;p&gt;b10&lt;/p&gt;(String)
//★ &lt;==    Updates: 1 ★
Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15650472]
//★ 2天3小时23分钟 ★
//★ 延迟消息-定时发布文章：Thu Aug 01 20:36:24 CST 2024 ★
Fetched SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15650472] from current transaction
==&gt;  Preparing: UPDATE article SET article_status = ? WHERE ( ( id = ? ) ) 
==&gt; Parameters: 2(Integer), 240801FNS7M8G354(String)
&lt;==    Updates: 1
</code></pre>
<h3 id="互联网框架演变【微服务块】"><a href="#互联网框架演变【微服务块】" class="headerlink" title="互联网框架演变【微服务块】"></a>互联网框架演变【微服务块】</h3><ul>
<li><strong>架构演变</strong></li>
<li><strong>微服务入门</strong></li>
<li><strong>SpringCloud各个组件学习</strong></li>
<li><strong>改造项目服务化</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6d9d64a0daa29b87ebdd0c5ca1240264d5b802ed/data/r%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98.png"></p>
<h3 id="注冊中心模型"><a href="#注冊中心模型" class="headerlink" title="注冊中心模型"></a>注冊中心模型</h3><ul>
<li>Eureka</li>
<li>可以把每個服務注入到eureka，更利於管理和維護，使得服務閒通信更方便</li>
</ul>
<blockquote>
<p>Lilei [上户口] → <strong>派出所</strong>  ← [上户口] HanMeimei</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/317410ba901fb06e893bcdd7e2eb05980a9d19d0/data/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png"></p>
<h3 id="构建Eureka注册服务【eureka】"><a href="#构建Eureka注册服务【eureka】" class="headerlink" title="构建Eureka注册服务【eureka】"></a>构建Eureka注册服务【eureka】</h3><pre><code class="java">springcloud-eureka  com/imooc/eureka/Application.java
package com.imooc.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;


@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, MongoAutoConfiguration.class&#125;)
@EnableEurekaServer // 开启注册中心
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;

&#125;
http://localhost:7000/hello  #运行接口
http://localhost:7000         #运行eureka
</code></pre>
<pre><code class="java">springcloud-eureka  com/imooc/eureka/controller/HelloController.java
package com.imooc.eureka.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">springcloud-eureka  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-eureka&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;
            &lt;/dependency&gt;
            &lt;!-- 其他必要的依赖 --&gt;
    &lt;/dependencies&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR12&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">springcloud-eureka  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-admin&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-dev/springcloud-eureka&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/eureka.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="yaml">springcloud-eureka  application.yml
############################################################
#
# eureka 注册中心
# web访问端口号  约定：7000
#
############################################################
server:
  port: 7000
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-eureka

############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:  # eureka 实例的hostname，也可以是自定义配置hostname
    hostname: eureka
  client:  # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<pre><code class="java">http://localhost:7000/
进入了Spring Eureka
Instances currently registered with Eureka
</code></pre>
<h3 id="实现用户与文章的服务注册【eureka】"><a href="#实现用户与文章的服务注册【eureka】" class="headerlink" title="实现用户与文章的服务注册【eureka】"></a>实现用户与文章的服务注册【eureka】</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/longd123/article/details/124440454">关于eureka客户端启动报错UnknownHostException详细解决方法_eureka unknownhostexception-CSDN博客</a> </p>
<pre><code class="mysql"># 问题：
http://eureka:7000/eureka   找不到 eureka 的服务器 IP 地址

在cmd里面
C:\Users\Pluminary&gt;ping eureka
Ping 请求找不到主机 eureka。请检查该名称，然后重试。

# 解答：
从你的描述来看，主机eureka无法解析，这是导致服务无法注册到Eureka Server的原因。你可以通过以下方法解决这个问题：

1. 更新 hosts 文件
在你的开发机器上更新 hosts 文件以手动解析 eureka 主机名。

Windows
打开记事本以管理员身份运行。

打开文件 C:\Windows\System32\drivers\etc\hosts。

添加以下行，将 &lt;eureka服务器的IP地址&gt; 替换为实际的IP地址：

plaintext
复制代码
&lt;eureka服务器的IP地址&gt; eureka
保存并关闭文件。

=================================================================
# imooc-news 192.168.1.3
127.0.0.1 www.imoocnews.com
127.0.0.1 writer.imoocnews.com
127.0.0.1 admin.imoocnews.com
```
127.0.0.1 article.imoocnews.com
127.0.0.1 user.imoocnews.com
127.0.0.1 files.imoocnews.com
127.0.0.1 html.imoocnews.com
</code></pre>
<pre><code class="yaml">springcloud-eureka  resources/application.yml
############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # eureka 实例的hostname，可以是hostname，也可以自定义配置hostname
    hostname: eureka
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<pre><code class="yaml">service-user  resources/application.yml
上面的其余不变 底下添加eureka
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
      defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
</code></pre>
<pre><code class="java">service-user  com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient // 开启eureka client 注册到server中
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">springcloud-eureka  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-eureka&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">springcloud-eureka  com/imooc/user/Application.java
package com.imooc.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;


@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, MongoAutoConfiguration.class&#125;)
@EnableEurekaServer // 开启注册中心
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
====================================================================
// 先启动这个服务 再启动user的服务
随后就能看见http://localhost:7000/
里面有一个注册的服务
/*  
   Instances currently registered with Eureka
   Application    AMIs    Availability Zones    Status
★ SERVICE-USER    n/a (1)    (1)    UP (1) - localhost:service-user:8003 
*/
</code></pre>
<pre><code class="yaml">service-article  resources/application.yml
# 定义freemarker生成的HTML
freemarker:
  html:
    target: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
    article: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
      defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java 
//【此时再去启动这个article服务 会发现SERVICE-ARTICLE也成功的注册到Eureka中】
package com.imooc.article;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
/*
   Application    AMIs    Availability Zones    Status
★ SERVICE-ARTICLE    n/a (1)    (1)    UP (1) - localhost:service-article:8001
★ SERVICE-USER    n/a (1)    (1)    UP (1) - localhost:service-user:8003
*/
</code></pre>
<h3 id="使用AppName优化服务间的通信【eureka】"><a href="#使用AppName优化服务间的通信【eureka】" class="headerlink" title="使用AppName优化服务间的通信【eureka】"></a>使用AppName优化服务间的通信【eureka】</h3><h6 id="实行动态化调用-地址拼接"><a href="#实行动态化调用-地址拼接" class="headerlink" title="实行动态化调用 地址拼接"></a>实行动态化调用 地址拼接</h6><p>AppName是eureka的ApplicationId &#x3D; <strong>SERVICE-USER</strong></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·[文章article]自媒体接口api</a> 如果页面没有信息那就是在<strong>Swagger2.java</strong>中代码的问题<br><a target="_blank" rel="noopener" href="http://localhost:7000/">Eureka</a></p>
<blockquote>
<p>门户端文章业务的controller →  &#x2F;portal&#x2F;article&#x2F;detail  →  articleId&#x3D;2006117B57WRZGHH</p>
</blockquote>
<pre><code class="java">package com.imooc.api.config;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.RequestHandler;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration //Springboot啓動的時候會被掃描到并且加載
@EnableSwagger2
public class Swagger2 &#123;

    //    http://localhost:8088/swagger-ui.html     原路径
    //    http://localhost:8088/doc.html            新路径

    // 配置swagger2核心配置 docket
    @Bean
    public Docket createRestApi() &#123;
        Predicate&lt;RequestHandler&gt; adminPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.admin.controller&quot;);
        Predicate&lt;RequestHandler&gt; articlePredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.article.controller&quot;);
        Predicate&lt;RequestHandler&gt; userPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.user.controller&quot;);
        Predicate&lt;RequestHandler&gt; filesPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.files.controller&quot;);

        return new Docket(DocumentationType.SWAGGER_2)  // 指定api类型为swagger2
                .apiInfo(apiInfo())                 // 用于定义api文档汇总信息
                .select()
//                .apis(Predicates.or(userPredicate, adminPredicate, filesPredicate))
                .apis(Predicates.or(adminPredicate, articlePredicate, userPredicate, filesPredicate))
                .paths(PathSelectors.any())         // 所有controller
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕课新闻·自媒体接口api&quot;)                       // 文档页标题
                .contact(new Contact(&quot;imooc&quot;,
                        &quot;https://www.imooc.com&quot;,
                        &quot;abc@imooc.com&quot;))                   // 联系人信息
                .description(&quot;专为慕课新闻·自媒体平台提供的api文档&quot;)      // 详细信息
                .version(&quot;1.0.1&quot;)                               // 文档版本号
                .termsOfServiceUrl(&quot;https://www.imooc.com&quot;)     // 网站地址
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
// 注入服务发现，可以获得已经注册的服务相关信息
    @Autowired
    private DiscoveryClient discoveryClient;
    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
        String serviceId = &quot;SERVICE-USER&quot;;
        List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(serviceId);
        ServiceInstance userService = instanceList.get(0);
    // 实行动态化调用 地址拼接
        String userServerUrlExecute
                = &quot;http://&quot;+ userService.getHost() + &quot;:&quot; + userService.getPort() + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;
</code></pre>
<h3 id="动态构建eureka集群【eureka】保证高可用"><a href="#动态构建eureka集群【eureka】保证高可用" class="headerlink" title="动态构建eureka集群【eureka】保证高可用"></a>动态构建eureka集群【eureka】<del>保证高可用</del></h3><blockquote>
<p>创建一个新的<strong>module</strong> 其内容和 <strong>springcloud-eureka</strong> 里面的一样</p>
</blockquote>
<pre><code class="mysql">SwitchHosts配置信息
# imooc-news 192.168.1.3
127.0.0.1 www.imoocnews.com
127.0.0.1 writer.imoocnews.com
127.0.0.1 admin.imoocnews.com
```
127.0.0.1 article.imoocnews.com
127.0.0.1 user.imoocnews.com
127.0.0.1 files.imoocnews.com
127.0.0.1 html.imoocnews.com

# SpringCloud
127.0.0.1 eureka
127.0.0.1 eureka-cluster-7001
127.0.0.1 eureka-cluster-7002
127.0.0.1 eureka-cluster-7003
</code></pre>
<pre><code class="yaml">springcloud-eureka-cluster  application.yml
############################################################
#
# eureka 集群的注册中心
# web访问端口号  约定：7001~7003
#
############################################################
server:
  port: 7001
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-eureka-cluster

############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # 集群中每个eureka的名字都是唯一的
    hostname: eureka-cluster-7001
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

####################################################################################
http://localhost:7001/

DS Replicas
eureka-cluster-7003
eureka-cluster-7002
####################################################################################
如果后面服务很多 100个 那是不是也要创建100个module呢？
并不是 因为每个都是一样的只是改一下application.yml的port端口号而已
所以我们要去把它设置为动态的端口
</code></pre>
<h3 id="↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓"><a href="#↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓" class="headerlink" title="↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓"></a><span style = "color:red">↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></h3><pre><code class="yaml">springcloud-eureka-cluster  application.yml【改后】
############################################################
#
# eureka 集群的注册中心
# web访问端口号  约定：7001~7003
#
############################################################
server:
  port: $&#123;7001&#125;
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-eureka-cluster

############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # 集群中每个eureka的名字都是唯一的
    hostname: eureka-cluster-$&#123;server.port&#125;
    # 自定义端口号
  other-node-port2: $&#123;p2:7002&#125;
  other-node-port3: $&#123;p3:7003&#125;
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://eureka-cluster-$&#123;eureka.other-node-port2&#125;:$&#123;eureka.other-node-port2&#125;/eureka/,http://eureka-cluster-$&#123;eureka.other-node-port3&#125;:$&#123;eureka.other-node-port3&#125;/eureka/

####################################################################################
http://eureka-cluster-7001:7001/  #【可运行】
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyl-0110/p/14368753.html">1一站式管理所有SpringBoot启动类，Services服务窗口 - 喵酱张-Eric - 博客园 (cnblogs.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44603382/article/details/121593216">IDEA 2021没有VM options_idea2021怎么找到“vm options”-CSDN博客</a></p>
<blockquote>
<p>复制eureka-cluster-7001服务 变成eureka-cluster-7002 并且在Edit configuration的地方点击Modify options中的Add VM 输入代码：**-DPORT&#x3D;7002 -DP2&#x3D;7001 -DP3&#x3D;7003**<br>同理弄一个eureka-cluster-7003 输入VM代码：**-DPORT&#x3D;7003 -DP2&#x3D;7001 -DP3&#x3D;7002**<br>全部启动后都可以在浏览器正常运行 【集群】<br><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">http://eureka-cluster-7001:7001/</a>  DS Replicas：<a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a> + <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a><br><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/">http://eureka-cluster-7002:7002/</a>  DS Replicas：<a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a> + <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/eureka/">eureka-cluster-7001</a><br><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/">http://eureka-cluster-7003:7003/</a>  DS Replicas：<a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a> + <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/eureka/">eureka-cluster-7001</a><br>如果把里面的application.yml配置注释掉 就可以把自己注册到eureka中<br>client:<br>  <em>#</em> *是否要把当前的<strong>eureka server</strong>注册到自己<br>    *  register-with-eureka: false<br>  <em>#</em> *从注册中心获得检索服务实例，<strong>server</strong>没有必要，直接<strong>false</strong>即可<br>    *  fetch-registry: false<br>之后再重新启动eureka-cluster-7001~7003</p>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">eureka-cluster-7001:7001</a></p>
<h5 id="DS-Replicas"><a href="#DS-Replicas" class="headerlink" title="DS Replicas"></a>DS Replicas</h5><ul>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a></li>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a></li>
</ul>
<h5 id="Instances-currently-registered-with-Eureka"><a href="#Instances-currently-registered-with-Eureka" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h5><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
</blockquote>
<h3 id="微服务注册到eureka集群【eureka】-port-8003"><a href="#微服务注册到eureka集群【eureka】-port-8003" class="headerlink" title="微服务注册到eureka集群【eureka】${port:8003}"></a>微服务注册到eureka集群【eureka】<del>${port:8003}</del></h3><pre><code class="yaml">service-user  application.yml
    # 注册中心的服务地址
    service-url:
  # defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/ 三个节点的注册
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="yaml">service-article  application.yml
    # 注册中心的服务地址
    service-url:
  # defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口:8001_api</a><br>门户端文章业务的controller → get：&#x2F;portal&#x2F;article&#x2F;detail → articleId：2006117B57WRZGHH</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">Eureka:7001</a></p>
<h6 id="DS-Replicas-1"><a href="#DS-Replicas-1" class="headerlink" title="DS Replicas"></a>DS Replicas</h6><ul>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a></li>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a></li>
</ul>
<h6 id="Instances-currently-registered-with-Eureka-1"><a href="#Instances-currently-registered-with-Eureka-1" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE-ARTICLE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8001/actuator/info">localhost:service-article:8001</a></td>
</tr>
<tr>
<td align="left"><strong>SERVICE-USER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8003/actuator/info">localhost:service-user:8003</a></td>
</tr>
<tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
<h3 id="构建微服务集集群【eureka】"><a href="#构建微服务集集群【eureka】" class="headerlink" title="构建微服务集集群【eureka】"></a>构建微服务集集群【eureka】</h3><blockquote>
<p>复制<strong>service-user:8003</strong>服务 变成service-user:8013 并且在Edit configuration的地方点击Modify options中的Add VM 输入代码：**–DPORT&#x3D;8013** </p>
</blockquote>
<pre><code class="yaml">service-user  application-dev.yml
server:
  port: $&#123;port:8003&#125;

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
# open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# setup CN from java, This is resource
website:
  domain-name: imoocnews.com
</code></pre>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">Eureka:7001</a></p>
<h6 id="DS-Replicas-2"><a href="#DS-Replicas-2" class="headerlink" title="DS Replicas"></a>DS Replicas</h6><ul>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a></li>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a></li>
</ul>
<h6 id="Instances-currently-registered-with-Eureka-2"><a href="#Instances-currently-registered-with-Eureka-2" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE-ARTICLE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8001/actuator/info">localhost:service-article:8001</a></td>
</tr>
<tr>
<td align="left"><strong>SERVICE-USER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (2)</td>
<td align="left">(2)</td>
<td align="left"><strong>UP</strong> (2) - <a target="_blank" rel="noopener" href="http://localhost:8003/actuator/info">localhost:service-user:8003</a> , <a target="_blank" rel="noopener" href="http://localhost:8013/actuator/info">localhost:service-user:8013</a></td>
</tr>
<tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
<h3 id="实现轮训负载均衡【eureka】"><a href="#实现轮训负载均衡【eureka】" class="headerlink" title="实现轮训负载均衡【eureka】"></a>实现轮训负载均衡【eureka】</h3><pre><code class="yaml">imooc-news-dev-service-user  application-dev.yml
server:
  port: $&#123;port:8003&#125;

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
# open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# setup CN from java, This is resource
website:
  domain-name: imoocnews.com
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
//每次调用的时候 都会输出其Port
 @Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;

    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
    // 注入服务发现，可以获得已经注册的服务相关信息
    @Autowired
    private DiscoveryClient discoveryClient;
    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
        String serviceId = &quot;SERVICE-USER&quot;;
//        List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(serviceId);
//        ServiceInstance userService = instanceList.get(0);
    // 实行动态化调用 地址拼接
        String userServerUrlExecute
                //因为seviceId里面的SERVICE—USER就存在着userService.getHost()和.getPort()
                = &quot;http://&quot;+ serviceId + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://&quot;+ userService.getHost() + &quot;:&quot; + userService.getPort() + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        // 为restTemplate增加一个负载均衡 @CloudConfig 
                // public RestTemplate restTemplate()
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;
    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced //添加负载均衡
    public RestTemplate restTemplate() &#123;
        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口:8001-api</a><br>门户端文章业务的controller → articleId：2006117B57WRZGHH</p>
</blockquote>
<h3 id="自我保护功能【eureka】"><a href="#自我保护功能【eureka】" class="headerlink" title="自我保护功能【eureka】"></a>自我保护功能【eureka】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/6475d580b535921c2886327b5964ef9fdcad0663/data/Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4.png"></p>
<pre><code class="yaml">springcloud-eureka-cluster  application.yml
############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # 集群中每个eureka的名字都是唯一的
    hostname: eureka-cluster-$&#123;server.port&#125;
    # 自定义端口号
  other-node-port2: $&#123;p2:7002&#125;
  other-node-port3: $&#123;p3:7003&#125;
  client:
    # 是否要把当前的eureka server注册到自己
      # register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
      # fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://eureka-cluster-$&#123;eureka.other-node-port2&#125;:$&#123;eureka.other-node-port2&#125;/eureka/,http://eureka-cluster-$&#123;eureka.other-node-port3&#125;:$&#123;eureka.other-node-port3&#125;/eureka/
  server:
    enable-self-preservation: false # 关闭eureka的自我保护功能
    eviction-interval-timer-in-ms: 5000 # 清理无效节点的时间，可以缩短为5s 默认60s
</code></pre>
<pre><code class="yaml">springcloud-eureka application.yml
############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # eureka 实例的hostname，可以是hostname，也可以自定义配置hostname
    hostname: eureka
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
  server:
    enable-self-preservation: false # 关闭eureka的自我保护功能
    eviction-interval-timer-in-ms: 5000 # 清理无效节点的时间，可以缩短为5s 默认60s
</code></pre>
<pre><code class="yaml">service-user  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/ 三个节点的注册
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="yaml">service-article  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">Eureka:7001</a><br>先把所有服务全启动<br>eureka:7000<br>eureka-cluster-7001<br>eureka-cluster-7002<br>eureka-cluster-7003<br>service-article:8001<br>service-user:8003<br>service-user:8013<br>然后去刷新</p>
<h6 id="Instances-currently-registered-with-Eureka-3"><a href="#Instances-currently-registered-with-Eureka-3" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE-ARTICLE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8001/actuator/info">localhost:service-article:8001</a></td>
</tr>
<tr>
<td align="left"><strong>SERVICE-USER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (2)</td>
<td align="left">(2)</td>
<td align="left"><strong>UP</strong> (2) - <a target="_blank" rel="noopener" href="http://localhost:8003/actuator/info">localhost:service-user:8003</a> , <a target="_blank" rel="noopener" href="http://localhost:8013/actuator/info">localhost:service-user:8013</a></td>
</tr>
<tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
<p>随后只留下eureka-cluster-7001其他全部Stop<br>再次刷新</p>
<h6 id="Instances-currently-registered-with-Eureka-4"><a href="#Instances-currently-registered-with-Eureka-4" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a></td>
</tr>
</tbody></table>
</blockquote>
<h3 id="负载均衡工具"><a href="#负载均衡工具" class="headerlink" title="负载均衡工具"></a>负载均衡工具</h3><ul>
<li><strong>Ribbon</strong>[本地] &#x3D; <strong>RestTemplate</strong> + <strong>@LoadBalanced</strong></li>
<li><strong>服务间通信的负载均衡工具，提供完善的超时重试机制</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a0b97158e7b360bc72b677aad99c5cb41b32d995/data/ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;

    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced //添加负载均衡 默认的负载均衡算法：枚举
    public RestTemplate restTemplate() &#123;

        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<h3 id="实现多种负载均衡算法【ribbon】"><a href="#实现多种负载均衡算法【ribbon】" class="headerlink" title="实现多种负载均衡算法【ribbon】"></a>实现多种负载均衡算法【ribbon】</h3><h6 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h6><p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口api</a></p>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;

    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced //添加负载均衡 默认的负载均衡算法：枚举
    public RestTemplate restTemplate() &#123;

        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/rule/MyRule.java
package com.rule;

import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.RandomRule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 官方定义了规则不要被 @ComponentScan( 扫描到
@Configuration
public class MyRule &#123;
    @Bean
    public IRule iRule()&#123;// 随机的负载均衡策略
        return new RandomRule();
        // 在调用方article的启动类开启注解 @RibbonClient
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h6 id="运用配置文件进行配置"><a href="#运用配置文件进行配置" class="headerlink" title="运用配置文件进行配置"></a>运用配置文件进行配置</h6><blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口api</a> 发送11次请求 <strong>门户端文章业务</strong>→articleId：2006117B57WRZGHH<br>service-user:8003请求到myPort&#x3D;8003 8次<br>service-user:8013请求到myPort&#x3D;8013 3次</p>
</blockquote>
<pre><code class="yaml">service-article  resources/application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5

# 配置指定自定义的ribbon规则
SERVICE-USER:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="重试机制【ribbon】"><a href="#重试机制【ribbon】" class="headerlink" title="重试机制【ribbon】"></a>重试机制【ribbon】</h3><h6 id="节点有可能因为网络问题访问不到-而为了不让其返回错误-需要重试机制"><a href="#节点有可能因为网络问题访问不到-而为了不让其返回错误-需要重试机制" class="headerlink" title="节点有可能因为网络问题访问不到 而为了不让其返回错误 需要重试机制"></a>节点有可能因为网络问题访问不到 而为了不让其返回错误 需要重试机制</h6><pre><code class="xml">sevice-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
            &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">service-article  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5

# 配置指定自定义的ribbon规则
SERVICE-USER:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule


ribbon:
  ConnectTimeout: 5000          # 创建连接的超时时间，单位：ms
  ReadTimeout: 5000             # 在连接创建好以后，调用接口的超时时间，单位：ms
  MaxAutoRetries: 1             # 最大重试次数
  MaxAutoRetriesNextServer: 2   # 切换到下个微服务实例的重试次数
  # 当请求到某个微服务5s，超时后会进行重试，先重试连接自己当前的这个实例
  # 如果当前重试失败1次，则会切换到访问集群中的下一个微服务实例，切换最大为2次

logging:
  level:
#    com.imooc.api.controller.user.UserControllerApi: debug
    root: debug
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口-8001api</a>     articleId：2006117B57WRZGHH<br>先把所有服务全部启动 然后把service-user:8013 的服务Stop<br>再去api接口发送请求 查看servcice-article:8001的Console输出日志<br>14:10.288 [http-nio-8001-exec-1] DEBUG o.s.retry.support.RetryTemplate - Retry: count&#x3D;0<br>14:10.774 [http-nio-8001-exec-1] DEBUG o.s.web.client.RestTemplate - Response 200 OK<br>14:10.288 [http-nio-8001-exec-1] DEBUG o.s.retry.support.RetryTemplate - Retry: count&#x3D;1<br>14:10.288 [http-nio-8001-exec-1] DEBUG o.s.retry.support.RetryTemplate - Retry: count&#x3D;2<br>14:10.774 [http-nio-8001-exec-1] DEBUG o.s.web.client.RestTemplate - Response 200 OK</p>
</blockquote>
<h3 id="简化服务调用【feign】以Api作为接口-面向接口的编程风格"><a href="#简化服务调用【feign】以Api作为接口-面向接口的编程风格" class="headerlink" title="简化服务调用【feign】以Api作为接口,面向接口的编程风格"></a>简化服务调用【feign】<del>以Api作为接口,面向接口的编程风格</del></h3><h5 id="声明式HTTP工具"><a href="#声明式HTTP工具" class="headerlink" title="声明式HTTP工具"></a>声明式HTTP工具</h5><ul>
<li><strong>Feign</strong></li>
<li><strong>声明式的http工具，用于简化服务调用</strong></li>
</ul>
<pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
    // 注入服务发现，可以获得已经注册的服务相关信息
    @Autowired
    private DiscoveryClient discoveryClient;

    @Autowired
    private UserControllerApi userControllerApi;
    //面向接口 UserControllerApi
    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
//        String serviceId = &quot;SERVICE-USER&quot;;
//        List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(serviceId);
//        ServiceInstance userService = instanceList.get(0);
    // 实行动态化调用 地址拼接
//        String userServerUrlExecute
                //因为seviceId里面的SERVICE—USER就存在着userService.getHost()和.getPort()
//                = &quot;http://&quot;+ serviceId + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        GraceJSONResult bodyResult = userControllerApi.queryByIds(JsonUtils.objectToJson(idSet));
//        String userServerUrlExecute
//                = &quot;http://&quot;+ userService.getHost() + &quot;:&quot; + userService.getPort() + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        // 为restTemplate增加一个负载均衡@CloudConfig public RestTemplate restTemplate()
//        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
//                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
//        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java //【EnableFeignClients】
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
@EnableFeignClients(&#123;&quot;com.imooc&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/MyServiceList.java
package com.imooc.api.config;

public class MyServiceList &#123;
    public static final String SERVICE_USER = &quot;service-user&quot;;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/api/controller/user/UserControllerApi.java【@FeignClient】
package com.imooc.api.controller.user;

import com.imooc.api.config.MyServiceList;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
@FeignClient(value = MyServiceList.SERVICE_USER) //作为客户端直接调用
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
                                          @RequestParam BindingResult result); //RequestParam  BindingResult result 加了肯定在前端不可用 对Feign而言不能存在两个对象不然会认为有两个model

    @ApiOperation(value = &quot;根据用户的ids查询用户列表&quot;,notes = &quot;根据用户的ids查询用户列表&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/queryByIds&quot;)
    public GraceJSONResult queryByIds(@RequestParam String userIds);
&#125;
</code></pre>
<h3 id="统一检验处理【feign】"><a href="#统一检验处理【feign】" class="headerlink" title="统一检验处理【feign】"></a>统一检验处理【feign】</h3><blockquote>
<p>把所有的BindingResult都可以采用全局调用的方法去调用<br><a target="_blank" rel="noopener" href="http://localhost:8003/doc.html">慕课新闻·自媒体接口8003api</a> → 用户信息相关 → 修改&#x2F;完善用户信息  Post &#x2F;user&#x2F;updateUserInfo</p>
</blockquote>
<pre><code class="java">dev-common  com/imooc/exception/GraceExceptionHandler.java
package com.imooc.exception;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MaxUploadSizeExceededException;

import javax.naming.Binding;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 统一异常拦截处理
 * 可以针对异常的类型进行捕获 然后返回json信息到前端
 */
@ControllerAdvice
public class GraceExceptionHandler &#123;
 /* @ExceptionHandler(MyCustomException.class)
    //只要是这个类的异常都会进入下面的方法
    @ResponseBody
    public GraceJSONResult returnMyException(MyCustomException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.exception(e.getResponseStatusEnum());
    &#125;

    @ExceptionHandler(MaxUploadSizeExceededException.class)
    @ResponseBody
    public GraceJSONResult returnMaxUploadSizeExceededException(MaxUploadSizeExceededException e) &#123;
        return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_MAX_SIZE_ERROR);
    &#125;*/

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody //该异常是基于所有的vo验证
    public GraceJSONResult returnException(MethodArgumentNotValidException e) &#123;
        BindingResult result = e.getBindingResult();
        Map&lt;String, String&gt; map = getErrors(result);
        return GraceJSONResult.errorMap(map);
    &#125;

    public Map&lt;String, String&gt; getErrors(BindingResult result) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList) &#123;
            // 发送验证错误的时候所对应的某个属性
            String field = error.getField();
            // 验证的错误消息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
//    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
//    @PostMapping(&quot;/updateUserInfo&quot;)
//    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
//                                          @RequestParam BindingResult result);
    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO);
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
    @Override
  public GraceJSONResult updateUserInfo(@Valid UpdateUserInfoBO updateUserInfoBO)&#123;
    //, BindingResult result) &#123;
//        // 0.校验BO
//        if (result.hasErrors())&#123;
//            Map&lt;String, String&gt; map = getErrors(result);
//            return GraceJSONResult.errorMap(map);
//        &#125;
        // 1.执行更新操作
        userService.updateUserInfo(updateUserInfoBO);
        return GraceJSONResult.ok();
        //调用UserService把独有信息传入
    &#125;
</code></pre>
<h3 id="开启日志调式【feign】基于http的调用"><a href="#开启日志调式【feign】基于http的调用" class="headerlink" title="开启日志调式【feign】基于http的调用"></a>开启日志调式【feign】<del>基于http的调用</del></h3><pre><code class="yaml">service-article  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5

# 配置指定自定义的ribbon规则
SERVICE-USER:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule


ribbon:
  ConnectTimeout: 5000          # 创建连接的超时时间，单位：ms
  ReadTimeout: 5000             # 在连接创建好以后，调用接口的超时时间，单位：ms
  MaxAutoRetries: 1             # 最大重试次数
  MaxAutoRetriesNextServer: 2   # 切换到下个微服务实例的重试次数
  # 当请求到某个微服务5s，超时后会进行重试，先重试连接自己当前的这个实例
  # 如果当前重试失败1次，则会切换到访问集群中的下一个微服务实例，切换最大为2次

logging:
  level:
    com.imooc.api.controller.user.UserControllerApi: debug
#    root: debug 日志打印级别

# 配置feign
feign:
  client:
    config:
      # 配置服务提供方的名称
      service-user:
        logger-level: full
</code></pre>
<blockquote>
<p>重启所有服务 调用<a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口8001api</a>门户端→文章详情 articleId：2006117B57WRZGHH<br>09:19.009 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] &lt;— HTTP&#x2F;1.1 200 (590ms)<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] connection: keep-alive<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] content-type: application&#x2F;json<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] date: Mon, 05 Aug 2024 09:09:19 GMT<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] keep-alive: timeout&#x3D;60<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] transfer-encoding: chunked<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] vary: Access-Control-Request-Headers<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] vary: Access-Control-Request-Method<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] vary: Origin<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds]<br>09:19.013 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] {“status”:200,”msg”:”操作成功！”,”success”:true,”data”:[{“id”:”200628AFYM7AGWPH”,”nickname”:”我是慕课网”,”face”:”<a target="_blank" rel="noopener" href="https://imooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/200628AFYM7AGWPH/2007088XH2WT7GXP.png&quot;,&quot;activeStatus&quot;:1,&quot;myFollowCounts&quot;:null,&quot;myFansCounts&quot;:null%7D]%7D">https://imooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/200628AFYM7AGWPH/2007088XH2WT7GXP.png&quot;,&quot;activeStatus&quot;:1,&quot;myFollowCounts&quot;:null,&quot;myFansCounts&quot;:null}]}</a><br>09:19.013 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] &lt;— END HTTP (286-byte body)<br>09:19.518 [PollingServerListUpdater-0] INFO  c.n.config.ChainedDynamicProperty - Flipping property: service-user.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit &#x3D; 2147483647<br>09:21.013 [scheduling-1] INFO  c.imooc.api.aspect.ServiceLogAspect - 开始执行 class com.imooc.article.service.impl.ArticleServiceImpl.updateAppointToPublish </p>
</blockquote>
<h3 id="阐述断路器及概念【hystrix】"><a href="#阐述断路器及概念【hystrix】" class="headerlink" title="阐述断路器及概念【hystrix】"></a>阐述断路器及概念【hystrix】</h3><h6 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h6><ul>
<li><strong>Hystrix</strong></li>
<li><strong>提供容错机制，避免微服务系统雪崩</strong></li>
</ul>
<h6 id="服务熔断与降级"><a href="#服务熔断与降级" class="headerlink" title="服务熔断与降级"></a>服务熔断与降级</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/397bfbaea5edddda83d11dce86c9e70cbac33f5c/data/hystrix%E6%96%AD%E8%B7%AF%E5%99%A8_%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7.png"></p>
<h3 id="模拟服务故障【hystrix】"><a href="#模拟服务故障【hystrix】" class="headerlink" title="模拟服务故障【hystrix】"></a>模拟服务故障【hystrix】</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口8001api</a>  同上<br>会报Timeout超时的异常</p>
</blockquote>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
   @Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;

    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        // 1.手动触发异常
        int a = 1/0;
        // 2.模拟超时异常
        try &#123;
            Thread.sleep(6000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;


        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="服务提供者熔断【hystrix】"><a href="#服务提供者熔断【hystrix】" class="headerlink" title="服务提供者熔断【hystrix】"></a>服务提供者熔断【hystrix】</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;
    // 添加熔断机制 一旦熔断会有替补方法[降级的方法]
    @HystrixCommand(fallbackMethod = &quot;queryByIdsFallback&quot;)
    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        // 1.手动触发异常
        int a = 1/0;
        // 2.模拟超时异常
        try &#123;
            Thread.sleep(6000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;


    public GraceJSONResult queryByIdsFallback(String userIds) &#123;
        System.out.println(&quot;进入降级方法：queryByIdsFallback&quot;);

        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            // 手动构建空对象，详情页所展示的用户信息可有可无 返回空对象
            AppUserVO userVO = new AppUserVO();
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient   // 开启eureka client 注册到server中
@EnableCircuitBreaker // 开启hystrix的熔断机制
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
===============================================================
进入降级方法
</code></pre>
<pre><code class="yaml">service-user  application.yml
#  配置hystrix
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000   # 设置hystrix超时时间，超过2秒触发降级
</code></pre>
<h3 id="全局降级【hystrix】"><a href="#全局降级【hystrix】" class="headerlink" title="全局降级【hystrix】"></a>全局降级【hystrix】</h3><blockquote>
<p>只需要return一个错误就行了没必要100个方法写100个降级<br>{</p>
<p>​    status: 555,<br>​    msg: “”全局降级：系统繁忙，请稍后再试！””<br>​    success: false,<br>​    data: null</p>
<p>}</p>
</blockquote>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)
public class UserController extends BaseController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    // 其他方法一旦发现异常就会进入这个方法里面 全局唯一 其他的降级方法要注释
    public GraceJSONResult defaultFallback()&#123;
        return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_GLOBAL);
    &#125;
......
&#125;
</code></pre>
<pre><code class="java">// 改动是为了不报错空指针异常 因为已经变成了全局降级  降级的错误信息要调整
    @Autowired
    private UserControllerApi userControllerApi;
    //面向接口 UserControllerApi
    // 发起远程调用，获得用户的基本信息
   /* private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
GraceJSONResult bodyResult = userControllerApi.queryByIds(JsonUtils.objectToJson(idSet)); 
List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;*/ else &#123;
            publisherList = new ArrayList&lt;&gt;();
        &#125;
        return publisherList;
    &#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/grace/result/ResponseStatusEnum.java
 // 系统错误，未预期的错误 555
    SYSTEM_ERROR(555, false, &quot;系统繁忙，请稍后再试！&quot;),
    SYSTEM_OPERATION_ERROR(556, false, &quot;操作失败，请重试或联系管理员&quot;),
    SYSTEM_RESPONSE_NO_INFO(557, false, &quot;&quot;),
    SYSTEM_ERROR_GLOBAL(558, false, &quot;全局降级：系统繁忙，请稍后再试！&quot;),
    SYSTEM_ERROR_FEIGN(559, false, &quot;客户端Feign降级：系统繁忙，请稍后再试！&quot;),
    SYSTEM_ERROR_ZUUL(560, false, &quot;请求系统过于繁忙，请稍后再试！&quot;);
</code></pre>
<h3 id="服务调用者降级【hystrix】"><a href="#服务调用者降级【hystrix】" class="headerlink" title="服务调用者降级【hystrix】"></a>服务调用者降级【hystrix】</h3><pre><code class="yaml">service-article  application.yml
# 配置feign
feign:
  client:
    config:
      # 配置服务提供方的名称
      service-user:
        logger-level: full

  hystrix:  #打开feign客户端的内置hystrix
    enabled: true
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java //【增加一个@EnableHystrix】
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
@EnableFeignClients(&#123;&quot;com.imooc&quot;&#125;)
@EnableHystrix
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
====================================================================================
service-article:8001  进入客户端(服务调用者)的降级方法
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java//【@FeignClient增加fallbackFactory】
package com.imooc.api.controller.user;

import com.imooc.api.config.MyServiceList;
import com.imooc.api.controller.user.fallbacks.UserControllerFactoryFallback;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;) //fallbackFactory所有方法的降级
@FeignClient(value = MyServiceList.SERVICE_USER, fallbackFactory = UserControllerFactoryFallback.class ) //作为客户端直接调用
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

//    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
//    @PostMapping(&quot;/updateUserInfo&quot;)
//    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
//                                          @RequestParam BindingResult result);
    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO);


    @ApiOperation(value = &quot;根据用户的ids查询用户列表&quot;,notes = &quot;根据用户的ids查询用户列表&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/queryByIds&quot;)
    public GraceJSONResult queryByIds(@RequestParam String userIds);
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/fallbacks/UserControllerFactoryFallback.java
package com.imooc.api.controller.user.fallbacks;

import com.imooc.api.controller.user.UserControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.pojo.vo.AppUserVO;
import feign.hystrix.FallbackFactory;
import org.springframework.stereotype.Component;

import javax.validation.Valid;
import java.util.ArrayList;
import java.util.List;

@Component //这个类让容器加载
public class UserControllerFactoryFallback implements FallbackFactory&lt;UserControllerApi&gt; &#123;
    @Override
    public UserControllerApi create(Throwable throwable) &#123;
 // 重写的过程就是降级的过程
        return new UserControllerApi() &#123;
            //SYSTEM_ERROR_FEIGN(559, false, &quot;客户端Feign降级：系统繁忙，请稍后再试！&quot;)
            @Override
            public GraceJSONResult getUserInfo(String userId) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_FEIGN);
            &#125;

            @Override
            public GraceJSONResult getAccountInfo(String userId) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_FEIGN);
            &#125;

            @Override
            public GraceJSONResult updateUserInfo(@Valid UpdateUserInfoBO updateUserInfoBO) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_FEIGN);
            &#125;

            @Override
            public GraceJSONResult queryByIds(String userIds) &#123;
                System.out.println(&quot;进入客户端(服务调用者)的降级方法&quot;);
                List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
                return GraceJSONResult.ok(publisherList);
            &#125;
        &#125;;
    &#125;
&#125;
</code></pre>
<h3 id="自动触发熔断隔离与恢复【hystrix】"><a href="#自动触发熔断隔离与恢复【hystrix】" class="headerlink" title="自动触发熔断隔离与恢复【hystrix】"></a>自动触发熔断隔离与恢复【hystrix】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/c67b7337984e7ad3913d8d161ec90de36aba38a8/data/%E7%86%94%E6%96%AD%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<pre><code class="yaml">service-user  application.yml #【配置熔断器】
#  配置hystrix
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000   # 设置hystrix超时时间，超过2秒触发降级
      circuitBreaker:   # 配置断路器
        enabled: true
        requestVolumeThreshold: 10    # 触发熔断最小请求次数，默认：20
        sleepWindowInMilliseconds: 15000    # 熔断后过几秒后尝试半开状态（请求重试），默认：5s
        errorThresholdPercentage: 50  # 触发熔断的失败率（异常率/阈值），默认：50
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java //[FIXME:]
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;
    // 添加熔断机制 一旦熔断会有替补方法[降级的方法]
    @HystrixCommand//(fallbackMethod = &quot;queryByIdsFallback&quot;)
    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        // 1.手动触发异常
        int a = 1/0;
        // 2.模拟超时异常
        try &#123;
            Thread.sleep(6000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;


        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        // FIXME: 仅用于dev测试，硬编码动态判断来抛出异常
        if (userIdList.size() &gt; 1)&#123;
            System.out.println(&quot;出现异常~~&quot;);
            throw new RuntimeException(&quot;出现异常~~&quot;);
        &#125;

        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<h3 id="微服务网关【zuul】维护微服务的ip地址"><a href="#微服务网关【zuul】维护微服务的ip地址" class="headerlink" title="微服务网关【zuul】维护微服务的ip地址"></a>微服务网关【zuul】<del>维护微服务的ip地址</del></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/56aa521f01816d47174142d710bde78e0f31fd7e/data/%E5%BE%AE1%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3.png"></p>
<h5 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h5><ul>
<li>Zuul (祖尔)</li>
<li>微服务的网关，可以实现动态路由、过滤器等功能</li>
</ul>
<h3 id="构建网关微服务【zuul】"><a href="#构建网关微服务【zuul】" class="headerlink" title="构建网关微服务【zuul】"></a>构建网关微服务【zuul】</h3><pre><code class="java">springcloud-zuul-server  com/imooc/zuul/Application.java
@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
//@EnableZuulServer
@EnableZuulProxy      // @EnableZuulProxy是@EnableZuulServer的一个增强升级版，当zuul和eureka、ribbon等组件共同使用，则使用增强版即可
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;

&#125;
</code></pre>
<pre><code class="xml">springcloud-zuul-server  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/springcloud-zuul&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/zuul.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/logger&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">springcloud-zuul-server  pom.xml 【exclusions是重点】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-zuul-server&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除包--&gt;
                &lt;exclusions&gt;
                    &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--&lt;dependency&gt;--&gt;
        &lt;!--&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;
        &lt;!--&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;--&gt;
        &lt;!--&lt;/dependency&gt;--&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yml">springcloud-zuul-server  application.yml 
############################################################
#
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server

  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1
</code></pre>
<pre><code class="java">zuul-server  com/imooc/zuul/controller/HelloController.java
package com.imooc.zuul.controller;

import com.imooc.grace.result.GraceJSONResult;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<h3 id="配置路由【zuul】"><a href="#配置路由【zuul】" class="headerlink" title="配置路由【zuul】"></a>配置路由【zuul】</h3><pre><code class="yaml">zuul-server  application.yml
# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
      path: /service-article/**       # 请求路径(前缀)
      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
</code></pre>
<pre><code class="yaml">localhost:8001/portal/article/detail?articleId=2006117B57WRZGHH
直接可以访问到详情数据
微服务网关→ 7070
// service-article: /service-article/** # 请求路径(前缀**)
# localhost:7070/service-article/portal/detail?articleId=2006117B57WRZGHH

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
      path: /service-article/**       # 请求路径(前缀)
      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀
# localhost:7070/api/service-article/portal/detail?articleId=2006117B57WRZGHH
</code></pre>
<h3 id="配置微服务实例的路由【zuul】"><a href="#配置微服务实例的路由【zuul】" class="headerlink" title="配置微服务实例的路由【zuul】"></a>配置微服务实例的路由【zuul】</h3><pre><code class="yaml">在路由规则里面的  url: http://192.168.1.2:8001  很容易发生变化
所以直接去请求eureka的SERVICE-USER/ARTICLE
</code></pre>
<pre><code class="xml">springcloud-zuul-server  pom.xml 【取消exclusions注释 包含eureka client】
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除包--&gt;
          &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="java">springcloud-zuul-server  com/imooc/zuul/Application.java 【打开@EnableEurekaClient】
@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@EnableZuulServer
@EnableZuulProxy      // @EnableZuulProxy是@EnableZuulServer的一个增强升级版，当zuul和eureka、ribbon等组件共同使用，则使用增强版即可
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">zuul-server  application.yml 【实现service-id进行请求转发 ip发生变化没有关系】
# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
      service-article:                  # 配置微服务的路由id，微服务的实例id
      path: /service-article/**       # 请求路径(前缀)
      service-id: service-article     # 请求转发的微服务实例id
#     url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀

↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 简化版本 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀
</code></pre>
<h3 id="过滤器【zuul】网端ip黑名单拦截"><a href="#过滤器【zuul】网端ip黑名单拦截" class="headerlink" title="过滤器【zuul】网端ip黑名单拦截"></a>过滤器【zuul】<del>网端ip黑名单拦截</del></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/3cb9704aa86555cd937cb6b045ace81a44ec3dbd/data/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84.png"></p>
<pre><code class="java">zuul-server  com/imooc/zuul/filters/MyFilter.java
package com.imooc.zuul.filters;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.stereotype.Component;

/**
 * 构建zuul的自定义过滤器
 */
@Component
public class MyFilter extends ZuulFilter &#123;

    /**
     * 定义过滤器的类型
     *      pre：    在请求被路由之前执行
     *      route：  在路由请求的时候执行
     *      post：   请求路由以后执行
     *      error：  处理请求时发生错误的时候执行
     * @return
     */
    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    /**
     * 过滤器执行的顺序，配置多个有顺序的过滤
     * 执行顺序从小到大
     * @return
     */
    @Override
    public int filterOrder() &#123;
        return 1;
    &#125;

    /**
     * 是否开启过滤器
     *      true：开启
     *      false：禁用
     * @return
     */
    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;

    /**
     * 过滤器的业务实现
     * @return
     * @throws ZuulException
     */
    @Override
    public Object run() throws ZuulException &#123;

        System.out.println(&quot;display pre zuul filter...&quot;);

        return null;    // 没有意义可以不用管。
    &#125;
&#125;
</code></pre>
<blockquote>
<p> localhost:7070&#x2F;api&#x2F;service-article&#x2F;portal&#x2F;detail?articleId&#x3D;2006117B57WRZGHH<br>刷新成功后 在zuul-7070服务console会有一行<br>display pre zuul filter… [启动成功]</p>
</blockquote>
<h3 id="限制ip黑名单的频繁请求【zuul】"><a href="#限制ip黑名单的频繁请求【zuul】" class="headerlink" title="限制ip黑名单的频繁请求【zuul】"></a>限制ip黑名单的频繁请求【zuul】</h3><pre><code class="yaml">zuul-server  application.yml 【增加ip请求限制的参数配置】
# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
      service-article:                  # 配置微服务的路由id，微服务的实例id
      path: /service-article/**       # 请求路径(前缀)
      service-id: service-article     # 请求转发的微服务实例id
#     url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀

↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 简化版本 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀

# ip请求限制的参数配置
blackIp:
  continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
  timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
  limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
</code></pre>
<pre><code class="java">zuul-server  com/imooc/zuul/filters/BlackIPFilter.java
package com.imooc.zuul.filters;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
/* application.yml
*  blackIp:
   continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
   timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
   limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
* */
@Component
@RefreshScope
public class BlackIPFilter extends ZuulFilter &#123;

    @Value(&quot;$&#123;blackIp.continueCounts&#125;&quot;)
    public Integer continueCounts;
    @Value(&quot;$&#123;blackIp.timeInterval&#125;&quot;)
    public Integer timeInterval;
    @Value(&quot;$&#123;blackIp.limitTimes&#125;&quot;)
    public Integer limitTimes;

    @Autowired
    private RedisOperator redis;

    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 2;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;

    @Override
    public Object run() throws ZuulException &#123;

        System.out.println(&quot;执行【ip黑名单】过滤器...&quot;);

        System.out.println(&quot;continueCounts: &quot; + continueCounts);
        System.out.println(&quot;timeInterval: &quot; + timeInterval);
        System.out.println(&quot;limitTimes: &quot; + limitTimes);


        // 获得上下文对象
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();

        // 获得ip
        String ip = IPUtil.getRequestIp(request);

        /**
         * 需求：
         *  判断ip在10秒内的请求次数是否超过10次
         *  如果超过，则限制这个ip访问15秒，15秒以后再放行
         */

        final String ipRedisKey = &quot;zuul-ip:&quot; + ip;
        final String ipRedisLimitKey = &quot;zuul-ip-limit:&quot; + ip;

        // 获得当前ip这个key的剩余时间
        long limitLeftTime = redis.ttl(ipRedisLimitKey);
        // 如果当前限制ip的key还存在剩余时间，说明这个ip不能访问，继续等待
        if (limitLeftTime &gt; 0) &#123;
            stopRequest(context);
            return null;
        &#125;

        // 在redis中累加ip的请求访问次数
        long requestCounts = redis.increment(ipRedisKey, 1);
        // 从0开始计算请求次数，初期访问为1，则设置过期时间，也就是连续请求的间隔时间
        if (requestCounts == 1) &#123;
            redis.expire(ipRedisKey, timeInterval);
        &#125;

        // 如果还能取得请求次数，说明用户连续请求的次数落在10秒内
        // 一旦请求次数超过了连续访问的次数，则需要限制这个ip的访问
        if (requestCounts &gt; continueCounts) &#123;
            // 限制ip的访问时间
            redis.set(ipRedisLimitKey, ipRedisLimitKey, limitTimes);
            stopRequest(context);
        &#125;

        return null;
    &#125;

    private void stopRequest(RequestContext context) &#123;
        // 停止zuul继续向下路由，禁止请求通信
        context.setSendZuulResponse(false);
        context.setResponseStatusCode(200);
        String result = JsonUtils.objectToJson(
                GraceJSONResult.errorCustom(
                        ResponseStatusEnum.SYSTEM_ERROR_ZUUL));
        context.setResponseBody(result);
        context.getResponse().setCharacterEncoding(&quot;utf-8&quot;);
        context.getResponse().setContentType(MediaType.APPLICATION_JSON_VALUE);
    &#125;
&#125;

=============================================================================
dev-common  com/imooc/grace/result/ResponseStatusEnum.java
SYSTEM_ERROR_ZUUL(560, false, &quot;请求系统过于繁忙，请稍后再试！&quot;);
</code></pre>
<pre><code class="yaml">zuul-server  application.yml 【把redis增加进来】
############################################################
#
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server

  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀



# ip请求限制的参数配置
blackIp:
  continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
  timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
  limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
</code></pre>
<blockquote>
<p>此时redis中会出现<br>zuul-ip(1) → zuul-ip  → Value:1<br>zuul-ip-limit(1) → zuul-ip-limit: 本机地址<br>在zuul-7070服务里的Console 显示：<br>display pre zuul filter …<br>执行【ip黑名单】过滤器…</p>
</blockquote>
<h3 id="分布式配置中心【config】"><a href="#分布式配置中心【config】" class="headerlink" title="分布式配置中心【config】"></a>分布式配置中心【config】</h3><ul>
<li><strong>SpringCloud Config</strong></li>
<li><strong>为所有服务提供统一的配置管理服务</strong><del>微服务配置一下子全部生效</del></li>
<li><strong>包含配置服务端与配置客户端</strong></li>
</ul>
<h5 id="配置中心的功能"><a href="#配置中心的功能" class="headerlink" title="配置中心的功能"></a>配置中心的功能</h5><ul>
<li><strong>统一管理配置</strong></li>
<li><strong>管理不同环境下的配置</strong></li>
<li><strong>动态调整配置</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b1fb9d3f444bf78ad6621441538f809d208f8c1a/data/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.png"></p>
<h3 id="搭配配置中心【config】"><a href="#搭配配置中心【config】" class="headerlink" title="搭配配置中心【config】"></a>搭配配置中心【config】</h3><p><a target="_blank" rel="noopener" href="https://github.com/leechenxiang/imooc-news-config/tree/master">leechenxiang&#x2F;imooc-news-config (github.com)</a></p>
<pre><code class="yaml">zuul-dev.yml
blackIp:
  continueCounts: 10
  timeInterval: 10
  limitTimes: 15

zuul-prod.yml
blackIp:
  continueCounts: 40
  timeInterval: 70
  limitTimes: 315
</code></pre>
<pre><code class="xml">springcloud-config  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-config&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">springcloud-config  com/imooc/config/Application.java
package com.imooc.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.config.server.EnableConfigServer;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
==========================================================================
config-7080
</code></pre>
<pre><code class="yaml">springcloud-config  application.yml
############################################################
#
# 配置服务Config
# web访问端口号  约定：7080
#
############################################################
server:
  port: 7080
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-config
  
  rabbitmq:
    host: 192.168.1.204
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/


# 配置动态刷新git配置的路径终端请求地址
management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;
</code></pre>
<pre><code class="xml">springcloud-config  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/springcloud-config&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/config.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">springcloud-config  com/imooc/config/controller/HelloController.java
package com.imooc.config.controller;

import com.imooc.grace.result.GraceJSONResult;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<h3 id="配置中心实现git配置读取【config】"><a href="#配置中心实现git配置读取【config】" class="headerlink" title="配置中心实现git配置读取【config】"></a>配置中心实现git配置读取【config】</h3><pre><code class="xml">springcloud-config  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-config&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yaml">springcloud-config  application.yml
#增加  cloud:config:server:git: uri
############################################################
#
# 配置服务Config
# web访问端口号  约定：7080
#
############################################################
server:
  port: 7080
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-config
  cloud:
    config:
      server:
        git:
          uri: https://github.com/leechenxiang/imooc-news-config.git
  rabbitmq:
    host: 192.168.1.204
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="java">springcloud-config  com/imooc/config/Application.java
package com.imooc.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.config.server.EnableConfigServer;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
@EnableConfigServer //开启这个配置中心
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/leechenxiang/imooc-news-config/tree/master">leechenxiang&#x2F;imooc-news-config (github.com)</a></p>
<blockquote>
<p>localhost:7080&#x2F;zuul-prod.yml    这里直接引用了github上面的yml<br>localhost:7080&#x2F;master&#x2F;zuul-prod.yml   </p>
</blockquote>
<pre><code class="yaml">zuul-dev.yml
blackIp:
  continueCounts: 10
  timeInterval: 10
  limitTimes: 15

zuul-prod.yml
blackIp:
  continueCounts: 40
  timeInterval: 70
  limitTimes: 315
</code></pre>
<h3 id="配置客户端拉取配置"><a href="#配置客户端拉取配置" class="headerlink" title="配置客户端拉取配置"></a>配置客户端拉取配置</h3><pre><code class="xml">zuul-server  pom.xml
         &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server  resources/bootstrap.yml
############################################################
# 系统全局加载文件 先加载这个文件
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server
  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  cloud:
    config:
      label: master # github上的分支
      name: zuul # 定义的服务
      profile: prod  # 所加载的环境变量
#      uri: http://192.168.1.2:7080
      discovery:
        enabled: true
        service-id: springcloud-config


############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/**
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址
  prefix: /api                        # 请求前缀
</code></pre>
<pre><code class="java">启动zuul-7070  //客户端连接config(server)并且动态获得了github的数据
打印控制台Console
display pre zuul filter...
执行【ip黑名单】过滤器...
// zuul-prod.yml
  continueCounts: 40
  timeInterval: 70
  limitTimes: 315
</code></pre>
<h3 id="动态刷新git配置"><a href="#动态刷新git配置" class="headerlink" title="动态刷新git配置"></a>动态刷新git配置</h3><pre><code class="java">// zuul-prod.yml 动态修改数值
  continueCounts: 35
  timeInterval: 305
  limitTimes: 65
在浏览器会显示更新后的数值 但是在console打印台不会显示改后的 只会显示之前的
需要重启服务才可以达到修改后的效果 显示修改的数值
</code></pre>
<pre><code class="xml">zuul-server  pom.xml
添加健康检测的配置
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">zuul-server  com/imooc/zuul/filters/BlackIPFilter.java
//【开启刷新 @RefreshScope 不能全自动 需要触碰某些请求 在yaml配置动态刷新的地址】
package com.imooc.zuul.filters;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
/* application.yml
*  blackIp:
   continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
   timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
   limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
* */
@Component
@RefreshScope
public class BlackIPFilter extends ZuulFilter &#123;

    @Value(&quot;$&#123;blackIp.continueCounts&#125;&quot;)
    public Integer continueCounts;
    @Value(&quot;$&#123;blackIp.timeInterval&#125;&quot;)
    public Integer timeInterval;
    @Value(&quot;$&#123;blackIp.limitTimes&#125;&quot;)
    public Integer limitTimes;

    @Autowired
    private RedisOperator redis;

    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 2;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">zuul-server  bootstrap.yml  +  springcloud-config  application.yaml
# 配置动态刷新git配置的路径终端请求地址 只需要通过URL请求不用重启就可以自动刷新 后期要通过脚本运行才可【通过请求处理 postman → POST → https://localhost:7070/actuator/refresh】
management:
  endpoints:
    web:
      exposure:
        include: refresh
# 此时回到console就可以有更新后的数据显示了
</code></pre>
<h3 id="消息总线概述【bus】-RabbitMQ"><a href="#消息总线概述【bus】-RabbitMQ" class="headerlink" title="消息总线概述【bus】[RabbitMQ]"></a>消息总线概述【bus】<del>[RabbitMQ]</del></h3><h5 id="Config遗留问题"><a href="#Config遗留问题" class="headerlink" title="Config遗留问题"></a>Config遗留问题</h5><ul>
<li><strong>手动刷新与业务耦合</strong> [也可能在文章&#x2F;user模块发生]</li>
<li>Config配置中心的刷新去解决动态刷新</li>
<li><strong>N个微服务端需要N次手动书信</strong></li>
</ul>
<h5 id="消息总线-要和config与微服务端进行配置"><a href="#消息总线-要和config与微服务端进行配置" class="headerlink" title="消息总线(要和config与微服务端进行配置)"></a>消息总线<del>(要和config与微服务端进行配置)</del></h5><ul>
<li><strong>SpringCloud Bus</strong></li>
<li>为SpringCloud Config提供增益buff</li>
<li><strong>可以实现配置自动刷新</strong>[1k个 1w个]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5fc0f342c2ab14a5e7e3aa9869b97348c7ed39ed/data/%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0.jpg"></p>
<h3 id="配置实现消息统一发送【bus】"><a href="#配置实现消息统一发送【bus】" class="headerlink" title="配置实现消息统一发送【bus】"></a>配置实现消息统一发送【bus】</h3><blockquote>
<p>config把消息推給zull-server</p>
</blockquote>
<pre><code class="xml">springcloud-config  pom.xml    ＋    zuul-server  pom.xml
    &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server  resources/bootstrap.yaml  +  springcloud-config  application.yaml
  rabbitmq:
    host: 192.168.1.204
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev
</code></pre>
<blockquote>
<p>实现刷新server端达到所有的刷新配置<br>【通过请求处理 postman → POST → <a target="_blank" rel="noopener" href="https://localhost:7080/actuator/bus-refresh%E3%80%91">https://localhost:7080/actuator/bus-refresh】</a><br>若想精确刷新某个服务 需要拼接<br> postman → POST → <a target="_blank" rel="noopener" href="https://localhost:7080/actuator/bus-refresh/%7B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E4%BE%8Bid%7D:%7Bport%7D">https://localhost:7080/actuator/bus-refresh/{微服务的实例id}:{port}</a><br>微服务实例id是yaml配置项目信息 → spring.application.name：springcloud-zuul-server<br><a target="_blank" rel="noopener" href="https://localhost:7080/actuator/bus-refresh/springcloud-zuul-server:7070">https://localhost:7080/actuator/bus-refresh/springcloud-zuul-server:7070</a> 【目标微服务地址实现精确打击】</p>
</blockquote>
<h3 id="消息驱动概述【stream】"><a href="#消息驱动概述【stream】" class="headerlink" title="消息驱动概述【stream】"></a>消息驱动概述【stream】</h3><h5 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h5><ul>
<li><strong>SpringCloud Stream</strong></li>
<li><strong><span style = "color:red">统一封装消息的服务框架</span></strong></li>
<li>RabbitMQ，RocketMQ，Kafka，ActiveMQ，ZeroMQ，…</li>
</ul>
<h5 id="Stream消息模型"><a href="#Stream消息模型" class="headerlink" title="Stream消息模型"></a>Stream消息模型</h5><img src="https://raw.githubusercontent.com/P-luminary/images/995964c627f628ee94ebb76bbbe6fe7872884f32/data/Stream%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B.png" style="zoom:80%;" />



<h3 id="实现消费者与生产者【stream】"><a href="#实现消费者与生产者【stream】" class="headerlink" title="实现消费者与生产者【stream】"></a>实现消费者与生产者【stream】</h3><blockquote>
<p>将zuul-server的resources&#x2F;application.yml 恢复到原来配置</p>
</blockquote>
<pre><code class="yaml">############################################################
#
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server

  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀



# ip请求限制的参数配置
blackIp:
  continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
  timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
  limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
</code></pre>
<pre><code class="xml">service-article  pom.xml  +  service-user  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
            &lt;version&gt;4.1.1&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">service-article  application.yaml      +      service-user  application.yaml
    cloud:
    stream:
      bindings:                    # 绑定通道和交换机
        myOutput:                   # 定义生产者的通道
          # 自定义交换机的名字，也就是代码里构建的信息，交给底层mq的交换机
          destination:
        myInput:                    # 定义消费者通道
          # 自定义交换机的名字，也就是消息从底层mq输入到消费端进行消费
          destination:
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamChannel.java
package com.imooc.article.stream;

import org.springframework.cloud.stream.annotation.Input;
import org.springframework.cloud.stream.annotation.Output;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.stereotype.Component;

/**
 * 声明构建通道channel
 */
@Component
public interface MyStreamChannel &#123;

    String OUTPUT = &quot;myOutput&quot;;
    String INPUT = &quot;myInput&quot;;

    @Output(MyStreamChannel.OUTPUT)
    MessageChannel output();

    @Input(MyStreamChannel.INPUT)
    SubscribableChannel input();  //订阅能力的通道
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamChannel.java
package com.imooc.article.stream;


import org.springframework.cloud.stream.annotation.Input;
import org.springframework.cloud.stream.annotation.Output;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.stereotype.Component;

/**
 * 声明构建通道channel
 */
@Component
public interface MyStreamChannel &#123;
    String OUTPUT = &quot;myOutput&quot;;
    String INPUT = &quot;myInput&quot;;

    @Output(MyStreamChannel.OUTPUT)
    MessageChannel output();

    @Input(MyStreamChannel.INPUT)
    SubscribableChannel input();
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamService.java
package com.imooc.article.stream;

public interface StreamService &#123;
    public void sendMsg();
    public void eat(String dumpling);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamServiceImpl.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

/**
 * 开启绑定器
 * 绑定通道channel
 */
@Component
@EnableBinding(MyStreamChannel.class)
public class StreamServiceImpl implements StreamService &#123;

    @Autowired
    private MyStreamChannel myStreamChannel;

    @Override
    public void sendMsg() &#123;
        AppUser user = new AppUser();
        user.setId(&quot;10101&quot;);
        user.setNickname(&quot;imooc&quot;);

        // 消息通过绑定器发送给mq
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(user).build());
    &#125;

    @Override
    public void eat(String dumpling) &#123;
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(dumpling).build());
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamConsumer.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.stereotype.Component;

/**
 * 构建消费端
 */
@Component
@EnableBinding(MyStreamChannel.class) //开启通道绑定
public class MyStreamConsumer &#123;

    /**
     * 监听并且实现消息的消费和相关业务处理
     */
    @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(AppUser user) &#123;
        System.out.println(user.toString());
    &#125;

    @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(String dumpling) &#123;
        System.out.println(dumpling);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private StreamService streamService;

    @GetMapping(&quot;/stream&quot;)
    public Object stream() &#123;
        streamService.sendMsg();

        for (int i = 0 ; i &lt; 10 ; i ++ ) &#123;
            streamService.eat(&quot;我吃了第&quot; + (i+1) + &quot;只饺子~&quot;);
        &#125;

        return &quot;ok~~!!!&quot;;
    &#125;
</code></pre>
<h3 id="消息分组与持久化【stream】"><a href="#消息分组与持久化【stream】" class="headerlink" title="消息分组与持久化【stream】"></a>消息分组与持久化【stream】</h3><blockquote>
<p>避免重复消费  分组group 组内消费者不会重复消费</p>
</blockquote>
<h5 id="Stream消息分组"><a href="#Stream消息分组" class="headerlink" title="Stream消息分组"></a>Stream消息分组</h5><pre><code class="yaml">service-article  application.yml  
  cloud:
    stream:
      bindings:                    # 绑定通道和交换机
        myOutput:                   # 定义生产者的通道
          # 自定义交换机的名字，也就是代码里构建的信息，交给底层mq的交换机
          destination:
        myInput:                    # 定义消费者通道
          # 自定义交换机的名字，也就是消息从底层mq输入到消费端进行消费
          destination:
          group: boys

------------------------------------------------------------------------------

service-user  application.yml
  cloud:
    stream:
      bindings: # 绑定通道和交换机
        myOutput: # 定义生产者的通道
          # 自定义交换机的名字，也就是代码里构建的信息，交给底层mq的交换机
          destination:
        myInput: # 定义消费者通道
          # 自定义交换机的名字，也就是消息从底层mq输入到消费端进行消费
          destination:
          group: girls
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamService.java
package com.imooc.article.stream;

public interface StreamService &#123;
  //public void sendMsg();
    public void eat(String dumpling);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamServiceImpl.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

/**
 * 开启绑定器
 * 绑定通道channel
 */
@Component
@EnableBinding(MyStreamChannel.class)
public class StreamServiceImpl implements StreamService &#123;

    @Autowired
    private MyStreamChannel myStreamChannel;

    @Override
 /* public void sendMsg() &#123;
        AppUser user = new AppUser();
        user.setId(&quot;10101&quot;);
        user.setNickname(&quot;imooc&quot;);

        // 消息通过绑定器发送给mq
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(user).build());
    &#125; */

    @Override
    public void eat(String dumpling) &#123;
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(dumpling).build());
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamConsumer.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.stereotype.Component;

/**
 * 构建消费端
 */
@Component
@EnableBinding(MyStreamChannel.class) //开启通道绑定
public class MyStreamConsumer &#123;

    /**
     * 监听并且实现消息的消费和相关业务处理
     */
 /* @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(AppUser user) &#123;
        System.out.println(user.toString());
    &#125; */

    @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(String dumpling) &#123;
        System.out.println(dumpling);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private StreamService streamService;

    @GetMapping(&quot;/stream&quot;)
    public Object stream() &#123;
     // streamService.sendMsg();

        for (int i = 0 ; i &lt; 10 ; i ++ ) &#123;
            streamService.eat(&quot;我吃了第&quot; + (i+1) + &quot;只饺子~&quot;);
        &#125;

        return &quot;ok~~!!!&quot;;
    &#125;
</code></pre>
<blockquote>
<p>消息不会被重复消费<br>service-article:8001   我吃了1-10只饺子~  【消费的饺子总数一共10次】<br>service-user:8003(女生) 我吃了1 3 5 7 9只饺子~    【饺子随机】<br>service-user:8013(男生) 我吃了2 4 6 8 10只饺子~  【饺子随机】</p>
<p>如果把service-user:8003(女生)  service-user:8013(男生) 服务stop 用户微服务无法接收任何消息<br>但是我们定义了group → 消息是可以持久化的 当重启用户微服务之后  就会打印出刚刚已经吃的饺子了<br>服务器宕机  &#x3D;  吃饺子中途去上厕所 回来后仍然还能吃到饺子</p>
</blockquote>
<h3 id="链路追踪概述与zipkin【sleuth】组件"><a href="#链路追踪概述与zipkin【sleuth】组件" class="headerlink" title="链路追踪概述与zipkin【sleuth】组件"></a>链路追踪概述与zipkin【sleuth】<del>组件</del></h3><h5 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h5><ul>
<li><strong>Sleuth</strong></li>
<li><strong>贯穿整个微服务系统中，追踪一个请求的过程</strong></li>
<li><strong>zipkin 可视化控制面板</strong></li>
</ul>
<blockquote>
<p>下载zipkin-server-2.12.6-exec.jar<br>CMD → C:\Users\Pluminary&gt;java -jar &#x2F;Users&#x2F;Pluminary&#x2F;Desktop&#x2F;zipkin-server-2.12.6-exec.jar<br><a target="_blank" rel="noopener" href="https://localhost:9411/zipkin/">https://localhost:9411/zipkin/</a></p>
</blockquote>
<h3 id="整合zipkin【sleuth】项目入口是网关"><a href="#整合zipkin【sleuth】项目入口是网关" class="headerlink" title="整合zipkin【sleuth】项目入口是网关"></a>整合zipkin【sleuth】<del>项目入口是网关</del></h3><pre><code class="xml">zuul-server  pom.xml  +  service-article  pom.xml  +  service-user  pom.xml
         &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server与service-article与service-user  application.yml
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://localhost:9411/zipkin/">https://localhost:9411/zipkin/</a></p>
</blockquote>
<h3 id="SpringCloud章节总结"><a href="#SpringCloud章节总结" class="headerlink" title="SpringCloud章节总结"></a>SpringCloud章节总结</h3><ul>
<li><strong>eureka 注册中心</strong></li>
<li><strong>ribbon 负载均衡</strong></li>
<li><strong>feign 声明式客户端</strong></li>
<li><strong>hystrix 熔断降级组件</strong></li>
<li><strong>zuul 网关</strong></li>
<li><strong>config 配置中心</strong></li>
<li><strong>bus 消息总线</strong></li>
<li><strong>stream 消息驱动</strong></li>
<li><strong>zipkin + sleuth 链路追踪</strong></li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/05/12/后端/Cloud分布式微服务打造大型自媒体3大业务平台/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/05/04/后端/Zookeeper-Dubbo应用与面试/">
        <h2>
            Zookeeper+Dubbo应用与面试
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/5/4
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Zookeeper-Dubbo与面试周介绍"><a href="#Zookeeper-Dubbo与面试周介绍" class="headerlink" title="Zookeeper+Dubbo与面试周介绍"></a>Zookeeper+Dubbo与面试周介绍</h1><ul>
<li>Zookeeper的下载、配置与运行</li>
<li>数据结构node与常用命令</li>
<li>Watcher机制和权限cal介绍</li>
<li>使用Zookeeper的Java原生客户端和Curator进行开发</li>
<li>RPC调用，在Dubbo架构下各服务的关系</li>
<li>整合Dubbo和Zookeeper</li>
<li>完成Dubbo开发案例</li>
<li>线程进阶面试</li>
<li>分布式、微服务面试题</li>
<li>Spring Cloud、Zookeeper的理解</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li>理解Zookeeper</li>
<li>安装、配置</li>
<li>节点znode</li>
<li>常用命令</li>
<li>Watcher机制</li>
<li>ACL权限控制</li>
<li>代码实操</li>
</ul>
<h3 id="理解Zookeeper"><a href="#理解Zookeeper" class="headerlink" title="理解Zookeeper"></a>理解Zookeeper</h3><ul>
<li>5大特点</li>
<li>集群架构</li>
<li>Zookeeper和CAP关系</li>
<li>Zookeeper作用</li>
</ul>
<h3 id="为什么需要Zookeeper"><a href="#为什么需要Zookeeper" class="headerlink" title="为什么需要Zookeeper"></a>为什么需要Zookeeper</h3><ul>
<li><p>用起来像<strong>单机</strong>但是又比单机更<strong>可靠</strong></p>
</li>
<li><p>leader在团队里的<strong>协调</strong>作用  </p>
</li>
<li><p>内存、单机 </p>
</li>
<li><p>集群、<strong>可靠</strong></p>
</li>
<li><p>当信息<strong>还没同步完成时，不对外提供服务</strong></p>
</li>
<li><p>同步的时间压缩的更短</p>
</li>
</ul>
<h3 id="Zookeeper诞生历史"><a href="#Zookeeper诞生历史" class="headerlink" title="Zookeeper诞生历史"></a>Zookeeper诞生历史</h3><p>雅虎研究室</p>
<ul>
<li>无单点问题的<strong>分布式协调架构</strong>，精力集中在处理业务逻辑</li>
<li>内部很多项目都是使用动物的名字来命名</li>
<li>大型动物园</li>
</ul>
<h3 id="Zookeeper是什么-底层是Java"><a href="#Zookeeper是什么-底层是Java" class="headerlink" title="Zookeeper是什么 [底层是Java]"></a>Zookeeper是什么 [底层是Java]</h3><ul>
<li>Zookeeper是<strong>开源的高性能的分布式应用协调系统</strong>，一个高性能的分布式数据一致性解决方案</li>
</ul>
<h3 id="5大特点"><a href="#5大特点" class="headerlink" title="5大特点"></a>5大特点</h3><ul>
<li>顺序一致性</li>
<li>原子性 [全部成功或者全部不成功]</li>
<li>单一视图 [无论连接哪个 都是一致的信息]</li>
<li>可靠性</li>
<li>及时性 [一定时间内能从服务器读到状态]</li>
</ul>
<h5 id="架构图、集群、工作过程"><a href="#架构图、集群、工作过程" class="headerlink" title="架构图、集群、工作过程"></a>架构图、集群、工作过程</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/b25f2311da13cf23726ffd71545a05cdc2630f95/data/zookeeper%E6%9E%B6%E6%9E%84%E5%9B%BE%E3%80%81%E9%9B%86%E7%BE%A4%E3%80%81%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.jpg"></p>
<h3 id="Zookeeper和CAP的关系"><a href="#Zookeeper和CAP的关系" class="headerlink" title="Zookeeper和CAP的关系"></a>Zookeeper和CAP的关系</h3><ul>
<li>CP：一致性+分区容错性</li>
<li>能<strong>得到一致的数据结果</strong>，同时系统对网络具备容错性</li>
<li>但是它不能保证每次服务请求的可用性</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>分布式服务注册与订阅</li>
<li>统一配置文件</li>
<li>生成分布式唯一ID [&#x2F;order-0000001、&#x2F;order-0000002]</li>
<li>Master节点选举</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/96130bcb29ba40dee3d21543e5d7b46f33ad9920/data/Zookeeper%E7%89%B9%E7%82%B9.jpg"></p>
<h5 id="针对不能同时进行写数据，保证互斥同步-→-分布式锁"><a href="#针对不能同时进行写数据，保证互斥同步-→-分布式锁" class="headerlink" title="针对不能同时进行写数据，保证互斥同步 → 分布式锁"></a>针对不能同时进行写数据，保证互斥同步 → 分布式锁</h5><h3 id="Zookeeper的安装、配置"><a href="#Zookeeper的安装、配置" class="headerlink" title="Zookeeper的安装、配置"></a>Zookeeper的安装、配置</h3><ul>
<li>寻找教辅里的<code>apache-zookeeper-3.6.0-bin.tar</code></li>
<li>解压压缩包：<code>tar zxvf apache-zookeeper-3.6.0-bin.tar.gz</code></li>
<li>进入压缩包：<code>cd apache-zookeeper-3.6.0-bin</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ls
bin  conf  docs  lib  LICENSE.txt  NOTICE.txt  README.md README_packaging.md
</code></pre>
<ul>
<li>配置[进入文件]：<code>cp conf/zoo_sample.cfg conf/zoo</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# cp conf/zoo_sample.cfg conf/zoo
[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ls conf/
configuration.xsl  log4j.properties  zoo  zoo.cfg  zoo_sample.cfg
</code></pre>
<ul>
<li>打开文件, 进行修改：<code>vi conf/zoo.cfg</code></li>
</ul>
<pre><code class="java">找到 dataDir=/tmp/zookeeper
修改成 dataDir=/tmp/lib/zookeeper 以免被自动清除
</code></pre>
<ul>
<li>启动：<code>./bin/zkServer.sh start</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... already running as process 1877.
======================================================================
[root@iZbp1dssknxftmjczbtpndZ bin]# ./zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... ^[[ASTARTED
[root@iZbp1dssknxftmjczbtpndZ bin]# ./zkServer.sh status
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Client port found: 2181. Client address: localhost.
Mode: standalone
======================================================================
</code></pre>
<ul>
<li>停止：<code>./bin/zkServer.sh stop</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh stop
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Stopping zookeeper ... STOPPED
</code></pre>
<h3 id="znode节点-基本数据模型"><a href="#znode节点-基本数据模型" class="headerlink" title="znode节点 [基本数据模型]"></a>znode节点 [基本数据模型]</h3><ul>
<li><h5 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h5></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/15f1b158dfd61ad9498e5febc8d809e4dcb7f0af/data/Znode%E8%8A%82-%20%E6%A0%91%E5%BD%A2%E5%9B%BE.jpg"></p>
<h5 id="节点性质"><a href="#节点性质" class="headerlink" title="节点性质"></a>节点性质</h5><ul>
<li>树形结构，也可以理解为linux的文件目录</li>
<li>每一个节点都是znode，里面可以包含<strong>数据</strong>，也可以有<strong>子节点</strong></li>
<li>点分为<strong>永久节点</strong>和<strong>临时节点</strong>(与客户端绑定) [session失效，也就是客户端断开过，临时节点消失]</li>
<li>每个znode都有<strong>版本号</strong>，每当数据变化，版本号都会累加(<strong>乐观锁</strong>)</li>
<li>删除或修改节点，版本号不匹配的话(版本号已超时), 会报错)</li>
<li>每个节点存储的<strong>数据不宜过大</strong>，几k即可 [保存路径再去查询]</li>
<li>节点可以设置<strong>权限</strong>，来限制用户的访问</li>
<li>Zookeeper保证读和写都是<strong>原子操作</strong>，且每次读写操作都是对数据的完整读取或完整写入</li>
</ul>
<h5 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h5><ul>
<li><strong>持久</strong>节点</li>
<li><strong>临时</strong>节点</li>
<li><strong>顺序</strong>节点</li>
</ul>
<h5 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h5><ul>
<li>dataVersion</li>
<li>cversion [child]</li>
<li>aclVersion [权限]</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><span style = "color:blue">常用命令</span></h2><ul>
<li><p>启动：<code>./bin/zkServer.sh start</code></p>
</li>
<li><p>连接到Zookeeper</p>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... STARTED

[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkCli.sh -server 127.0.0.1:2181
</code></pre>
</li>
<li><p><span style = "color:red"><strong>查看节点</strong></span></p>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 3] ls 
ls [-s] [-w] [-R] path
[zk: 127.0.0.1:2181(CONNECTED) 4] ls /
[zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 5] ls /zookeeper
[config, quota]
[zk: 127.0.0.1:2181(CONNECTED) 6] 
</code></pre>
<ul>
<li>查看节点状态：<code>stat /</code></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 6] stat /
cZxid = 0x0
ctime = Thu Jan 01 08:00:00 CST 1970
mZxid = 0x0
mtime = Thu Jan 01 08:00:00 CST 1970
pZxid = 0x0
cversion = -1    //子节点更改的次数
dataVersion = 0  //数据更改的情况
aclVersion = 0   //权限修改的情况
ephemeralOwner = 0x0  //[0是永久节点 其他的是临时节点]
dataLength = 0
numChildren = 1  //有几个子节点
</code></pre>
<ul>
<li>查看节点的数据和状态：<code>get</code></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 7] get /45
jj
</code></pre>
<ul>
<li>创建、修改、删除节点</li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 8] create
create [-s] [-e] [-c] [-t ttl] path [data] [acl]

//创建
[zk: 127.0.0.1:2181(CONNECTED) 9] create /imooc2
Created /imooc2
[zk: 127.0.0.1:2181(CONNECTED) 10] create /imooc3 123
Created /imooc3
[zk: 127.0.0.1:2181(CONNECTED) 11] get /imooc3
123

[zk: 127.0.0.1:2181(CONNECTED) 12] stat /imooc3
cZxid = 0x5
ctime = Sun May 05 01:41:21 CST 2024
mZxid = 0x5
mtime = Sun May 05 01:41:21 CST 2024
pZxid = 0x5
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0

//修改
[zk: 127.0.0.1:2181(CONNECTED) 13] set /imooc3 456
[zk: 127.0.0.1:2181(CONNECTED) 14] get /imooc3
456
[zk: 127.0.0.1:2181(CONNECTED) 15] stat /imooc3
cZxid = 0x5
ctime = Sun May 05 01:41:21 CST 2024
mZxid = 0x6
mtime = Sun May 05 01:42:16 CST 2024
pZxid = 0x5
cversion = 0
dataVersion = 1
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0
</code></pre>
</li>
</ul>
<h2 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a><span style = "color:blue">高级命令</span></h2><h4 id="创建节点的高级功能"><a href="#创建节点的高级功能" class="headerlink" title="创建节点的高级功能"></a>创建节点的高级功能</h4><ul>
<li><h5 id="创建顺序节点-s-会戴上序号"><a href="#创建顺序节点-s-会戴上序号" class="headerlink" title="创建顺序节点 [-s] (会戴上序号)"></a>创建顺序节点 [-s] (会戴上序号)</h5></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 16] create /imooc4
Created /imooc4
[zk: 127.0.0.1:2181(CONNECTED) 17] create -s /imooc4 /s
Created /imooc40000000003
[zk: 127.0.0.1:2181(CONNECTED) 18] create -s /imooc4 /s
Created /imooc40000000004
</code></pre>
<ul>
<li><h5 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h5><blockquote>
<p>ephemeralOwner &#x3D; 0x0  [0是永久节点 其他的是临时节点]</p>
</blockquote>
</li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 22] create /imooc
Created /imooc
[zk: 127.0.0.1:2181(CONNECTED) 23] create -e /imooc/tmp 123
Created /imooc/tmp
[zk: 127.0.0.1:2181(CONNECTED) 24] stat /imooc/tmp
cZxid = 0xd
ctime = Sun May 05 01:48:50 CST 2024
mZxid = 0xd
mtime = Sun May 05 01:48:50 CST 2024
pZxid = 0xd
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x10085ad02c90001  //[0x0是永久节点 其他的是临时节点]
dataLength = 3
numChildren = 0
</code></pre>
<ul>
<li><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 27] set /imooc 6
[zk: 127.0.0.1:2181(CONNECTED) 28] get /imooc
6
[zk: 127.0.0.1:2181(CONNECTED) 29] stat /imooc
cZxid = 0xc
ctime = Sun May 05 01:48:46 CST 2024
mZxid = 0xe
mtime = Sun May 05 01:51:15 CST 2024
pZxid = 0xd
cversion = 1
dataVersion = 1
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 1
numChildren = 1 
//set -v 1 /imooc 9 是因为上面 dataVersion = 1  指定条件版本更新
[zk: 127.0.0.1:2181(CONNECTED) 35] set -v 1 /imooc 9  
[zk: 127.0.0.1:2181(CONNECTED) 36] get /imooc
9
</code></pre>
<ul>
<li><h5 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h5></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 38] delete
delete [-v version] path //也可以按照版本号去删除
[zk: 127.0.0.1:2181(CONNECTED) 42] ls /
[imooc, imooc2, imooc3, imooc4, imooc40000000003, imooc40000000004, imooc40000000005, zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 43] delete /imooc40000000003
[zk: 127.0.0.1:2181(CONNECTED) 44] ls /
[imooc, imooc2, imooc3, imooc4, imooc40000000004, imooc40000000005, zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 45] 
</code></pre>
<h3 id="Watcher机制"><a href="#Watcher机制" class="headerlink" title="Watcher机制"></a><span style = "color:red">Watcher机制</span></h3><ul>
<li><h5 id="触发器、监督者"><a href="#触发器、监督者" class="headerlink" title="触发器、监督者"></a>触发器、监督者</h5></li>
<li><h5 id="使用场景：统一资源配置-发生变化时-会給所有监听客户端发送信息"><a href="#使用场景：统一资源配置-发生变化时-会給所有监听客户端发送信息" class="headerlink" title="使用场景：统一资源配置 [发生变化时 会給所有监听客户端发送信息]"></a>使用场景：统一资源配置 [发生变化时 会給所有监听客户端发送信息]</h5></li>
</ul>
<h5 id="Watcher事件类型"><a href="#Watcher事件类型" class="headerlink" title="Watcher事件类型"></a>Watcher事件类型</h5><table>
<thead>
<tr>
<th>EventType</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>NodeCreated (节点创建)</td>
<td>Watcher监听的对应数据节点被创建</td>
</tr>
<tr>
<td>NodeDeleted (节点删除)</td>
<td>Watcher监听的对应数据节点被删除</td>
</tr>
<tr>
<td>NodeDataChanged(节点数据修改)</td>
<td>Watcher监听的对应数据节点的数据内容发生变更</td>
</tr>
<tr>
<td>NodeChildrenChanged(子节点变更)</td>
<td>Watcher监听的对应数据节点的子节点列表发生变更</td>
</tr>
</tbody></table>
<h5 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h5><ul>
<li>access control list 权限控制</li>
<li>它使用<strong>权限位</strong>来允许&#x2F;禁止对话节点及其所作用域的各种操作</li>
<li>ACL仅与特定的znode有关，与<strong>子节点无关</strong></li>
</ul>
<h5 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h5><ul>
<li>ACL：[scheme采用的权限机制：id用户：permissions权限组合字符串]</li>
<li>world</li>
<li>auth [认证登录]</li>
<li>digest [密文加密]</li>
<li>ip [只允许特定ip访问]</li>
<li>super [超级权限]</li>
</ul>
<h5 id="权限字符串crdwa"><a href="#权限字符串crdwa" class="headerlink" title="权限字符串crdwa"></a>权限字符串crdwa</h5><ul>
<li><h6 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h6></li>
<li><h6 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h6></li>
<li><h6 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h6></li>
<li><h6 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h6></li>
<li><h6 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h6></li>
</ul>
<h5 id="ACL-权限使用场景"><a href="#ACL-权限使用场景" class="headerlink" title="[ACL]权限使用场景"></a>[ACL]权限使用场景</h5><ul>
<li>区分开发&#x2F;测试&#x2F;运维环境，防止误操作</li>
<li>可以针对不同IP而产生具体的配置，更安全</li>
</ul>
<h3 id="Java原生客户端连接到zookeeper-ZK"><a href="#Java原生客户端连接到zookeeper-ZK" class="headerlink" title="Java原生客户端连接到zookeeper [ZK]"></a>Java原生客户端连接到zookeeper [ZK]</h3><ul>
<li>利用<strong>ZK原生的Java</strong>的API</li>
<li>利用Apache <strong>Curator</strong>作为客户端来操作ZK</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;zk-practicer&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
            &lt;version&gt;3.6.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/zkjavaapi/ZKConnect.java
package com.imooc.zkjavaapi;

import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import org.omg.CORBA.TIMEOUT;

import java.io.IOException;

/**
 * 连接到ZK服务端，打印连接状态
 */
public class ZKConnect implements Watcher &#123;
    public static final String SERVER_PATH=&quot;47.98.225.105:2181&quot;;
    public static final Integer TIMEOUT = 5000;

    public static void main(String[] args) throws IOException, InterruptedException &#123;
        //后面new的相当于把这个作为参数传递进去
        //客户端和服务端是异步连接，连接成功之后，客户端会收到watcher通知
        //connectString：服务器的IP+端口号
        //sessionTImeout：超时时间
        //watcher：接收通知事件
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKConnect());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);
        System.out.println(zk.getState());
    &#125;

    @Override
    public void process(WatchedEvent watchedEvent) &#123;
        System.out.println(&quot;收到了通知&quot; + watchedEvent);
    &#125;
&#125;
===========================================================
17:35:46 INFO zookeeper.ZooKeeper: Client environment:os.memory.free=466MB
17:35:46 INFO zookeeper.ZooKeeper: Client environment:os.memory.max=7209MB
17:35:46 INFO zookeeper.ZooKeeper: Client environment:os.memory.total=487MB
17:35:46 INFO zookeeper.ZooKeeper: Initiating client connection, connectString=127.0.0.1:2181 sessionTimeout=5000 watcher=com.imooc.zkjavaapi.ZKConnect@7591083d
17:35:46 INFO common.X509Util: Setting -D jdk.tls.rejectClientInitiatedRenegotiation=true to disable client-initiated TLS renegotiation
17:35:46 INFO zookeeper.ClientCnxnSocket: jute.maxbuffer value is 1048575 Bytes
17:35:46 INFO zookeeper.ClientCnxn: zookeeper.request.timeout value is 0. feature enabled=false
客户端开始连接ZK服务器了
CONNECTING
17:35:46 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
17:35:46 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
17:35:46 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:50517, server: 127.0.0.1/127.0.0.1:2181
17:35:46 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec08710001, negotiated timeout = 5000
收到了通知WatchedEvent state:SyncConnected type:None path:null
CONNECTED
</code></pre>
<pre><code class="xml">log4j.properties
log4j.rootLogger=INFO, stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d&#123;HH:mm:ss&#125; %p %c&#123;2&#125;: %m%n
</code></pre>
<pre><code class="linux">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... already running as process 4147.
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33316784/article/details/88563482">windows环境下安装zookeeper教程详解（单机版）_windows zooke-CSDN博客</a></p>
<h3 id="用代码对节点进行操作"><a href="#用代码对节点进行操作" class="headerlink" title="用代码对节点进行操作"></a>用代码对节点进行操作</h3><pre><code class="java">com/imooc/zkjavaapi/ZKOperator.java
package com.imooc.zkjavaapi;

import java.io.IOException;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;

/**
 * 描述：     演示对节点的操作，包含创建、读取、删除等。
 */
public class ZKOperator implements Watcher &#123;

    public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;

    public static final Integer TIMEOUT = 5000;

    public static void main(String[] args)
            throws IOException, InterruptedException, KeeperException &#123;
        /**
         * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。
         * connectString：服务器的IP+端口号，比如127.0.0.1:2181
         * sessionTimeout：超时时间
         * watcher：通知事件
         */
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKOperator());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);

        /**
         * path:创建的路径
         * data：存储的数据
         * acl：权限，开放
         * createMode：永久、临时、顺序。
         */
        System.out.println(zk.create(&quot;/imooc-create-node2&quot;, &quot;imooc2&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,
                CreateMode.PERSISTENT));
    &#125;

    @Override
    public void process(WatchedEvent event) &#123;
    &#125;
&#125;
==========================================================================
客户端开始连接ZK服务器了
CONNECTING
17:57:14 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
17:57:14 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
17:57:14 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:57443, server: 127.0.0.1/127.0.0.1:2181
17:57:14 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec08710008, negotiated timeout = 5000
/imooc-create-node2
==========================================================================
==========================================================================
 /**
         * path:创建的路径
         * data：存储的数据
         * acl：权限，开放
         * createMode：永久、临时、顺序。
         */
//        System.out.println(zk.create(&quot;/imooc-create-node2&quot;, &quot;imooc2&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,
//                CreateMode.PERSISTENT));
//        zk.setData(&quot;/imooc-create-node&quot;, &quot;imooc3&quot;.getBytes(), 1);
        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);
        System.out.println(new String(data));
    &#125;
==========================================================================
客户端开始连接ZK服务器了
CONNECTING
17:58:09 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
17:58:09 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
17:58:09 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:57766, server: 127.0.0.1/127.0.0.1:2181
17:58:09 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec08710009, negotiated timeout = 5000
imooc2
</code></pre>
<h5 id="version版本不一样-保证不做修改"><a href="#version版本不一样-保证不做修改" class="headerlink" title="version版本不一样 保证不做修改"></a>version版本不一样 保证不做修改</h5><pre><code class="java">com/imooc/zkjavaapi/ZKOperator.java
修改值 让版本变成1
 zk.setData(&quot;/imooc-create-node2&quot;, &quot;imooc3&quot;.getBytes(), 1);
        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);
        System.out.println(new String(data)); 
----------------------------------------------------------------------------
Exception in thread &quot;main&quot; org.apache.zookeeper.KeeperException$BadVersionException: KeeperErrorCode = BadVersion for /imooc-create-node2
    at org.apache.zookeeper.KeeperException.create(KeeperException.java:122)
    at org.apache.zookeeper.KeeperException.create(KeeperException.java:54)
    at org.apache.zookeeper.ZooKeeper.setData(ZooKeeper.java:2551)
    at com.imooc.zkjavaapi.ZKOperator.main(ZKOperator.java:41)

报错=&gt;版本不一致
===========================================================================
[修改]
 zk.setData(&quot;/imooc-create-node2&quot;, &quot;imooc3&quot;.getBytes(), 0);
        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);
        System.out.println(new String(data));
----------------------------------------------------------------------------
客户端开始连接ZK服务器了
CONNECTING
18:01:35 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
18:01:35 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
18:01:35 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:58870, server: 127.0.0.1/127.0.0.1:2181
18:01:35 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec0871000d, negotiated timeout = 5000
imooc3 [修改成功]
</code></pre>
<h5 id="删除节点-引入回调函数-休眠"><a href="#删除节点-引入回调函数-休眠" class="headerlink" title="删除节点 [引入回调函数+休眠]"></a>删除节点 [引入回调函数+休眠]</h5><pre><code class="java">com/imooc/zkjavaapi/ZKOperator.java
package com.imooc.zkjavaapi;

import java.io.IOException;

import com.imooc.zkjavaapi.callback.DeleteCallBack;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;

/**
 * 描述：     演示对节点的操作，包含创建、读取、删除等。
 */
public class ZKOperator implements Watcher &#123;

    public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;

    public static final Integer TIMEOUT = 5000;

    public static void main(String[] args)
            throws IOException, InterruptedException, KeeperException &#123;
        /**
         * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。
         * connectString：服务器的IP+端口号，比如127.0.0.1:2181
         * sessionTimeout：超时时间
         * watcher：通知事件
         */
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKOperator());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);

        /**
         * path:创建的路径
         * data：存储的数据
         * acl：权限，开放
         * createMode：永久、临时、顺序。
         */
        zk.create(&quot;/imooc-create-node3&quot;, &quot;imooc3&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,
                CreateMode.PERSISTENT);
//        zk.setData(&quot;/imooc-create-node2&quot;, &quot;imooc3&quot;.getBytes(), 0);
//        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);

        String ctx = &quot;删除成功&quot;; //把ctx的内容代入到DeleteCallBack()里面去运行
        zk.delete(&quot;/imooc-create-node3&quot;,0,new DeleteCallBack(),ctx);
        Thread.sleep(2000);
//        System.out.println(new String(data));
    &#125;

    @Override
    public void process(WatchedEvent event) &#123;
    &#125;
&#125;
--------------------------------------------------------------------------------
客户端开始连接ZK服务器了
CONNECTING
18:10:01 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
18:10:01 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
18:10:01 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:2600, server: 127.0.0.1/127.0.0.1:2181
18:10:01 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec0871000f, negotiated timeout = 5000
删除节点/imooc-create-node3
删除成功
</code></pre>
<pre><code class="java">com/imooc/zkjavaapi/callback/DeleteCallBack.java
package com.imooc.zkjavaapi.callback;

import org.apache.zookeeper.AsyncCallback;

/**
 * 删除后运行的方法
 */
public class DeleteCallBack implements AsyncCallback.VoidCallback &#123;
    @Override
    public void processResult(int rc, String path, Object ctx) &#123;
        System.out.println(&quot;删除节点&quot; + path);
        System.out.println((String)ctx);
    &#125;
&#125;
</code></pre>
<h3 id="处理Watcher事件"><a href="#处理Watcher事件" class="headerlink" title="处理Watcher事件"></a>处理Watcher事件</h3><pre><code class="java">com/imooc/zkjavaapi/ZKGetNode.java
package com.imooc.zkjavaapi;

import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.data.Stat;

import java.io.IOException;
import java.util.concurrent.CountDownLatch;

/**
 * 和节点相关：是否存在，获取数据，加上Watch
 */
public class ZKGetNode implements Watcher &#123;
    public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;

    public static final Integer TIMEOUT = 5000;

    //这个是门闩
    private static CountDownLatch countDownLatch = new CountDownLatch(1);

    public static void main(String[] args) throws IOException, InterruptedException, KeeperException &#123;
        /**
         * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。
         * connectString：服务器的IP+端口号，比如127.0.0.1:2181
         * sessionTimeout：超时时间
         * watcher：通知事件
         */
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKGetNode());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);
        System.out.println(zk.getState());

//        Stat exists = zk.exists(&quot;/imooc-create-node&quot;, false);//不需要额外监听
//        if (exists != null)&#123;
//            System.out.println(&quot;节点的版本为： &quot;+exists.getVersion());
//        &#125;else&#123;
//            System.out.println(&quot;该节点不存在&quot;);
//        &#125;
        zk.getData(&quot;/imooc-create-node&quot;, true, null);
        countDownLatch.await();
    &#125;

    @Override
    public void process(WatchedEvent event) &#123;
        if (event.getType() == Event.EventType.NodeChildrenChanged)&#123;
            System.out.println(&quot;数据被改变&quot;);
            countDownLatch.countDown();
        &#125;
        System.out.println(&quot;收到了通知&quot; + event);
    &#125;
&#125;
--------------------------------------------------------------------------------
在运行的情况下 去cmd中 修改
[zk: localhost:2181(CONNECTED) 1] set /imooc-create-node 11
--------------------------------------------------------------------------------
客户端开始连接ZK服务器了
CONNECTING
18:52:14 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
18:52:14 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
18:52:14 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:16204, server: 127.0.0.1/127.0.0.1:2181
18:52:14 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x1000534afde0001, negotiated timeout = 5000
收到了通知WatchedEvent state:SyncConnected type:None path:null
CONNECTED
数据被改变
收到了通知WatchedEvent state:SyncConnected type:NodeDataChanged path:/imooc-create-node
</code></pre>
<h3 id="用Curator操作ZK"><a href="#用Curator操作ZK" class="headerlink" title="用Curator操作ZK"></a><span style = "color:red">用Curator操作ZK</span></h3><h5 id="原生的Java的API的缺点"><a href="#原生的Java的API的缺点" class="headerlink" title="原生的Java的API的缺点"></a>原生的Java的API的缺点</h5><ul>
<li>不支持连接超时后的<strong>自动连接</strong></li>
<li>Watcher<strong>注册一次</strong>后会失效</li>
<li>不支持<strong>递归</strong>创建节点</li>
</ul>
<h5 id="利用Apache-Curator"><a href="#利用Apache-Curator" class="headerlink" title="利用Apache Curator"></a>利用Apache Curator</h5><ul>
<li>解决了Watcher注册一次后会失效的问题</li>
<li>API更加<strong>简单易用</strong>，提供了工具类</li>
</ul>
<pre><code class="java">com/imooc/curator/CuratorTests.java
package com.imooc.curator;

import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;

/**
 * 用Curator来操作ZK
 */
public class CuratorTests &#123;
    public static void main(String[] args) throws Exception &#123;
        String connectString = &quot;127.0.0.1:2181&quot;;
        RetryPolicy retry = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retry);
        client.start();
        String path = &quot;/curator&quot;;
        String data = &quot;test&quot;;
        client.create().withMode(CreateMode.PERSISTENT).forPath(path,data.getBytes());
        byte[] bytes = client.getData().forPath(path);
        System.out.println(new String(bytes));
    &#125;
&#125;
</code></pre>
<h6 id="更改高级一点！！！【添加-修改-删除】"><a href="#更改高级一点！！！【添加-修改-删除】" class="headerlink" title="更改高级一点！！！【添加+修改+删除】"></a>更改高级一点！！！【添加+修改+删除】</h6><pre><code class="java">com/imooc/curator/CuratorTests.java
package com.imooc.curator;

import com.sun.net.httpserver.Authenticator.Retry;
import java.text.MessageFormat;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorEvent;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher.Event.EventType;

/**
 * 描述：     用Curator来操作ZK
 */
public class CuratorTests &#123;

    public static void main(String[] args) throws Exception &#123;
        String connectString = &quot;127.0.0.1:2181&quot;;
        String path = &quot;/curator2&quot;;

        RetryPolicy retry = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retry);
        client.start();
        client.getCuratorListenable().addListener((CuratorFramework c, CuratorEvent event) -&gt; &#123;
            switch (event.getType()) &#123;
                case WATCHED:
                    WatchedEvent watchedEvent = event.getWatchedEvent();
                    if (watchedEvent.getType() == EventType.NodeDataChanged) &#123;
                        System.out.println(new String(c.getData().forPath(path)));
                    &#125;
            &#125;
        &#125;);
        String data = &quot;test&quot;;
        String data2 = &quot;test2&quot;;
        //添加
        client.create().withMode(CreateMode.PERSISTENT).forPath(path, data.getBytes());

        byte[] bytes = client.getData().watched().forPath(path);
        System.out.println(new String(bytes));
        //更改
        client.setData().forPath(path, data2.getBytes());
        //删除
        client.delete().forPath(path);
        Thread.sleep(2000); //保证足够时间运行成功
    &#125;
&#125;
-------------------------------------------------------------------------------------
19:44:41 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
19:44:41 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
19:44:41 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:32984, server: 127.0.0.1/127.0.0.1:2181
19:44:41 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x1000534afde0005, negotiated timeout = 40000
19:44:41 INFO state.ConnectionStateManager: State change: CONNECTED
test
test2
</code></pre>
<h2 id="Dubbo-RPC远程过程调用"><a href="#Dubbo-RPC远程过程调用" class="headerlink" title="Dubbo [RPC远程过程调用]"></a>Dubbo [RPC远程过程调用]</h2><ul>
<li>初识Dubbo</li>
<li><strong>RPC</strong>介绍</li>
<li>Dubbo<strong>工作原理</strong></li>
<li>案例实操：项目编写</li>
<li>整合Dubbo和Zookeeper</li>
<li>实现服务间调用</li>
</ul>
<h3 id="初始Dubbo"><a href="#初始Dubbo" class="headerlink" title="初始Dubbo"></a>初始Dubbo</h3><h5 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么"></a>Dubbo是什么</h5><ul>
<li>轻量级、高性能的<strong>RPC框架</strong></li>
<li>并不是要成为一个微服务的全面解决方案</li>
<li>以Java语言而出名</li>
</ul>
<h5 id="Dubbo现状"><a href="#Dubbo现状" class="headerlink" title="Dubbo现状"></a>Dubbo现状</h5><ul>
<li>全称是<strong>Apache Dubbo</strong></li>
<li>微店、网易云音乐、滴滴、中国电信、中国人寿</li>
<li>star有30K+个，fork有20K+个</li>
</ul>
<h5 id="Dubbo的故事"><a href="#Dubbo的故事" class="headerlink" title="Dubbo的故事"></a>Dubbo的故事</h5><ul>
<li>09年开始做，做的第一个版本</li>
<li>10年初的时候，架构升级，Dubbo2.0</li>
<li><strong>开源</strong></li>
<li>one company战略</li>
<li>合到HSF去</li>
<li>第3节点，捐给Apache</li>
</ul>
<h5 id="开源的理解"><a href="#开源的理解" class="headerlink" title="开源的理解"></a>开源的理解</h5><ul>
<li><strong>共同成长</strong>、巨人的肩膀上</li>
<li>演化慢、不断革新、很强大的生命力</li>
<li>突破任何的束缚，突破任何的常规，<strong>包容和开放</strong></li>
</ul>
<h3 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h3><ul>
<li>RPC ——远程过程调用</li>
<li>早期单机时代：IPC</li>
<li>网络时代：<strong>把IPC扩展到网络上，这就是RPC</strong></li>
<li>实现RPC很头疼，于是有了<strong>RPC框架</strong></li>
<li>调用其他机器上的程序和<strong>调用本地的程序一样方便</strong></li>
</ul>
<h5 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h5><ul>
<li>阿里的Dubbo</li>
<li>新浪的Montan</li>
<li>Facebook的Thrift</li>
<li>各个框架都有其各自的优缺点</li>
</ul>
<h5 id="HTTP和RPC对比"><a href="#HTTP和RPC对比" class="headerlink" title="HTTP和RPC对比"></a>HTTP和RPC对比</h5><ul>
<li><strong>普通话</strong>[通用] 与 <strong>方言</strong>[企业内部]</li>
<li>普通话本质上也是一种方言，只不过它是官方的方言</li>
<li>传输效率 <ul>
<li>RPC定制自己传输请求让传输效率更高</li>
<li>HTTP会包含一些无用的内容效率较低</li>
</ul>
</li>
<li>性能消耗，主要在于序列化和反序列化的耗时</li>
<li>负载均衡</li>
</ul>
<h3 id="Dubbo工作原理"><a href="#Dubbo工作原理" class="headerlink" title="Dubbo工作原理"></a>Dubbo工作原理</h3><h6 id="一旦注册中心的信息有变化的时候会主动推送信息"><a href="#一旦注册中心的信息有变化的时候会主动推送信息" class="headerlink" title="一旦注册中心的信息有变化的时候会主动推送信息"></a>一旦注册中心的信息有变化的时候会主动推送信息</h6><ul>
<li>服务<strong>容器</strong>负责启动，加载，<strong>运行服务提供者</strong></li>
<li><strong>服务提供者</strong>在启动时，向注册中心<strong>注册</strong>自己提供的服务</li>
<li><strong>服务提供者</strong>在启动时，向注册中心<strong>订阅</strong>自己所需的服务</li>
<li>注册中心返回服务提供者<strong>地址列表</strong>给消费者</li>
<li>从提供者地址列表中，<strong>选一台</strong>提供者进行调用</li>
<li>定期发送一次<strong>统计数据</strong>到监控中心</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ded5afda4ae8cff8392f5ccf0217657054c8981/data/Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的控制中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<h3 id="服务提供者开发"><a href="#服务提供者开发" class="headerlink" title="服务提供者开发"></a>服务提供者开发</h3><h5 id="案例实操"><a href="#案例实操" class="headerlink" title="案例实操"></a>案例实操</h5><ul>
<li>引入依赖</li>
<li>添加注解</li>
<li>整合Dubbo和<strong>Zookeeper</strong></li>
</ul>
<pre><code class="xml">pom.xml[dubbo-practice]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;modules&gt;
        &lt;module&gt;producer&lt;/module&gt;
    &lt;/modules&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.12.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt;
    &lt;version&gt;0.0.1&lt;/version&gt;
    &lt;name&gt;dubbo-practice&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;spring-boot.version&gt;2.1.12.RELEASE&lt;/spring-boot.version&gt;
        &lt;dubbo.version&gt;2.7.4.1&lt;/dubbo.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- Spring Boot --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- Apache Dubbo  --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo-dependencies-bom&lt;/artifactId&gt;
                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
                &lt;exclusions&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                        &lt;artifactId&gt;spring&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
                        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;log4j&lt;/groupId&gt;
                        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                &lt;/exclusions&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">pom.xml[dubbo-practice-producer]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;0.0.1&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;producer&lt;/artifactId&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- Dubbo Spring Boot Starter --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.7.4.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- Zookeeper dependencies --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;
            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- Web 功能 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- MySQL connector, 需要与 MySQL 版本对应 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- MyBatis依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/producer/service/CourseListService.java
package com.imooc.producer.service;

import com.imooc.producer.entity.Course;

import java.util.List;

/**
 * 课程列表服务
 */
public interface CourseListService &#123;
    List&lt;Course&gt; getCourseList();
&#125;
</code></pre>
<pre><code class="java">com/imooc/producer/entity/Course.java
package com.imooc.producer.entity;

import java.io.Serializable;

/**
 * 描述：     Course实体类
 */
public class Course implements Serializable &#123;

    Integer id;
    Integer courseId;
    String name;
    //1上架，0下架
    Integer valid;

    @Override
    public String toString() &#123;
        return &quot;Course&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, valid=&quot; + valid +
                &#39;&#125;&#39;;
    &#125; Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/producer/service/impl/CourseListServiceImpl.java
package com.imooc.producer.service.impl;

import com.imooc.producer.entity.Course;
import com.imooc.producer.mapper.CourseMapper;
import com.imooc.producer.service.CourseListService;
import java.util.List;
import org.apache.dubbo.config.annotation.Service;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * 描述：     课程列表服务实现类
 */
@Service(version = &quot;$&#123;demo.service.version&#125;&quot;)
public class CourseListServiceImpl implements CourseListService &#123;

    @Autowired
    CourseMapper courseMapper;

    public List&lt;Course&gt; getCourseList() &#123;
        return courseMapper.findValidCourses();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/producer/mapper/CourseMapper.java
package com.imooc.producer.mapper;

import com.imooc.producer.entity.Course;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Mapper类
 */
@Mapper
@Repository
public interface CourseMapper &#123;
    @Select(&quot;SELECT * FORM course WHERE valid = 1&quot;)
    List&lt;Course&gt; findValidCourses();
&#125;
</code></pre>
<pre><code class="mysql">application.properties
demo.service.version=1.0.0

#server.port=8081

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_prepare?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;


spring.application.name=course-list

#dubbo协议
dubbo.protocol.name=dubbo
dubbo.protocol.port=-1
#dubbo注册
dubbo.registry.address=zookeeper://127.0.0.1:2181
dubbo.registry.file=$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache

mybatis.configuration.map-underscore-to-camel-case=true

dubbo.scan.base-packages=com.imooc.producer.service.impl
</code></pre>
<pre><code class="java">com/imooc/producer/DubboProducerApplication.java
package com.imooc.producer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 描述：     Spring Boot启动类
 */
@EnableAutoConfiguration
public class DubboProducerApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(DubboProducerApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="服务消费方开发"><a href="#服务消费方开发" class="headerlink" title="服务消费方开发"></a>服务消费方开发</h3><p>查看PID为8080：<code>netstat -ano|findstr 8080</code><br>杀死进程：<code>taskkill /pid 查询的PID /f</code></p>
<pre><code class="xml">pom.xml[dubbo-practice-consumer]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;version&gt;0.0.1&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;artifactId&gt;concumer&lt;/artifactId&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- Dubbo Spring Boot Starter --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.7.4.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- Zookeeper dependencies --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;
      &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;!-- Web 功能 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL connector, 需要与 MySQL 版本对应 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- MyBatis依赖--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.imooc&lt;/groupId&gt;
      &lt;artifactId&gt;producer&lt;/artifactId&gt;
      &lt;version&gt;0.0.1&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/consumer/service/CoursePriceService.java
package com.imooc.consumer.service;

import com.imooc.consumer.entity.CourseAndPrice;
import com.imooc.consumer.entity.CoursePrice;
import java.util.List;

/**
 * 描述：     课程价格服务
 */
public interface CoursePriceService &#123;

    CoursePrice getCoursePrice(Integer courseId);

    List&lt;CourseAndPrice&gt; getCoursesAndPrice();
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/service/impl/CoursePriceServiceImpl.java
package com.imooc.consumer.service.impl;

import com.imooc.consumer.dao.CoursePriceMapper;
import com.imooc.consumer.entity.CourseAndPrice;
import com.imooc.consumer.entity.CoursePrice;
import com.imooc.consumer.service.CoursePriceService;
import com.imooc.producer.entity.Course;
import com.imooc.producer.service.CourseListService;
import java.util.ArrayList;
import java.util.List;
import org.apache.dubbo.config.annotation.Reference;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 描述：     课程 价格服务
 */
@Service
public class CoursePriceServiceImpl implements CoursePriceService &#123;

    @Autowired
    CoursePriceMapper coursePriceMapper;

    @Reference(version = &quot;$&#123;demo.service.version&#125;&quot;)
    CourseListService courseListService;

    @Override
    public CoursePrice getCoursePrice(Integer courseId) &#123;
        return coursePriceMapper.findCoursePrices(courseId);
    &#125;

    @Override
    public List&lt;CourseAndPrice&gt; getCoursesAndPrice() &#123;
        List&lt;CourseAndPrice&gt; courseAndPriceList = new ArrayList&lt;&gt;();
        List&lt;Course&gt; courseList = courseListService.getCourseList();
        for (int i = 0; i &lt; courseList.size(); i++) &#123;
            Course course = courseList.get(i);
            if (course != null) &#123;
                CoursePrice price = getCoursePrice(course.getCourseId());
                if (price != null &amp;&amp; price.getPrice() &gt; 0) &#123;
                    CourseAndPrice courseAndPrice = new CourseAndPrice();
                    courseAndPrice.setId(course.getId());
                    courseAndPrice.setCourseId(course.getCourseId());
                    courseAndPrice.setName(course.getName());
                    courseAndPrice.setPrice(price.getPrice());
                    courseAndPriceList.add(courseAndPrice);
                &#125;
            &#125;
        &#125;
        return courseAndPriceList;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/dao/CoursePriceMapper.java
package com.imooc.consumer.dao;

import com.imooc.consumer.entity.CoursePrice;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

/**
 * 描述：     Mapper类
 */
@Mapper
@Repository
public interface CoursePriceMapper &#123;

    @Select(&quot;SELECT * FROM course_price WHERE course_id = #&#123;courseId&#125;&quot;)
    CoursePrice findCoursePrices(Integer courseId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/entity/CourseAndPrice.java
package com.imooc.consumer.entity;

import java.io.Serializable;

/**
 * 描述：     CoursePrice实体类
 */
public class CourseAndPrice implements Serializable &#123;

    Integer id;
    Integer courseId;
    String name;
    Integer price;

    @Override
    public String toString() &#123;
        return &quot;CourseAndPrice&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, price=&quot; + price +
                &#39;&#125;&#39;;
    &#125; Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/entity/CoursePrice.java
package com.imooc.consumer.entity;


import java.io.Serializable;

/**
 * 描述：     CoursePrice实体类
 */
public class CoursePrice implements Serializable &#123;

    Integer id;
    Integer courseId;
    Integer price;
&#125; Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/consumer/controller/CoursePriceController.java
package com.imooc.consumer.controller;

import com.imooc.consumer.entity.CourseAndPrice;
import com.imooc.consumer.entity.CoursePrice;
import com.imooc.consumer.service.CoursePriceService;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 描述：CoursePriceController
 */
@RestController
public class CoursePriceController &#123;

    @Autowired
    CoursePriceService coursePriceService;


    @GetMapping(&#123;&quot;/price&quot;&#125;)
    public Integer getCoursePrice(Integer courseId) &#123;
        CoursePrice coursePrice = coursePriceService.getCoursePrice(courseId);
        if (coursePrice != null) &#123;
            return coursePrice.getPrice();
        &#125; else &#123;
            return -1;
        &#125;
    &#125;


    @GetMapping(&#123;&quot;/coursesAndPrice&quot;&#125;)
    public List&lt;CourseAndPrice&gt; getcoursesAndPrice() &#123;
        return coursePriceService.getCoursesAndPrice();
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">application.properties
demo.service.version=1.0.0

server.port=8084

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_practice?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;


spring.application.name=course-price

#dubboåè®®
dubbo.protocol.name=dubbo
dubbo.protocol.port=-1
#dubboæ³¨å
dubbo.registry.address=zookeeper://127.0.0.1:2181
dubbo.registry.file=$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache
</code></pre>
<pre><code class="java">com/imooc/consumer/DubboConsumerApplication.java
package com.imooc.consumer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 描述：     Spring Boot启动类
 */
@SpringBootApplication
public class DubboConsumerApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(DubboConsumerApplication.class, args);
    &#125;
&#125;
</code></pre>
<h5 id="案例实操总结"><a href="#案例实操总结" class="headerlink" title="案例实操总结"></a>案例实操总结</h5><ul>
<li><strong>自动检查</strong>zk和依赖的服务</li>
<li>dubbo.scan.base-packages配置</li>
<li>实现<strong>服务间调用</strong></li>
</ul>
<h1 id="面试课"><a href="#面试课" class="headerlink" title=" 面试课"></a><span style = "color:red"> 面试课</span></h1><ul>
<li><h5 id="Spring-Boot常见面试题"><a href="#Spring-Boot常见面试题" class="headerlink" title="Spring Boot常见面试题"></a>Spring Boot常见面试题</h5></li>
<li><h5 id="线程常见面试题"><a href="#线程常见面试题" class="headerlink" title="线程常见面试题"></a>线程常见面试题</h5></li>
<li><h5 id="分布式的面试题"><a href="#分布式的面试题" class="headerlink" title="分布式的面试题"></a>分布式的面试题</h5></li>
<li><h5 id="Docker相关面试题"><a href="#Docker相关面试题" class="headerlink" title="Docker相关面试题"></a>Docker相关面试题</h5></li>
<li><h5 id="Nginx和Zookeeper相关面试题"><a href="#Nginx和Zookeeper相关面试题" class="headerlink" title="Nginx和Zookeeper相关面试题"></a>Nginx和Zookeeper相关面试题</h5></li>
<li><h5 id="RabbitMQ相关面试题"><a href="#RabbitMQ相关面试题" class="headerlink" title="RabbitMQ相关面试题"></a>RabbitMQ相关面试题</h5></li>
<li><h5 id="微服务相关"><a href="#微服务相关" class="headerlink" title="微服务相关"></a>微服务相关</h5></li>
<li><h5 id="彩蛋：学习方法"><a href="#彩蛋：学习方法" class="headerlink" title="彩蛋：学习方法"></a>彩蛋：学习方法</h5></li>
<li><h5 id="锁分类、死锁"><a href="#锁分类、死锁" class="headerlink" title="锁分类、死锁"></a>锁分类、死锁</h5></li>
<li><h5 id="HashMap和final"><a href="#HashMap和final" class="headerlink" title="HashMap和final"></a>HashMap和final</h5></li>
<li><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5></li>
<li><h5 id="面试避坑指南"><a href="#面试避坑指南" class="headerlink" title="面试避坑指南"></a>面试避坑指南</h5></li>
<li><h5 id="重要的软实力"><a href="#重要的软实力" class="headerlink" title="重要的软实力"></a>重要的软实力</h5></li>
</ul>
<h3 id="Spring、Spring-Boot和Spring-Cloud的关系？"><a href="#Spring、Spring-Boot和Spring-Cloud的关系？" class="headerlink" title="Spring、Spring Boot和Spring Cloud的关系？"></a>Spring、Spring Boot和Spring Cloud的关系？</h3><ul>
<li>Spring最初利用<strong>IOC</strong>和<strong>AOP</strong>解耦</li>
<li>按照这种模式搞了<strong>MVC框架</strong> [之后就配置太繁琐了]</li>
<li>写了很多样板代码很麻烦，就有了Spring Boot</li>
<li>Spring Boot是在强大的Spring帝国发展起来的，发明Spring Boot是为了让人们更好更高效的使用Spring，Spring Boot理念是约定优于配置</li>
<li>Spring Cloud是在Spring Boot基础上诞生的 [一系列框架的有序集合]</li>
</ul>
<h3 id="Spring-Boot如何配置多环境"><a href="#Spring-Boot如何配置多环境" class="headerlink" title="Spring Boot如何配置多环境"></a>Spring Boot如何配置多环境</h3><ul>
<li><h5 id="开发、测试、预发、生产"><a href="#开发、测试、预发、生产" class="headerlink" title="开发、测试、预发、生产"></a>开发、测试、预发、生产</h5></li>
</ul>
<blockquote>
<p>面试官你好，我这边平时是会使用多套环境，比如说”开发、测试、预发、生产”环境。<br>开发环境通常在本地，它所连接的数据库也是专门用于开发的，里面的数据也是一定情况下算出来的，因为并不需要在开发环境的情况下保证数据的完全精确，为了开发效率的提高，我们通常造一些模拟的数据，通常开发完后我们要把程序部署到测试环境，因为测试环境通常是公司所提供的服务器，而开发环境通常是我们本机，对于本机而言如果关闭或关机后别人就无法访问了，但是测试的同学工作时间不一定能和开发的同学一致，如果把程序关掉了他们就没办法测试了。我们需要给测试同学提供一套稳定的环境去测试。而且有的时候会同时开发多种功能，前一个功能开发完了需要去测试，这个时候就要去开发新的功能了，此时本地的代码已经发生了变化，如果把开发环境当成测试环境的话会发生很多问题，它实际测试的和我们想要测试的不是同一套代码，正是这个原因测试环境是必不可少的，需要用一台稳定的服务器把我们开发好的部署上测试环境中去，这样的话无论电脑是否关机都不会影响测试人员的进度。但是在测试环境的数据库往往可以和开发环境的保持一致可以允许公用同一个数据。<br>预发环境是预备发布，和真正的线上环境高度统一，和测试环境的区别：<br>1.网络隔离 为了保证线上环境的稳定会采取环境隔离，在本地或者测试环境下是没有办法访问到预发环境的机器，不可直接访问。在预发环境通常采用真实的数据库去测试。在测试环境并不能把所有问题都测试出来，所以在测试环境中无法测试到的问题在预发环境就可以暴露出来了，有时候在测试环境中模拟的数据不是准确，比如模拟一个商品详情，报的是50个字，最后发现真实情况是100个字，就能看到数据库大小不够，再次比如测试的是整数，到真实环境中发现是小数。隔离+数据验真<br>生产环境是真实对外的数据，也会有很多流量进来，直接面向所有用户，也有并发问题，要确保数据稳定</p>
</blockquote>
<ul>
<li><h5 id="提供多套配置文件"><a href="#提供多套配置文件" class="headerlink" title="提供多套配置文件"></a>提供多套配置文件</h5></li>
</ul>
<blockquote>
<p>在发布到某个环境之前，不建议把配置文件全部删除替换，有可能漏了文件导致了错误的替换，如果发布环境是测试环境的数据库，有可能会产生对外暴露的是测试环境的情况，这是很严重的事故</p>
</blockquote>
<ul>
<li><h5 id="通过改变application里的profiles-active值来加载对应的环境"><a href="#通过改变application里的profiles-active值来加载对应的环境" class="headerlink" title="通过改变application里的profiles.active值来加载对应的环境"></a>通过改变application里的profiles.active值来加载对应的环境</h5></li>
</ul>
<pre><code class="java">com/imooc/profiles/ProfilesApplication.java
package com.imooc.profiles;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProfilesApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(ProfilesApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">application.properties

spring.profiles.active=prod
</code></pre>
<pre><code class="mysql">application-pre.properties

spring.profiles.active=test
server.port=8082
</code></pre>
<pre><code class="mysql">application-prod.properties

spring.profiles.active=test
server.port=8083
</code></pre>
<pre><code class="mysql">application-test.properties

spring.profiles.active=test
server.port=8081
</code></pre>
<h3 id="实际工作中，如何全局处理异常？"><a href="#实际工作中，如何全局处理异常？" class="headerlink" title="实际工作中，如何全局处理异常？"></a>实际工作中，如何全局处理异常？</h3><ul>
<li><h5 id="为什么异常需要全局处理？不处理行不行？"><a href="#为什么异常需要全局处理？不处理行不行？" class="headerlink" title="为什么异常需要全局处理？不处理行不行？"></a>为什么异常需要全局处理？不处理行不行？</h5></li>
</ul>
<blockquote>
<p>如果我们不进行处理的话，异常可能会把整个堆栈抛出去，一旦发生异常，用户或者别用用心的黑客可以看到详细的异常发生情况，包含详细的错误信息和代码的行数，这样的话对方可以利用一个漏洞进行不同的尝试，而且可以顺藤摸瓜分析出更多潜在的风险，最终把系统攻击破，异常是必须处理的。<br>但为什么要全局处理呢？电商项目→exception→GlobalExceptionHandler</p>
</blockquote>
<ul>
<li><h5 id="GlobalExceptionHandler-使用全局处理"><a href="#GlobalExceptionHandler-使用全局处理" class="headerlink" title="GlobalExceptionHandler [使用全局处理]"></a>GlobalExceptionHandler [使用全局处理]</h5>识别到什么异常，调用什么其处理器。写了全局异常处理器，轻松的针对不同的异常做出定制化的解决方案，不但增加了安全性，对用户也是友好的</li>
</ul>
<pre><code class="java">package com.imooc.mall.exception;

import com.imooc.mall.common.ApiRestResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.ArrayList;
import java.util.List;

/**
 * 19.处理统一异常的handler 业务异常 处理不同逻辑异常  20对密码进行MD5加密UserServiceImpl 先创建MD5Utils
 */
@ControllerAdvice
public class GlobalExceptionHandler &#123;
    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    //   统一处理Exception.class异常 所有异常的父类
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Object handleException(Exception e) &#123;
        log.error(&quot;Default Exception: &quot;, e);
        return ApiRestResponse.error(ImoocMallExceptionEnum.SYSTEM_ERROR);
    &#125;
    
    // 处理自己所定义的异常 用户/密码不能为空......
    @ExceptionHandler(ImoocMallException.class)
    @ResponseBody
    public Object handleImoocMallException(ImoocMallException e) &#123;
        log.error(&quot;ImoocMallException: &quot;, e); //传进来的是什么就传出去
        return ApiRestResponse.error(e.getCode(), e.getMessage());
    &#125;

    //  39.处理方法参数不合规的情况
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public ApiRestResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e) &#123;
        log.error(&quot;handleMethodArgumentNotValidException: &quot;, e);
        return handleBindingResult(e.getBindingResult());
    &#125;
//  40.处理返回异常的ApiRespond 41去pom引入Swagger自动生成API文档
    private ApiRestResponse handleBindingResult(BindingResult result)&#123;
//  把异常处理为对外暴露的提示
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        if (result.hasErrors())&#123;
            List&lt;ObjectError&gt; allErrors = result.getAllErrors();
            for (ObjectError objectError : allErrors) &#123; //itli快速  对着for按alt+回车 改成增强for
                String message = objectError.getDefaultMessage();
                list.add(message);
            &#125;
        &#125;
        if (list.size() == 0)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR);
        &#125; //list.toString()生成所创建的异常描述信息
        return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR.getCode(), list.toString());
    &#125;
&#125;
</code></pre>
<h3 id="线程如何启动？"><a href="#线程如何启动？" class="headerlink" title="线程如何启动？"></a>线程如何启动？</h3><blockquote>
<p>Thread.start.run</p>
</blockquote>
<ul>
<li><h5 id="既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？"><a href="#既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？" class="headerlink" title="既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？"></a>既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？</h5></li>
</ul>
<blockquote>
<p>因为它只是一个普通的java代码，而不会真正的启动一个线程，调用一次run()方法只执行一次，而且是在主线程执行的，就没有起到任何创建线程的效果了。<br>如果选择start方法的话会在后台执行很多操作，比如去申请一个线程、让子方法去执行run()里的内容，而且还包括执行之后的对线程状态的调整。所以说表面上是相同都是执行一段代码，但是实际上是不同的。</p>
</blockquote>
<ul>
<li><h5 id="两次调用start-方法会出现什么情况？"><a href="#两次调用start-方法会出现什么情况？" class="headerlink" title="两次调用start()方法会出现什么情况？"></a>两次调用start()方法会出现什么情况？</h5></li>
</ul>
<blockquote>
<p>两次调用start()方法会报异常，异常类型叫做<code>IllegalThreadStateException</code>，在start()的时候首先会进行线程状态的检测只有是new的时候才能正常启动，不允许启动两次</p>
</blockquote>
<pre><code class="java">com/imooc/interniew/StartTwice.java
package com.imooc.interniew;

/**
 * 描述：     两次启动线程
 */
public class StartTwice &#123;

    public static void main(String[] args) &#123;
        Thread thread = new Thread();
        thread.start();
        thread.start();
    &#125;
&#125;
======================== 报错信息  ==========================
Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException
    at java.lang.Thread.start(Thread.java:705)
    at com.imooc.interniew.StartTwice.main(StartTwice.java:11)
</code></pre>
<pre><code class="java">Thread.java
public synchronized void start() &#123;
        /**
         * This method is not invoked for the main method thread or &quot;system&quot;
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state &quot;NEW&quot;.
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group&#39;s list of threads
         * and the group&#39;s unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try &#123;
            start0();
            started = true;
        &#125; finally &#123;
            try &#123;
                if (!started) &#123;
                    group.threadStartFailed(this);
                &#125;
            &#125; catch (Throwable ignore) &#123;
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="实现多线程的方法有几种？"><a href="#实现多线程的方法有几种？" class="headerlink" title="实现多线程的方法有几种？"></a>实现多线程的方法有几种？</h3><ul>
<li><h5 id="方法一：实现Runnable接口"><a href="#方法一：实现Runnable接口" class="headerlink" title="方法一：实现Runnable接口"></a>方法一：实现<strong>Runnable</strong>接口</h5></li>
</ul>
<pre><code class="java">com/imooc/interniew/createthreads/RunnableStyle.java
package com.imooc.interniew.createthreads;

import java.util.concurrent.Callable;

/**
 * 描述：     用Runnable方式创建线程
 */
public class RunnableStyle implements Runnable &#123;
//new里new的意思是 把这个Runnable类作为参数传进Thread里面
    public static void main(String[] args) &#123;
        Thread thread = new Thread(new RunnableStyle());
        thread.start();
    &#125;

    @Override
    public void run() &#123;
        System.out.println(&quot;用Runnable方法实现线程&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="方法二：继承Thread类"><a href="#方法二：继承Thread类" class="headerlink" title="方法二：继承Thread类"></a>方法二：继承Thread类</h5></li>
</ul>
<pre><code class="java">package com.imooc.interniew.createthreads;

import java.util.Timer;
import java.util.TimerTask;

/**
 * 描述：     利用定时器新建线程
 */
public class TimerDemo &#123;

    public static void main(String[] args) &#123;
        System.out.println(Thread.currentThread().getName());
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() &#123;
            @Override
            public void run() &#123;
                System.out.println(Thread.currentThread().getName());
            &#125;
        &#125;, 1000, 1000);
    &#125;
&#125;
</code></pre>
<h3 id="两种方式的对比"><a href="#两种方式的对比" class="headerlink" title="两种方式的对比"></a>两种方式的对比</h3><h4 id="方法1-实现Runnable接口更好"><a href="#方法1-实现Runnable接口更好" class="headerlink" title="方法1(实现Runnable接口更好)"></a><span style = "color:blue">方法1(实现Runnable接口更好)</span></h4><h5 id="实现多线程——常见面试问题"><a href="#实现多线程——常见面试问题" class="headerlink" title="实现多线程——常见面试问题"></a>实现多线程——常见面试问题</h5><ul>
<li><p><span style = "color:red"><strong>实现Runnable接口和继承Thread类哪种方式更好？</strong></span></p>
<ul>
<li><h5 id="从代码架构角度"><a href="#从代码架构角度" class="headerlink" title="从代码架构角度"></a>从代码架构角度</h5></li>
</ul>
<blockquote>
<p>本意是想让我们的执行类和任务的具体内容解耦，关系不那么密切，从架构角度好<br>★ Runnable具体描述的是工作的内容和线程的启动没有什么关系<br>★ Thread是维护整个线程的: 线程的启动、线程状态更改、线程结束，这两个本身的任务很分明的，不应该过度耦合[未来会发生很难扩展的问题]</p>
</blockquote>
<ul>
<li><h5 id="新建线程损耗"><a href="#新建线程损耗" class="headerlink" title="新建线程损耗"></a>新建线程损耗</h5></li>
</ul>
<blockquote>
<p>★ Runnable 在线程池更高级的用法中，一定不是每个任务都去新建一个线程的，为了提高整体的效率会让有限数量的线程由我们自己来确定，10个线程可以运行成千上万个任务。减少了新建线程的损耗。<br>可以把任务作为一个参数直接传递给线程池，线程池里面用固定的线程去执行任务不需要每次都新建和销毁线程，这样大大降低了线程的开销。</p>
<p>★ Runnable 如果用这个不得不去把线程损耗承担起来，有的时候run方法执行的比较少，开销的少比不上新建线程的开销[捡了芝麻丢了西瓜]。</p>
</blockquote>
<ul>
<li><h5 id="Java不支持双继承"><a href="#Java不支持双继承" class="headerlink" title="Java不支持双继承"></a>Java不支持双继承</h5></li>
</ul>
<blockquote>
<p>public class ThreadStyle extends Thread,Date (×)<br>Class cannot extend multiple classes</p>
<p>从语法的角度不允许继承多个类，一旦选定了一个父类就无法更改了[一辈子就被定死了]。在创建线程起就限制了代码的可扩展性，如果实现Runnable接口就不会出现这个问题，实现接口并不仅仅只能实现一个，实现接口后还可以继承类</p>
<blockquote>
<p>public class RunnableStyle extends Thread implements Runnable,Callable</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="两种方法的本质对比"><a href="#两种方法的本质对比" class="headerlink" title="两种方法的本质对比"></a><span style = "color:blue">两种方法的本质对比</span></h4><h5 id="方法一：最终调用target-run"><a href="#方法一：最终调用target-run" class="headerlink" title="方法一：最终调用target.run();"></a><span style = "color:red">方法一：最终调用target.run();</span></h5><blockquote>
<p>此方法本质是传入类后调用！<br>Ctrl+F12可以精确查找方法<br>@Override<br>public void run(){<br>    if(target !&#x3D; null){<br>        target.run()<br>    }<br>}<br>而target是什么呢？实际上就是我们写的<br>@Override<br>public void run() {<br>    System.<em>out</em>.println(“用Runnable方法实现线程”);<br>}</p>
</blockquote>
<h5 id="方法二：run-整个都被重写"><a href="#方法二：run-整个都被重写" class="headerlink" title="方法二：run()整个都被重写"></a><span style = "color:red">方法二：run()整个都被重写</span></h5><blockquote>
<p>整个重写代码</p>
</blockquote>
<h4 id="若同时使用这两种方法会发生什么？"><a href="#若同时使用这两种方法会发生什么？" class="headerlink" title="若同时使用这两种方法会发生什么？"></a>若同时使用这两种方法会发生什么？</h4><ul>
<li><h5 id="从面向对象的思想去考虑"><a href="#从面向对象的思想去考虑" class="headerlink" title="从面向对象的思想去考虑"></a>从面向对象的思想去考虑</h5></li>
</ul>
<pre><code class="java">com/imooc/interniew/createthreads/BothRunnableThread.java
package com.imooc.interniew.createthreads;
/**
 * 描述：     同时使用RUNNABLE和Thread两种方式实现线程
 */
public class BothRunnableThread &#123;

    public static void main(String[] args) &#123;
        Thread t1 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;实现Runnable接口的方式&quot;);
            &#125;
        &#125;) &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;我来自Thread&quot;);
            &#125;
        &#125;;
        t1.start();
    &#125;
&#125;
=========================================================
我来自Thread
---------------------------------------------------------
因为 run重写会被覆盖！！子类覆盖父类时 实行子类方法
@Override
public void run()&#123;
    if(target != null)&#123;
        target.run()
    &#125;
&#125;
</code></pre>
<h5 id="其他观点分析"><a href="#其他观点分析" class="headerlink" title="其他观点分析"></a>其他观点分析</h5><ul>
<li><p><strong>线程池</strong>创建线程也算是一种新建线程的方式 [把那两种方式进行包装]</p>
</li>
<li><p>通过<strong>Callable</strong>创建线程，也算是一种新建线程的方式</p>
</li>
<li><p>定时器[方法二：extends Thread]</p>
<pre><code class="java">package com.imooc.interniew.createthreads;

import java.util.Timer;
import java.util.TimerTask;

/**
 * 描述：     利用定时器新建线程
 */
public class TimerDemo &#123;

    public static void main(String[] args) &#123;
        System.out.println(Thread.currentThread().getName());
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() &#123;
            @Override
            public void run() &#123;
                System.out.println(Thread.currentThread().getName());
            &#125;
        &#125;, 1000, 1000);
    &#125;
&#125;
=======================================================
main     //两个不一致证明新建了一个线程
Timer-0
Timer-0
......
</code></pre>
</li>
<li><p>匿名内部类</p>
</li>
<li><p>Lambda表达式</p>
</li>
</ul>
<h5 id="实现多线程——常见面试问题-1"><a href="#实现多线程——常见面试问题-1" class="headerlink" title="实现多线程——常见面试问题"></a>实现多线程——常见面试问题</h5><ul>
<li>有多少种实现线程的方法？5点思路<ul>
<li>从<strong>不同的角度</strong>看，会有不同的答案</li>
<li>经典答案是<strong>两</strong>种</li>
<li>我们看原理，两种<strong>本质</strong>都是一样的</li>
<li>具体<strong>展开</strong>说其他方式</li>
</ul>
</li>
</ul>
<h5 id="总结：最精准的描述"><a href="#总结：最精准的描述" class="headerlink" title="总结：最精准的描述"></a>总结：最精准的描述</h5><blockquote>
<p>准确地讲：创建线程只有一种方法那就是构造Thread类，而实现线程的执行单元有两种方式<br>  ★ 方法一：实现<strong>Runnable</strong>接口的run方法，并把Runnable实例传給Thread类<br>  ★ 方法二：重写Thread的run方法(继承<strong>Thread</strong>类)<br>多线程的实现方法，在代码种写法千变万化，但其本质<strong>万变不离其宗</strong></p>
</blockquote>
<h3 id="线程的生命周期是什么？"><a href="#线程的生命周期是什么？" class="headerlink" title="线程的生命周期是什么？"></a>线程的生命周期是什么？</h3><h5 id="线程有几种状态？"><a href="#线程有几种状态？" class="headerlink" title="线程有几种状态？"></a>线程有几种状态？</h5><ul>
<li>有哪<strong>6</strong>种状态</li>
<li><strong>每个状态</strong>是什么含义？</li>
<li>状态间的转化？</li>
<li><strong>阻塞</strong>状态是什么？</li>
</ul>
<h5 id="每个状态是什么含义？"><a href="#每个状态是什么含义？" class="headerlink" title="每个状态是什么含义？"></a>每个状态是什么含义？</h5><ul>
<li>New</li>
<li>Runnable [从new到调用start方法]</li>
<li>Blocked [线程状态由sychronized修饰]</li>
<li>Waiting</li>
<li>Timed Waiting</li>
<li>Terminated</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/215ff6397d1cc14f17c11471dc420af64d92ea83/data/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" style="zoom: 200%;" />



<h3 id="状态转换的注意点和阻塞"><a href="#状态转换的注意点和阻塞" class="headerlink" title="状态转换的注意点和阻塞"></a>状态转换的注意点和阻塞</h3><pre><code class="java">com/imooc/interniew/NewRunnableTerminated.java
package com.imooc.interniew;

/**
 * 描述：     演示New、Runnable、Terminated状态。
 */
public class NewRunnableTerminated &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        Thread thread = new Thread();
        //打印出NEW的状态 线程被创建但没有启动会打出new状态
        System.out.println(thread.getState());
        thread.start();
        //打印出Runnable状态 线程被启动后打印runnable状态
        System.out.println(thread.getState());
        Thread.sleep(100);
        //打印出TERMINATED状态 打印terminate状态
        System.out.println(thread.getState());
    &#125;
&#125;
=================================================================================
NEW
RUNNABLE
TERMINATED

Process finished with exit code 0
</code></pre>
<pre><code class="java">com/imooc/interniew/BlockedWaitingTimedWaiting.java
package com.imooc.interniew;

/**
 * 描述：     展示Blocked、Waiting、Timed_Waiting状态
 */
public class BlockedWaitingTimedWaiting implements Runnable &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        Runnable runnable = new BlockedWaitingTimedWaiting();
        Thread t1 = new Thread(runnable);
        t1.start();
        Thread t2 = new Thread(runnable);
        t2.start();
        Thread.sleep(10);
        //打印Timed_Waiting状态，因为正在执行Thread.sleep(1000);
        System.out.println(t1.getState());
        //打印出BLOCKED状态，因为t2拿不到synchronized锁[线程1还在休眠]
        System.out.println(t2.getState());

        Thread.sleep(1300);
        //打印出WAITING状态，以为执行了wait()
        System.out.println(t1.getState());
    &#125;

    @Override
    public void run() &#123;
        syn();
    &#125;

    private synchronized void syn() &#123; //锁！！
        try &#123;
            Thread.sleep(1000);
            wait();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
=================================================================================
TIMED_WAITING
BLOCKED
WAITING
</code></pre>
<h5 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h5><ul>
<li>一般习惯而言，把<strong>Blocked</strong>(被阻塞)、<strong>Waiting</strong>(等待)、<strong>Timed_waiting</strong>(计时等待)都称为阻塞状态</li>
<li>不仅仅是Blocked</li>
</ul>
<h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a><span style = "color:red">分布式面试题</span></h1><h5 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h5><ul>
<li>饭店厨师的例子<ul>
<li>一个厨师</li>
<li>多个厨师</li>
<li>术业有专攻：配菜师、洗菜工</li>
</ul>
</li>
<li>实际项目的演进过程<ul>
<li>一个项目，大而全</li>
<li>多台机器，部署同样的应用</li>
<li>分布式：权限系统、员工系统、请假系统</li>
</ul>
</li>
</ul>
<h5 id="分布式和单体结构哪个更好？-脱离业务场景和发展阶段的空谈就是耍流氓"><a href="#分布式和单体结构哪个更好？-脱离业务场景和发展阶段的空谈就是耍流氓" class="headerlink" title="分布式和单体结构哪个更好？[脱离业务场景和发展阶段的空谈就是耍流氓]"></a>分布式和单体结构哪个更好？[脱离业务场景和发展阶段的空谈就是耍流氓]</h5><table>
<thead>
<tr>
<th></th>
<th>传统单体架构</th>
<th>分布式架构</th>
</tr>
</thead>
<tbody><tr>
<td>新人的学习成本</td>
<td>业务逻辑成本高</td>
<td>架构逻辑成本高</td>
</tr>
<tr>
<td>部署、运维</td>
<td>容易</td>
<td>发布频繁、发布顺序复杂、运维难</td>
</tr>
<tr>
<td>隔离性</td>
<td>一损俱损，殃及鱼池</td>
<td>故障影响范围小</td>
</tr>
</tbody></table>
<h3 id="CAP理论是什么？-只选其二-三者不可兼得"><a href="#CAP理论是什么？-只选其二-三者不可兼得" class="headerlink" title="CAP理论是什么？[只选其二 三者不可兼得]"></a>CAP理论是什么？[只选其二 三者不可兼得]</h3><ul>
<li>C(Consistency, 一致性)：读操作是否总能读到前一个写操作的结果</li>
<li>A(Availability, 可用性)：非故障节点应该在合理的时间内做出合理的响应</li>
<li>P(Partition tolerance, 分区容错性)：当出现网络分区现象后，系统能够继续运行</li>
</ul>
<h5 id="CAP怎么选？"><a href="#CAP怎么选？" class="headerlink" title="CAP怎么选？"></a>CAP怎么选？</h5><ul>
<li>CP或者AP</li>
<li>在什么场合，可用性高于一致性？</li>
</ul>
<h3 id="为什么需要Docker？"><a href="#为什么需要Docker？" class="headerlink" title="为什么需要Docker？"></a>为什么需要Docker？</h3><ul>
<li>Docker：用来装程序以及环境的容器</li>
<li><strong>环境配置</strong>的难题</li>
<li>虚拟机</li>
</ul>
<h5 id="Docker的用途是什么？"><a href="#Docker的用途是什么？" class="headerlink" title="Docker的用途是什么？"></a>Docker的用途是什么？</h5><ul>
<li>提供<strong>统一</strong>的环境</li>
<li>提供<strong>快速拓展</strong>、弹性伸缩的云服务</li>
<li>防止其他用户的进程把服务器资源<strong>占用过多</strong></li>
</ul>
<p>Docker的架构是什么样的？</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/28665426b3b7f9351280ab4c58b1ea388391f211/data/image%E9%95%9C%E5%83%8F.jpg"></p>
<h5 id="Docker的网络模式有哪些？"><a href="#Docker的网络模式有哪些？" class="headerlink" title="Docker的网络模式有哪些？"></a>Docker的网络模式有哪些？</h5><ul>
<li><strong>Bridge</strong> [桥接 用外面主机的端口号映射到里面的端口号 实现了一座桥]</li>
<li><strong>Host</strong> [里面的容器不会获得独立的网络配置 不会使用虚拟网卡ip 而是使用宿主机上的ip和端口号]</li>
<li>None [不需要网络模式]</li>
</ul>
<h3 id="Nginx的适用场景有哪些？"><a href="#Nginx的适用场景有哪些？" class="headerlink" title="Nginx的适用场景有哪些？"></a>Nginx的适用场景有哪些？</h3><ul>
<li><p>HTTP的<strong>反向代理</strong>服务器</p>
</li>
<li><p><strong>动态静态</strong>资源分离</p>
<ul>
<li>不分离会<strong>变慢</strong></li>
<li>静态资源<strong>无需经过Tomcat</strong>，Tomcat只负责处理动态请求</li>
<li>后缀为gif的时候，Nginx会直接获取到当前请求的文件并返回</li>
<li>静态资源服务器</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/93ef10f6db6a389181a9f20268c6c4b8b82c46d7/data/%E6%AD%A3%E5%90%91_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_.jpg"></p>
<h3 id="Nginx常用命令有哪些？"><a href="#Nginx常用命令有哪些？" class="headerlink" title="Nginx常用命令有哪些？"></a>Nginx常用命令有哪些？</h3><pre><code class="java">/usr/sbin/nginx 启动
-h 帮助
-c 读取指定的配置文件
-t 测试
-v 版本
-s信号
  stop 立即停止(不再接收任何请求立刻停止)  
  quit 优雅停止(不接收了但目前的请求要作完)
  reload 重启
  reopen 更换日志文件
</code></pre>
<h3 id="Zookeeper有哪些节点类型？"><a href="#Zookeeper有哪些节点类型？" class="headerlink" title="Zookeeper有哪些节点类型？"></a>Zookeeper有哪些节点类型？</h3><ul>
<li>持久节点</li>
<li>临时节点</li>
<li>顺序节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/15f1b158dfd61ad9498e5febc8d809e4dcb7f0af/data/Znode%E8%8A%82-%20%E6%A0%91%E5%BD%A2%E5%9B%BE.jpg"></p>
<h3 id="为什么要用消息队列？什么场景用？"><a href="#为什么要用消息队列？什么场景用？" class="headerlink" title="为什么要用消息队列？什么场景用？"></a>为什么要用消息队列？什么场景用？</h3><ul>
<li>系统<strong>解耦</strong></li>
<li><strong>异步</strong>调用</li>
<li>流量<strong>削峰</strong></li>
</ul>
<h5 id="消息队列RabbitMQ核心概念？"><a href="#消息队列RabbitMQ核心概念？" class="headerlink" title="消息队列RabbitMQ核心概念？"></a>消息队列RabbitMQ核心概念？</h5><p>同一个RabbitMQ的Server下建立不同的虚拟主机，他们之间是相互独立的，用于不同的业务线。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8fc65400c147b4cda128b49a11d646330a5860fc/data/RabiitMQ%E6%B6%88%E6%81%AF%E6%B5%81%E8%BD%AC%E6%96%B9%E5%BC%8F.jpg"></p>
<h5 id="交换机工作模式有哪4种？"><a href="#交换机工作模式有哪4种？" class="headerlink" title="交换机工作模式有哪4种？"></a>交换机工作模式有哪4种？</h5><ul>
<li><p><strong>fanout</strong>：广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的</p>
</li>
<li><p><strong>direct</strong>：根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/df64342f867398846ad29a0cb944a8490cd247b0/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-direct.jpg"></p>
<ul>
<li><p><strong>topic</strong>：比如消息严重性怎么样、只想记录error模块的用户信息</p>
<ul>
<li><p>***** 可以替代一个单词</p>
</li>
<li><p><strong>#</strong> 可以替代零个或多个单词</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76b7e6d6ebbac01f8f73850149fefbf50ca51712/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-topic%E7%94%9F%E4%BA%A7%E8%80%85.jpg"></p>
<ul>
<li><strong>headers</strong>：根据发送消息内容中的headers属性来匹配</li>
</ul>
<h1 id="微服务面试题"><a href="#微服务面试题" class="headerlink" title="微服务面试题"></a><span style = "color:red">微服务面试题</span></h1><h3 id="微服务有哪两大门派？"><a href="#微服务有哪两大门派？" class="headerlink" title="微服务有哪两大门派？"></a>微服务有哪两大门派？</h3><ul>
<li><strong>Spring Cloud</strong>：众多子项目</li>
<li><strong>dubbo</strong>：高性能、轻量级的开源RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</li>
<li>dubbo提供的能力只是SpringCloud的一部分<strong>子集</strong></li>
</ul>
<h5 id="Spring-Cloud核心组件有哪些？"><a href="#Spring-Cloud核心组件有哪些？" class="headerlink" title="Spring Cloud核心组件有哪些？"></a>Spring Cloud核心组件有哪些？</h5><table>
<thead>
<tr>
<th align="center">核心组件</th>
<th align="center">Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务注册中心</td>
<td align="center">Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td align="center">服务调用</td>
<td align="center">Spring Cloud Netflix Feign</td>
</tr>
<tr>
<td align="center">服务网关</td>
<td align="center">Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td align="center">断路器</td>
<td align="center">Spring Cloud Netflix Hystrix</td>
</tr>
</tbody></table>
<h5 id="画一下Eureka架构"><a href="#画一下Eureka架构" class="headerlink" title="画一下Eureka架构"></a>画一下Eureka架构</h5><ul>
<li>EureKa <strong>Server</strong> 和 EureKa <strong>Client</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6a3bfcded810da5a827559f3b8f868a0de867787/data/Eureka%E6%9E%B6%E6%9E%84.png"></p>
<ul>
<li><strong>集群</strong> [只要能获得一个Eureka Server 就能获得整个信息]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f756e06eed90edb75c6b3b6f234eee57763d8811/data/Eureka%E6%9E%B6%E6%9E%84-%E9%9B%86%E7%BE%A4.png"></p>
<h5 id="负载均衡的两种类型是什么？"><a href="#负载均衡的两种类型是什么？" class="headerlink" title="负载均衡的两种类型是什么？"></a>负载均衡的两种类型是什么？</h5><ul>
<li><strong>客户端</strong>负载均衡(Ribbon)</li>
<li><strong>服务端</strong>负载均衡(Nginx)</li>
</ul>
<h5 id="负载均衡有哪些策略？"><a href="#负载均衡有哪些策略？" class="headerlink" title="负载均衡有哪些策略？"></a>负载均衡有哪些策略？</h5><ul>
<li>RandomRule表示<strong>随机</strong>策略</li>
<li>RoundRobinRule表示<strong>轮询</strong>策略</li>
<li>ResponseTimeWeightedRule<strong>加权</strong>，根据每一个Server的平均响应时间动态加权</li>
</ul>
<h5 id="为什么需要断路器？"><a href="#为什么需要断路器？" class="headerlink" title="为什么需要断路器？"></a>为什么需要断路器？</h5><p>防止线程突然卡住，当发现某个模块不可用时，把它摘除不影响主要流程。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e441bfbcf0e2cf07f9d53564669b2dbd90533142/data/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%96%AD%E8%B7%AF%E5%99%A8.jpg"></p>
<h5 id="为什么需要网关？"><a href="#为什么需要网关？" class="headerlink" title="为什么需要网关？"></a>为什么需要网关？</h5><ul>
<li>签名校验、登录校验<strong>冗余</strong>问题</li>
<li>统一对外，安全 [对恶意IP进行拦截 打出日志]</li>
</ul>
<h5 id="Dubbo的工作流程是什么？"><a href="#Dubbo的工作流程是什么？" class="headerlink" title="Dubbo的工作流程是什么？"></a>Dubbo的工作流程是什么？</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/2ded5afda4ae8cff8392f5ccf0217657054c8981/data/Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<h3 id="彩蛋：学习编程知识的优质路径"><a href="#彩蛋：学习编程知识的优质路径" class="headerlink" title="彩蛋：学习编程知识的优质路径"></a>彩蛋：学习编程知识的优质路径</h3><ul>
<li><h5 id="宏观上"><a href="#宏观上" class="headerlink" title="宏观上"></a>宏观上</h5></li>
</ul>
<ol>
<li>并不是靠工作年限，有的人工作5年技术却还是只懂皮毛</li>
<li>要有强大的责任心，不放过任何bug，找到原因并去解决，这就是提高</li>
<li>主动：永远不会觉得自己的时间多余，重构、优化、学习、总结等</li>
<li>敢于承担：虽然这个技术难题以前没有碰到过，但是在一定的了解调研后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程种，进步是飞速的</li>
<li>关心产品，关心业务，而不是只写代码</li>
</ol>
<ul>
<li><h5 id="微观上"><a href="#微观上" class="headerlink" title="微观上"></a>微观上</h5></li>
</ul>
<ol>
<li>系统化的学习 看经典的书籍</li>
<li>看官方文档</li>
<li>自己动手写代码，尝试应用到项目中</li>
<li>不理解的内容参考多个知识来源，综合判断</li>
<li>学习开源项目，总结代码</li>
</ol>
<h3 id="Synchronized和Lock"><a href="#Synchronized和Lock" class="headerlink" title="Synchronized和Lock"></a>Synchronized和Lock</h3><h5 id="Lock简介、地址、作用"><a href="#Lock简介、地址、作用" class="headerlink" title="Lock简介、地址、作用"></a>Lock简介、地址、作用</h5><ul>
<li>锁是一种工具，用于控制对<strong>共享资源</strong>的访问</li>
<li>Lock和Synchronized，这两个是最常见的锁，它们都可以达到<strong>线程安全</strong>的目的，但是在使用上和功能上又有较大的不同</li>
<li>Lock并不是用来替代Synchronized的，而是当使用Synchronized不合适或不满足要求的时候，来提供<strong>高级功能</strong>的</li>
<li>Lock接口最常见的实现类是<strong>ReentrantLock</strong></li>
<li><strong>lock()、tryLock()、tryLock(long time, TimeUnit unit)</strong> 和<strong>locakInterruptibly()</strong></li>
</ul>
<h5 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h5><ul>
<li>lock()就是最普通的获取锁。如果锁已经被其他线程获取，则进行等待</li>
<li>Lock不会像Synchronized一样在<strong>异常时自动释放锁</strong></li>
<li>因此最佳实践是，在<strong>finally中释放锁</strong>，以保证发生异常时锁一定被释放</li>
<li>lock()方法不能被中断，这就会带来很大隐患：一旦陷入<strong>死锁</strong>，lock()就会陷入永久等待</li>
</ul>
<h5 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h5><ul>
<li>tryLock()用来<strong>尝试获取锁</strong>，如果当前锁没有被其他线程占用，则获取成功，则返回true，否则返回false，代表获取锁失败</li>
<li>相对比lock，这样的方法显然功能更加强大了，我们可以根据是否能获取到锁来<strong>决定后续程序的行为</strong></li>
<li>该方法会<strong>立即返回</strong>，即便在拿不到锁时不会一直在那等</li>
</ul>
<h5 id="tryLock-long-time-TimeUnit-unit-：超时就放弃"><a href="#tryLock-long-time-TimeUnit-unit-：超时就放弃" class="headerlink" title="tryLock(long time, TimeUnit unit)：超时就放弃"></a>tryLock(long time, TimeUnit unit)：超时就放弃</h5><p><strong>locakInterruptibly()<strong>：相当于tryLock(long time, TimeUnit unit)把超时时间设置为无限。在等待锁的过程中，线程可以被</strong>中断</strong></p>
<p><strong>unlock()：</strong>解锁 [最应该写在try…finally里面]</p>
<h4 id="Synchronized和Lock有什么不同？"><a href="#Synchronized和Lock有什么不同？" class="headerlink" title="Synchronized和Lock有什么不同？"></a>Synchronized和Lock有什么不同？</h4><h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h5><ul>
<li>保障资源线程的安全：目的和作用都是为了 保障资源线程的安全<br>[使用Synchronized后被保护的代码块最多只有一个线程可以访问]</li>
<li>可重入 [不然就必须在获得第二个锁前释放]</li>
</ul>
<pre><code class="java">com/imooc/interniew/Reentrant.java
package com.imooc.interniew;

/**
 * 描述：     synchronized可重入
 */
public class Reentrant &#123;

    public synchronized void f1() &#123;
        System.out.println(&quot;f1方法被运行了&quot;);
        f2();
    &#125;

    public synchronized void f2() &#123;
        System.out.println(&quot;f2方法被运行了&quot;);
    &#125;

    public static void main(String[] args) &#123;
        Reentrant reentrant = new Reentrant();
        reentrant.f1();
    &#125;
&#125;
========================================================
f1方法被运行了
f2方法被运行了
</code></pre>
<ul>
<li><strong>ReentrantLock</strong> [实现了Lock接口]</li>
</ul>
<h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><ul>
<li><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><ul>
<li>Synchronized用在方法上、用在同步代码块上 [隐式]</li>
<li>Lock必须使<u>用lock方法加锁</u>，<u>unlock方法解锁</u> [显式]</li>
</ul>
</li>
<li><h6 id="加解锁顺序不同"><a href="#加解锁顺序不同" class="headerlink" title="加解锁顺序不同"></a>加解锁顺序不同</h6><ul>
<li>Synchronized是java内部控制，自动加解锁</li>
<li>Lock可以手动调节</li>
</ul>
</li>
<li><h6 id="Synchronized锁不够灵活"><a href="#Synchronized锁不够灵活" class="headerlink" title="Synchronized锁不够灵活"></a>Synchronized锁不够灵活</h6><ul>
<li>Synchronized获得了一个锁 其他的只能等待</li>
<li>Lock获得锁很灵活 可以随时调整</li>
</ul>
</li>
<li><h6 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h6><ul>
<li>Synchronized由差到好 目前同等程度的性能</li>
</ul>
</li>
</ul>
<h3 id="你知道有几种锁？"><a href="#你知道有几种锁？" class="headerlink" title="你知道有几种锁？"></a>你知道有几种锁？</h3><ul>
<li><p><span style = "color:blue"><strong>共享锁</strong>[读写锁] 和 <strong>独占锁</strong>[排他锁]</span></p>
</li>
<li><p>共享锁，又称为读锁，获得<strong>共享锁</strong>之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但<strong>无法修改和删除</strong>数据</p>
</li>
<li><p>共享锁和排他锁的典型是读写锁<strong>ReentrantReadWriteLock</strong>，其中<strong>读锁是共享锁，写锁是独享锁</strong></p>
</li>
</ul>
<h5 id="读写锁的作用"><a href="#读写锁的作用" class="headerlink" title="读写锁的作用"></a>读写锁的作用</h5><ul>
<li>在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也<strong>浪费了一定的资源：多个读操作同时进行，并没有线程安全问题</strong></li>
<li>在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果<strong>没有写锁的情况下，读是无阻塞的</strong>，提高了程序的执行效率</li>
</ul>
<h5 id="读写锁的规则"><a href="#读写锁的规则" class="headerlink" title="读写锁的规则"></a>读写锁的规则</h5><ul>
<li>多个线程只申请读锁，都可以申请到</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁</li>
<li>一句话总结：要么是<strong>一个</strong>或<strong>多个</strong>线程同时有<strong>读锁</strong>，要么一个线程有写锁，但是两者不会同时出现(要么多读，要麽一写)</li>
</ul>
<h5 id="公平锁-和-非公平锁"><a href="#公平锁-和-非公平锁" class="headerlink" title="公平锁 和 非公平锁"></a><span style = "color:blue">公平锁 和 非公平锁</span></h5><ul>
<li>公平指的是按照线程请求的顺序，来分配锁</li>
<li>非公平指的是不完全按照请求的顺序，在一定情况下，可以插队 </li>
<li>注意：<strong>非公平</strong>也同样不提倡 ”插队“ 行为，这里的非公平，指的是”在合适的时机”插队，而不是盲目插队</li>
<li>什么是合适的时机呢？<ul>
<li>买火车票被插队的例子，排队买的例子</li>
</ul>
</li>
<li>实际情况并不是这样的，java设计者这样设计的目的是为了<strong>提高效率</strong></li>
<li><span style = "color:red"><strong>避免唤醒带来的空档期，提升吞吐量</strong></span></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>公平锁</td>
<td>各线程公平平等，每个线程在等待一段时间后，总有执行的机会</td>
<td>更慢，吞吐量更小</td>
</tr>
<tr>
<td>不公平锁</td>
<td>更快，吞吐量更大</td>
<td>有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行</td>
</tr>
</tbody></table>
<h5 id="悲观锁-和-乐观锁"><a href="#悲观锁-和-乐观锁" class="headerlink" title=" 悲观锁 和 乐观锁"></a><span style = "color:blue"> 悲观锁 和 乐观锁</span></h5><ul>
<li>从<strong>是否锁住资源</strong>的角度分类</li>
</ul>
<h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><ul>
<li>如果我不锁住这个资源，别人就会来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失</li>
<li>java中悲观锁的实现就是<code>synchronized</code>和<code>Lock</code>相关类</li>
</ul>
<h5 id="乐观锁-1"><a href="#乐观锁-1" class="headerlink" title="乐观锁"></a>乐观锁</h5><ul>
<li>认为自己在处理操作的时候不会有其他线程来干扰，所以并<strong>不会锁住</strong>被操作对象</li>
<li>在更新的时候，去对比在我修改的期间数据有没有被其他人改变过，如果<strong>没被改变过</strong>，就说明真的是只有我自己在操作，那我就正常去修改数据</li>
<li>如果数据和我<strong>一开始拿到的不一样</strong>了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略</li>
<li>乐观锁的实现一般都是利用<strong>CAS</strong>算法来实现的</li>
</ul>
<h6 id="在数据库中"><a href="#在数据库中" class="headerlink" title="在数据库中"></a>在数据库中</h6><ul>
<li><strong>select for update</strong>就是悲观锁</li>
<li>用<strong>version</strong>控制数据库就是乐观锁</li>
</ul>
<h6 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h6><pre><code class="mysql">添加一个字段lock_version
先查询这个更新语句的vesion：SELECT * FROM table
然后
UPDATE SET num = 2, 
version = version + 1 WHERE version = 1 AND id = 5
如果version被更新了等于2，不一样就会更新出错，这就是乐观锁的原理
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a6265784dee5e723d22bfceddca39a9a2afe91b8/data/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.jpg"></p>
<h5 id="自旋锁-和-非自旋锁"><a href="#自旋锁-和-非自旋锁" class="headerlink" title="自旋锁 和 非自旋锁"></a><span style = "color:blue">自旋锁 和 非自旋锁</span></h5><ul>
<li>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间</li>
<li>如果同步代码块的内容过于简单，<strong>状态转换消耗的时间有可能比用户代码执行的时间还要长</strong></li>
<li>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复线程的花费可能会让系统<strong>得不偿失</strong></li>
<li>如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁 </li>
<li>而为了让当前线程“<strong>稍等一下</strong>”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而<strong>避免切换线程的开销</strong>，这就是自旋锁。</li>
</ul>
<h5 id="自旋锁的缺点"><a href="#自旋锁的缺点" class="headerlink" title="自旋锁的缺点"></a>自旋锁的缺点</h5><ul>
<li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源</li>
<li>在自旋的过程中，一直消耗CPU，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的</li>
</ul>
<h5 id="可重入锁-和-非可重入锁"><a href="#可重入锁-和-非可重入锁" class="headerlink" title="可重入锁 和 非可重入锁"></a><span style = "color:blue">可重入锁 和 非可重入锁</span></h5><ul>
<li><p>什么是可重入 [摇一个号拿N个牌]</p>
</li>
<li><p>好处 [避免死锁]</p>
</li>
</ul>
<h5 id="可中断锁-和-不可中断锁"><a href="#可中断锁-和-不可中断锁" class="headerlink" title="可中断锁 和 不可中断锁"></a><span style = "color:blue">可中断锁 和 不可中断锁</span></h5><ul>
<li>可中断锁 [可以随时中断]</li>
</ul>
<h3 id="死锁相关"><a href="#死锁相关" class="headerlink" title="死锁相关"></a>死锁相关</h3><h5 id="写一个必然死锁的例子？"><a href="#写一个必然死锁的例子？" class="headerlink" title="写一个必然死锁的例子？"></a>写一个必然死锁的例子？</h5><h6 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h6><ul>
<li><p>发生在<strong>并发</strong>中</p>
</li>
<li><p><strong>互不相让</strong>：当两个(或更多)线程(或进程)相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁</p>
</li>
<li><p>一图胜千言</p>
</li>
<li><p>线程A持有锁1但试图获取锁2 线程B持有锁2但视图获取锁1</p>
</li>
</ul>
<h5 id="多个线程造成死锁的情况"><a href="#多个线程造成死锁的情况" class="headerlink" title="多个线程造成死锁的情况"></a>多个线程造成死锁的情况</h5><ul>
<li>如果多个线程之间的依赖关系是<strong>环形</strong>，存在环路的锁的依赖关系，那么也可能会发生死锁</li>
</ul>
<h5 id="死锁的影响"><a href="#死锁的影响" class="headerlink" title="死锁的影响"></a>死锁的影响</h5><ul>
<li>死锁的影响在不同系统中是不一样的，这取决于系统对死锁的处理能力<ul>
<li><strong>数据库</strong>中：检测并放弃事务</li>
<li><strong>JVM</strong>中：无法自动处理</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ce81bd17386cbcc3d04b5ef352a1c492ec9b0668/data/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81.jpg"></p>
<h5 id="几率不高但危害大"><a href="#几率不高但危害大" class="headerlink" title="几率不高但危害大"></a>几率不高但危害大</h5><ul>
<li>不一定发生，但是遵守<strong>墨菲定律</strong></li>
<li>一旦发生，多是<strong>高并发</strong>场景，影响用户多</li>
<li>整个<strong>系统崩溃</strong>、子系统崩溃、性能降低</li>
<li>压力测试<strong>无法找出</strong>所有潜在的死锁</li>
</ul>
<pre><code class="java">deadlock/DeadLock.java
package deadlock;

/**
 * 描述：     必然发生死锁
 */
public class DeadLock implements Runnable &#123;

    public int flag;

    static Object o1 = new Object();
    static Object o2 = new Object();

    public void run() &#123;
        System.out.println(&quot;开始执行&quot;);
        if (flag == 1) &#123;
            synchronized (o1) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o2) &#123;
                    System.out.println(&quot;成功获取到了两把锁&quot;);
                &#125;
            &#125;
        &#125;
        if (flag == 2) &#123;
            synchronized (o2) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o1) &#123;
                    System.out.println(&quot;成功获取到了两把锁&quot;);
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        DeadLock r1 = new DeadLock();
        DeadLock r2 = new DeadLock();
        r1.flag = 1;
        r2.flag = 2;
        new Thread(r1).start();
        new Thread(r2).start();
    &#125;
&#125;
====================================== 分析 =======================================
★ 当类的对象flag=1时(T1),先锁定O1,睡眠500毫秒，然后锁定O2;
★ 而T1在睡眠的时候另一个flag=2的对象(T2)线程启动，先锁定O2，睡眠500毫秒，等待T1释放O1;
★ T1睡眠结束后需要锁定O2才能继续执行，而此时O2已被T2锁定
★ T2睡眠结束后需要锁定O1才能继续执行，而此时O1已被T1锁定
★ T1、T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁
</code></pre>
<h3 id="哲学家就餐问题？"><a href="#哲学家就餐问题？" class="headerlink" title="哲学家就餐问题？"></a>哲学家就餐问题？</h3><ul>
<li>先拿起左手的筷子</li>
<li>然后拿起右手的筷子</li>
<li>如果筷子被人使用了，那就等别人用完</li>
</ul>
<pre><code class="java">while(true)&#123; //伪代码
    think();
    pick_up_left_fork();
    pick_up_right_fork();
    eat();
    put_down_right_fork();
    put_down_left_fork();
&#125;
</code></pre>
<pre><code class="java">package deadlock;

/**
 * 描述：     哲学家就餐问题导致的死锁
 */
public class DiningPhilosophers &#123;

    public static class Philosopher implements Runnable &#123;

        private Object leftChopstick;

        public Philosopher(Object leftChopstick, Object rightChopstick) &#123;
            this.leftChopstick = leftChopstick;
            this.rightChopstick = rightChopstick;
        &#125;

        private Object rightChopstick;

        @Override
        public void run() &#123;
            try &#123;
                while (true) &#123;
                    doAction(&quot;Thinking&quot;);
                    synchronized (leftChopstick) &#123;
                        doAction(&quot;Picked up left chopstick&quot;);
                        synchronized (rightChopstick) &#123;
                            doAction(&quot;Picked up right chopstick - eating&quot;);
                            doAction(&quot;Put down right chopstick&quot;);
                        &#125;
                        doAction(&quot;Put down left chopstick&quot;);
                    &#125;
                &#125;
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        private void doAction(String action) throws InterruptedException &#123;
            System.out.println(Thread.currentThread().getName() + &quot; &quot; + action);
            Thread.sleep((long) (Math.random() * 10));
        &#125;
    &#125;

    public static void main(String[] args) &#123;//五个哲学家方便管理
        Philosopher[] philosophers = new Philosopher[5];
        Object[] chopsticks = new Object[philosophers.length];
        for (int i = 0; i &lt; chopsticks.length; i++) &#123;
            chopsticks[i] = new Object();
        &#125;
        for (int i = 0; i &lt; philosophers.length; i++) &#123;
            Object leftChopstick = chopsticks[i]; //从0开始 i为5 所以底下要加1 但是越界就取余
            Object rightChopstick = chopsticks[(i + 1) % chopsticks.length];
            //领导调节(检测与恢复策略) [定期巡视命令哲学家] 让最后一个 跟别人不一样 
            //别人都是先左后右面 它是先后面再左边 避免了环路的形成
            //直接避免死锁发生！！！！！
            if (i == philosophers.length - 1) &#123;
                philosophers[i] = new Philosopher(rightChopstick, leftChopstick);
            &#125; else &#123;
                philosophers[i] = new Philosopher(leftChopstick, rightChopstick);
            &#125;
            new Thread(philosophers[i], &quot;哲学家&quot; + (i + 1) + &quot;号&quot;).start();
        &#125;
    &#125;
&#125;
=============================================================================
哲学家4号 Thinking
哲学家5号 Thinking
哲学家3号 Thinking
哲学家1号 Thinking
哲学家2号 Thinking
哲学家2号 Picked up left chopstick
哲学家3号 Picked up left chopstick
哲学家1号 Picked up left chopstick
哲学家4号 Picked up left chopstick
哲学家4号 Picked up right chopstick - eating
哲学家4号 Put down right chopstick
哲学家4号 Put down left chopstick
哲学家4号 Thinking
哲学家3号 Picked up right chopstick - eating
哲学家3号 Put down right chopstick
哲学家3号 Put down left chopstick
哲学家4号 Picked up left chopstick
哲学家4号 Picked up right chopstick - eating
哲学家4号 Put down right chopstick
哲学家4号 Put down left chopstick
哲学家3号 Thinking
哲学家2号 Picked up right chopstick - eating
哲学家4号 Thinking
哲学家2号 Put down right chopstick
哲学家4号 Picked up left chopstick
哲学家4号 Picked up right chopstick - eating
.............................
发生死锁的时候哲学家都拿着左边的筷子
原理：Thread.sleep((long) (Math.random() * 10));
random到了一个更大的数
</code></pre>
<h5 id="多种解决策略"><a href="#多种解决策略" class="headerlink" title="多种解决策略"></a>多种解决策略</h5><ul>
<li>服务员检查(避免策略) [提前看一看是否发生死锁]</li>
<li><strong>改变一个哲学家拿叉子的顺序</strong>(避免策略)</li>
<li>餐票(避免策略)</li>
<li>领导调节(检测与恢复策略) [定期巡视命令哲学家]</li>
</ul>
<h5 id="实际工程中如何避免死锁"><a href="#实际工程中如何避免死锁" class="headerlink" title="实际工程中如何避免死锁"></a>实际工程中如何避免死锁</h5><h6 id="①-设置超时时间"><a href="#①-设置超时时间" class="headerlink" title="① 设置超时时间"></a>① 设置<strong>超时</strong>时间</h6><ul>
<li>Lock的<strong>tryLock</strong>(long timeout, TImeUnit unit)</li>
<li><strong>synchronized</strong>不具备尝试锁的能力</li>
<li>造成超时的可能性很多：发生了死锁、线程陷入死循环、线程执行很慢</li>
<li>获取锁失败：打日志、发报警邮件、<strong>重启</strong>等</li>
<li>代码演示：<strong>退一步海阔天空</strong></li>
</ul>
<pre><code class="java">package deadlock;

import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 描述：     用tryLock来避免死锁
 */
public class TryLockDeadlock implements Runnable &#123;

    int flag = 1;
    static Lock lock1 = new ReentrantLock();
    static Lock lock2 = new ReentrantLock();

    public static void main(String[] args) &#123;
        TryLockDeadlock r1 = new TryLockDeadlock();
        TryLockDeadlock r2 = new TryLockDeadlock();
        r1.flag = 1;
        r2.flag = 0;
        new Thread(r1).start();
        new Thread(r2).start();
    &#125;

    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            if (flag == 1) &#123;
                try &#123;
                    if (lock1.tryLock(800, TimeUnit.MILLISECONDS)) &#123;
                        System.out.println(&quot;线程1获取到了锁1&quot;);
                        Thread.sleep(new Random().nextInt(1000));
                        if (lock2.tryLock(800, TimeUnit.MILLISECONDS)) &#123;
                            System.out.println(&quot;线程1获取到了锁2&quot;);
                            System.out.println(&quot;线程1成功获取到了两把锁&quot;);
                            lock2.unlock();
                            lock1.unlock();
                            break;
                        &#125; else &#123;
                            System.out.println(&quot;线程1尝试获取锁2失败，已重试&quot;);
                            lock1.unlock();
                            Thread.sleep(new Random().nextInt(1000));
                        &#125;
                    &#125; else &#123;
                        System.out.println(&quot;线程1获取锁1失败，已重试&quot;);
                    &#125;
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if (flag == 0) &#123;
                try &#123;
                    if (lock2.tryLock(3000, TimeUnit.MILLISECONDS)) &#123;
                        System.out.println(&quot;线程2获取到了锁2&quot;);

                        Thread.sleep(new Random().nextInt(1000));
                        if (lock1.tryLock(3000, TimeUnit.MILLISECONDS)) &#123;
                            System.out.println(&quot;线程2获取到了锁1&quot;);
                            System.out.println(&quot;线程2成功获取到了两把锁&quot;);
                            lock1.unlock();
                            lock2.unlock();
                            break;
                        &#125; else &#123;
                            System.out.println(&quot;线程2尝试获取锁1失败，已重试&quot;);
                            lock2.unlock();
                            Thread.sleep(new Random().nextInt(1000));
                        &#125;
                    &#125; else &#123;
                        System.out.println(&quot;线程2获取锁2失败，已重试&quot;);
                    &#125;
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
====================================================================================
线程1获取到了锁1
线程2获取到了锁2
线程1尝试获取锁2失败，已重试 【正是有了线程1的释放 才让线程2拿到了锁1】
线程2获取到了锁1
线程2成功获取到了两把锁
线程1获取到了锁1
线程1获取到了锁2
线程1成功获取到了两把锁
</code></pre>
<h6 id="②-多使用并发类而不是自己设置锁"><a href="#②-多使用并发类而不是自己设置锁" class="headerlink" title="② 多使用并发类而不是自己设置锁"></a>② 多使用并发类而不是自己设置锁</h6><h6 id="③-尽量降低锁的使用粒度：用不同的锁而不是一个锁"><a href="#③-尽量降低锁的使用粒度：用不同的锁而不是一个锁" class="headerlink" title="③ 尽量降低锁的使用粒度：用不同的锁而不是一个锁"></a>③ 尽量降低锁的使用粒度：用不同的锁而不是一个锁</h6><h6 id="④-如果能使用同步代码块，就不使用同步方法：自己锁定锁对象"><a href="#④-如果能使用同步代码块，就不使用同步方法：自己锁定锁对象" class="headerlink" title="④ 如果能使用同步代码块，就不使用同步方法：自己锁定锁对象"></a>④ 如果能使用同步代码块，就不使用同步方法：自己锁定锁对象</h6><h6 id="⑤-给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践"><a href="#⑤-给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践" class="headerlink" title="⑤ 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践"></a>⑤ 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践</h6><h3 id="Hashmap为什么-线程-不安全？"><a href="#Hashmap为什么-线程-不安全？" class="headerlink" title="Hashmap为什么[线程]不安全？"></a>Hashmap为什么[线程]不安全？</h3><ul>
<li><p>i++</p>
<ul>
<li>第一个步骤是<strong>读取</strong></li>
<li>第二个步骤是<strong>增加</strong></li>
<li>第三个步骤是<strong>保存</strong></li>
</ul>
<p>有可能会发生线程不安全的情况<br><img src="https://raw.githubusercontent.com/P-luminary/images/ae6685b2f5be7812a77134895bdd7c4fe843933f/data/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8.jpg"></p>
</li>
<li><p>同时put碰撞导致数据丢失</p>
</li>
<li><p>可见性问题无法保证</p>
</li>
</ul>
<h3 id="final的作用是什么？有哪些用法？"><a href="#final的作用是什么？有哪些用法？" class="headerlink" title="final的作用是什么？有哪些用法？"></a>final的作用是什么？有哪些用法？</h3><ul>
<li>final修饰<strong>变量</strong></li>
<li>final修饰<strong>方法</strong></li>
<li>final修饰<strong>类</strong></li>
</ul>
<h5 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h5><ul>
<li>早期<ul>
<li>锁定</li>
<li>final效率：早期的Java实现版本中，会将final方法转为内嵌调用</li>
</ul>
</li>
<li>现在<ul>
<li><strong>类防止被继承、方法防止被重写、变量防止被修改</strong></li>
<li>天生是<strong>线程安全</strong>的，而不需要额外的同步开销</li>
</ul>
</li>
</ul>
<h5 id="final的3种用法"><a href="#final的3种用法" class="headerlink" title="final的3种用法"></a>final的3种用法</h5><h6 id="final修饰变量：赋值时机"><a href="#final修饰变量：赋值时机" class="headerlink" title="final修饰变量：赋值时机"></a>final修饰变量：赋值时机</h6><ul>
<li><p><strong>属性</strong>被声明为final后，该变量则<strong>只能被赋值一次</strong>。且一旦被赋值，final的变量就<strong>不能再被改变</strong>，无论如何也不会改变</p>
</li>
<li><p>final修饰<strong>变量</strong></p>
<ul>
<li><p>final instance variable (类中的final属性) </p>
<ul>
<li>第一种是在声明变量的<strong>等号右边</strong>直接赋值</li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰变量
 */
public class FinalVariable &#123;

    public static int a = 5;

    public static void main(String[] args) &#123;
        FinalVariable.a = 8;
    &#125;
&#125;
</code></pre>
<ul>
<li>第二种就是<strong>构造函数</strong>中赋值</li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰变量
 */
public class FinalVariable &#123;

    public final int a;

    public testFinal(int a) &#123;
        this.a = b;
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<ul>
<li>第三种就是在类的<strong>初始代码块种</strong>赋值(不常用)</li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰变量
 */
public class FinalVariable &#123;

    public static final int a;

    static &#123;
        a = 9;
    &#125;

    void testFinal() &#123;
        final int b;
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<ul>
<li>如果不采用第一种赋值方法，那么就必须在第2、3种挑一个来赋值，而不能不赋值，这是final语法所 规定的</li>
</ul>
</li>
<li><p>final <strong>static</strong> variable (类中的static final属性)</p>
<ul>
<li>两种赋值时机：除了在声明变量的<strong>等号右边</strong>直接赋值外，static final变量还可以用<strong>static初始代码块</strong>赋值，但是不能用普通的初始代码块赋值</li>
</ul>
</li>
<li><p>final <strong>local</strong> variable (方法中的final变量)</p>
<ul>
<li>和前两种不同，由于这里的变量是在方法里的，所以没有构造函数，也不存在初始代码块</li>
<li>final local variable不规则赋值时机，只要求在<strong>使用前必须赋值</strong>，这和方法中的非final变量的要求也是一样的</li>
</ul>
</li>
</ul>
<h6 id="为什么要规定赋值时机？"><a href="#为什么要规定赋值时机？" class="headerlink" title="为什么要规定赋值时机？"></a>为什么要规定赋值时机？</h6><ul>
<li>如果初始化不赋值，<strong>后续赋值，就是从null变成你的赋值</strong>，这就违反final不变的规则了</li>
</ul>
</li>
<li><p>final修饰<strong>方法</strong></p>
<ul>
<li><strong>构造方法</strong>不允许final修饰</li>
<li><strong>不可被重写</strong>，也就是不能被<strong>override</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰方法
 */
public class FinalMethodDemo&#123;

    public void drink() &#123;
    &#125;

    public final void eat() &#123;
    &#125;
&#125;

class SubClass extends FinalMethodDemo &#123;

    @Override
    public void drink() &#123;
        super.drink();
    &#125;

//    @Override
//    public void eat() &#123;
//        super.drink();
//    &#125;
&#125;
</code></pre>
</li>
<li><p>final修饰<strong>类</strong></p>
<ul>
<li><strong>不可被继承</strong></li>
<li>例如经典的<strong>String类就是final</strong>的，我们从见过哪个类是继承String类的</li>
</ul>
</li>
</ul>
<h3 id="单例模式你会写吗？"><a href="#单例模式你会写吗？" class="headerlink" title="单例模式你会写吗？"></a><span style = "color:red">单例模式你会写吗？</span></h3><ul>
<li><h5 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h5></li>
</ul>
<p>保证只有一个实例且提供只有一个全局入口</p>
<ul>
<li><h5 id="为什么需要单例：节省内存和计算、保证结果正确、方便管理"><a href="#为什么需要单例：节省内存和计算、保证结果正确、方便管理" class="headerlink" title="为什么需要单例：节省内存和计算、保证结果正确、方便管理"></a>为什么需要单例：节省内存和计算、保证结果正确、方便管理</h5></li>
<li><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>无状态的工具类</li>
<li>全局信息类</li>
</ul>
</li>
<li><h5 id="单例模式的8种写法"><a href="#单例模式的8种写法" class="headerlink" title="单例模式的8种写法"></a>单例模式的8种写法</h5><ul>
<li>饿汉式(静态常量) [可用]</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     饿汉式（静态常量）（可用）
 */
public class Singleton1 &#123;

    private Singleton1() &#123;

    &#125;

    private final static Singleton1 INSTANCE = new Singleton1();
// [未达到懒加载] 直接创建出来了
    public static Singleton1 getInstance() &#123;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>饿汉式(静态代码块) [可用]</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     饿汉式（静态代码块）（可用） // [未达到懒加载]
 */
public class Singleton2 &#123;

    private Singleton2() &#123;

    &#125;

    static &#123;
        INSTANCE = new Singleton2();
    &#125;
    private final static Singleton2 INSTANCE;

    public static Singleton2 getInstance() &#123;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>懒汉式(线程不安全) <strong>[不可用]</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程不安全）
 */
public class Singleton3 &#123;

    private Singleton3() &#123;

    &#125;

    private static Singleton3 INSTANCE;

    public static Singleton3 getInstance() &#123;
        if (INSTANCE == null) &#123;//第一次访问方法
            INSTANCE = new Singleton3();//初始化
        &#125;
        //此时如果两个线程同时访问，都是null，就创造了两个初始化 违反单例模式
        return INSTANCE; //已经被初始化 就返回
    &#125;
&#125;
</code></pre>
<ul>
<li>懒汉式(线程安全，同步方法) <strong>[不推荐用]</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程安全，同步方法）（不推荐）
 */
public class Singleton4 &#123;

    private Singleton4() &#123;

    &#125;

    private static Singleton4 INSTANCE;
    //synchronized同步关键字 最多一个线程访问
    //不推荐用的原因是因为一旦适用了synchronized同步关键字 线程就要排队 并发量大
    public synchronized static Singleton4 getInstance() &#123;
        if (INSTANCE == null) &#123;
            INSTANCE = new Singleton4();
        &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//方法上不进行同步了
package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程安全，同步方法）（不推荐）
 */
public class Singleton5 &#123;

    private Singleton5() &#123;

    &#125;

    private static Singleton5 INSTANCE;

    public static Singleton5 getInstance() &#123;
        if (INSTANCE == null) &#123; //此时不会存在两个线程同时出来了
            synchronized (Singleton5.class) &#123;
                //假如第一个执行完了 第二个进去执行 那么结果还是生成了两个 不符合单例
                INSTANCE = new Singleton5();
            &#125;
        &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>双重检查[推荐用]</strong><ul>
<li>新建一个对象，但还未初始化</li>
<li>调用构造函数等来初始化该对象</li>
<li>把对象指向引用</li>
</ul>
</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程安全，同步方法）（不推荐）
 */
public class Singleton6 &#123;

    private Singleton6() &#123;//2

    &#125;

    private static volatile Singleton6 INSTANCE;

    public static Singleton6 getInstance() &#123;
        if (INSTANCE == null) &#123;
            synchronized (Singleton6.class) &#123;
                if (INSTANCE == null) &#123; //3
                    //就不会出现多个结果了
                    INSTANCE = new Singleton6 //1
                &#125;
            &#125;
        &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>静态内部类[推荐用]</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     静态内部类写法（推荐用）
 */
public class Singleton7 &#123;

    private Singleton7() &#123;

    &#125;

    private static class SingletonInstance &#123;
        private static Singleton7 INSTANCE = new Singleton7();
    &#125;

    public static Singleton7 getInstance() &#123;
        return SingletonInstance.INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>枚举[推荐用]</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     枚举单例模式
 */
public enum Singleton8 &#123;
    //1.写法简洁
    //2.线程安全
    //3.防止反射
    
    INSTANCE;
&#125;
</code></pre>
</li>
</ul>
<h5 id="不同写法对比"><a href="#不同写法对比" class="headerlink" title="不同写法对比"></a>不同写法对比</h5><ul>
<li><strong>饿汉</strong>：简单，但是没有lazy loading</li>
<li><strong>懒汉</strong>：有线程安全问题</li>
<li><strong>静态内部类</strong>：可用</li>
<li><strong>双重检查：面试用</strong></li>
<li><strong>枚举：最好</strong></li>
</ul>
<h5 id="单例模式面试常见问题"><a href="#单例模式面试常见问题" class="headerlink" title="单例模式面试常见问题"></a>单例模式面试常见问题</h5><ul>
<li>饿汉式的缺点？[没有懒加载]</li>
<li>懒汉式的缺点？[不可以保证线程安全]</li>
<li><strong>为什么要用double-check</strong>？不用就不安全吗？</li>
<li>为什么双重检查模式要用<strong>volatile</strong>？</li>
<li>应该如何选择，<strong>用哪种单例的实现方案最好</strong>？<ul>
<li>单元素的枚举类型已经成为实现Singleton的最佳方法</li>
<li>写法简单</li>
<li>线程安全有保障</li>
<li>避免反射破坏单例</li>
</ul>
</li>
</ul>
<h3 id="面试避坑指南-1"><a href="#面试避坑指南-1" class="headerlink" title="面试避坑指南"></a>面试避坑指南</h3><ul>
<li>何时投简历 [Offer数量只会越来越少，越早越好]  秋招7-9月 社招金3银4 </li>
<li>信息尽量全面</li>
<li>技术栈契合</li>
<li>慎用”<strong>精通</strong>“ [对源码有很多熟悉] &#x3D;&gt; 多写<strong>熟悉</strong></li>
<li>面试无处不在 [如果没时间可以申请换一个时间节点 并询问对方是否有时间]</li>
<li>提前调试设备</li>
<li>仪容仪表、提前到场 [提前5分钟左右联系面试官]</li>
<li>确认问题 [实在不会可以说思路设想]</li>
<li>问面试官的问题 [提前查公司信息 我了解到我们公司… 可不可以介绍一下… 未来规划… 技术栈…]</li>
</ul>
<h3 id="哪些软素质值得面试官认可？"><a href="#哪些软素质值得面试官认可？" class="headerlink" title="哪些软素质值得面试官认可？"></a>哪些软素质值得面试官认可？</h3><ul>
<li>基本能力：聆听、沟通表达、<strong>学习能力</strong></li>
<li>工作能力：<strong>协作</strong>、<strong>执行力</strong>、管理能力</li>
<li>个人素质：技术自驱力、韧性、积极开放的心态</li>
</ul>
<h3 id="面试课总结"><a href="#面试课总结" class="headerlink" title="面试课总结"></a>面试课总结</h3><ul>
<li>Spring Boot常见面试题</li>
<li>线程常见面试题</li>
<li>分布式的面试题</li>
<li>Docker相关面试题</li>
<li>Nginx和Zookeeper相关面试题</li>
<li>RabbitMQ相关面试题</li>
<li>微服务相关</li>
<li>彩蛋：学习方法</li>
<li>锁分类、死锁</li>
<li>HashMap和final</li>
<li>单例模式[高频考点]</li>
<li>面试避坑指南</li>
<li>重要的软实力</li>
</ul>
<h4 id="2024-5-9-14-34-在创新楼B105-JSP动态网页设计课上-完成了java-4399全部课程的学习"><a href="#2024-5-9-14-34-在创新楼B105-JSP动态网页设计课上-完成了java-4399全部课程的学习" class="headerlink" title="2024.5.9 14:34   在创新楼B105-JSP动态网页设计课上  完成了java+4399全部课程的学习"></a><span style = "color:red">2024.5.9 14:34   在创新楼B105-JSP动态网页设计课上  完成了java+4399全部课程的学习</span></h4>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/05/04/后端/Zookeeper-Dubbo应用与面试/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
    </div>

    <div class="page-index">

        

        <span class="current">
            1
        </span>

        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/12">
                <span class="page-num">
                    12
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>