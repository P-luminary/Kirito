
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2025/02/09/面试/洪哥面试题/">
        <h2>
            洪哥面试题
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/2/9
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="线程池的执行流程大致如下"><a href="#线程池的执行流程大致如下" class="headerlink" title="线程池的执行流程大致如下:"></a><strong>线程池的执行流程大致如下</strong>:</h4><p>线程池：ThreadPoolExecutor<br>一开始new的时候没有 是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><strong>怎么确定核心线程数和最大线程数</strong>？</p>
<h6 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h6><ul>
<li>CPU密集型任务：如果任务是CPU密集型的，即任务主要是进行计算而不是等待I&#x2F;O操作，核心线程数通常设置为CPU核心数加1。这样可以确保CPU在忙于计算的同时，还有额外的线程来处理可能出现的临时高峰。【纯内存计算 不涉及到网络计算和io计算】<ul>
<li>八个核 创建十个cpu 没意义 因为最多并发只是8，建议保持一致或者+1，<u>减少加入队列和创建队列的开销</u></li>
<li>先把其当成io密集 因为层级不一样 不断压测去逼近最理想值</li>
</ul>
</li>
<li>I&#x2F;O密集型任务：对于I&#x2F;O密集型任务，由于线程在等待I&#x2F;O操作时会阻塞，因此可以设置更多的核心线程数。一个常用的经验法则是核心线程数设置为CPU核心数的两倍。【线程数越多越好】【压测无限逼近取最合适的线程数】</li>
</ul>
<h6 id="最大线程数"><a href="#最大线程数" class="headerlink" title="最大线程数"></a>最大线程数</h6><p>需要一开始创建好线程等着访问来，如果 <u>核心&#x3D;最大</u>，此时没有临时线程</p>
<h4 id="创建线程有几种方式（必会）"><a href="#创建线程有几种方式（必会）" class="headerlink" title="创建线程有几种方式（必会）"></a>创建线程有几种方式（必会）</h4><p>1.继承Thread类并重写 run 方法创建线程，实现简单但不可以继承其他类<br>2.实现Runnable接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。<br>3.实现 Callable接口并重写 call 方法，创建线程。可以获取线程执行结果的返回值，并且可以抛出异常。<br>4.使用线程池创建（使用java.util.concurrent.Executor接口）</p>
<ul>
<li>想获得线程池里的返回结果用什么？<strong>execute + submit</strong></li>
<li>线程有哪些状态？ java线程有哪些状态？</li>
<li>线程池有哪些状态？</li>
</ul>
<pre><code class="java">// 1. 继承Thread类并重写run方法
class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;线程运行中 - 继承Thread类&quot;);
    &#125;
&#125;

// 2. 实现Runnable接口并重写run方法
class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;线程运行中 - 实现Runnable接口&quot;);
    &#125;
&#125;

// 3. 实现Callable接口并重写call方法
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable&lt;String&gt; &#123;
    @Override
    public String call() throws Exception &#123;
        System.out.println(&quot;线程运行中 - 实现Callable接口&quot;);
        return &quot;Callable线程返回结果&quot;;
    &#125;
&#125;

// 4. 使用线程池创建线程
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadCreationExamples &#123;
    public static void main(String[] args) &#123;
        // 继承Thread类创建线程
        Thread thread1 = new MyThread();
        thread1.start();

        // 实现Runnable接口创建线程
        Thread thread2 = new Thread(new MyRunnable());
        thread2.start();

        // 实现Callable接口创建线程
        MyCallable callable = new MyCallable();
        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable);
        Thread thread3 = new Thread(futureTask);
        thread3.start();
        try &#123;
            // 获取线程执行结果的返回值
            String result = futureTask.get();
            System.out.println(result);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        // 使用线程池创建线程
        ExecutorService executor = Executors.newFixedThreadPool(2);
        executor.execute(new MyRunnable()); // 提交Runnable任务
        executor.submit(new MyCallable()); // 提交Callable任务
        executor.shutdown(); // 关闭线程池
    &#125;
&#125;
</code></pre>
<h4 id="线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池"><a href="#线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池" class="headerlink" title="线程池哪些类型？通过JUC[包]的executes可以创建这四个类型的线程池"></a>线程池哪些类型？<del>通过JUC[包]的executes可以创建这四个类型的线程池</del></h4><p>问题：为什么阿里巴巴不推荐JUC？有可能会出现OOM、资源浪费</p>
<ul>
<li>单线程线程池</li>
<li>可缓存线程池&#x2F;定长</li>
<li>变长的线程池</li>
<li>定时任务的线程池</li>
</ul>
<h4 id="java-线程池创建时核心参数-高薪常问"><a href="#java-线程池创建时核心参数-高薪常问" class="headerlink" title="java 线程池创建时核心参数(高薪常问)"></a>java 线程池创建时核心参数(高薪常问)</h4><p>核心线程池大小、线程池创建线程的最大个数(核心+非核心[临时线程])、临时线程存活时间、时间单位、阻塞队列、线程工厂(指定线程池创建线程的命名)、拒绝策略<br><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>阻塞队列常用的队列</u>：</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
</ol>
<h4 id="线程池的应用要有实际的业务场景"><a href="#线程池的应用要有实际的业务场景" class="headerlink" title="线程池的应用要有实际的业务场景"></a>线程池的应用<del>要有实际的业务场景</del></h4><ul>
<li>异步任务处理：将任务提交到线程池异步执行，而不阻塞主线程</li>
</ul>
<blockquote>
<p>假设我们有一个电商平台，其中一个核心业务是处理用户订单。在订单处理过程中，我们需要执行以下任务：</p>
<ol>
<li>验证订单信息（例如：检查库存、验证用户信息等）。</li>
<li>计算订单金额（包括商品价格、折扣、运费等）。</li>
<li>生成订单并保存到数据库。</li>
<li>发送订单确认邮件给用户。</li>
</ol>
<p>由于这些任务相对独立，并且处理时间可能较长，我们希望在不影响用户操作的前提下异步执行它们。以下是使用线程池处理这些异步任务的模拟代码：</p>
<pre><code class="java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

class Order &#123;
    // 订单信息
    private String orderId;
    private String userId;
    private double amount;

    // 构造函数、getter和setter省略
&#125;

class OrderService &#123;
    private ExecutorService executorService = Executors.newFixedThreadPool(10); // 假设线程池大小为10

    // 处理订单
    public void processOrder(Order order) &#123;
        // 1. 验证订单信息
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;验证订单信息: &quot; + order.getOrderId());
            // 假设验证成功
        &#125;);

        // 2. 计算订单金额
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;计算订单金额: &quot; + order.getOrderId());
            // 假设计算成功，设置订单金额
            order.setAmount(100.0); // 示例金额
        &#125;);

        // 3. 生成订单并保存到数据库
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;生成订单并保存到数据库: &quot; + order.getOrderId());
            // 假设保存成功
        &#125;);

        // 4. 发送订单确认邮件
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;发送订单确认邮件: &quot; + order.getOrderId());
            // 假设邮件发送成功
        &#125;);
    &#125;

    // 关闭线程池
    public void shutdown() &#123;
        try &#123;
            executorService.shutdown();
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) &#123;
                executorService.shutdownNow();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            executorService.shutdownNow();
        &#125;
    &#125;
&#125;

public class ThreadPoolApplication &#123;
    public static void main(String[] args) &#123;
        OrderService orderService = new OrderService();
        Order order = new Order();
        order.setOrderId(&quot;ORDER12345&quot;);
        order.setUserId(&quot;USER12345&quot;);

        // 处理订单
        orderService.processOrder(order);

        // 假设主线程还有其他任务，这里模拟等待其他任务完成
        try &#123;
            Thread.sleep(5000); // 等待5秒
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        // 关闭线程池
        orderService.shutdown();
    &#125;
&#125;

</code></pre>
<p>在这个模拟场景中，我们创建了一个 <code>OrderService</code> 类，它包含一个线程池用于异步处理订单的各个步骤。当用户创建订单时，<code>processOrder</code> 方法会将订单处理的各个任务提交到线程池中异步执行。这样，主线程不会被阻塞，可以继续处理其他用户请求或执行其他任务。在所有任务都提交到线程池后，主线程可能会执行其他逻辑，最后调用 <code>shutdown</code> 方法来优雅地关闭线程池。</p>
</blockquote>
<h4 id="你单独部署过项目吗？"><a href="#你单独部署过项目吗？" class="headerlink" title="你单独部署过项目吗？"></a>你单独部署过项目吗？</h4><p>前端打包ng配置文件<br>git所有人都用 需要拉分支 maven打包后端 包放到远程服务器 java -jar 启动！【不应该有人去做】<br>有专门工具去流水线制作 → <strong>Jenkins</strong>是一个开源的自动化服务器，它可以帮助您实现自动化构建、测试和部署项目   <strong><u>JenKins + docker 做自动化部署</u></strong><br>部署是建立本地的项目再推到服务器</p>
<blockquote>
<p><strong>安装 Docker</strong>：确保你的部署服务器上安装了 Docker。<br><strong>安装 Jenkins</strong>：可以通过 Docker 安装 Jenkins，或者直接在服务器上安装。</p>
<h4 id="步骤-1：安装-Jenkins-和-Docker"><a href="#步骤-1：安装-Jenkins-和-Docker" class="headerlink" title="步骤 1：安装 Jenkins 和 Docker"></a>步骤 1：安装 Jenkins 和 Docker</h4><p>确保 Jenkins 和 Docker 在服务器上都已经安装并运行。</p>
<h4 id="步骤-2：配置-Jenkins"><a href="#步骤-2：配置-Jenkins" class="headerlink" title="步骤 2：配置 Jenkins"></a>步骤 2：配置 Jenkins</h4><ol>
<li><p><strong>启动 Jenkins</strong>：</p>
<p>使用 Docker 启动 Jenkins：</p>
<pre><code>docker run -d --name jenkins -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts
</code></pre>
</li>
<li><p><strong>访问 Jenkins</strong>：在浏览器中访问 <code>http://&lt;服务器地址&gt;:8080</code>，并按照指示完成 Jenkins 的初始设置。</p>
</li>
<li><p><strong>安装必要的插件</strong>：安装 Docker、Git 等相关插件。</p>
</li>
</ol>
<h4 id="步骤-3：创建-Jenkins-任务"><a href="#步骤-3：创建-Jenkins-任务" class="headerlink" title="步骤 3：创建 Jenkins 任务"></a>步骤 3：创建 Jenkins 任务</h4><ol>
<li><p><strong>新建任务</strong>：在 Jenkins 主页上，点击“新建任务”。</p>
</li>
<li><p><strong>配置源码管理</strong>：配置 Git 仓库地址。</p>
</li>
<li><p><strong>配置构建触发器</strong>：选择合适的触发器。</p>
</li>
<li><p><strong>配置构建环境</strong>：勾选“Build inside a Docker container”。</p>
</li>
<li><p><strong>添加构建步骤</strong>：</p>
<ul>
<li><p><strong>执行 Shell</strong>：</p>
<pre><code>docker build -t myapp .
</code></pre>
</li>
</ul>
</li>
<li><p><strong>添加构建后操作</strong>：</p>
<ul>
<li><p><strong>Push built image</strong>：如果需要将镜像推送到 Docker 仓库，填写仓库信息。</p>
</li>
<li><p><strong>执行 Shell</strong>：</p>
<pre><code>docker stop myapp || true
docker rm myapp || true
docker run -d --name myapp -p 8080:8080 myapp
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="步骤-4：执行构建"><a href="#步骤-4：执行构建" class="headerlink" title="步骤 4：执行构建"></a>步骤 4：执行构建</h4><p>保存配置后，可以手动触发构建或者等待触发器自动执行构建。</p>
<h4 id="步骤-5：验证部署"><a href="#步骤-5：验证部署" class="headerlink" title="步骤 5：验证部署"></a>步骤 5：验证部署</h4><p>构建完成后，访问服务器的指定端口（例如 <code>http://&lt;服务器地址&gt;:8080</code>），验证应用是否成功部署。</p>
</blockquote>
<h4 id="你的期望薪资？"><a href="#你的期望薪资？" class="headerlink" title="你的期望薪资？"></a>你的期望薪资？</h4><p>我目前的薪资是8000，考虑到我即将承担的职责和我的职业发展，我期望的薪资是在现有基础上有所提升，大约在8000到10000之间。当然，我对整体的薪酬包[包括福利、奖金和职业发展机会]也很感兴趣。薪资是如何构成的，包括固定工资、奖金、股权、福利等。</p>
<h4 id="线程池场景题"><a href="#线程池场景题" class="headerlink" title="线程池场景题"></a>线程池场景题</h4><h6 id="核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？"><a href="#核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？" class="headerlink" title="核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？"></a>核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？</h6><p>在您描述的线程池配置下，当有6个并发任务到来时，这些任务的处理情况如下：</p>
<ul>
<li>核心线程数是5，意味着线程池会首先创建5个线程来处理任务。</li>
<li>当第6个任务到来时，由于核心线程都在忙，线程池会将这个任务放入队列中，因为队列的大小也是10。</li>
</ul>
<p>所以，在这种情况下，线程池中会有6个任务：<strong>5个任务正在被5个核心线程处理，另外1个任务在队列中等待</strong>。线程池并没有达到最大线程数10个，因为当前的任务数量和队列容量还未超过核心线程数和队列的总和。</p>
<blockquote>
<p>在您提供的线程池配置下（核心线程数5个，最大线程数10个，队列容量10个），当6个并发任务到来时，线程池不会立即创建10个线程，原因如下：</p>
<ol>
<li><strong>核心线程数优先</strong>：线程池首先会使用核心线程来处理任务。核心线程数是5，所以前5个任务会分别由5个核心线程来处理。</li>
<li><strong>队列缓冲</strong>：当核心线程都在忙碌时，额外的任务会被放入队列中等待，而不是立即创建新的线程。您的队列容量是10，足以容纳当前的第6个任务。</li>
<li><strong>按需创建线程</strong>：线程池会根据任务的处理速度和队列的饱和度来决定是否需要创建超出核心线程数的线程。在您的例子中，尽管有6个并发任务，但队列还未满，因此没有必要创建额外的线程。</li>
<li><strong>最大线程数限制</strong>：最大线程数是线程池可以创建的线程数量的上限，但这并不意味着线程池会一开始就创建到这个上限。只有当队列满了，且还有新的任务到来时，线程池才会创建额外的线程（最多达到最大线程数）来处理这些任务。</li>
</ol>
<p>因此，在您的场景中，当6个并发任务到来时，线程池的操作是：</p>
<ul>
<li>5个核心线程各自处理一个任务。</li>
<li>第6个任务被放入队列中等待。</li>
</ul>
<p>此时，线程池中只有5个线程在运行，队列中有1个任务，总共6个任务。线程池不会创建额外的线程，因为当前的任务数量还未超过核心线程数和队列的总容量。只有当队列满了（即有10个任务在队列中），且还有新的任务到来时，线程池才会考虑创建额外的线程，直到达到最大线程数10个。</p>
</blockquote>
<h4 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h4><h6 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h6><ul>
<li>请求指定的资源。使用GET的目的是获取数据，</li>
<li>数据在URL中传输，通过将数据附在<strong>URL</strong>之后，以查询字符串的形式出现</li>
<li>由于数据在URL中可见，因此安全性较低，敏感数据不应通过过GET请求发送</li>
<li>URL长度限制通常在<strong>2000个字符</strong>左右，这意味着GET请求能够传输的数据有限</li>
<li><strong>可以被缓存</strong>，也会被浏览器保存在历史记录中</li>
<li>常用于<strong>信息查询、数据检索</strong>等操作.</li>
</ul>
<h6 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h6><ul>
<li>向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在<strong>请求体</strong>中。</li>
<li>数据存储在请求体(HTTP消息主体)中，不会密在URL上</li>
<li>数据不会出现在URL中，相对更安全，适合传输敏感信息。</li>
<li>理论上<strong>没有大小限制</strong>，适用于传输大量数据.</li>
<li><strong>不会被缓存</strong>，且不会保存在浏觉器历史记录中</li>
<li>常用于<strong>数据提交、表单提交</strong>等操作</li>
</ul>
<p>请求行：请求类型 请求方法 url http版本1.1 老式1.0不支持长连接<br>请求头：key value<br>   <u>常见请求头</u>： 请求数据类型，restful基于json<br><strong>Content-Type</strong>：上传文件不用application 要用 multipart&#x2F;form-data”<br><strong>Host</strong>：指定请求的服务器的域名和端口号。<br><strong>User-Agent</strong>：包含发出请求的用户代理软件信息，通常包括浏览器类型和版本<br>请求体：get请求可以有请求体<br>响应：响应行 响应体 状态码 描述<br>  <u>常见响应头</u>：<strong>Content-Type</strong>：返回数据的格式   <strong>Content-Length</strong>：响应体的长度，以字节为单位</p>
<p>post请求也可以用问号的形式拼接到浏览器 也可以用路径参数</p>
<p>很大区别：get一般放在url后面 会展示url和后面参数 会暴露传参隐私  登录接口用post来做 有密码敏感信息<br>表单、密码、长数据用post 不过怕黑客抓包 相对来说安全<br>get请求后面传参的大小限制 理论上没有限制 只是浏览器厂商会有限制<br>get用来查询 post新增提交表单</p>
<h4 id="是否上传过图片"><a href="#是否上传过图片" class="headerlink" title="是否上传过图片"></a>是否上传过图片</h4><p>阿里云是最后存储的<br>完整的上传图片应该：<br><strong>前端</strong>要配合(表单 post提交)  <strong>Content-Type</strong>：上传文件不用application 要用 <strong>multipart&#x2F;form-data</strong>”  同一个请求能边上传图片和文本数据<br><strong>后端</strong>的操作：传到后端controller接收，有一个类multipart 专门接收二进制数据 图片视频等，有很多api → get input stream封装util 调用upload上传。中小型企业都用阿里云oss 因为要考虑容灾 地震 容易数据丢失，要考虑备份→集群，服务器有物理硬件上限(要有运维成本)，文件维护很专业交给专业的人。阿里云的机房在深圳，广州的人访问会比哈尔滨的更快。光纤受物理限制 越长越有损耗。大型运营商在全国各地都有机房，可以智能判断比如哈尔滨的就去访问黑龙江服务器。CSDN内容分发(收费)</p>
<h4 id="前端传过来的图片怎么设置图片大小-有没有什么办法？"><a href="#前端传过来的图片怎么设置图片大小-有没有什么办法？" class="headerlink" title="前端传过来的图片怎么设置图片大小 有没有什么办法？"></a>前端传过来的图片怎么设置图片大小 有没有什么办法？</h4><p>思考：为什么后端要限制前端图片传的大小？<br>大图片 + 多人上传，首先后端要读到jvm内存再二进制流给到阿里云，同时并发有可能超出OM的java内存大小<br>springboot yml加文件上传大小配置</p>
<pre><code class="yaml">spring:
  servlet:
    multipart:
      max-file-size: 10MB # 单个文件的最大大小
      max-request-size: 20MB # 整个请求的最大大小，包括多个文件的总和
</code></pre>
<blockquote>
<ol>
<li><strong>读取到 JVM 内存</strong>：<ul>
<li>当前端发送图片文件到后端时，后端服务器需要接收这个文件的数据。</li>
<li>在 Java 应用程序中，接收到的文件数据首先会被加载到 JVM（Java 虚拟机）的内存中。这是因为在 Java 应用程序中处理任何数据之前，数据必须先被加载到内存中。</li>
</ul>
</li>
<li><strong>二进制流给到阿里云</strong>：<ul>
<li>一旦文件数据被加载到 JVM 内存中，后端服务通常会将这些数据以二进制流的形式上传到云存储服务，比如阿里云的对象存储服务（OSS）。</li>
<li>这个过程涉及到数据的读取和写入操作，即从 JVM 内存读取数据，然后写入到云存储服务。</li>
</ul>
</li>
<li><strong>并发可能导致内存溢出</strong>：<ul>
<li>如果有多个用户同时上传大图片，后端服务器可能会同时处理多个上传请求。</li>
<li>每个上传请求都会占用一部分 JVM 内存。如果上传的图片非常大，且并发请求的数量很多，那么所有请求加起来的内存使用量可能会迅速增加。</li>
<li>如果内存使用量超过了 JVM 分配给应用程序的内存大小（即 OutOfMemory，简称 OOM），就会发生内存溢出错误。这种错误会导致应用程序崩溃或者变得不稳定。</li>
</ul>
</li>
<li><strong>限制上传大小的重要性</strong>：<ul>
<li>为了防止内存溢出错误，后端通常会限制上传文件的大小。</li>
<li>通过限制单个文件的最大大小（<code>max-file-size</code>）和整个请求的最大大小（<code>max-request-size</code>），可以有效地控制内存的使用，避免因大量并发上传大文件而耗尽服务器内存。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="你在里面主要负责哪方面的工作？"><a href="#你在里面主要负责哪方面的工作？" class="headerlink" title="你在里面主要负责哪方面的工作？"></a>你在里面主要负责哪方面的工作？</h4><p>我之前负责后端开发 也会参与一部分<strong>设计工作</strong><br>开发完会协助测试 和前端进行联调<br>和组长一起进行测试<br>和前后端的逻辑基本上都是可以的</p>
<h4 id="上家公司的离职原因，薪资多少，薪资结构"><a href="#上家公司的离职原因，薪资多少，薪资结构" class="headerlink" title="上家公司的离职原因，薪资多少，薪资结构"></a>上家公司的离职原因，薪资多少，薪资结构</h4><p>不要说一些面试官能挑刺的理由<br><del>发展前景？表明上家公司不好</del><br><del>太想进步？表名上家公司提供的技术不好 自己技术不好</del><br>在上家公司我学习了很多 成长了很多，个人发展原因 ，想要涨薪</p>
<pre><code class="java">// 来自AI的答案 仅供参考
我在上家公司学到了很多，但我觉得为了我的职业发展，我需要寻找一个能够提供更多成长机会和挑战的职位。我想要在[技能/领域]上进一步深耕，而贵公司的职位看起来非常符合我的职业规划；我在上家公司的年薪大约在6000到7000之间；我的薪资结构主要包括基本工资、每年两次的绩效奖金、股票期权以及一些标准福利，比如健康保险、退休金计划等。此外，公司还提供了一些额外的福利，比如灵活的工作时间和远程工作的机会
</code></pre>
<h6 id="简历公司"><a href="#简历公司" class="headerlink" title="简历公司"></a>简历公司</h6><p>上家公司<strong>如果问工作不好找 为什么不先找到再离职</strong>？<br>我在这一块想好好准备面试 但是上班的时间不好分配 我想专心去找工作<br>上家工作繁忙抽不出时间去准备 所以我想多多准备<br>若<strong>异地</strong>公司 → 万能理由：现在面的公司在哪家里人就在哪[地理位置要接近 精确到哪个城市] 异地很多都线下不方便先离职专心准备</p>
<h6 id="薪资多少"><a href="#薪资多少" class="headerlink" title="薪资多少"></a>薪资多少</h6><p>现在期望12k 上家最好保证**20%-30%**区间→8-9-10k(参考城市不同)</p>
<h6 id="薪资结构"><a href="#薪资结构" class="headerlink" title="薪资结构"></a>薪资结构</h6><p>基本工资(七八成)+绩效工资(20%-30%) 有公司先扣除 有的当月发<br>A 120%  S 150%-200%  C 80%</p>
<h6 id="你对上家公司的看法"><a href="#你对上家公司的看法" class="headerlink" title="你对上家公司的看法"></a>你对上家公司的看法</h6><p>不能贬低 要说优点 学习成长了很多 同事和领导都很照顾我</p>
<h6 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h6><p>三个工作日 到 一周之间</p>
<h6 id="你离职了-现在有多少个offer了？"><a href="#你离职了-现在有多少个offer了？" class="headerlink" title="你离职了 现在有多少个offer了？"></a>你离职了 现在有多少个offer了？</h6><p>不能说一个都没有</p>
<ul>
<li>我已经有2个offer 但是一定要表达对当前公司的期待 经过我的了解 我更喜欢贵公司的发展和文化</li>
<li>我也是刚刚开始找工作…</li>
</ul>
<h4 id="你可以接受加班吗"><a href="#你可以接受加班吗" class="headerlink" title="你可以接受加班吗"></a>你可以接受加班吗</h4><p>(必须完全接受全部加班 先拿到offer再说)</p>
<h4 id="Controller和RestController的区别"><a href="#Controller和RestController的区别" class="headerlink" title="Controller和RestController的区别"></a>Controller和RestController的区别</h4><p>@RestController &#x3D; @Controller + @ResponseBody</p>
<p>@Controller如果要返回JSON&#x2F;XML等格式的数据给客户端，必须显式的使用@ResponseBody注解将返回的对象转换为HTTP响应体内容。<br>@RestController 专门为构建RESTful Web服务设计的控制器。它简化了创建API的过程，因为所有方法默认都会将返回值直接写入HTTP响应体中作为JSON或XML格式的数据。</p>
<p>@Controller可以声明一个类为一个bean 控制器用<br>@ResponseBody 具体方法和类都可以 不是包装类和字符 都可以自动转成json数据格式 更符合restful风格</p>
<h4 id="在yaml文件中定义了一些参数，该怎么调用"><a href="#在yaml文件中定义了一些参数，该怎么调用" class="headerlink" title="在yaml文件中定义了一些参数，该怎么调用"></a><strong>在yaml文件中定义了一些参数，该怎么调用</strong></h4><ul>
<li>使用 @Value 注解，这是最直接的方式，适用于简单的属性注入。是bean的注解 <strong>用${key}还可以用#</strong><ul>
<li><code>$&#123;&#125;</code>：用于注入外部配置文件的值。它告诉Spring需要从环境变量、属性文件、系统属性等地方查找相应的值。</li>
<li><code>#&#123;&#125;</code>：用于执行SpEL（Spring Expression Language，Spring表达式语言）表达式。它允许你在注入值时执行一些简单的计算或逻辑。</li>
<li>如果在多个类里引用 配置多 杂乱  可以写个配置类写一堆的属性 提供get set方法 配置类.get获取到配置</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code class="yaml"># application.yml
server:
port: 8080

custom:
property: myCustomValue
number: 42
enabled: true
</code></pre>
<pre><code class="java">import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class CustomComponent &#123;

 // 注入server.port属性
 @Value(&quot;$&#123;server.port&#125;&quot;)
 private String serverPort;

 // 注入custom.property属性
 @Value(&quot;$&#123;custom.property&#125;&quot;)
 private String customProperty;

 // 注入custom.number属性，并转换为int类型
 @Value(&quot;$&#123;custom.number&#125;&quot;)
 private int customNumber;

 // 注入custom.enabled属性，并转换为boolean类型
 @Value(&quot;$&#123;custom.enabled&#125;&quot;)
 private boolean customEnabled;

 // 使用SpEL表达式来计算值
 @Value(&quot;#&#123;$&#123;custom.number&#125; * 2&#125;&quot;)
 private int doubleCustomNumber;

 // 使用SpEL表达式来获取环境变量
 @Value(&quot;#&#123;systemProperties[&#39;os.name&#39;]&#125;&quot;)
 private String osName;

 // ... 使用注入的值进行操作

 // Getter和Setter方法
 // ...
&#125;
</code></pre>
</blockquote>
<ul>
<li>使用 @ConfigurationProperties 注解，通常会指定一个<strong>前缀</strong>（<strong>prefix</strong>），这个前缀用于指定配置文件中哪些属性应该被绑定到这个 Bean 上。然后确保主应用程序类或某个配置类上有<code>@EnableConfigurationProperties(AppProperties.class)</code> 注解<br><code>@ConfigurationProperties(prefix = &quot;prefix&quot;)</code></li>
</ul>
<h4 id="IOC和DI有了解过吗，它们的好处是什么"><a href="#IOC和DI有了解过吗，它们的好处是什么" class="headerlink" title="IOC和DI有了解过吗，它们的好处是什么"></a>IOC和DI有了解过吗，它们的好处是什么</h4><p><span style = "color:red">它们的目的是为了<strong>解耦</strong></span><br>IOC(控制反转)是Spring的两大核心之一，DI(依赖注入)<br>IOC把控制权交给spring容器<br>对象创建好之后 之间会有依赖关系 DI因此而生<br>实现方式：DI通常有四种实现方式</p>
<ul>
<li><p><strong>属性注入</strong> <del>注解注入</del></p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，用于自动装配 Bean。它可以用于字段、构造函数、方法或设置器上。当 Spring 容器启动时，它会自动查找并注入匹配的 Bean。<ul>
<li>偶尔有不影响程序运行的报错？写spring技术人员是根据jdk写，怕别人不用。</li>
</ul>
</li>
<li><code>@Resource</code> 是 Java 的注解[JDK的]，用于依赖注入，它也可以用于字段、方法或设置器上。与 <code>@Autowired</code> 不同的是，<code>@Resource</code> 默认通过名称进行匹配，如果未指定名称，则尝试通过类型进行匹配。</li>
<li>两者区别<ul>
<li>@Autowired 先根据<strong>属性类型</strong> 去容器里面找 如果找不到 再根据**属性名称[字段]**去找 如果实在找不到就会报错 [@Autowired永远不会放弃你的 尽其所能去帮你找]</li>
<li>@Resource 先根据<strong>属性名称</strong>去找 要么找不到 要么找到一个 找到就去注入 如果找不到 可以再根据<strong>属性类型</strong>去找 [类型找不到 或者 找到多个 也会报错]</li>
</ul>
</li>
</ul>
<h6 id="它俩最大的区别是什么？"><a href="#它俩最大的区别是什么？" class="headerlink" title="它俩最大的区别是什么？"></a>它俩最大的区别是什么？</h6><blockquote>
<p> <code>@Autowired</code> 更倾向于按<strong>类型注入</strong>，如果类型不唯一，则需要指定注入的名称。<br> <code>@Resource</code> 更倾向于按<strong>名称注入</strong>，如果没有指定名称，则尝试按类型注入。<br> 两者的不同在于默认的注入策略和如何处理不唯一的 Bean 定义。</p>
<p><code>@Autowired</code> 和 <code>@Resource</code> 最大的区别在于它们的默认注入策略和所依赖的注入机制：</p>
<ol>
<li><strong>默认注入策略</strong>：<ul>
<li><code>@Autowired</code>：默认是按照类型（Type）进行注入的。如果容器中存在多个相同类型的 Bean，则需要通过 <code>@Qualifier</code> 注解指定具体的 Bean 名称，或者通过设置 <code>@Autowired</code> 的 <code>required</code> 属性为 <code>false</code> 来允许没有找到匹配的 Bean 时不抛出异常。</li>
<li><code>@Resource</code>：默认是按照名称（Name）进行注入的。如果未指定名称，则尝试按类型进行注入。如果容器中存在多个相同类型的 Bean，且没有指定名称，可能会抛出异常。</li>
</ul>
</li>
<li><strong>依赖的注入机制</strong>：<ul>
<li><code>@Autowired</code>：是 Spring 框架提供的注解，因此它只能用于 Spring 管理的上下文中。</li>
<li><code>@Resource</code>：是 Java 的扩展包（javax.annotation）提供的注解，它是 JSR-250 规范的一部分，因此可以在任何实现了 JSR-250 规范的容器中使用，不仅限于 Spring。</li>
</ul>
</li>
</ol>
<p>简而言之，最大的区别在于 <code>@Autowired</code> 更侧重于<strong>类型匹配</strong>，而 <code>@Resource</code> 更侧重于<strong>名称匹配</strong>，并且 <code>@Resource</code> 是 Java 标准的一部分，具有更广泛的适用性。</p>
</blockquote>
</li>
<li><p><strong>构造函数注入</strong> [默认生成空参构造方法 若写有参构造原来无参会被覆盖 参数根据类型去找和<code>@Autowired</code>类型一样 可以写多个构造方法 如果去多个构造方法重载会报错 怎么办？加个<code>@Autowired[属性,构造方法,参数]都可加</code> <strong>不可多个方法都加@Autowired</strong>  反射会触发构造方法 @Bean &#x3D;&gt; new ] </p>
<pre><code class="java">public class MyService &#123;

    private DependencyA dependencyA;
    private DependencyB dependencyB;

    // 构造函数注入
    @Autowired
    public MyService(DependencyA dependencyA) &#123;
        this.dependencyA = dependencyA;
    &#125;

    // 另一个构造函数
    @Autowired
    public MyService(DependencyB dependencyB) &#123;
        this.dependencyB = dependencyB;
    &#125;

    // ... 其他方法 ...
&#125;
/////////////////////////////////////////////////////
在上面的例子中，由于有两个构造函数都使用了 @Autowired 注解，Spring 将无法确定使用哪一个构造函数，因此会抛出异常。要解决这个问题，你应该只在一个构造函数上使用 @Autowired 注解。
</code></pre>
</li>
<li><p>Set方法注入[原生spring 用xml去定义才有 SpringBoot没有这个注入 ]</p>
<pre><code class="java">public class MyService &#123;

    private DependencyA dependencyA;

    // Set 方法注入
    @Autowired
    public void setDependencyA(DependencyA dependencyA) &#123;
        this.dependencyA = dependencyA;
    &#125;

    // ... 其他方法 ...
&#125;
//////////////////////////////////////////////////////
在 Spring Boot 中，虽然不常用 XML 配置，但是你仍然可以通过注解来实现 Set 方法注入。
</code></pre>
</li>
<li><p><strong>普通方法注入</strong></p>
<pre><code class="java">public class MyService &#123;

    private DependencyA dependencyA;

    // 普通方法注入
    @Autowired
    public void init(DependencyA dependencyA) &#123;
        this.dependencyA = dependencyA;
    &#125;

    // ... 其他方法 ...
&#125;
//////////////////////////////////////////////////////
普通方法注入指的是在类中的任意非构造函数方法上使用 @Autowired 注解
</code></pre>
</li>
</ul>
<h4 id="测试过程有没有出现反复的困扰"><a href="#测试过程有没有出现反复的困扰" class="headerlink" title="测试过程有没有出现反复的困扰?"></a>测试过程有没有出现反复的困扰?</h4><p>客户<strong>需求频繁更改</strong><br>测试用例没有覆盖到<br>开发和测试环境未协调</p>
<p>太复杂的改动要先报备技术经理、项目经理</p>
<p>测试：自测 单元测试 专业人员</p>
<h4 id="公司使用哪些技术？"><a href="#公司使用哪些技术？" class="headerlink" title="公司使用哪些技术？"></a>公司使用哪些技术？</h4><p>后端：Redis RabbitMQ 搜索引擎 微服务常用组件 远程调用 统一网关 Springboot Springcloud MybatisPlus</p>
<h4 id="项目有多少个成员？"><a href="#项目有多少个成员？" class="headerlink" title="项目有多少个成员？"></a>项目有多少个成员？</h4><p>2前 8后 1测 1运维 1项目经理(小公司约13人左右) 要具体人数<br>自研公司？外包？</p>
<p><strong>自研公司</strong>：</p>
<ul>
<li>创业型自研公司：通常员工人数在10-50人之间，初期可能更少，只有几人到十几人。</li>
<li>成熟自研公司：员工人数可能从几十人到几百人甚至更多。</li>
</ul>
<p><strong>外包公司</strong>：</p>
<ul>
<li>小型外包公司：员工人数可能在10-50人之间。</li>
<li>中型外包公司：员工人数可能在50-200人之间。</li>
<li>大型外包公司：员工人数可能超过200人。</li>
</ul>
<h4 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h4><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>jdk1.8之前底层结构是<strong>数组+链表</strong>(key+value)  数据结构通用的[键值对+哈希表的数据结构]<br>jdk1.8以后【数组+链表+红黑树】在解决哈希冲突时有了较大的变化，当<strong>链表长度</strong>大于阈值（默认为<strong>8</strong>）时且<strong>数组长度</strong>大于<strong>64</strong>时，将链表转化为红黑树，以减少搜索时间。扩容时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。后期使用map获取值时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>底层的地址运算出来 如果地址不一样计算出来的hashcode不一样，hashcode一般是数字[整数(±或0)] 通过key进行hashcode运算 对<strong>数组长度取模</strong> eg：任何整数去取模10   可以定位到value可以放在哪个桶下面</p>
<p>hashcode本身不同的对象算出来的hashcde值是相同的怎么办呢？<br>两个value不可能放在同一个桶 这就是<strong>hash冲突</strong>  如果数组长度是8 算出来一个hashcode值是8 和 16 此时取模余数相同这样的情况也是相同。所以此时应该用<strong>拉链法</strong>[小葡萄串]，即使桶一样 可以用指针一个个指，此时的链表是单向链表[linkedlist才是双向链表]。<br>在1.8后指出如果同一个桶的葡萄串太多了，此时要拿出数据，时间复杂度就是O(n)，如果没有很多就是O(1)数组的长度。红黑树的引入是解决链表过长的问题。<br>红黑树是树形的高级数据结构 时间复杂度O(logn)<br>二叉树在某些情况下会退化成链表 右子树永远比根节点大<br>红黑树会旋转自平衡[局部旋转达到平衡] 超过多少层会旋转 不至于退化成链表。</p>
<blockquote>
<p>拉链法（Chaining）是 Java 的 <code>HashMap</code> 在 JDK 1.8 之前以及之后都使用的一种解决哈希冲突的方法。在 JDK 1.8 之前，<code>HashMap</code> 的实现主要是基于拉链法，即使用链表来解决哈希冲突。当不同的键通过哈希函数计算出相同的哈希码，并且映射到同一个桶（bucket）时，这些键值对将以链表的形式存储在同一个桶中。</p>
<p>在 JDK 1.8 中，<code>HashMap</code> 的实现进行了改进，当链表的长度超过一定阈值（默认是 8）时，链表会被转换成红黑树。这是为了优化哈希表的性能，特别是当哈希冲突严重时，链表的查询效率会降低到 O(n)，而红黑树可以将查询效率提升到 O(log n)。</p>
<h3 id="红黑树如何避免哈希冲突"><a href="#红黑树如何避免哈希冲突" class="headerlink" title="红黑树如何避免哈希冲突"></a>红黑树如何避免哈希冲突</h3><p>红黑树本身并不直接解决哈希冲突，而是优化了哈希冲突发生后的数据结构。以下是红黑树在 <code>HashMap</code> 中是如何工作的：</p>
<ol>
<li><strong>哈希冲突</strong>：当不同的键产生相同的哈希码或经过取模运算后落在同一个桶时，就会发生哈希冲突。</li>
<li><strong>链表</strong>：在 JDK 1.8 中，如果桶中的元素少于一定数量（默认为 8），就会使用链表来存储这些元素。</li>
<li><strong>红黑树转换</strong>：当链表的长度超过阈值（默认为 8）时，并且数组的长度超过 64，链表会被转换成红黑树。这样可以减少查找时间，因为红黑树是一种自平衡的二叉搜索树。</li>
<li><strong>自平衡</strong>：红黑树通过旋转和重新着色操作来保持树的平衡，从而避免了二叉搜索树退化成链表的情况。</li>
</ol>
<h3 id="红黑树的旋转和自平衡"><a href="#红黑树的旋转和自平衡" class="headerlink" title="红黑树的旋转和自平衡"></a>红黑树的旋转和自平衡</h3><p>红黑树通过以下规则保持平衡：</p>
<ul>
<li><strong>节点颜色</strong>：每个节点要么是红色，要么是黑色。</li>
<li><strong>根节点</strong>：根节点是黑色的。</li>
<li><strong>红色规则</strong>：如果一个节点是红色的，则它的子节点必须是黑色的（不能有两个连续的红色节点）。</li>
<li><strong>黑色高度</strong>：从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<p>当插入或删除节点时，可能会破坏这些规则，此时红黑树会通过以下操作来重新平衡：</p>
<ul>
<li><strong>左旋转</strong>：当右子节点是红色，而左子节点是黑色或不存在时，进行左旋转。</li>
<li><strong>右旋转</strong>：当左子节点是红色，并且它的左子节点也是红色时，进行右旋转。</li>
<li><strong>重新着色</strong>：在某些情况下，通过改变节点颜色来维持红黑树的性质。</li>
</ul>
<p>通过这些操作，红黑树确保了即使在最坏的情况下，树的高度也不会超过 2log(n+1)，从而保证了 O(log n) 的时间复杂度。</p>
<p>总结来说，红黑树并不直接解决哈希冲突，而是优化了哈希冲突后的数据结构，使得即使在发生大量哈希冲突的情况下，<code>HashMap</code> 的性能也不会显著下降。</p>
</blockquote>
<h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>new的初始化 数组为空<br>当第一次put的时候才不会为空 为16<br>扩容因子为什么是0.75？hashmap不仅仅java 其他语言也有这种数据结构 但扩容因子可能不同，是通过大量的数学概率统计出的最好最平衡的值。达到12的时候会扩容成2倍<br>new一个hashmap可以指定数组长度为7 此时数组长度是8【hashmap的长度永远是2的幂次方 比你传入的长度永远大 且 是2的幂次方】 为什么2的幂次方？因为1.7要数组取模 怎么打这个符号 shift+5 &#x3D;&gt; %，1.8之后用了位运算，&gt;&gt;2 &lt;&lt;2 让你的取模运算更快。如果出现hash冲突会拉链 当它的<strong>数组长度</strong>大于64 并且 <strong>链表长度</strong>大于8时，当链表长度小于等于6临界值会变回来【为什么是6？避免频繁切换(离8太近) 链表 ←→ 红黑树[消耗性能]】</p>
<p>链表1.7之前是头插法 会产生一条首尾相接的死循环【并发情况<del>[但是hashmap线程不安全不会用在并发，要用ConcurrentHashMap]</del>一起put 且 同一个桶】<br>1.8之后是尾插法，并发情况下不会出现cpu飙高，</p>
<h5 id="HashSet底层数据结构"><a href="#HashSet底层数据结构" class="headerlink" title="HashSet底层数据结构"></a>HashSet底层数据结构</h5><p><strong>底层是包装了一个hashmap</strong>，无序 key不允许重复  value可重复<br>HashSet单列无序不重复的 key就是那个元素 value就是new了一个无意义的object对象</p>
<p>ArrayList和LinkedList不是线程安全的 用什么？</p>
<ul>
<li>Vector 读写都加锁。</li>
<li>CopyOnWriteArrayList 读不加锁 写加锁</li>
</ul>
<p>ConcurrentHashMap能存null吗？不允许使用 <code>null</code> 作为键，但是允许使用 <code>null</code> 作为值。<br>HashMap：null默认放在第一个桶下面 下标写死为0</p>
<h6 id="Hashcode相同equals一定相同吗？"><a href="#Hashcode相同equals一定相同吗？" class="headerlink" title="Hashcode相同equals一定相同吗？"></a>Hashcode相同equals一定相同吗？</h6><p><code>hashCode()</code> 相同不一定意味着 <code>equals()</code> 相同，但 <code>equals()</code> 相同则 <code>hashCode()</code> 必须相同。</p>
<ul>
<li><code>equals()</code> 方法用于判断两个对象是否逻辑上相等。</li>
<li><code>hashCode()</code> 方法用于返回对象的哈希码，这个哈希码通常用于哈希表的快速查找。</li>
</ul>
<p>key可以放复合对象，要注意要重写 hashcode()和equals() 如果不重写 new了的两个对象有可能会相同<br><code>&quot;重地&quot;</code> 和 <code>&quot;通话&quot;</code> 。<strong>计算hashcode会比equals更快</strong>，一个对象new出来后hashcode已经计算出来了。equals要比较每个对象值，<strong>所以先判断hashcode 再判断equals</strong>   重写：@Override 用属性里面的hashcode，user里面包含了复杂对象order 此时order也要重写。包装类已经重写了hashcode，要整个对象返回true才为正确的，要层层递进去判断。hashmap重写复杂对象就一定要重写那俩个   ∵ 是比较对象里的属性值<br>list 有序可重复单列<br>map 双列key不能重复value可重复  treemap是有序的<br>set 单列不重复无序 hashset 无序 treeset 有序 </p>
<p>&#x3D;&#x3D; 值 + 地址值<br>equals 是对象属性值是否一 一相等</p>
<h4 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h4><p>不安全的，可以使用<strong>ConcurrentHashMap<del>线程安全</del><strong>、Collections.synchronizedMap()、</strong>HashTable</strong><br><strong>线程安全</strong>：多线程对同一个数据进行增删改是否受到影响<br>怎么办？</p>
<ul>
<li><p><strong>加锁</strong></p>
<ul>
<li>synchronized</li>
<li>ReentrantLock</li>
</ul>
<p>加锁为什么能解决线程安全问题？线程访问资源的先后顺序<br>多线程访问同一个数据 &#x3D;&gt; 多个线程访问同一个数据<br><strong>秒杀</strong> &#x3D;&gt;[思想] 1w个人买 对 100个库存进行扣减，只搞100个线程 把100个库存分成10份 其中每份有10个</p>
<pre><code class="java">初始化库存： 创建一个共享的库存计数器，初始值为100。
创建线程： 创建100个线程，每个线程在启动时分配到一个特定的库存分片。
扣减库存： 每个线程尝试扣减其分配到的库存分片中的一个商品。扣减操作必须是原子的，以确保线程安全。
同步机制： 使用适当的同步机制（如synchronized关键字、ReentrantLock等）来保护库存扣减操作，防止并发问题。
库存检查： 在扣减前，线程需要检查当前分片是否有剩余库存。如果没有，则线程可以终止或进行其他处理。
</code></pre>
<p>hashtable不管读写都会用synchronized加锁，并发一起来读都加锁 没必要，所以用了ConcurrentHashMap读不加锁 写加锁。<br>随着时间的推移，<code>Hashtable</code> 已经被认为是遗留代码，现代Java代码更倾向于使用 <code>HashMap</code>（非线程安全）或 <code>ConcurrentHashMap</code>（线程安全）。</p>
</li>
</ul>
<blockquote>
<p><strong>Synchronized</strong></p>
<pre><code class="java">public class SynchronizedExample &#123;
    public synchronized void synchronizedMethod() &#123;
        // 这里是同步代码块
        System.out.println(&quot;进入同步方法&quot;);
        // 执行一些操作
        System.out.println(&quot;退出同步方法&quot;);
    &#125;
&#125;
-----------------------------------------------------
public class SynchronizedBlockExample &#123;
    private final Object lock = new Object();

    public void synchronizedBlock() &#123;
        synchronized (lock) &#123;
            // 这里是同步代码块
            System.out.println(&quot;进入同步代码块&quot;);
            // 执行一些操作
            System.out.println(&quot;退出同步代码块&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>ReentrantLock</strong></p>
<pre><code class="java">import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample &#123;
    private final ReentrantLock lock = new ReentrantLock();

    public void lockedMethod() &#123;
        lock.lock(); // 加锁
        try &#123;
            // 这里是同步代码块
            System.out.println(&quot;进入锁定的方法&quot;);
            // 执行一些操作
            System.out.println(&quot;退出锁定的方法&quot;);
        &#125; finally &#123;
            lock.unlock(); // 解锁
        &#125;
    &#125;
&#125;
</code></pre>
</blockquote>
<h4 id="红黑树查询效率高的原因"><a href="#红黑树查询效率高的原因" class="headerlink" title="红黑树查询效率高的原因"></a>红黑树查询效率高的原因</h4><p>红黑树是一种自平衡的二叉搜索树，它通过特定的规则来保持树的平衡，这些规则确保了树的高度大约是log(n)<br>自平衡 局部旋转 </p>
<p>hashMap时间复杂度</p>
<ul>
<li>O(1)：不涉及到拉链</li>
<li>O(n)：拉链不是树</li>
<li>O(logn)：桶为红黑树</li>
</ul>
<h4 id="这个测试是你做的吗，还是你们团队去做的？"><a href="#这个测试是你做的吗，还是你们团队去做的？" class="headerlink" title="这个测试是你做的吗，还是你们团队去做的？"></a>这个测试是你做的吗，还是你们团队去做的？</h4><p>像自测的话是我自己去做的(测试用例、apifox)，然后交给专业测试人员</p>
<h4 id="团队是怎么协作的？"><a href="#团队是怎么协作的？" class="headerlink" title="团队是怎么协作的？"></a>团队是怎么协作的？</h4><p>像我们团队的话，有使用禅道来做我们的文档管理，需求管理和需求的变更控制，和工作的一个统计报表，大部分的协作任务都可以在禅道上完成，代码这一块我们是使用git来做一个代码管理和协作的。</p>
<h4 id="linux查看每个文件夹下的文件大小的命令"><a href="#linux查看每个文件夹下的文件大小的命令" class="headerlink" title="linux查看每个文件夹下的文件大小的命令"></a>linux查看每个文件夹下的文件大小的命令</h4><p>ls -lh</p>
<h4 id="linux查看文件夹大小的命令"><a href="#linux查看文件夹大小的命令" class="headerlink" title="linux查看文件夹大小的命令"></a>linux查看文件夹大小的命令</h4><p>du -sh<br>du -sh –all 隐藏<br>du -sh .&#x2F;* : 单独列出各子项占用的容量</p>
<h4 id="linux查看进程的命令，动态查看一个文件的最后100行的命令"><a href="#linux查看进程的命令，动态查看一个文件的最后100行的命令" class="headerlink" title="linux查看进程的命令，动态查看一个文件的最后100行的命令"></a>linux查看进程的命令，动态查看一个文件的最后100行的命令</h4><p>ps -ef<br>ps aux [查看所有用户的进程（包括其他用户的进程）：]<br>ps -ef | grep mysql</p>
<p><strong>动态</strong>：tail  -n 100 -f xxx 【-f → follow】<br><strong>静态</strong>：tail  -n 100 xxx</p>
<h4 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h4><h6 id="rm-x3D-romove"><a href="#rm-x3D-romove" class="headerlink" title="rm &#x3D; romove"></a>rm &#x3D; romove</h6><p>用于删除文件和目录<br> rm [-rf] name<br>-r(recursive递归)：将目录及目录中所有文件（目录）逐一删除，即递归删除<br>-f(force)：无需确认，直接删除</p>
<h6 id="rmdir-x3D-remove-directory"><a href="#rmdir-x3D-remove-directory" class="headerlink" title="rmdir &#x3D; remove directory"></a>rmdir &#x3D; remove directory</h6><p>它用于删除空目录。如果目录不为空，即目录中包含文件或其他子目录，rmdir 命令将无法删除该目录</p>
<h6 id="pwd-x3D-print-working-directory"><a href="#pwd-x3D-print-working-directory" class="headerlink" title="pwd &#x3D; print working directory"></a>pwd &#x3D; print working directory</h6><p>打印出当前工作目录的绝对路径。当你需要知道你在文件系统中的当前位置时，这个命令非常有用</p>
<h6 id="cp-x3D-copy"><a href="#cp-x3D-copy" class="headerlink" title="cp &#x3D; copy"></a>cp &#x3D; copy</h6><p>复制文件和目录。这个命令可以用来创建文件的副本或将文件从一个位置移动到另一个位置。<br>cp [-r] source dest<br>-r (recursive递归)：如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件</p>
<h6 id="mv-x3D-move"><a href="#mv-x3D-move" class="headerlink" title="mv &#x3D; move"></a>mv &#x3D; move</h6><p>为文件或目录改名、或将文件或目录移动到其他位置【移动 重命名 修改】</p>
<h6 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h6><p>用于搜索文本数据，特别是使用正则表达式来匹配指定的模式<br>查看特定进程的详细信息，例如进程名为 <u>mysql</u><br>ps -ef | grep mysql</p>
<h6 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar [tape archive]"></a>tar [tape archive]</h6><p>用于打包多个文件和目录到一个归档文件中，或者从归档文件中提取文件</p>
<h6 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h6><p>切换路径</p>
<h6 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h6><p>编辑文件</p>
<h6 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h6><p>查看文件[head]</p>
<h6 id="如何查日志"><a href="#如何查日志" class="headerlink" title="如何查日志"></a>如何查日志</h6><p>查看<code>/var/log/user.log</code>文件，并且想要跟踪用户 <u>name：<code>pcy</code></u> 的活动</p>
<p>tail -f &#x2F;var&#x2F;log&#x2F;user.log | grep “pcy”<br><span style = "color:red"><strong>高级专用使用</strong></span>：<code>awk</code> 可以用正则等一些逻辑操作去获取日志</p>
<blockquote>
<h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p><code>awk</code> 非常强大，可以用于执行复杂的文本分析和报告生成，<code>awk</code> 有许多内建函数，如 <code>length()</code>、<code>toupper()</code>、<code>tolower()</code> 等。</p>
<pre><code>awk &#39;&#123;print toupper($0)&#125;&#39; filename  # 将所有内容转换为大写
</code></pre>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><pre><code>awk &#39;&#123;if ($1 &gt; 100) print$1&#125;&#39; filename
</code></pre>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre><code>awk &#39;&#123;for (i=1; i&lt;=NF; i++) print $i&#125;&#39; filename
</code></pre>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><pre><code>awk &#39;&#123;count[$1]++&#125; END &#123;for (word in count) print word, count[word]&#125;&#39; filename
</code></pre>
</blockquote>
<h4 id="你们接口是如何让前端调用的"><a href="#你们接口是如何让前端调用的" class="headerlink" title="你们接口是如何让前端调用的"></a>你们接口是如何让前端调用的</h4><p>我们会在设计阶段提前设计好给前端 并行开发 前后端联调[本地ip端口告诉前端]</p>
<h4 id="接口文档怎么定下来的"><a href="#接口文档怎么定下来的" class="headerlink" title="接口文档怎么定下来的"></a>接口文档怎么定下来的</h4><p>根据页面原型、需求设计接口文档[后端自己写]，绝大部分后端看原型的出参入参 无太大需求和前端商量。【前端组件库】[若修改返回结构的时候] [按照数据结构修改] 需要听前端意见</p>
<h4 id="前端调用后端用的是什么请求方式"><a href="#前端调用后端用的是什么请求方式" class="headerlink" title="前端调用后端用的是什么请求方式"></a>前端调用后端用的是什么请求方式</h4><p><strong>WebSocket</strong>【基于长连接通讯】<br>HTTP</p>
<blockquote>
<p>前端开发中，以下是一些常见的使用场景：</p>
<ul>
<li>获取数据：使用GET请求。</li>
<li>提交表单或数据：使用POST请求。</li>
<li>更新资源：使用PUT或PATCH请求。</li>
<li>删除资源：使用DELETE请求。</li>
</ul>
<p>前端可以通过多种方式发起这些请求，例如：</p>
<ul>
<li>使用HTML表单（通常用于GET和POST请求）。</li>
<li>使用JavaScript的<code>XMLHttpRequest</code>对象或者更现代的<code>fetch</code> API来发起各种类型的HTTP请求。</li>
<li>使用各种前端框架和库（如React, Angular, Vue.js）中提供的封装好的HTTP服务。</li>
</ul>
</blockquote>
<h4 id="SpringBoot主要的一些注解？都有哪些，以及主要作用"><a href="#SpringBoot主要的一些注解？都有哪些，以及主要作用" class="headerlink" title="SpringBoot主要的一些注解？都有哪些，以及主要作用"></a><strong>SpringBoot主要的一些注解？都有哪些，以及主要作用</strong></h4><pre><code class="java">SpringBoot：
@SpringBootApplication [见↓↓]
@ConfigurationProperties：注解用于将外部配置（如来自properties文件、YAML文件或环境变量）绑定到JavaBean上。它的作用是将配置文件中的属性映射到JavaBean的属性上，这样就可以在应用程序中使用这些配置属性。
@SpringBootTest：用于测试 Spring Boot 应用，提供测试环境的支持
@EnableConfigurationProperties：启用对配置属性的支持，允许将配置文件中的属性注入到 bean 中。


Spring：
@Component 
@ComponentScan 
@Conditional 
</code></pre>
<pre><code class="java">@SpringBootApplication 是一个组合注解，它结合了以下三个注解的功能：
1. @SpringBootConfiguration: 表示这是一个Spring Boot配置类，它本质上是一个@Configuration注解，用于定义配置类，可以包含多个@Bean注解的方法。
2. @EnableAutoConfiguration: 告诉Spring Boot基于类路径设置、其他bean和各种属性设置来添加bean。例如，如果你添加了spring-webmvc和thymeleaf的依赖，这个注解就会自动配置你的应用程序为一个web应用程序。
3. @ComponentScan: 告诉Spring在包及其子包下扫描注解定义的组件（如@Component, @Service, @Repository等）。
</code></pre>
<h4 id="aop在项目中有没有使用？aop使用的一些注解及其功能"><a href="#aop在项目中有没有使用？aop使用的一些注解及其功能" class="headerlink" title="aop在项目中有没有使用？aop使用的一些注解及其功能"></a><strong>aop在项目中有没有使用？aop使用的一些注解及其功能</strong></h4><p>一定要描述项目场景，web使用aop打印操作日志、使用aop做数据脱敏(150***8786)<br><u>过滤器</u>是Servlet技术的一部分，它是Java EE规范的一部分<br><u>拦截器</u>是Spring MVC框架的一部分，用于在处理HTTP请求时拦截控制器方法调用。<br>AOP底层是动态代理设计模式，在<u>理论上</u>效果在一定程度上相同<br>过滤器拦截器一般拦截某个web的前后，在controller执行前后<br>AOP是万物皆可拦截、甚至接口和类都可以切，可以增强controller、service、mapper……</p>
<p><u>定义一个切面类 <code>@Aspect</code> 声明为切面类 + @Component</u><br><u>定义切点 <code>@Pointcut</code> 声明切点表达式</u></p>
<blockquote>
<p>eg：@AfterReturning(pointcut &#x3D; “execution(public String com.example.yourpackage.Controller.*(..))”, returning &#x3D; “result”)</p>
</blockquote>
<h6 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h6><ul>
<li>前置  @Before</li>
<li>后置  @After</li>
<li>返回  @AfterReturning</li>
<li>异常  @AfterThrowing</li>
<li>环绕  @Around</li>
</ul>
<h4 id="你在公司里负责的内容"><a href="#你在公司里负责的内容" class="headerlink" title="你在公司里负责的内容"></a><strong>你在公司里负责的内容</strong></h4><h4 id="想在controller访问完之后，想在aop实现之后再进行操作"><a href="#想在controller访问完之后，想在aop实现之后再进行操作" class="headerlink" title="想在controller访问完之后，想在aop实现之后再进行操作"></a><strong>想在controller访问完之后，想在aop实现之后再进行操作</strong></h4><p>UserThreadLocal 在执行完之后要 remove 出去，抛异常也会执行<br>@After 不管有无异常都会执行<br>@Around 结合try…catch…finally 里也可以达到同样效果</p>
<blockquote>
<p><code>@After</code>：这个注解用于定义一个通知（Advice），它在目标方法执行之后执行，无论目标方法执行的结果如何（成功或异常）。</p>
</blockquote>
<pre><code class="java">@Aspect
@Component
public class AroundFinallyAspect &#123;

    // 定义切点
    @Pointcut(&quot;execution(* com.example.yourpackage.controller..*(..))&quot;)
    public void controllerMethods() &#123;
    &#125;

    // 环绕通知
    @Around(&quot;controllerMethods()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        Object result = null;
        try &#123;
            // 在目标方法执行之前执行
            result = joinPoint.proceed(); // 执行目标方法
            // 在目标方法成功执行之后执行
        &#125; catch (Throwable e) &#123;
            // 在目标方法抛出异常时执行
            throw e; // 可以选择处理异常或者重新抛出
        &#125; finally &#123;
            // 无论目标方法是否成功执行或者是否抛出异常，这里的代码都会执行
            performFinallyAction();
        &#125;
        return result;
    &#125;

    private void performFinallyAction() &#123;
        // 在这里放置最终要执行的代码
    &#125;
&#125;

--------------------------------------------------------------------------------
// 后置通知
    @After(&quot;execution(* com.example.service.*.*(..))&quot;)
    public void afterAdvice(JoinPoint joinPoint) &#123;
        // 在目标方法执行之后执行的逻辑
    &#125;

    // 返回后通知
    @AfterReturning(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;, returning = &quot;result&quot;)
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) &#123;
        // 在目标方法成功执行并返回结果后执行的逻辑
    &#125;

在第一个例子中，你直接在@After注解中指定了切点表达式，因此不需要额外的pointcut属性。

对于@AfterReturning注解，它不仅需要在目标方法执行之后执行通知，还需要访问目标方法的返回值。因此，@AfterReturning注解有一个额外的pointcut属性，用于指定切点表达式。此外，@AfterReturning注解还有一个returning属性，用于指定一个参数名，该参数将接收目标方法的返回值
</code></pre>
<p>@AfterReturning：在方法执行后返回结果后执行通知。【如果有异常不会处理】</p>
<h4 id="你们这个项目怎么技术选型的"><a href="#你们这个项目怎么技术选型的" class="headerlink" title="你们这个项目怎么技术选型的"></a>你们这个项目怎么技术选型的</h4><p>我进到项目中很多已经确认下来的 一般由组长确定了</p>
<h6 id="那你自己怎么想的？-开放性问题"><a href="#那你自己怎么想的？-开放性问题" class="headerlink" title="那你自己怎么想的？[开放性问题]"></a>那你自己怎么想的？[开放性问题]</h6><p>选xxx技术 网上资料&#x2F;备书 比较多可以参考[用的人多]<br>学习成本[框架厉害但上手复杂不好用]<br>社区的活跃度[官网持续更新版本 框架会不断发展]</p>
<h4 id="你处于后端的什么位置"><a href="#你处于后端的什么位置" class="headerlink" title="你处于后端的什么位置"></a>你处于后端的什么位置</h4><p>初级 中级 高级<br>中级 骨干开发位置[协助组长完成]<br>中高级 完成设计类</p>
<h4 id="你对你的职业规划是什么"><a href="#你对你的职业规划是什么" class="headerlink" title="你对你的职业规划是什么"></a>你对你的职业规划是什么</h4><p>讲实际的话<br>想成为高级开发&#x2F;某个领域的专家<br>提前了解公司领域，有备而来</p>
<h4 id="java基本类型"><a href="#java基本类型" class="headerlink" title="java基本类型"></a>java基本类型</h4><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20241222141950707.png" alt="image-20241222141950707" style="zoom:200%;" />

<p>short   可以占两个字节   可以用16位<br>int        可以占四个字节    -21亿 ~ 21亿<br>long     可以占八个字节   天文数字<br>float      可以占四个字节 0.2F&#x2F;f<br>double  可以占八个字节 0.2D&#x2F;d</p>
<p>float double尽量不要进行运算 ，在Java中进行金钱运算时，应当特别注意浮点数的精度问题，因为浮点数（如<code>float</code>和<code>double</code>）在表示某些数值时可能会丢失精度，这对于需要精确计算的金融计算来说是非常不合适的。</p>
<p>1.金钱转成分 向下取整<br>2.BigDecimal</p>
<p>ASCII码占1个字节 → Unicode字符占2个字节【有些汉字存不了】→ UTF-8占1-3个字节[灵活可变]<br>在我们性能中一般走Unicode编码性能更高一点 在网络中&#x2F;存入磁盘Unicode转成ASCII码</p>
<p>jdk？之后 jdk开始存储大量英文和数字 String类也作了更新 不是基于基本数据类型 而是基于byte数组</p>
<pre><code class="java">在Java的早期版本中（例如JDK 1.4及之前版本），String类内部确实使用char数组来存储字符串数据。每个char在Java中占用16位（2个字节），这意味着不管存储的是英文字符还是数字，每个字符都会占用2个字节的内存空间。

从JDK 5开始，Java平台引入了一些变化，但String类的内部表示仍然基于char数组。直到JDK 6和JDK 7，String类的内部表示并没有改为基于byte数组。

真正发生变化的是在JDK 9中，String类内部表示从char数组转变为byte数组加上一个编码标识（coder），这种改变是为了更有效地存储只有ASCII字符的字符串。ASCII字符只需要一个字节来表示，因此使用byte数组可以节省内存空间。当字符串包含Unicode字符时，String类可能会使用更多的编码方式，例如LATIN1或UTF-16。
</code></pre>
<h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p>生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法(钩子)</p>
<ol>
<li>beforeCreate创建前</li>
<li>created创建后</li>
<li>beforeMount载入前</li>
<li>mounted挂载完成</li>
<li>beforeUpdate数据更新前</li>
<li>updated数据更新后</li>
<li>beforeUnmount组件销毁前</li>
<li>unmounted组件销毁后</li>
</ol>
<h4 id="String是基础类型吗"><a href="#String是基础类型吗" class="headerlink" title="String是基础类型吗"></a>String是基础类型吗</h4><p>不是，是<code>java.lang</code>下的类</p>
<blockquote>
<p>String 在 Java 中并不是基础类型，而是一个引用类型。因为 String 是一个类，所以它是引用类型，意味着当我们声明一个 String 变量时，你实际上是指向一个 String 对象的引用</p>
</blockquote>
<pre><code class="java">String 的特性
不可变性：String 对象一旦创建就不能被修改。任何改变 String 内容的操作都会创建一个新的 String 对象。
线程安全：由于 String 的不可变性，它们是线程安全的，可以自由地在多个线程之间共享。
字符串池：为了提高性能和减少内存使用，Java 为 String 提供了字符串常量池（String Pool）。当创建一个新字符串时，如果字符串池中已经存在相同内容的字符串，则会返回池中的实例，而不是创建新的对象。
</code></pre>
<h4 id="java集合中list和set的区别"><a href="#java集合中list和set的区别" class="headerlink" title="java集合中list和set的区别?"></a>java集合中list和set的区别?</h4><p>都是接口 某个实现类</p>
<p>单链 有顺序 可重复 有索引[有下标]<br>单链 不可重复 无索引[无下标] 不能说是无序 因为TreeSet有序 HashSet就是无序的</p>
<h4 id="做了几年开发呢-实际几个项目"><a href="#做了几年开发呢-实际几个项目" class="headerlink" title="做了几年开发呢? 实际几个项目?"></a>做了几年开发呢? 实际几个项目?</h4><p>三年[初中级] → 四~五个项目</p>
<h4 id="你觉得敲代码最重要的是什么"><a href="#你觉得敲代码最重要的是什么" class="headerlink" title="你觉得敲代码最重要的是什么?"></a>你觉得敲代码最重要的是什么?</h4><p><strong>理解需求</strong>、<strong>前期设计工作</strong>[数据库、接口 → 流程图(思路清晰)]、<strong>编码阶段</strong>[考虑方法封装、注释、考虑代码后期和维护性(设计模式 → 可维护性+扩展性)]、<strong>编码风格</strong>[阿里巴巴规范]</p>
<h4 id="你的项目有上线吗-多少人进行开发-你主要负责后端吗"><a href="#你的项目有上线吗-多少人进行开发-你主要负责后端吗" class="headerlink" title="你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?"></a>你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?</h4><p>有，介绍一下项目组成结构，是的[再问再回答]</p>
<h4 id="SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件"><a href="#SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件" class="headerlink" title="SpringBoot的自动装配原理[启动过程中的一部分]SpringBoot启动原理&amp;&amp;如何内嵌外部原件"></a><span style = "color:red"><strong>SpringBoot的自动装配原理</strong></span>[启动过程中的一部分]<del>SpringBoot启动原理&amp;&amp;如何内嵌外部原件</del></h4><p>Spring Boot的自动装配原理是基于Spring框架的IoC（控制反转）和DI（依赖注入）的核心概念，并结合了一系列的约定和条件注解来实现配置类的自动加载和Bean的自动注册</p>
<blockquote>
<ol>
<li><strong>启动类</strong>：Spring Boot 应用通常有一个带有 <code>@SpringBootApplication</code> 注解的启动类。这个注解是一个组合注解，它包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</li>
<li><strong>@EnableAutoConfiguration</strong>：这个注解是自动装配的关键。它告诉 Spring Boot 根据类路径下的类、Bean 的定义以及各种属性设置，自动配置 Spring 应用。这个注解会导入 <code>AutoConfigurationImportSelector</code> 类，该类会读取所有 <code>spring.factories</code> 文件中的 <code>EnableAutoConfiguration</code> 条目，并将它们作为配置类导入。</li>
<li><strong>条件化配置</strong>：Spring Boot 使用 <code>@Conditional</code> 注解及其一系列的派生注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等）来确保只有在满足特定条件时，配置类或 Bean 才会被创建。</li>
<li><strong>配置类</strong>：自动装配是通过一系列的配置类来实现的，这些配置类包含了 <code>@Bean</code> 方法，用于创建和配置 Spring 容器中的 Bean。</li>
</ol>
</blockquote>
<h6 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h6><pre><code class="xml">&lt;!-- Maven项目的依赖示例 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.xxx&lt;/groupId&gt;
    &lt;artifactId&gt;xxx-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>三大优点</strong>：依赖Maven特性[依赖传递]  自动配置  内嵌Tomcat<br>Spring Boot的自动装配原理是<br>在<code>src/main/resources/META-INF</code>目录下创建<code>spring.factories</code>文件，添加自动配置类的全限定名<br>我们可以在-info定义spring.factories位于<code>META-INF</code>目录下，Spring Boot使用它来发现和加载自动配置类。</p>
<p><strong>配置类扫描</strong>: 通过<code>@SpringBootApplication</code>注解，Spring Boot会触发对<code>@EnableAutoConfiguration</code>注解的处理，该注解会查找<code>spring.factories</code>文件中定义的自动配置类。</p>
<p>Maven里面写test类 用configuration声明 写很多的test类 但是我可以自己写test类然后调不同的方法 <strong>应该怎么办</strong>？@Conditional[Spring的注解] → 做成非常灵活的 如果没有就用自己写的 </p>
<h4 id="Spring里面的事务传播行为"><a href="#Spring里面的事务传播行为" class="headerlink" title="Spring里面的事务传播行为"></a><strong>Spring里面的事务传播行为</strong></h4><p>在Spring框架中，事务传播行为定义了事务方法之间的调用关系，即一个事务方法被另一个事务方法调用时，事务应该如何传播。</p>
<ol>
<li><span style = "color:blue"><u><strong>REQUIRED</strong>（默认值）</u></span> required<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
</ul>
</li>
<li><strong>SUPPORTS</strong> supports<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</li>
</ul>
</li>
<li><strong>MANDATORY</strong> mandatory<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
</ul>
</li>
<li><strong>REQUIRES_NEW</strong> requires_new<ul>
<li>创建一个新的事务，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NOT_SUPPORTED</strong> not_supported<ul>
<li>以非事务方式执行操作，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NEVER</strong> never<ul>
<li>以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ul>
</li>
<li><strong>NESTED</strong> nested<ul>
<li>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则行为类似于<code>REQUIRED</code>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>REQUIRED：通常用于方法需要在一个事务中运行，但如果已经有一个事务在运行，那么它应该加入这个事务。<br>SUPPORTS：用于方法不需要事务上下文，但如果已经在一个事务中，它也可以在这个事务中运行。<br>MANDATORY：用于方法必须在事务中运行，如果没有事务，则会抛出异常。<br><strong>REQUIRES_NEW</strong>：用于方法必须在自己的新事务中运行，即使当前已经有一个事务在运行。<br>[一般适用于不管有没有抛出异常 都要记录某些操作日志 不能在同一个类里底层是动态代理]<br>[如果a()和b()方法在同一个类中，并且a()直接调用b()，那么Spring的事务代理无法拦截这个内部调用，因此b()的REQUIRES_NEW事务传播行为不会生效。这是因为内部方法调用不会通过代理，而是直接在同一个对象实例上调用。]</p>
<pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.annotation.Propagation;

@Service
public class MyService &#123;

@Autowired
private MyService self; // 注入自身代理实例

public void methodA() &#123;
  // ... 业务逻辑 ...

  self.methodB(); // 通过代理实例调用，事务注解将生效
&#125;

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() &#123;
  // ... 业务逻辑 ...
&#125;
&#125;
</code></pre>
<p>NOT_SUPPORTED：用于方法不应该在事务中运行，如果有一个事务在运行，它将被挂起。<br>NEVER：用于方法绝对不应该在事务中运行，如果有一个事务在运行，将抛出异常。<br>NESTED：用于方法应该在嵌套事务中运行，嵌套事务可以独立于外部事务进行提交或回滚</p>
</blockquote>
<h4 id="用过Spring的事务吗"><a href="#用过Spring的事务吗" class="headerlink" title="用过Spring的事务吗"></a><strong>用过Spring的事务吗</strong></h4><p>一组数据库的增删改操作<br><strong>声明式事务管理</strong>：这是Spring推荐的用法，它通过使用注解（如<code>@Transactional</code>）或基于XML的配置来声明事务边界。底层基于AOP实现动态代理增强方法<br><strong>编程式事务管理</strong>：允许你通过编程的方式直接管理事务，通常使用<code>TransactionTemplate</code>或者直接使用底层的<code>PlatformTransactionManager</code>。</p>
<blockquote>
<h4 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h4><pre><code class="java">// 你需要在 Spring 配置中启用事务注解支持：
@Configuration
@EnableTransactionManagement
public class SpringConfig &#123;

    @Bean
    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) &#123;
        return new JpaTransactionManager(entityManagerFactory);
    &#125;
    
    // ... 其他配置
&#125;


// 然后，你可以在服务层的方法上使用 @Transactional 注解来声明事务边界：
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class AccountService &#123;

    @Autowired
    private AccountRepository accountRepository;

    @Transactional
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) &#123;
        // 执行转账操作，比如：
        Account fromAccount = accountRepository.findById(fromAccountId).orElseThrow(...);
        Account toAccount = accountRepository.findById(toAccountId).orElseThrow(...);
        
        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        toAccount.setBalance(toAccount.getBalance().add(amount));
        
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
        
        // 如果这里发生异常，Spring 将回滚事务
    &#125;
&#125;
</code></pre>
<h4 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h4><pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;

@Service
public class AccountService &#123;

    @Autowired
    private TransactionTemplate transactionTemplate;
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) &#123;
        transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) &#123;
                try &#123;
                    // 执行转账操作，与声明式事务管理中的操作相同
                    // ...
                &#125; catch (Exception e) &#123;
                    status.setRollbackOnly(); // 如果发生异常，标记事务回滚
                &#125;
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
</blockquote>
<h4 id="你熟悉的技术栈有哪些，用了哪些"><a href="#你熟悉的技术栈有哪些，用了哪些" class="headerlink" title="你熟悉的技术栈有哪些，用了哪些?"></a>你熟悉的技术栈有哪些，用了哪些?</h4><p>SpringBoot Vue Git Maven MyBatis……</p>
<h4 id="解决难点的决策有和用户沟通的吗？"><a href="#解决难点的决策有和用户沟通的吗？" class="headerlink" title="解决难点的决策有和用户沟通的吗？"></a>解决难点的决策有和用户沟通的吗？</h4><p>有过沟通 让他们了解一下我们的方案</p>
<h6 id="万一用户听不懂怎么办？"><a href="#万一用户听不懂怎么办？" class="headerlink" title="万一用户听不懂怎么办？"></a>万一用户听不懂怎么办？</h6><p>我会用一些更加直白通俗的语言让用户理解我们的方案</p>
<h6 id="用户不接受这个方案怎么办？"><a href="#用户不接受这个方案怎么办？" class="headerlink" title="用户不接受这个方案怎么办？"></a>用户不接受这个方案怎么办？</h6><p>我们可以提供不止一个方案 或者 提供他提的方案 综合一下各种方案告诉其优缺点(站在我们的专业角度意见)和风险 让客户明知 让其选择</p>
<h4 id="通常一般怎么学习的？最近在研究什么技术？"><a href="#通常一般怎么学习的？最近在研究什么技术？" class="headerlink" title="通常一般怎么学习的？最近在研究什么技术？"></a>通常一般怎么学习的？<del>最近在研究什么技术？</del></h4><p>想面试的目的 要給公司带来一些好的<br>一般<strong>以公司的实际项目中为切入点</strong>去学习会更有效率</p>
<h5 id="学习一个新的技术大概要多久？"><a href="#学习一个新的技术大概要多久？" class="headerlink" title="学习一个新的技术大概要多久？"></a>学习一个新的技术大概要多久？</h5><p>1-2天 首先看官网 这个技术是解决哪些 看我们的项目需要哪些技术切入点能引用 然后去专门针对这个技术功能点去学习快速上手的接口文档</p>
<h4 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h4><ul>
<li><strong>主数据基于内存操作</strong></li>
<li><strong>Redis是单线程</strong>[操作数据的线程]，避免上下文的频繁切换<del>整个redis不是就一个线程</del></li>
<li><strong>底层基于C语言实现</strong> <del>得益于底层良好的数据结构[]</del></li>
<li><strong>基于<span style = "color:red">非阻塞</span>的IO</strong><del>提升IO读写性能，NIO,BIO,AIO…</del></li>
</ul>
<h6 id="Java四大杀手"><a href="#Java四大杀手" class="headerlink" title="Java四大杀手"></a>Java四大杀手</h6><p><u>集合数据结构     jvm    并发编程    网络IO</u></p>
<blockquote>
<p>非阻塞IO（Non-blocking I&#x2F;O）是一种IO模型，它允许程序在执行IO操作时不会被阻塞，即程序可以在发起IO请求后继续执行其他任务，而不需要等待IO操作完成。以下是关于非阻塞IO的一些关键点：</p>
<h3 id="非阻塞IO的特点："><a href="#非阻塞IO的特点：" class="headerlink" title="非阻塞IO的特点："></a>非阻塞IO的特点：</h3><ol>
<li><strong>异步操作</strong>：非阻塞IO操作通常是异步的，意味着程序发起IO请求后，不需要等待IO操作完成，而是可以立即返回去做其他事情。</li>
<li><strong>事件驱动</strong>：非阻塞IO往往与事件驱动模型结合使用，程序可以通过监听器来响应IO事件（如数据可读、连接可写等）。</li>
<li><strong>减少等待时间</strong>：由于程序在等待IO操作完成时不会阻塞，它可以继续处理其他任务，从而提高了程序的响应性和吞吐量。</li>
</ol>
<h3 id="非阻塞IO的实现方式："><a href="#非阻塞IO的实现方式：" class="headerlink" title="非阻塞IO的实现方式："></a>非阻塞IO的实现方式：</h3><ul>
<li><strong>NIO（New I&#x2F;O）</strong>：在Java中，NIO提供了一种非阻塞的IO方式，使用<code>Selector</code>来管理多个通道（Channel）上的IO事件。</li>
<li><strong>AIO（Asynchronous I&#x2F;O）</strong>：AIO是另一种非阻塞IO模型，它允许程序完全异步地执行IO操作，通常是通过完成端口（Completion Ports）来实现。</li>
<li><strong>BIO（Blocking I&#x2F;O）</strong>：与非阻塞IO相对的是阻塞IO，其中每个IO操作都会阻塞调用线程，直到操作完成。</li>
</ul>
<h3 id="非阻塞IO的优势："><a href="#非阻塞IO的优势：" class="headerlink" title="非阻塞IO的优势："></a>非阻塞IO的优势：</h3><ul>
<li><strong>资源利用率</strong>：非阻塞IO可以更有效地利用系统资源，因为单个线程可以处理多个IO操作。</li>
<li><strong>高并发处理</strong>：在处理大量并发连接时，非阻塞IO可以显著提高系统的并发处理能力。</li>
</ul>
<h3 id="非阻塞IO在Redis中的应用："><a href="#非阻塞IO在Redis中的应用：" class="headerlink" title="非阻塞IO在Redis中的应用："></a>非阻塞IO在Redis中的应用：</h3><ul>
<li><strong>单线程模型</strong>：Redis是一个基于内存的键值存储数据库，它使用单线程模型来处理所有客户端请求。由于操作是基于内存的，速度非常快，而单线程避免了上下文切换的开销。</li>
<li><strong>非阻塞IO和多路复用</strong>：尽管Redis是单线程的，但它使用非阻塞IO和多路复用技术（如epoll或kqueue）来同时处理多个IO流。这意味着Redis可以在等待IO操作（如网络响应）时不阻塞，从而可以继续处理其他请求。</li>
<li><strong>高性能</strong>：Redis的非阻塞IO和多路复用机制使得它即使在面对大量并发请求时也能保持高性能。</li>
</ul>
</blockquote>
<h4 id="redis的数据类型以及使用场景分别是什么"><a href="#redis的数据类型以及使用场景分别是什么" class="headerlink" title="redis的数据类型以及使用场景分别是什么"></a>redis的数据类型以及使用场景分别是什么</h4><h6 id="写入依赖"><a href="#写入依赖" class="headerlink" title="写入依赖"></a>写入依赖</h6><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;3.7.0&lt;/version&gt; &lt;!-- Use the latest version available --&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li><p><strong>String</strong>：存储对象信息(转JSON)<br>将用户信息序列化为JSON字符串后存储。</p>
<pre><code class="json">SET user:1000 &#39;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;email&quot;:&quot;alice@example.com&quot;&#125;&#39;

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisStringExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.set(&quot;user:1000&quot;, &quot;&#123;\&quot;name\&quot;:\&quot;Alice\&quot;,\&quot;age\&quot;:30,\&quot;email\&quot;:\&quot;alice@example.com\&quot;&#125;&quot;);
        String userInfo = jedis.get(&quot;user:1000&quot;);
        System.out.println(userInfo);
        
        jedis.incr(&quot;visits&quot;);
        long visits = jedis.get(&quot;visits&quot;);
        System.out.println(&quot;Visits: &quot; + visits);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>List</strong>：链表，查询记录的缓存、列表，朋友圈，微博，队列数据结构<br>可以将数据库查询结果缓存为一个列表</p>
<pre><code class="mysql"># 查询记录的缓存
LPUSH recent:queries &quot;SELECT * FROM users WHERE age &gt; 30&quot;

# 消息队列
使用List作为消息队列，生产者将消息LPUSH到列表，消费者从列表中RPOP消息
LPUSH message:queue &quot;message1&quot;
RPOP message:queue

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisListExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.lpush(&quot;recent:queries&quot;, &quot;SELECT * FROM users WHERE age &gt; 30&quot;);
        String query = jedis.rpop(&quot;recent:queries&quot;);
        System.out.println(&quot;Recent Query: &quot; + query);
        
        jedis.close();
    &#125;
&#125;
w
</code></pre>
</li>
<li><p><strong>Hash</strong>：获取局部属性，小key不能设置过期时间<del>Hash是一个键值对集合，适合存储对象</del><br>Hash是一个键值对集合，适合存储对象</p>
<pre><code class="mysql">HSET user:1000 name &quot;Alice&quot; age 30 email &quot;alice@example.com&quot;
HGET user:1000 name

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisHashExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.hset(&quot;user:1000&quot;, &quot;name&quot;, &quot;Alice&quot;);
        jedis.hset(&quot;user:1000&quot;, &quot;age&quot;, &quot;30&quot;);
        jedis.hset(&quot;user:1000&quot;, &quot;email&quot;, &quot;alice@example.com&quot;);
        
        String name = jedis.hget(&quot;user:1000&quot;, &quot;name&quot;);
        System.out.println(&quot;Name: &quot; + name);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>Set</strong>：无序不可重复的，收藏，点赞，社交场景，聚合计算(∩∪差集)<br>社交场景：使用Set来存储用户的关注列表，确保关注关系的唯一性。</p>
<pre><code class="mysql">SADD user:1000:following 2000 3000 4000

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisSetExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.sadd(&quot;user:1000:following&quot;, &quot;2000&quot;, &quot;3000&quot;, &quot;4000&quot;);
        Set&lt;String&gt; following = jedis.smembers(&quot;user:1000:following&quot;);
        System.out.println(&quot;Following: &quot; + following);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
<p>聚合计算：计算两个用户的共同关注。</p>
<pre><code class="java">SINTER user:1000:following user:2000:following
</code></pre>
</li>
<li><p><strong>Zset</strong>：排序场景，排行榜，姓名排序</p>
<p>排行榜：根据用户得分来存储排行榜</p>
<pre><code class="mysql">ZADD leaderboard 1000 Alice 950 Bob 900 Charlie
ZRANGE leaderboard 0 -1 WITHSCORES

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;
import java.util.Set;

public class RedisZsetExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.zadd(&quot;leaderboard&quot;, 1000, &quot;Alice&quot;);
        jedis.zadd(&quot;leaderboard&quot;, 950, &quot;Bob&quot;);
        jedis.zadd(&quot;leaderboard&quot;, 900, &quot;Charlie&quot;);
        
        Set&lt;String&gt; leaderboard = jedis.zrange(&quot;leaderboard&quot;, 0, -1);
        System.out.println(&quot;Leaderboard: &quot; + leaderboard);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
<p>姓名排序：存储学生姓名和成绩，并按成绩排序。</p>
<pre><code class="mysql">ZADD students 92 John 85 Mary 88 Alice
ZRANGE students 0 -1 WITHSCORES
</code></pre>
</li>
</ul>
<p>分布式锁都可以用。Redisson是Redis的儿子，底层为Hash</p>
<h4 id="redis数据过期策略"><a href="#redis数据过期策略" class="headerlink" title="redis数据过期策略"></a>redis数据过期策略</h4><ul>
<li><p>惰性删除：键过期时不会立即删除，当访问该键时判断是否过期，如果过期就删除<br><strong>惰性删除策略是在访问键时检查键是否过期</strong>，如果过期则删除。</p>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class LazyExpiration &#123;
    private Jedis jedis;

    public LazyExpiration() &#123;
        // 连接到Redis服务器
        this.jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    public String getKey(String key) &#123;
        // 检查键是否存在
        if (!jedis.exists(key)) &#123;
            return null;
        &#125;

        // 检查键是否过期
        if (isExpired(key)) &#123;
            // 如果键已过期，则删除它
            jedis.del(key);
            return null;
        &#125;

        // 如果键未过期，返回键的值
        return jedis.get(key);
    &#125;

    private boolean isExpired(String key) &#123;
        // 获取键的剩余生存时间，如果返回值大于0，则键未过期
        return jedis.ttl(key) == -2;
    &#125;

    public static void main(String[] args) &#123;
        LazyExpiration lazyExpiration = new LazyExpiration();
        String value = lazyExpiration.getKey(&quot;myKey&quot;);
        if (value != null) &#123;
            System.out.println(&quot;Key value: &quot; + value);
        &#125; else &#123;
            System.out.println(&quot;Key does not exist or has expired.&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>定时删除：设置键的过期时间，当键过期时，立即删除</p>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class ActiveExpiration &#123;
    private Jedis jedis;

    public ActiveExpiration() &#123;
        // 连接到Redis服务器
        this.jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    public void activeExpireCycle() &#123;
        // 随机检查一定数量的键
        for (int i = 0; i &lt; 10; i++) &#123;
            String key = jedis.randomKey();
            if (key != null &amp;&amp; isExpired(key)) &#123;
                // 如果键已过期，则删除它
                jedis.del(key);
            &#125;
        &#125;
    &#125;

    private boolean isExpired(String key) &#123;
        // 获取键的剩余生存时间，如果返回值大于0，则键未过期
        return jedis.ttl(key) == -2;
    &#125;

    public void runPeriodicTask() &#123;
        // 定时任务，按照一定的频率运行
        while (true) &#123;
            activeExpireCycle();
            try &#123;
                Thread.sleep(1000); // 每秒执行一次
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        ActiveExpiration activeExpiration = new ActiveExpiration();
        // 启动定时任务
        activeExpiration.runPeriodicTask();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h6 id="高薪冲刺-→-定时删除详细策略"><a href="#高薪冲刺-→-定时删除详细策略" class="headerlink" title="高薪冲刺 → 定时删除详细策略"></a><span style = "color:red">高薪冲刺 → 定时删除详细策略</span></h6><blockquote>
<p>要扫描所有的定期任务删除 有策略可以设置阈值</p>
</blockquote>
<h4 id="啥时候离职的？半个月太长了"><a href="#啥时候离职的？半个月太长了" class="headerlink" title="啥时候离职的？半个月太长了"></a>啥时候离职的？<del>半个月太长了</del></h4><p>刚刚离职 也是刚刚开始投</p>
<h4 id="主要工作职责"><a href="#主要工作职责" class="headerlink" title="主要工作职责"></a>主要工作职责</h4><p>主要负责后端工作，协助测试，运维上线</p>
<h4 id="你对前端有了解过吗？"><a href="#你对前端有了解过吗？" class="headerlink" title="你对前端有了解过吗？"></a>你对前端有了解过吗？</h4><p>有了解过，如HTML、CSS、JavaScript、框架[Vue、Element]等 可以很快的上手<br><u>我主要专长在于后端开发，可以学习和了解更多的前端知识</u>。</p>
<h4 id="各种淘汰策略介绍"><a href="#各种淘汰策略介绍" class="headerlink" title="各种淘汰策略介绍"></a>各种淘汰策略介绍</h4><blockquote>
<p>Redis提供了8种淘汰策略，可以分成两大类：</p>
<p><strong>1、针对所有键的策略：</strong>对所有键进行选择和淘汰。</p>
<p><strong>2、仅针对有过期时间的键的策略：</strong>只在设置了过期时间的键中选择淘汰对象。</p>
</blockquote>
<p><strong>以下具体策略：</strong><br><strong>可以区分为两类</strong>：[有设置过期时间的key  不管你有没有设置过期时间]</p>
<h5 id="1-noeviction【默认】"><a href="#1-noeviction【默认】" class="headerlink" title="1. noeviction【默认】"></a>1. <strong>noeviction</strong>【默认】</h5><ul>
<li><strong>描述</strong>：达到内存限制时，不再执行删除操作，直接拒绝所有写入请求（包括插入和更新）。[可以读 但是拒绝写请求]</li>
<li><strong>适用场景</strong>：<u>希望数据永不丢失的场景</u>，但需要保证内存充足，否则会导致写入操作失败。</li>
</ul>
<h5 id="2-allkeys-lru（最近最少使用）"><a href="#2-allkeys-lru（最近最少使用）" class="headerlink" title="2. allkeys-lru（最近最少使用）"></a>2. <strong>allkeys-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：在所有的键中使用 LRU算法，删除最近最少使用的键。</li>
<li><strong>适用场景</strong>：适合缓存场景，保留<strong>频繁访问</strong>的键，逐出很少被访问的键。</li>
</ul>
<h5 id="3-allkeys-lfu（最少使用频率）【电商】"><a href="#3-allkeys-lfu（最少使用频率）【电商】" class="headerlink" title="3. allkeys-lfu（最少使用频率）【电商】"></a>3. <strong>allkeys-lfu（最少使用频率）</strong>【电商】</h5><ul>
<li><strong>描述</strong>：在所有键中使用 LFU 算法，删除使用频率最低的键。</li>
<li><strong>适用场景</strong>：适用于需根据<strong>使用频率</strong>进行淘汰的场景，更关注访问次数而非访问时间。</li>
</ul>
<h5 id="4-volatile-lru（最近最少使用）"><a href="#4-volatile-lru（最近最少使用）" class="headerlink" title="4. volatile-lru（最近最少使用）"></a>4. <strong>volatile-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LRU 算法。</li>
<li><strong>适用场景</strong>：适合缓存一些有过期时间的数据，希望根据<strong>访问频率</strong>来进行内存管理的场景。</li>
</ul>
<h5 id="5-volatile-lfu（最少使用频率）【电商】"><a href="#5-volatile-lfu（最少使用频率）【电商】" class="headerlink" title="5. volatile-lfu（最少使用频率）【电商】"></a>5. <strong>volatile-lfu（最少使用频率）【电商】</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LFU算法。</li>
<li><strong>适用场景</strong>：同 volatile-lru，但更关注<strong>使用频率</strong>。</li>
</ul>
<h5 id="6-allkeys-random"><a href="#6-allkeys-random" class="headerlink" title="6. allkeys-random"></a>6. <strong>allkeys-random</strong></h5><ul>
<li><strong>描述</strong>：在所有键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适用于缓存数据访问频率没有明显差异的情况。</li>
</ul>
<h5 id="7-volatile-random"><a href="#7-volatile-random" class="headerlink" title="7. volatile-random"></a>7. <strong>volatile-random</strong></h5><ul>
<li><strong>描述</strong>：在所有设置了过期时间的键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适合缓存带有过期时间的数据，删除哪个数据不重要的场景。</li>
</ul>
<h5 id="8-volatile-ttl"><a href="#8-volatile-ttl" class="headerlink" title="8. volatile-ttl"></a>8. <strong>volatile-ttl</strong></h5><ul>
<li><strong>描述</strong>：在设置了过期时间的键中，优先删除剩余生存时间（TTL）较短的键。</li>
<li><strong>适用场景</strong>：适合希望优先清理<strong>即将过期</strong>的数据的场景。</li>
</ul>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class RedisMaxMemoryPolicyExample &#123;
    private Jedis jedis;

    public RedisMaxMemoryPolicyExample() &#123;
        // 连接到Redis服务器
        this.jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    public void setMaxMemoryPolicy(String policy) &#123;
        // 设置Redis的内存淘汰策略
        jedis.configSet(&quot;maxmemory-policy&quot;, policy);
    &#125;

    public String getMaxMemoryPolicy() &#123;
        // 获取当前Redis的内存淘汰策略
        return jedis.configGet(&quot;maxmemory-policy&quot;).get(1);
    &#125;

    public static void main(String[] args) &#123;
        RedisMaxMemoryPolicyExample example = new RedisMaxMemoryPolicyExample();

        // 设置不同的内存淘汰策略
        example.setMaxMemoryPolicy(&quot;noeviction&quot;);       // 默认策略，拒绝写请求
        example.setMaxMemoryPolicy(&quot;allkeys-lru&quot;);      // 所有键使用LRU淘汰
        example.setMaxMemoryPolicy(&quot;allkeys-lfu&quot;);      // 所有键使用LFU淘汰
        example.setMaxMemoryPolicy(&quot;volatile-lru&quot;);     // 仅有过期时间的键使用LRU淘汰
        example.setMaxMemoryPolicy(&quot;volatile-lfu&quot;);     // 仅有过期时间的键使用LFU淘汰
        example.setMaxMemoryPolicy(&quot;allkeys-random&quot;);   // 所有键随机淘汰
        example.setMaxMemoryPolicy(&quot;volatile-random&quot;);  // 仅有过期时间的键随机淘汰
        example.setMaxMemoryPolicy(&quot;volatile-ttl&quot;);     // 优先淘汰TTL较短的键

        // 获取当前内存淘汰策略
        String currentPolicy = example.getMaxMemoryPolicy();
        System.out.println(&quot;Current Max Memory Policy: &quot; + currentPolicy);
    &#125;
&#125;
</code></pre>
<h4 id="缓存三兄弟-穿透、击穿、雪崩"><a href="#缓存三兄弟-穿透、击穿、雪崩" class="headerlink" title="缓存三兄弟(穿透、击穿、雪崩)"></a>缓存三兄弟(穿透、击穿、雪崩)</h4><p>一般在读缓存的时候出现的问题。<strong>思路</strong>：产生的原因 + 解决的方案</p>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：用户或前端查询到一个在数据库中不存在的数据，先查redis再走数据库。对数据库压力会很大。<u>关系型数据库是性能的瓶颈 希望把高数量都挡在数据库前面</u>。查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong> 【空字符串】<del>没有Null的数据类型</del>下一次读取直接把空串返回<br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</li>
</ul>
<p>如果一直模拟一个不同的不存在的key 这时候就要用到<strong>布隆过滤器</strong></p>
<ul>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)<br>[商品读多写少上缓存，要把商品数据写到布隆过滤器中，以商品的id<del>独一无二</del>计算hashcode，用布隆过滤器。取模数组落到桶内 会把0置为1]<br>有很多个二进制数组每个二进制数组用不同的hash算法进行计算此时落到的桶就不一样<br>作用：读的时候 前端传id 之前怎么写进去就怎么拿出来。[位运算(与)速度很快 把多个数组的数据拿出来与运算如果都是1 则这个数据可能存在<del>再查一遍缓存</del> 若不存在直接return返回] 布隆过滤器说你不存在 一定不存在，说你存在 则可能存在[哈希冲突] </p>
<h6 id="★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？"><a href="#★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？" class="headerlink" title="★ 项目上线很久了 商品早就下架不卖了 这时候会发生什么问题？"></a>★ 项目上线很久了 商品早就下架不卖了 <strong>这时候会发生什么问题</strong>？</h6><p>这时候布隆过滤器还有之前的痕迹，需要把那些1设置为0。<br>布隆过滤器 不支持对某个的1设置0 → 因为有哈希冲突<del>我不知道这个1曾经是誰设置的</del><br>支持将整个都置为0，之后可以搞个定时任务<br><strong>布隆过滤器具体实现</strong>：Redis、Redission<del>亲儿子</del>、1cache、咖啡因（Caffeine<del>提供了一种非常高效且易于使用的缓存解决方案，它支持多种缓存过期策略</del>）、Guava<del>谷歌</del></p>
<h6 id="★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据"><a href="#★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据" class="headerlink" title="★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 怎么解决？存量数据"></a>★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 <strong>怎么解决</strong>？<del>存量数据</del></h6><p>写一个定时任务</p>
<h6 id="★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了"><a href="#★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了" class="headerlink" title="★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)用户量太多了"></a>★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)<del>用户量太多了</del></h6><p>搞一个二进制数组，10亿长度的数组，每个数组是一个bit &#x3D; 10亿个位，一个字节<del>1&#x2F;bit</del>&#x3D;8个位，综合计算后大概消耗119MB的空间<del>每天</del>。用用户id去hash 如果用户登录将0置为1<del>有单独的位图结构</del>，统计时间就可以拿日期 往前面数 拿某个id去取模得到桶 找前七个，去进行与运算，连续为1就达到了重复连续七天前端。否则非连续七天。</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class DailyActiveUserCounter &#123;
    private Jedis jedis;

    public DailyActiveUserCounter() &#123;
        this.jedis = new Jedis(&quot;localhost&quot;); // 连接到Redis服务器
    &#125;

    // 映射用户ID到位图的键
    private String getUserBitmapKey(long userId, int day) &#123;
        return &quot;user:bitmap:&quot; + userId + &quot;:&quot; + day;
    &#125;

    // 用户签到
    public void userSignIn(long userId, int day) &#123;
        String key = getUserBitmapKey(userId, day);
        jedis.setbit(key, userId % 86400, true); // 假设一天有86400秒，使用秒数作为偏移量
    &#125;

    // 检查用户连续七天的签到情况
    public boolean checkContinuousSignIn(long userId, int day) &#123;
        for (int i = 0; i &lt; 7; i++) &#123;
            String key = getUserBitmapKey(userId, day - i);
            if (jedis.getbit(key, userId % 86400) == false) &#123;
                return false; // 如果在连续的七天内有一天没有签到，则返回false
            &#125;
        &#125;
        return true; // 连续七天都有签到
    &#125;

    public static void main(String[] args) &#123;
        DailyActiveUserCounter counter = new DailyActiveUserCounter();

        // 假设用户ID为12345，今天签到
        long userId = 12345;
        int today = 1; // 假设今天是第1天
        counter.userSignIn(userId, today);

        // 检查用户是否连续七天签到
        boolean isContinuous = counter.checkContinuousSignIn(userId, today);
        System.out.println(&quot;User &quot; + userId + &quot; has signed in for 7 consecutive days: &quot; + isContinuous);
    &#125;
&#125;
</code></pre>
<p>**bitmap（位图）<del>巨大的二进制数组</del>**：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大 【要数组足够大 误判率就小】</p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给某<strong>一个</strong>热点key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿<del>微博[鹿晗+关晓彤]</del>【并发同一时间访问】</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】[控制一个个来访问的次数]</p>
<p><del>AQS、ReentrantLock</del>是进程级别的互斥锁，因为有数据在节点1或节点2，<strong>分布式锁</strong>是在不同场景都可以锁也可以控制访问顺序。</p>
<p>以商品id作为key  先redis开始查缓存 判断是否为空 不为空直接return后解锁，空就先<strong>加锁</strong> 去数据库查完备份一份redis后<strong>解锁</strong>。被锁的其他线程在外面等待。</p>
<h6 id="★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"><a href="#★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。" class="headerlink" title="★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"></a>★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。</h6><p>方案：**<u>双重缓存校验</u>**  先查缓存 查不到加锁 再查缓存 查不到再去数据库 查完后看是否备份后解锁<del>冷代码</del></p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[  <u><em>不设置过期时间</em></u>  ] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内<strong>大量</strong>的缓存key同时失效或者<u>Redis服务宕机</u>，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值<del>不在同一时间过期</del></li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<h6 id="★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？"><a href="#★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？" class="headerlink" title="★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？"></a>★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？</h6><p><strong>try catch 在里面继续再去查mysql数据库</strong></p>
<h6 id="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"><a href="#降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。" class="headerlink" title="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"></a>降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。</h6><pre><code class="java">public boolean setData(String key, String value) &#123;
    try &#123;
        // 尝试将数据设置到Redis
        redisTemplate.opsForValue().set(key, value);
        return true;
    &#125; catch (Exception e) &#123;
        // 日志记录Redis错误
        log.error(&quot;Redis is down, failing over to MySQL&quot;, e);
        
        // Redis设置失败，降级到MySQL
        return setDataToMySQL(key, value);
    &#125;
&#125;

private boolean setDataToMySQL(String key, String value) &#123;
    // 这里实现将数据写入MySQL的逻辑
    // 例如：
    // mySqlTemplate.update(&quot;INSERT INTO cache (key, value) VALUES (?, ?)&quot;, key, value);
    // 注意：这里的mySqlTemplate和SQL语句需要根据实际情况调整
    return true; // 假设写入成功
&#125;
</code></pre>
<h6 id="如果公司对要求更高，需要限流降级、熔断"><a href="#如果公司对要求更高，需要限流降级、熔断" class="headerlink" title="如果公司对要求更高，需要限流降级、熔断"></a>如果公司对要求更高，需要限流<del>降级、熔断</del></h6><p>同一时间设置QPS为100 超过的返回友好提示[商品太火爆啦，请稍后再试]</p>
<h4 id="你有自己部署过环境吗"><a href="#你有自己部署过环境吗" class="headerlink" title="你有自己部署过环境吗"></a>你有自己部署过环境吗</h4><p>公司里面用 Jenkins + docker 测试环境我们部署 生产环境是组长部署</p>
<h4 id="未来1-3年规划"><a href="#未来1-3年规划" class="headerlink" title="未来1-3年规划"></a>未来1-3年规划</h4><p>将具体一点，从业务技术上提升自己的深度和广度达到高级工程师</p>
<h4 id="你平时做笔记吗"><a href="#你平时做笔记吗" class="headerlink" title="你平时做笔记吗"></a>你平时做笔记吗</h4><p>有做笔记 Xmind + Markdown<br>因为我觉得无论从网上的还是别人请教的不经历我的消化都不是我的东西<br>我还是会将这些知识点总结起来变成自己的知识</p>
<h4 id="什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？"><a href="#什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？" class="headerlink" title="什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？"></a>什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？</h4><h6 id="代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式"><a href="#代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式" class="headerlink" title="代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系装饰者模式"></a>代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系<del>装饰者模式</del></h6><p>在程序运行期间才会产生代理类加载到我们jvm中yaml文件</p>
<ul>
<li><h6 id="JDK动态代理是-基于接口实现来实现增强"><a href="#JDK动态代理是-基于接口实现来实现增强" class="headerlink" title="JDK动态代理是 基于接口实现来实现增强"></a>JDK动态代理是 <u>基于接口实现来实现增强</u></h6><p>[txt文本 把目标增强类 作为接口<del>本身就是接口</del> 实现过来写成源码 源文件 再用jdk工具把源码编译成class字节码 再用类加载器把class加载到jvm中]</p>
</li>
<li><h6 id="CGLIB动态代理是-基于继承目标类并覆写其方法来实现"><a href="#CGLIB动态代理是-基于继承目标类并覆写其方法来实现" class="headerlink" title="CGLIB动态代理是 基于继承目标类并覆写其方法来实现"></a>CGLIB动态代理是 <u>基于继承目标类并覆写其方法来实现</u></h6><p>[ASN字节码机制直接生成class 直接加载到内存中]<del>性能较高，速度更快。因为直接生成class</del></p>
</li>
</ul>
<p>要调用某个方法 CGLIB性能高 是通过反射来实现的 老版本的jdk的反射性能较低。如今在调用方法的性能上差距不大</p>
<p><strong>区别</strong>：</p>
<ul>
<li>JDK动态代理要求目标类必须实现一个或多个接口，而CGLIB没有这个要求。</li>
<li>JDK动态代理生成的代理类是接口的实现，而CGLIB生成的<strong>代理</strong>类是目标类的子类。</li>
<li>性能上，CGLIB通常比JDK动态代理更快，因为它直接操作字节码生成新的类。</li>
</ul>
<h4 id="什么样的代码是静态代理？"><a href="#什么样的代码是静态代理？" class="headerlink" title="什么样的代码是静态代理？"></a>什么样的代码是静态代理？</h4><p>发生在我们写代码的过程中 在编译阶段产生了代理类<br>静态代理是指代理类在编译时就已经确定，通常由程序员手动编写</p>
<h4 id="你用过Linux吗？"><a href="#你用过Linux吗？" class="headerlink" title="你用过Linux吗？"></a>你用过Linux吗？</h4><p>是的，我在工作中经常使用Linux操作系统。我熟悉Linux的基本命令<br>基础的命令：xxx【查看之前笔记】</p>
<h4 id="你工作的时候有需求文档吗？"><a href="#你工作的时候有需求文档吗？" class="headerlink" title="你工作的时候有需求文档吗？"></a>你工作的时候有需求文档吗？</h4><p>有的，<strong>有一些简单的需求是没有的</strong>[沟通成本太高了]<br><strong>稍微复杂的需求会有需求文档</strong>，我会根据需求文档来理解项目需求，并进行系统设计和开发。</p>
<h4 id="你有什么需要了解的？不要难为面试官-不问技术栈"><a href="#你有什么需要了解的？不要难为面试官-不问技术栈" class="headerlink" title="你有什么需要了解的？不要难为面试官,不问技术栈"></a><span style="color:red">你有什么需要了解的？</span><del>不要难为面试官,不问技术栈</del></h4><p>我想了解一下贵公司的业务是什么…好的那我这块已经没有什么想了解的了 <span style="color:red">感谢面试官</span><br>HR：想了解一下贵公司的上班时间…<br>我没有什么想了解的，来之前有了解过贵公司</p>
<h4 id="平时用注解创建的bean是单例的还是多例的？"><a href="#平时用注解创建的bean是单例的还是多例的？" class="headerlink" title="平时用注解创建的bean是单例的还是多例的？"></a>平时用注解创建的bean是单例的还是多例的？</h4><p>默认情况下，通过注解（如@Component、@Service、@Repository、@Bean等）创建的Bean是单例的。如果需要创建多例Bean，可以在注解上添加@Scope(“prototype”)来指定。</p>
<pre><code class="java">// 单例Bean
import org.springframework.stereotype.Component;

@Component
public class SingletonBean &#123;
    // Bean的代码
&#125;

----------------------------------------------------
    
// 多例Bean

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope(&quot;prototype&quot;)
public class PrototypeBean &#123;
    // Bean的代码
&#125;
</code></pre>
<h4 id="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"><a href="#SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？" class="headerlink" title="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"></a>SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？</h4><p><code>FROM -&gt; Join -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY -&gt; limit</code><br>这样的顺序是为了优化查询性能。首先确定数据来源（FROM），然后筛选出满足条件的数据（WHERE），接着进行分组（GROUP BY），在分组的基础上进行进一步筛选（HAVING），然后选择需要的数据（SELECT），最后对结果进行排序（ORDER BY）。这样的顺序可以减少中间结果集的大小，提高查询效率。</p>
<h6 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h6><p><code>select -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; having -&gt; order by -&gt; limit</code></p>
<h4 id="线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答"><a href="#线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答" class="headerlink" title="线上项目发生死锁如何去解决？ 我暂时没遇到过→分布式事务上去答"></a>线上项目发生死锁如何去解决？ <del>我暂时没遇到过→分布式事务上去答</del></h4><p><strong>死锁</strong>：两个线程争夺两个资源的时候  <code>1线程拿到a 想拿b   2线程拿到了b 想拿a</code><br><strong>四个原因</strong>：<u>互斥条件 请求保持 不可剥夺 循环等待</u><br>产生死锁的四个因素 同时满足才会死锁     想要解决死锁 需要打破其中一个原因就行</p>
<blockquote>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时使用。即某个资源在一段时间内只能由一个线程占用，其他线程必须等待该资源被释放后才能使用。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源又被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：已经分配给某个线程的资源在该线程完成任务前不能被抢占，即只能由线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一种线程资源的循环等待链，每个线程都在等待下一个线程所持有的资源。</li>
</ol>
</blockquote>
<blockquote>
<h4 id="在实际操作中，以下是一些打破死锁的具体方法："><a href="#在实际操作中，以下是一些打破死锁的具体方法：" class="headerlink" title="在实际操作中，以下是一些打破死锁的具体方法："></a>在实际操作中，以下是一些打破死锁的具体方法：</h4><ul>
<li><strong>资源分配图</strong>：使用资源分配图来检测循环等待条件，并在检测到循环时采取措施。</li>
<li><strong>锁排序</strong>：确保所有线程以相同的顺序获取锁，从而避免循环等待。</li>
<li><strong>超时机制</strong>：线程在请求资源时设置超时时间，如果超过时间未获得资源，则放弃当前任务并释放已持有的资源。</li>
<li><strong>死锁检测算法</strong>：运行死锁检测算法，如银行家算法，来检测系统中的死锁，并在必要时采取措施。</li>
<li><strong>线程中断</strong>：允许系统或其他线程中断正在等待资源的线程。</li>
<li><strong>回滚操作</strong>：如果检测到死锁，可以让某些线程回滚它们的工作，并释放资源，从而打破死锁。</li>
</ul>
</blockquote>
<p>MySQL是不会有死锁的 自身会检测 [让后面的超时释放回滚]<br>在分布式事务 线程1拿着资源a是数据库1 线程2拿着资源b是数据库2<br>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<h4 id="如果你遇到-新的-技术栈，怎么去解决"><a href="#如果你遇到-新的-技术栈，怎么去解决" class="headerlink" title="如果你遇到(新的)技术栈，怎么去解决?"></a>如果你遇到(新的)技术栈，怎么去解决?</h4><p>【return Previous.notes(NowDay);】</p>
<h4 id="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通"><a href="#如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通" class="headerlink" title="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?"></a>如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?</h4><p>首先尝试自己解决问题，通过搜索引擎、官方文档、Debug等。<br>尽可能不让这个问题不出现风险 实在解决不了就向上反馈 寻求帮助 请教上司领导或同事<br>平常和项目经理进行沟通 如果需求评审有些不理解还是会及时沟通 不清楚的一定要及时明确</p>
<h4 id="对于加班情况怎么看"><a href="#对于加班情况怎么看" class="headerlink" title="对于加班情况怎么看?"></a>对于加班情况怎么看?</h4><p>为了确保项目进度和团队利益，加班是可以接受的。</p>
<h4 id="多线程怎么保证线程之间的安全"><a href="#多线程怎么保证线程之间的安全" class="headerlink" title="多线程怎么保证线程之间的安全"></a>多线程怎么保证线程之间的安全</h4><h6 id="加锁-不让多线程抢夺资源"><a href="#加锁-不让多线程抢夺资源" class="headerlink" title="加锁  不让多线程抢夺资源"></a>加锁  不让多线程抢夺资源</h6><p>互斥锁、读写锁、线程局部存储(ThreadLocal每个线程独享自己变量)</p>
<h4 id="mybatis中-和-的区别，哪个更好-为什么"><a href="#mybatis中-和-的区别，哪个更好-为什么" class="headerlink" title="mybatis中${}和#{}的区别，哪个更好? 为什么?"></a>mybatis中${}和#{}的区别，哪个更好? 为什么?</h4><ol>
<li><h5 id="（字符串替换）："><a href="#（字符串替换）：" class="headerlink" title="${}（字符串替换）："></a><code>$&#123;&#125;</code>（字符串替换）：</h5><ul>
<li><code>$&#123;&#125;</code>会将参数直接替换到SQL语句中，不进行任何转义处理。</li>
<li>它适用于动态SQL中的表名或列名，或者在SQL语句中需要使用特定数据库函数的情况。</li>
<li>使用<code>$&#123;&#125;</code>时，如果参数是用户输入的，那么可能会引发SQL注入攻击，因为它不会对参数进行转义。</li>
</ul>
</li>
<li><h5 id="（预处理语句参数）："><a href="#（预处理语句参数）：" class="headerlink" title="#{}（预处理语句参数）："></a><code>#&#123;&#125;</code>（预处理语句参数）：</h5><ul>
<li><code>#&#123;&#125;</code>会创建预处理语句（prepared statement）的参数占位符，并在设置参数时进行适当的转义处理。</li>
<li>它适用于大部分情况，特别是当参数是用户输入时，可以有效防止SQL注入攻击。</li>
<li>MyBatis会根据参数的类型自动选择<code>setString</code>、<code>setInt</code>、<code>setDate</code>等预处理语句方法。</li>
</ul>
</li>
<li><h5 id="在大多数情况下，-是更好的选择，因为它提供了以下优势："><a href="#在大多数情况下，-是更好的选择，因为它提供了以下优势：" class="headerlink" title="在大多数情况下，#{}是更好的选择，因为它提供了以下优势："></a>在大多数情况下，<code>#&#123;&#125;</code>是更好的选择，因为它提供了以下优势：</h5><ul>
<li><strong>安全性</strong>：<code>#&#123;&#125;</code>可以防止SQL注入攻击，因为它会自动转义参数。</li>
<li><strong>类型处理</strong>：MyBatis会根据参数的实际类型来设置预处理语句的参数，这减少了类型错误的可能性。</li>
<li><strong>可读性和维护性</strong>：使用<code>#&#123;&#125;</code>可以使SQL语句更加清晰，因为它清楚地标识了参数的位置。</li>
</ul>
<p>然而，在某些特定的场景下，如需要动态地指定表名或列名时，<code>$&#123;&#125;</code>是必要的，因为预处理语句</p>
</li>
</ol>
<h4 id="说一下内连接和外连接的区别"><a href="#说一下内连接和外连接的区别" class="headerlink" title="说一下内连接和外连接的区别"></a>说一下内连接和外连接的区别</h4><p><strong>左外连接（Left Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：左外连接返回左表中的所有行，即使在右表中没有匹配的行。对于左表中没有匹配的行，结果集中的右表部分将包含NULL。</li>
<li>如果左表是主表，或者左表中的数据是查询的主要关注点，而右表中的数据是辅助信息时，通常使用左外连接。</li>
</ul>
<p><strong>右外连接（Right Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：右外连接返回右表中的所有行，即使在左表中没有匹配的行。对于右表中没有匹配的行，结果集中的左表部分将包含NULL。</li>
<li>如果右表是主表，或者右表中的数据是查询的主要关注点，而左表中的数据是辅助信息时，通常使用右外连接</li>
</ul>
<p><strong>全外连接（Full Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：全外连接返回左表和右表中的所有行。当某行在另一个表中没有匹配时，结果集中的相应部分将包含NULL。</li>
<li>全外连接不常用，因为它通常会返回大量的包含NULL的数据，这可能会导致查询结果难以解释。只有在确实需要两表中的所有数据时才使用。</li>
</ul>
<hr>
<blockquote>
<ul>
<li><strong>性能考虑</strong>：外连接可能会比内连接（Inner Join）更消耗资源，特别是当表很大时。如果可能，尽量使用内连接。</li>
<li><strong>数据完整性</strong>：如果业务逻辑要求查询结果必须包含某个表的所有记录，那么应该使用相应的外连接。</li>
</ul>
</blockquote>
<h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>xxx</p>
<h4 id="你觉得学习我们这些技术最重要的是什么"><a href="#你觉得学习我们这些技术最重要的是什么" class="headerlink" title="你觉得学习我们这些技术最重要的是什么?"></a>你觉得学习我们这些技术最重要的是什么?</h4><p>首先要清楚**<u>这个技术是解决什么领域的问题</u>**，学习技术很多方面都是用来服务业务的，结合实际业务来学习技术融合性会更强</p>
<h4 id="技术栈有些不同，有没有想过换方向发展"><a href="#技术栈有些不同，有没有想过换方向发展" class="headerlink" title="技术栈有些不同，有没有想过换方向发展?"></a>技术栈有些不同，有没有想过换方向发展?</h4><p>没问题的 因为技术是相通的 可以去学新技术</p>
<h3 id="ThreadLocal相关面试题"><a href="#ThreadLocal相关面试题" class="headerlink" title="ThreadLocal相关面试题"></a>ThreadLocal相关面试题</h3><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h5><p>ThreadLocal(定义全局静态变量 项目中共用)是Java中的一个线程局部变量工具类，它提供了一种在多线程环境下，每个线程都可以独立访问自己的变量副本的机制。ThreadLocal中存储的数据对于每个线程来说都是独立的，互不干扰。</p>
<h5 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h5><p>ThreadLocal适用于以下场景：</p>
<ul>
<li>在多线程环境下，需要保持线程安全性的数据访问。</li>
<li>需要在多个方法之间共享数据，但又不希望使用传递参数的方式。<ul>
<li>在传递登录用户id是非常方便且适用</li>
</ul>
</li>
</ul>
<p><strong>以后获取用户id不用再解析token了，线程拿仅仅拿当前线程的数据 每个登录的用户都有自己的threadlocal数据</strong></p>
<p><strong>ThreadLocal</strong>并不是一个Thread，<strong>而是Thread的局部变量</strong>【可以存储数据】<br>ThreadLocal<strong>为每个线程提供单独一份存储空间</strong>，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。**<u>ThreadLocal实现一个线程内传递数据</u>**[就不用一个个参数往后传递了]<br>注意：客户端发送的每次请求，后端的tomcat服务器都会分配一个单独的线程来处理请求</p>
<ul>
<li><strong><u>一个请求是一个线程</u></strong>[意义：在第一个线程里面使用ThreadLocal存储用户Id 在后面controller或service中就可以取出来用户id]</li>
<li>第二个请求就是另一个线程 线程池用完第一个放回线程池 也有可能把上一个线程接着给它用</li>
</ul>
<p><code>postHandle </code>只有在正确调用返回才会引用 如果抛出异常则不会使用<br><code>afterCompletion </code>无论怎样最后都要运行</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h6 id="3-1-创建ThreadLocal对象"><a href="#3-1-创建ThreadLocal对象" class="headerlink" title="3.1 创建ThreadLocal对象"></a>3.1 创建ThreadLocal对象</h6><p>首先，我们需要创建一个ThreadLocal对象来存储线程局部变量。可以使用ThreadLocal的默认构造函数创建一个新的实例。【给每个线程拷贝一份 synchn + Lock锁】</p>
<pre><code class="Java">ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</code></pre>
<h6 id="3-2-设置线程局部变量的值"><a href="#3-2-设置线程局部变量的值" class="headerlink" title="3.2 设置线程局部变量的值"></a>3.2 设置线程局部变量的值</h6><p>使用<code>set()</code>方法可以设置当前线程的局部变量的值。</p>
<pre><code class="Java">threadLocal.set(&quot;value&quot;);
</code></pre>
<h6 id="3-3-获取线程局部变量的值"><a href="#3-3-获取线程局部变量的值" class="headerlink" title="3.3 获取线程局部变量的值"></a>3.3 获取线程局部变量的值</h6><p>使用<code>get()</code>方法可以获取当前线程的局部变量的值。</p>
<pre><code class="Java">String value = threadLocal.get();
</code></pre>
<h6 id="3-4-清除线程局部变量的值"><a href="#3-4-清除线程局部变量的值" class="headerlink" title="3.4 清除线程局部变量的值"></a>3.4 清除线程局部变量的值</h6><p>使用<code>remove()</code>方法可以清除当前线程的局部变量的值，建议在整个请求使用完一定要执行remove清除数据，不然可能会发生内存泄漏问题。</p>
<pre><code class="Java">threadLocal.remove();
</code></pre>
<h6 id="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"><a href="#下面是一个简单的示例代码，演示了如何使用ThreadLocal。" class="headerlink" title="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"></a>下面是一个简单的示例代码，演示了如何使用ThreadLocal。</h6><pre><code class="Java">public class ThreadLocalTest &#123;

    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();

    public static void main(String[] args) &#123;

        Thread t1 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itheima&quot;);
            getData(&quot;t1&quot;);
        &#125;, &quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itcast&quot;);
            getData(&quot;t2&quot;);
        &#125;, &quot;t1&quot;);

        t1.start();
        t2.start();

    &#125;

    private static void getData(String threadName)&#123;
        Object data = THREAD_LOCAL.get();
        System.out.println(threadName+&quot;-&quot;+data);
    &#125;
&#125;
</code></pre>
<p>运行以上代码，输出结果为：</p>
<pre><code class="Plain">t1-itheima
t2-itcast
</code></pre>
<p>在任意位置都可以调用Threadlocal，线程隔离互不影响，解决了线程安全问题：[每个线程存一份 线程不共享]</p>
<p>用mybatis+建造者模式 一定要在类里面加 一定要具有有参和无参构造缺一不可 否则mybatis数据封装无法映射<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Builder</p>
<h4 id="字符和字符串类型的区别"><a href="#字符和字符串类型的区别" class="headerlink" title="字符和字符串类型的区别"></a>字符和字符串类型的区别</h4><p>字符是基本数据类型 没有null 用单引号<br>字符串是引用数据类型[一个类] 用双引号</p>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250102142357092.png" alt="image-20250102142357092"></p>
<h4 id="操作字符串的工具类是什么"><a href="#操作字符串的工具类是什么" class="headerlink" title="操作字符串的工具类是什么"></a>操作字符串的工具类是什么</h4><p>apache的common提供的String Utils工具类，hutool也有String Utils</p>
<h4 id="局部变量和成员变量的区别"><a href="#局部变量和成员变量的区别" class="headerlink" title="局部变量和成员变量的区别"></a>局部变量和成员变量的区别</h4><p><strong>成员变量</strong>是在jvm的<strong>堆</strong><br><strong>局部变量</strong>是在jvm的<strong>栈</strong><br>基本数据类型的引用类型 类在堆<br>基本数据类型的成员变量在堆 非静态在堆 静态变量在方法区<br>引用类型 无论静态还是非静态成员变量都在堆区</p>
<p>局部变量是在方法或代码块内部声明的变量，其作用域仅限于声明它的方法或代码块<br>局部变量不能被static修饰<br>局部变量必须被初始化才能使用</p>
<p>成员变量是在类内部声明的变量，其作用域是整个类<br>成员变量可以被static修饰<br>成员变量有默认值</p>
<h4 id="你编写完代码，写完这个功能后，会进行什么操作呢"><a href="#你编写完代码，写完这个功能后，会进行什么操作呢" class="headerlink" title="你编写完代码，写完这个功能后，会进行什么操作呢"></a>你编写完代码，写完这个功能后，会进行什么操作呢</h4><p>进行<strong>代码审查</strong>，检查代码是否符合编码规范和设计要求。</p>
<ul>
<li>进行<strong>单元测试</strong>，确保代码的功能正确无误。</li>
<li>进行<strong>代码优化</strong>，提高代码的性能和可维护性。</li>
<li>与团队成员进行代码合并，确保代码的集成。</li>
<li>编写文档，记录功能实现和代码变更。</li>
</ul>
<h4 id="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"><a href="#上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？" class="headerlink" title="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"></a>上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？</h4><p>期望薪资：<br>了解过广东这边的市场 我想换工作想涨薪10~20%<br>节假日会发放礼品和福利</p>
<h4 id="可以接受低代码平台吗？"><a href="#可以接受低代码平台吗？" class="headerlink" title="可以接受低代码平台吗？"></a>可以接受低代码平台吗？</h4><p>可以接受<br>低代码平台：类若依</p>
<h4 id="具体说说Java面向对象"><a href="#具体说说Java面向对象" class="headerlink" title="具体说说Java面向对象"></a>具体说说Java面向对象</h4><p>Java面向对象是一种编程范式，<strong>它将现实世界的事物抽象成程序中的对象</strong>。Java面向对象的主要特征包括：</p>
<ul>
<li><strong>封装</strong>：将对象的<strong>属性</strong>和<strong>行为</strong>封装在一起，对外只暴露必要的接口，隐藏内部实现细节。</li>
<li><strong>继承</strong>：允许<strong>子类继承父类的属性和行为</strong>，实现代码的复用。</li>
<li><strong>多态</strong>：<strong>同一个接口可以有多个不同的实现</strong>，通过对象的类型和方法的调用，实现不同的功能。</li>
</ul>
<h4 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别"></a>&#x3D;&#x3D; 和 equals 的区别</h4><ul>
<li>&#x3D;&#x3D;：比较<strong>基本数据类型</strong>时，比较的是<strong>值</strong>；比较<strong>引用数据类型</strong>时，比较的是对象的<strong>内存地址</strong>。</li>
<li>equals：是Object类的一个方法，<strong>默认比较</strong>的是<strong>对象的内存地址</strong>。但在很多类中（如String、Integer等），equals方法被重写，用于比较对象的内容是否相等。<br>没重写 就是 &#x3D;&#x3D; 比较对象地址。重写过的话就比较对象的值。</li>
</ul>
<h4 id="有没有做过权限控制，整个系统的权限"><a href="#有没有做过权限控制，整个系统的权限" class="headerlink" title="有没有做过权限控制，整个系统的权限"></a>有没有做过权限控制，整个系统的权限</h4><p>有过 SpringSecurity</p>
<h6 id="能具体说一下权限控制怎么做？"><a href="#能具体说一下权限控制怎么做？" class="headerlink" title="能具体说一下权限控制怎么做？"></a>能具体说一下权限控制怎么做？</h6><p>使用RBAC模型 不是把用户关联资源 而是中间利用角色间接关联<br><u>用户+角色+资源+用户角色中间表+角色资源中间表<del>多对多</del></u></p>
<h6 id="SpringSecurity-具体怎么实现"><a href="#SpringSecurity-具体怎么实现" class="headerlink" title="SpringSecurity 具体怎么实现"></a>SpringSecurity 具体怎么实现</h6><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息。</p>
<h4 id="线程池有哪些状态，这些状态是怎么进行转换的"><a href="#线程池有哪些状态，这些状态是怎么进行转换的" class="headerlink" title="线程池有哪些状态，这些状态是怎么进行转换的"></a>线程池有哪些状态，这些状态是怎么进行转换的</h4><p>线程池有以下几种状态：</p>
<ul>
<li>RUNNING：线程池正常运行，可以接受新的任务和处理任务队列中的任务。</li>
<li>SHUTDOWN：线程池不再接受新的任务，但会处理任务队列中的任务。</li>
<li>STOP：线程池不再接受新的任务，也不处理任务队列中的任务，并且会中断正在执行的任务。</li>
<li>TIDYING：所有任务都已终止，线程池即将关闭。</li>
<li>TERMINATED：线程池已关闭。</li>
</ul>
<p>状态转换过程如下：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：调用shutdown()方法。</li>
<li>RUNNING -&gt; STOP：调用shutdownNow()方法。</li>
<li>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空时。</li>
<li>STOP -&gt; TIDYING：当线程池为空时。</li>
<li>TIDYING -&gt; TERMINATED：当terminated()钩子方法执行完成后。</li>
</ul>
<h4 id="说一下怎么使用多线程？"><a href="#说一下怎么使用多线程？" class="headerlink" title="说一下怎么使用多线程？"></a>说一下怎么使用多线程？</h4><ul>
<li><p>继承Thread类，并重写run()方法。</p>
</li>
<li><p>实现Runnable接口，并将实现类传递给Thread对象。</p>
</li>
<li><p>实现Callable接口，实现<code>call()</code>方法</p>
</li>
<li><p>使用Executor框架，如ExecutorService和ThreadPoolExecutor来管理线程池。</p>
</li>
</ul>
<h4 id="操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？"><a href="#操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？" class="headerlink" title="操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？"></a>操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？</h4><ul>
<li>新建（New）：创建后尚未启动的线程处于这个状态。<code>new Thread</code></li>
<li>可运行（Runnable）：包括运行（Running）和就绪（Ready）状态，线程正在执行或等待CPU调度。</li>
<li>阻塞（Blocked）：线程因为等待某些资源或锁而被阻塞。notify可以唤醒阻塞状态 睡眠完会自动唤醒</li>
<li>等待（Waiting）：线程等待其他线程执行特定操作（如通知）。</li>
<li>计时等待（Timed Waiting）：线程在一定时间内等待另一个线程的通知。</li>
<li>终止（Terminated）：线程执行完成或因异常而终止。</li>
</ul>
<h6 id="怎么把线程杀死-终止"><a href="#怎么把线程杀死-终止" class="headerlink" title="怎么把线程杀死 终止"></a>怎么把线程杀死 终止</h6><p><strong>stop</strong>()方法[暴力方法]    <strong>interrupt</strong>()方法[优雅关闭线程]    正常回收</p>
<h4 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h4><p>乐观锁：读多写少 线程执行时间相差较大  并发不太激烈</p>
<p>悲观锁：写多读少 线程执行时间相差不大 竞争激烈 并发锁多</p>
<p>加锁的时机不一样，<br>悲观锁：没改数据的时候先加锁 比较明显利用底层操作系统api实现<br>乐观锁：在改数据的时候才加锁 依靠底层的硬件</p>
<p><strong>java层面</strong>：<code>synchronized  ReentrantLock</code></p>
<p><strong>数据库层面</strong>：<br>悲观锁：select for update是mysql的的实现<br>乐观锁：JUC Java Util Concurrent）是Java并发工具包</p>
<blockquote>
<p><code>SELECT ... FOR UPDATE</code>：这个语句在读取记录时会锁定这些记录，直到事务提交或回滚。其他的事务不能更新这些锁定的记录，这是悲观锁的一个典型实现</p>
</blockquote>
<p>乐观锁要读取目前旧的值再将新设置的值以及旧的值比较 如果相同 就把新的值更新 如果不相同 就把旧的值重新提取 因为在这期间有人读取了这个数据跟我之前不一样(底层api 要调用两个 一个旧的值 一个新的值)。一般乐观锁是结合自旋 类于while(true)直到读到为止 <code>要设计次数后再报错</code></p>
<p>要更新数据库某个值 把旧的值读出来 想更新银行里的余额<br>这是<strong>典型的ABA问题</strong>：<u>要用<strong>时间戳</strong>或<strong>自增版本号</strong>去做</u></p>
<h4 id="Stream流的使用及常用API"><a href="#Stream流的使用及常用API" class="headerlink" title="Stream流的使用及常用API"></a>Stream流的使用及常用API</h4><p>Stream是Java 8中引入的一种新特性，用于简化数据处理和操作。它可以用来解决集合循环遍历处理的问题。在此之前用循环来代替</p>
<blockquote>
<h3 id="基础Stream操作"><a href="#基础Stream操作" class="headerlink" title="基础Stream操作"></a>基础Stream操作</h3><ul>
<li><code>stream()</code>: 为集合创建串行流。</li>
<li><code>parallelStream()</code>: 为集合创建并行流。</li>
<li><code>forEach</code>: 对每个元素执行操作。</li>
<li><code>map</code>: 将每个元素映射到对应的结果。</li>
<li><code>filter</code>: 过滤出满足条件的元素。</li>
<li><code>limit</code>: 限制流的大小。</li>
<li><code>skip</code>: 跳过流中的前n个元素。</li>
<li><code>sorted</code>: 对流进行排序。</li>
</ul>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><ul>
<li><code>collect</code>: 将流转换为其他形式，比如列表、集合或Map。</li>
<li><code>reduce</code>: 通过一个起始值，反复利用BinaryOperator来处理和累积元素，返回一个值。</li>
<li><code>count</code>: 返回流中元素的数量。</li>
<li><code>min</code> &#x2F; <code>max</code>: 找到流中的最小&#x2F;最大值。</li>
<li><code>anyMatch</code>: 流中是否有一个元素匹配给定的谓词。</li>
<li><code>allMatch</code>: 流中的所有元素是否都匹配给定的谓词。</li>
<li><code>noneMatch</code>: 流中没有任何元素匹配给定的谓词。</li>
<li><code>findFirst</code>: 返回第一个元素。</li>
<li><code>findAny</code>: 返回当前流中的任意元素。</li>
</ul>
</blockquote>
<h4 id="项目中具体用到哪些设计模式"><a href="#项目中具体用到哪些设计模式" class="headerlink" title="项目中具体用到哪些设计模式"></a>项目中具体用到哪些<span style = "color:red">设计模式</span></h4><p><del><strong>单例模式</strong>：确保一个类只有一个实例，例如配置文件管理器。</del>[<u>Spring原本设计好的</u>]<br><strong><u>工厂模式</u><strong>：创建对象时无需指定具体的类，例如日志工厂。<br><strong>观察者模式</strong>：当一个对象状态发生改变时，</strong>所有依赖于它的对象</strong>都得到通知并自动更新，例如事件监听。<br>**<u>策略模式</u>**：定义一系列算法，将每个算法封装起来，并使它们可以互换，例如支付策略。<br><strong>模板方法模式</strong>：在项目中，我有一些具有相同操作步骤但具体实现不同的算法，我使用了模板方法模式来定义这些步骤的骨架，将具体的步骤实现留给子类。任链模式的目的是将请求的发送者和接收者解耦，从而使得多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。<br><strong>责任链模式</strong>：它允许将请求沿着处理者链进行发送。收到请求后，每个处理者都有机会对请求进行处理，或者将其传递给链上的下一个处理者。这样，请求就能在一系列处理者中传递，直到有一个处理者对其进行处理为止。    </p>
<p>1.<u>递归方式</u> ：在递归模式中，每个处理者内部调用下一个处理者的处理方法。如果当前处理者无法处理请求，它会直接调用下一个处理者的处理方法。这种方式通常是通过<strong>递归调用</strong>来实现的<br>2.<u>迭代模式</u>：在迭代模式中，处理者链被构建为一个线性结构，每个处理者都有一个指向下一个处理者的引用。请求从链的第一个处理者开始，依次传递给下一个处理者，直到找到能够处理该请求的处理者为止。这种方式通常是通过循环迭代来实现的<br><strong>代理模式</strong>：为了控制对远程服务的访问，我使用了代理模式。代理负责处理所有与服务对象的交互，并在必要时进行延迟加载。</p>
<p>在我的项目中结合<strong>工厂模式</strong>和<strong>策略模式</strong>来设计登录接口时，我们可以将登录验证的逻辑抽象为一个策略接口，并为每种登录方式（如：用户名密码登录、手机验证码登录、社交账号登录等）实现具体的策略类。工厂类则负责创建并管理这些策略对象</p>
<h6 id="思考一个问题：哪些方式创建单例模式？"><a href="#思考一个问题：哪些方式创建单例模式？" class="headerlink" title="思考一个问题：哪些方式创建单例模式？"></a>思考一个问题：哪些方式创建单例模式？</h6><blockquote>
<h3 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h3><p>这种方式在类加载时不初始化。在需要的时候才创建对象，节约资源。</p>
<pre><code>public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="2-懒汉式，线程安全"><a href="#2-懒汉式，线程安全" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h3><p>通过同步方法确保线程安全。</p>
<pre><code>public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3. 饿汉式"></a>3. 饿汉式</h3><p>类加载时就完成了初始化，保证了线程的安全性。容易浪费资源</p>
<pre><code>public class Singleton &#123;
    private static Singleton instance = new Singleton();
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="4-双重校验锁"><a href="#4-双重校验锁" class="headerlink" title="4. 双重校验锁"></a>4. 双重校验锁</h3><p>线程安全且在实例域需要延迟加载时提高性能。</p>
<pre><code>public class Singleton &#123;
    private volatile static Singleton singleton;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (singleton == null) &#123;
            synchronized (Singleton.class) &#123;
                if (singleton == null) &#123;
                    singleton = new Singleton();
                &#125;
            &#125;
        &#125;
        return singleton;
    &#125;
&#125;
</code></pre>
<h3 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5. 静态内部类"></a>5. 静态内部类</h3><p>这种方式既实现了懒加载，又保证了线性安全。</p>
<pre><code>public class Singleton &#123;
    private static class SingletonHolder &#123;
        private static final Singleton INSTANCE = new Singleton();
    &#125;
    private Singleton() &#123;&#125;

    public static final Singleton getInstance() &#123;
        return SingletonHolder.INSTANCE;
    &#125;
&#125;
</code></pre>
<h3 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6. 枚举"></a>6. 枚举</h3><p>实现单例的最佳方法，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p>
<pre><code class="java">public enum Singleton &#123;
    INSTANCE;
    public void whateverMethod() &#123;
    &#125;
&#125;
</code></pre>
</blockquote>
<h4 id="MySQL支持四种隔离级别"><a href="#MySQL支持四种隔离级别" class="headerlink" title="MySQL支持四种隔离级别"></a><span style = "color:red"><u>MySQL支持四种隔离级别</u></span></h4><ul>
<li><p><u>第一个</u>是<strong>读未提交</strong>(readuncomm itted)它解决不了刚才提出的所有问题，一般项目中也不用这个。存在脏读问题  可解决不可重复读 幻读<br><code>**不可解决脏读**：读未提交允许一个事务读取另一个事务尚未提交的数据变更。如果一个事务读取了另一个事务的未提交数据，然后那个事务回滚，则第一个事务读取的数据就是无效的（脏数据）</code></p>
</li>
<li><p><u>第二个</u>是<strong>读已提交</strong>(readcomm ited)它能解决脏读的问题的，但是解决不了不可重复读和幻读。<br><code>**解决脏独**：读已提交确保一个事务只能读取已经提交的数据变更。如果一个事务正在修改某些数据，那么在它提交之前，其他事务不能读取这些数据。这样就可以避免脏读。</code><br><code>**不可解决不可重复读**：一个事务在读取某些数据后，另一个事务修改了这些数据并提交，导致第一个事务再次读取时得到不同的结果</code><br><code>**不可解决幻读**：一个事务在读取某个范围的数据后，另一个事务插入了一些新数据并提交，导致第一个事务在执行范围查询时看到了新插入的数据</code></p>
</li>
<li><p><u>第三个</u>是<strong>可重复读</strong>(repeatable read)它能解决脏读和不可重复读，但是解决不了幻读[解决了一部分]，这个也是mysql默认的隔离级别。</p>
</li>
<li><p><u>第四个</u>是<strong>串行化</strong>(serializable)它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。<br>串行化里的读也要加锁 表锁：整个表上锁            行锁：只对一行加锁<br><code>串行化是最严格的事务隔离级别。它通过强制事务串行执行来避免上述所有问题。在一个事务执行时，它会锁定涉及的所有数据行或表，直到事务完成。这确保了事务完全隔离，但是会显著降低系统的并发性能</code></p>
</li>
</ul>
<h6 id="什么时候上行锁-x2F-表锁？"><a href="#什么时候上行锁-x2F-表锁？" class="headerlink" title="什么时候上行锁&#x2F;表锁？"></a>什么时候上行锁&#x2F;表锁？</h6><p><code>INSERT</code>不带查询筛选条件  <strong>上行锁</strong><del>底层是索引，b+树底层叶子</del></p>
<blockquote>
<ul>
<li><strong>行锁</strong>：通常情况下，插入操作会锁定插入行所在的索引项，以防止其他事务同时修改同一行。这是因为数据库通常使用B+树来维护索引，<strong>插入操作需要在B+树中找到正确的位置来插入新的索引项</strong>。如果插入操作涉及到唯一索引，数据库还会检查是否有重复的键值，这也会触发行锁。</li>
<li><strong>注意</strong>：即使插入操作没有查询筛选条件，它仍然可能涉及到行锁，因为数据库需要保证新插入的数据不会与现有数据冲突。</li>
</ul>
</blockquote>
<p><code>UPDATE</code>看where后面的条件 <strong>带索引</strong>加行锁<del>构建b+树</del> <strong>不带索引</strong>的加表锁<br>表锁的速度比行锁速度快</p>
<blockquote>
<h6 id="带索引的条件："><a href="#带索引的条件：" class="headerlink" title="带索引的条件："></a>带索引的条件：</h6><ul>
<li><strong>行锁</strong>：如果更新操作的条件是索引列，数据库能够快速定位到需要更新的行，因此只会锁定那些特定的行。行锁可以最大程度地减少锁定的数据量，从而提高并发性能。</li>
<li><strong>原理</strong>：数据库使用B+树索引来快速查找满足条件的行，然后对这些行加锁。</li>
</ul>
<h6 id="不带索引的条件："><a href="#不带索引的条件：" class="headerlink" title="不带索引的条件："></a>不带索引的条件：</h6><ul>
<li><strong>表锁</strong>：如果更新操作的条件不是索引列，数据库可能需要扫描整个表来找到需要更新的行。在这种情况下，为了简化锁定逻辑并防止在扫描过程中数据被修改，数据库可能会选择锁定整个表。</li>
<li><strong>原理</strong>：由于没有索引可以利用，数据库必须检查每一行来确定是否满足更新条件，因此使用表锁可以避免复杂的锁定管理。</li>
</ul>
</blockquote>
<p>MVCC底层是多版本并发控制 但底层并不怎么了解</p>
<h4 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h4><p><strong>浅拷贝</strong>：只复制对象的<strong>基本数据类型</strong>和<strong>引用类型地址</strong>，不复制引用类型指向的对象。如果原对象和浅拷贝对象中的一个改变了引用类型，另一个也会受到影响。旧对象改变新对象也会改变。<br><strong>深拷贝</strong>：创建一个新的对象，并复制对象的所有字段，包括基本数据类型和引用类型指向的对象。原对象和深拷贝对象之间不会相互影响。旧对象改变新对象不会改变<br>  Java是值传递 </p>
<h6 id="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"><a href="#如何实现深拷贝？数组不需要重写【体现了原型设计模式】" class="headerlink" title="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"></a>如何实现深拷贝？<del>数组不需要重写</del>【体现了<code>原型设计模式</code>】</h6><ul>
<li><p>实现<strong>Cloneable接口</strong>并重写<strong>clone</strong>方法 会调用构造方法</p>
<p>这是最常见的实现深拷贝的方法。首先，你的类需要实现<code>Cloneable</code>接口，然后重写<code>clone()</code>方法<del>构造新对象的过程</del>，并在该方法中调用<code>super.clone()</code>，同时递归地克隆所有引用类型的字段。[如果里面有多层嵌套复杂对象 在每层都要实现Cloneable接口一直重写到基本数据类型的时候才停止]</p>
</li>
</ul>
<pre><code class="java">public class Person implements Cloneable &#123;
    private int age;
    private Address address;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Person cloned = (Person) super.clone();
        // 假设Address也实现了Cloneable接口
        cloned.address = (Address) this.address.clone(); 
        return cloned;
    &#125;
&#125;

public class Address implements Cloneable &#123;
    private String street;
    private String city;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
&#125;
</code></pre>
<ul>
<li>通过<strong>序列化</strong><del>对象转二进制</del>和<strong>反序列化</strong><del>二进制转对象</del>。这种方式不需要实现<code>Cloneable</code>接口，但你的类需要实现<code>Serializable</code>接口。反序列化不会调用构造方法</li>
</ul>
<h4 id="开启线程的时候为什么用的是thread-start方法："><a href="#开启线程的时候为什么用的是thread-start方法：" class="headerlink" title="开启线程的时候为什么用的是thread.start方法："></a>开启线程的时候为什么用的是thread.start方法：</h4><p>thread.start()方法用于<strong>启动一个新线程</strong>，并执行<strong>该线程</strong>的run()方法。调用start()方法后，线程会被放入线程调度队列，等待CPU调度执行。</p>
<p>直接调用run()方法，并<strong>不会启动</strong>一个新线程，而是在当前线程中执行run()方法，这不符合多线程编程的目的。使用start()方法可以确保线程并发执行，提高程序的性能和响应速度。</p>
<p>java没权限开启一个线程 要调用底层的操作系统 在JVM的底层实现中，会有相应的本地（C或C++）方法来处理线程的创建和管理</p>
<h4 id="你在你们项目中使用过多线程吗"><a href="#你在你们项目中使用过多线程吗" class="headerlink" title="你在你们项目中使用过多线程吗?"></a>你在你们项目中使用过多线程吗?</h4><p>是的，在我们的项目中，我确实使用过多线程。 【结合项目去说】<br>在处理大量数据计算或执行耗时的IO操作时，我会使用Java的线程池（如ExecutorService）来并行处理任务，以提高系统的响应速度和吞吐量<br><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250107153246645.png" alt="image-20250107153246645"></p>
<blockquote>
<h6 id="我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统"><a href="#我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统" class="headerlink" title="我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统"></a>我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统</h6><h5 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h5><p>该系统需要处理大量的订单，包括订单验证、库存检查、支付处理和订单状态更新。为了提高处理效率，我们决定使用多线程来并行处理订单。</p>
<pre><code class="java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.Random;

public class OrderProcessingSystem &#123;

    public static void main(String[] args) &#123;
        // 创建一个固定大小的线程池
        int numberOfProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(numberOfProcessors);

        // 模拟订单队列
        Random random = new Random();
        for (int orderId = 1; orderId &lt;= 100; orderId++) &#123;
            int finalOrderId = orderId;
            executor.submit(() -&gt; &#123;
                processOrder(finalOrderId, random.nextInt(1000));
            &#125;);
        &#125;

        // 关闭线程池
        executor.shutdown();
        try &#123;
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) &#123;
                executor.shutdownNow();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        &#125;
    &#125;

    private static void processOrder(int orderId, int orderAmount) &#123;
        System.out.println(&quot;Processing order ID: &quot; + orderId + &quot; - Thread: &quot; + Thread.currentThread().getName());
        
        // 模拟订单验证
        validateOrder(orderId);
        
        // 模拟库存检查
        checkInventory(orderId);
        
        // 模拟支付处理
        processPayment(orderId, orderAmount);
        
        // 更新订单状态
        updateOrderStatus(orderId, &quot;Completed&quot;);
    &#125;

    private static void validateOrder(int orderId) &#123;
        // 模拟订单验证逻辑
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
        System.out.println(&quot;Order ID &quot; + orderId + &quot; validated.&quot;);
    &#125;

    private static void checkInventory(int orderId) &#123;
        // 模拟库存检查逻辑
        try &#123;
            Thread.sleep(200);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
        System.out.println(&quot;Inventory checked for Order ID &quot; + orderId + &quot;.&quot;);
    &#125;

    private static void processPayment(int orderId, int orderAmount) &#123;
        // 模拟支付处理逻辑
        try &#123;
            Thread.sleep(300);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
        System.out.println(&quot;Payment processed for Order ID &quot; + orderId + &quot; - Amount: &quot; + orderAmount);
    &#125;

    private static void updateOrderStatus(int orderId, String status) &#123;
        // 模拟订单状态更新逻辑
        System.out.println(&quot;Order ID &quot; + orderId + &quot; status updated to &quot; + status + &quot;.&quot;);
    &#125;
&#125;
</code></pre>
<p>在这个示例中，我们创建了一个固定大小的线程池，其大小等于可用处理器的数量。然后，我们模拟了一个包含100个订单的队列，并为每个订单提交了一个任务到线程池中。每个任务代表订单处理的整个流程，包括验证、库存检查、支付处理和状态更新。<strong>每个步骤都通过休眠来模拟耗时操作</strong>。最后，我们关闭线程池并等待所有任务完成。</p>
</blockquote>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><p><strong>sleep</strong>是Thread类的一个静态方法，它使当前线程暂停执行指定的时间，但不会释放锁资源。<br><strong>wait</strong>是Object类的一个方法，它使当前线程<strong>暂停执行</strong>并<strong>释放当前对象上的锁</strong>，直到另一个线程调用同一个对象的<code>notify()</code>或<code>notifyAll()</code>方法，或者过了指定的等待时间。</p>
<p>sleep是线程内的静态方法 需要指定睡眠的时间 或者自动自己唤醒 不会释放锁<br>wait是Object类的一个方法 可以指定睡眠时间 不指定就等于无限期 要释放锁<br>wait一定要搭配<code>synchronized</code>，且都为同一个对象 synchronized锁住了wait<del>万物对象皆为锁</del><br>可以被唤醒<code>notify()</code>或<code>notifyAll()</code>方法   区别：notify是随机唤醒一个 notifyall会唤醒全部</p>
<p>普通方法上 锁的是this<br>静态方法上 锁的是当前类的class对象</p>
<h4 id="ConcurrentHashMap-和-HashTable的区别"><a href="#ConcurrentHashMap-和-HashTable的区别" class="headerlink" title="ConcurrentHashMap 和 HashTable的区别"></a>ConcurrentHashMap 和 HashTable的区别</h4><h6 id="是否支持传入NULL"><a href="#是否支持传入NULL" class="headerlink" title="是否支持传入NULL"></a>是否支持传入NULL</h6><p>HashMap可以支持为null<br>若尝试将 <code>null</code> 作为键或值放入 <code>ConcurrentHashMap</code> 将会抛出 <code>NullPointerException</code><br>ConcurrentHashMap 不能支持存null</p>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><p>ConcurrentHashMap 1.8之前是分段锁来实现 默认是16个HashTable<br>1.8之后无限接近单个的HashMap  底层用CAS+synchronized<br>HashTable通过加<code>synchronized</code>锁来控制线程安全 </p>
<p>ConcurrentHashMap 读不要加锁 [读写的读也不会加锁] 会走最终一致性<br>HashTable 读要加锁 [读读都加锁]</p>
<h4 id="为什么要用Redis"><a href="#为什么要用Redis" class="headerlink" title="为什么要用Redis"></a>为什么要用Redis</h4><p><strong>高性能</strong>：Redis是<strong>基于内存</strong>的数据结构存储，可以提供高速的数据读写操作。<br><strong>数据结构丰富</strong>：Redis支持多种数据结构，如字符串、列表、集合、散列表、有序集合等，非常适合各种场景。<br><strong>持久化</strong>：Redis支持<strong>数据持久化</strong>，可以将内存中的数据<strong>保存到磁盘</strong>中，防止数据丢失。<br><strong>分布式</strong>：Redis支持<strong>主从复制</strong>、<strong>哨兵</strong>和<strong>集群模式</strong>，可以轻松实现分布式缓存。</p>
<h4 id="Redis中缓存了哪些数据"><a href="#Redis中缓存了哪些数据" class="headerlink" title="Redis中缓存了哪些数据"></a>Redis中缓存了哪些数据</h4><h6 id="可以存储一下类型的数据"><a href="#可以存储一下类型的数据" class="headerlink" title="可以存储一下类型的数据"></a>可以存储一下类型的数据</h6><blockquote>
<ol>
<li><strong>会话缓存（Session Store）</strong>：用户会话信息，如用户登录状态、用户偏好设置等。</li>
<li><strong>页面缓存</strong>：动态生成的网页内容，以减少数据库的读取次数。</li>
<li><strong>对象缓存</strong>：例如，用户信息、商品详情等，减少数据库访问。</li>
<li><strong>消息队列</strong>：用作消息队列，处理异步任务。</li>
<li><strong>排行榜或计数器</strong>：如用户点赞数、视频播放次数等。</li>
<li><strong>地理空间数据</strong>：用于实现基于地理位置的查询。</li>
<li><strong>分布式锁</strong>：在分布式系统中协调不同服务或节点的操作</li>
</ol>
</blockquote>
<h6 id="关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明："><a href="#关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明：" class="headerlink" title="关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明："></a>关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明：</h6><p>若放登录的信息到Redis的时候 不再用JWT了<br>Session在集群里面不能用了<br>替代方案：<span style = "color:red"><strong>用Redis 不用JWT</strong></span><br>JWT是无状态 无需集中存储</p>
<p>在我们的项目中，Redis中缓存了以下类型的数据：<br>会话信息：如用户登录信息、购物车内容等。<br><strong>热点数据</strong>：如热门商品信息、推荐内容等。<br><strong>计数器</strong>：如用户访问次数、点赞数、评论数等。<br>缓存数据库查询结果：减少数据库访问次数，提高系统响应速度。</p>
<blockquote>
<h3 id="JWT（JSON-Web-Tokens）"><a href="#JWT（JSON-Web-Tokens）" class="headerlink" title="JWT（JSON Web Tokens）"></a>JWT（JSON Web Tokens）</h3><p>JWT是一种在各方之间传递安全可靠信息的简洁的、URL安全的表达方式。其特点包括：</p>
<ul>
<li><strong>无状态</strong>：服务器不存储任何会话信息，每个请求都携带包含所有必要信息的JWT。</li>
<li><strong>自包含</strong>：JWT中包含了用户的所有声明，减少了服务器的数据库查询。</li>
<li><strong>跨域认证</strong>：特别适用于单点登录（SSO）。</li>
</ul>
<h3 id="JWT的局限性"><a href="#JWT的局限性" class="headerlink" title="JWT的局限性"></a>JWT的局限性</h3><ul>
<li><strong>无法失效</strong>：一旦签发了JWT，在它过期之前，它在任何地方都是有效的，无法提前失效。</li>
<li><strong>续签问题</strong>：JWT过期后需要重新签发，处理起来相对复杂。</li>
<li><strong>携带信息量大</strong>：每个请求都携带JWT，如果JWT中包含的信息较多，会增加请求的大小。</li>
</ul>
<h3 id="使用Redis替代JWT"><a href="#使用Redis替代JWT" class="headerlink" title="使用Redis替代JWT"></a>使用Redis替代JWT</h3><p>使用Redis作为会话存储，可以解决JWT的一些问题：</p>
<ol>
<li><strong>中心化控制</strong>：通过Redis，服务器可以集中管理会话信息，可以随时使会话失效。</li>
<li><strong>灵活的过期策略</strong>：可以设置更细粒度的过期时间，并在需要时刷新会话。</li>
<li><strong>状态管理</strong>：对于需要频繁更改用户状态的应用，使用Redis可以更方便地管理。</li>
<li><strong>安全性</strong>：虽然Redis存储会话信息，但可以结合HTTPS和合适的加密策略来保证传输过程的安全</li>
</ol>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ol>
<li><strong>用户登录</strong>：用户登录成功后，生成一个唯一的会话标识（如UUID），并将其作为key存储在Redis中，value可以是用户ID或者其他必要信息，并设置适当的过期时间。</li>
<li><strong>请求验证</strong>：用户每次请求时，需要在请求头中携带会话标识，服务器端通过这个标识在Redis中查找会话信息，进行验证。</li>
<li><strong>会话过期或失效</strong>：当用户登出或会话过期时，从Redis中删除对应的会话信息。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>数据持久性</strong>：Redis的数据是存储在内存中的，需要考虑持久化策略以防止数据丢失。</li>
<li><strong>高可用性</strong>：在集群环境下，需要配置Redis的高可用方案，如哨兵（Sentinel）或集群模式。</li>
<li><strong>安全性</strong>：确保Redis的安全性，防止未授权访问。</li>
</ul>
</blockquote>
<h4 id="检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考"><a href="#检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考" class="headerlink" title="检测数据存在Redis中，有过期时间吗? 过期时间是多少?仅参考"></a>检测数据存在Redis中，有过期时间吗? 过期时间是多少?<del>仅参考</del></h4><p>是的，我们在Redis中缓存的数据通常会设置过期时间，以避免过时的数据占用内存。具体的过期时间取决于数据的类型和业务需求。对于会话信息，我们可能会设置较短的过期时间，如30分钟或1小时；而对于热点数据，可能会设置较长的过期时间，如几小时或一天。具体的过期时间需要根据实际业务场景和数据访问模式来决定。</p>
<pre><code class="java">   // 用户登录，创建会话
    public String loginUser(String userId) &#123;
        String sessionId = UUID.randomUUID().toString();
        String sessionData = createSessionData(userId);
        jedis.setex(sessionId, 1800, sessionData); // 设置会话过期时间为30分钟
        return sessionId;
    &#125;
</code></pre>
<h4 id="微服务之间如何调用？"><a href="#微服务之间如何调用？" class="headerlink" title="微服务之间如何调用？"></a>微服务之间如何调用？</h4><p>通过注册中心去协调的<br>首先是有三个重要的概念，<strong>服务消费者</strong>，<strong>注册中心</strong>，<strong>服务提供者</strong>提供者在第一次会把自己的信息注册到注册中心中，比如ip端口，服务功能等消费者需要到注册中心来寻找服务进行消费，<strong>在服务消费者第一次请求的时候会拉取服务提供者的信息，注册中心会把提供者的实例列表给到消费者供消费者选择，使用负载均衡来选择服务</strong>，默认为轮询，还有加权轮询，随机。<strong>同时服务消费者还会定时去注册中心拉取服务提供者的信息</strong></p>
<h6 id="如果我们的服务挂掉了怎么办"><a href="#如果我们的服务挂掉了怎么办" class="headerlink" title="如果我们的服务挂掉了怎么办?"></a>如果我们的服务挂掉了怎么办?</h6><p>服务提供者会每隔一段时间去向注册中心报告自己的状态[发送心跳ping 30s&#x2F;次 共90s]，如果没有向注册中心报告状态，那么这个时候注册中心会认为服务提供者已经宕机，同时会推送到我们的服务消费者，这个服务提供者已经宕机</p>
<h4 id="微服务的五大组件"><a href="#微服务的五大组件" class="headerlink" title="微服务的五大组件"></a>微服务的五大组件</h4><ol>
<li><strong>服务注册与发现</strong>：如Eureka<del>已过时</del>、<strong>Nacos</strong>、Consul，用于服务的注册和发现。</li>
<li><strong>配置管理</strong>：如Spring Cloud Config、<strong>OpenFeign</strong> 用于集中管理服务的配置。</li>
</ol>
<p><code>Feign是一个声明式的Web服务客户端（Web服务客户端就是Http客户端），让编写Web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可。</code></p>
<p>&#96;&#96;OpenFeign是Spring Cloud 在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。&#96;</p>
<pre><code class="java">@FeignClient(name = &quot;feignTestService&quot;, url = &quot;http://localhost/8001&quot;)
public interface FeignTestService &#123;
&#125;

@Component
@FeignClient(url = &quot;http://localhost/8001&quot;)
public interface PaymentFeignService&#123;
&#125;
</code></pre>
<blockquote>
<pre><code class="java">二、OpenFeign使用
2.1.OpenFeign 常规远程调用
所谓常规远程调用，指的是对接第三方接口，和第三方并不是微服务模块关系，所以肯定不可能通过注册中心来调用服务。

第一步：导入OpenFeign的依赖

第二步：启动类需要添加@EnableFeignClients
    
第三步：提供者的接口
@RestController
@RequestMapping(&quot;/test&quot;)
public class FeignTestController &#123;

    @GetMapping(&quot;/selectPaymentList&quot;)
    public CommonResult&lt;Payment&gt; selectPaymentList(@RequestParam int pageIndex, @RequestParam int pageSize) &#123;
        System.out.println(pageIndex);
        System.out.println(pageSize);
        Payment payment = new Payment();
        payment.setSerial(&quot;222222222&quot;);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + payment);
    &#125;

    @GetMapping(value = &quot;/selectPaymentListByQuery&quot;)
    public CommonResult&lt;Payment&gt; selectPaymentListByQuery(Payment payment) &#123;
        System.out.println(payment);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + null);
    &#125;

    @PostMapping(value = &quot;/create&quot;, consumes = &quot;application/json&quot;)
    public CommonResult&lt;Payment&gt; create(@RequestBody Payment payment) &#123;
        System.out.println(payment);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + null);
    &#125;

    @GetMapping(&quot;/getPaymentById/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) String id) &#123;
        System.out.println(id);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + null);
    &#125;
    
第四步：消费者调用提供者接口
@FeignClient(name = &quot;feignTestService&quot;, url = &quot;http://localhost/8001&quot;)
public interface FeignTestService &#123;

    @GetMapping(value = &quot;/payment/selectPaymentList&quot;)
    CommonResult&lt;Payment&gt; selectPaymentList(@RequestParam int pageIndex, @RequestParam int pageSize);

    @GetMapping(value = &quot;/payment/selectPaymentListByQuery&quot;)
    CommonResult&lt;Payment&gt; selectPaymentListByQuery(@SpringQueryMap Payment payment);

    @PostMapping(value = &quot;/payment/create&quot;, consumes = &quot;application/json&quot;)
    CommonResult&lt;Payment&gt; create(@RequestBody Payment payment);

    @GetMapping(&quot;/payment/getPaymentById/&#123;id&#125;&quot;)
    CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) String id);
&#125;
</code></pre>
</blockquote>
<ol>
<li><strong>服务网关</strong>：如Zuul、Spring Cloud <strong>Gateway</strong>，作为系统的唯一入口，处理外部请求的路由和过滤。</li>
<li><strong>负载均衡</strong>：如<strong>Ribbon</strong>，用于在多个服务实例之间分配请求。</li>
<li><strong>断路器</strong>：如<strong>Hystrix</strong>，用于服务熔断，防止系统雪崩</li>
</ol>
<h4 id="对于服务注册这块有什么了解？"><a href="#对于服务注册这块有什么了解？" class="headerlink" title="对于服务注册这块有什么了解？"></a>对于服务注册这块有什么了解？</h4><ul>
<li><strong>服务注册中心</strong>：服务实例在启动时向服务注册中心注册自己的地址和端口信息。检查 心跳 如果未查询就剔除，同时也有注册中心主动发起请求。</li>
<li><strong>健康检查</strong>：服务注册中心通常会定期对已注册的服务进行健康检查，以确保服务的可用性。</li>
<li><strong>服务发现</strong>：服务消费者通过服务注册中心查找可用的服务实例，以进行服务调用。</li>
<li><strong>服务去注册</strong>：当服务实例关闭或出现故障时，它需要从服务注册中心注销，以避免调用不可用的服务。</li>
</ul>
<h4 id="你能说一下小程序的登录流程吗"><a href="#你能说一下小程序的登录流程吗" class="headerlink" title="你能说一下小程序的登录流程吗?"></a>你能说一下小程序的登录流程吗?</h4><p>调用微信api，根据code获取openid；根据openid查询用户为空就新增；调用微信api <code>WechatService + WechatServiceImpl</code>(openId+phoneCode) 获取用户绑定的手机号；保存或修改该用户；将用户id存入token返回(JWT生成token)</p>
<h4 id="有哪些方式可以创建单例？"><a href="#有哪些方式可以创建单例？" class="headerlink" title="有哪些方式可以创建单例？"></a>有哪些方式可以创建单例？</h4><ol>
<li><strong>饿汉式</strong>：在<strong>类加载</strong>时就立即初始化并创建单例对象。</li>
<li><strong>懒汉式</strong>：在<strong>第一次调用时</strong>初始化单例对象，通常需要考虑线程安全问题。</li>
<li><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</li>
<li><strong>静态内部类</strong>：利用静态内部类的加载机制来确保单例对象的唯一性。</li>
<li><strong>枚举</strong>：利用枚举的特性，保证单例对象的唯一性和线程安全【不可用反射】</li>
</ol>
<h6 id="并发情况下严格控制单例？volatile→禁止进行指令重排序"><a href="#并发情况下严格控制单例？volatile→禁止进行指令重排序" class="headerlink" title="并发情况下严格控制单例？volatile→禁止进行指令重排序"></a>并发情况下严格控制单例？<del>volatile→禁止进行指令重排序</del></h6><p><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</p>
<blockquote>
<h6 id="思考一个问题：哪些方式创建单例模式？-1"><a href="#思考一个问题：哪些方式创建单例模式？-1" class="headerlink" title="思考一个问题：哪些方式创建单例模式？"></a>思考一个问题：哪些方式创建单例模式？</h6><blockquote>
<h3 id="1-懒汉式，线程不安全-1"><a href="#1-懒汉式，线程不安全-1" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h3><p>这种方式在类加载时不初始化。在需要的时候才创建对象，节约资源。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="2-懒汉式，线程安全-1"><a href="#2-懒汉式，线程安全-1" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h3><p>通过同步方法确保线程安全。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="3-饿汉式-1"><a href="#3-饿汉式-1" class="headerlink" title="3. 饿汉式"></a>3. 饿汉式</h3><p>类加载时就完成了初始化，保证了线程的安全性。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance = new Singleton();
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="4-双重校验锁-1"><a href="#4-双重校验锁-1" class="headerlink" title="4. 双重校验锁"></a>4. 双重校验锁</h3><p>线程安全且在实例域需要延迟加载时提高性能。</p>
<pre><code class="java">public class Singleton &#123;
    private volatile static Singleton singleton;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (singleton == null) &#123;
            synchronized (Singleton.class) &#123;
                if (singleton == null) &#123;
                    singleton = new Singleton();
                &#125;
            &#125;
        &#125;
        return singleton;
    &#125;
&#125;
</code></pre>
<h3 id="5-静态内部类-1"><a href="#5-静态内部类-1" class="headerlink" title="5. 静态内部类"></a>5. 静态内部类</h3><p>这种方式既实现了懒加载，又保证了线性安全。</p>
<pre><code class="java">public class Singleton &#123;
    private static class SingletonHolder &#123;
        private static final Singleton INSTANCE = new Singleton();
    &#125;
    private Singleton() &#123;&#125;

    public static final Singleton getInstance() &#123;
        return SingletonHolder.INSTANCE;
    &#125;
&#125;
</code></pre>
<h3 id="6-枚举-1"><a href="#6-枚举-1" class="headerlink" title="6. 枚举"></a>6. 枚举</h3><p>实现单例的最佳方法，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p>
<pre><code class="java">public enum Singleton &#123;
    INSTANCE;
    public void whateverMethod() &#123;
    &#125;
&#125;
</code></pre>
</blockquote>
</blockquote>
<h4 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h4><ul>
<li><p><strong>公平锁</strong>：多个线程按照它们请求<strong>锁的顺序</strong>来获取锁，<strong>先来先得</strong>。这种方式不会产生饥饿现象，但可能会<strong>降低吞吐量</strong>，因为需要额外的开销来维护等待队列的顺序。【僵尸线程】<u>对资源顺序有严格要求</u></p>
<blockquote>
<h6 id="为什么会降低吞吐量？"><a href="#为什么会降低吞吐量？" class="headerlink" title="为什么会降低吞吐量？"></a>为什么会降低吞吐量？</h6><ol>
<li><strong>维护等待队列</strong>：公平锁为了保证按照请求锁的顺序来获取锁，必须维护一个有序的等待队列。这意味着每次有线程请求锁或者释放锁时，都需要进行额外的操作来管理这个队列，这会增加开销。</li>
<li><strong>上下文切换开销</strong>：当锁被释放时，公平锁需要唤醒等待队列中的第一个线程。这个过程涉及到线程的上下文切换，上下文切换是有成本的，因为它涉及到保存和恢复线程的状态。</li>
<li><strong>减少并发机会</strong>：由于公平锁要求先来先得，即使锁被释放，后请求锁的线程即使处于可运行状态，也必须等待前面的线程先执行。这可能会减少并发执行的机会，从而降低吞吐量。</li>
<li><strong>增加延迟</strong>：公平锁可能会增加线程获取锁的平均等待时间，因为每个线程都必须等待前一个线程完成。这种延迟可能会导致系统整体性能下降。</li>
</ol>
</blockquote>
</li>
<li><p><strong>非公平锁</strong>：线程获取锁的顺序不一定是按照请求锁的顺序，允许线程“插队”。这种方式可能会提高吞吐量，但可能导致某些线程长时间无法获取锁，产生饥饿现象。【为什么性能高？不用沉睡和阻塞 避免来回切换】<u>对性能要求高</u></p>
</li>
</ul>
<h6 id="ReentrantLock-看传参-公平-x2F-非公平都支持"><a href="#ReentrantLock-看传参-公平-x2F-非公平都支持" class="headerlink" title="ReentrantLock 看传参 公平&#x2F;非公平都支持"></a>ReentrantLock 看传参 <u>公平&#x2F;非公平</u>都支持</h6><pre><code class="java">ReentrantLock 是Java提供的显式锁，它允许你通过构造函数参数来选择是使用公平锁还是非公平锁：

公平锁（Fair Lock）：通过传递true给ReentrantLock的构造函数来创建。这确保了锁的获取是按照线程请求锁的顺序进行的，防止饥饿现象。
ReentrantLock fairLock = new ReentrantLock(true);

非公平锁（Non-Fair Lock）：通过传递false或者不传递参数（默认值）给ReentrantLock的构造函数来创建。这种方式允许线程“插队”，可能会提高吞吐量，但也可能导致某些线程长时间无法获取锁。
ReentrantLock nonFairLock = new ReentrantLock(false); // 或者
ReentrantLock nonFairLock = new ReentrantLock(); // 默认是非公平锁
</code></pre>
<h6 id="Synchronized-公平锁"><a href="#Synchronized-公平锁" class="headerlink" title="Synchronized 公平锁"></a>Synchronized 公平锁</h6><pre><code class="java">从Java 6开始，synchronized的实现得到了改进，它试图实现一种偏向锁和轻量级锁的策略，以提高性能。
以下是关于synchronized的一些关键点：

偏向性：synchronized在锁竞争不激烈的情况下，会尝试偏向第一个获取锁的线程，这有助于减少不必要的同步开销。
轻量级锁：当没有竞争时，synchronized会使用轻量级锁，这比使用操作系统提供的重量级锁要快得多。
重量级锁：当存在竞争时，synchronized会升级为重量级锁，这涉及到操作系统的线程调度。

synchronized不会严格地保证公平性，因为它允许锁的“重入”和偏向性，这意味着它更倾向于非公平锁的行为。然而，在锁竞争激烈的情况下，synchronized会尽量保持一定的公平性，因为它会按照线程在监视器队列中的顺序来获取锁。

总的来说，synchronized不是严格意义上的公平锁，但它的实现细节和调度策略可能会在一定程度上表现出公平锁的特性。与ReentrantLock相比，synchronized的锁获取机制更为复杂，并且它是由JVM内部实现的，因此具体的调度细节对开发者来说是透明的。
</code></pre>
<h4 id="SpringMVC的工作原理"><a href="#SpringMVC的工作原理" class="headerlink" title="SpringMVC的工作原理"></a>SpringMVC的工作原理</h4><ul>
<li><p>前端的HTTP请求到达时首先被<strong>DispatcherServlet</strong>接收</p>
</li>
<li><p>DispatcherServlet根据请求信息<del>路径</del>查找合适的<strong>HandlerMapping</strong>来确定哪个<strong>Controller</strong>应该处理该请求。</p>
</li>
<li><p>找到合适的Controller后，DispatcherServlet将请求转发给它处理。</p>
</li>
<li><p>Controller处理完请求后返回一个<strong>ModelAndView</strong>对象给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet再通过<strong>ViewResolver</strong>解析ModelAndView中的视图逻辑名，找到对应的视图。</p>
</li>
<li><p>最后，DispatcherServlet将模型数据渲染到视图上并响应给客户端。</p>
</li>
</ul>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250206094925513.png" alt="image-20250206094925513"></p>
<h4 id="OpenFeign的底层原理"><a href="#OpenFeign的底层原理" class="headerlink" title="OpenFeign的底层原理"></a>OpenFeign的底层原理</h4><p>OpenFeign 实现了简洁、声明式的 HTTP 请求调用，并且与 Spring Cloud 集成后能提供更多的功能如负载均衡等</p>
<p><strong>动态代理</strong>： OpenFeign 使用 Java 动态代理技术，基于接口创建代理类，代理类会自动发起 HTTP 请求。你定义的接口方法会映射到 HTTP 请求上，OpenFeign 会根据注解（如 <code>@RequestMapping</code>, <code>@GetMapping</code> 等）来构建请求。</p>
<p><strong>注解解析</strong>： OpenFeign 会解析接口方法上的注解，构造 HTTP 请求的 URL、请求方法类型（GET、POST 等），以及请求体和请求头等信息。</p>
<p><strong>请求拦截和处理</strong>： 在请求发起之前，OpenFeign 允许通过拦截器（<code>RequestInterceptor</code>）来修改请求，比如设置请求头、参数等。</p>
<p><strong>负载均衡与容错</strong>： 如果与 Spring Cloud 一起使用，OpenFeign 会集成 Ribbon（负载均衡）和 Hystrix（容错），使得服务调用更加健壮和可靠。</p>
<p><strong>序列化与反序列化</strong>： OpenFeign 会利用 Jackson 等库进行请求和响应的序列化和反序列化，将 Java 对象与 HTTP 请求&#x2F;响应内容相互转换</p>
<p>在使用OpenFeign时，开发者只需要定义接口并添加相应的注解，OpenFeign会在运行时动态生成实现类来执行HTTP请求。</p>
<h4 id="对Volatile的理解"><a href="#对Volatile的理解" class="headerlink" title="对Volatile的理解"></a>对Volatile的理解</h4><p><code>volatile</code> 是Java语言中的一个关键字，用于修饰变量，以确保该变量的读写操作对所有线程立即可见，并且防止指令重排序优化。</p>
<p>确保了不同线程对这个变量进行读写操作时的可见性。<br>是java的关键字是修饰共享的变量，不能修饰局部变量。<br>修饰普通或静态成员变量，主要用来保证<strong>可见性</strong>和<strong>有序性</strong>。</p>
<blockquote>
<h3 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h3><p>在一个多线程程序中，为了提高性能，每个线程可能会将共享变量缓存到自己的CPU缓存中。如果一个线程修改了这个变量的值，而这个新值没有及时写回主内存，那么其他线程可能会读取到旧值。使用<code>volatile</code>关键字可以确保：</p>
<ul>
<li>每次读写变量都是直接操作主内存。</li>
<li>当一个线程修改了一个<code>volatile</code>变量时，新值会立即被写入主内存。</li>
<li>其他线程读取<code>volatile</code>变量时，会从主内存中读取最新值。</li>
</ul>
<p>这样，<code>volatile</code>就保证了不同线程之间共享变量的可见性。</p>
<h3 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h3><p>在没有<code>volatile</code>修饰的变量上，Java编译器和处理器可能会进行指令重排序，以提高程序运行的效率。指令重排序可能会导致程序的执行顺序与代码的编写顺序不一致。使用<code>volatile</code>可以防止以下两种类型的重排序：</p>
<ul>
<li><strong>写操作的重排序</strong>：<code>volatile</code>变量的写操作不允许与它之前的操作重排序。</li>
<li><strong>读操作的重排序</strong>：<code>volatile</code>变量的读操作不允许与它之后的操作重排序。</li>
</ul>
<p>这样，<code>volatile</code>就提供了一定的有序性保证。</p>
</blockquote>
<h4 id="Spring-Security的实现"><a href="#Spring-Security的实现" class="headerlink" title="Spring Security的实现"></a>Spring Security的实现</h4><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息</p>
<h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><p>是多线程中的<del>抽象</del>队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，是一个抽象类。<br>像ReentrantLock都是基于AQS实现的</p>
<blockquote>
<p>在Java的并发编程中，<code>AbstractQueuedSynchronizer</code>（简称AQS）是一个非常重要的类，它提供了一个框架，用于实现依赖于先进先出（FIFO）等待队列的阻塞锁和其他同步器（例如信号量、事件等）。AQS 本身是一个抽象类，<strong>它内部定义了<u>获取资源（锁）</u>和<u>释放资源（锁）</u>的基本方法</strong>，以及<strong>管理同步状态</strong>和<strong>队列</strong>的机制。</p>
<p>当说“ReentrantLock是基于AQS实现的”，意味着<code>ReentrantLock</code>这个具体锁的实现类，是<strong>继承并利用了AQS提供的模板方法</strong>来构建其功能的。具体来说：</p>
<ul>
<li><strong>继承</strong>：<code>ReentrantLock</code>内部有一个内部类叫做<code>Sync</code>，这个<code>Sync</code>类直接继承自<code>AbstractQueuedSynchronizer</code>。</li>
<li><strong>实现</strong>：<code>Sync</code>类（及其子类）会根据需要重写AQS的一些方法，如<code>tryAcquire</code>和<code>tryRelease</code>，这些方法用于定义获取锁和释放锁的具体行为。</li>
<li><strong>利用模板方法</strong>：AQS提供了一系列的模板方法（如<code>acquire</code>、<code>release</code>等），这些方法内部会调用前面提到的可重写方法（如<code>tryAcquire</code>、<code>tryRelease</code>），从而允许<code>ReentrantLock</code>按照特定的逻辑来管理锁的状态。</li>
</ul>
<p>因此，<u>“基于AQS实现”的表述强调了<code>ReentrantLock</code>并不是从头开始构建锁的所有细节，而是站在AQS这个强大的基础框架之上</u>，通过实现特定的策略来完成锁的具体功能。这样做的好处是减少了代码量，提高了代码的可维护性和可重用性，并且由于AQS经过了严格的测试，基于它实现的锁也更加可靠。</p>
</blockquote>
<p>定义了一个并发情况下一些抽象的资源 资源能否<strong>共享&#x2F;独享</strong> 定义了<strong>公平&#x2F;非公平</strong><br>如果是非公平锁如果来了个新的线程来抢线程 也是会去抢一次<br>AQS成为了JUC很多类都去继承的 它<strong>抽象了很多并发的属性和行为</strong>，让子类去继承它扩展自己</p>
<h4 id="Synchronized的锁升级"><a href="#Synchronized的锁升级" class="headerlink" title="Synchronized的锁升级"></a>Synchronized的锁升级</h4><ul>
<li>Monitor实现的锁属于<strong>重量级锁</strong>，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<p><u>一段很长的时间内都只被一个线程使用锁</u> <strong>偏向锁</strong><br><u>有线程交替或线程加锁的时间是错开的</u> <strong>轻量级锁</strong><br><u>有很多线程来抢</u> <strong>重量级锁</strong></p>
<blockquote>
<h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><p>偏向锁是一种优化锁的机制，它的设计初衷是：如果一个锁在大多数时间里只被一个线程访问，那么就没有必要进行线程间的同步操作，因为不存在锁竞争。在这种情况下，JVM会为这个锁赋予一个“偏向”，即偏向于第一个获取它的线程。在后续的锁操作中，如果该线程再次请求这个锁，就不需要进行同步操作，从而提高性能。偏向锁适用于只有一个线程访问同步块的场景。</p>
<h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><p>轻量级锁是另一种锁的优化，它适用于锁竞争不是很激烈，且锁持有的时间短的场景。当线程交替访问同步块时，使用轻量级锁可以减少传统的重量级锁带来的性能开销。轻量级锁是通过在对象头中的一些标记位来实现的，当锁处于轻量级锁状态时，线程通过CAS操作来尝试获取锁，如果成功，则直接进入同步块执行，从而避免了使用操作系统级别的重量级锁机制。</p>
<h6 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h6><p>重量级锁是JVM中最传统的锁实现，也是性能开销最大的锁。当有很多线程同时竞争同一个锁时，JVM会使用重量级锁来确保线程安全。重量级锁依赖于操作系统的互斥量（mutex），会导致线程状态在用户态和核心态之间转换，这种转换是非常耗时的。因此，当锁竞争非常激烈时，使用重量级锁可以保证公平性和线程安全，但会带来较大的性能开销。</p>
<blockquote>
<p>在处理多线程同时竞争同一个锁的情况时，并不一定总是需要使用重量级锁。以下是一些优化和策略，可以帮助您更好地处理并发场景：</p>
<ol>
<li><strong>最小化同步范围</strong>：<ul>
<li>仅对必要的代码块进行同步，减少锁的竞争。</li>
<li>使用细粒度锁，比如对不同的数据结构使用不同的锁，而不是对整个对象加锁。</li>
</ul>
</li>
<li><strong>使用并发工具类</strong>：<ul>
<li>Java提供了许多并发工具类，如<code>java.util.concurrent</code>包中的<code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ConcurrentHashMap</code>等，它们提供了比synchronized更丰富的功能。</li>
</ul>
</li>
<li><strong>锁分离</strong>：<ul>
<li>对于读多写少的场景，可以使用读写锁（<code>ReadWriteLock</code>），它允许多个读线程同时访问，而写线程则互斥。</li>
</ul>
</li>
<li><strong>锁优化</strong>：<ul>
<li>在锁竞争不是很激烈的情况下，可以使用轻量级锁或偏向锁，这些锁的开销比重量级锁小。</li>
</ul>
</li>
<li><strong>无锁编程</strong>：<ul>
<li>使用原子类（如<code>AtomicInteger</code>、<code>AtomicReference</code>）和线程安全的数据结构，这些类通过CAS操作实现了无锁的线程安全。</li>
</ul>
</li>
<li><strong>线程池</strong>：<ul>
<li>使用线程池来管理线程，避免频繁创建和销毁线程带来的开销。</li>
</ul>
</li>
<li><strong>避免死锁</strong>：<ul>
<li>设计代码时注意锁的顺序，避免循环等待条件，减少死锁的发生。</li>
</ul>
</li>
<li><strong>性能测试</strong>：<ul>
<li>对并发代码进行性能测试，了解不同锁策略对性能的影响，并根据测试结果选择合适的锁。</li>
</ul>
</li>
</ol>
</blockquote>
</blockquote>
<p>java语言是高级语言如果想调用底层的操作系统和硬件要通过操作系统的API去操作。以前老的JDK版本 数据是在操作系统找的数据<del>锁</del>，Monitor的标志0 和 1，底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 。<br>引入新型锁后，java里是<strong>用对象头找个地方存一把锁</strong>，这样就不涉及到调用操作系统底层。一开始new了个对象 此时是无锁状态。接下来来人拿锁，长期一个人拿到那个锁 此时是<strong>偏向锁</strong><del>竞争不激烈</del>。后面多线程一起来 <u>交替抢锁</u> 此时是<strong>轻量级锁</strong>。随着并发越来越高 此时在一个线程拿到锁后很多线程来抢锁 线程先尝试自己先获取几次(<strong>自旋锁</strong>64次未拿到锁就会升级为重量级锁) 这时就涉及到操作系统的底层对象涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低。锁不可逆<del>可能新版本可以降级</del></p>
<h4 id="Dockerfile-常用命令"><a href="#Dockerfile-常用命令" class="headerlink" title="Dockerfile 常用命令"></a>Dockerfile 常用命令</h4><ul>
<li><code>FROM</code>: 指定基础镜像。</li>
<li><code>ENV</code>: 设置环境变量。</li>
<li><code>RUN</code>: 执行命令并创建新的镜像层。</li>
<li><code>COPY</code>: 将文件从宿主机复制到容器中。</li>
<li><code>EXPOSE</code>: 声明容器运行时将监听的端口。</li>
<li><code>ENTRYPOINT</code>: 配置容器启动时运行的命令。</li>
</ul>
<h4 id="常用的-Docker-命令"><a href="#常用的-Docker-命令" class="headerlink" title="常用的 Docker 命令"></a>常用的 Docker 命令</h4><ul>
<li><code>docker run</code>: 创建一个新的容器并运行一个命令。</li>
<li><code>docker pull</code>: 从仓库中拉取或者更新一个镜像。</li>
<li><code>docker push</code>：推送镜像到服务</li>
<li><code>docker build</code>: 从 Dockerfile 构建一个镜像。</li>
<li><code>docker images</code>: 列出本地镜像。</li>
<li><code>docker ps</code>: 列出运行中的容器。</li>
<li><code>docker stop</code>: 停止一个运行中的容器。</li>
<li><code>docker start</code>: 启动一个停止的容器。</li>
<li><code>docker rm</code>: 删除一个容器。</li>
<li><code>docker rmi</code>: 删除一个镜像。</li>
<li><code>docker exec</code>: 在运行中的容器内执行命令。</li>
<li><code>docker logs</code>: 获取容器的日志。</li>
</ul>
<pre><code class="java">- docker volume create：创建数据卷
- docker volume ls：查看所有数据卷
- docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置
- docker volume rm：删除指定数据卷
</code></pre>
<p>Docker Compose 常用命令</p>
<ul>
<li><code>docker-compose up</code>: 启动所有服务的容器。</li>
<li><code>docker-compose down</code>: 停止并删除容器、网络、卷和镜像。</li>
<li><code>docker-compose ps</code>: 列出项目中所有的容器。</li>
<li><code>docker-compose exec</code>: 进入指定的容器。</li>
<li><code>docker-compose build</code>: 构建或重建服务。</li>
<li><code>docker-compose logs</code>: 查看服务的日志输出。</li>
<li><code>docker-compose stop</code>: 停止运行的容器。</li>
</ul>
<h4 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h4><ul>
<li><code>synchronized</code> 是Java的一个关键字<del>用于方法和代码块中</del>，而 <code>ReentrantLock</code> 是JUC包的一个类。</li>
<li><code>synchronized</code> 可以<strong>自动</strong>加锁和解锁，而 <code>ReentrantLock</code> 需要<strong>手动</strong>加锁和解锁。</li>
<li><code>synchronized</code> 的锁是非公平的，而 <code>ReentrantLock</code> 默认也是非公平的，但可以设置为公平锁。</li>
</ul>
<h4 id="你们公司是怎么部署项目的"><a href="#你们公司是怎么部署项目的" class="headerlink" title="你们公司是怎么部署项目的"></a>你们公司是怎么部署项目的</h4><p>是通过docker + jenkins<br>测试环境我们参与 生产环境组长部署</p>
<h4 id="varchar-与-char-区别"><a href="#varchar-与-char-区别" class="headerlink" title="varchar 与 char 区别"></a>varchar 与 char 区别</h4><ul>
<li><code>varchar</code> 是可变长度的字符串，而 <code>char</code> 是固定长度的字符串。</li>
<li><code>varchar</code> 的性能通常比 <code>char</code> 差，因为需要处理额外的长度信息。</li>
<li>当数据长度变化很大时，推荐使用 <code>varchar</code>；当数据长度几乎固定时，使用 <code>char</code> 可能更合适。</li>
</ul>
<h4 id="Redis的持久化有哪几种-它们的区别是什么"><a href="#Redis的持久化有哪几种-它们的区别是什么" class="headerlink" title="Redis的持久化有哪几种? 它们的区别是什么?"></a>Redis的持久化有哪几种? 它们的区别是什么?</h4><p>完整性 大小 数据恢复速度 建议</p>
<p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果</p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照哦</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h4 id="项目中是怎么使用redis的"><a href="#项目中是怎么使用redis的" class="headerlink" title="项目中是怎么使用redis的"></a>项目中是怎么使用redis的</h4><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题</p>
<p>用Hash类型  大Key是Id  小key是商品id value是商品数量<br>数据量点击量 用String类型<br>用Set类型 Zset做排行榜</p>
<h4 id="你的项目中哪里使用到分布式锁"><a href="#你的项目中哪里使用到分布式锁" class="headerlink" title="你的项目中哪里使用到分布式锁?"></a>你的项目中哪里使用到分布式锁?</h4><p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、EX是设置超时时间<br><strong>SET lock value NX EX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h4 id="你可以说一下redis的分布式锁的原理吗"><a href="#你可以说一下redis的分布式锁的原理吗" class="headerlink" title="你可以说一下redis的分布式锁的原理吗"></a>你可以说一下redis的分布式锁的原理吗</h4><h4 id="我在项目中是集成了redisson-底层基于Lua脚本-具有原子性"><a href="#我在项目中是集成了redisson-底层基于Lua脚本-具有原子性" class="headerlink" title="我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])"></a><del>我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])</del></h4><p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责<strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h4 id="redis和mysql怎么保证数据一致性"><a href="#redis和mysql怎么保证数据一致性" class="headerlink" title="redis和mysql怎么保证数据一致性"></a>redis和mysql怎么保证数据一致性</h4><p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行<br><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】<del>有过期时间兜底</del></p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知：</strong>&#x3D;&#x3D;<u>异步通知保证数据的最终一致性</u>(需要保证MQ的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先将数据写入Redis，然后通过异步通知机制触发数据库的更新操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog<br>可以解析binlog文件 可以存放mysql里面的数据 看最近有无增删改查 转换成redis命令 再给redis里面</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<h4 id="synchronized可以作用在哪些地方-作用域-，分别锁的是什么"><a href="#synchronized可以作用在哪些地方-作用域-，分别锁的是什么" class="headerlink" title="synchronized可以作用在哪些地方(作用域)，分别锁的是什么"></a>synchronized可以作用在哪些地方(作用域)，分别锁的是什么</h4><p>在Java中，<code>synchronized</code>关键字可以用来实现线程同步，它可以作用在不同的地方，并且锁定的对象也不同：</p>
<ol>
<li><p><strong>实例方法</strong>：</p>
<ul>
<li>作用在实例方法上时，锁的是调用该方法的<strong>对象实例</strong>（即**<u>this对象</u>**）。</li>
<li>任何线程想要执行这个方法，都必须获得该对象实例的锁。</li>
</ul>
<pre><code>public synchronized void synchronizedMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>静态方法</strong>：</p>
<ul>
<li>作用在静态方法上时，锁的是类的<strong>Class对象</strong>。</li>
<li>由于静态方法是属于类的，而不是属于任何特定实例，所以所有线程要想执行这个静态同步方法，都必须获得该类的Class对象的锁。</li>
</ul>
<pre><code>public static synchronized void synchronizedStaticMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>代码块</strong>：</p>
<ul>
<li>作用在代码块上时，可以指定一个<strong>锁对象<del>括号里的对象</del><strong>，可以是</strong>任何对象</strong>。</li>
<li>当进入这个代码块时，线程必须获得指定锁对象的锁。</li>
</ul>
<pre><code>public void synchronizedBlock() &#123;
    synchronized(this) &#123; // 锁定当前对象实例
        // 代码块
    &#125;
&#125;

public void synchronizedBlockWithObject() &#123;
    Object lock = new Object();
    synchronized(lock) &#123; // 锁定指定的对象
        // 代码块
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行<strong>运算操作</strong>，索引将失效</li>
<li>字符串不加单引号，造成索引失效。(类型转换)</li>
<li>以%开头的Like模糊查询，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span><del>索引很多就会有很多B+树</del></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong> [where、group by、order by]<br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><del>对存储节省空间</del></p>
<pre><code class="java">如果我们经常根据客户ID和订单日期来查询订单，那么可以在 customer_id 和 order_date 上创建一个联合索引。
CREATE INDEX idx_customer_date ON orders (customer_id, order_date);

这个联合索引 idx_customer_date 有以下几个特点：

索引顺序：首先根据 customer_id 排序，然后在每个 customer_id 的基础上根据 order_date 排序。
查询优化：以下查询可以利用这个联合索引：
SELECT * FROM orders WHERE customer_id = ? AND order_date = ?;
SELECT * FROM orders WHERE customer_id = ?;
</code></pre>
<p>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它<br>大字段不建议建立索引是因为B+树一个叶子节点&#x2F;一个非叶子节点 差不多16k 一个节点对应一个[页] 多的话会更多层<br>尽量不用性别去创建索引</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<h4 id="mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层"><a href="#mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层" class="headerlink" title="mysql底层为什么用B+树利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层"></a>mysql底层为什么用B+树<del>利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层</del></h4><p><del><strong>二叉树</strong> O(logn) 容易退化成链表 所以不用它</del><br><del><strong>平衡二叉树</strong> 全部倾斜</del><br><del><strong>红黑树</strong> 一个节点只能存一个数据</del><br>B树能不能除了叶子节点其他不存数据呢？</p>
<blockquote>
<p>你可以设计一种变体的B树，其中只有叶子节点存储数据，而所有其他非叶子节点仅作为导航节点，不存储实际的数据。这种结构在概念上类似于B树的一个特例，通常被称为B树索引结构的一部分，其中非叶子节点存储的是键值，而叶子节点存储的是实际的数据记录或者是指向数据记录的指针</p>
</blockquote>
<p>B+树第三层2000多万条数据，尽量不要把数据达到2000多万<br>B+树叶子节点加了双向链表 让我们查询更加稳定 范围查询会更快</p>
<h6 id="mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高"><a href="#mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高" class="headerlink" title="mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高"></a>mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高</h6><p><strong>R—Tree</strong>：地理位置搜索</p>
<h6 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h6><p><code>where b= AND c= AND a= </code> 这样走索引都能走 底层自己排序<br>为什么联合索引要遵循最左匹配原则【里面的b+树 先按照a排序 再b 因为要二分查找 不排序怎么找？】</p>
<p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span><del>查询前用explain查询是否走了索引等问题</del></p>
<h6 id="explain查询后的列："><a href="#explain查询后的列：" class="headerlink" title="explain查询后的列："></a>explain查询后的列：</h6><pre><code class="java">id：查询中SELECT语句的序列号，如果该行引用其他行的并集结果，则该值可以为空。
select_type：表示查询的类型，常见的类型有：
SIMPLE：简单的SELECT查询，不使用UNION或子查询。
PRIMARY：最外层的SELECT查询。
UNION：在UNION中的第二个或随后的SELECT查询。
DEPENDENT UNION：在UNION中的第二个或随后的SELECT查询，取决于外层查询。
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT。
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外层查询。
table：查询的是哪个表。
type：这是你提到的一个非常重要的列，它表示MySQL在表中找到所需行的方式，也称为“访问类型”。以下是一些常见的访问类型，从最好到最差排序：
system：表只有一行（系统表）。
const：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，所以优化器的其余部分可以将这一行视为常量。
eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这通常是最好的联接类型，除了const类型。
ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。
fulltext：使用全文索引执行查询。
ref_or_null：与ref类似，但是MySQL会额外搜索包含NULL值的行。
index_merge：表示查询使用了两个或更多的索引。
unique_subquery：用于IN子查询，子查询返回不重复的值集。
index_subquery：用于IN子查询，子查询返回不重复的值集，可以使用索引。
range：使用索引来检索给定范围的行。
index：全索引扫描（比ALL快，因为索引通常比数据行小）。
ALL：全表扫描，这是最差的一种类型，因为MySQL必须检查每一行以找到匹配的行。
possible_keys：指出MySQL能使用哪些索引来优化查询。
key：MySQL实际决定使用的索引。
key_len：使用的索引的长度。越短越好。
ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。
rows：MySQL认为必须检查的用来返回请求数据的行数。
filtered：显示了通过条件过滤出的行数的百分比估计。
Extra：包含MySQL解析查询的额外信息，例如是否使用了索引，是否排序了结果，是否使用了临时表等
</code></pre>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、SKywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li><strong>聚簇索引(聚集索引)<strong>：数据与索引放到一块，B+树的叶子节点保存了整行数据，</strong>有且只有一个</strong>【id存放的b+树】</li>
<li>**非聚簇索引(二级索引)**：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个【叶子就是id的字段】</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
<p>怎么避免回表 → 使用覆盖索引！<br>需要name 直接 select name 而不用 select *<br>要按需来查找</p>
</blockquote>
<pre><code class="java">除了InnoDB，MySQL数据库还支持多种其他存储引擎，其中最著名的是MyISAM。以下是InnoDB和MyISAM两个存储引擎的主要区别：

事务支持：
InnoDB：支持事务，它遵循ACID原则（原子性、一致性、隔离性和持久性）。如果事务中的某个操作失败，整个事务可以回滚到开始状态。
MyISAM：不支持事务，这意味着你无法回滚操作，这对于数据完整性和恢复可能是一个问题。
    
锁定机制：
InnoDB：使用行级锁定，只锁定需要的特定行，这可以大大减少数据库操作的冲突。
MyISAM：使用表级锁定，每次操作都会锁定整个表，这在并发操作较多时可能导致性能问题。
    
崩溃恢复：
InnoDB：具有自动崩溃恢复功能，即使数据库崩溃，也不会丢失数据，因为它将事务日志写入磁盘。
MyISAM：在崩溃后恢复较为困难，可能会丢失数据，因为它不记录事务日志。
    
全文搜索：
InnoDB（MySQL 5.6及以后版本）：支持全文索引，但功能上不如MyISAM的全文搜索强大。
MyISAM：提供了更强大的全文搜索功能，但在MySQL 5.6之前，这是MyISAM相对于InnoDB的主要优势。
    
存储限制：
InnoDB：表的大小理论上受限于操作系统的文件大小限制，通常可以处理更大的数据量。
MyISAM：表的大小受限于最大文件大小，通常是2GB到4GB，这取决于文件系统的限制。
    
外键支持：
InnoDB：支持外键约束，这有助于保持数据的引用完整性。
MyISAM：不支持外键约束。
    
存储空间：
InnoDB：通常需要更多的存储空间，因为它存储了额外的信息来支持事务和行级锁定。
MyISAM：通常占用更少的存储空间，因为它不需要存储这些额外的信息
</code></pre>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<h4 id="MySQL的日志文件有哪些，它们的作用是什么"><a href="#MySQL的日志文件有哪些，它们的作用是什么" class="headerlink" title="MySQL的日志文件有哪些，它们的作用是什么"></a>MySQL的日志文件有哪些，它们的作用是什么</h4><p><strong>MySQL的日志文件有哪些，它们的作用是什么？</strong></p>
<p>MySQL主要有以下几种日志文件：</p>
<ul>
<li>错误日志（Error Log）：记录MySQL服务的启动、运行或停止过程中的错误信息。</li>
<li>查询日志（General Query Log）：记录所有MySQL执行的SQL命令，无论这些命令是否正确执行。</li>
<li>慢查询日志（Slow Query Log）：记录执行时间超过指定阈值的查询语句。</li>
<li><strong><u>二进制日志</u>（Binary Log）</strong>：<u>记录所有更改数据的SQL语句，用于主从复制和数据恢复。</u>事务的提交 和 主从复制</li>
<li><strong><u>事务日志&#x2F;重做日志</u>（InnoDB Redo Log）</strong>：<u>记录InnoDB存储引擎的事务操作，用于崩溃恢复。</u></li>
<li><strong><u>回滚日志&#x2F;撤销日志</u>（InnoDB Undo Log）</strong>：<u>用于事务回滚，保证事务的原子性。</u></li>
</ul>
<blockquote>
<p><span style = "color:red"><strong>undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是数据页的物理变化，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undo log保证了事务的原子性和一致性</p>
</blockquote>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
</blockquote>
<h4 id="MySQL主从同步原理？"><a href="#MySQL主从同步原理？" class="headerlink" title="MySQL主从同步原理？"></a><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></h4><blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
<pre><code class="java">主服务器（Master）上的数据更改（如INSERT、UPDATE、DELETE操作）会被记录到二进制日志中。
从服务器（Slave）上的I/O线程连接到主服务器，请求主服务器上的二进制日志。
主服务器将二进制日志发送给从服务器，从服务器将这些日志事件写入到本地的中继日志（Relay Log）。
从服务器上的SQL线程读取中继日志中的事件，并在本地执行这些事件，从而实现数据的复制。
</code></pre>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<h4 id="项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下"><a href="#项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下" class="headerlink" title="项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下"></a>项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下</h4><p>分布式事务问题可能出现在跨多个服务或数据库的操作中，例如在订单服务中同时更新订单状态和扣减库存。<del>秒杀案例：是先扣库存提前缓存到redis里，判断够不够，用RabbitMQ异步下来</del></p>
<p>解决方案：可以使用分布式事务框架，如Seata，其中AT模式是一种常见的解决方案。</p>
<p><strong>AT模式原理：</strong></p>
<ul>
<li>AT模式基于两阶段提交，分为两个阶段：一阶段 prepare 和二阶段 commit&#x2F;rollback。</li>
<li>在业务方法开始时，Seata会拦截业务SQL，记录业务数据在执行前后的镜像，生成行锁。</li>
<li>如果一阶段 prepare 成功，则二阶段进行 commit，直接提交事务；如果 prepare 失败，则执行 rollback，利用之前保存的数据镜像回滚到执行前的状态。</li>
</ul>
<h4 id="项目中哪里用到MQ，用来干什么？"><a href="#项目中哪里用到MQ，用来干什么？" class="headerlink" title="项目中哪里用到MQ，用来干什么？"></a><strong>项目中哪里用到MQ，用来干什么？</strong></h4><p>异步发优惠卷 + 积分 [用户对于实时性要求不是很高]</p>
<ul>
<li><h5 id="使用MQ的场景：订单处理"><a href="#使用MQ的场景：订单处理" class="headerlink" title="使用MQ的场景：订单处理"></a>使用MQ的场景：订单处理</h5><h5 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h5><p>当用户在电子商务平台上成功下单后，订单服务需要执行以下操作：</p>
<ol>
<li>更新订单状态为“已支付”。</li>
<li>扣减商品库存。</li>
<li>通知支付服务处理支付。</li>
<li>通知物流服务准备发货。</li>
</ol>
<h5 id="使用MQ的原因"><a href="#使用MQ的原因" class="headerlink" title="使用MQ的原因"></a>使用MQ的原因</h5><p>在这些操作中，更新订单状态和扣减库存是实时且同步的操作，但通知支付服务和物流服务则可以异步进行。使用MQ可以帮助我们实现以下目标：</p>
<ul>
<li><strong>解耦服务</strong>：订单服务不需要直接调用支付服务和物流服务，降低了服务间的耦合度。</li>
<li><strong>异步处理</strong>：订单服务可以立即响应客户端，不必等待支付和物流服务的处理结果。</li>
<li><strong>流量削峰</strong>：在高峰期，MQ可以缓冲大量的订单处理请求，避免服务被压垮。</li>
</ul>
</li>
</ul>
<p><strong>订单服务生产消息：</strong> 当订单服务完成订单状态更新和库存扣减后，它将以下消息发送到</p>
<pre><code>&#123;
  &quot;orderId&quot;: &quot;123456789&quot;,
  &quot;status&quot;: &quot;paid&quot;,
  &quot;userId&quot;: &quot;user123&quot;,
  &quot;items&quot;: [
    &#123;&quot;productId&quot;: &quot;prod123&quot;, &quot;quantity&quot;: 1&#125;,
    &#123;&quot;productId&quot;: &quot;prod456&quot;, &quot;quantity&quot;: 2&#125;
  ]
&#125;
</code></pre>
<p>这个消息将被发送到不同的主题或队列，例如<code>payment_topic</code>和<code>logistics_topic</code>。</p>
<p><strong>2. 支付服务和物流服务消费消息：</strong></p>
<ul>
<li><strong>支付服务</strong>订阅<code>payment_topic</code>，当接收到订单支付消息后，它会处理支付逻辑，如验证支付状态、记录交易日志等。</li>
<li><strong>物流服务</strong>订阅<code>logistics_topic</code>，当接收到订单消息后，它会准备发货，更新物流信息，并通知用户。</li>
</ul>
<p>通过这种方式，订单服务可以快速响应用户请求，而支付和物流服务可以按照自己的节奏处理订单相关的操作，整个系统因此变得更加灵活和可扩展。</p>
<h4 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a><strong>如何保证消息不丢失？</strong></h4><p>保证生产者能够成功发送到交换机和队列(存储消息)，生产者提供了消息确认机制<br>到队列后消息要有持久化机制<br>消费者要有一个消息确认机制 保证消费者至少消费成功消息一次</p>
<blockquote>
<ul>
<li><p>开启生产者确认机制，确保生产者的消息能到达队列<br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
</li>
<li><p>开启持久化功能，确保消息未消费前在队列中不会丢失<br>万一broker挂掉就惨了 保证至少成功一次消费</p>
</li>
<li><p>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack<br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息，而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h4 id="如何解决消息积压？"><a href="#如何解决消息积压？" class="headerlink" title="如何解决消息积压？"></a><strong>如何解决消息积压？</strong></h4><p>产生原因：当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h4 id="如何保证消费幂等性【MQ】"><a href="#如何保证消费幂等性【MQ】" class="headerlink" title="如何保证消费幂等性【MQ】"></a>如何保证消费幂等性【MQ】</h4><p>幂等性是指同一个操作执行多次和执行一次的效果相同。在消息消费的场景中，保证幂等性通常有以下几种方法：<br><strong><u>利用数据库的唯一约束</u><strong>：<br>在数据库中为消息设置唯一标识（如消息ID），在处理消息前先检查该标识是否已存在。<br>导致重复消费 返回ack，blocker未收到。一定要在</strong>生产者</strong>投递的时候生成全局唯一的id，消费者就会去判断。异步生成 拿订单号去数据库查 如果查得到就直接return<br><strong>精髓就是全局唯一</strong><br>UUID不行 因为每次发送的消息都不是同一个UUID 要用业务上的</p>
<h6 id="哪些地方还会有幂等问题？"><a href="#哪些地方还会有幂等问题？" class="headerlink" title="哪些地方还会有幂等问题？"></a>哪些地方还会有幂等问题？</h6><p>提供者的openfegin、xxl-job、被别人调用且涉及到增删改</p>
<h6 id="状态记录："><a href="#状态记录：" class="headerlink" title="状态记录："></a>状态记录：</h6><p>在消费消息前，记录消息的状态（如已处理），处理完毕后再更新状态。要根据订单ID+状态 来保证消费幂等性。订单存在且未支付 → 更新<del>锁订单ID</del></p>
<h6 id="并发情况幂等性："><a href="#并发情况幂等性：" class="headerlink" title="并发情况幂等性："></a>并发情况幂等性：</h6><p>完美的幂等要加上分布式锁<del>对敏感性要求高，且要控制好锁的力度</del></p>
<h4 id="如何保证消费有序性"><a href="#如何保证消费有序性" class="headerlink" title="如何保证消费有序性"></a>如何保证消费有序性</h4><p>队列中可以指定消息的消费顺序</p>
<p>  <strong>RabbitMQ</strong> → 多个生产者并发投，所以生产者不能保证有序性，只考虑消费有序性。以消息进入的MQ的消息去回答。</p>
<h5 id="怎么保证？"><a href="#怎么保证？" class="headerlink" title="怎么保证？"></a>怎么保证？</h5><h6 id="单线程消费："><a href="#单线程消费：" class="headerlink" title="单线程消费："></a>单线程消费：</h6><p>在消费者端使用单个线程处理消息，确保消息按顺序处理。</p>
<h6 id="分区有序："><a href="#分区有序：" class="headerlink" title="分区有序："></a>分区有序：</h6><p>在如Kafka这样的消息队列中，可以保证同一个分区内的消息是有序的。</p>
<h4 id="如何既要又要【有序-速度快】"><a href="#如何既要又要【有序-速度快】" class="headerlink" title="如何既要又要【有序 + 速度快】"></a>如何既要又要【有序 + 速度快】</h4><p>既要又要”通常指的是在保证消息的幂等性和有序性的同时，还需要考虑其他特性（如高性能、高可用等）<br>在一些场景下，可能需要在性能和一致性之间做权衡。例如，可以选择最终一致性来换取更高的性能。<br>Kafka 和 RocketMQ可以天生实现【底层Hash取模】</p>
<h6 id="若非要用RabbitMQ实现呢？"><a href="#若非要用RabbitMQ实现呢？" class="headerlink" title="若非要用RabbitMQ实现呢？"></a>若非要用RabbitMQ实现呢？</h6><p>不同订单之间是否要求一定顺序？？<br>镜像集群，先搭3个节点的镜像集群，建立三个队列分为不同的镜像节点 各占一个队列，需要自己去实现<br>对订单号进行hash取模看到落到哪个节点<br>三个队列至少三个消费者 分别去消费它们<br>此时就可以并行有三个消费者去执行<br>把业务数据没关系的放在不同的队列去管理</p>
<h6 id="万一挂掉了呢？"><a href="#万一挂掉了呢？" class="headerlink" title="万一挂掉了呢？"></a>万一挂掉了呢？</h6><p>队列有持久化不用担心</p>
<h4 id="能说一下如何使用死信交换机吗支付"><a href="#能说一下如何使用死信交换机吗支付" class="headerlink" title="能说一下如何使用死信交换机吗支付"></a>能说一下如何使用死信交换机吗<del>支付</del></h4><p>死信交换机（DLX）用于处理无法正常消费的消息<br>创建一个正常的交换机和队列，以及一个死信交换机和死信队列。</p>
<blockquote>
<ol>
<li><strong>定义死信交换机</strong>：创建一个用于处理死信的交换机。</li>
<li><strong>定义死信队列</strong>：创建一个队列用于接收死信，并将其绑定到死信交换机。</li>
<li><strong>配置主队列的死信交换机属性</strong>：在主队列上设置参数，指定当消息无法正常处理时应该发送到哪个死信交换机。</li>
<li><strong>发送消息到主队列</strong>：生产者将消息发送到主交换机，进而路由到主队列。</li>
<li><strong>消费主队列消息</strong>：消费者从主队列中获取消息并进行处理。如果消息处理失败，它将被路由到死信交换机。</li>
<li><strong>消费死信队列消息</strong>：设置消费者来处理死信队列中的消息，进行错误处理或记录日志等操作。</li>
</ol>
</blockquote>
<h4 id="mysql如何提升深分页查询效率子查询-索引"><a href="#mysql如何提升深分页查询效率子查询-索引" class="headerlink" title="mysql如何提升深分页查询效率子查询+索引"></a>mysql如何提升深分页查询效率<del>子查询+索引</del></h4><p><strong>使用索引</strong>：</p>
<ul>
<li>确保查询中使用的列上有适当的索引，这样可以加快查找速度。</li>
</ul>
<p>**避免使用<code>OFFSET</code>和<code>LIMIT</code>**：</p>
<ul>
<li>使用<code>OFFSET</code>进行深分页时，MySQL需要遍历所有<code>OFFSET</code>之前的行。可以通过记住上一次查询的最大ID来避免使用<code>OFFSET</code>。</li>
</ul>
<p><strong>使用条件过滤</strong>：</p>
<ul>
<li>如果可能，使用WHERE子句来减少需要扫描的数据量。</li>
</ul>
<p><strong>增加<code>LIMIT</code>的大小</strong>：</p>
<ul>
<li>如果业务允许，可以增加每次查询返回的结果集大小，减少分页次数。</li>
</ul>
<p><strong>缓存</strong>：</p>
<ul>
<li>对于不经常变更的数据，可以使用缓存来存储已经查询过的页。</li>
</ul>
<p><strong>使用<code>EXPLAIN</code>分析查询</strong>：</p>
<ul>
<li>使用<code>EXPLAIN</code>来分析查询计划，找出性能瓶颈并进行优化。</li>
</ul>
<h4 id="能说一下常用的存储引擎以及它们的差异吗"><a href="#能说一下常用的存储引擎以及它们的差异吗" class="headerlink" title="能说一下常用的存储引擎以及它们的差异吗"></a>能说一下常用的存储引擎以及它们的差异吗</h4><p><strong>InnoDB</strong>：<br>支持事务、行级锁和外键。<br>适合处理大量短期事务。<br>为了维护数据的完整性，写操作相对较慢</p>
<p><strong>MyISAM</strong>：</p>
<p>不支持事务、不支持行锁只支持表锁<br>并发没那么大 事务要求没那么高可以用</p>
<h4 id="能说一下倒排索引的原理吗？"><a href="#能说一下倒排索引的原理吗？" class="headerlink" title="能说一下倒排索引的原理吗？"></a>能说一下倒排索引的原理吗？</h4><p>根据参与文档中的字段 要构建倒排就会去分词<br>根据用户索引也会分词 就会去查文档id 再去查文档<br>中文词库为IK <del>(Ikun 你干嘛 哎哟~)</del></p>
<h4 id="es的text和keyword的区别"><a href="#es的text和keyword的区别" class="headerlink" title="es的text和keyword的区别"></a>es的text和keyword的区别</h4><h6 id="text"><a href="#text" class="headerlink" title="text"></a>text</h6><p>用于全文搜索，会分词，字符串类型</p>
<h6 id="keywod"><a href="#keywod" class="headerlink" title="keywod"></a>keywod</h6><p>用于精确搜索字段，不会被分词，字符串类型</p>
<h4 id="es在你的项目中是用来做什么的"><a href="#es在你的项目中是用来做什么的" class="headerlink" title="es在你的项目中是用来做什么的"></a>es在你的项目中是用来做什么的</h4><p>快速搜索<del>商品(C端)、订单(后台)</del> + 日志查询 + 地理位置搜索<del>经纬度定位附近的事物</del></p>
<h4 id="mysql和ElasticSearch如何做数据同步"><a href="#mysql和ElasticSearch如何做数据同步" class="headerlink" title="mysql和ElasticSearch如何做数据同步"></a>mysql和ElasticSearch如何做数据同步</h4><p>mysql进行增删改的时候<br>对数据敏感性实时性要求没那么高 只看<u>可靠性</u>[<strong>MQ</strong>异步  +  <strong>定时任务</strong>  &#x3D; 没有那么强一致性]</p>
<h6 id="如果数据量没那么大-有没有必要上ES？"><a href="#如果数据量没那么大-有没有必要上ES？" class="headerlink" title="如果数据量没那么大 有没有必要上ES？"></a>如果数据量没那么大 有没有必要上ES？</h6><p>没有必要，正排索引不走全表扫描也蛮快<br>组长进行技术选型 考虑到以后的业务增长</p>
<h6 id="项目已经上线了-但是中途想换成ES-怎么办"><a href="#项目已经上线了-但是中途想换成ES-怎么办" class="headerlink" title="项目已经上线了 但是中途想换成ES 怎么办"></a>项目已经上线了 但是中途想换成ES 怎么办</h6><p>mysql是全量数据 mq只能同步增量数据 怎么办呢？<br>新上架的只能到ES 那应该如何？</p>
<p>此时涉及到全量和增量的同步<del>与Redis不一样</del><br>加定时任务每周&#x2F;每天 会定期重构一次索引库<del>晚上跑→兜底模式</del>，全量同步，后期再增量同步</p>
<h4 id="能说一下分词的原理吗"><a href="#能说一下分词的原理吗" class="headerlink" title="能说一下分词的原理吗"></a>能说一下分词的原理吗</h4><p>底层是大数据量的内容 树的结构来构建分词 IK，<u>字符分割、词汇识别、过滤停用词</u><br>不好意思面试官 具体底层原理不是很了解</p>
<h4 id="使用ES有遇到什么问题吗"><a href="#使用ES有遇到什么问题吗" class="headerlink" title="使用ES有遇到什么问题吗"></a>使用ES有遇到什么问题吗</h4><p>类似于深分页！<br>测试环境数据量不会很大 等到上线后才会有这种问题</p>
<h4 id="说一下jvm的内存区域，以及每个区域是干什么的"><a href="#说一下jvm的内存区域，以及每个区域是干什么的" class="headerlink" title="说一下jvm的内存区域，以及每个区域是干什么的"></a>说一下jvm的内存区域，以及每个区域是干什么的</h4><p>虚拟机栈、本地方法栈、程序计数器、元空间、堆</p>
<blockquote>
<h6 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h6><p><strong>虚拟机栈</strong>：每个线程运行时所需要的内存(<u><strong>先进后出</strong></u>)<del>方法调用过程</del>。每个栈由多个栈帧组成，对应着每次方法调用所占用的内存。每个线程只能有一个活动<strong>栈帧</strong>，对应着当前执行的那个方法</p>
<p><strong>本地方法栈</strong>：与虚拟机栈类似，区别→虚拟机栈执行java方法，本地方法栈执行native方法【被封装的方法  没有具体实现的 都封装在java虚拟机中】专门存储java写的局部方法的局部变量</p>
<p><strong>程序计数器</strong>：是当前线程所执行的字节码指令的行号指示器 同一个核是错峰出行 会上下文切换，要用程序计数器记录下当前执行到哪里的代码</p>
<p><strong>元空间</strong>：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。最大区别是<strong>元空间在本地内存</strong>中而不是虚拟机中。1.8以前叫永久代   1.8后叫方法区或元空间 一般存储类元信息。还会存有运行时常量池。在里面还会存有静态变量</p>
<p><strong>堆内存</strong>：是JVM所有线程共享的部分，唯一用途是来保存对象实例、数组；由年轻代和老年代组成。new一个都会开启一个空间</p>
</blockquote>
<p><strong>类加载器</strong>：类加载器（Class Loader）负责将类的字节码文件（.class文件）加载到JVM中，并转化为对应的<code>java.lang.Class</code>对象，以供Java程序使用。</p>
<p><strong>执行引擎</strong>：执行引擎（Execution Engine）是负责执行字节码的核心组件。执行引擎的作用是读取字节码指令，对它们进行解析并执行，从而实现Java程序的功能</p>
<p><strong>本地库接口</strong>：是Java虚拟机的一部分，它允许Java程序调用其他语言编写的本地应用程序和库（通常是C或C++）。这是因为Java本身设计为平台无关的语言，但它有时需要与特定平台的底层系统或硬件进行交互，而这通常是通过本地代码实现的。</p>
<p><strong>直接内存（Direct Memory）</strong>：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>
<h4 id="说一下常见的垃圾回收算法-他们的特点是什么？"><a href="#说一下常见的垃圾回收算法-他们的特点是什么？" class="headerlink" title="说一下常见的垃圾回收算法 他们的特点是什么？"></a>说一下常见的垃圾回收算法 他们的特点是什么？</h4><p><strong>标记清除算法</strong>：将垃圾回收分为2个阶段，标记和清除。内存碎片高，效率高，清除快<br><strong>标记整理算法</strong>：一般用于老年代，将存活的对象都向另一端移动，然后清理边界以外的垃圾。[对象要移动,效率低]，效率慢一些 需要把内存碎片移动，内存碎片没有 但是效率低一点<br><strong>复制算法</strong>：将原有的内存空间一分为二，每次只用其中一块，正在使用的对象复制到另一个内存中，然后将该内存空间清空，交换两个内存的角色，完成垃圾回收。</p>
<p><u>被标记的是没有被回收的</u></p>
<h4 id="说一下常见的垃圾回收器以及他们的特点垃圾收集器是垃圾收集算法的具体实现"><a href="#说一下常见的垃圾回收器以及他们的特点垃圾收集器是垃圾收集算法的具体实现" class="headerlink" title="说一下常见的垃圾回收器以及他们的特点垃圾收集器是垃圾收集算法的具体实现"></a>说一下常见的垃圾回收器以及他们的特点<del>垃圾收集器是垃圾收集算法的具体实现</del></h4><p><strong>串行</strong>垃圾收集器[新生代区]：指使用<strong>单线程</strong>进行垃圾回收(用户请求不能访问<del>STW</del>)，堆内存较小适合个人电脑。底层用的<strong>复制算法</strong><br><strong>并行</strong>垃圾收集器：JDK8默认使用此垃圾回收器，在垃圾回收时，<strong>多个线程</strong>在工作(用户请求不能访问<del>STW</del>)，并且java应用中所有线程都要暂停，等待垃圾回收的完成。底层用的<strong>复制算法</strong><br><strong>CMS</strong>(并发[Concurrent Mark Sweep])垃圾收集器：是一款并发的、使用标记—清除算法的垃圾回收器(针对老年代)   <u>初始标记 → 并发标记 → 并发预清理 → 最终标记 → 并发清除 → 并发重置</u>  小于8G内存用CMS  一般用并发垃圾收集器配合收集年轻小内存<br><strong>G1</strong>垃圾收集器[复制算法]：Eden(2M)、最大回收停顿时间、大内存适合用G1、大于8G内存用G1</p>
<h4 id="说一下cms的各个阶段过程以及特点CMS一般都清理老年代"><a href="#说一下cms的各个阶段过程以及特点CMS一般都清理老年代" class="headerlink" title="说一下cms的各个阶段过程以及特点CMS一般都清理老年代"></a>说一下cms的各个阶段过程以及特点<del>CMS一般都清理老年代</del></h4><p>过程：初始标记 → 并发标记 → 并发预清理 → 最终标记 → 并发清除 → 并发重置<br>是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。<br>其最大特点是在进行垃圾回收时，应用仍然能正常运行</p>
<p><strong>初始标记</strong>：找GCRoot根去的第一层对象[STW] 速度是非常快的。为什么STW？如果找的时候同时也要标记 那么若这时候有的未被标记那就有大BUG。<br><strong>并发标记</strong>：从第一层找到后的之后那些对象不能被回收(CMS回收器会遍历老年代，标记出所有活动的对象)，在这个阶段，应用程序线程与垃圾回收线程并发运行[能接收用户请求]，会产生新的对象。<br><strong>并发预清理</strong>：这个阶段也是并发执行的，目的是处理在并发标记阶段应用程序线程产生的新垃圾，CMS回收器会清理那些在并发标记阶段被修改的对象，并执行一些预清理工作，以减少下一个STW阶段的暂停时间。<br><strong>最终标记</strong>：这个阶段是STW的，它是为了处理在并发标记和并发预清理阶段未被处理的对象。CMS回收器会完成所有剩余的标记工作，确保所有存活的对象都被正确标记<br><strong>并发清除</strong>：在这个阶段，应用程序线程与垃圾回收线程再次并发运行。CMS回收器会清除未被标记的对象，释放内存空间。清除过程中不会移动存活对象，因此可能会产生内存碎片。<br><strong>并发重置</strong>：这个阶段是并发执行的，目的是重置CMS数据结构，为下一次垃圾回收做准备。</p>
<h4 id="说一下g1的各个阶段过程以及特点，"><a href="#说一下g1的各个阶段过程以及特点，" class="headerlink" title="说一下g1的各个阶段过程以及特点，"></a>说一下g1的各个阶段过程以及特点，</h4><p>划分成多个区域，每个区域都可以充当eden，survivor，old，humongous，其中<code>humongous</code>专为大对象准备<br>分成三个阶段：新生代回收(STW)、并发标记(重新标记STW)、混合收集。如果并发失败(即回收速度赶不上创建新对象速度)，就会触发<code>Full GC</code></p>
<h4 id="你们项目是用哪一个垃圾收集器，为什么用这个"><a href="#你们项目是用哪一个垃圾收集器，为什么用这个" class="headerlink" title="你们项目是用哪一个垃圾收集器，为什么用这个?"></a>你们项目是用哪一个垃圾收集器，为什么用这个?</h4><p>每个服务两个节点 8G4核 用CMS 太大就用G1</p>
<h4 id="什么样的对象会被成为垃圾对象？"><a href="#什么样的对象会被成为垃圾对象？" class="headerlink" title="什么样的对象会被成为垃圾对象？"></a>什么样的对象会被成为垃圾对象？</h4><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收</p>
<h6 id="怎么确定什么是垃圾？"><a href="#怎么确定什么是垃圾？" class="headerlink" title="怎么确定什么是垃圾？"></a>怎么确定什么是垃圾？</h6><ul>
<li><p><strong>引用计数法</strong><br>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<ol>
<li><strong>标记阶段</strong>：从GCRoots开始，标记所有可达的对象。</li>
<li><strong>回收阶段</strong>：遍历堆中的所有对象，回收那些未被标记的对象所占用的空间。</li>
</ol>
<p>采用的都是通过可达性分析算法来确定哪些内容是垃圾</p>
<p>通过可达性分析算法，那些从任何GCRoots都无法到达的对象被认为是不可达的，因此可以被垃圾回收器回收。这种方法能够处理循环引用的情况，这是引用计数法所无法解决的</p>
</li>
</ul>
<p>静态的成员变量[元空间 基本不会被回收] 局部变量 成员属性 </p>
<h4 id="说一下双亲委派机制以及优点"><a href="#说一下双亲委派机制以及优点" class="headerlink" title="说一下双亲委派机制以及优点"></a>说一下双亲委派机制以及优点</h4><p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类<br>优点：</p>
<ul>
<li>通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性</li>
<li>为了安全，保证类库API不会被修改</li>
</ul>
<p>用相同的加载器在同一个路径下只能用同一个路径的类 用不同的加载器就可以加载</p>
<h6 id="如何打破双亲委派模型？"><a href="#如何打破双亲委派模型？" class="headerlink" title="如何打破双亲委派模型？"></a>如何打破双亲委派模型？</h6><p><strong>自定义类加载器</strong>：</p>
<ul>
<li><p>通过<strong>自定义类加载器</strong>，并重写<code>loadClass</code>方法，可以实现在加载类时不遵循双亲委派模型。在自定义类加载器中，你可以直接尝试加载类，而不是先委派给父类加载器。</p>
<pre><code class="java">public class CustomClassLoader extends ClassLoader &#123;
    @Override
    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;
        // 直接加载，不委派给父类加载器
        return findClass(name);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="jvm常用的参数有哪些？代表什么意思"><a href="#jvm常用的参数有哪些？代表什么意思" class="headerlink" title="jvm常用的参数有哪些？代表什么意思"></a>jvm常用的参数有哪些？代表什么意思</h4><p>jps 进程状态信息<br>jstack 查看进程内线程的堆栈信息(产生死锁也可以查看)<br>jmap 查看堆栈信息(生成堆栈内存快照，内存使用信息)<br>jhat 堆转存快照分析工具<br>jstat JVM统计监测工具</p>
<ol>
<li><code>-Xms</code> 和 <code>-Xmx</code>：<ul>
<li><code>-Xms</code>：设置JVM堆内存的初始大小（最小值）。</li>
<li><code>-Xmx</code>：设置JVM堆内存的最大大小。</li>
</ul>
</li>
<li><code>-Xss</code>：<ul>
<li>设置每个线程的堆栈大小。</li>
</ul>
</li>
<li><code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code>：<ul>
<li><code>-XX:NewSize</code>：设置新生代内存的初始大小。</li>
<li><code>-XX:MaxNewSize</code>：设置新生代内存的最大大小。</li>
</ul>
</li>
<li><code>-XX:SurvivorRatio</code>：<ul>
<li>设置新生代中Eden区与Survivor区的容量比例。</li>
</ul>
</li>
<li><code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code>（Java 8及之前版本）：<ul>
<li><code>-XX:PermSize</code>：设置永久代（方法区）的初始大小。</li>
<li><code>-XX:MaxPermSize</code>：设置永久代的最大大小。</li>
</ul>
</li>
<li>设置元空间大小<ol>
<li><code>-XX:MetaspaceSize</code>：<ul>
<li>设置元空间的初始大小。当元空间耗尽时，JVM会尝试扩展元空间的大小，直到达到最大值（如果设置了的话）。</li>
</ul>
</li>
<li><code>-XX:MaxMetaspaceSize</code>：<ul>
<li>设置元空间的最大大小。如果没有设置这个参数，元空间的大小只受本地内存限制。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="四大引用分别是什么，代表什么意思？"><a href="#四大引用分别是什么，代表什么意思？" class="headerlink" title="四大引用分别是什么，代表什么意思？"></a>四大引用分别是什么，代表什么意思？</h4><p><strong>强引用</strong>：只要所有 GC Roots 能找到，就不会被回收。<br><strong>软引用</strong>：需要配合<code>SoftReference</code>使用，当垃圾多次回收，<strong>内存依然不够</strong>时候会回收软引用对象<br><strong>弱引用</strong>：需要配合<code>WeakReference</code>使用，<strong>只要进行了垃圾回收</strong>，就会把引用对象回收<br><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</p>
<p>● 强引用指的就是代码中普遍存在的赋值方式，比如A 但是不a &#x3D; new A()这种。强引用关联的对象，永远不会被GC回收。<br>● 软引用可以用SoftReference来描述，指的是那些有用是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。<br>● 弱引用可以用WeakReference来描述，他的强度比软引用更低一点，只要进行了垃圾回收，就会把引用对象回收。<br>● 虚引用他必须和ReferenceQueue一起使用，必须配合引用队列使用，被引用对象回收时，<br>会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存。</p>
<h4 id="什么是内存溢出？什么是内存泄露？"><a href="#什么是内存溢出？什么是内存泄露？" class="headerlink" title="什么是内存溢出？什么是内存泄露？"></a>什么是内存溢出？什么是内存泄露？</h4><p><strong>内存溢出</strong>：内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，导致所需要的内存超出了系统所能提供的最大内存。【会先进行一次GC实在不够就OOM 堆\栈(递归过多,局部变量过多)\方法区都有可能发生内存溢出】<br><strong>内存泄露</strong><del>ThreadLocal会导致</del>：内存泄露是指程序中已分配的内存由于某种原因未能释放，即使在不再需要这些内存的情况下，它们仍然保持分配状态，导致可用内存逐渐减少</p>
<h4 id="你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？"><a href="#你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？" class="headerlink" title="你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？"></a>你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？</h4><p>有的，内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况<br>1、通过jmap或设置jvm参数获取堆内存快照dump<br>2、通过工具，VisualVM去分析dump文件，VisualVM可以加载离线的dump文件<br>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题<br>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
<p>异常的祖先是：<code>Throwable</code></p>
<h4 id="怎么解决cpu飙高"><a href="#怎么解决cpu飙高" class="headerlink" title="怎么解决cpu飙高"></a>怎么解决cpu飙高</h4><p>使用top命令查看占用cpu的情况<br>通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>使用ps命令查看进程中的线程信息<br>使用jstack命令查看进程中哪些线程出现了问题，最终定位问题</p>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程<strong>转换十六进程</strong><br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/面试" style=color:#ff7d73>
                面试
            </a>
        </span>
        
    </div>

    <a href="/2025/02/09/面试/洪哥面试题/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/02/07/面试/JL/">
        <h2>
            JL
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/2/7
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="招聘流程"><a href="#招聘流程" class="headerlink" title="招聘流程"></a>招聘流程</h4><p>主流网站：Boss直聘<br>先过系统筛选[写本科 写计算机专业 过筛选 得到面试机会]<br>HR会帮我们的 需要KPI当月目标和业绩<br>黑马课程对标3年工作经验 大厂211都不好进</p>
<p>每次都要微信问一下HR：**<u>技术面</u>** 还是 人力面<br>可以打听面试官侧重点，问一下是领导还是主管还是技术组长</p>
<p>不要乱讲话！！不要乱讲话！！不要乱讲话！！不要乱讲话！！</p>
<p>学信网可查吗？ 先说可查  若让 <em><strong>发编号</strong></em> 就下一家      [<u>可填专科吗？？？</u>]</p>
<hr>
<h4 id="简历怎么写好？"><a href="#简历怎么写好？" class="headerlink" title="简历怎么写好？"></a>简历怎么写好？</h4><p>基本信息 籍贯 <strong>工作年限</strong> 求职岗位(Java开发工程师) 薪资(面议)<br>薪资范围6-18k 拉大范围  入职时间：一周内到岗<br>电话必写 邮箱也必写</p>
<p><u>面试问你什么时候能到岗</u>？<strong>3个工作日左右 &#x2F; (3天左右)</strong></p>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250207105915015.png" alt="image-20250207105915015"></p>
<p><strong>教育经历</strong><br>25届  19-23  也可以大三出去实习 21-24<br>在校：往前推一年<br>学校 + 专业</p>
<p><strong>工作经历</strong><br>每一家一年多 建议2个公司<br>上一家公司距离现在 不能有很空窗时期【<strong>实时修改工作经验时间</strong>】</p>
<p><strong>上周离职</strong>？<br>有没有面试其他？<br>没有 我也是刚好碰到贵公司  有 拿到了offer但是我还是意愿最大贵公司喜欢贵公司的环境</p>
<p><strong>开发技能</strong> [15条以上]<br>细节引导面试官去书写开发技能<br>记得要设置陷阱<br>从优先级高到低写<br>前端一定要写</p>
<p>Java基础先写到前面<br>大数据统计至少要 3年经验 4个项目经验 </p>
<p><strong>项目周期</strong>：时间控制在5-8个月<br>第一个项目经历至少7-8点 需要业务+技术点<br>第二个项目至少5-6条 达到项目一的七成<br>第三四项目至少3条 减量不减质【不要龙头蛇尾】</p>
<p>2025.2.10号中午收集好简历</p>
<p>文件名称：**<u>Java开发工程师 _ 3年 _ 潘春尧</u>**.pdf</p>
<hr>
<hr>
<h4 id="求职意向"><a href="#求职意向" class="headerlink" title="求职意向"></a>求职意向</h4><p>期望城市：不限<br>期望岗位：Java开发工程师<br>期望薪资：面议<br>到岗时间：一周内&#x2F;随时<br>写虚岁！！</p>
<h4 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h4><p>民教网3年：2018.9-2022.7     xxx大学   专业：不相关可以不写</p>
<p>学信网<br>25届：实习<br>23-24届：1-2年</p>
<h4 id="工作经历-一家公司超过两年左右-5-8个月-x2F-一个项目"><a href="#工作经历-一家公司超过两年左右-5-8个月-x2F-一个项目" class="headerlink" title="工作经历(一家公司超过两年左右)  5-8个月 &#x2F; 一个项目"></a>工作经历<del>(一家公司超过两年左右)</del>  5-8个月 &#x2F; 一个项目</h4><p><u>xxx公司(找自己熟悉城市，<strong>不要找在线招聘</strong><del>会被HR直接问对面招聘中的HR</del>)</u></p>
<p>没有社保：不写期望城市<br>社保：写社保所在地<br>公司开业时间、小公司(100人以内)、科技有限公司、上班地点交通方式、背景调查写洪哥、法人(老板)、公司地址</p>
<p>背调：模板<br>写纸质版信息表 出生年月日 → 写真实的日期</p>
<p>第一步：写纸质信息表（证明人：电话）<del>洪哥敏姐</del><br><strong>背调信息</strong>：发给洪哥敏姐</p>
<blockquote>
<p>hr会根据你给的电话直接<br>上级领导：项目<br>第三者：朋友&#x2F;同学&#x2F;同事 [可以拒绝回答很多]</p>
</blockquote>
<p><strong>第三方背调</strong>：查社保 查工作记录 查学信网</p>
<p>带身份证去的话 证明楼下的大厦需要登记身份信息才能进</p>
<hr>
<hr>
<h4 id="Boss上的投递"><a href="#Boss上的投递" class="headerlink" title="Boss上的投递"></a>Boss上的投递</h4><p>上传PDF版本的简历<br>工作经历 → 对该公司隐藏我的简历</p>
<p>文件名称：**<u>潘春尧-本科-3年-Java开发工程师</u>**.pdf</p>
<h5 id="尽量先从远的地方投递简历-试试状态！最想去广州的留到最后状态好的时候再投递"><a href="#尽量先从远的地方投递简历-试试状态！最想去广州的留到最后状态好的时候再投递" class="headerlink" title="尽量先从远的地方投递简历 试试状态！最想去广州的留到最后状态好的时候再投递"></a>尽量先从远的地方投递简历 试试状态！最想去广州的留到最后状态好的时候再投递</h5><p><strong>外包公司</strong>：跟培训的学生匹配 哈哈哈！</p>
<hr>
<hr>
<p>五险一金：基本养老保险[<u>工作里面累计交满20年退休时领退休金</u>] 、 基本医疗保险 [<del>总部上海现在在广州</del>一般都是本地医保方便]、 失业保险[<u>工作满一年后因公司被辞退才可以领取</u>] 、 工伤保险 、 生育保险 及 住房公积金</p>
<p>【要找公积金的公司】公积金5% → 买房可以用公积金来贷款；退休后这笔钱可以一次性提取出来养老；装修&#x2F;租房的名义提取(半年一次)</p>
<p>面试题问：上家公司的工资待遇 → 城市最低标准买的<br>10k扣除五险一金 保险400-500 公积金大概300-400左右 </p>
<p>个人所得税：不超过3.6w就是3%，每个月财务都会扣除发放税后工资，起征点5k，超过5k的部分才会交税。10k以内的大概是3%，</p>
<p>面试：公司有绩效考核  我们没有很明确的考核 日常都能完成工作量</p>
<p>入职当天要签劳务合同 1年或3年？<br>区别是什么？<br>1年的劳动合同只能定1个月试用期 2年2个月 3年3个月<br>大概率试用期8-9折 都是3-6个月</p>
<p>签订劳动合同可以离职   末尾淘汰在法律上不允许<br>转正以后被裁可以n+1个月 n代表年 试用期被辞退会赔偿半个月薪资</p>
<p><strong>民教网</strong>(1000人以下的公司) 主攻针对小型企业 和 二三线城市<br>浙江→绍兴杭州<br>远公司约线上公司 </p>
<h6 id="现在在外地-能不能开一轮的线上面试-如果有需求我还是能过去的"><a href="#现在在外地-能不能开一轮的线上面试-如果有需求我还是能过去的" class="headerlink" title="现在在外地 能不能开一轮的线上面试 如果有需求我还是能过去的"></a>现在在外地 能不能开一轮的线上面试 如果有需求我还是能过去的</h6>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/面试" style=color:#00bcd4>
                面试
            </a>
        </span>
        
    </div>

    <a href="/2025/02/07/面试/JL/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/01/03/后端/ElasticSearch/">
        <h2>
            ElasticSearch
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/1/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>ElasticSearch结合Kibana、Logstash、Beats，核心是elastic stack的核心，负责<strong>存储、搜索、分析数据</strong><br>Lucene的优势：容易扩展、高性能(基于倒排索引)<br>Lucene的缺点：直选与java语言开发<br>ElasticSearch是基于Lucene开发的</p>
<h6 id="Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能"><a href="#Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能" class="headerlink" title="Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能"></a>Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</h6><h4 id="正向索引和倒排索引"><a href="#正向索引和倒排索引" class="headerlink" title="正向索引和倒排索引"></a>正向索引和倒排索引</h4><p>传统数据库是<strong>正向索引</strong></p>
<p><strong>ElasticSearch采用倒排索引</strong>：</p>
<ul>
<li>文档(document)：每条数据就是一个文档</li>
<li>词条(term)：文档按照语义分成词语</li>
</ul>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">title</th>
<th align="center">price</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">小米手机</td>
<td align="center">3499</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">华为手机</td>
<td align="center">4999</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">华为小米充电器</td>
<td align="center">49</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">小米手环</td>
<td align="center">299</td>
</tr>
</tbody></table>
<p>  ↓↓↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓       </p>
<table>
<thead>
<tr>
<th align="center">词条(term)</th>
<th align="center">文档id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">小米</td>
<td align="center">1，3，4</td>
</tr>
<tr>
<td align="center">手机</td>
<td align="center">1，2</td>
</tr>
<tr>
<td align="center">华为</td>
<td align="center">2，3</td>
</tr>
<tr>
<td align="center">充电器</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">手环</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p><strong>过程</strong>：搜索<code>华为手机</code> → 得到：<code>华为</code>、<code>手机</code>两个词条 → 得到每个词条所在文档id：华为:2,3 手机:1,2 → 得到id为1,2,3的文档 → 存入结果集<br><strong>倒排索引</strong>：对文档内容分词，对词条创建索引，并记录词条所在文档的信息。查询时现根据词条查询到文档id，而后获取到文档<br><strong>正排索引</strong>：基于文档id创建索引。查询词条时必须先找到文档，而后判断是否包含词条</p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>ElasticSearch是面向文档存储的，可以是数据库中的一条商品数据，一个订单信息，文档数据会被序列化为json格式后存储在ElasticSearch中<br>在ElasticSearch中</p>
<ul>
<li>**索引(index)**：相同类型的文档的集合</li>
<li>**映射(mapping)**：索引中文档的字段约束信息，类似表的结构约束</li>
</ul>
<h6 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h6><table>
<thead>
<tr>
<th align="center">MySQL</th>
<th align="center">ElasticSearch</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Table</td>
<td align="center">Index</td>
<td align="center">索引(index)，就是文档的集合，类似于数据库的表(table)</td>
</tr>
<tr>
<td align="center">Row</td>
<td align="center">Document</td>
<td align="center">文档(Document)，就是一条条的数据，类似数据库中的行(Row)，文档都是JSON格式</td>
</tr>
<tr>
<td align="center">Column</td>
<td align="center">Field</td>
<td align="center">字段(Field)，就是JSON文档中的字段，类似数据库中的列(Column)</td>
</tr>
<tr>
<td align="center">Schema</td>
<td align="center">Mapping</td>
<td align="center">Mapping(映射)，就是索引中文档的约束，例如字段类型约束。类似数据库的表结构(Schema)</td>
</tr>
<tr>
<td align="center">SQL</td>
<td align="center">DSL</td>
<td align="center">DSL是ElasticSearch提供的JSON风格的请求语句，用来操作ElasticSearch，实现CRUD</td>
</tr>
</tbody></table>
<h6 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h6><p><strong>MySQL</strong><del>写操作</del>：擅长事务类型操作，可以确保数据的安全和一致性<br><strong>ElasticSearch</strong><del>查询</del>：擅长海量数据的搜索、分析、计算<br>[<strong><u>可以互补达到数据双写一致性</u></strong>]</p>
<h2 id="1-1-创建网络"><a href="#1-1-创建网络" class="headerlink" title="1.1.创建网络"></a>1.1.创建网络</h2><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络（创建过的不用再创建）：</p>
<pre><code class="sh">docker network create es-net
</code></pre>
<h2 id="1-2-加载镜像"><a href="#1-2-加载镜像" class="headerlink" title="1.2.加载镜像"></a>1.2.加载镜像</h2><p>这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。</p>
<p>课前资料提供了镜像的tar包：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210510165308064.png" alt="image-20210510165308064"></p>
<p>大家将其上传到虚拟机中，然后运行命令加载即可：</p>
<pre><code class="sh"># 导入数据
docker load -i es.tar
</code></pre>
<p>同理还有<code>kibana</code>的tar包也需要这样做。</p>
<h2 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3.运行"></a>1.3.运行</h2><p>运行docker命令，部署单点es：</p>
<pre><code class="sh">docker run -d \
    --name es \
    -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \
    -e &quot;discovery.type=single-node&quot; \
    -v es-data:/usr/share/elasticsearch/data \
    -v es-plugins:/usr/share/elasticsearch/plugins \
    --privileged \
    --network es-net \
    -p 9200:9200 \
    -p 9300:9300 \
elasticsearch:7.12.1
</code></pre>
<p>命令解释：</p>
<ul>
<li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li>
<li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li>
<li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li>
<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li>
<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li>
<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li>
<li><code>--privileged</code>：授予逻辑卷访问权</li>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中</li>
<li><code>-p 9200:9200</code>：端口映射配置</li>
</ul>
<p>在浏览器中输入：<a target="_blank" rel="noopener" href="http://192.168.xxx.xxx:9200/">http://192.168.xxx.xxx:9200</a> 即可看到elasticsearch的响应结果：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506101053676.png" alt="image-20210506101053676"></p>
<h1 id="2-部署kibana"><a href="#2-部署kibana" class="headerlink" title="2.部署kibana"></a>2.部署kibana</h1><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p>
<h2 id="2-1-部署"><a href="#2-1-部署" class="headerlink" title="2.1.部署"></a>2.1.部署</h2><p>运行docker命令，部署kibana，同理先加载镜像： docker load -i kibana.tar，然后启动：</p>
<pre><code class="sh">docker run -d \
--name kibana \
-e ELASTICSEARCH_HOSTS=http://es:9200 \
--network=es-net \
-p 5601:5601  \
kibana:7.12.1
</code></pre>
<ul>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li>
<li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为<strong>kibana已经与elasticsearch在一个网络</strong>，因此可以用容器名直接访问elasticsearch</li>
<li><code>-p 5601:5601</code>：端口映射配置</li>
</ul>
<p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p>
<pre><code class="sh">docker logs -f kibana
</code></pre>
<p>查看运行日志，当查看到下面的日志，说明成功：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210109105135812.png" alt="image-20210109105135812"></p>
<p>此时，在浏览器输入地址访问：<a href="http://192.168.xxx.xxx:5601，即可看到结果">http://192.168.xxx.xxx:5601，即可看到结果</a></p>
<h6 id="分词效果概览-Dev-Tools-Elastic"><a href="#分词效果概览-Dev-Tools-Elastic" class="headerlink" title="分词效果概览 Dev Tools - Elastic"></a>分词效果概览 <a target="_blank" rel="noopener" href="http://192.168.200.146:5601/app/dev_tools#/console">Dev Tools - Elastic</a></h6><blockquote>
<p>GET &#x2F;_analyze<br>{<br>  “analyzer”: “standard”,<br>  “text”: “黑马程序员”<br>}</p>
</blockquote>
<pre><code class="json">&#123;
  &quot;tokens&quot; : [
    &#123;
      &quot;token&quot; : &quot;黑&quot;,
      &quot;start_offset&quot; : 0,
      &quot;end_offset&quot; : 1,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 0
    &#125;,
    &#123;
      &quot;token&quot; : &quot;马&quot;,
      &quot;start_offset&quot; : 1,
      &quot;end_offset&quot; : 2,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 1
    &#125;,
    &#123;
      &quot;token&quot; : &quot;程&quot;,
      &quot;start_offset&quot; : 2,
      &quot;end_offset&quot; : 3,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 2
    &#125;,
    &#123;
      &quot;token&quot; : &quot;序&quot;,
      &quot;start_offset&quot; : 3,
      &quot;end_offset&quot; : 4,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 3
    &#125;,
    &#123;
      &quot;token&quot; : &quot;员&quot;,
      &quot;start_offset&quot; : 4,
      &quot;end_offset&quot; : 5,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 4
    &#125;
  ]
&#125;
</code></pre>
<p>如果是分析中午就不能用它原有的，存在明显的问题：将中文逐字分词，没有任何业务语义，因此需要借助专业的分词器</p>
<h1 id="3-安装IK分词器"><a href="#3-安装IK分词器" class="headerlink" title="3.安装IK分词器"></a>3.安装IK分词器</h1><h2 id="3-1-在线安装ik插件（较慢）"><a href="#3-1-在线安装ik插件（较慢）" class="headerlink" title="3.1.在线安装ik插件（较慢）"></a>3.1.在线安装ik插件（较慢）</h2><pre><code class="shell"># 进入容器内部
docker exec -it elasticsearch /bin/bash

# 在线下载并安装
./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip

#退出
exit
#重启容器
docker restart elasticsearch
</code></pre>
<h2 id="3-2-离线安装ik插件（推荐）"><a href="#3-2-离线安装ik插件（推荐）" class="headerlink" title="3.2.离线安装ik插件（推荐）"></a>3.2.离线安装ik插件（推荐）</h2><h3 id="1）查看数据卷目录"><a href="#1）查看数据卷目录" class="headerlink" title="1）查看数据卷目录"></a>1）查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p>
<pre><code class="sh">docker volume inspect es-plugins
</code></pre>
<p>显示结果：</p>
<pre><code class="json">[
    &#123;
        &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: null,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;,
        &quot;Name&quot;: &quot;es-plugins&quot;,
        &quot;Options&quot;: null,
        &quot;Scope&quot;: &quot;local&quot;
    &#125;
]
</code></pre>
<p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code>这个目录中。</p>
<h3 id="2）解压缩分词器安装包"><a href="#2）解压缩分词器安装包" class="headerlink" title="2）解压缩分词器安装包"></a>2）解压缩分词器安装包</h3><p>下面我们需要把课前资料中的ik分词器解压缩，重命名为ik</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506110249144.png" alt="image-20210506110249144"></p>
<h3 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a>3）上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data </code>：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506110704293.png" alt="image-20210506110704293"></p>
<h3 id="4）重启容器"><a href="#4）重启容器" class="headerlink" title="4）重启容器"></a>4）重启容器</h3><pre><code class="shell"># 4、重启容器
docker restart es
</code></pre>
<pre><code class="sh"># 查看es日志
docker logs -f es
</code></pre>
<h3 id="5）测试："><a href="#5）测试：" class="headerlink" title="5）测试："></a>5）测试：</h3><p><span style = "color:red"><strong>IK分词器包含两种模式</strong>：</span></p>
<ul>
<li><p><code>ik_smart</code>：最少切分</p>
</li>
<li><p><code>ik_max_word</code>：最细切分</p>
</li>
</ul>
<pre><code class="json">GET /_analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;黑马程序员学习java太棒了&quot;
&#125;
</code></pre>
<p>结果：</p>
<pre><code class="json">&#123;
  &quot;tokens&quot; : [
    &#123;
      &quot;token&quot; : &quot;黑马&quot;,
      &quot;start_offset&quot; : 0,
      &quot;end_offset&quot; : 2,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 0
    &#125;,
    &#123;
      &quot;token&quot; : &quot;程序员&quot;,
      &quot;start_offset&quot; : 2,
      &quot;end_offset&quot; : 5,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 1
    &#125;,
    &#123;
      &quot;token&quot; : &quot;程序&quot;,
      &quot;start_offset&quot; : 2,
      &quot;end_offset&quot; : 4,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 2
    &#125;,
    &#123;
      &quot;token&quot; : &quot;员&quot;,
      &quot;start_offset&quot; : 4,
      &quot;end_offset&quot; : 5,
      &quot;type&quot; : &quot;CN_CHAR&quot;,
      &quot;position&quot; : 3
    &#125;,
    &#123;
      &quot;token&quot; : &quot;学习&quot;,
      &quot;start_offset&quot; : 5,
      &quot;end_offset&quot; : 7,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 4
    &#125;,
    &#123;
      &quot;token&quot; : &quot;java&quot;,
      &quot;start_offset&quot; : 7,
      &quot;end_offset&quot; : 11,
      &quot;type&quot; : &quot;ENGLISH&quot;,
      &quot;position&quot; : 5
    &#125;,
    &#123;
      &quot;token&quot; : &quot;太棒了&quot;,
      &quot;start_offset&quot; : 11,
      &quot;end_offset&quot; : 14,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 6
    &#125;,
    &#123;
      &quot;token&quot; : &quot;太棒&quot;,
      &quot;start_offset&quot; : 11,
      &quot;end_offset&quot; : 13,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 7
    &#125;,
    &#123;
      &quot;token&quot; : &quot;了&quot;,
      &quot;start_offset&quot; : 13,
      &quot;end_offset&quot; : 14,
      &quot;type&quot; : &quot;CN_CHAR&quot;,
      &quot;position&quot; : 8
    &#125;
  ]
&#125;
</code></pre>
<h2 id="3-3-扩展词词典"><a href="#3-3-扩展词词典" class="headerlink" title="3.3 扩展词词典"></a>3.3 扩展词词典</h2><h5 id="注意当前文件的编码必须是-UTF-8-格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑"><a href="#注意当前文件的编码必须是-UTF-8-格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑" class="headerlink" title="注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑"></a><span style = "color:red">注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑</span></h5><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。</p>
<p>所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p>
<p>1）打开IK分词器config目录：<code>/var/lib/docker/volumes/es-plugins/_data/ik/config/IKAnalyzer.cfg.xml</code></p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506112225508.png" alt="image-20210506112225508"></p>
<p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;
&lt;properties&gt;
        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;
      
        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; 
&lt;/properties&gt;
</code></pre>
<p>3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p>
<pre><code class="properties">传智播客
奥力给
</code></pre>
<p>4）重启elasticsearch </p>
<pre><code class="sh">docker restart es

# 查看 日志
docker logs -f es
</code></pre>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20201115230900504.png" alt="image-20201115230900504"></p>
<p>日志中已经成功加载ext.dic配置文件</p>
<p>5）测试效果：</p>
<pre><code class="json">GET /_analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;传智播客Java就业超过90%,奥力给！&quot;
&#125;
</code></pre>
<blockquote>
<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑</p>
</blockquote>
<h2 id="3-4-停用词词典"><a href="#3-4-停用词词典" class="headerlink" title="3.4 停用词词典"></a>3.4 停用词词典</h2><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p>
<p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p>
<p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;
&lt;properties&gt;
        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;
        &lt;!--用户可以在这里配置自己的扩展字典--&gt;
        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;
         &lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;
        &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;
&lt;/properties&gt;
</code></pre>
<p>3）在 stopword.dic 添加停用词</p>
<pre><code class="properties">习大大
</code></pre>
<p>4）重启elasticsearch </p>
<pre><code class="sh"># 重启服务
docker restart es
docker restart kibana

# 查看 日志
docker logs -f es
</code></pre>
<p>日志中已经成功加载stopword.dic配置文件</p>
<p>5）测试效果：</p>
<pre><code class="json">GET /_analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;传智播客Java就业率超过95%,习大大都点赞,奥力给！&quot;
&#125;
</code></pre>
<blockquote>
<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p>
</blockquote>
<hr>
<hr>
<h4 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h4><h5 id="mapping属性"><a href="#mapping属性" class="headerlink" title="mapping属性"></a>mapping属性</h5><h6 id="mapping是对索引库中文档的约束，常见的mapping属性包括："><a href="#mapping是对索引库中文档的约束，常见的mapping属性包括：" class="headerlink" title="mapping是对索引库中文档的约束，常见的mapping属性包括："></a>mapping是对索引库中文档的约束，常见的mapping属性包括：</h6><p>• type：字段数据类型，常见的简单类型有：<br>• 字符串：text（可分词的文本）、<strong>keyword</strong>（精确值，例如：品牌、国家、ip地址）<br>• 数值：long、integer、short、byte、double、float<br>• 布尔：boolean<br>• 日期：date<br>• 对象：object<br>• index：是否创建索引，默认为true【默认倒排】<br>• analyzer：使用哪种分词器【只有text才需要分词】<br>• properties：该字段的子字段</p>
<pre><code class="java">&#123;
    &quot;age&quot;: 21,
    &quot;weight&quot;: 52.1,
    &quot;isMarried&quot;: false,
    &quot;info&quot;: &quot;黑马程序员Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;score&quot;: [99.1, 99.5, 98.9],
    &quot;name&quot;: &#123;
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    &#125;
&#125;
</code></pre>
<h5 id="索引库操作-1"><a href="#索引库操作-1" class="headerlink" title="索引库操作"></a>索引库操作</h5><h6 id="创建索引库和mapping的请求语法"><a href="#创建索引库和mapping的请求语法" class="headerlink" title="创建索引库和mapping的请求语法"></a>创建索引库和mapping的请求语法</h6><pre><code class="java">PUT /索引库名称
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;字段名&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_smart&quot;
      &#125;,
      &quot;字段名2&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: &quot;false&quot;
      &#125;,
      &quot;字段名3&quot;:&#123;
        &quot;properties&quot;: &#123;
          &quot;子字段&quot;: &#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;,
      // ...略
    &#125;
  &#125;
&#125;
</code></pre>
<p>↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓</p>
<pre><code class="java"># 创建索引库
PUT /heima
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;info&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      &#125;,
      &quot;email&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      &#125;,
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: &#123;
          &quot;firstName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;,
          &quot;lastName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
---------------------------------------------------------------------
&#123;
  &quot;acknowledged&quot; : true,
  &quot;shards_acknowledged&quot; : true,
  &quot;index&quot; : &quot;heima&quot;
&#125;
</code></pre>
<h4 id="操作索引库禁止修改索引库-因为已经映射好了"><a href="#操作索引库禁止修改索引库-因为已经映射好了" class="headerlink" title="操作索引库禁止修改索引库(因为已经映射好了)"></a>操作索引库<del>禁止修改索引库(因为已经映射好了)</del></h4><h6 id="查看索引语法："><a href="#查看索引语法：" class="headerlink" title="查看索引语法："></a>查看索引语法：</h6><p><code>GET/索引名</code></p>
<h6 id="删除索引库的语法："><a href="#删除索引库的语法：" class="headerlink" title="删除索引库的语法："></a>删除索引库的语法：</h6><p><code>DELETE/索引库名</code></p>
<h6 id="可以在修改索引的过程中添加新的字段"><a href="#可以在修改索引的过程中添加新的字段" class="headerlink" title="可以在修改索引的过程中添加新的字段"></a>可以在修改索引的过程中添加新的字段</h6><pre><code class="java">PUT /索引库名/_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;新字段名&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;
---------------------------
PUT /heima/_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;age&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>当您使用Elasticsearch（ES）的PUT请求创建索引库时，这个索引库实际上是存储在Elasticsearch集群的节点上的。如果您的Elasticsearch集群是安装在Linux服务器上的，那么是的，索引库会被创建在Linux文件系统中。</p>
<p>Elasticsearch为每个索引分配一个或多个主分片，并为每个主分片分配一个或多个副本分片。这些分片实际上是存储在Elasticsearch节点的文件系统上的。具体来说，索引数据存储在以下路径：</p>
<p>复制</p>
<pre><code>/path/to/elasticsearch/data/nodes/&lt;node-id&gt;/&lt;index&gt;/&lt;shard-id&gt;
</code></pre>
<p>这里的<code>/path/to/elasticsearch</code>是Elasticsearch的安装路径，<code>data</code>目录是默认的数据存储位置，<code>nodes</code>目录包含了集群中各个节点的数据，<code>&lt;node-id&gt;</code>是节点的唯一标识，<code>&lt;index&gt;</code>是您创建的索引名称，而<code>&lt;shard-id&gt;</code>则是分片的ID。</p>
</blockquote>
<h4 id="索引库的增删改查汇总"><a href="#索引库的增删改查汇总" class="headerlink" title="索引库的增删改查汇总"></a>索引库的增删改查汇总</h4><pre><code class="mysql">
# 创建索引库
PUT /heima
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;info&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      &#125;,
      &quot;email&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      &#125;,
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: &#123;
          &quot;firstName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;,
          &quot;lastName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;

# 查询
GET /heima

# 修改索引库
PUT /heima/_mapping
&#123;
  &quot;properties&quot;:&#123;
    &quot;age&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;

# 修改
DELETE /heima
</code></pre>
<h5 id="文档操作——添加文档"><a href="#文档操作——添加文档" class="headerlink" title="文档操作——添加文档"></a>文档操作——添加文档</h5><pre><code class="mysql"># 每次写操作的时候 版本会增加 &quot;_version ++&quot;

# 插入文档
POST /heima/_doc/1
&#123;
  &quot;info&quot;: &quot;广州黑马198班&quot;,
  &quot;email&quot;: &quot;390415049@qq.com&quot;,
  &quot;name&quot;:&#123;
    &quot;firstName&quot;: &quot;春&quot;,
    &quot;lastName&quot;: &quot;尧&quot;
  &#125;
&#125;

# 查询文档
GET /heima/_doc/1

# 删除文档
DELETE /heima/_doc/1
</code></pre>
<h5 id="文档操作——修改文档"><a href="#文档操作——修改文档" class="headerlink" title="文档操作——修改文档"></a>文档操作——修改文档</h5><h6 id="方式一：全量修改，会删除旧文档，添加新文档"><a href="#方式一：全量修改，会删除旧文档，添加新文档" class="headerlink" title="方式一：全量修改，会删除旧文档，添加新文档"></a>方式一：全量修改，会删除旧文档，添加新文档</h6><pre><code class="java">PUT /索引库名/_doc/文档id
&#123;
    &quot;字段1&quot;: &quot;值1&quot;,
    &quot;字段2&quot;: &quot;值2&quot;,
    // ... 略
&#125;
-------------------------
PUT /heima/_doc/1
&#123;
    &quot;info&quot;: &quot;黑马程序员高级Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;name&quot;: &#123;
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    &#125;
&#125;


# 全量修改文档
POST /heima/_doc/1
&#123;
  &quot;info&quot;: &quot;广州黑马198班&quot;,
  &quot;email&quot;: &quot;90415049@qq.com&quot;,
  &quot;name&quot;:&#123;
    &quot;firstName&quot;: &quot;尧&quot;,
    &quot;lastName&quot;: &quot;春&quot;
  &#125;
&#125;
</code></pre>
<h6 id="方式二：增量修改，修改指定字段值"><a href="#方式二：增量修改，修改指定字段值" class="headerlink" title="方式二：增量修改，修改指定字段值"></a>方式二：增量修改，修改指定字段值</h6><pre><code class="java">POST /索引库名/_update/文档id
&#123;
    &quot;doc&quot;: &#123;
         &quot;字段名&quot;: &quot;新的值&quot;,
    &#125;
&#125;
-------------------------
POST /heima/_update/1
&#123;
  &quot;doc&quot;: &#123;
    &quot;email&quot;: &quot;ZhaoYun@itcast.cn&quot;
  &#125;
&#125;


# 局部修改文档
POST /heima/_update/1
&#123;
  &quot;doc&quot;: &#123;
    &quot;email&quot;: &quot;ZYun@itcast.cn&quot;
  &#125;
&#125;
</code></pre>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>文档操作有哪些？</p>
<ul>
<li><p>创建文档：POST &#x2F;索引库名&#x2F;_doc&#x2F;文档id { json文档 }</p>
</li>
<li><p>查询文档：GET &#x2F;索引库名&#x2F;_doc&#x2F;文档id</p>
</li>
<li><p>删除文档：DELETE &#x2F;索引库名&#x2F;_doc&#x2F;文档id</p>
</li>
<li><p>修改文档：</p>
<ul>
<li><p>全量修改：PUT &#x2F;索引库名&#x2F;_doc&#x2F;文档id { json文档 }</p>
</li>
<li><p>增量修改：POST &#x2F;索引库名&#x2F;_update&#x2F;文档id { “doc”: {字段}}</p>
</li>
</ul>
</li>
</ul>
<h3 id="JavaRestClient"><a href="#JavaRestClient" class="headerlink" title="JavaRestClient"></a>JavaRestClient</h3><p>Elasticsearch目前最新版本是8.0，其Java客户端有很大变化。不过大多数企业使用的还是8以下版本，所以我们选择使用早期的JavaRestClient客户端来学习。官方文档地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">Elasticsearch Clients | Elastic</a></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2025/01/03/后端/ElasticSearch/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/23/后端/MyBatisPlus/">
        <h2>
            MyBatisPlus
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/23
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><a target="_blank" rel="noopener" href="https://www.baomidou.com/">MyBatis-Plus</a><br><a target="_blank" rel="noopener" href="https://www.baomidou.com/introduce/">简介 | MyBatis-Plus</a></p>
<h5 id="引入MybatisPlus起步依赖写依赖-认爸爸"><a href="#引入MybatisPlus起步依赖写依赖-认爸爸" class="headerlink" title="引入MybatisPlus起步依赖写依赖+认爸爸"></a>引入MybatisPlus起步依赖<del>写依赖+认爸爸</del></h5><ul>
<li>MyBatisPlus官方提供了starter，其中集成了Mybatis和MybatisPlus的所有功能，并且实现了自动装配效果。因此我们可以用MybatisPlus的starter代替Mybatis的starter：</li>
</ul>
<pre><code class="xml">&lt;!--MybatisPlus--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; 
    &lt;version&gt;3.5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>自定义的Mapper继承MybatisPlus提供的<code>BaseMapper</code>接口</li>
</ul>
<pre><code class="java">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">UserMapper.java

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
</code></pre>
<pre><code class="xml">UserMapper.xml

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.itheima.mp.mapper.UserMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul>
<li><code>@TableName</code>：用来指定表名</li>
<li><code>@Tableld</code>：用来指定表中的主键字段信息<ul>
<li><code>IdType枚举</code>：<ul>
<li><strong>AUTO</strong>：数据库自增长</li>
<li><strong>INPUT</strong>：通过set方法自行输入</li>
<li><em>ASSIGN_ID</em>：<u>分配ID 默认实现类是</u><code>雪花算法</code></li>
</ul>
</li>
</ul>
</li>
<li><code>@TableField</code>：用来指定表中的普通字段信息<del>默认驼峰转下划线，不一致需要改</del><ul>
<li>成员变量名与数据库字段名不一致</li>
<li><u>成员变量名是以<strong>is开头</strong>，且是<strong>布尔值</strong></u><del>isMarried</del></li>
<li>成员变量名与数据库关键字冲突<del>order</del></li>
<li>成员变量不是数据库字段<del>address</del>，要标记不存在不然会默认数据库字段</li>
</ul>
</li>
</ul>
<pre><code class="java">@Data
public class User &#123;
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Long id;
    
    @TableField(&quot;username&quot;)
    private String name;

    @TableField(&quot;is_married&quot;)
    private Boolean isMarried;  // is经过反射会默认变成变量名Married
    
    @TableField(&quot;`order`&quot;)
    private Integer order;
    
    @TableField(exist = false)
    private String address;
......
&#125;
</code></pre>
<p>此时如果数据库的表名是：<code>tb_user</code> 就需要用到 <code>@TableName</code> 了</p>
<pre><code class="mysql">数据库名：tb_user (用户表)
#  名称
1  id
2  username
3  is_married
4  order
</code></pre>
<h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><p><code>MyBatisPlus</code>的配置项继承了MyBatis原生配置和一些自己特有的配置<br>MP更擅长单表的增删改查，如果是多表还是推荐用xml</p>
<pre><code class="yaml">mybatis:
  mapper-locations: classpath*:mapper/*.xml # Mapper.xml文件地址，默认值
  type-aliases-package: com.itheima.po # 别名扫描包
  configuration:
    map-underscore-to-camel-case: true # 开启驼峰命名自动映射
    cache-enabled: false # 是否开启二级缓存
  global-config:
    db-config:
      id-type: assign_id # id为雪花算法生成
      update-strategy: not_null # 更新策略：只更新非空字段 类似于动态sql
</code></pre>
<p><span style="color:red"><strong>MyBatisPlus使用的基本流程</strong></span></p>
<ul>
<li>引入起步依赖</li>
<li>自定义Mapper基础BaseMapper</li>
<li>在实体类上添加注释声明 表信息</li>
<li>在application.yml中根据需要添加配置</li>
</ul>
<h3 id="核心功能—条件构造器"><a href="#核心功能—条件构造器" class="headerlink" title="核心功能—条件构造器"></a>核心功能—条件构造器</h3><h6 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/3b9a3950642e32ab3182e3aae6cd2ba50c25f42f/MyBatisPlus%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%88%97%E8%A1%A8.jpg"></p>
<p><code>MyBatisPlus</code>支持各种复杂的<code>where</code>条件，满足日常开发的所有需求</p>
<ul>
<li>查询出名字中带o的，存款大于等于1000元的人的id、username、info、balance字段</li>
</ul>
<pre><code class="mysql"># 原始SQL：
SELECT id,username,info,balance
FROM user
WHERE username LIKE ? AND balance &gt;= ?
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testQueryWrapper()&#123;
        // 1.构建查询条件
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;()
                .select(&quot;id&quot;, &quot;username&quot;, &quot;phone&quot;)
                .like(&quot;username&quot;, &quot;o&quot;)
                .ge(&quot;balance&quot;, 1000);
        // 2.查询
        List&lt;User&gt; users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    &#125;
</code></pre>
<pre><code class="java">// MyBatisPlus Lambda编码格式(解决硬编码)：
 @Test
    void testLambdaQueryWrapper()&#123;
        // 1.构建查询条件
        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;User&gt;()
                // 利用反射 解决字符串硬编码
                .select(User::getId, User::getUsername, User::getPhone)
                .like(User::getUsername, &quot;o&quot;)
                .ge(User::getBalance, 1000);
        // 2.查询
        List&lt;User&gt; users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    &#125;

-------------------------------------------------------------------------
@Test
void testLambdaQueryWrapperWithQueryWrapper()&#123;
    // 1. 构建查询条件
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();
    LambdaQueryWrapper&lt;User&gt; wrapper = queryWrapper.lambda()
            .select(User::getId, User::getUsername, User::getPhone)
            .like(User::getUsername, &quot;o&quot;)
            .ge(User::getBalance, 1000);

    // 2. 查询
    List&lt;User&gt; users = userMapper.selectList(wrapper);
    users.forEach(System.out::println);
&#125;
</code></pre>
<ul>
<li>更新用户名为jack的用户的余额为2000</li>
</ul>
<pre><code class="mysql"># 原始SQL：
UPDATE user
    SET balance = 2000
    WHERE (username = &quot;jack&quot;)
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testUpdateByQueryWrapper()&#123;
        // 1.要更新的数据
        User user = new User();
        user.setBalance(2000);
        // 2.更新的条件
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().eq(&quot;username&quot;, &quot;jack&quot;);
        // 3.执行更新
        userMapper.update(user, wrapper);
    &#125;
</code></pre>
<ul>
<li>更新id为1，2，4的用户的余额，扣200</li>
</ul>
<pre><code class="mysql"># 原始SQL：
UPDATE user
    SET balance = balance - 200
    WHERE id in (1,2,4)
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testUpdateWrapper()&#123;
        List&lt;Long&gt; ids = List.of(1L, 2L, 4L);
        UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;User&gt;()
                .setSql(&quot;balance = balance - 100&quot;)
                .in(&quot;id&quot;, ids);
        userMapper.update(null, wrapper);
    &#125;
</code></pre>
<h5 id="条件构造器的用法："><a href="#条件构造器的用法：" class="headerlink" title="条件构造器的用法："></a>条件构造器的用法：</h5><ul>
<li><p>QueryWrapper和LambdaQueryWrapper通常用来构建select、delete、update的where条件部分</p>
</li>
<li><p>UpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才使用</p>
</li>
<li><p>尽量使用LambdaQueryWrapper和LambdaUpdateWrapper，避免硬编码</p>
</li>
</ul>
<h3 id="4-字段映射与表名映射"><a href="#4-字段映射与表名映射" class="headerlink" title="4. 字段映射与表名映射"></a>4. 字段映射与表名映射</h3><h4 id="4-1-问题一：表字段与编码属性设计不同步"><a href="#4-1-问题一：表字段与编码属性设计不同步" class="headerlink" title="4.1 问题一：表字段与编码属性设计不同步"></a>4.1 问题一：表字段与编码属性设计不同步</h4><ul>
<li>在模型类属性上方，使用**@TableField**属性注解，通过&#x3D;&#x3D;<strong>value</strong>&#x3D;&#x3D;属性，设置当前属性对应的数据库表中的字段关系。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\1683796001750.png" alt="1683796001750"></p>
<h4 id="4-2-问题二：编码中添加了数据库中未定义的属性"><a href="#4-2-问题二：编码中添加了数据库中未定义的属性" class="headerlink" title="4.2 问题二：编码中添加了数据库中未定义的属性"></a>4.2 问题二：编码中添加了数据库中未定义的属性</h4><ul>
<li>在模型类属性上方，使用**@TableField<strong>注解，通过</strong>&#x3D;&#x3D;exist&#x3D;&#x3D;**属性，设置属性在数据库表字段中是否存在，默认为true。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\exist.png" alt="1683796121907"></p>
<h4 id="4-3-问题三：表名与编码开发设计不同步"><a href="#4-3-问题三：表名与编码开发设计不同步" class="headerlink" title="4.3 问题三：表名与编码开发设计不同步"></a>4.3 问题三：表名与编码开发设计不同步</h4><ul>
<li>在<u><strong>模型类</strong></u>上方，使用**@TableName<strong>注解，通过</strong>&#x3D;&#x3D;value&#x3D;&#x3D;**属性，设置当前类对应的数据库表名称。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\table.png" alt="1683798660359"></p>
<h2 id="四、主键生成策略"><a href="#四、主键生成策略" class="headerlink" title="四、主键生成策略"></a>四、主键生成策略</h2><p>id主键生成的策略有哪几种方式？</p>
<p>不同的表应用不同的id生成策略</p>
<ul>
<li>日志：自增（1,2,3,4，……）</li>
<li>购物订单：特殊规则（FQ23948AK3843）</li>
<li>外卖单：关联地区日期等信息（10 04 20200314 34 91）</li>
<li>关系表：可省略id</li>
<li>……</li>
</ul>
<h3 id="1-id生成策略控制（-TableId注解）"><a href="#1-id生成策略控制（-TableId注解）" class="headerlink" title="1 id生成策略控制（@TableId注解）"></a>1 id生成策略控制（@TableId注解）</h3><p>雪花算法：<code>@TableId(type= IdType.ASSIGN_ID)</code><br><code>ASSIGN_UUID</code>是趋势递增<br>用了<code>分库分表</code>就不能用默认的id自增了 要用雪花算法</p>
<ul>
<li><p>名称：@TableId</p>
</li>
<li><p>类型：<strong>属性注解</strong></p>
</li>
<li><p>位置：模型类中用于表示主键的属性定义上方</p>
</li>
<li><p>作用：设置当前类中主键属性的生成策略</p>
</li>
<li><p>相关属性</p>
<p>​    <strong>type</strong>：设置主键属性的生成策略，值参照IdType枚举值</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801192449901.png" alt="image-20210801192449901"></p>
</li>
</ul>
<h3 id="2-全局策略配置"><a href="#2-全局策略配置" class="headerlink" title="2 全局策略配置"></a>2 全局策略配置</h3><pre><code class="yml">mybatis-plus:
  global-config:
    db-config:
      id-type: assign_id #全局设置主键id策略
      table-prefix: tbl_  #表名前缀设置
</code></pre>
<h5 id="id生成策略全局配置"><a href="#id生成策略全局配置" class="headerlink" title="id生成策略全局配置"></a>id生成策略全局配置</h5><p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801183128266.png" alt="image-20210801183128266"></p>
<h5 id="表名前缀全局配置"><a href="#表名前缀全局配置" class="headerlink" title="表名前缀全局配置"></a>表名前缀全局配置</h5><p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801183157694.png" alt="image-20210801183157694"></p>
<h3 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h3><p>我们可以利用MyBatisPlus的Wrapper来**<u>构造复杂的where条件</u>**，然后自己定义SQL语句中剩下的部分。</p>
<h6 id="将id在指定范围的用户-1-2-4-的余额扣减指定值"><a href="#将id在指定范围的用户-1-2-4-的余额扣减指定值" class="headerlink" title="将id在指定范围的用户(1,2,4)的余额扣减指定值"></a>将id在指定范围的用户(1,2,4)的余额扣减指定值</h6><pre><code class="sql">&lt;update id = &quot;updateBalanceByIds&quot;&gt;
    UPDATE user
    SET balance = balance - #&#123;amount&#125;
    WHERE id IN
    &lt;foreach collection=&quot;ids&quot; separator=&quot;,&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
    #&#123;id&#125;
    &lt;/foreach&gt;
&lt;/update&gt;
</code></pre>
<ul>
<li>基于Wrapper构建where条件</li>
</ul>
<pre><code class="java">// 1.更新条件
  List&lt;Long&gt; ids = List.of(1L, 2L, 4L);
  int amount = 200;
// 2.定义条件
  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().in(User::getId, ids);
// 3.调用自定义SQL方法
  userMapper.updateBalanceByIds(wrapper, amount);
</code></pre>
<ul>
<li>在mapper方法参数中用Param注解声明wrapper变量名称，<strong>必须是ew</strong></li>
</ul>
<pre><code class="java">void updateBalanceByIds(@Param(Constants.WRAPPER) QueryWrapper&lt;User&gt; wrapper, @Param(&quot;amount&quot;) int amount);
</code></pre>
<ul>
<li>自定义SQL，并使用Wrapper条件</li>
</ul>
<pre><code class="xml">&lt;update id=&quot;updateBalanceByIds&quot;&gt;
        update user
        set balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;
    &lt;/update&gt;
</code></pre>
<h3 id="IService接口基本用法"><a href="#IService接口基本用法" class="headerlink" title="IService接口基本用法"></a>IService接口基本用法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/d025a67eaeb98c3eb9725d71e36e36b6516b2b7d/IService%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.jpg" style="zoom:150%;" />

<ul>
<li>自定义Service接口继承IService接口</li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.mp.domain.po.User;

public interface IUserService extends IService&lt;User&gt; &#123;

&#125;
</code></pre>
<ul>
<li>自定义Service实现类，实现自定义接口并继承ServiceImpl类</li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.impl.IUserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;

&#125;
</code></pre>
<ul>
<li>搞了个测试类<code>@Test</code></li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl;

import com.itheima.mp.domain.po.User;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

@SpringBootTest
class IUserServiceTest &#123;
    @Autowired
    private IUserService userService;

    @Test
    void testSaveUser() &#123;
        User user = new User();
        user.setId(5L);
        user.setUsername(&quot;Lucy&quot;);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;18688990011&quot;);
        user.setBalance(200);
        user.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        userService.save(user);
    &#125;
    @Test
    void testQuery()&#123;
        List&lt;User&gt; users = userService.listByIds(Arrays.asList(1L, 2L, 3L));
        users.forEach(System.out::println);
    &#125;

&#125;
</code></pre>
<h3 id="IService开发基础业务接口"><a href="#IService开发基础业务接口" class="headerlink" title="IService开发基础业务接口"></a>IService开发基础业务接口</h3><ul>
<li>基于Restful风格实现下面的接口：<br>飞书文档说明：(<a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc</a>)</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>编号</strong></th>
<th align="left"><strong>接口</strong></th>
<th align="left"><strong>请求方式</strong></th>
<th align="left"><strong>请求路径</strong></th>
<th><strong>请求参数</strong></th>
<th><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">新增用户</td>
<td align="left">POST</td>
<td align="left">&#x2F;users</td>
<td>用户表单实体</td>
<td>无</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">删除用户</td>
<td align="left">DELETE</td>
<td align="left">&#x2F;users&#x2F;{id}</td>
<td>用户id</td>
<td>无</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">根据id查询用户</td>
<td align="left">GET</td>
<td align="left">&#x2F;users&#x2F;{id}</td>
<td>用户id</td>
<td>用户VO</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">根据id批量查询</td>
<td align="left">GET</td>
<td align="left">&#x2F;users</td>
<td>用户id集合</td>
<td>用户VO集合</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">根据id扣减余额</td>
<td align="left">PUT</td>
<td align="left">&#x2F;users&#x2F;{id}&#x2F;deduction&#x2F;{money}</td>
<td>•用户id  •扣减金额</td>
<td>无</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/thinkingandworkinghard/p/10482929.html">解决在IDEA 的Maven下 出现 Cannot access in offline mode 问题 - Doyourself! - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/doc.html">管理接口文档</a></p>
<pre><code class="java">UserController.java
package com.itheima.mp.controller;

import cn.hutool.core.bean.BeanUtil;
import com.itheima.mp.domain.po.User;

import com.itheima.mp.domain.dto.UserFormDTO;

import com.itheima.mp.domain.vo.UserVO;
import com.itheima.mp.service.IUserService;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Api(tags = &quot;用户管理接口&quot;)
@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;users&quot;)
public class UserController &#123;

    private final IUserService userService;

    @PostMapping
    @ApiOperation(&quot;新增用户&quot;)
    public void saveUser(@RequestBody UserFormDTO userFormDTO) &#123;
        // 1.转换DTO为PO
        User user = BeanUtil.copyProperties(userFormDTO, User.class);
        // 2.新增
        userService.save(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;删除用户&quot;)
    public void removeUserById(@PathVariable(&quot;id&quot;) Long userId) &#123;
        userService.removeById(userId);
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询用户&quot;)
    public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long userId) &#123;
        // 1.查询用户
        User user = userService.getById(userId);
        // 2.处理vo
        return BeanUtil.copyProperties(user, UserVO.class);
    &#125;

    @GetMapping
    @ApiOperation(&quot;根据id集合查询用户&quot;)
    public List&lt;UserVO&gt; queryUserByIds(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;
        // 1.查询用户
        List&lt;User&gt; users = userService.listByIds(ids);
        // 2.处理vo
        return BeanUtil.copyToList(users, UserVO.class);
    &#125;

    @PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)
    @ApiOperation(&quot;扣减用户余额&quot;)
    public void deductBalance(@ApiParam(&quot;用户id&quot;) @PathVariable(&quot;id&quot;) Long id, @ApiParam(&quot;扣减的金额&quot;) @PathVariable(&quot;money&quot;) Integer money) &#123;
        userService.deductBalance(id, money);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserFormDTO.java
package com.itheima.mp.domain.dto;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户表单实体&quot;)
public class UserFormDTO &#123;

    @ApiModelProperty(&quot;id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;密码&quot;)
    private String password;

    @ApiModelProperty(&quot;注册手机号&quot;)
    private String phone;

    @ApiModelProperty(&quot;详细信息，JSON风格&quot;)
    private String info;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;
&#125;
</code></pre>
<pre><code class="java">UserQuery.java
package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery &#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.IUserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;
    @Override
    public void deductBalance(Long id, Integer money) &#123;
        // 1.查询用户
        User user = getById(id);
        // 2.判断用户状态
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 3.判断用户余额
        if (user.getBalance() &lt; money) &#123;
            throw new RuntimeException(&quot;用户余额不足&quot;);
        &#125;
        // 4.扣减余额
        baseMapper.deductMoneyById(id, money);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.mp.mapper;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.baomidou.mybatisplus.core.toolkit.Constants;
import com.itheima.mp.domain.po.User;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Update;

import java.util.List;

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;

    List&lt;User&gt; queryUserByIds(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);

    void updateBalanceByIds(@Param(Constants.WRAPPER) QueryWrapper&lt;User&gt; wrapper, @Param(&quot;amount&quot;) int amount);

    @Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)
    void deductMoneyById(Long id, Integer money);
&#125;
</code></pre>
<h3 id="Iservice的Lambda方法"><a href="#Iservice的Lambda方法" class="headerlink" title="Iservice的Lambda方法"></a>Iservice的Lambda方法</h3><h6 id="需求：实现一个根据复杂条件查询用户的接口，查询条件如下："><a href="#需求：实现一个根据复杂条件查询用户的接口，查询条件如下：" class="headerlink" title="需求：实现一个根据复杂条件查询用户的接口，查询条件如下："></a>需求：实现一个根据复杂条件查询用户的接口，查询条件如下：</h6><p><strong>name</strong>：用户名关键字，可以为空<br><strong>status</strong>：用户状态，可以为空<br><strong>minBalance</strong>：最小余额，可以为空<br><strong>maxBalance</strong>：最大余额，可以为空</p>
<pre><code class="mysql">&lt;select id=&quot;queryUsers&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;
    SELECT *
    FROM tb_user
    &lt;where&gt;
        &lt;if test=&quot;name != null&quot;&gt;
            AND username LIKE CONCAT(&#39;%&#39;, #&#123;name&#125;, &#39;%&#39;)
        &lt;/if&gt;
        &lt;if test=&quot;status != null&quot;&gt;
            AND `status` = #&#123;status&#125;
        &lt;/if&gt;
        &lt;if test=&quot;minBalance != null and maxBalance != null&quot;&gt;
            AND balance BETWEEN #&#123;minBalance&#125; AND #&#123;maxBalance&#125;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<h6 id="UserQuery-java"><a href="#UserQuery-java" class="headerlink" title="UserQuery.java"></a>UserQuery.java</h6><pre><code class="java">package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery &#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<h6 id="UserController-java"><a href="#UserController-java" class="headerlink" title="UserController.java"></a>UserController.java</h6><pre><code class="java">    @ApiOperation(&quot;根据复杂条件查询用户接口&quot;)
    @GetMapping(&quot;/list&quot;)
    public List&lt;UserVO&gt; queryUsers(UserQuery query) &#123;
        // 1.查询用户PO
        List&lt;User&gt; users = userService.queryUsers(query.getName(), query.getStatus(), query.getMinBalance(), query.getMaxBalance());
        // 2.把po拷贝到vo
        return BeanUtil.copyToList(users, UserVO.class);
    &#125;
</code></pre>
<h6 id="IUserService-java"><a href="#IUserService-java" class="headerlink" title="IUserService.java"></a>IUserService.java</h6><pre><code class="java">package com.itheima.mp.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.mp.domain.po.User;

import java.util.List;

public interface IUserService extends IService&lt;User&gt; &#123;
    void deductBalance(Long id, Integer money);

    List&lt;User&gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance);
&#125;
</code></pre>
<h6 id="UserServiceImpl-java"><a href="#UserServiceImpl-java" class="headerlink" title="UserServiceImpl.java"></a>UserServiceImpl.java</h6><pre><code class="java">package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.IUserService;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;
   @Override
    public List&lt;User&gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance) &#123;
        return lambdaQuery()
                .like(name!=null, User::getUsername,name)
                .eq(status!=null, User::getStatus,status)
                .gt(minBalance!=null, User::getBalance,minBalance) // 大于
                .lt(maxBalance!=null, User::getBalance,maxBalance) // 小于
                .list();
    &#125;
&#125;
</code></pre>
<h3 id="IService的Lambda更新LambdaUpdate-、LambdaQuery"><a href="#IService的Lambda更新LambdaUpdate-、LambdaQuery" class="headerlink" title="IService的Lambda更新LambdaUpdate()、LambdaQuery()"></a>IService的Lambda更新<del>LambdaUpdate()、LambdaQuery()</del></h3><h6 id="改造根据id修改用户余额的接口，要求如下"><a href="#改造根据id修改用户余额的接口，要求如下" class="headerlink" title="改造根据id修改用户余额的接口，要求如下"></a>改造根据id修改用户余额的接口，要求如下</h6><ul>
<li><p>完成对用户状态校验</p>
</li>
<li><p>完成对用户余额校验</p>
</li>
<li><p>如果扣减后余额为0，则将用户status修改为冻结状态 (2)</p>
<h6 id="UserController-java-1"><a href="#UserController-java-1" class="headerlink" title="UserController.java"></a>UserController.java</h6></li>
</ul>
<pre><code class="java"> @PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)
    @ApiOperation(&quot;扣减用户余额&quot;)
    public void deductBalance(@ApiParam(&quot;用户id&quot;) @PathVariable(&quot;id&quot;) Long id, @ApiParam(&quot;扣减的金额&quot;) @PathVariable(&quot;money&quot;) Integer money) &#123;
        userService.deductBalance(id, money);
    &#125;
</code></pre>
<h6 id="UserServiceImpl-java-1"><a href="#UserServiceImpl-java-1" class="headerlink" title="UserServiceImpl.java"></a>UserServiceImpl.java</h6><pre><code class="java"> @Override
    public void deductBalance(Long id, Integer money) &#123;
        // 1.查询用户
        User user = getById(id);
        // 2.判断用户状态
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 3.判断用户余额
        if (user.getBalance() &lt; money) &#123;
            throw new RuntimeException(&quot;用户余额不足&quot;);
        &#125;
        // 4.扣减余额 update tb_user set balance = balance - ?
        int remainBalance = user.getBalance() - money;
        lambdaUpdate()
                .set(User::getBalance, remainBalance)
                .set(remainBalance == 0,User::getStatus, 2)
                .eq(User::getId, id)
                .eq(User::getBalance, user.getBalance()) // 乐观锁
                .update();
    &#125;
</code></pre>
<h3 id="IService的批量新增"><a href="#IService的批量新增" class="headerlink" title="IService的批量新增"></a>IService的批量新增</h3><h6 id="批量插入10万条用户数据，并作出对比："><a href="#批量插入10万条用户数据，并作出对比：" class="headerlink" title="批量插入10万条用户数据，并作出对比："></a>批量插入10万条用户数据，并作出对比：</h6><ul>
<li>普通for循环插入<del>4分钟</del></li>
<li><strong>IService的批量插入</strong><del>30秒</del></li>
<li>开启<strong>rewriteBatchedStatements&#x3D;true</strong>参数【6秒】<del>重写Statement语句，在application.yaml的sql中url拼接</del></li>
</ul>
<pre><code class="java">Test  com/itheima/mp/service/IUserServiceTest.java
@Test
    void testSaveOneByOne() &#123;
        long b = System.currentTimeMillis();
        for (int i = 1; i &lt;= 100000; i++) &#123;
            userService.save(buildUser(i));
        &#125;
        long e = System.currentTimeMillis();
        System.out.println(&quot;耗时：&quot; + (e - b));
    &#125;

    private User buildUser(int i) &#123;
        User user = new User();
        user.setUsername(&quot;user_&quot; + i);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;&quot; + (18688190000L + i));
        user.setBalance(2000);
        user.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(user.getCreateTime());
        return user;
    &#125;
</code></pre>
<h6 id="MyBatisPlus的批处理"><a href="#MyBatisPlus的批处理" class="headerlink" title="MyBatisPlus的批处理"></a>MyBatisPlus的批处理</h6><pre><code class="java">@Test
void testSaveBatch() &#123;
    // 准备10万条数据
    List&lt;User&gt; list = new ArrayList&lt;&gt;(1000);
    long b = System.currentTimeMillis();
    for (int i = 1; i &lt;= 100000; i++) &#123;
        list.add(buildUser(i));
        // 每1000条批量插入一次
        if (i % 1000 == 0) &#123;
            userService.saveBatch(list);
            list.clear();
        &#125;
    &#125;
    long e = System.currentTimeMillis();
    System.out.println(&quot;耗时：&quot; + (e - b));
&#125;
</code></pre>
<p>可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。</p>
<p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p>
<pre><code class="SQL">Preparing: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? )
Parameters: user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
Parameters: user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
Parameters: user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
</code></pre>
<p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p>
<pre><code class="SQL">INSERT INTO user ( username, password, phone, info, balance, create_time, update_time )
VALUES 
(user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_4, 123, 18688190004, &quot;&quot;, 2000, 2023-07-01, 2023-07-01);
</code></pre>
<p>该怎么做呢？</p>
<p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。参考文档：</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements</a></p>
<p>这个参数的默认值是false，我们需要修改连接参数，将其配置为true</p>
<p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p>
<pre><code class="YAML">spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: MySQL123
</code></pre>
<h3 id="扩展功能-——-代码生成器生成代码的代码"><a href="#扩展功能-——-代码生成器生成代码的代码" class="headerlink" title="扩展功能 —— 代码生成器生成代码的代码"></a>扩展功能 —— 代码生成器<del>生成代码的代码</del></h3><h2 id="3-1-代码生成"><a href="#3-1-代码生成" class="headerlink" title="3.1 代码生成"></a><strong>3.1 代码生成</strong></h2><p>在使用MybatisPlus以后，基础的<code>Mapper</code>、<code>Service</code>、<code>PO</code>代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成<code>PO</code>、<code>Mapper</code>、<code>Service</code>等相关代码。只不过代码生成器同样要编码使用，也很麻烦。</p>
<p>这里推荐大家使用一款<code>MybatisPlus</code>的插件，它可以基于图形化界面完成<code>MybatisPlus</code>的代码生成，非常简单。</p>
<h3 id="3-1-1-安装插件"><a href="#3-1-1-安装插件" class="headerlink" title="3.1.1.安装插件"></a><strong>3.1.1.安装插件</strong></h3><p>在<code>Idea</code>的plugins市场中搜索并安装<code>MyBatisPlus</code>插件：</p>
<p>然后重启你的Idea即可使用。</p>
<h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a><strong>3.1.2.使用</strong></h3><p>刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到<code>other</code>，选择<code>Config Database</code>：</p>
<p>点击OK保存。</p>
<p>然后再次点击Idea顶部菜单中的other，然后选择<code>Code Generator</code>:</p>
<p>在弹出的表单中填写信息：</p>
<p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY1ZmEzNjMxODM4NjkzMjUzZDkxMGY1NDdlZjUzNmRfMjQweXV3NE1lRmpkWGNzcU5pOGxyMW1yaGoxNmtJamZfVG9rZW46WlRqemI4SGVjb080VWp4Sko0ZWNZR2lTbnRoXzE3MzI0MTU0NDQ6MTczMjQxOTA0NF9WNA" alt="img"></p>
<p>最终，代码自动生成到指定的位置了：</p>
<h3 id="扩展功能-——-DB静态工具两个Service相互注入"><a href="#扩展功能-——-DB静态工具两个Service相互注入" class="headerlink" title="扩展功能 —— DB静态工具两个Service相互注入"></a>扩展功能 —— DB静态工具<del>两个Service相互注入</del></h3><ul>
<li>改造根据id查询用户的接口，查询用户的同时<del>user表</del>，查询出用户对应的所有地址<del>address表</del></li>
<li>改造根据id批量查询用户的接口，查询用户的同时，查询出用户对应的所有地址</li>
<li>实现根据用户id查询收货地址功能，需要验证用户状态，冻结用户抛出异常(练习)</li>
</ul>
<h2 id="3-2-静态工具"><a href="#3-2-静态工具" class="headerlink" title="3.2.静态工具"></a><strong>3.2.静态工具</strong></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/76848ff08a98edaf6d5d07285cd76e50f42e7c5b/DB%E9%9D%99%E6%80%81%E5%B7%A5%E5%85%B7.jpg"></p>
<p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：</p>
<pre><code class="java">UserController.java
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询用户&quot;)
    public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long id) &#123;
        // 1.查询用户
//        User user = userService.getById(userId);
        // 2.处理vo
        return userService.queryUserAndAddressById(id);
    &#125;
</code></pre>
<pre><code class="java">IUserService.java
public interface IUserService extends IService&lt;User&gt; &#123;
    UserVO queryUserAndAddressById(Long id);
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public UserVO queryUserAndAddressById(Long id) &#123;
        // 1.查询用户
        User user = getById(id);
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 2.查询方法
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)
                .eq(Address::getUserId, id).list();
        // 3.封装VO
        // 3.1 转User的PO为VO
        UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
        if (CollUtil.isEmpty(addresses)) &#123;
           userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));
        &#125;
        return userVO;
    &#125;
</code></pre>
<h3 id="扩展功能—DB静态工具-练习"><a href="#扩展功能—DB静态工具-练习" class="headerlink" title="扩展功能—DB静态工具(练习)"></a>扩展功能—DB静态工具(练习)</h3><pre><code class="java">UserController.java
@GetMapping
    @ApiOperation(&quot;根据id集合查询用户&quot;)
    public List&lt;UserVO&gt; queryUserByIds(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;
        // 1.查询用户
//        List&lt;User&gt; users = userService.listByIds(ids);
        // 2.处理vo
        return userService.queryUserAndAddressByIds(ids);
    &#125;
</code></pre>
<pre><code class="java">IUserService.java
public interface IUserService extends IService&lt;User&gt; &#123;
    List&lt;UserVO&gt; queryUserAndAddressByIds(List&lt;Long&gt; ids);
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public List&lt;UserVO&gt; queryUserAndAddressByIds(List&lt;Long&gt; ids) &#123;
        // 1.查询用户
        List&lt;User&gt; users = listByIds(ids);
        if (CollUtil.isEmpty(users)) &#123;
            return Collections.emptyList();
        &#125;
        // 2.查询地址
        // 2.1 获取用户id集合
        List&lt;Long&gt; userIds = users.stream().map(User::getId).collect(Collectors.toList());
        // 2.2 根据用户id查询地址 这是全部地址
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class).in(Address::getUserId, userIds).list();
        // 2.3 转换地址VO
        List&lt;AddressVO&gt; addressVOList = BeanUtil.copyToList(addresses, AddressVO.class);
        // 2.4 梳理地址集合分组处理，分类整理，相同用户放入一个集合(组)中
        Map&lt;Long, List&lt;AddressVO&gt;&gt; addressMap = new HashMap&lt;&gt;(0);
        if (CollUtil.isNotEmpty(addressVOList))&#123;
            addressMap = addressVOList.stream().collect(Collectors.groupingBy(AddressVO::getUserId));
        &#125;
        // 3.转换VO返回
        List&lt;UserVO&gt; list = new ArrayList&lt;&gt;(users.size());
        for (User user : users) &#123;
            // 3.1 转换User的Po为VO
            UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
            list.add(userVO);

            // 3.2 转换地址VO
            userVO.setAddresses(addressMap.get(user.getId()));
        &#125;
        return null;
    &#125;
</code></pre>
<h3 id="扩展功能—逻辑删除要在数据库里面创建一个deleted表"><a href="#扩展功能—逻辑删除要在数据库里面创建一个deleted表" class="headerlink" title="扩展功能—逻辑删除要在数据库里面创建一个deleted表"></a>扩展功能—逻辑删除<del>要在数据库里面创建一个deleted表</del></h3><h6 id="订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息"><a href="#订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息" class="headerlink" title="订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息"></a>订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息</h6><p><strong>逻辑删除</strong>就是基于代码逻辑模拟删除效果，但并不会真正删除数据。思路如下：</p>
<ul>
<li>在表中添加一个字段标记数据是否被删除</li>
<li>当删除数据时把标记置为1</li>
<li>查询时只查询标记为0的数据</li>
</ul>
<p>例如逻辑删除字段为deleted：</p>
<p>• 删除操作：</p>
<pre><code class="mysql"># 是0才删除 是1就不用删除 所以用AND
UPDATE user SET deleted = 1 WHERE id = 1 AND deleted = 0
</code></pre>
<p>• 查询操作：</p>
<pre><code class="mysql"># 查询未删除的数据
SELECT * FROM user WHERE deleted = 0
</code></pre>
<h5 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h5><p><strong>MybatisPlus</strong>提供了逻辑删除功能，无需改变方法调用的方式，而是在底层帮我们自动修改CRUD的语句。我们要做的就是在application.yaml文件中配置逻辑删除的字段名称和值即可：</p>
<pre><code class="yaml">mybatis-plus: 
  global-config:    
   db-config:
    logic-delete-field: flag # 全局逻辑删除的实体字段名，字段类型可以是boolean、integer
    logic-delete-value: 1 # 逻辑已删除值(默认为 1)
    logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
</code></pre>
<h6 id="逻辑删除本身也有自己的问题，比如："><a href="#逻辑删除本身也有自己的问题，比如：" class="headerlink" title="逻辑删除本身也有自己的问题，比如："></a>逻辑删除本身也有自己的问题，比如：</h6><p>• 会导致数据库表垃圾数据越来越多，影响查询效率<br>• SQL中全都需要对逻辑删除字段做判断，影响查询效率</p>
<p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。</p>
<h3 id="扩展功能—枚举处理器"><a href="#扩展功能—枚举处理器" class="headerlink" title="扩展功能—枚举处理器"></a>扩展功能—枚举处理器</h3><p>像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p>
<p>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p>
<h3 id="3-3-1-定义枚举"><a href="#3-3-1-定义枚举" class="headerlink" title="3.3.1.定义枚举"></a><strong>3.3.1.定义枚举</strong></h3><p>我们定义一个用户状态的枚举：</p>
<pre><code class="java">User.java //使用枚举类型
// 使用状态(1正常 2冻结)
private UserStatus status;
</code></pre>
<p>要让<code>MybatisPlus</code>处理枚举与数据库类型自动转换，我们必须告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值。 <code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性：</p>
<pre><code class="java">package com.itheima.mp.enums;

import com.baomidou.mybatisplus.annotation.EnumValue;
import lombok.Getter;

@Getter
public enum UserStatus &#123;
    NORMAL(1, &quot;正常&quot;),
    FREEZE(2, &quot;冻结&quot;)
    ;
    @EnumValue
    private final int value;
    private final String desc;

    UserStatus(int value, String desc) &#123;
        this.value = value;
        this.desc = desc;
    &#125;
&#125;
</code></pre>
<h3 id="3-3-2-配置枚举处理器MP增加了Enum和JSON处理器"><a href="#3-3-2-配置枚举处理器MP增加了Enum和JSON处理器" class="headerlink" title="3.3.2.配置枚举处理器MP增加了Enum和JSON处理器"></a>3.3.2.配置枚举处理器<del>MP增加了Enum和JSON处理器</del></h3><p>在application.yaml文件中添加配置：</p>
<pre><code class="YAML">mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
</code></pre>
<pre><code class="java">UserVO.java
package com.itheima.mp.domain.vo;

import com.itheima.mp.enums.UserStatus;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.util.List;

@Data
@ApiModel(description = &quot;用户VO实体&quot;)
public class UserVO &#123;

    @ApiModelProperty(&quot;用户id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;详细信息&quot;)
    private String info;

    @ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)
    private UserStatus status;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;

    @ApiModelProperty(&quot;用户的收货地址&quot;)
    private List&lt;AddressVO&gt; addresses;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
 @Override
    public UserVO queryUserAndAddressById(Long id) &#123;
        // 1.查询用户
        User user = getById(id);
        if (user == null || user.getStatus() == UserStatus.FREEZE) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 2.查询方法
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)
                .eq(Address::getUserId, id).list();
        // 3.封装VO
        // 3.1 转User的PO为VO
        UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
        if (CollUtil.isEmpty(addresses)) &#123;
           userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));
        &#125;
        return userVO;
    &#125;
</code></pre>
<h6 id="想要前端返回正常还是冻结-JsonValue"><a href="#想要前端返回正常还是冻结-JsonValue" class="headerlink" title="想要前端返回正常还是冻结  @JsonValue"></a>想要前端返回正常还是冻结 <code> @JsonValue</code></h6><pre><code class="java">package com.itheima.mp.enums;

import com.baomidou.mybatisplus.annotation.EnumValue;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonValue;
import lombok.Getter;

@Getter
public enum UserStatus &#123;
    NORMAL(1, &quot;正常&quot;),
    FREEZE(2, &quot;冻结&quot;)
    ;
    @EnumValue
    private final int value;
    @JsonValue
    private final String desc;

    UserStatus(int value, String desc) &#123;
        this.value = value;
        this.desc = desc;
    &#125;
&#125;
</code></pre>
<h3 id="扩展功能—JSON处理器AbstractJsonTypeHandler"><a href="#扩展功能—JSON处理器AbstractJsonTypeHandler" class="headerlink" title="扩展功能—JSON处理器AbstractJsonTypeHandler"></a>扩展功能—JSON处理器<del>AbstractJsonTypeHandler</del></h3><p>数据库中user表中有一个json类型的字段</p>
<blockquote>
<p><strong>名称   数据类型      注释</strong><br>info    JSON            详细信息<br>。。。。。。。。。。。。</p>
<p>JSON：<br>{ “age”:20,<br>“intro”: “”青年”,<br>“gender”:”male”}</p>
</blockquote>
<p>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。</p>
<p>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p>
<p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p>
<h6 id="接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器："><a href="#接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：" class="headerlink" title="接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器："></a>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：</h6><p><code>@TableField(typeHandler = JacksonTypeHandler.class)</code> 定义类型处理器<br><code>@TableName(value = &quot;user&quot;, autoResultMap = true)</code></p>
<pre><code class="java">User.java
@Data
@TableName(value = &quot;user&quot;, autoResultMap = true)
public class User &#123;

    /**
     * 用户id
     */
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Long id;

    /**
     * 用户名
     */
    private String username;

    /**
     * 详细信息
     */
    @TableField(typeHandler = JacksonTypeHandler.class)
    private UserInfo info;
&#125;
</code></pre>
<pre><code class="java">UserVO.java
package com.itheima.mp.domain.vo;

import com.itheima.mp.domain.po.UserInfo;
import com.itheima.mp.enums.UserStatus;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.util.List;

@Data
@ApiModel(description = &quot;用户VO实体&quot;)
public class UserVO &#123;

    @ApiModelProperty(&quot;用户id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;详细信息&quot;)
    private UserInfo info;

    @ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)
    private UserStatus status;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;

    @ApiModelProperty(&quot;用户的收货地址&quot;)
    private List&lt;AddressVO&gt; addresses;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.mp.domain.po;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor(staticName = &quot;of&quot;)
public class UserInfo &#123;
    private Integer age;
    private String intro;
    private String gender;
    // 添加静态方法 of
    public static UserInfo of(Integer age, String intro, String gender) &#123;
        return new UserInfo(age, intro, gender);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserMapperTest.java
@SpringBootTest
class UserMapperTest &#123;

    @Autowired
    private UserMapper userMapper;

    @Test
    void testInsert() &#123;
        User user = new User();
        user.setId(5L);
        user.setUsername(&quot;Lucy&quot;);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;18688990011&quot;);
        user.setBalance(200);
        user.setInfo(UserInfo.of(14, &quot;英文老师&quot;, &quot;female&quot;));
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        userMapper.insert(user);
    &#125;
</code></pre>
<h3 id="插件功能—分页插件基本用法"><a href="#插件功能—分页插件基本用法" class="headerlink" title="插件功能—分页插件基本用法"></a>插件功能—分页插件基本用法</h3><p>MyBatisPlus提供的内置拦截器有下面这些：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>拦截器</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TenantLineInnerInterceptor</td>
<td>多租户插件</td>
</tr>
<tr>
<td>2</td>
<td>DynamicTableNameInnerInterceptor</td>
<td>动态表名插件</td>
</tr>
<tr>
<td>3</td>
<td>PaginationInnerInterceptor</td>
<td>分页插件</td>
</tr>
<tr>
<td>4</td>
<td>OptimisticLockerInnerInterceptor</td>
<td>乐观锁插件</td>
</tr>
<tr>
<td>5</td>
<td>IllegalSQLInnerInterceptor</td>
<td>SQL性能规范插件，检测并拦截垃圾SQL</td>
</tr>
<tr>
<td>6</td>
<td>BlockAttackInnerInterceptor</td>
<td>防止全表更新和删除的插件</td>
</tr>
</tbody></table>
<h6 id="首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】"><a href="#首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】" class="headerlink" title="首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】"></a>首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】</h6><pre><code class="java">@Configuration
public class MybatisConfig &#123;

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;
        // 1. 初始化核心插件
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 2. 添加分页插件
        PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);
        pageInterceptor.setMaxLimit(1000L); // 设置分页上限
        interceptor.addInnerInterceptor(pageInterceptor);
        return interceptor;
    &#125;
&#125;
</code></pre>
<h6 id="接着，就可以使用分页的API了：-IService里面就有"><a href="#接着，就可以使用分页的API了：-IService里面就有" class="headerlink" title="接着，就可以使用分页的API了：[IService里面就有]"></a>接着，就可以使用分页的API了：[IService里面就有]</h6><pre><code class="java">@Test
    void testPageQuery() &#123;
        // 1. 查询
        int pageNo = 1, pageSize = 5;
        // 1.1. 分页参数
        Page&lt;User&gt; page = Page.of(pageNo, pageSize);
        // 1.2. 排序参数, 通过OrderItem来指定
        page.addOrder(new OrderItem(&quot;balance&quot;, true));
        // 先按balance排序 再按id排序
        page.addOrder(new OrderItem(&quot;id&quot;, true));
        // 1.3. 分页查询
        Page&lt;User&gt; p = userService.page(page);
        // 2. 总条数
        System.out.println(&quot;total = &quot; + p.getTotal());
        // 3. 总页数
        System.out.println(&quot;pages = &quot; + p.getPages());
        // 4. 分页数据
        List&lt;User&gt; records = p.getRecords();
        records.forEach(System.out::println);
    &#125;
</code></pre>
<h3 id="插件功能—通用分页实体"><a href="#插件功能—通用分页实体" class="headerlink" title="插件功能—通用分页实体"></a>插件功能—通用分页实体</h3><h6 id="遵循下面的接口规范，编写一个UserController接口，实现User的分页查询"><a href="#遵循下面的接口规范，编写一个UserController接口，实现User的分页查询" class="headerlink" title="遵循下面的接口规范，编写一个UserController接口，实现User的分页查询"></a>遵循下面的接口规范，编写一个UserController接口，实现User的分页查询</h6><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>请求方式</td>
<td>GET</td>
</tr>
<tr>
<td>请求路径</td>
<td>&#x2F;users&#x2F;page</td>
</tr>
<tr>
<td>请求参数</td>
<td>“pageNo”: 1<br/>“pageSize”: 5<br/>“sortBy”: “balance”<br/>“isAsc”: false<br/>“name”: “jack”<br/>“status”: 1</td>
</tr>
<tr>
<td>返回值</td>
<td>“total”: 1005<br/>“pages”: 201<br/>“list”: 包含两个元素的数组，每个元素都是一个对象，包含以下键值对：<br/>“id”: 1 或 2<br/>“username”: “Jack” 或 “Rose”<br/>“info”: 包含以下键值对的对象：<br/>“age”: 21 或 20<br/>“gender”: “male” 或 “female”<br/>“intro”: “佛系青年” 或 “文艺青年”<br/>“status”: “正常” 或 “冻结”<br/>“balance”: 2000 或 1000</td>
</tr>
<tr>
<td>特殊说明</td>
<td>如果排序字段为空，默认按照更新时间排序  •排序字段不为空，则按照排序字段排序</td>
</tr>
</tbody></table>
<h6 id="准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】"><a href="#准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】" class="headerlink" title="准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】"></a>准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】</h6><p><code>写一个 【统一的分页条件】 和 【统一的分页结果】</code></p>
<pre><code class="java">com/itheima/mp/domain/query/UserQuery.java
// 要记得继承哦
package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery extends PageQuery&#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/query/PageQuery.java
package com.itheima.mp.domain.query;

import com.baomidou.mybatisplus.core.metadata.OrderItem;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;分页查询实体&quot;)
public class PageQuery &#123;
    @ApiModelProperty(&quot;页码&quot;)
    private Integer pageNo;
    @ApiModelProperty(&quot;页码个数&quot;)
    private Integer pageSize;
    @ApiModelProperty(&quot;排序字段&quot;)
    private String sortBy;
    @ApiModelProperty(&quot;是否升序&quot;)
    private Boolean isAsc;

    public &lt;T&gt;  Page&lt;T&gt; toMpPage(OrderItem ... orders)&#123;
        // 1.分页条件
        Page&lt;T&gt; p = Page.of(pageNo, pageSize);
        // 2.排序条件
        // 2.1.先看前端有没有传排序字段
        if (sortBy != null) &#123;
            p.addOrder(new OrderItem(sortBy, isAsc));
            return p;
        &#125;
        // 2.2.再看有没有手动指定排序字段
        if(orders != null)&#123;
            p.addOrder(orders);
        &#125;
        return p;
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPage(String defaultSortBy, boolean isAsc)&#123;
        return this.toMpPage(new OrderItem(defaultSortBy, isAsc));
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByCreateTimeDesc() &#123;
        return toMpPage(&quot;create_time&quot;, false);
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByUpdateTimeDesc() &#123;
        return toMpPage(&quot;update_time&quot;, false);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/dto/PageDTO.java
package com.itheima.mp.domain.dto;

import cn.hutool.core.bean.BeanUtil;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

@Data
@ApiModel(description = &quot;分页结果&quot;)
@NoArgsConstructor
@AllArgsConstructor
public class PageDTO&lt;V&gt; &#123;
    @ApiModelProperty(&quot;总条数&quot;)
    private Long total;
    @ApiModelProperty(&quot;总页数&quot;)
    private Long pages;
    @ApiModelProperty(&quot;集合&quot;)
    private List&lt;V&gt; list;

    /**
     * 返回空分页结果
     * @param p MybatisPlus的分页结果
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; empty(Page&lt;P&gt; p)&#123;
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果
     * @param p MybatisPlus的分页结果
     * @param voClass 目标VO类型的字节码
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Class&lt;V&gt; voClass) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式
     * @param p MybatisPlus的分页结果
     * @param convertor PO到VO的转换函数
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">com/itheima/mp/controller/UserController.java
@ApiOperation(&quot;根据复杂条件查询用户接口&quot;)
    @GetMapping(&quot;/list&quot;)
    public List&lt;UserVO&gt; queryUsers(UserQuery query) &#123;
        return (List&lt;UserVO&gt;) userService.queryUsersPage(query);
    &#125;
</code></pre>
<pre><code class="java">// 如果你想在字符串中表示一个大于号，
你可以直接输入 &gt;，或者使用HTML实体 &amp;gt; 
小于号可以使用 &lt; 或者 &amp;lt;，
等于号可以使用 = 或者 &amp;equals
</code></pre>
<h3 id="插件功能—通用分页实体与MP转换"><a href="#插件功能—通用分页实体与MP转换" class="headerlink" title="插件功能—通用分页实体与MP转换"></a>插件功能—通用分页实体与MP转换</h3><p>需求：</p>
<ul>
<li>在PageQuery中定义方法，将PageQuery对象转为MyBatisPlus中的Page对象</li>
<li>在PageDTO中定义方法，将MyBatisPlus中的Page结果转为PageDTO结果</li>
</ul>
<h6 id="最好直接封装通用部分"><a href="#最好直接封装通用部分" class="headerlink" title="最好直接封装通用部分"></a>最好直接封装通用部分</h6><h5 id="封装查询"><a href="#封装查询" class="headerlink" title="封装查询"></a>封装查询</h5><pre><code class="java"> @Override
    public PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query) &#123;
        String name = query.getName();
        Integer status = query.getStatus();
        // 1.构建查询条件
        // 1.1 分页条件
        Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());
        // 1.2 排序条件
        if (StrUtil.isNotBlank(query.getSortBy())) &#123;
            // 不为空
            page.addOrder(new OrderItem(query.getSortBy(), query.getIsAsc()));
        &#125;else &#123;
            // 为空，默认按照更新时间排序
            page.addOrder(new OrderItem(&quot;update_time&quot;, false));
        &#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/query/PageQuery.java
package com.itheima.mp.domain.query;

import com.baomidou.mybatisplus.core.metadata.OrderItem;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;分页查询实体&quot;)
public class PageQuery &#123;
    @ApiModelProperty(&quot;页码&quot;)
    private Integer pageNo;
    @ApiModelProperty(&quot;页码个数&quot;)
    private Integer pageSize;
    @ApiModelProperty(&quot;排序字段&quot;)
    private String sortBy;
    @ApiModelProperty(&quot;是否升序&quot;)
    private Boolean isAsc;

    public &lt;T&gt;  Page&lt;T&gt; toMpPage(OrderItem ... orders)&#123;
        // 1.分页条件
        Page&lt;T&gt; p = Page.of(pageNo, pageSize);
        // 2.排序条件
        // 2.1.先看前端有没有传排序字段
        if (sortBy != null) &#123;
            p.addOrder(new OrderItem(sortBy, isAsc));
            return p;
        &#125;
        // 2.2.再看有没有手动指定排序字段
        if(orders != null)&#123;
            p.addOrder(orders);
        &#125;
        return p;
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPage(String defaultSortBy, boolean isAsc)&#123;
        return this.toMpPage(new OrderItem(defaultSortBy, isAsc));
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByCreateTimeDesc() &#123;
        return toMpPage(&quot;create_time&quot;, false);
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByUpdateTimeDesc() &#123;
        return toMpPage(&quot;update_time&quot;, false);
    &#125;
&#125;
</code></pre>
<h5 id="封装结果"><a href="#封装结果" class="headerlink" title="封装结果"></a>封装结果</h5><pre><code class="java">// 3.封装VO结果
        PageDTO&lt;UserVO&gt; dto = new PageDTO&lt;&gt;();
        // 3.1 总条数
        dto.setTotal(p.getTotal());
        // 3.2 总页数
        dto.setPages(p.getPages());
        // 3.3 当前页数据
        List&lt;User&gt; records = p.getRecords();
        if (CollUtil.isEmpty(records)) &#123;
            dto.setList(Collections.emptyList());
            return dto;
        &#125;
        // 3.4 拷贝user的VO
        dto.setList(BeanUtil.copyToList(records, UserVO.class));
        // 4.返回
        return dto;
    &#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/dto/PageDTO.java
package com.itheima.mp.domain.dto;

import cn.hutool.core.bean.BeanUtil;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

@Data
@ApiModel(description = &quot;分页结果&quot;)
@NoArgsConstructor
@AllArgsConstructor
public class PageDTO&lt;V&gt; &#123;
    @ApiModelProperty(&quot;总条数&quot;)
    private Long total;
    @ApiModelProperty(&quot;总页数&quot;)
    private Long pages;
    @ApiModelProperty(&quot;集合&quot;)
    private List&lt;V&gt; list;

    /**
     * 返回空分页结果
     * @param p MybatisPlus的分页结果
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; empty(Page&lt;P&gt; p)&#123;
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果
     * @param p MybatisPlus的分页结果
     * @param voClass 目标VO类型的字节码
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Class&lt;V&gt; voClass) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式
     * @param p MybatisPlus的分页结果
     * @param convertor PO到VO的转换函数
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query) &#123;
        String name = query.getName();
        Integer status = query.getStatus();
        // 1.构建查询条件
        // 1.1 分页条件
        Page&lt;User&gt; page = query.toMpPageDefaultSortByUpdateTimeDesc();
        // 2. 分页查询
        Page&lt;User&gt; p = lambdaQuery()
                .like(name != null, User::getUsername, name)
                .eq(status != null, User::getStatus, status)
                .page(page);
        // 3. 封装VO结果
//        return PageDTO.of(p, UserVO.class); 属性转换 ↓
        return PageDTO.of(p, user -&gt; &#123;
            // 1.拷贝基础属性
            UserVO vo = BeanUtil.copyProperties(user, UserVO.class);
            // 2.处理特殊逻辑 密码加**
            vo.setUsername(vo.getUsername().substring(0, vo.getUsername().length()-2)+&quot;**&quot;);
            return vo;
        &#125;);
    &#125;
</code></pre>
<hr>
<hr>
<hr>
<h3 id="tilas-all-成功案例"><a href="#tilas-all-成功案例" class="headerlink" title="tilas-all 成功案例"></a>tilas-all 成功案例</h3><pre><code class="java">package com.itheima.domain.dto;

import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class GenderStatisticsDTO &#123;
    private String name;
    private Integer value;

&#125;
==================================================
package com.itheima.domain.dto;

import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName(&quot;emp&quot;)
public class JobStatisticsDTO &#123;
    private List&lt;String&gt; jobList;
    private List&lt;Long&gt; dataList;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.domain.dto.CombinedStatisticsDTO;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.pojo.Emp;

import java.util.List;

public interface ReportService extends IService&lt;Emp&gt; &#123;
    List&lt;GenderStatisticsDTO&gt; getGenderStatistics(); // 获取性别统计信息
    JobStatisticsDTO getJobStatistics(); // 获取职位统计信息
&#125;


//    CombinedStatisticsDTO getCombinedStatistics();
</code></pre>
<pre><code class="java">com/itheima/controller/ReportController.java
package com.itheima.controller;

import com.itheima.domain.dto.CombinedStatisticsDTO;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.pojo.Result;
import com.itheima.service.ReportService;
import io.swagger.annotations.Api;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@Api(tags = &quot;报表统计接口&quot;)
@RestController
@RequestMapping(&quot;/report&quot;)
@RequiredArgsConstructor
public class ReportController &#123;

    private final ReportService reportService;

    // 获取合并后的统计信息
//    @GetMapping(&quot;/statistics&quot;)
//    public Result&lt;CombinedStatisticsDTO&gt; getStatistics() &#123;
//        CombinedStatisticsDTO combinedStatistics = reportService.getCombinedStatistics();
//        return Result.success(combinedStatistics);
//    &#125;

    // 获取员工性别统计信息
    @GetMapping(&quot;/empGenderData&quot;)
    public Result&lt;List&lt;GenderStatisticsDTO&gt;&gt; getEmployeeGenderStatistics() &#123;
        List&lt;GenderStatisticsDTO&gt; genderStatistics = reportService.getGenderStatistics();
        return Result.success(genderStatistics);
    &#125;

    // 获取员工职位统计信息
    @GetMapping(&quot;/empJobData&quot;)
    public Result&lt;JobStatisticsDTO&gt; getEmployeeJobStatistics() &#123;
        JobStatisticsDTO jobStatistics = reportService.getJobStatistics();
        return Result.success(jobStatistics);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/service/impl/ReportServiceImpl.java
package com.itheima.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.mapper.ReportMapper;
import com.itheima.pojo.Emp;
import com.itheima.service.ReportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class ReportServiceImpl extends ServiceImpl&lt;ReportMapper, Emp&gt; implements ReportService &#123;

    private final ReportMapper reportMapper;

    @Autowired
    public ReportServiceImpl(ReportMapper reportMapper) &#123;
        this.reportMapper = reportMapper;
    &#125;

    // 获取员工职位统计信息
    @Override
    public JobStatisticsDTO getJobStatistics() &#123;
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();

        // 修改查询字段，注意这里你仍然需要写正确的字段名
        wrapper.select(&quot;CASE job WHEN 1 THEN &#39;班主任&#39; WHEN 2 THEN &#39;讲师&#39; WHEN 3 THEN &#39;学工主管&#39; WHEN 4 THEN &#39;校研主管&#39; WHEN 5 THEN &#39;咨询师&#39; ELSE &#39;其他&#39; END AS 职位&quot;,
                        &quot;COUNT(*) AS 数量&quot;)
                .groupBy(&quot;job&quot;);

        // 通过 selectMaps 执行查询
        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 创建两个列表来存储职位和数量
        List&lt;String&gt; jobTitles = new ArrayList&lt;&gt;();
        List&lt;Long&gt; counts = new ArrayList&lt;&gt;();

        // 遍历查询结果并填充列表
        for (Map&lt;String, Object&gt; stat : statistics) &#123;
            jobTitles.add((String) stat.get(&quot;职位&quot;));
            counts.add((Long) stat.get(&quot;数量&quot;));
        &#125;

        // 返回JobStatisticsDTO对象，传入两个列表
        return new JobStatisticsDTO(jobTitles, counts);
    &#125;

    // 获取员工性别统计信息
    @Override
    public List&lt;GenderStatisticsDTO&gt; getGenderStatistics() &#123;
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.select(&quot;gender&quot;, &quot;COUNT(gender) AS value&quot;)
                .groupBy(&quot;gender&quot;);

        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 转换为 GenderStatisticsDTO
        return statistics.stream()
                .map(stat -&gt; &#123;
                    String genderName = &quot;1&quot;.equals(String.valueOf(stat.get(&quot;gender&quot;))) ? &quot;男性员工&quot; : &quot;女性员工&quot;;
                    int count = ((Number) stat.get(&quot;value&quot;)).intValue();
                    return new GenderStatisticsDTO(genderName, count);
                &#125;)
                .collect(Collectors.toList());
    &#125;
&#125;
</code></pre>
<h6 id="上面的获取员工职位属性已修改为高级版本"><a href="#上面的获取员工职位属性已修改为高级版本" class="headerlink" title="上面的获取员工职位属性已修改为高级版本"></a>上面的获取员工职位属性已修改为高级版本</h6><pre><code class="java">// 获取员工职位统计信息
    @Override
    public JobStatisticsDTO getJobStatistics() &#123;
        // 1. 构建查询条件
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.select(&quot;job&quot;, &quot;COUNT(*) AS count&quot;)
                .groupBy(&quot;job&quot;);

        // 2. 查询数据
        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 如果返回结果为 null 或为空列表，返回默认对象
        if (statistics == null || statistics.isEmpty()) &#123;
            return new JobStatisticsDTO(new ArrayList&lt;&gt;(), new ArrayList&lt;&gt;());
        &#125;

        // 3. 转换结果：处理 `null` 值和字段映射
        List&lt;String&gt; jobTitles = new ArrayList&lt;&gt;();
        List&lt;Long&gt; counts = new ArrayList&lt;&gt;();

        for (Map&lt;String, Object&gt; stat : statistics) &#123;
            if (stat == null) &#123;
                continue; // 跳过 null 数据
            &#125;

            // 使用 `getOrDefault` 方法，确保不会返回 null
            Integer jobCode = (Integer) stat.getOrDefault(&quot;job&quot;, -1);
            Long count = stat.get(&quot;count&quot;) == null ? 0L : ((Number) stat.get(&quot;count&quot;)).longValue();

            // 如果 jobCode 是 -1 或其他无效值，则视为“其他”
            String jobTitle = switch (jobCode) &#123;
                case 1 -&gt; &quot;班主任&quot;;
                case 2 -&gt; &quot;讲师&quot;;
                case 3 -&gt; &quot;学工主管&quot;;
                case 4 -&gt; &quot;校研主管&quot;;
                case 5 -&gt; &quot;咨询师&quot;;
                default -&gt; &quot;其他&quot;;
            &#125;;

            jobTitles.add(jobTitle);
            counts.add(count);
        &#125;

        // 返回封装好的 DTO 对象
        return new JobStatisticsDTO(jobTitles, counts);
    &#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/23/后端/MyBatisPlus/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/22/后端/Stream模板+Lambda常用+@注释+常用方法模板集合/">
        <h2>
            Stream模板+Lambda常用+@注释+常用方法模板集合
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/22
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Stream模板"><a href="#Stream模板" class="headerlink" title="Stream模板"></a>Stream模板</h1><h6 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h6><p>中间方法的特点惰性求值：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。可以链式调用：多个中间操作可以链接在一起，形成一个操作链。返回类型：所有的中间操作返回的都是一个 Stream 对象。</p>
<h6 id="Stream中间代码"><a href="#Stream中间代码" class="headerlink" title="Stream中间代码"></a>Stream中间代码</h6><pre><code class="java">功能：过滤流中的元素，仅保留满足给定条件的元素。
// 示例：
Stream.of(1, 2, 3, 4, 5)
      .filter(n -&gt; n % 2 == 0) // 只保留偶数
      .forEach(System.out::println);//打印功能：将流中的元素映射为其他形式（通常是不同类型）。
// 示例：
Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。示例：Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);功能：去除流中的重复元素。示例：Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4功能：对流中的元素进行排序。示例：Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);功能：截取流中的前 maxSize 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);功能：跳过流中的前 n 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5下面是一个示例，展示了多种中间方法的使用：import java.util.Arrays;
import java.util.List;
</code></pre>
<details class="lake-collapse"><summary id="u41427c34"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 16px">中间方法：</span></strong></summary><ol class="ne-ol"><li id="ue6d895fe" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">中间方法的特点<br /></span></strong><a href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">惰性求值</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">可以</span></strong><a href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">链式调用</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：多个中间操作可以链接在一起，形成一个操作链。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">返回类型：所有的中间操作返回的都是一个 Stream 对象。</span></strong></li></ol></details>
<details class="lake-collapse"><summary id="ueec7bf3e"><strong><span class="ne-text" style="color: #DF2A3F">stream中间操作</span></strong></summary><p id="u9155c15c" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：过滤流中的元素，仅保留满足给定条件的元素。</span></strong></p><p id="ue9508648" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oyHwt" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
.filter(n -&gt; n % 2 == 0) // 只保留偶数
.forEach(System.out::println);//打印</code></pre><p id="u7087b579" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素映射为其他形式（通常是不同类型）。</span></strong></p><p id="uec5be4e7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="rVrS1" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写</code></pre><p id="ufc5f99d4" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。</span></strong></p><p id="ub40cb3ec" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="NUaVI" class="ne-codeblock language-java"><code>Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);</code></pre><p id="u9bb719ff" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F">功能：去除流中的重复元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="Q888J" class="ne-codeblock language-java"><code>Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4</code></pre><p id="u18f09612" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">功能：对流中的元素进行排序。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">示例：</span></strong></p><pre data-language="java" id="JLF00" class="ne-codeblock language-java"><code>Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);</code></pre><p id="ue50c0c95" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：截取流中的前 maxSize 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="OdjlP" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);</code></pre><p id="u5c024d35" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：跳过流中的前 n 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="fN4RR" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5</code></pre><p id="u05623b28" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种中间方法的使用：</span></strong></p><pre data-language="java" id="wLvBv" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
public class StreamIntermediateOperations &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;, &quot;Eve&quot;);

<pre><code>    // 使用中间方法
    names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;)) // 过滤以 &#39;A&#39; 开头的名字
        .map(String::toUpperCase) // 将名字转换为大写
        .sorted() // 排序
        .forEach(System.out::println); // 输出结果
&#125;
</code></pre>
<p>}</code></pre><p id="ud6df2a51" class="ne-p"><br></p></details></p>
<details class="lake-collapse"><summary id="u8303321d"><strong><span class="ne-text">终结方法</span></strong></summary><p id="u6620a2d6" class="ne-p"><strong><span class="ne-text">在 Java Stream API 中，终结方法（Terminal Operations）是指那些会触发流的计算并最终产生结果的方法。与中间操作不同，终结方法会结束流的操作链，并返回一个具体的结果或副作用。以下是对终结方法的详细介绍：</span></strong></p><p id="ued92678c" class="ne-p"><strong><span class="ne-text">1. 终结方法的特点</span></strong></p><p id="u4f276cc4" class="ne-p"><strong><span class="ne-text">触发计算：终结方法会对流中的数据进行处理并生成结果，通常会遍历流中的所有元素。</span></strong></p><p id="u06c9bbef" class="ne-p"><strong><span class="ne-text">返回类型：终结方法可以返回不同类型的结果，包括：</span></strong></p><p id="ucfcd69c3" class="ne-p"><strong><span class="ne-text">基本类型（如 int、double）</span></strong></p><p id="u477c4769" class="ne-p"><strong><span class="ne-text">对象（如 List、Set、Map）</span></strong></p><p id="u935ad81e" class="ne-p"><strong><span class="ne-text">特殊值（如 Optional、Void）</span></strong></p></details>
<details class="lake-collapse"><summary id="u2b491d90"><strong><span class="ne-text" style="color: #DF2A3F">终结方法</span></strong></summary><p id="u6772e1b1" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：对流中的每个元素执行指定的操作。</span></strong></p><p id="udd84ed9a" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oUmRF" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).forEach(System.out::println);</code></pre><p id="u8e4efc31" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素收集到集合或其他形式。</span></strong></p><p id="u5b5cf4d3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="zF3zf" class="ne-codeblock language-java"><code>List&lt;String&gt; list = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).collect(Collectors.toList());</code></pre><p id="u76f88dab" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F; font-size: 14px">功</span></strong><strong><span class="ne-text" style="color: #DF2A3F">能：对流中的元素进行归约，返回一个单一的结果。</span></strong></p><p id="ue96e0ab3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="H9hY0" class="ne-codeblock language-java"><code>int sum = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</code></pre><p id="uab6649eb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中元素的数量。</span></strong></p><p id="u88fba7fd" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="ATK6U" class="ne-codeblock language-java"><code>long count = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).count();</code></pre><p id="u2f406546" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中是否有任何元素满足给定的条件。</span></strong></p><p id="uc612e6ba" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="yGMii" class="ne-codeblock language-java"><code>boolean hasA = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).anyMatch(s -&gt; s.equals(&quot;a&quot;));</code></pre><p id="u371b5ce7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中所有元素是否满足给定的条件。</span></strong></p><p id="ufd1731bb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="O6I5A" class="ne-codeblock language-java"><code>boolean allMatch = Stream.of(1, 2, 3).allMatch(n -&gt; n &lt; 5);</code></pre><p id="u5928384b" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中的第一个元素（如果存在）。</span></strong></p><p id="ufe6ffdc2" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="qh5FK" class="ne-codeblock language-java"><code>Optional&lt;String&gt; first = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).findFirst();</code></pre><p id="ub4cf4986" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种终结方法的使用：</span></strong></p><pre data-language="java" id="dakWh" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;


<p>public class StreamTerminalOperations &#123;<br>    public static void main(String[] args) &#123;<br>        List&lt;String&gt; names &#x3D; Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;);</p>
<pre><code>    // forEach
    names.stream().forEach(System.out::println);

    // collect
    List&amp;lt;String&amp;gt; filteredNames = names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;))
        .collect(Collectors.toList());
    System.out.println(filteredNames);

    // reduce
    String concatenated = names.stream()
        .reduce(&amp;quot;&amp;quot;, (a, b) -&amp;gt; a + b);
    System.out.println(concatenated);
    
    // count
    long count = names.stream().count();
    System.out.println(&amp;quot;Count: &amp;quot; + count);
    
    // findFirst
    String firstName = names.stream().findFirst().orElse(&amp;quot;No Name&amp;quot;);
    System.out.println(&amp;quot;First Name: &amp;quot; + firstName);
&#125;
</code></pre>
<p>}</code></pre></details></p>
<h3 id="stream流超强引用"><a href="#stream流超强引用" class="headerlink" title="stream流超强引用"></a>stream流超强引用</h3><pre><code class="java">package com.itheima.pojo.test;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Arrays.asList 是 Java 中 java.util.Arrays 类的一个静态方法，
 * 用于将指定的数组或可变数量的参数转换为一个固定大小的 List。
 * 这个 List 是 ArrayList 的一个内部实现类，
 * 但它不是 java.util.ArrayList，
 * 而是一个不可变的列表
 */
public class Test2 &#123;
    public static void main(String[] args) &#123;
        // List&lt;String&gt; list：将上述列表赋值给 list 变量
        List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);
        // 定义一个映射，键为整数，值为字符串列表 = 创建一个新的空哈希映射
        // 键的类型是 Integer，值的类型是 List&lt;String&gt; 表示具有相同长度的字符串列表
        // 用HashMap  允许 null 值：键和值都可以为 null，但键只能有一个 null。
        Map&lt;Integer, List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
        for (String s : list) &#123;
            int length = s.length();
            // 检查 groups 映射中是否已经存在键为 length 的条目
            if (!groups.containsKey(length)) &#123;
                // 将新创建的列表作为值，以 length 为键添加到 groups 映射中
                // 创建一个新的 ArrayList，并将当前字符串 s 添加到其中
                groups.put(length, new ArrayList&lt;&gt;(Arrays.asList(s)));
            &#125; else &#123;
                // 从 groups 映射中获取键为 length 的列表
                List&lt;String&gt; group = groups.get(length);
                group.add(s);
            &#125;
            System.out.println(groups);
        &#125;

        // 使用 Stream API 进行分组
        // 使用 Collectors.groupingBy 方法按字符串长度进行分组
        // 将分组结果收集到一个新的映射 group2 中。
        Map&lt;Integer, List&lt;String&gt;&gt; group2 = list.stream().collect(Collectors.groupingBy(String::length));
        System.out.println(group2);
    &#125;
&#125;
</code></pre>
<h1 id="Lambda-Stream实用方法"><a href="#Lambda-Stream实用方法" class="headerlink" title="Lambda+Stream实用方法"></a>Lambda+Stream实用方法</h1><pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.for循环输出
for (String s : list)&#123;
System.out.println(s);&#125;

2.表达式输出   
list.forEach(s -&gt;
System.out.println(s);&#125;);

3.表达式最简洁输出
List.forEach(System.out::println);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.使用重写Collections 排序
Collections.sort(list,new Comparator&lt;String&gt;（） &#123;
@override
public int compare(String o1, String o2) &#123;
return o1.compareTo(o2);
&#125;
&#125;);

2.使用lambda表达式排序
Collections.sort(list,(o1,o2) -&gt;&#123;
    return o1.compareTo(o2)
&#125;);

3.使用最简洁的表达式
Collections.sort(list,(o1,o2) -&gt;&#123;o1.compareTo(o2)&#125;);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式过滤
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
List&lt;String s : list2)&#123;
if(s.startsWith(&quot;a&quot;))&#123;
     list2.add(s);
&#125; &#125;

2.使用 Stream API 进行过滤和收集,过滤以 &#39;a&#39; 开头的字符串,收集结果到一个新的 List 中
List&lt;String&gt;list3 = list.stream().filter(s - &gt; s.startsWith(&quot;a&quot;)).collect(Collectrs.toList());
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式获取长度
List&lt;Integer&gt; List2 = new ArrayList&lt;&gt;();
for （String s:list)&#123;
    
list2.add(s.length());&#125;

2.Lambda表达式+stream流获取长度
(map)这个函数对我们管道中的每个元素做了处理，在此处为把string转换为Integer类型 主要进行转换作用
List&lt;Integer&gt; list3 = list.stream().map(s -&gt; s.length()).collect(Collectors.toList());
</code></pre>
<pre><code class="java">//新建一个List集合
List&lt;Integer&gt; list = Arrays.asList（1,2, 3, 4, 5);
1.普通方式相加操作
int sum =0;
for (Integer v : list) &#123;
SUm +=V  &#125;
System.out.println(sum);

2.Lambda+stream
(表达式含义)：【0】操作的起始值，【a = a+b】 循环下去
int sum2 = list.stream().reduce( identity: 0, (a, b) -&gt; a + b);
System.out.println(sum2)
</code></pre>
<pre><code class="java">//新建一个集合
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);

Map&lt;Integer,List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();

1.普通方式分组
for （String s:list)&#123;
int length = s.length();
if (!groups.containsKey(length))&#123;
groups.put(length,new ArrayList&lt;&gt;());
&#125;
groups.get(Length) .add(s);
&#125;
    System.out.println(groups);

2.Lambda+stream分组
Map&lt;Integer,List&lt;String&gt;&gt; groups2 = list.stream().collect(Collectors.groupingBy(String::length));
System.out.println（groups2）
</code></pre>
<pre><code class="java">1.普通方式创建线程

Thread thread = newThread(new Runnable()&#123;
@Override
public void run()&#123;
System.out.println(&quot;hello world&quot;);
&#125;
&#125;);
thread.start();

2.Lambda表达式

Thread thread1 = new Threal(() -&gt; System.out.println(hello world&quot;));
thread1.start();
</code></pre>
<pre><code class="java">1.创建接口
interface  MyInterface&#123;
public void doSomething(String s);&#125;

2.普通实现接口
MyInterface myInterface = new MyInterface&#123;
    @override
    public void doSomething(String s)&#123;
    System.out.println(s);
    &#125;
&#125;;
myInterface.doSomething( s:&quot;hello world&quot;);

3.Lambda表达式实现接口
MyInterface myInterface1 = (s) -&gt; System.out.println(s);
myInterface1.doSomething( s:&quot;hello worLd&quot;)
</code></pre>
<pre><code class="java">String str = &quot;hello world&quot;;

1.普通方式
if（str !=null）&#123;
System.out.println(str.toUpperCase());&#125;

2.Lambda表达式
Optional.ofNuLlable(str).map(String::toUpperCase).ifPresent(System.out::println);
</code></pre>
<pre><code class="java">List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.普通方式
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
for （String s:list2)&#123; //遍历循环
    if （s.startsWith(&quot;a&quot;))&#123; //取出 包含a的元素
        list2.add(s.toUpperCase());//添加到list2中然后转换为大写
    &#125;
&#125;       Collections.sort(list2); //排序

2.Lambda+stream方式

List&lt;String&gt; list3 = list.stream().filter(s -&gt; s.startsWith(&quot;a&quot;))
.map(String::toupperCase).sorted().collect(collectors.toList());
</code></pre>
<pre><code class="java">public class Dept &#123;
    private int id;

    public Dept(int id) &#123;
        this.id = id;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Dept&#123;id=&quot; + id + &quot;&#125;&quot;;
    &#125;
&#125;

public class TestCollectStopOptions &#123;

    public void testCollectStopOptions() &#123;
        // 创建一个包含 Dept 对象的列表
        List&lt;Dept&gt; ids = Arrays.asList(new Dept(17), new Dept(22), new Dept(23));

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 List 中
        List&lt;Dept&gt; collectList = ids.stream()
                                   .filter(dept -&gt; dept.getId() &gt; 20)
                                   .collect(Collectors.toList());
        System.out.println(&quot;collectList: &quot; + collectList);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Set 中
        Set&lt;Dept&gt; collectSet = ids.stream()
                                 .filter(dept -&gt; dept.getId() &gt; 20)
                                 .collect(Collectors.toSet());
        System.out.println(&quot;collectSet: &quot; + collectSet);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Map 中，key 为 id，value 为 Dept 对象
        Map&lt;Integer, Dept&gt; collectMap = ids.stream()
                                          .filter(dept -&gt; dept.getId() &gt; 20)
                                          .collect(Collectors.toMap(Dept::getId, dept -&gt; dept));
        System.out.println(&quot;collectMap: &quot; + collectMap);
    &#125;

    public static void main(String[] args) &#123;
        new TestCollectStopOptions().testCollectStopOptions();
    &#125;
&#125;

结果

collectList:[Dept&#123;id=22&#125;, Dept&#123;id=23&#125;]
collectSet:[Dept&#123;id=23&#125;, Dept&#123;id=22&#125;]
collectMap:&#123;22=Dept&#123;id=22&#125;, 23=Dept&#123;id=23&#125;&#125;
</code></pre>
<pre><code class="java">import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class User &#123;
    private String id;

    public User() &#123;
    &#125;

    public String getId() &#123;
        return id;
    &#125;

    public void setId(String id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;id=&#39;&quot; + id + &#39;\&#39;&#39; + &#39;&#125;&#39;;
    &#125;
&#125;

public class TestStringToIntMap &#123;

    /**
     * 演示map的用途：一对一转换
     */
    public void stringToIntMap() &#123;
        // 创建一个包含字符串 ID 的列表
        List&lt;String&gt; ids = Arrays.asList(&quot;205&quot;, &quot;105&quot;, &quot;308&quot;, &quot;469&quot;, &quot;627&quot;, &quot;193&quot;, &quot;111&quot;);

        // 使用流操作
        List&lt;User&gt; results = ids.stream()
                               .map(id -&gt; &#123;
                                   // 创建一个新的 User 对象
                                   User user = new User();
                                   // 设置 User 对象的 id 属性
                                   user.setId(id);
                                   // 返回 User 对象
                                   return user;
                               &#125;)
                               .collect(Collectors.toList()); // 收集结果到一个新的 List 中

        // 打印结果
        System.out.println(results);
    &#125;

    public static void main(String[] args) &#123;
        new TestStringToIntMap().stringToIntMap();
    &#125;
&#125;
</code></pre>
<h1 id="注释笔记"><a href="#注释笔记" class="headerlink" title="@注释笔记"></a>@注释笔记</h1><p>@RequestBody ：获取请全体json字符串数据 封装给java对象，封装的前提是 json字符串属性要与实体类属性名一致才可以封装。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>#{name} 占位符 会从方法参数 对象里面调用getname封装方法获取数据映射到占位符位置。</p>
<p>#{参数名} 是Mybatis的参数占位符，可以自动将参数映射到SQL语句去执行</p>
<p>参数名要与接口方法的参数名要一致，但是方法只有一个参数时，参数名可以是任意的。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>Spring MVC 的 <font style="color:#DF2A3F;">@RequestMapping </font>注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的请求默认都会是 HTTP GET 类型的。比如<font style="color:#DF2A3F;">@GetMapping </font></p>
<p><font style="color:#DF2A3F;">加入路径处理前端响应</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>注解<font style="color:#DF2A3F;">@RequiredArgsConstructor</font> 是 Lombok 提供的一个注解，其主要作用在于简化 @Autowired 的书写过程。在编写 Controller 层或 Service 层代码时，常常需要注入众多的 mapper 接口或 service 接口。若每个接口都使用 @Autowired 进行标注，代码会显得繁琐。而 @RequiredArgsConstructor 注解能够替代 @Autowired 注解，但需注意，在类上添加 @RequiredArgsConstructor 时，需要注入的类必须使用 final 进行声明。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;"> ：</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">的作用与</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Controller&lt;/font&gt;</code><font style="color:#000000;">，</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Service&lt;/font&gt;</code><font style="color:#000000;">的作用都是把对象交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">是标注在</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Dao&lt;/font&gt;</code><font style="color:#000000;">层接口上，作用是将接口的一个实现类交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Mapper</font></p>
<p><font style="color:#000000;">@Mapper: 这个注解一般使用在Dao层接口上，相当于一个mapper.xml文件，它的作用就是将接口生成一个动态代理类。加入了@Mapper注解，目的就是为了不再写mapper映射文件。这个注解就是用来映射mapper.xml文件的。</font></p>
<p><font style="color:#000000;">使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中</font></p>
<p><font style="color:#000000;">注意：</font></p>
<p><font style="color:#000000;">在Dao层不要存在相同名字的接口，也就是在Dao不要写重载。因为mapper文件是通过id与接口进行对应的，如果写了两个同名的接口，就会导致mapper文件映射出错。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Transactional </font></p>
<p><font style="color:#000000;">Spring事务管理-控制事务 注解:@Transactional</font></p>
<p><font style="color:#000000;">作用:将当前方法交给spring进行事务管理，方法执行前，开启事务;成功执行完毕，提交事务;出现异常，回滚事务  放在类上 则是整个类都会启动事务  放在接口上 接口的实现类都会去启动事务。放在方法上此方法中的代码会启动事务。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>规则:JSON数据的键名与方法形参对象的属性名相同，并需要使用@RequestBody注解标识。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>MultipartFile  接收文件接口</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@Service 表明这个是逻辑层 可以被调用</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ConfigurationPropertise（）</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#000000;">@Autowired 注入bean</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;background-color:#131314;">集合:@RequestParam[List<Integer> ids</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>是一个在Java项目中常用的注解，特别是在使用日志框架如SLF4J时，通过在你的类上使用<code>@Slf4j</code>注解，Lombok会自动为你的类生成一个静态的日志字段，这个字段通常是<code>org.slf4j.Logger</code>类型的，并且通常命名为<code>log</code>。这样，你就可以在类中直接使用<code>log.info()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.error()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.debug()</code>等方法来记录日志，而无需手动声明和初始化<code>Logger</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">对象。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">@PathVariable  是 Spring MVC 中用于将 URL 模板变量绑定到你控制器处理器方法参数上的注解。这个注解使得你可以从 URL 中提取出变量值，并将其作为参数传递给控制器的方法。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RequestParam(defaultValue &#x3D; “1”)  给参数设置默认值  如果前端没有参数传进来 默认值为1 可自己设置</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@RequestBody 注解  使用对象去接收 的时候使用的注解  </p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RestControllerAdvice</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@ExceptionHandler</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">限制请求的方式</font></p>
<p><font style="color:#DF2A3F;">@RequestMapping  可以放在类上，获取的路径可以当做所有方法的父路径</font></p>
<p>@PostMapping(value&#x3D;”&#x2F;depts”,method&#x3D;RequestMethod.GET)注解 可以放方法上，获取前端的路径。</p>
<p>@GetMapping（”&#x2F;depts”）</p>
<p>@PutMapping</p>
<p>@DeleteMapping</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">junnit5</font></p>
<p>@Test</p>
<p><font style="color:#DF2A3F;">@ParameterizedTest</font></p>
<p><font style="color:#DF2A3F;">@BeforeEach</font></p>
<p>@AfterEach</p>
<p>@BeforeAll  标识静态方法</p>
<p>@AfterAll  标识静态方法</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@RestController &#x3D;  @Controller+@ResponseBody</font></p>
<p>标识当前控制类所有方法都有了@ResponseBody</p>
<p>@ResponseBody 将控制器方法直接输出给前端，将java对象转换为json字符串输出给前端</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>lombok</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">在定义完Filter之后，Filter其实并不会生效，还需要完成Filter的配置，Filter的配置非常简单，只需要在Filter类上添加一个注解：</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;@WebFilter&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，并指定属性</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;urlPatterns&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，通过这个属性指定过滤器要拦截哪些请求。</font></p>
<p><font style="color:rgb(51, 51, 51);">当我们在Filter类上面加了@WebFilter注解之后，接下来我们还需要在启动类上面加上一个注解@ServletComponentScan，通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持。</font></p>
<p><font style="color:rgb(51, 51, 51);">@Order注解 控制过滤器优先级数字越小 优先级越高</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">Spring Boot 中注解的作用</font></p>
<p><font style="color:#DF2A3F;"></font></p>
<p><font style="color:#000000;">Spring Boot 利用注解来简化配置和提高开发效率。主要注解包括但不限于：</font></p>
<p><font style="color:#000000;">@SpringBootApplication: 启动 Spring Boot 应用程序。</font></p>
<p><font style="color:#000000;">@Component, @Service, @Repository, @Controller: 标记组件，以便 Spring 容器可以自动检测和管理它们。</font></p>
<p><font style="color:#000000;">@Bean 该方法会在spring项目启动时自动调用，并将方法的返回值交给IOC容器管理 – bean对象</font></p>
<p><font style="color:#000000;">@Autowired: 用于自动装配 Bean。</font></p>
<p><font style="color:#000000;">@Bean: 在配置类中定义 Bean。</font></p>
<p><font style="color:#000000;">@Configuration: 定义配置类。</font></p>
<p><font style="color:#000000;">@EnableAutoConfiguration: 开启自动配置。</font></p>
<p><font style="color:#000000;">这些注解通常被组合使用，以提供一个高度可配置且易于扩展的应用程序结构。</font></p>
<p><font style="color:#000000;">12. @PathVariable, @RequestParam, @ModelAttribute, @RequestBody, @ResponseBody</font></p>
<p><font style="color:#000000;">参数绑定</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">这些注解用于从 HTTP 请求中提取参数，并将它们绑定到方法参数上。</font></p>
<p><font style="color:#000000;">@PathVariable: 用于从 URL 中提取路径变量。</font></p>
<p><font style="color:#000000;">@RequestParam: 用于从查询字符串中提取参数。</font></p>
<p><font style="color:#000000;">@ModelAttribute: 用于将多个请求参数绑定到一个对象上。</font></p>
<p><font style="color:#000000;">@RequestBody: 用于将请求体中的数据绑定到方法参数上。 获取请求体json字符串数据封装给java对象</font></p>
<p><font style="color:#000000;">@ResponseBody: 用于将方法的结果直接写入响应体。</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">13. @RestController</font></p>
<p><font style="color:#000000;">控制器注解</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">@RestController 注解是一个组合注解，它等价于 @Controller 和 @ResponseBody 的组合。它表示这是一个 REST 控制器，所有返回值都将被序列化为 JSON 格式并直接写入 HTTP 响应体。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">全局异常处理</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@ControllerAdvice&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于定义全局异常处理类，它可以捕获控制器方法抛出的所有异常，并提供统一的错误响应。</font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class)</font></p>
<p><font style="color:rgb(77, 77, 77);">测试运行器</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class) 注解告诉 JUnit 使用 Spring 测试运行器 (SpringRunner) 来运行测试。Spring 测试运行器提供了一种方便的方式来加载 Spring 上下文并管理测试生命周期。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">整体测试</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@SpringBootTest&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于执行整体测试，它会加载整个 Spring 应用上下文，包括所有自动配置的 Bean。这对于集成测试非常有用，因为它可以模拟完整的 Spring Boot 应用程序。</font></p>
<p>@Configuration 用于定义配置类，<font style="color:rgb(77, 77, 77);">配置类中的bean可以自动装配到其他bean中</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类可以使用其他Spring注解，如@ComponentScan和@Import，来扫描组件或导入其他配置类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类在Spring容器启动时会通过CGLIB动态代理机制生成代理类，以确保@Bean方法只被调用一次，从而保证单例bean的行为</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">环境和属性配置：</font></strong><font style="color:rgb(77, 77, 77);"><br></font><font style="color:rgb(77, 77, 77);">使用@PropertySource和@Value注解可以将外部属性文件中的值注入到配置类中</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">作用:按照一定的条件进行判断，在满足给定条件才会注册对应的bean对象到Spring IOC容器中。</font></p>
<p><font style="color:rgb(77, 77, 77);">位置:方法、类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Conditional 本身是一个父注解，派生出大量子注解</font></p>
<p><font style="color:rgb(77, 77, 77);">@ConditionalonClass:判断环境中是否有对应节码文件才注册bean到IOC容器</font></p>
<p><font style="color:rgb(77, 77, 77);">对应的bean(类型或名称)，才注册bean到IOC容器@ConditionalOnMissingBean:判断环境中没@ConditionalonProperty:判断配置文件中有应属性和值，才注册bean到IOC容器。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">SpringBoot 底层原理</font></p>
<p><font style="color:rgb(77, 77, 77);">bean获取。</font></p>
<p><font style="color:rgb(77, 77, 77);">@singleton   默认容器内同名称的bean只有一个实例（单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@prototype  每次使用该bean时会创建新的实例（非单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@request 每个请求范围内会创建新的实例（web环境中，了解即可）</font></p>
<p><font style="color:rgb(77, 77, 77);">@session 每个会话范围内都会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:rgb(77, 77, 77);">@application 每个应用范围内会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:#DF2A3F;">@Scope 设置bean的作用域 </font><font style="color:rgb(77, 77, 77);"> </font></p>
<p><font style="color:rgb(77, 77, 77);">@Lazy 延迟加载 会延迟到第一次使用的时候才会去加载</font></p>
<p><font style="color:rgb(77, 77, 77);">默认singleton的bean，在容器启动时被创建，可以使用aLazy注解来延迟初始化(延迟到第一次使用时)</font></p>
<p><font style="color:rgb(77, 77, 77);">prototype的bean，每一次使用该bean的时候都会创建一个新的实例。</font></p>
<p><font style="color:rgb(77, 77, 77);">实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性</font></p>
<p><font style="color:rgb(77, 77, 77);">– 非单例是每次使用时会创建一个全新的bean</font></p>
<p><font style="color:rgb(77, 77, 77);">@Import  </font><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">是 Java 中 Spring 框架（特别是 Spring Framework 和 Spring Boot）中用于配置类的一个注解。它主要用于导入其他配置类，使得当前的配置类能够复用其他配置类中的配置信息，从而避免重复的配置代码。</font></p>
<p><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Conditional&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 是 Spring Framework 中的一个注解，它用于在自动配置类（@Configuration 类）中或者通过 </font><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Bean&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 方法定义 bean 时，根据特定的条件来决定是否创建某个 bean 或配置。这个注解使得 Spring 的自动配置更加灵活和强大，因为它允许开发者基于特定的条件（如类路径上的特定类、操作系统属性、环境变量等）来启用或禁用配置。</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">@Transactional注解书写位置：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">方法</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前方法交给spring进行事务管理</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">类</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前类中所有的方法都交由spring进行事务管理 （推荐）</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">接口</font><ul>
<li><font style="color:rgb(51, 51, 51);">接口下所有的实现类当中所有的方法都交给spring 进行事务管理</font></li>
</ul>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<ul>
<li><p><font style="color:rgb(51, 51, 51);">@Data是lombok注解,可以生成getter&#x2F;setter方法,tostring&#x2F;hashcode&#x2F;equals等方法重写</font></p>
<pre><code>@NoArgsConstructor /添加无参构造

@AllArgsConstructor //添加全参构造
</code></pre>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ResponseBody: 将控制器方法返回值直接输出给前端，将java对象转换为json字符串输出给前端@RestController &#x3D; @controller + @ResponseBody</p>
<p>标识了当前控制器类所有方法就都有了@ResponseBody</p>
<p>@Controller : spring框架的ioc注解，用于给当前类创建实例对象，也就是加入ioc容器中。</p>
<p>@Autowired ：依赖注入注解:在运行时会从spring容器中找当前接口实现类对象并注入</p>
<p>@Qualifier(“Bean对象”)：指定Bean别名这与对象</p>
<p>@Qualifier常与@Autowired一起使用</p>
<p>@0ptions(useGeneratedKeys &#x3D; true，keyProperty &#x3D;”id”)&#x2F;&#x2F;需要获取数据库赋值的id属性 并赋值给对象的id</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<h1 id="常用方法模板集合"><a href="#常用方法模板集合" class="headerlink" title="常用方法模板集合"></a>常用方法模板集合</h1><pre><code class="java">@Test
1:JsONUtil.toJsonStr(paramMap)//将任意对象转换为json字符串形式
                     
//使用hutool工具类把BedDto类型转换成Bed实体类 类型
2:Bed bean = BeanUtil.toBean(bedDto, Bed.class);

//判断对象是否为null 如果为null 返回true
3:Objects.isNull(xx)

//判断对象是否不为null 如果不为null 返回true
4:Objects.nonNull(xx)
                  
//工具类Objects 专门用来解决空指针异常 意思 先判断s1！=null 在调用s1.equals(s2)
5:Objects.equals(s1,s2)

//强转方法
6:String.valueOf() 

//整个对象的转换方法
7:BeanUtils.copyProperties(user,userPojo) 

8:StringUtils.toStringArray(把括号中的内容转换为一个字符串类型数组)

//在java中，JSONOBject类中的get（String key）方法接收一个字符串参数作为键名，用于从JSON对象中获取对应的值，这种方法运行通过建模来检索特定的数据项
//当我们调用JSONOBject.get(&quot;acces_token&quot;)的时候，实际上是在告诉程序：请查找名为“access_token”的键，并返回其关键的值，
//如果找到匹配的键，则返回相应的值，如果没有找到，则返回null
9:JSONOBject.get(&quot;acces_token&quot;)
//建造者设计模式：利用各种组件（各种属性）随意组合生成对象，目的是创建对象更加灵活
//与直接调用构造函数对比
//类一般要提供很多构造函数才可以灵活构建对象，这种方式很麻烦
//建造者模式创建对象底层只需需要提供一个构造函数即可，在使用的时候想设置哪个属性就设置哪个属性，最终都调用同一个构造函数
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder给当前类添加建造者设计模式创建对象    这几个注解都要有
10：member = Member.builder()
.openId(openid)
.build();
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/22/后端/Stream模板+Lambda常用+@注释+常用方法模板集合/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/19/攻略/Git详细操作/">
        <h2>
            git详细操作
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><code>@Author yuan</code></p>
<h2 id="Git作用"><a href="#Git作用" class="headerlink" title="Git作用"></a>Git作用</h2><p><font style="color:#DF2A3F;background-color:#FBDE28;">Git 作用</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">代码回溯  版本控制  多人协作  远程备份</font></p>
<p>Git 简介</p>
<p>Git 是一个分布式版本控制工具，通常用来对软件开发过程中的源代码文件进行管理。通过Git 仓库来存储和管理这些文件，Git 仓库分为两种:</p>
<p><font style="color:#DF2A3F;background-color:#FBE4E7;">本地仓库:开发人员自己电脑上的 Git 仓库</font></p>
<p><font style="color:#DF2A3F;background-color:#FBE4E7;">远程仓库:远程服务器上的 Git 仓库</font></p>
<p>commit:提交,将本地文件和版本信息保存到本地仓库</p>
<p>push:推送,将本地仓库文件和版本信息上传到远程仓库</p>
<p>pull:拉取,将远程仓库文件和版本信息下载到本地仓库</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728304999728-8681df84-6516-4c9a-a9e7-69119132c404.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">常用的 Git 代码托管服务</font></p>
<p>Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢?</p>
<p>我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">获取Git 仓库-从远程仓库克隆</font></p>
<p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地命令形式:git clone【远程Git仓库地址】</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">工作区、暂存区、版本库 概念</font></p>
<p>版本库:前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等工作区:包含.git文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码暂存区:.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">Git工作区中文件的状态</font></p>
<p>Git工作区中的文件存在两种状态:untracked 未跟踪(未被纳入版本控制)</p>
<p>tracked 已跟踪(被纳入版本控制)</p>
<p>1.Unmodified 未修改状态</p>
<p>2.Modified 已修改状态</p>
<p>3.Staged 已暂存状态</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">本地仓库操作</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">本地仓库常用命令如下:</font></p>
<p><strong>git status          查看文件状态</strong></p>
<p><strong>git add             将文件的修改加入暂存区</strong></p>
<p><strong>git reset           将暂存区的文件取消暂存或者是切换到指定版本</strong></p>
<p>git commit       将暂存区的文件修改提交到版本库</p>
<p>git log              查看日志</p>
<h1 id="Git项目克隆"><a href="#Git项目克隆" class="headerlink" title="Git项目克隆"></a>Git项目克隆</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">在IDEA中克隆Git项目</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">首先配置Git  </font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728347762923-5f8a0d24-f11c-4162-bd3f-b17b6fdfd7cc.png"></p>
<p><font style="color:rgb(51, 51, 51);">说明：如果Git安装在默认目录中（C:\Program Files\Git），则IDEA中无需再手动配置，直接就可以使用。</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第一步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728347513186-e3f2fa07-4c0b-46fe-920f-3982080e4299.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第二步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348065880-ac6cf502-c456-4122-a6ab-e70075051bf5.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第三步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348271734-59eff3ed-f0c4-4d72-b3d1-0c6c16584db3.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第四步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348416264-cd2e8e62-f156-45dd-82cd-9e9e6033170c.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第五步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348466727-6131437b-652f-4f1e-af23-ba44a5b06f34.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第六步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348514297-16fde195-3353-4143-b11f-1e2525409467.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>红色:未跟踪文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>绿色</strong>:<strong>已暂存文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>蓝色</strong>:<strong>已修改文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>黑色</strong>:<strong>未修改文件</strong></font></p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">1.创建一个标签</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356563022-557a0fbc-3faf-4e88-97dd-ebecc3f671e3.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">确认标签名：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356633874-991c5be6-115b-44dc-83f0-a14a3d8ae038.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">添加成功：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356669609-147814c4-3fc5-4905-8840-72f80f5051d2.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">推送到远程仓库：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356774166-0d41891d-631a-4313-937f-85f09f5438ef.png"></p>
<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">分支操作:</font></p>
<p>查看分支，本质就是执行 gitbranch 命令</p>
<p>创建分支，本质就是执行 git branch 分支名 </p>
<p>命令切换分支，本质就是执行 git checkout命令</p>
<p>将分支推送到远程仓库，本质就是执行 git push 命令</p>
<p>合并分支，本质就是执行 git merge 命令</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">IDEA中查看分支在右下角，如图</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355362895-b04cd00a-03e0-456c-b901-fc343da9be6d.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355451938-5e8ae2ff-5c6b-470a-8419-814bbc077498.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355509519-a24c495a-3bde-447e-8557-b8ef2bdc4405.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支推送</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355654046-73a4dbc8-b73d-4b40-b5e9-659ea5d82945.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">切换分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355795984-ecf5519c-c5ee-46fb-b86a-9b6f5a6d5bf2.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">合并分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356060830-877aa5cd-7b37-41df-a7b3-3c90f34d623c.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356178679-0aa3a848-e212-4bee-909a-d0360ede2269.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">合并分支后需要推送到远程仓库同步</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356308073-89d5e135-2d4c-437e-823d-cc122b649b3f.png"></p>
<h1 id="切换版本开发"><a href="#切换版本开发" class="headerlink" title="切换版本开发"></a>切换版本开发</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">切换版本：</font></p>
<p>在开发过程中，有a1到a5这几个版本的项目，现在需要重新基于a3去开发后续项目。基于这种情况，我们可以右键这个版本的项目，新建分支进行开发。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728357068967-77c87275-510e-4067-a7cd-17b8448bdecd.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728357294505-f9518280-5b27-4922-b4c6-0d3a68fc6399.png"></p>
<h1 id="提交-amp-amp-拉取-amp-amp-冲突"><a href="#提交-amp-amp-拉取-amp-amp-冲突" class="headerlink" title="提交 &amp;&amp; 拉取 &amp;&amp; 冲突"></a>提交 &amp;&amp; 拉取 &amp;&amp; 冲突</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">1.提交</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351542021-b166f619-90aa-438f-9679-bf82ac777e12.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">2.推送</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351606771-c5aa2b2a-b25d-4923-a1b1-5e57dc79a098.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">3.拉取</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351707487-a8cbd23f-0b89-4e76-9afd-9f9d4cf24fb1.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">4.提交推送2</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351889553-2e93cea9-f5a9-49a1-b38e-ed889eebe51e.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">5.拉取</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351959955-8efb3bf0-1fbf-456a-b187-0c8e56939498.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">操作冲突：</font>多个人操作同一个文件，其中有人基于旧的版本修改，提交新版本会成功，但是推送到远程会失败，就是发送冲突。</p>
<p>冲突为什么发生：a和b同时修改c1文件，a先修改完成c1文件，提交推送到远程仓库，c1文件进行更新版本成为c2，提交推送后b也修改完成c1文件，提交的时候成功 推送则失败，因为远程仓库的文件已经进行了更新。<strong>b推送的时候没有拉取最新的文件进行修改，而是使用的过期版本，所以造成冲突。</strong></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突，拉取，合并，推送</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">操作冲突：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353222693-dfb36773-9de9-4e59-913e-76ab27d9c7af.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：1</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353384068-45d7181b-852b-4c20-876c-c54ac075c495.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：2</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353537745-00b91a2b-d5b8-4490-8925-df9fb5637584.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：3</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353826957-3282047c-26eb-4555-8b12-19f1c2f9a5dc.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：4</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353863162-0e943f20-1ae9-4747-9008-3e253c18b7eb.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">推送合并后的项目到远程仓库</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728354076794-ee920b1a-dc3a-4524-ad43-753fb6e75526.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728354258412-947fe27d-bcf5-4153-ac1b-cf8c38a7db53.png"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/攻略" style=color:#1bccbc>
                攻略
            </a>
        </span>
        
    </div>

    <a href="/2024/11/19/攻略/Git详细操作/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/03/后端/若依-AI & 帝可得/">
        <h2>
            若依-AI & 帝可得
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="RuoYi-Vue"><a href="#RuoYi-Vue" class="headerlink" title="RuoYi-Vue"></a>RuoYi-Vue</h3><ul>
<li>RuoYi-Vue版本，采用了前后端分离的单体架构设计<br><a target="_blank" rel="noopener" href="https://gitee.com/ys-gitee/RuoYi-Vue3">https://gitee.com/ys-gitee/RuoYi-Vue3</a><br><a target="_blank" rel="noopener" href="https://gitee.com/y_project/RuoYi-Vue">https://gitee.com/y_project/RuoYi-Vue</a></li>
</ul>
<table>
<thead>
<tr>
<th align="center">课程版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDK 11</td>
</tr>
<tr>
<td align="center">MySQL 8</td>
</tr>
<tr>
<td align="center">Redis 5</td>
</tr>
<tr>
<td align="center">Maven 3.6</td>
</tr>
<tr>
<td align="center">Node 16 (Vue3)</td>
</tr>
</tbody></table>
<ul>
<li>技术选型：SpringBoot、SpringSecurity、MyBatis、Jwt、VUE3、Element-Plus</li>
</ul>
<ol>
<li><p><strong>从VCS导入项目</strong>：</p>
<ul>
<li><p>点击<code>VCS</code>菜单。</p>
</li>
<li><p>选择<code>Get from Version Control...</code>选项。</p>
</li>
<li><pre><code class="java">URL：https://gitee.com/y_project/RuoYi-Vue.git
Directory：C:\Users\Pluminary\Desktop\RuoYi-Vue
</code></pre>
</li>
</ul>
</li>
<li><p><strong>输入项目地址</strong>：</p>
<ul>
<li>在弹出的窗口中，您可以看到不同的版本控制系统（例如Git, SVN等）。</li>
<li>选择您要导入的项目所使用的版本控制系统。</li>
<li>在接下来的窗口中，您需要输入项目的URL地址。这通常是项目的仓库地址，例如Git仓库的HTTPS或SSH链接。</li>
</ul>
</li>
</ol>
<blockquote>
<p>① 若模块没有导入进去没有亮 就<strong>Maven → clean → package</strong></p>
<p>C:\Users\Pluminary\Desktop\RuoYi-Vue\sql 导入Sql文件两个<br><strong>sql&#x2F;quartz.sql</strong><br><strong>sql&#x2F;ry_20240629.sql</strong></p>
</blockquote>
<p>先git<a target="_blank" rel="noopener" href="https://github.com/wzs28150/RuoYi-Vue3">wzs28150&#x2F;RuoYi-Vue3: :tada: (RuoYi)官方仓库 基于SpringBoot，Spring Security，JWT，Vue3 &amp; Vite、Element Plus 的前后端分离权限管理系统</a>下载这里面的资料，在里面<code>C:\Users\Pluminary\Desktop\itcast&gt;code ./RuoYi-Vue3</code>导入vscode里面，再安装依赖(要进入Vue3里面才能利用package.json去生成)<code>npm install</code> → 运行前端项目<code>npm run dev</code></p>
<pre><code class="java">// npm install慢的话 就用中国镜像去下载
npm install --registr=https://registry.npmmirror.com

C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3&gt;npm run dev

&gt; ruoyi@3.8.8 dev
&gt; vite


  VITE v5.3.2  ready in 2026 ms

  ➜  Local:   http://localhost:8080/
  ➜  Network: http://10.254.3.124:8080/
  ➜  Network: http://192.168.104.38:8080/
  ➜  Network: http://192.168.22.1:8080/
  ➜  Network: http://192.168.36.1:8080/
  ➜  press h + enter to show help
</code></pre>
<p>再导入<code>课程管理.sql</code>数据库 → 在若依的后台系统 → 系统工具 → 代码生成 → 配置好后下载代码 → 导入数据库</p>
<p> → 导入RuoYi生成的前端代码<code>C:\Users\Pluminary\Downloads\ruoyi\vue\api</code> 的<strong>course</strong>导入vscode中 <code>C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3\src\api\course</code> &amp;&amp; <code>C:\Users\Pluminary\Downloads\ruoyi\vue\views</code> 的<strong>course</strong>导入vscode中 <code>C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3\src\api\course</code></p>
<p>→ 导入RuoYi生成的后端代码<code>C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3\src\views\course</code>的<strong>com</strong> 并且导入配置文件 &amp;&amp; <code>C:\Users\Pluminary\Downloads\ruoyi\main\resources</code>的<strong>mapper</strong>导入到idea的resource中</p>
<h3 id="功能详解"><a href="#功能详解" class="headerlink" title="功能详解"></a>功能详解</h3><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><ul>
<li>若依内置了强大的权限控制系统，为企业级项目提供了通用的解决方案<ul>
<li>**demo账号 (超级管理员)**，查看所有功能菜单</li>
<li>**zhangsan账号 (市场专员)**，查看线索菜单</li>
<li>**yueyue账号 (销售专员)**，查看商机、合同等菜单</li>
</ul>
</li>
<li><strong>RBAC (基于<span style = "color:red">角色的控制访问</span>)</strong> 是一种广泛使用的访问控制模型，通过<strong>角色</strong>来分配和管理<strong>用户</strong>的菜单<strong>权限</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">表名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sys_dept</td>
<td align="center">部门表</td>
</tr>
<tr>
<td align="center">sys_post</td>
<td align="center">岗(职)位信息表</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_menu</strong></span></td>
<td align="center"><span style = "color:red"><strong>菜单权限表</strong></span></td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_role</strong></span></td>
<td align="center"><span style = "color:red"><strong>角色信息表</strong></span></td>
</tr>
<tr>
<td align="center">sys_role_dept</td>
<td align="center">角色和部门关联表</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_role_menu</strong></span></td>
<td align="center"><span style = "color:red"><strong>角色和菜单关联表</strong></span></td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_user</strong></span></td>
<td align="center"><span style = "color:red"><strong>用户信息表</strong></span></td>
</tr>
<tr>
<td align="center">sys_user_post</td>
<td align="center">用户与岗位关联表</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_user_role</strong></span></td>
<td align="center"><span style = "color:red"><strong>用户和角色关联表</strong></span></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e34a8982a14929c9b4d00cae2f337c3e043708da/%E8%8B%A5%E4%BE%9D-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.jpg"></p>
<h6 id="创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。"><a href="#创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。" class="headerlink" title="创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。"></a>创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。</h6><p>① <strong>创建菜单</strong><br>② <strong>创建角色，并分配权限</strong><del>课研人员</del><br>③ <strong>创建用户，并关联角色</strong><del>xiaozhi</del></p>
<pre><code class="java">若依通过简单的功能配置实现RBC的权限管理
</code></pre>
<h5 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h5><ul>
<li>若依内置的数据字典，用于维护系统中常见的静态数据。例如：性别、状态</li>
<li>功能包括：字典类型管理、字典数据管理</li>
<li>表关系说明【一对多】</li>
</ul>
<table>
<thead>
<tr>
<th>表名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sys_dict_type</td>
<td>字典类型表</td>
</tr>
<tr>
<td>sys_dict_data</td>
<td>字典数据表</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>dict_id</th>
<th>dict_name</th>
<th><span style = "color:red">dict_type</span></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户性别</td>
<td>sys_user_sex</td>
</tr>
<tr>
<td>2</td>
<td>菜单状态</td>
<td>sys_show_hide</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>dict_code</th>
<th>dict_sort</th>
<th>dict_label</th>
<th>dict_value</th>
<th><span style = "color:red">dict_type</span></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>男</td>
<td>0</td>
<td>sys_user_sex</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>女</td>
<td>1</td>
<td>sys_user_sex</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>未知</td>
<td>2</td>
<td>sys_user_sex</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>将一些不经常修改的数据(课程管理的学科字段)改为数据字典维护，以免占用大量空间</strong></p>
<ul>
<li><p>添加字典类型和数据</p>
<blockquote>
<p>系统管理 → 字典管理 → 新增 → <strong>添加字典类型</strong><br>字典名称：学科<br>字典类型：course_subject<br>第二页点进去<strong>添加字典数据</strong><br>javaEE → 0 → 1 </p>
</blockquote>
</li>
<li><p>修改代码生成信息</p>
<blockquote>
<p>系统工具 → 代码生成 → 编辑课程管理 → subject课程学科 显示类型从<strong>文本框</strong>改成<strong>下拉框</strong> → 字典类型 是学科 → 下载最新的代码<br>只需要修改前端vue组件 因为只改了从前端文本框到下拉框 和一些数据字典</p>
</blockquote>
</li>
<li><p>下载代码，导入前端</p>
<blockquote>
<p>C:\Users\Pluminary\Downloads\ruoyi (1)\vue\views\course\course\index.vue去替换前端的index.vue  此时去若依前端查看课程管理→课程学科就会发现已经添加新的进去了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>此时去<code>课程管理</code>里面找<code>课程学科：JavaEE</code>进行筛选不会出 因为若依底层<br><a target="_blank" rel="noopener" href="http://10.254.2.179/dev-api/course/course/list?pageNum=1&amp;pageSize=10&amp;subject=0">http://10.254.2.179/dev-api/course/course/list?pageNum=1&amp;pageSize=10&amp;subject=0</a><br>要从数据库里把JavaEE的subject改成0<br>优点：<strong>降低数据库的存储压力 提高磁盘利用率</strong></p>
</blockquote>
<h5 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h5><ul>
<li><p><strong>参数设置</strong>：对系统中的参数进行动态维护</p>
<blockquote>
<p>系统管理 → 参数设置 → 验证码开关 → 修改 → 参数键值 → false<br>还可以开启是否 <u>用户注册功能</u> → 前端代码隐藏需要修改 → src&#x2F;views&#x2F;login.vue → 97行注册开关<br>const register &#x3D; ref(true) 此时登录界面就有立即注册 跳转注册</p>
</blockquote>
</li>
<li><p><strong>通知公告(半成品)：</strong>促进组织内部信息传递</p>
<blockquote>
<p>系统管理 → 通知公告 → 新增</p>
</blockquote>
</li>
<li><p><strong>日志管理：</strong>轻松追踪用户行为和系统运行状况</p>
<blockquote>
<p>系统管理 → 通知公告 → 日志管理 → 操作日志</p>
</blockquote>
</li>
</ul>
<h5 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h5><ul>
<li><p>若依提供了一些列强大的监控工具，能够帮助开发者和运维快速了解应用程序的性能状态</p>
<blockquote>
<p>系统监控 → 在线用户 &amp;&amp; 缓存列表<br>数据监控【Druid Monitor】 → ruoyi &amp;&amp; 123456</p>
</blockquote>
</li>
</ul>
<h5 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h5><ul>
<li><p>若依为定时任务功能提供方便友好的web界面，实现动态管理任务</p>
<pre><code class="java">@Component
public class MyTask&#123;
  @Scheduled(cron = &quot;0/5 *****?&quot;)
  public void showTime()&#123;
     sout(&quot;定时任务开始执行：&quot; + new Date());
  &#125;
&#125;
// 硬编码 改代码需要重新修改 重新编译 重新上传...
</code></pre>
</li>
<li><p><strong>每间隔5秒，控制台输出系统时间</strong></p>
<ul>
<li><p>创建任务类</p>
<blockquote>
<p>创建一个类 <code>C:\Users\Pluminary\Desktop\RuoYi-Vue\ruoyi-quartz\src\main\java\com\ruoyi\quartz\task\MyTask.java</code></p>
<pre><code class="java">package com.ruoyi.quartz.task;

import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class MyTask &#123;
    public void showTime()&#123;
        System.out.println(&quot;定时任务开始执行：&quot; + new Date());
    &#125;
&#125;
</code></pre>
</blockquote>
</li>
<li><p>添加任务规则</p>
<blockquote>
<p>系统监控 → 定时任务 → 新增 →<br>任务名称：输出时间        任务分组：默认<br>调用方式：myTask.showTime()<br>Cron表达式生成器：<u>从0秒开始，每5秒执行一次</u> → 0&#x2F;5 * * * * ?<br>开启输出时间 状态打开！</p>
<h2 id="然后每间隔5秒就会向控制台输出时间"><a href="#然后每间隔5秒就会向控制台输出时间" class="headerlink" title="然后每间隔5秒就会向控制台输出时间"></a>然后每间隔5秒就会向控制台输出时间</h2><p>定时任务开始执行：Wed Nov 06 18:12:30 CST 2024<br>18:12:30.001 [quartzScheduler_Worker-4] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &gt; Preparing: insert into sys_job_log( job_name, job_group, invoke_target, job_message, status, create_time )values( ?, ?, ?, ?, ?, sysdate() ) 18:12:30.002 [quartzScheduler_Worker-4] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - –&gt; Parameters: 输出时间(String), DEFAULT(String), myTask.showTime()(String), 输出时间 总共耗时：0毫秒(String), 0(String) 18:12:30.009 [quartzScheduler_Worker-4] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &lt; Updates: 1 定时任务开始执行：Wed Nov 06 18:12:35 CST 2024 18:12:35.006 [quartzScheduler_Worker-5] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &gt; Preparing: insert into sys_job_log( job_name, job_group, invoke_target, job_message, status, create_time )values( ?, ?, ?, ?, ?, sysdate() ) 18:12:35.006 [quartzScheduler_Worker-5] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - –&gt; Parameters: 输出时间(String), DEFAULT(String), myTask.showTime()(String), 输出时间 总共耗时：0毫秒(String), 0(String) 18:12:35.012 [quartzScheduler_Worker-5] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &lt; Updates: 1</p>
</blockquote>
</li>
<li><p><strong>启动任务</strong></p>
<p>官方有提供可以训练的模型</p>
<blockquote>
<p>在这里面：com&#x2F;ruoyi&#x2F;quartz&#x2F;task&#x2F;RyTask.java</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="表单构建"><a href="#表单构建" class="headerlink" title="表单构建"></a>表单构建</h5><ul>
<li><h6 id="通过表单构建工具，单独制作一个添加课程的表单页面"><a href="#通过表单构建工具，单独制作一个添加课程的表单页面" class="headerlink" title="通过表单构建工具，单独制作一个添加课程的表单页面"></a>通过表单构建工具，单独制作一个添加课程的表单页面</h6><ul>
<li><p>制作表单并导出</p>
<blockquote>
<p>系统工具 → 表单构建 → 左侧<strong>行容器</strong> → 拖入第一个单行文本 → 右侧可以改名字 如果想实现一行两个文本的化 就把<code>表单栅格调小一点</code> → 选择性组件的<strong>下拉选择</strong>托到右面 → 修改字段名、标题、表单栅格…<br>日期范围 → 课程有效期 → 选择型组件里的日期范围 命名为：课程有效期<br>文件上传组件 → 课程封面<br>评分 → 推荐指数<br>多行文本 → 课程介绍</p>
</blockquote>
</li>
<li><p>复制到前端工程</p>
<blockquote>
<p>搞完后打开前端工程把add.vue它放在 src&#x2F;views&#x2F;course&#x2F;course&#x2F;中</p>
</blockquote>
</li>
<li><p>创建动态菜单</p>
<blockquote>
<p>系统管理 → 菜单管理 → 添加菜单 →<br>菜单类型：菜单<br>菜单名称：添加课程<br>显示排序：1<br>路由地址：course&#x2F;add<br>组件路径：course&#x2F;course&#x2F;add<br>刷新界面 就会有菜单管理→添加课程了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h4><h5 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h5><ul>
<li>代码生成器，根据数据库表结构自动生成前后端CRUD代码</li>
<li>提供三种生成模板：单表、树表、主子表(一对多)</li>
<li>树表是一种展示层级数据的表格，能展开折叠，清晰呈现父子关系，便于管理</li>
</ul>
<blockquote>
<p>系统工具 → 代码生成 → 导入部门表 → 编辑 → 生成信息 → 生成模板：树表 →<br>树编码字段：dept_id：部门id<br>树父编码字段：parent_id：父部门id<br>树名称字段：dept_name：部门名称<br>提交后下载代码<br>导入后就是 系统管理&#x2F;部门管理 的树型结构界面了</p>
</blockquote>
<table>
<thead>
<tr>
<th>dept_id</th>
<th>parent_id</th>
<th>ancestors</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>0</td>
<td>0</td>
<td>若依科技</td>
</tr>
<tr>
<td>101</td>
<td>100</td>
<td>0,100</td>
<td>深圳总公司</td>
</tr>
<tr>
<td><span style = "color:red">102</span></td>
<td>100</td>
<td>0,100</td>
<td>长沙分公司</td>
</tr>
<tr>
<td>108</td>
<td><span style = "color:red">102</span></td>
<td>0,100,101</td>
<td>市场部门</td>
</tr>
<tr>
<td>109</td>
<td><span style = "color:red">102</span></td>
<td>0,100,102</td>
<td>财务部门</td>
</tr>
</tbody></table>
<h5 id="系统接口"><a href="#系统接口" class="headerlink" title="系统接口"></a>系统接口</h5><ul>
<li><p>Swagger，能够自动生成API的同步在线文档，并提供Web界面进行接口调用和测试</p>
<blockquote>
<p>系统工具 → 系统接口<br>若依的Token在应用程序里 需要搞token进去<br>测试：获取用户列表GET<br>得到Token(F12后找应用程序 → Cookie<del>若依</del> → 找到Admin-Token<del>一定是当前ip地址的Token</del> → 在Authorize中设置Token令牌 → 去后端改swagger的请求前缀pathMapping：&#x2F;<del>因为他的地址前面默认佩戴&#x2F;dev-api</del></p>
<pre><code class="yaml"># Swagger配置
swagger:
  # 是否开启swagger
  enabled: true
  # 请求前缀
  pathMapping: /
</code></pre>
<p>然后重启后台项目刷新浏览器打开接口再调用Token再去测试<br>此时就操作成功了</p>
<pre><code class="json">&#123;
  &quot;code&quot;: 200,
  &quot;msg&quot;: &quot;操作成功&quot;,
  &quot;data&quot;: [
    &#123;
      &quot;userId&quot;: 1,
      &quot;username&quot;: &quot;admin&quot;,
      &quot;password&quot;: &quot;admin123&quot;,
      &quot;mobile&quot;: &quot;15888888888&quot;
    &#125;,
    &#123;
      &quot;userId&quot;: 2,
      &quot;username&quot;: &quot;ry&quot;,
      &quot;password&quot;: &quot;admin123&quot;,
      &quot;mobile&quot;: &quot;15666666666&quot;
    &#125;
  ]
&#125;
</code></pre>
</blockquote>
</li>
</ul>
<p><span style = "color:red"><strong>若依常用功能？</strong></span></p>
<p>① <strong>权限控制</strong><br>② <strong>数据字典</strong><br>③ <strong>定时任务</strong><br>④ <strong>表单构建</strong><br>⑤ <strong>代码生成</strong></p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><img src="https://raw.githubusercontent.com/P-luminary/images/2d1ced51ed4dfb918b78181cb385e58594e7bdaa/RuoYi%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg"  />

<h5 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h5><img src="https://raw.githubusercontent.com/P-luminary/images/f157a27c9825e2305562a5f7a5917ad511ee7ac5/RuoYi%E8%A1%A8%E7%BB%93%E6%9E%84.jpg" style="zoom:150%;" />

<h5 id="前端代码分析"><a href="#前端代码分析" class="headerlink" title="前端代码分析"></a>前端代码分析</h5><ul>
<li><code>api/course/course.js</code>  用于向后端发送Ajax请求的接口代码</li>
<li><code>views/course/course/index.vue</code>用于在浏览器展示课程的视图组件</li>
</ul>
<pre><code class="vue">src\views\course\course\index.vue
&lt;template&gt;
  &lt;div class=&quot;app-container&quot;&gt;
    &lt;!-- :model做双向绑定 将前端录入条件封装给响应对象  v-show控制搜索栏显示隐藏--&gt;
    &lt;el-form :model=&quot;queryParams&quot; ref=&quot;queryRef&quot; :inline=&quot;true&quot; v-show=&quot;showSearch&quot; label-width=&quot;68px&quot;&gt;
      &lt;el-form-item label=&quot;课程编码&quot; prop=&quot;code&quot;&gt;
        &lt;!-- v-model双向绑定code(前端课程编码) clearable清理用户输入信息 @keyup键盘回车事件完成搜索--&gt;
        &lt;el-input
          v-model=&quot;queryParams.code&quot;
          placeholder=&quot;请输入课程编码&quot;
          clearable
          @keyup.enter=&quot;handleQuery&quot;
        /&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;课程学科&quot; prop=&quot;subject&quot;&gt;
        &lt;!-- v-for遍历课程学科的字典数据列表 :lable展示label :value提交value值--&gt;
        &lt;el-select v-model=&quot;queryParams.subject&quot; placeholder=&quot;请选择课程学科&quot; clearable&gt;
          &lt;el-option
            v-for=&quot;dict in course_subject&quot;
            :key=&quot;dict.value&quot;
            :label=&quot;dict.label&quot;
            :value=&quot;dict.value&quot;
          /&gt;
        &lt;/el-select&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt;
        &lt;el-input
          v-model=&quot;queryParams.name&quot;
          placeholder=&quot;请输入课程名称&quot;
          clearable
          @keyup.enter=&quot;handleQuery&quot;
        /&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;applicablePerson&quot;&gt;
        &lt;el-select v-model=&quot;queryParams.applicablePerson&quot; placeholder=&quot;请选择适用人群&quot; clearable&gt;
          &lt;el-option
            v-for=&quot;dict in course_applicable_person&quot;
            :key=&quot;dict.value&quot;
            :label=&quot;dict.label&quot;
            :value=&quot;dict.value&quot;
          /&gt;
        &lt;/el-select&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item&gt;
        &lt;el-button type=&quot;primary&quot; icon=&quot;Search&quot; @click=&quot;handleQuery&quot;&gt;搜索&lt;/el-button&gt;
        &lt;el-button icon=&quot;Refresh&quot; @click=&quot;resetQuery&quot;&gt;重置&lt;/el-button&gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;

    &lt;el-row :gutter=&quot;10&quot; class=&quot;mb8&quot;&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;!-- @click点击新增按钮弹出新增 v-hasPermi自定义属性完成菜单显示/隐藏 --&gt;
        &lt;el-button
          type=&quot;primary&quot;
          plain
          icon=&quot;Plus&quot;
          @click=&quot;handleAdd&quot;
          v-hasPermi=&quot;[&#39;course:course:add&#39;]&quot;
        &gt;新增&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;!-- :disabled表示这个框是否可用 --&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;el-button
          type=&quot;success&quot;
          plain
          icon=&quot;Edit&quot;
          :disabled=&quot;single&quot;
          @click=&quot;handleUpdate&quot;
          v-hasPermi=&quot;[&#39;course:course:edit&#39;]&quot;
        &gt;修改&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;el-button
          type=&quot;danger&quot;
          plain
          icon=&quot;Delete&quot;
          :disabled=&quot;multiple&quot;
          @click=&quot;handleDelete&quot;
          v-hasPermi=&quot;[&#39;course:course:remove&#39;]&quot;
        &gt;删除&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;el-button
          type=&quot;warning&quot;
          plain
          icon=&quot;Download&quot;
          @click=&quot;handleExport&quot;
          v-hasPermi=&quot;[&#39;course:course:export&#39;]&quot;
        &gt;导出&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;!-- 点击会控制&#39;搜索栏&#39;显示隐藏 @queryTable重新加载表格展示数据 --&gt;
      &lt;right-toolbar v-model:showSearch=&quot;showSearch&quot; @queryTable=&quot;getList&quot;&gt;&lt;/right-toolbar&gt;
    &lt;/el-row&gt;
    &lt;!-- v-loading展示表格的加载状态 遍历展示courseList 事件监听器监听选中行 --&gt;
    &lt;el-table v-loading=&quot;loading&quot; :data=&quot;courseList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;
      &lt;!-- 当用户勾选复选框 触发@selection-change --&gt;
      &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
      &lt;!-- 展示具体数据源数据 --&gt;
      &lt;el-table-column label=&quot;课程id&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
      &lt;el-table-column label=&quot;课程编码&quot; align=&quot;center&quot; prop=&quot;code&quot; /&gt;
      &lt;el-table-column label=&quot;课程学科&quot; align=&quot;center&quot; prop=&quot;subject&quot;&gt;
 &lt;!-- 通过scope拿到整个表格数据 通过:value=&quot;scope.row.subject&quot;拿到字典值去匹配字典数据列表 找到该值对应的标签显示给前端--&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;dict-tag :options=&quot;course_subject&quot; :value=&quot;scope.row.subject&quot;/&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;课程名称&quot; align=&quot;center&quot; prop=&quot;name&quot; /&gt;
      &lt;el-table-column label=&quot;价格&quot; align=&quot;center&quot; prop=&quot;price&quot; /&gt;
      &lt;el-table-column label=&quot;适用人群&quot; align=&quot;center&quot; prop=&quot;applicablePerson&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;dict-tag :options=&quot;course_applicable_person&quot; :value=&quot;scope.row.applicablePerson&quot;/&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;课程介绍&quot; align=&quot;center&quot; prop=&quot;info&quot; /&gt;
      &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
&lt;!-- 使用了模板插槽 --&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;!-- @click=&quot;handleUpdate(scope.row)把当前行的数据传给当前方法  v-hasPermi自定义权限属性--&gt;
          &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;course:course:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot; icon=&quot;Delete&quot; @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;course:course:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
    
    &lt;!-- 分页区域 --&gt;
     &lt;!-- v-show如果大于0条就显示反之隐藏 :total展示总条数 展示分页页码 @pagination=&quot;getList&quot;换页后新数据的查询--&gt;
    &lt;pagination
      v-show=&quot;total&gt;0&quot;
      :total=&quot;total&quot;
      v-model:page=&quot;queryParams.pageNum&quot;
      v-model:limit=&quot;queryParams.pageSize&quot;
      @pagination=&quot;getList&quot;
    /&gt;

    &lt;!-- 添加或修改课程管理对话框 --&gt;
     &lt;!-- el-dialog默认隐藏的 点击会显示 append-to-body默认将对话框在body上追加显示 :title动态绑定标题(新增和修改不一样)--&gt;
    &lt;el-dialog :title=&quot;title&quot; v-model=&quot;open&quot; width=&quot;500px&quot; append-to-body&gt;
      &lt;!-- :model来双向绑定 :rules校验规则--&gt;
      &lt;el-form ref=&quot;courseRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt;
        &lt;el-form-item label=&quot;课程编码&quot; prop=&quot;code&quot;&gt;
          &lt;el-input v-model=&quot;form.code&quot; placeholder=&quot;请输入课程编码&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;课程学科&quot; prop=&quot;subject&quot;&gt;
          &lt;el-select v-model=&quot;form.subject&quot; placeholder=&quot;请选择课程学科&quot;&gt;
            &lt;el-option
              v-for=&quot;dict in course_subject&quot;
              :key=&quot;dict.value&quot;
              :label=&quot;dict.label&quot;
              :value=&quot;dict.value&quot;
            &gt;&lt;/el-option&gt;
          &lt;/el-select&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt;
          &lt;el-input v-model=&quot;form.name&quot; placeholder=&quot;请输入课程名称&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;价格&quot; prop=&quot;price&quot;&gt;
          &lt;el-input v-model=&quot;form.price&quot; placeholder=&quot;请输入价格&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;applicablePerson&quot;&gt;
          &lt;el-select v-model=&quot;form.applicablePerson&quot; placeholder=&quot;请选择适用人群&quot;&gt;
            &lt;el-option
              v-for=&quot;dict in course_applicable_person&quot;
              :key=&quot;dict.value&quot;
              :label=&quot;dict.label&quot;
              :value=&quot;dict.value&quot;
            &gt;&lt;/el-option&gt;
          &lt;/el-select&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;课程介绍&quot; prop=&quot;info&quot;&gt;
          &lt;el-input v-model=&quot;form.info&quot; placeholder=&quot;请输入课程介绍&quot; /&gt;
        &lt;/el-form-item&gt;
      &lt;/el-form&gt;
      &lt;template #footer&gt;
        &lt;div class=&quot;dialog-footer&quot;&gt;
          &lt;!-- 提交前先进行表单规则的校验:rules=&quot;rules&quot;  --&gt;
          &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm&quot;&gt;确 定&lt;/el-button&gt;
          &lt;el-button @click=&quot;cancel&quot;&gt;取 消&lt;/el-button&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/el-dialog&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup name=&quot;Course&quot;&gt;
// 引入后端api接口文件
import &#123; listCourse, getCourse, delCourse, addCourse, updateCourse &#125; from &quot;@/api/course/course&quot;;
// 获取当前实例代理对象，用于访问组件数据、方法
const &#123; proxy &#125; = getCurrentInstance();
// 获取课程学科的数据字典
const &#123; course_applicable_person, course_subject &#125; = proxy.useDict(&#39;course_applicable_person&#39;, &#39;course_subject&#39;);
// 列表数据
const courseList = ref([]);
// 是否显示弹框
const open = ref(false);
// 是否显示加载状态
const loading = ref(true);
// 是否显示搜索栏
const showSearch = ref(true);
// 复选框，被选中id的数组
const ids = ref([]);
// 复选框，是否单选，用于高亮修改、删除按钮
const single = ref(true);
// 复选框，是否多选，仅高亮删除按钮
const multiple = ref(true);
// 总(记录)条数
const total = ref(0);
// 用于区分新增、修改对话框标题
const title = ref(&quot;&quot;);
// 定义reactive响应式对象
const data = reactive(&#123;
  // 新增或修改表单数据
  form: &#123;&#125;,
  // 搜索条件参数
  queryParams: &#123;
    pageNum: 1,
    pageSize: 10,
    code: null,
    subject: null,
    name: null,
    applicablePerson: null,
  &#125;,
  // 表单校验规则
  rules: &#123;
    code: [
      &#123; required: true, message: &quot;课程编码不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
    subject: [
      &#123; required: true, message: &quot;课程学科不能为空&quot;, trigger: &quot;change&quot; &#125;
    ],
    name: [
      &#123; required: true, message: &quot;课程名称不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
    price: [
      &#123; required: true, message: &quot;价格不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
    applicablePerson: [
      &#123; required: true, message: &quot;适用人群不能为空&quot;, trigger: &quot;change&quot; &#125;
    ],
    info: [
      &#123; required: true, message: &quot;课程介绍不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
  &#125;
&#125;);
// 将data对象的三个属性，转换为ref响应式对象
const &#123; queryParams, form, rules &#125; = toRefs(data);

/** 查询课程管理列表 */
function getList() &#123;
  loading.value = true;
  listCourse(queryParams.value).then(response =&gt; &#123;
    courseList.value = response.rows;
    total.value = response.total;
    loading.value = false;
  &#125;);
&#125;

// 取消按钮
function cancel() &#123;
  open.value = false;
  reset();
&#125;

// 表单重置
function reset() &#123;
  form.value = &#123;
    id: null,
    code: null,
    subject: null,
    name: null,
    price: null,
    applicablePerson: null,
    info: null,
    createTime: null,
    updateTime: null
  &#125;;
  proxy.resetForm(&quot;courseRef&quot;);
&#125;

/** 搜索按钮操作 */
function handleQuery() &#123;
  // 最新的从第一页开始 再发送请求
  queryParams.value.pageNum = 1;
  getList();
&#125;

/** 重置按钮操作 */
function resetQuery() &#123;
  proxy.resetForm(&quot;queryRef&quot;);
  handleQuery();
&#125;

// 多选框选中数据
// 把选中的复选框对象传递过来
function handleSelectionChange(selection) &#123;
  // 拿到对象调用map方法进行遍历取每个复选框的id
  // 封装给ids的响应式数组对象
  ids.value = selection.map(item =&gt; item.id);
  // 控制修改和删除按钮是否高亮可用的 23默认为true
  single.value = selection.length != 1;
  // 修改按钮只要大于0 就是false 那么修改按钮可用使用
  multiple.value = !selection.length;
&#125;

/** 新增按钮操作 */
function handleAdd() &#123;
  reset();
  open.value = true;
  title.value = &quot;添加课程管理&quot;;
&#125;

/** 修改按钮操作 */
// 拿到行对象 重置 取出当前行id或一个id
function handleUpdate(row) &#123;
  reset();
  const _id = row.id || ids.value
  getCourse(_id).then(response =&gt; &#123;
    form.value = response.data;
    open.value = true;
    title.value = &quot;修改课程管理&quot;;
  &#125;);
&#125;

/** 提交按钮 */
function submitForm() &#123;
  // &#39;修改课程&#39;对表单进行校验 正则规则...是否必填
  proxy.$refs[&quot;courseRef&quot;].validate(valid =&gt; &#123;
    if (valid) &#123;// 区分新增还是修改的操作
      if (form.value.id != null) &#123;
        updateCourse(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;修改成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125; else &#123;
        addCourse(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;新增成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125;
    &#125;
  &#125;);
&#125;

/** 删除按钮操作 */
function handleDelete(row) &#123;
  // 一行或数组
  const _ids = row.id || ids.value;
  // 防止误操作
  proxy.$modal.confirm(&#39;是否确认删除课程管理编号为&quot;&#39; + _ids + &#39;&quot;的数据项？&#39;).then(function() &#123;
    return delCourse(_ids);
  &#125;).then(() =&gt; &#123;
    getList();
    proxy.$modal.msgSuccess(&quot;删除成功&quot;);
  &#125;).catch(() =&gt; &#123;&#125;);
&#125;

/** 导出按钮操作 */
function handleExport() &#123;
  proxy.download(&#39;course/course/export&#39;, &#123;
    ...queryParams.value
  &#125;, `course_$&#123;new Date().getTime()&#125;.xlsx`)
&#125;

getList();
&lt;/script&gt;
</code></pre>
<pre><code class="js">src\api\course\course.js
// 封装了请求和响应拦截器 下面return每个都调用请求
import request from &#39;@/utils/request&#39;

// 查询课程管理列表
// 接收用户输入参数 调用工具类把参数传过去 向后端发送请求完成课程列表的查询
// 然后返回前端并展示数据
export function listCourse(query) &#123;
  return request(&#123;
    url: &#39;/course/course/list&#39;,
    method: &#39;get&#39;,
    params: query
  &#125;)
&#125;

// 查询课程管理详细
// 点击修改按钮时候根据id去查询 返回给前端
export function getCourse(id) &#123;
  return request(&#123;
    url: &#39;/course/course/&#39; + id,
    method: &#39;get&#39;
  &#125;)
&#125;

// 新增课程管理
// 当点击确定按钮的时候 就把数据添加进来发送请求后返回前端
export function addCourse(data) &#123;
  return request(&#123;
    url: &#39;/course/course&#39;,
    method: &#39;post&#39;,
    data: data
  &#125;)
&#125;

// 修改课程管理
// 修改完毕(根据id去查找数据库的)
export function updateCourse(data) &#123;
  return request(&#123;
    url: &#39;/course/course&#39;,
    method: &#39;put&#39;,
    data: data
  &#125;)
&#125;

// 删除课程管理
// 批量/单体删除
export function delCourse(id) &#123;
  return request(&#123;
    url: &#39;/course/course/&#39; + id,
    method: &#39;delete&#39;
  &#125;)
&#125;
</code></pre>
<h3 id="再次熟悉：前-后端结构"><a href="#再次熟悉：前-后端结构" class="headerlink" title="再次熟悉：前+后端结构"></a><span style = "color:red">再次熟悉：前+后端结构</span></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/2d1ced51ed4dfb918b78181cb385e58594e7bdaa/RuoYi%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg"></p>
<h6 id="若i18n乱码的情况下"><a href="#若i18n乱码的情况下" class="headerlink" title="若i18n乱码的情况下"></a>若i18n乱码的情况下</h6><blockquote>
<p>file -&gt; settings -&gt; editor -&gt; file ecoding -&gt; <strong>default encoding for properties files</strong>：utf-8</p>
</blockquote>
<h3 id="后端代码分析"><a href="#后端代码分析" class="headerlink" title="后端代码分析"></a>后端代码分析</h3><ul>
<li><p><strong>CourseController</strong></p>
</li>
<li><p><strong>ICourseService及实现类</strong></p>
</li>
<li><p><strong>CourseMapper及映射方法</strong></p>
</li>
<li><p><strong>Course</strong></p>
</li>
<li><p><strong><u>BaseController：web层通用数据处理</u></strong></p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/afd799acd589023d8452649e6565150168bee83b/BaseController%E5%86%85%E5%AE%B9.jpg" style="zoom:200%;" />

<pre><code class="java">/**
     * 查询课程管理列表
     */
    @PreAuthorize(&quot;@ss.hasPermi(&#39;course:course:list&#39;)&quot;)
    @GetMapping(&quot;/list&quot;)
    public TableDataInfo list(Course course) &#123;
        //1.开启分页
        startPage();
        //2.查询课程列表
        List&lt;Course&gt; list = courseService.selectCourseList(course);
        return getDataTable(list);
    &#125;
// 在分页查询那块会附带着两个封装好的sql语句
// select * from tb_course where xxx 【逐步细分成两个小sql】
  1. select count(*) from tb_course where xxx      //总记录数
  2. select * from tb_course where xxx limit ?,?   //获取当前的数据列表
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/644e3ab525e8c4aaf75d6f6f3e3879cb2a196303/%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%8E%9F%E7%90%86.jpg"></p>
<h5 id="分页原理"><a href="#分页原理" class="headerlink" title="分页原理"></a>分页原理</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/14bbabe082a07e29da26ea9d5f0c648dcf91677a/%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%8E%9F%E7%90%862.jpg"></p>
<h5 id="AjaxResult：操作消息提醒"><a href="#AjaxResult：操作消息提醒" class="headerlink" title="AjaxResult：操作消息提醒"></a>AjaxResult：操作消息提醒</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/92f34019d9a098b23780c66e99a5bab18541ee9a/AjaxResult%E6%93%8D%E4%BD%9C%E4%BF%A1%E6%81%AF%E6%8F%90%E9%86%92.jpg"></p>
<h5 id="权限解读"><a href="#权限解读" class="headerlink" title="权限解读"></a>权限解读</h5><ul>
<li><code>@PreAuthorize</code>注解是Spring Security框架中用来做权限检查的。</li>
<li>它在运行方法前先验证权限，权限够就放行，不够就拦截</li>
</ul>
<pre><code class="java">@RestController
@RequestMapping(&quot;/course/course&quot;)
public class CourseController extends BaseController &#123;
    @Autowired
    private ICourseService courseService;

    /**
     * 查询课程管理列表
     */
// 问题：我怎么知道该用户有没有权限呢？基于RBC权限模型 
    @PreAuthorize(&quot;@ss.hasPermi(&#39;course:course:list&#39;)&quot;)
    @GetMapping(&quot;/list&quot;)
    public TableDataInfo list(Course course) &#123;
        startPage();
        List&lt;Course&gt; list = courseService.selectCourseList(course);
        return getDataTable(list);
    &#125;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>菜单名称</th>
<th>排序</th>
<th>权限标识</th>
</tr>
</thead>
<tbody><tr>
<td>课程管理</td>
<td>1</td>
<td>course:course:list</td>
</tr>
<tr>
<td>课程管理查询</td>
<td>1</td>
<td>course:course:query</td>
</tr>
<tr>
<td>课程管理新增</td>
<td>2</td>
<td>course:course:add</td>
</tr>
<tr>
<td>课程管理修改</td>
<td>3</td>
<td>course:course:edit</td>
</tr>
<tr>
<td>课程管理删除</td>
<td>4</td>
<td>course:course:remove</td>
</tr>
<tr>
<td>课程管理导出</td>
<td>5</td>
<td>course:course:export</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/623caf468a6f636c5fe27e119368bfabc1e20aa2/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg"></p>
<pre><code class="java">PermissionService.java
源码解读在后期

/**
 * RuoYi首创 自定义权限实现，ss取自SpringSecurity首字母
 * 
 * @author ruoyi
 */
@Service(&quot;ss&quot;)
public class PermissionService
&#123;
    /**
     * 验证用户是否具备某权限
     * 
     * @param permission 权限字符串
     * @return 用户是否具备某权限
     */
    public boolean hasPermi(String permission)
    &#123;
        if (StringUtils.isEmpty(permission))
        &#123;
            return false;
        &#125;
        LoginUser loginUser = SecurityUtils.getLoginUser();
        if (StringUtils.isNull(loginUser) || CollectionUtils.isEmpty(loginUser.getPermissions()))
        &#123;
            return false;
        &#125;
        PermissionContextHolder.setContext(permission);
        return hasPermissions(loginUser.getPermissions(), permission);
    &#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7e976e8ec0b1bb90abd5f6fc94d23c9b8ba39a8b/%E5%89%8D%E5%90%8E%E8%81%94%E8%B0%83.jpg"></p>
<h3 id="二次开发-——-苍穹外卖"><a href="#二次开发-——-苍穹外卖" class="headerlink" title="二次开发 —— 苍穹外卖"></a>二次开发 —— 苍穹外卖</h3><h5 id="若依框架修改器"><a href="#若依框架修改器" class="headerlink" title="若依框架修改器"></a>若依框架修改器</h5><ul>
<li>若依框架修改器是一个可以一键修改RuoYi框架包名、项目名等的工具</li>
</ul>
<blockquote>
<p>E:\Java实例项目1-20套\2024-Java若依框架专题课\01-基础篇\资料\04-二次开发\若依框架修改器.exe</p>
</blockquote>
<pre><code class="java">选择系列：RuoYi-Vue
目录名称: sky
项目名：sky
包名：com.sky
artifactId：sky
groupId：com.sky
站点名称：外卖管理系统


C:\Users\Pluminary\Desktop\20241108150415\sky
</code></pre>
<h5 id="新建业务模块"><a href="#新建业务模块" class="headerlink" title="新建业务模块"></a>新建业务模块</h5><ul>
<li><p>新建<code>sky-merchant</code>子模块<del>商家管理</del></p>
<ul>
<li><p>新建子模块<br><code>sky-merchant</code> → Advanced Settings → GroupId：com.sky</p>
</li>
<li><p>父工程版本锁定</p>
<pre><code class="xml">pom.xml(sky总)
&lt;!-- 商家管理--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.sky&lt;/groupId&gt;
                &lt;artifactId&gt;sky-merchant&lt;/artifactId&gt;
                &lt;version&gt;$&#123;sky.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">pom.xml(sky-merchant)
&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sky&lt;/groupId&gt;
            &lt;artifactId&gt;sky-framework&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
</li>
<li><p>sky-admin添加依赖</p>
<pre><code class="xml">pom.xml(sky-admin) 
&lt;dependency&gt;
            &lt;groupId&gt;com.sky&lt;/groupId&gt;
            &lt;artifactId&gt;sky-merchant&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h3><ul>
<li><strong>利用若依代码生成器(主子表模板)，生成菜品管理的前后端代码</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">tb_dish【菜品管理】</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><span style = "color:red"><strong>id</strong></span></td>
</tr>
<tr>
<td align="left">name</td>
</tr>
<tr>
<td align="left">price</td>
</tr>
<tr>
<td align="left">image</td>
</tr>
<tr>
<td align="left">description</td>
</tr>
<tr>
<td align="left">status</td>
</tr>
<tr>
<td align="left">create_time</td>
</tr>
<tr>
<td align="left">update_time</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>tb_dish_flavor【菜品口味关系表】</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
</tr>
<tr>
<td><span style = "color:red"><strong>dish_id</strong></span></td>
</tr>
<tr>
<td>name</td>
</tr>
<tr>
<td>value</td>
</tr>
</tbody></table>
<ul>
<li><p>准备SQL并导入数据库</p>
<blockquote>
<p>E:\Java实例项目1-20套\2024-Java若依框架专题课\01-基础篇\资料\04-二次开发\菜品管理</p>
</blockquote>
</li>
<li><p>配置代码生成信息【主子表的生成】</p>
<blockquote>
<p>在若依代码生成 → 导入表<strong>tb_dish</strong> 和 <strong>tb_dish_flavor</strong></p>
</blockquote>
</li>
<li><p>下载代码并导入项目</p>
</li>
<li><p>修改代码 → 系统工具 → 代码生成 → 菜品管理(修改) → </p>
<blockquote>
<p>基本信息：实体类名称→Dish     作者→itheima</p>
</blockquote>
<p>字段信息<del>参考页面原型生成</del> → 系统管理 → 字典管理 →</p>
<blockquote>
<p>字典名称：售卖状态<br>字典类型：dish_status<br>第二页点进去售卖状态的字典类型 dish_status → 新增</p>
<blockquote>
<p>数据标签：停售  +  起售<br>数据键值：0  +  1<br>显示排序：1  +  2</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>​      回到系统工具 → 代码生成 → 菜品管理修改 → 售卖状态 → 显示类型：下拉框 → 字典类型：售卖状态</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f50e3c057b0a8fae3fb16f4e3bcc1c9b507ed227/%E8%8F%9C%E5%8D%95%E8%8B%A5%E4%BE%9D%E4%BD%BF%E7%94%A8.jpg"></p>
<p>→ 代码生成 → 修改菜单配置信息 → 菜品</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/26b0d18887d1c565926b28e8d450fa2a773ccadb/%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%93%81.jpg"></p>
<p>→ 上面的生成信息</p>
<blockquote>
<p>生成模板：主子表<br>生成模块名：merchant<br>生成业务名：dish<br>关联子表的表名：tb_dish_flavor：菜品口味关系表<br>子表关联的外键名：dish_id：菜品</p>
</blockquote>
<p>→ 在代码生成 → tb_dish_flavor菜品口味关系表 → 点击编辑</p>
<blockquote>
<p>基本信息：<br>实体名：DishFalvor</p>
</blockquote>
<p>→ 生成代码(main后端 + vue前端 + dishMenu.sql数据库动态菜单) → 动态sql导入进去 → 前端vue将merchant导入到.&#x2F;src&#x2F;api中，将views导入到views中 → 在前端中将java和resources导入到merchant模块中</p>
<h4 id="对菜品管理进行升级改造"><a href="#对菜品管理进行升级改造" class="headerlink" title="对菜品管理进行升级改造"></a>对菜品管理进行升级改造</h4><h6 id="主键隐藏掉-售价前缀￥-修改时间时分秒"><a href="#主键隐藏掉-售价前缀￥-修改时间时分秒" class="headerlink" title="主键隐藏掉 售价前缀￥ 修改时间时分秒"></a>主键隐藏掉 售价前缀￥ 修改时间时分秒</h6><pre><code class="java">src\views\merchant\dish\index.vue 
把  &lt;el-table-column label=&quot;主键&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;  打注释符
////////////////////////////////////////////////////////////////////////////
插入￥流程：
&lt;el-table-column label=&quot;售价&quot; align=&quot;center&quot; prop=&quot;price&quot; /&gt; 修改为 →
&lt;el-table-column label=&quot;售价&quot; align=&quot;center&quot; prop=&quot;price&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;div&gt;
            ￥&#123;&#123; scope.row.price &#125;&#125;
          &lt;/div&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
通义灵码操作：
先解析那行代码，然后输入使用vue3语法在售价前显示￥
////////////////////////////////////////////////////////////////////////////
生成年月日时分秒：
&lt;el-table-column label=&quot;更新时间&quot; align=&quot;center&quot; prop=&quot;updateTime&quot; width=&quot;180&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;span&gt;&#123;&#123; parseTime(scope.row.updateTime, '&#123;y&#125;-&#123;m&#125;-&#123;d&#125;') &#125;&#125;&lt;/span&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
修改为：

</code></pre>
<h6 id="修改图片回显bug"><a href="#修改图片回显bug" class="headerlink" title="修改图片回显bug"></a>修改图片回显bug</h6><blockquote>
<p>新增毛血旺的图片若依默认保存在了本地服务器而不是阿里云上<br><code>/profile/upload/2024/11/10/毛血旺_20241110093243A001.jpg</code></p>
<p>C:\Users\Pluminary\Desktop\20241108150415\sky\sky-admin\src\main\resources\application.yml</p>
<pre><code class="yaml"># 项目相关配置
ruoyi:
  # 名称
  name: RuoYi
  # 版本
  version: 3.8.8
  # 版权年份
  copyrightYear: 2024
  # 文件路径 示例（ Windows配置D:/ruoyi/uploadPath，Linux配置 /home/ruoyi/uploadPath）
  profile: D:/ruoyi/uploadPath
  # 获取ip地址开关
  addressEnabled: false
  # 验证码类型 math 数字计算 char 字符验证
  captchaType: math
</code></pre>
<p><code>D:\ruoyi\uploadPath\upload\2024\11\10</code><br>文件上传组件标签修改 增加<code>&amp;&amp; item.indexOf(&quot;http&quot;) === -1</code></p>
<pre><code class="js">watch(() =&gt; props.modelValue, val =&gt; &#123;
  if (val) &#123;
    // 首先将值转为数组
    const list = Array.isArray(val) ? val : props.modelValue.split(&quot;,&quot;);
    // 然后将数组转为对象数组
    fileList.value = list.map(item =&gt; &#123;
      if (typeof item === &quot;string&quot;) &#123;
        if (item.indexOf(baseUrl) === -1 &amp;&amp; item.indexOf(&quot;http&quot;) === -1) &#123;
          item = &#123; name: baseUrl + item, url: baseUrl + item &#125;;
        &#125; else &#123;
          item = &#123; name: item, url: item &#125;;
        &#125;
      &#125;
      return item;
    &#125;);
  &#125; else &#123;
    fileList.value = [];
    return [];
  &#125;
&#125;,&#123; deep: true, immediate: true &#125;);
</code></pre>
</blockquote>
<h6 id="修改口味列表数组格式-改为下拉框的口味搭配"><a href="#修改口味列表数组格式-改为下拉框的口味搭配" class="headerlink" title="修改口味列表数组格式 改为下拉框的口味搭配"></a>修改口味列表数组格式 改为下拉框的口味搭配</h6><pre><code class="js">src\views\merchant\dish\index.vue
//------------------------------------------------
// 定义口味名称和口味列表静态数据
const dishFlavorListSelect = ref([
  &#123;name:&quot;辣度&quot;, value:[&quot;不辣&quot;,&quot;微辣&quot;,&quot;中辣&quot;,&quot;重辣&quot;]&#125;,
  &#123;name:&quot;忌口&quot;, value:[&quot;不要葱&quot;,&quot;不要蒜&quot;,&quot;不要香菜&quot;,&quot;不要辣&quot;]&#125;,
  &#123;name:&quot;甜味&quot;, value:[&quot;无糖&quot;,&quot;少糖&quot;,&quot;半糖&quot;]&#125;
]);
//------------------------------------------------
</code></pre>
<pre><code class="js">src\views\merchant\dish\index.vue
&lt;template #default=&quot;scope&quot;&gt;
      &lt;!-- &lt;el-input v-model=&quot;scope.row.name&quot; placeholder=&quot;请输入口味名称&quot; /&gt; --&gt;
               &lt;!-- label是最终看到下拉框的内容 value是用户提交的内容 --&gt;
           &lt;el-select v-model=&quot;scope.row.name&quot;  placeholder=&quot;请选择口味名称&quot;&gt;
                &lt;el-option
                  v-for=&quot;dishFlavor in dishFlavorListSelect&quot;
                  :key=&quot;dishFlavor.name&quot;
                  :label=&quot;dishFlavor.name&quot; 
                  :value=&quot;dishFlavor.name&quot;
                &gt;
                &lt;/el-option&gt;
            &lt;/el-select&gt;
           &lt;/template&gt;
       &lt;/el-table-column&gt;
</code></pre>
<pre><code class="js">src\views\merchant\dish\index.vue【修改当选中辣度时候 后面的规格】
// 存储当前选中口味列表数组
const checkValueList = ref([]);
// 定义改变口味名称时更新当前选中的口味列表
function changeFlavorName(row)&#123;
  // 清空当前行的value
  row.value = [];
  // 根据选中的name去查找静态数据的value
  checkValueList.value = dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;
&#125;
</code></pre>
<pre><code class="js">//增加了一个 @change   注意：如果是多选框一定要 → multiple

&lt;el-table-column label=&quot;口味名称&quot; prop=&quot;name&quot; width=&quot;150&quot;&gt;
            &lt;template #default=&quot;scope&quot;&gt;
              &lt;!-- &lt;el-input v-model=&quot;scope.row.name&quot; placeholder=&quot;请输入口味名称&quot; /&gt; --&gt;
               &lt;!-- label是最终看到下拉框的内容 value是用户提交的内容 --&gt;
               &lt;el-select v-model=&quot;scope.row.name&quot;  placeholder=&quot;请选择口味名称&quot;
               @change=&quot;changeFlavorName(scope.row)&quot;&gt;
                &lt;el-option
                  v-for=&quot;dishFlavor in dishFlavorListSelect&quot;
                  :key=&quot;dishFlavor.name&quot;
                  :label=&quot;dishFlavor.name&quot; 
                  :value=&quot;dishFlavor.name&quot;
                &gt;
                &lt;/el-option&gt;
               &lt;/el-select&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;口味列表&quot; prop=&quot;value&quot; width=&quot;150&quot;&gt;
            &lt;template #default=&quot;scope&quot;&gt;
              &lt;!-- &lt;el-input v-model=&quot;scope.row.value&quot; placeholder=&quot;请输入口味列表&quot; /&gt; --&gt;
          &lt;el-select v-model=&quot;scope.row.value&quot;  placeholder=&quot;请选择口味列表&quot; multiple&gt;
                &lt;el-option
                  v-for=&quot;value in checkValueList&quot;
                  :key=&quot;value&quot;
                  :label=&quot;value&quot; 
                  :value=&quot;value&quot;
                /&gt;
          &lt;/el-select&gt;
          &lt;/template&gt;
          &lt;/el-table-column&gt;
</code></pre>
<pre><code class="js">//------------------------------------------------
// 定义口味名称和口味列表静态数据
const dishFlavorListSelect = ref([
  &#123;name:&quot;辣度&quot;, value:[&quot;不辣&quot;,&quot;微辣&quot;,&quot;中辣&quot;,&quot;重辣&quot;]&#125;,
  &#123;name:&quot;忌口&quot;, value:[&quot;不要葱&quot;,&quot;不要蒜&quot;,&quot;不要香菜&quot;,&quot;不要辣&quot;]&#125;,
  &#123;name:&quot;甜味&quot;, value:[&quot;无糖&quot;,&quot;少糖&quot;,&quot;半糖&quot;]&#125;
]);


// 存储当前选中口味列表数组
const checkValueList = ref([]);
// 定义改变口味名称时更新当前选中的口味列表
function changeFlavorName(row)&#123;
  // 根据选中的name去查找静态数据的value
  checkValueList.value =       dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;
&#125;
//------------------------------------------------
</code></pre>
<pre><code class="java">// 此时报错了 
11:59:00.441 [http-nio-8080-exec-64] ERROR c.s.f.w.e.GlobalExceptionHandler - [handleRuntimeException,100] - 请求地址&#39;/merchant/dish&#39;,发生未知异常.
org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.lang.String` from Array value (token `JsonToken.START_ARRAY`); nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize value of type `java.lang.String` from Array value (token `JsonToken.START_ARRAY`)
 at [Source: (org.springframework.util.StreamUtils$NonClosingInputStream); line: 1, column: 239] (through reference chain: com.sky.system.domain.Dish[&quot;dishFlavorList&quot;]-&gt;java.util.ArrayList[0]-&gt;com.sky.system.domain.DishFlavor[&quot;value&quot;])
    
/*
根据错误日志，问题出在请求地址 /merchant/dish 处理过程中，JSON 解析时出现了类型不匹配的问题。具体来说，Dish 对象中的 dishFlavorList 字段下的 DishFlavor 对象的 value 字段期望接收一个 String 类型的值，但实际接收到的是一个数组。
*/
</code></pre>
<h6 id="解决序列化问题bug将口味列表中value通过JSON工具类转换为字符串"><a href="#解决序列化问题bug将口味列表中value通过JSON工具类转换为字符串" class="headerlink" title="解决序列化问题bug将口味列表中value通过JSON工具类转换为字符串"></a>解决序列化问题bug<del>将口味列表中value通过JSON工具类转换为字符串</del></h6><p>提交数据后是字符串 而不是数组</p>
<pre><code class="js">在331行
/** 提交按钮 */
function submitForm() &#123;
  proxy.$refs[&quot;dishRef&quot;].validate(valid =&gt; &#123;
    if (valid) &#123;
      form.value.dishFlavorList = dishFlavorList.value;
      // 将口味列表中value通过JSON工具类转换为字符串
      form.value.dishFlavorList.forEach(item=&gt;item.value = JSON.stringify(item.value))
      if (form.value.id != null) &#123;
        updateDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;修改成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125; else &#123;
        addDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;新增成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125;
    &#125;
  &#125;);
</code></pre>
<h6 id="解决后端添加成功后-修改后口味列表无法回显再增加个非空判断"><a href="#解决后端添加成功后-修改后口味列表无法回显再增加个非空判断" class="headerlink" title="解决后端添加成功后 修改后口味列表无法回显再增加个非空判断"></a>解决后端添加成功后 修改后口味列表无法回显<del>再增加个非空判断</del></h6><p>因为前端提交了字符串給后端，后端再回去修改的时候无法解析字符串 <code>拿到字符串后返回JSON数组即可</code></p>
<pre><code class="js">/** 修改按钮操作 */
function handleUpdate(row) &#123;
  reset();
  const _id = row.id || ids.value
  getDish(_id).then(response =&gt; &#123;
    form.value = response.data;
    dishFlavorList.value = response.data.dishFlavorList;
    // 将口味列表的value字符串转成json数组
    if(dishFlavorList.value!=null)&#123;
      form.value.dishFlavorList.forEach(item=&gt;item.value = JSON.parse(item.value))
    &#125;
    open.value = true;
    title.value = &quot;修改菜品管理&quot;;
  &#125;);
&#125;

/** 提交按钮 */
function submitForm() &#123;
  proxy.$refs[&quot;dishRef&quot;].validate(valid =&gt; &#123;
    if (valid) &#123;
      form.value.dishFlavorList = dishFlavorList.value;
      // 将口味列表中value通过JSON工具类转换为字符串
      if(form.value.dishFlavorList!=null)&#123;
        form.value.dishFlavorList.forEach(item=&gt;item.value = JSON.stringify(item.value))
      &#125;
      if (form.value.id != null) &#123;
        updateDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;修改成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125; else &#123;
        addDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;新增成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125;
    &#125;
  &#125;);
&#125;
</code></pre>
<h6 id="解决修改时无法修改口味列表的下拉框"><a href="#解决修改时无法修改口味列表的下拉框" class="headerlink" title="解决修改时无法修改口味列表的下拉框"></a>解决修改时无法修改口味列表的下拉框</h6><blockquote>
<p>給口味下拉框绑定一个获取焦点事件 再该事件内调用方法根据当前行的口味名称去查询静态数据 再赋值給静态数组</p>
</blockquote>
<pre><code class="js">// 删除清除策略
// 定义口味列表获取焦点时更新当前选中的口味列表
function FocusFlavorName(row)&#123;
  // 根据选中的name去查找静态数据的value
  checkValueList.value = dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;
&#125;
</code></pre>
<pre><code class="js">// 加个 @focus
&lt;el-table-column label=&quot;口味列表&quot; prop=&quot;value&quot; width=&quot;150&quot;&gt;
            &lt;template #default=&quot;scope&quot;&gt;
              &lt;!-- &lt;el-input v-model=&quot;scope.row.value&quot; placeholder=&quot;请输入口味列表&quot; /&gt; --&gt;
              &lt;el-select v-model=&quot;scope.row.value&quot;  placeholder=&quot;请选择口味列表&quot; multiple
              @focus = &quot;FocusFlavorName(scope.row)&quot;&gt;
                &lt;el-option
                  v-for=&quot;value in checkValueList&quot;
                  :key=&quot;value&quot;
                  :label=&quot;value&quot; 
                  :value=&quot;value&quot;
                /&gt;
               &lt;/el-select&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
</code></pre>
<h3 id="二次开发——页面调整"><a href="#二次开发——页面调整" class="headerlink" title="二次开发——页面调整"></a>二次开发——页面调整</h3><h6 id="将原有的页面，调整为外卖管理系统的项目标识"><a href="#将原有的页面，调整为外卖管理系统的项目标识" class="headerlink" title="将原有的页面，调整为外卖管理系统的项目标识"></a>将原有的页面，调整为外卖管理系统的项目标识</h6><ul>
<li>浏览器标签页icon、标题</li>
<li>系统页面中的logo、标题</li>
<li>去除源码 &amp; 文档 </li>
<li>主题和自定义图标</li>
<li>登录页面中标题、背景图</li>
</ul>
<blockquote>
<p><strong>icon</strong>：public中的favicon.ico 改为 favicon.ico.bak 就作废了<br>把新的图标复制进来改成favicon.ico</p>
<p><strong>标题</strong>：最外层index.html<br>&lt; title&gt; 外卖管理系统 &lt; &#x2F;title&gt;<br>但是改完没有效果 是因为运行环境給覆盖了<br><code>.env.development</code>修改一下</p>
<p><strong>logo</strong>放在了静态资源页面<br>src\assets\logo\logo.png</p>
<p><strong>修改顶部源码和文档图标内容</strong><br>src\layout\components\Navbar.vue</p>
<pre><code class="js">&lt;!-- &lt;el-tooltip content=&quot;源码地址&quot; effect=&quot;dark&quot; placement=&quot;bottom&quot;&gt;
          &lt;ruo-yi-git id=&quot;ruoyi-git&quot; class=&quot;right-menu-item hover-effect&quot; /&gt;
        &lt;/el-tooltip&gt;

        &lt;el-tooltip content=&quot;文档地址&quot; effect=&quot;dark&quot; placement=&quot;bottom&quot;&gt;
          &lt;ruo-yi-doc id=&quot;ruoyi-doc&quot; class=&quot;right-menu-item hover-effect&quot; /&gt;
        &lt;/el-tooltip&gt; --&gt;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a><br>下载一个<strong>菜品管理的小图标</strong><br>然后给它复制进去src\assets\icons\svg\菜品管理.svg<br>随后回到菜单管理修改图标就好</p>
<p><strong>登录界面图片修改：</strong><br>src\views\login.vue 修改一下标题<br>背景图 → src\assets\images\login-background1.jpg<br>通过css样式修改背景图<br>171行<br> <code>background-image: url(&quot;../assets/images/login-background.jpg&quot;);</code><br>修改为<br><code> background-image: url(&quot;../assets/images/login-background1.jpg&quot;);</code></p>
<pre><code class="css">.login &#123;
  display: flex;
  justify-content: right;
  align-items: center;
  height: 100%;
  background-image: url(&quot;../assets/images/login-background1.jpg&quot;);
  background-size: cover;
&#125;
</code></pre>
</blockquote>
<h6 id="給外卖商家的员工创建角色和用户分配菜单的权限-登录后只能看到自己的功能"><a href="#給外卖商家的员工创建角色和用户分配菜单的权限-登录后只能看到自己的功能" class="headerlink" title="給外卖商家的员工创建角色和用户分配菜单的权限 登录后只能看到自己的功能"></a>給外卖商家的员工创建角色和用户分配菜单的权限 登录后只能看到自己的功能</h6><blockquote>
<p>系统管理 → 角色管理 →  新增 →<br>角色名称：商家员工<br>权限字符串：merchant<br>角色顺序：4<br>菜单权限：父子联动<br>√ 菜品管理</p>
<p>再到用户管理 → 新增 → 添加用户 →<br>用户昵称：波妞<br>用户名称：boniu<br>用户密码：admin123<br>角色：商家员工</p>
</blockquote>
<h1 id="帝可得"><a href="#帝可得" class="headerlink" title="帝可得"></a>帝可得</h1><ul>
<li><p>帝可得是一个基于<strong>物联网</strong>概念下的<strong>智能售货机</strong>运营管理系统</p>
<ul>
<li><p><strong>物联网</strong>(IOT)</p>
<p>让各种物品通过互联网链接起来，实现信息的交换和通信</p>
<ul>
<li>智能家居</li>
<li>共享充电桩</li>
<li>智能售货机</li>
</ul>
</li>
<li><p><strong>智能售货机</strong></p>
<p>是物联网技术的一个典型应用</p>
<ul>
<li>物联网技术</li>
<li>智能分析与推荐</li>
<li>人员设备绑定管理</li>
<li>线上线下融合</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="售货机术语"><a href="#售货机术语" class="headerlink" title="售货机术语"></a>售货机术语</h6><ul>
<li><p><strong>区域管理</strong></p>
<p>为了更高效地进行经营管理，公司将运营范围划分为若干个逻辑区域</p>
</li>
<li><p><strong>点位选择</strong></p>
<p>点位指的是智能售货机的具体放置位置</p>
</li>
<li><p><strong>售货机功能</strong></p>
<p>自动小店，摆满了各种零食</p>
</li>
<li><p><strong>货道设计</strong></p>
<p>售货机里的货道</p>
</li>
</ul>
</li>
</ul>
<h3 id="角色与功能"><a href="#角色与功能" class="headerlink" title="角色与功能"></a>角色与功能</h3><ul>
<li>一个完整的售货机系统由**<u>五端五角色</u>**组成:</li>
<li><strong>管理员</strong>：对基础数据(区域、点位、设备、货道、商品等)进行管理</li>
<li><strong>运维人员</strong>：投放设备、撤除设备、维修设备。</li>
<li><strong>运营人员</strong>：补货。</li>
<li><strong>合作商</strong>：仅提供点位，坐收渔翁之利。</li>
<li><strong>消费者</strong>：在小程序或屏幕端下单购买商品。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://ksg50j5gph.feishu.cn/docx/NxIqdCZVzo2tRfxNL6Nc1BD1nnf">帝可得在线功能文档_Docs</a></p>
<p>帝可得项目点击链接立即查看 <a target="_blank" rel="noopener" href="https://codesign.qq.com/s/426304924036117">https://codesign.qq.com/s/426304924036117</a></p>
<h3 id="库表设计"><a href="#库表设计" class="headerlink" title="库表设计"></a>库表设计</h3><ul>
<li>系统后台基础数据表关系说明：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e677e01fa90ed813fd68cab1fabdde7b958ec9df/%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%85%B3%E7%B3%BB%E8%AF%B4%E6%98%8E.png"></p>
<h3 id="AIGC"><a href="#AIGC" class="headerlink" title="AIGC"></a>AIGC</h3><ul>
<li><p><strong>AI</strong> (Artificial Intelligence)：即<strong>人工智能</strong>，是指通过计算机系统模拟人类<strong>思维</strong>和<strong>行为</strong>一种技术</p>
</li>
<li><p>它通过机器学习、深度学习等算法，使计算机具备对数据分析、理解、推理和决策的能力</p>
</li>
<li><p><strong>AIGC</strong> (AI Generated content)：是AI领域的一个应用分支，专注于利用AI技术自动生成内容</p>
</li>
<li><p>国内常见的通用大模型(AGI)产品：</p>
<ul>
<li>文心一言</li>
<li>讯飞星火</li>
<li>通义千问</li>
<li>KIMI</li>
</ul>
</li>
</ul>
<h3 id="Prompt的组成"><a href="#Prompt的组成" class="headerlink" title="Prompt的组成"></a>Prompt的组成</h3><ul>
<li><strong>角色</strong>：给 AI 定义一个最匹配任务的角色，比如：「你是一位软件工程师」「你是一位小学老师」</li>
<li><strong>指示</strong>：对任务进行描述</li>
<li><strong>上下文</strong>：给出与任务相关的其它背景信息（尤其在多轮交互中）</li>
<li><strong>例子</strong>：必要时给出举例，[实践证明其对输出正确性有帮助]</li>
<li><strong>输入</strong>：任务的输入信息；在提示词中明确的标识出输入</li>
<li><strong>输出</strong>：输出的格式描述，以便后继模块自动解析模型的输出结果，比如（JSON、Java）</li>
</ul>
<blockquote>
<p>先定义角色，其实就是在<strong>开头把问题域收窄</strong>，减少二义性。</p>
</blockquote>
<p><strong>案例：</strong></p>
<pre><code class="markdown">角色：你是一位专业的博客作者。

指示：撰写一篇关于最新AI技术发展的文章。

上下文：文章应该涵盖AI技术的当前状态和未来趋势。

例子：可以引用最近的AI技术突破和行业专家的见解。

输入：当前AI技术的相关信息和数据。

输出：一篇结构清晰、观点鲜明的文章草稿。
</code></pre>
<pre><code class="markdown">角色：你是一位资深的Java开发工程师。

指示：编写一个Java函数，该函数接收两个整数参数，并返回它们的和。

上下文：这个函数将被用于一个简单的数学应用程序，该程序帮助学生练习基本的算术运算。

例子：如果你调用函数 `addNumbers(3, 5)`，它应该返回 `8`。

输入：两个整数参数，分别为 `int a` 和 `int b`。

输出：返回这两个整数的和，类型为 `int`。
</code></pre>
<h3 id="常见的编程相关的Prompt"><a href="#常见的编程相关的Prompt" class="headerlink" title="常见的编程相关的Prompt"></a>常见的编程相关的Prompt</h3><h4 id="表结构-1"><a href="#表结构-1" class="headerlink" title="表结构"></a>表结构</h4><pre><code class="markdown">你是一个软件工程师，帮我生成MySQL的表结构
需求如下：
    1，课程管理表，表名tb_course，字段有主键id、课程编码、课程学科、课程名称、课程价格、适用人群、课程介绍
其他要求：
    1，每个表中都有创建时间(create_time)、修改时间(date_time)、创建人(create_by)、修改人(update_by)、备注(remark)这些字段
    2，每个表的主键都是自增的
    3，课程价格是整型、课程编码是字符串
    4，请为每个字段都添加上comment
    5，帮我给生成的表中插入一些IT课程示例数据
        课程学科：Java、人工智能、大数据
        适用人群：小白学员、中级程序员
</code></pre>
<h4 id="生成数据库说明文档"><a href="#生成数据库说明文档" class="headerlink" title="生成数据库说明文档"></a>生成数据库说明文档</h4><pre><code class="markdown">你是一个软件工程师，现在要根据数据库的sql脚本，编写数据库说明文档，sql脚本如下：
CREATE TABLE `tb_course` (
    `id` INT AUTO_INCREMENT COMMENT &#39;主键ID&#39;,
    `course_code` VARCHAR(255) NOT NULL COMMENT &#39;课程编码&#39;,
    `course_subject` VARCHAR(100) NOT NULL COMMENT &#39;课程学科&#39;,
    `course_name` VARCHAR(255) NOT NULL COMMENT &#39;课程名称&#39;,
    `course_price` INT COMMENT &#39;课程价格&#39;,
    `target_audience` VARCHAR(100) COMMENT &#39;适用人群&#39;,
    `course_introduction` TEXT COMMENT &#39;课程介绍&#39;,
    `create_time` DATETIME COMMENT &#39;创建时间&#39;,
    `update_time` DATETIME COMMENT &#39;修改时间&#39;,
    `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
    `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
    `remark` VARCHAR(255) COMMENT &#39;备注&#39;,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;课程管理表&#39;;

输出要求是：
    1，每个表以及每个表的字段都要详细说明，包括，字段名称、类型、作用
    2，使用markdown的输出格式，字段的描述需要使用表格展示
    3，如果表之间有关系，需要描述清楚表之间的关系
</code></pre>
<h4 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h4><p>代码生成算是比较常规的方案，用的也比较多，分为了几种情况</p>
<ul>
<li>给出表生成代码（项目中常见）<ul>
<li>给出表结构的ddl，可以输出这个表的增删改查的所有代码</li>
<li>给出表结构的dll，可以输出增删改查的接口文档</li>
</ul>
</li>
<li>补全代码<ul>
<li>例1-给出实体类，帮助编写getter、setter、toString、构造方法等等</li>
<li>例2-给出一个controller，帮助编写swagger注解等</li>
</ul>
</li>
<li>提取结构（无含金量，费时间的编程）<ul>
<li>例1-根据接口文档提取dto类或者vo类</li>
</ul>
</li>
</ul>
<h4 id="生成代码流程图"><a href="#生成代码流程图" class="headerlink" title="生成代码流程图"></a>生成代码流程图</h4><p>有一些比较复杂的业务流程，往往需要画出流程图，现在就可以使用ai协助我们画流程图</p>
<pre><code class="java">你是一个软件工程师，为了方便理解代码执行流程，需要给出代码执行的流程图，代码如下：
    // 创建工单
    @Transactional
    @Override
    public int insertTaskDto(TaskDto taskDto) &#123;
    //1. 查询售货机是否存在
    VendingMachine vm = vendingMachineService.selectVendingMachineByInnerCode(taskDto.getInnerCode());
    if (vm == null) &#123;
        throw new ServiceException(&quot;设备不存在&quot;);
    &#125;
    //2. 校验售货机状态与工单类型是否相符
    checkCreateTask(vm.getVmStatus(), taskDto.getProductTypeId());
    //3. 校验这台设备是否有未完成的同类型工单，如果存在则不能创建
    hasTask(taskDto.getInnerCode(), taskDto.getProductTypeId());
    //4. 校验员工是否存在
    Emp emp = empService.selectEmpById(taskDto.getUserId());
    if (emp == null) &#123;
        throw new ServiceException(&quot;员工不存在&quot;);
    &#125;
    // 5. 校验非同区域下的工作人员不能接受工单
    if (emp.getRegionId() != vm.getRegionId()) &#123;
        throw new ServiceException(&quot;非同区域下的工作人员不能接受工单&quot;);
    &#125;
    //6. 保存工单信息
    Task task = new Task();
    BeanUtil.copyProperties(taskDto, task);// 属性赋值
    task.setCreateTime(DateUtils.getNowDate());// 创建时间
    task.setTaskCode(generateTaskCode());// 工单编号 202405150001
    task.setTaskStatus(DkdContants.TASK_STATUS_CREATE);// 创建工单
    task.setAddr(vm.getAddr());
    task.setRegionId(vm.getRegionId());
    task.setUserName(emp.getUserName());
    int taskResult = taskMapper.insertTask(task);
    //7. 如果是补货工单，向工单明细表插入记录
    if (task.getProductTypeId() == DkdContants.TASK_TYPE_SUPPLY) &#123;
        if (CollUtil.isEmpty(taskDto.getDetails())) &#123;
            throw new ServiceException(&quot;补货工单明细不能为空&quot;);
        &#125;
        List&lt;TaskDetails&gt; taskDetailsList = taskDto.getDetails().stream().map(details -&gt; &#123;
            TaskDetails taskDetails = BeanUtil.copyProperties(details, TaskDetails.class);
            taskDetails.setTaskId(task.getTaskId());
            return taskDetails;
        &#125;).collect(Collectors.toList());
        taskDetailsService.insertBatch(taskDetailsList);
    &#125;

    return taskResult;
&#125;

输出：请使用mermaid语言来描述这个方法的流程
</code></pre>
<pre><code class="mermaid">graph TD;
    A[查询售货机] --&gt; B(售货机不存在?)
    B -- 是 --&gt; C[抛出异常: 设备不存在]
    B -- 否 --&gt; D[校验售货机状态与工单类型]
    D --&gt; E(校验失败?)
    E -- 是 --&gt; F[抛出异常]
    E -- 否 --&gt; G[检查未完成同类型工单]
    G --&gt; H(存在未完成同类型工单?)
    H -- 是 --&gt; I[抛出异常]
    H -- 否 --&gt; J[查询员工]
    J --&gt; K(员工不存在?)
    K -- 是 --&gt; L[抛出异常: 员工不存在]
    K -- 否 --&gt; M[校验员工区域与售货机区域是否一致]
    M --&gt; N(不一致?)
    N -- 是 --&gt; O[抛出异常: 非同区域工作人员不能接受工单]
    N -- 否 --&gt; P[保存工单信息]
    P --&gt; Q(保存成功?)
    Q -- 否 --&gt; R[处理保存失败]
    Q -- 是 --&gt; S(工单类型为补货?)
    S -- 是 --&gt; T[处理补货工单明细]
    T --&gt; U[补货明细处理结果?]
    U -- 失败 --&gt; V[抛出异常: 补货工单明细不能为空]
    U -- 成功 --&gt; END(结束)
    S -- 否 --&gt; END
</code></pre>
<h3 id="项目搭建-后端"><a href="#项目搭建-后端" class="headerlink" title="项目搭建(后端)"></a>项目搭建(后端)</h3><blockquote>
<p>复制gitee克隆的地址<code>https://gitee.com/Pluminary/dkd-parent.git</code>，在新的idea中找到<code>Get from Version Control</code>在URL中导入<code>xxx.git</code><br>若左列模块没有高亮 右侧找maven→clean→package<br>MySQL的配置和导入 → sql里的sql文件导入到Database<br>C:\Users\Pluminary\Desktop\dkd-parent\dkd-admin\src\main\resources\application-druid.yml<br>连接好数据库配置信息<br>Redis的配置(搞个密码)<br>为了方便学习我没有搞redis的password 项目里的是：root【application.yml的redis里面】<br>打开redis服务后就可以启动啦<code>dkd-parent\dkd-admin\src\main\java\com\dkd\DkdApplication.java</code></p>
</blockquote>
<h3 id="项目搭建-前端"><a href="#项目搭建-前端" class="headerlink" title="项目搭建(前端)"></a>项目搭建(前端)</h3><blockquote>
<p>通过vscode克隆源码，仓库地址：<a target="_blank" rel="noopener" href="https://gitee.com/ys-gitee/dkd-vue.git/">https://gitee.com/ys-gitee/dkd-vue.git\</a></p>
<ul>
<li>打开VS Code，并确保已经安装了Git。如果未安装Git，请先下载并安装。</li>
<li>在VS Code<strong>左侧的活动栏</strong>中点击”Source Control”图标，或者按下Ctrl+Shift+G，打开Git集成面板。</li>
<li>在Git集成面板上方的输入框中，选择并输入要克隆的Git仓库地址。可以是HTTP或SSH地址。</li>
<li>点击Enter键，VS Code将连接到Git仓库并拉取最新的代码</li>
</ul>
<p>在vscode中右上角第二个小框框 点击打开命令行 导入jar包 <code>npm install</code><br>然后<code>npm run dev</code>打开项目<br><a target="_blank" rel="noopener" href="http://10.254.1.228/index">帝可得管理系统 http://10.254.1.228/index</a></p>
<pre><code class="java">在VSCode项目中运行npm install命令主要是用于安装项目所需的Node.js包依赖。以下是具体的作用和步骤：

安装依赖包：当你创建一个Node.js项目或者从版本控制系统中克隆一个项目到本地时，项目中通常会包含一个package.json文件。这个文件里列出了项目所有依赖的包及其版本号。运行npm install命令会读取这个文件，然后从npm（Node Package Manager）仓库下载并安装所有列出的依赖包到项目的node_modules目录。

确保环境一致性：通过npm install，可以确保在不同的开发环境和生产环境中，项目使用的是相同版本的依赖包，这有助于避免因为环境差异导致的bug。

项目初始化：如果你是第一次在一个项目中运行npm install，它还会运行每个依赖包的install脚本，这些脚本可能会进行一些设置工作，比如编译代码、生成必要的文件等。

脚本命令：在package.json中，除了依赖项，还可以定义一些脚本命令（scripts）。npm install会使得这些命令变为可用状态，你可以在项目目录下通过npm run &lt;script-name&gt;来执行这些脚本。
</code></pre>
<p>[npm 加速，命令行修改国内镜像源【附带国内最新几个镜像】超简约版<del>_npm 修改国内镜像-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52172586/article/details/142930356#">https://blog.csdn.net/m0_52172586/article/details/142930356#</a>:</del>:text&#x3D;1.查看目前的镜像源 &gt;npm get registry 2.设置镜像源 &gt;npm,config set registry https%3A %2F%2Fregistry.npmmirror.com 3.验证)</p>
<pre><code class="java">1.查看目前的镜像源
&gt; npm get registry
2.设置镜像源
&gt; npm config set registry https://registry.npmmirror.com
3.验证
&gt; npm get registry
    
/////////////////////////////////////////
后端maven镜像就先设置好maven地址(非C盘)
然后再去配置maven里的文件设置镜像
</code></pre>
</blockquote>
<h1 id="点位管理"><a href="#点位管理" class="headerlink" title="点位管理"></a>点位管理</h1><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p><strong>业务场景</strong>： 假设我们的公司现在有一个宏伟的计划——在北京发展业务。首先，我们需要确定几个有潜力的区域，这些区域可能是人流量大、消费能力高的商业区或居民区。然后，我们要与这些区域内的潜在合作商进行洽谈，比如商场、写字楼、学校等地方的管理者或所有者。</p>
<p>一旦我们与合作商达成协议，确定了合作的细节和点位，我们就可以安排工作人员去投放智能售货机了。这些点位将成为我们智能售货机的“家”，为消费者提供便捷的购买服务。</p>
<p>点位管理主要涉及到三个功能模块，业务流程如下：</p>
<ol>
<li><strong>登录系统</strong>：后台管理人员登录后台系统</li>
<li><strong>新增区域</strong>: 后台管理人员可以添加区域范围，区域范围与运维&#x2F;运维人员挂钩，区域下可关联点位。</li>
<li><strong>新增合作商</strong>: 管理人员可以添加合作商，合作商与点位进行关联。</li>
<li><strong>新增区域点位</strong>: 后台管理人员可以在特定区域内新增点位，这些点位是放置智能售货机的具体位置。</li>
</ol>
<pre><code class="mermaid">graph TD
    A[登录系统] 
    A --&gt; B[新增区域]
    B --&gt; C[新增合作商]
    C --&gt; D[新增区域点位]
</code></pre>
<h2 id="库表设计-1"><a href="#库表设计-1" class="headerlink" title="库表设计"></a>库表设计</h2><ul>
<li>参考页面原型和具体需求完成库表设计</li>
</ul>
<blockquote>
<p><strong>区域表</strong>: 主键id、区域名称、备注说明<br><strong>合作商表</strong>: 主键id、合作商名称、联系人、联系电话、分成比例、账号、密码<br><strong>点位表</strong>: 主键id、点位名称、详细地址、商圈类型、区域外键、合作商外键</p>
</blockquote>
<pre><code class="java">// 你是一位软件工程师，帮我生成MySQL的表结构
需求如下：
1，区域表，表名tb_region，字段有主键id、区域名称
2，合作商表，表名tb_partner，字段有主键id、合作商名称、联系人、联系电话、分成比例（int类型）、账号、密码
3，点位表，表名tb_node，字段有主键id、点位名称、详细地址、商圈类型（int类型）
    
其他要求：
1，每张表中都有创建时间(create_time)、修改时间(date_time)、创建人(create_by)、修改人(update_by)、备注(remark)这些字段
2，每张表的主键都是自增的
3，区域与点位是一对多的关系，合作商与点位是一对多的关系，请用字段表示出来，并建立外键约束
4，请为所有字段都添加上comment
5，帮我给生成的表中插入一些北京城市相关区域、点位、合作商的测试数据
</code></pre>
<pre><code class="sql">CREATE TABLE `tb_region` (
  `id` INT AUTO_INCREMENT COMMENT &#39;主键id&#39; PRIMARY KEY,
  `region_name` VARCHAR(255) NOT NULL COMMENT &#39;区域名称&#39;,
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
  `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
  `remark` TEXT COMMENT &#39;备注&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;区域表&#39;;

-- 插入测试数据
INSERT INTO `tb_region` (`region_name`,`remark`) VALUES (&#39;北京市朝阳区&#39;,&#39;北京市朝阳区&#39;), (&#39;北京市海淀区&#39;,&#39;北京市海淀区&#39;), (&#39;北京市东城区&#39;,&#39;北京市东城区&#39;);

CREATE TABLE `tb_partner` (
  `id` INT AUTO_INCREMENT COMMENT &#39;主键id&#39; PRIMARY KEY,
  `partner_name` VARCHAR(255) NOT NULL COMMENT &#39;合作商名称&#39;,
  `contact_person` VARCHAR(64) COMMENT &#39;联系人&#39;,
  `contact_phone` VARCHAR(15) COMMENT &#39;联系电话&#39;,
  `profit_ratio` INT COMMENT &#39;分成比例&#39;,
  `account` VARCHAR(64) COMMENT &#39;账号&#39;,
  `password` VARCHAR(64) COMMENT &#39;密码&#39;,
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
  `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
  `remark` TEXT COMMENT &#39;备注&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;合作商表&#39;;

-- 插入测试数据
INSERT INTO `tb_partner` (`partner_name`, `contact_person`, `contact_phone`, `profit_ratio`, `account`, `password`) VALUES
(&#39;合作商A&#39;, &#39;张三&#39;, &#39;13800138000&#39;, 30, &#39;a001&#39;, &#39;pwdA&#39;),
(&#39;合作商B&#39;, &#39;李四&#39;, &#39;13912345678&#39;, 25, &#39;b002&#39;, &#39;pwdB&#39;);

CREATE TABLE `tb_node` (
  `id` INT AUTO_INCREMENT COMMENT &#39;主键id&#39; PRIMARY KEY,
  `node_name` VARCHAR(255) NOT NULL COMMENT &#39;点位名称&#39;,
  `address` VARCHAR(255) NOT NULL COMMENT &#39;详细地址&#39;,
  `business_type` INT COMMENT &#39;商圈类型&#39;,
  `region_id` INT COMMENT &#39;区域ID&#39;,
  `partner_id` INT COMMENT &#39;合作商ID&#39;,
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
  `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
  `remark` TEXT COMMENT &#39;备注&#39;,
  FOREIGN KEY (`region_id`) REFERENCES `tb_region`(`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  FOREIGN KEY (`partner_id`) REFERENCES `tb_partner`(`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;点位表&#39;;


-- 插入测试数据
-- 假设区域ID为1对应&#39;北京市朝阳区&#39;，合作商ID为1对应&#39;合作商A&#39;
INSERT INTO `tb_node` (`node_name`, `address`, `business_type`, `region_id`, `partner_id`) VALUES
(&#39;三里屯点位&#39;, &#39;北京市朝阳区三里屯路&#39;, 1, 1, 1),
(&#39;五道口点位&#39;, &#39;北京市海淀区五道口&#39;, 2, 2, 2);
</code></pre>
<p>对于点位管理数据模型，下面是示意图：</p>
<ul>
<li><p>关系字段：region_id、partner_id</p>
</li>
<li><p>数据字典：business_type</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2aea3c59b88952c77f32514636619e7de0202c16/dkd%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1.jpg"></p>
<h3 id="生成基础代码"><a href="#生成基础代码" class="headerlink" title="生成基础代码"></a>生成基础代码</h3><h6 id="使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中："><a href="#使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中：" class="headerlink" title="使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中："></a>使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中：</h6><ul>
<li>创建目录菜单</li>
<li>添加数据字典</li>
<li>配置代码生成信息</li>
<li>下载代码并导入项目</li>
</ul>
<blockquote>
<p>系统管理 → 菜单管理 → 新增菜单<br>→ <u>主类目、点位管理、2、node</u></p>
<p>→ 系统管理 → 字典管理<br>→ <u>字典名称：商圈类型</u><br>     <u>字典类型：business_type</u><br>→ 在第二页找到商圈类型点进去<br>→ <u>新增：旅游区</u><br>     &lt;u<u>&gt;数据标签：旅游区</u><br>     <u>数据键值：1</u><br>     <u>显示排序：1</u><br>→ 新增：商场写字楼、2、2；学校33、交通枢纽44</p>
<p>→ 系统工具 → 代码生成 → 导入表(<u>tb_node、tb_partner、tb_region</u>)<br>分别配置表的生成信息<br>→ 点击<u><strong>区域表</strong></u> → <u>字段信息</u><br>→ 根据新增区域弹出菜单显示 需要增加<u>区域名称全打勾 备注说明除了查询全打勾 其余全×</u></p>
<p>→ 点击**<u>合作商表</u>** → 生成信息<br>→ <u>包路径：com.dkd.manage、生成模块名：manage、生成业务名：region、生成功能名：区域管理、上级菜单：点位管理</u><br>→ 代码生成：Partner<br>→  基本信息：<br><u>实体类名称：Partner</u><br><u>作者：itheima</u><br>→ 字段信息：见**<u>帝可得后台管理系统.md</u>**<br>→ 生成信息：<br><u>生成包路径：com.dkd.manage</u><br><u>生成模块名：manage</u><br><u>生成功能名：合作商管理</u><br><u>上级菜单：点位管理</u></p>
<p>→ 点击**<u>点位表</u>**<br>→ 生成信息：<br><u>生成包路径：com.dkd.manage</u><br><u>生成模块名：manage</u><br><u>生成功能名：点位管理</u><br><u>上级菜单：点位管理</u><br>→ 字段信息：见**<u>帝可得后台管理系统.md</u>**<br>→ 基本信息：<br><u>实体类名称：Node</u><br><u>表描述：点位表</u><br><u>作者：itheima</u></p>
<p>回到代码生成 选中三张表 生成！！<br>分别在前后端和数据库 导入java&#x2F;manage、vue&#x2F;manage、sql代码</p>
</blockquote>
<blockquote>
<p><strong>细节</strong>：如果当你创建一个模块以后 src.main.java里面没有任何代码 resources里面也没有 它提交仓库的时候是默认空的 所以可以手动添加一个占位符<code>.gitkeep</code>虽然什么都不是，但是可以提交空项目模块</p>
</blockquote>
<h3 id="区域管理改造"><a href="#区域管理改造" class="headerlink" title="区域管理改造"></a>区域管理改造</h3><h4 id="基础页面"><a href="#基础页面" class="headerlink" title="基础页面"></a>基础页面</h4><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul>
<li>参考页面原型，完成基础布局展示改造</li>
</ul>
<pre><code class="html">// 让前端页面自动排序
src\views\manage\region\index.vue
&lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
</code></pre>
<h5 id="区域管理改造-1"><a href="#区域管理改造-1" class="headerlink" title="区域管理改造"></a>区域管理改造</h5><ul>
<li><p>查看详情，需要显示所有区域下所有点位列表(<strong>稍后完成</strong>)</p>
</li>
<li><p><strong>在查询区域列表时，同时显示每个区域的点位数，还要新增查看详情</strong></p>
<p><span style="color:red; font-family: 'KaiTi';"><strong>修改<u>后端</u>要参考<u>接口文档</u>，修改<u>前端</u>要参考<u>产品原型</u></strong></span></p>
</li>
<li><p>实现此功能方案：</p>
<p>(1) <strong>同步存储</strong>在区域表中有点位数的字段，当点位发生变化时候，同步区域表中的点位数(<u>在tb_region里面新增一个<code>node_count</code></u> 方案可行考虑缺点：每次点位数据变化时都要更新区域表[增加了工作量]，添加数据不一致也会)<br>(2) <span style="color:red"><strong>关联查询</strong></span>编写关联查询语句，在mapper层封装</p>
</li>
</ul>
<p>SQL查询：先聚合统计每个区域的点位数，然后与区域表进行关联查询<br>[提前在idea中下面的通义灵码状态勾选 <code>本地补全模型</code>、<code>云端模型自动触发</code>]<br><span style="color:red; font-family: 'KaiTi';"><strong>数据库返回的数据 要结合前端所需要的返回数据来写</strong> </span><br><span style="color:blue; font-family: 'KaiTi';"><strong>比如接口文档需要返回remark id name nodeCount</strong> &#x3D;&#x3D;&gt; select r.id,r.region_name,r.remark,ifnull(n.node_count,0) as node_count</span></p>
<pre><code class="sql">-- 传统模式
-- 1.先聚合统计每个区域下的点位数
-- 确定查询表 tb_node
-- 确定分组字段 region_id
select region_id,count(*) as node_count from tb_node group by region_id;
-- 2.然后与区域表进行关联查询   内连接是两个表的交集
select r.id,r.region_name,r.remark,ifnull(n.node_count,0) as node_count 
   from tb_region r
left join (select region_id,count(*) as node_count 
   from tb_node group by region_id) n 
on r.id=n.region_id;

-- AI辅助编程模式
-- 查询区域表所有的信息,需要显示每个区域的点位数
SELECT r.*, COUNT(n.id) AS node_count FROM tb_region r LEFT JOIN tb_node n ON r.id = n.region_id GROUP BY r.id;
</code></pre>
<pre><code class="java">com/dkd/manage/domain/Region.java
package com.dkd.manage.domain;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import com.dkd.common.annotation.Excel;
import com.dkd.common.core.domain.BaseEntity;

/**
 * 区域管理对象 tb_region
 * 
 * @author itheima
 * @date 2024-11-12
 */
public class Region extends BaseEntity
&#123;
    private static final long serialVersionUID = 1L;

    /** 主键id */
    private Long id;

    /** 区域名称 */
    @Excel(name = &quot;区域名称&quot;)
    private String regionName;

    public void setId(Long id) 
    &#123;
        this.id = id;
    &#125;

    public Long getId() 
    &#123;
        return id;
    &#125;
    public void setRegionName(String regionName) 
    &#123;
        this.regionName = regionName;
    &#125;

    public String getRegionName() 
    &#123;
        return regionName;
    &#125;

    @Override
    public String toString() &#123;
        return new ToStringBuilder(this,ToStringStyle.MULTI_LINE_STYLE)
            .append(&quot;id&quot;, getId())
            .append(&quot;regionName&quot;, getRegionName())
            .append(&quot;createTime&quot;, getCreateTime())
            .append(&quot;updateTime&quot;, getUpdateTime())
            .append(&quot;createBy&quot;, getCreateBy())
            .append(&quot;updateBy&quot;, getUpdateBy())
            .append(&quot;remark&quot;, getRemark())
            .toString();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/domain/vo/RegionVo.java
package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Region;
import lombok.Data;

@Data
public class RegionVo extends Region &#123;
    // 点位数量
    private Integer nodeCount;

&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/RegionMapper.java
/**
     * 查询区域列表
     * @param regionVo
     * @return
     */
    public List&lt;RegionVo&gt; selectRegionVoList(RegionVo regionVo);
</code></pre>
<pre><code class="xml">mapper/manage/RegionMapper.xml    
&lt;select id=&quot;selectRegionVoList&quot; resultType=&quot;com.dkd.manage.domain.vo.RegionVo&quot;&gt;
        SELECT r.*, COUNT(n.id) AS node_count FROM tb_region r LEFT JOIN tb_node n ON r.id = n.region_id GROUP BY r.id
    &lt;/select&gt;
</code></pre>
<h6 id="思考：上面的xml中提取的字段是-node-count-而前端让返回的是驼峰式命名-nodeCount-若依默认关闭了此功能需要手动开启此功能"><a href="#思考：上面的xml中提取的字段是-node-count-而前端让返回的是驼峰式命名-nodeCount-若依默认关闭了此功能需要手动开启此功能" class="headerlink" title="思考：上面的xml中提取的字段是 node_count 而前端让返回的是驼峰式命名 nodeCount,  若依默认关闭了此功能需要手动开启此功能"></a>思考：上面的xml中提取的字段是 <u>node_count</u> 而前端让返回的是驼峰式命名 <u>nodeCount</u>,  若依默认关闭了此功能需要手动开启此功能</h6><pre><code class="xml">dkd-parent → resources → mybatis → mybatis-config.xml
&lt;!-- 使用驼峰命名法转换字段 --&gt;
&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
</code></pre>
<h6 id="Ctrl-F9是热部署-在不新增文件的时候可以直接部署"><a href="#Ctrl-F9是热部署-在不新增文件的时候可以直接部署" class="headerlink" title="Ctrl+F9是热部署 在不新增文件的时候可以直接部署"></a>Ctrl+F9是热部署 在不新增文件的时候可以直接部署</h6><h4 id="RegionMapper"><a href="#RegionMapper" class="headerlink" title="RegionMapper"></a>RegionMapper</h4><pre><code class="java">/**
 * 查询区域管理列表
 * @param region
 * @return RegionVo集合
 */
public List&lt;RegionVo&gt; selectRegionVoList(Region region);
</code></pre>
<h4 id="RegionMapper-xml"><a href="#RegionMapper-xml" class="headerlink" title="RegionMapper.xml"></a>RegionMapper.xml</h4><pre><code class="xml">&lt;select id=&quot;selectRegionVoList&quot; resultType=&quot;com.dkd.manage.domain.vo.RegionVo&quot;&gt;
select r.id,r.region_name,r.remark,ifnull(n.node_count,0) as node_count from tb_region r
    left join (select region_id,count(*) as node_count from tb_node group by region_id) n on r.id=n.region_id
    &lt;where&gt;
       &lt;if test=&quot;regionName != null  and regionName != &#39;&#39;&quot;&gt; and r.region_name like concat(&#39;%&#39;, #&#123;regionName&#125;, &#39;%&#39;)&lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt; 
</code></pre>
<h4 id="IRegionService"><a href="#IRegionService" class="headerlink" title="IRegionService"></a>IRegionService</h4><pre><code class="java">/**
 * 查询区域管理列表
 * @param region
 * @return RegionVo集合
 */
public List&lt;RegionVo&gt; selectRegionVoList(Region region);
</code></pre>
<h4 id="RegionServiceImpl"><a href="#RegionServiceImpl" class="headerlink" title="RegionServiceImpl"></a>RegionServiceImpl</h4><pre><code class="java">/**
 * 查询区域管理列表
 * @param region
 * @return RegionVo集合
 */
@Override
public List&lt;RegionVo&gt; selectRegionVoList(Region region) &#123;
    return regionMapper.selectRegionVoList(region);
&#125;
</code></pre>
<h4 id="RegionController"><a href="#RegionController" class="headerlink" title="RegionController"></a>RegionController</h4><pre><code class="java">/**
 * 查询区域管理列表
 */
@PreAuthorize(&quot;@ss.hasPermi(&#39;manage:region:list&#39;)&quot;)
@GetMapping(&quot;/list&quot;)
public TableDataInfo list(Region region)
&#123;
    startPage();
    List&lt;RegionVo&gt; voList = regionService.selectRegionVoList(region);
    return getDataTable(voList);
&#125;
</code></pre>
<h4 id="region-x2F-index-vue"><a href="#region-x2F-index-vue" class="headerlink" title="region&#x2F;index.vue"></a>region&#x2F;index.vue</h4><pre><code class="vue">&lt;!-- 区域列表 --&gt;
&lt;el-table v-loading=&quot;loading&quot; :data=&quot;regionList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;
  &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
  &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
  &lt;el-table-column label=&quot;区域名称&quot; align=&quot;center&quot; prop=&quot;regionName&quot; /&gt;
  &lt;el-table-column label=&quot;点位数&quot; align=&quot;center&quot; prop=&quot;nodeCount&quot; /&gt;
  &lt;el-table-column label=&quot;备注说明&quot; align=&quot;center&quot; prop=&quot;remark&quot; /&gt;
  &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
      &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
      &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
    &lt;/template&gt;
  &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><strong>区域列表改造步骤</strong><ul>
<li>确定关联查询方案并编写sql</li>
<li>创建RegionVo</li>
<li>在RegionMapper和xml中添加查询Vo方法和sql</li>
<li>在RegionService接口和实现类中添加查询Vo方法</li>
<li>修改RegionController查询方法</li>
<li>修改前端视图组件</li>
</ul>
</li>
</ul>
<h3 id="合作商改造-查看详情"><a href="#合作商改造-查看详情" class="headerlink" title="合作商改造-查看详情"></a>合作商改造-查看详情</h3><h5 id="密码是明文-改成密文"><a href="#密码是明文-改成密文" class="headerlink" title="密码是明文 改成密文"></a>密码是明文 改成密文</h5><pre><code class="html">&lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;
   &lt;el-input v-model=&quot;form.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;
&lt;/el-form-item&gt;
</code></pre>
<h5 id="隐藏修改时的账号密码id存在时隐藏不存在显示-因为修改和新增共用了一个对话框ui"><a href="#隐藏修改时的账号密码id存在时隐藏不存在显示-因为修改和新增共用了一个对话框ui" class="headerlink" title="隐藏修改时的账号密码id存在时隐藏不存在显示,因为修改和新增共用了一个对话框ui"></a>隐藏修改时的账号密码<del>id存在时隐藏不存在显示,因为修改和新增共用了一个对话框ui</del></h5><pre><code class="html">&lt;el-form-item label=&quot;账号&quot; prop=&quot;account&quot; v-if=&quot;form.id==null&quot;&gt;
    &lt;el-input v-model=&quot;form.account&quot; placeholder=&quot;请输入账号&quot; /&gt;
&lt;/el-form-item&gt;
&lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot; v-if=&quot;form.id==null&quot;&gt;
    &lt;el-input v-model=&quot;form.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;
&lt;/el-form-item&gt;
</code></pre>
<h5 id="前端需要返回创建时间因为数据返回时有，用v-if判断是否修改显示创建时间"><a href="#前端需要返回创建时间因为数据返回时有，用v-if判断是否修改显示创建时间" class="headerlink" title="前端需要返回创建时间因为数据返回时有，用v-if判断是否修改显示创建时间"></a>前端需要返回创建时间<del>因为数据返回时有，用v-if判断是否修改显示创建时间</del></h5><pre><code class="html"> &lt;el-form-item label=&quot;创建时间&quot; prop=&quot;contactPhone&quot; v-if=&quot;form.id!=null&quot;&gt;
          &#123;&#123;form.createTime&#125;&#125;
        &lt;/el-form-item&gt;
</code></pre>
<h5 id="新增时保存的数据是以明文保存到了数据库此时新增的合作商就是密文了"><a href="#新增时保存的数据是以明文保存到了数据库此时新增的合作商就是密文了" class="headerlink" title="新增时保存的数据是以明文保存到了数据库此时新增的合作商就是密文了"></a>新增时保存的数据是以明文保存到了数据库<del>此时新增的合作商就是密文了</del></h5><pre><code class="java">com/dkd/manage/service/impl/PartnerServiceImpl.java  
/**
     * 新增合作商管理
     *
     * @param partner 合作商管理
     * @return 结果
     */
    @Override
    public int insertPartner(Partner partner) &#123;
        // 使用SpringSecurity工具类，对前端传入的密码进行加密
        partner.setPassword(SecurityUtils.encryptPassword(partner.getPassword()));
        partner.setCreateTime(DateUtils.getNowDate());
        return partnerMapper.insertPartner(partner);
    &#125;
</code></pre>
<h5 id="合作商管理改造—合作商详情"><a href="#合作商管理改造—合作商详情" class="headerlink" title="合作商管理改造—合作商详情"></a>合作商管理改造—合作商详情</h5><ul>
<li>查看详情，需要显示合作商名称、联系人、联系电话、分成比例</li>
<li>在查询合作商列表时，同时显示每个合作商的点位数</li>
<li>重置密码，初始密码为123456</li>
</ul>
<pre><code class="js">/** 借鉴修改流程
/** 修改按钮操作 */
function handleUpdate(row) &#123;
  reset();
  const _id = row.id || ids.value
  getPartner(_id).then(response =&gt; &#123;
    form.value = response.data;
    open.value = true;
    title.value = &quot;修改合作商管理&quot;;
  &#125;);
&#125;
</code></pre>
<pre><code class="html">&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
  &lt;template #default=&quot;scope&quot;&gt;
    &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;getPartnerInfo(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:partner:query&#39;]&quot;&gt;查看详情&lt;/el-button&gt;
  &lt;/template&gt;
&lt;/el-table-column&gt;
</code></pre>
<pre><code class="java">com/dkd/manage/controller/PartnerController.java
    /**
     * 获取合作商管理详细信息
     */
    @PreAuthorize(&quot;@ss.hasPermi(&#39;manage:partner:query&#39;)&quot;)
    @GetMapping(value = &quot;/&#123;id&#125;&quot;)
    public AjaxResult getInfo(@PathVariable(&quot;id&quot;) Long id)
    &#123;
        return success(partnerService.selectPartnerById(id));
    &#125;
</code></pre>
<pre><code class="js">/** 查看合作商详情 **/
  const partnerInfoOpen = ref(false)
  function getPartnerInfo(row)&#123;
    reset();
    const _id = row.id
    getPartner(_id).then(response =&gt; &#123;
      form.value = response.data;
      partnerInfoOpen.value = true;
    &#125;);
  &#125;
</code></pre>
<pre><code class="html">    &lt;!-- 查看合作商详情对话框 --&gt;
&lt;el-dialog title=&quot;合作商详情&quot; v-model=&quot;partnerInfoOpen&quot; width=&quot;500px&quot; append-to-body&gt;
    &lt;!-- 使用el-descriptions组件以卡片形式展示信息，更加整洁 --&gt;
    &lt;el-descriptions :column=&quot;2&quot; border&gt;
        &lt;el-descriptions-item label=&quot;合作商名称&quot;&gt;&#123;&#123; form.partnerName &#125;&#125;&lt;/el-descriptions-item&gt;
        &lt;el-descriptions-item label=&quot;联系人&quot;&gt;&#123;&#123; form.contactPerson &#125;&#125;&lt;/el-descriptions-item&gt;
        &lt;el-descriptions-item label=&quot;联系电话&quot;&gt;&#123;&#123; form.contactPhone &#125;&#125;&lt;/el-descriptions-item&gt;
        &lt;el-descriptions-item label=&quot;分成比例&quot;&gt;&#123;&#123; form.profitRatio &#125;&#125;%&lt;/el-descriptions-item&gt;
    &lt;/el-descriptions&gt;
&lt;/el-dialog&gt;
</code></pre>
<h3 id="合作商改造—列表查询点位管理→合作商管理→增加点位数"><a href="#合作商改造—列表查询点位管理→合作商管理→增加点位数" class="headerlink" title="合作商改造—列表查询点位管理→合作商管理→增加点位数"></a>合作商改造—列表查询<del>点位管理→合作商管理→增加点位数</del></h3><ul>
<li>实现此功能方案：</li>
</ul>
<h4 id="后端改造"><a href="#后端改造" class="headerlink" title="后端改造"></a>后端改造</h4><p><strong>关联查询</strong>编写关联查询语句，在mapper层封装</p>
<blockquote>
<p><strong>tb_node</strong>(点位表)的partner_id(合作商ID)<br><u>关联</u><br><strong>tb_partner</strong>(合作商表)的id</p>
<pre><code class="sql">-- 查询合作商表的所有信息，同时显示每个合作商的点位数
select p.*, count(n.id) as node_count
from tb_partner p
    left join tb_node n on p.id = n.partner_id
group by p.id
</code></pre>
</blockquote>
<p><strong>首先先创建一个需要查询新东西的方法<del>增加</del></strong></p>
<pre><code class="java">com/dkd/manage/domain/vo/PartnerVo.java
package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Partner;
import lombok.Data;

@Data
public class PartnerVo extends Partner &#123;
    // 点位数量
    private Integer nodeCount;
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/controller/PartnerController.java
 /**
     * 查询合作商管理列表
     */
    @PreAuthorize(&quot;@ss.hasPermi(&#39;manage:partner:list&#39;)&quot;)
    @GetMapping(&quot;/list&quot;)
    public TableDataInfo list(Partner partner) &#123;
        startPage();
        List&lt;PartnerVo&gt; voList = partnerService.selectPartnerVoList(partner);
        return getDataTable(voList);
    &#125;
</code></pre>
<pre><code class="java">com/dkd/manage/service/IPartnerService.java
/**
     * 查询合作商列表
     * @param partner
     * @return
     */
    public List&lt;PartnerVo&gt; selectPartnerVoList(Partner partner);
</code></pre>
<pre><code class="java">com/dkd/manage/service/impl/PartnerServiceImpl.java
/**
     * 查询合作商列表
     * @param partner
     * @return
     */
    @Override
    public List&lt;PartnerVo&gt; selectPartnerVoList(Partner partner) &#123;
        return partnerMapper.selectPartnerVoList(partner);
    &#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/PartnerMapper.java
/**
     * 查询合作商列表
     * @param partner
     * @return
     */
    public List&lt;PartnerVo&gt; selectPartnerVoList(Partner partner);
</code></pre>
<pre><code class="java">mapper/manage/PartnerMapper.xml
&lt;/select&gt;
        &lt;select id=&quot;selectPartnerVoList&quot; resultType=&quot;com.dkd.manage.domain.vo.PartnerVo&quot;&gt;
        select p.*, count(n.id) as node_count
        from tb_partner p
                 left join tb_node n on p.id = n.partner_id
        &lt;where&gt;
            &lt;if test=&quot;partnerName != null  and partnerName != &#39;&#39;&quot;&gt; and partner_name like concat(&#39;%&#39;, #&#123;partnerName&#125;, &#39;%&#39;)&lt;/if&gt;
        &lt;/where&gt;
        group by p.id
    &lt;/select&gt;
</code></pre>
<h4 id="前端改造"><a href="#前端改造" class="headerlink" title="前端改造"></a>前端改造</h4><pre><code class="html">&lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
      &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
      &lt;el-table-column label=&quot;合作商名称&quot; align=&quot;center&quot; prop=&quot;partnerName&quot; /&gt;
      &lt;el-table-column label=&quot;点位数&quot; align=&quot;center&quot; prop=&quot;nodeCount&quot; /&gt;
      &lt;el-table-column label=&quot;账号&quot; align=&quot;center&quot; prop=&quot;account&quot; /&gt;
      &lt;el-table-column label=&quot;分成比例&quot; align=&quot;center&quot; prop=&quot;profitRatio&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &#123;&#123; scope.row.profitRatio + '%' &#125;&#125;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;联系人&quot; align=&quot;center&quot; prop=&quot;contactPerson&quot; /&gt;
      &lt;el-table-column label=&quot;联系电话&quot; align=&quot;center&quot; prop=&quot;contactPhone&quot; /&gt;
      &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
</code></pre>
<h3 id="合作商改造——重置密码"><a href="#合作商改造——重置密码" class="headerlink" title="合作商改造——重置密码"></a>合作商改造——重置密码</h3><ul>
<li>查看详情，需要显示合作商名称、联系人、联系电话、分成比例</li>
<li>在查询合作商列表时，同时显示每个合作商的点位数</li>
<li>重置密码，初始密码为123456</li>
</ul>
<h4 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h4><p>在PartnerController中</p>
<pre><code class="java">/**
 * 重置合作商密码
 */
@PreAuthorize(&quot;@ss.hasPermi(&#39;manage:partner:edit&#39;)&quot;)
@Log(title = &quot;重置合作商密码&quot;, businessType = BusinessType.UPDATE)
@PutMapping(&quot;/resetPwd/&#123;id&#125;&quot;)
public AjaxResult resetpwd(@PathVariable Long id) &#123;//1. 接收参数
    //2. 创建合作商对象
    Partner partner = new Partner();
    partner.setId(id);// 设置id
    partner.setPassword(SecurityUtils.encryptPassword(&quot;123456&quot;));// 设置加密后的初始密码
    //3. 调用service更新密码
    return toAjax(partnerService.updatePartner(partner));
&#125;
</code></pre>
<h4 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h4><p>在<code>manage/partner.js</code>请求api中</p>
<pre><code class="js">// 重置合作商密码
export function resetPartnerPwd(id)&#123;
  return request(&#123;
    url: &#39;/manage/partner/resetPwd/&#39; + id,
    method: &#39;put&#39;
  &#125;)
&#125;
</code></pre>
<p>在<code>partner/index.vue</code>视图组件中<del>参考@click&#x3D;”handleDelete”，此方法删除时弹出对话框</del></p>
<pre><code class="vue">&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot; width=&quot;300px&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
        &lt;el-button link type=&quot;primary&quot; @click=&quot;resetPwd(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:partner:edit&#39;]&quot;&gt;重置密码&lt;/el-button&gt;
    &lt;/template&gt;
&lt;/el-table-column&gt;

&lt;script&gt;
    import &#123; listPartner, getPartner, delPartner, addPartner, updatePartner,resetPartnerPwd &#125; from &quot;@/api/manage/partner&quot;;
    /* 重置合作商密码 */
    function resetPwd(row) &#123;
        proxy.$modal.confirm(&#39;你确定要重置该合作商密码吗？&#39;).then(function () &#123;
            return resetPartnerPwd(row.id);
        &#125;).then(() =&gt; &#123;
            proxy.$modal.msgSuccess(&quot;重置成功&quot;);
        &#125;).catch(() =&gt; &#123; &#125;);
    &#125;
&lt;/script&gt;
</code></pre>
<h3 id="点位管理改造——基础布局"><a href="#点位管理改造——基础布局" class="headerlink" title="点位管理改造——基础布局"></a>点位管理改造——基础布局</h3><p>修改前端更简单一些 可以把前端一次性请求1w条数据 后端接口就可以重复调用</p>
<p>在<code>src\views\manage\node\index.vue</code>视图组件中</p>
<pre><code class="js">import &#123;listRegion&#125; from &quot;@/api/manage/region&quot;;

/* 查询所有条件对象 */
const loadAllParams=reactive(&#123;
  pageNum:1,
  pageSize:10000
&#125;)
/** 查询区域列表 **/
const regionList=ref([]);
function getRegionList() &#123;
  listRegion(loadAllParams).then(response=&gt;&#123;
    regionList.value=response.rows;
  &#125;)
&#125;
getRegionList();
getList();
</code></pre>
<p>在<code>src\api\manage\region.js</code>中</p>
<pre><code class="js">// 查询区域管理列表
export function listRegion(query) &#123;
  return request(&#123;
    url: &#39;/manage/region/list&#39;,
    method: &#39;get&#39;,
    params: query
  &#125;)
&#125;
</code></pre>
<h6 id="新增点位管理的时候想把合作商输入的改成自动获取的下拉框"><a href="#新增点位管理的时候想把合作商输入的改成自动获取的下拉框" class="headerlink" title="新增点位管理的时候想把合作商输入的改成自动获取的下拉框"></a>新增点位管理的时候想把合作商输入的改成自动获取的下拉框</h6><ul>
<li>定义js代码向后台发送请求，将请求后的结果封装给合作商parnterList集合</li>
<li>将文本框改成下拉框来遍历展示每个合作商的名称，提交时关联合作商的id</li>
</ul>
<pre><code class="js">      &lt;el-table-column label=&quot;详细地址&quot; align=&quot;center&quot; prop=&quot;address&quot; show-overflow-tooltip/&gt; 详细地址多出的部分隐藏只有鼠标移动到才会显示


import &#123;listPartner&#125; from &quot;@/api/manage/partner&quot;

&lt;el-form-item label=&quot;合作商ID&quot; prop=&quot;partnerId&quot;&gt;
          &lt;!-- &lt;el-input v-model=&quot;form.partnerId&quot; placeholder=&quot;请输入合作商ID&quot; /&gt; --&gt;
           &lt;el-select v-model=&quot;form.partnerId&quot; placeholder=&quot;请选择合作商&quot;&gt;
            &lt;el-option
              v-for=&quot;item in partnerList&quot;
              :key=&quot;item.id&quot;
              :label=&quot;item.partnerName&quot;
              :value=&quot;item.id&quot;&gt;
            &lt;/el-option&gt;
           &lt;/el-select&gt;
&lt;/el-form-item&gt;

/* 查询合作商列表 */
const partnerList=ref([]);
function getPartnerList()&#123;
  listPartner(loadAllParams).then(response=&gt;&#123;
    partnerList.value = response.rows;
  &#125;)
&#125;
getPartnerList();
</code></pre>
<h6 id="避免每次都要写pageSize：10000-直接搞入js里面"><a href="#避免每次都要写pageSize：10000-直接搞入js里面" class="headerlink" title="避免每次都要写pageSize：10000 直接搞入js里面"></a>避免每次都要写pageSize：10000 直接搞入js里面</h6><pre><code class="java">src\api\page.js
/* 查询所有条件对象 */
// const loadAllParams=reactive(&#123;
//   pageNum:1,
//   pageSize:10000
// &#125;) →

export const loadAllParams = reactive(&#123;
  pageNum: 1,
  pageSize: 10000,
&#125;);
</code></pre>
<h3 id="点位管理改造点位中增加个查看详情-将单表查询改为多表查询咯"><a href="#点位管理改造点位中增加个查看详情-将单表查询改为多表查询咯" class="headerlink" title="点位管理改造点位中增加个查看详情(将单表查询改为多表查询咯)"></a>点位管理改造<del>点位中增加个查看详情(将单表查询改为多表查询咯)</del></h3><ul>
<li>查看详情，需要显示当前点位下所有设备列表(稍后完成)</li>
<li>在区域详情中，需要显示每个点位的设备数</li>
<li>在点位列表查询中，关联显示区域、合作商等信息</li>
<li><strong>关联查询：</strong><u>对于设备数量的统计，我们需要执行关联查询，在mapper层封装</u></li>
<li><strong>关联实体</strong>：<u>对于区域和合作商的数据，我们会采用Mybatis提供的嵌套查询功能</u></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/601b425cc8b355cd33badf92ed988dbdabef1b9d/%E7%82%B9%E4%BD%8D%E7%AE%A1%E7%90%86%E6%94%B9%E9%80%A0%E8%A1%A8%E8%AE%BE%E8%AE%A1.png" alt="点位管理改造表设计.png"></p>
<pre><code class="mysql">&lt;resultMap&gt;......&lt;/resultMap&gt;   #完成手动映射

#解决一对一 或 多对一 映射结果集只有一个对象时完成的ORM的映射封装
&lt;association&gt;......&lt;/association&gt;  #点位和点位1对1  点位和合作商1对多

#解决一对多场景下来映射多个结果的集合 单个区域表+区域点位列表 映射的是集合！！
&lt;collection&gt;......&lt;/collection&gt; 
</code></pre>
<pre><code class="mysql"># AI辅助编程模式
-- AI辅助编程模式
-- 你是一个软件开发工程师，现在要根据数据库的sql脚本，查询并显示点位表所有的字段信息,同时显示每个点位的设备数量，sql脚本如下：
create table tb_node
(
    id            int auto_increment comment &#39;主键id&#39;
        primary key,
    node_name     varchar(255)                        not null comment &#39;点位名称&#39;,
    address       varchar(255)                        not null comment &#39;详细地址&#39;,
    business_type int                                 null comment &#39;商圈类型&#39;,
    region_id     int                                 null comment &#39;区域ID&#39;,
    partner_id    int                                 null comment &#39;合作商ID&#39;,
    create_time   timestamp default CURRENT_TIMESTAMP null comment &#39;创建时间&#39;,
    update_time   timestamp default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment &#39;修改时间&#39;,
    create_by     varchar(64)                         null comment &#39;创建人&#39;,
    update_by     varchar(64)                         null comment &#39;修改人&#39;,
    remark        text                                null comment &#39;备注&#39;,
    constraint tb_node_ibfk_1
        foreign key (region_id) references tb_region (id)
            on update cascade on delete cascade,
    constraint tb_node_ibfk_2
        foreign key (partner_id) references tb_partner (id)
            on update cascade on delete cascade
)
    comment &#39;点位表&#39;;
    
create table tb_vending_machine
(
    id                   bigint auto_increment comment &#39;主键&#39;
        primary key,
    inner_code           varchar(15) default &#39;000&#39;                 null comment &#39;设备编号&#39;,
    channel_max_capacity int                                       null comment &#39;设备容量&#39;,
    node_id              int                                       not null comment &#39;点位Id&#39;,
    addr                 varchar(100)                              null comment &#39;详细地址&#39;,
    last_supply_time     datetime    default &#39;2000-01-01 00:00:00&#39; not null comment &#39;上次补货时间&#39;,
    business_type        int                                       not null comment &#39;商圈类型&#39;,
    region_id            int                                       not null comment &#39;区域Id&#39;,
    partner_id           int                                       not null comment &#39;合作商Id&#39;,
    vm_type_id           int         default 0                     not null comment &#39;设备型号&#39;,
    vm_status            int         default 0                     not null comment &#39;设备状态，0:未投放;1-运营;3-撤机&#39;,
    running_status       varchar(100)                              null comment &#39;运行状态&#39;,
    longitudes           double      default 0                     null comment &#39;经度&#39;,
    latitude             double      default 0                     null comment &#39;维度&#39;,
    client_id            varchar(50)                               null comment &#39;客户端连接Id,做emq认证用&#39;,
    policy_id            bigint                                    null comment &#39;策略id&#39;,
    create_time          timestamp   default CURRENT_TIMESTAMP     not null comment &#39;创建时间&#39;,
    update_time          timestamp   default CURRENT_TIMESTAMP     null comment &#39;修改时间&#39;,
    constraint vendingmachine_VmId_uindex
        unique (inner_code),
    constraint tb_vending_machine_ibfk_1
        foreign key (vm_type_id) references tb_vm_type (id),
    constraint tb_vending_machine_ibfk_2
        foreign key (node_id) references tb_node (id),
    constraint tb_vending_machine_ibfk_3
        foreign key (policy_id) references tb_policy (policy_id)
)
    comment &#39;设备表&#39;;
</code></pre>
<pre><code class="sql">-- 查询并显示点位表所有的字段信息,同时显示每个点位的设备数量
SELECT
    n.id,
    n.node_name,
    n.address,
    n.business_type,
    n.region_id,
    n.partner_id,
    n.create_time,
    n.update_time,
    n.create_by,
    n.update_by,
    n.remark,
    COUNT(v.id) AS vm_count
FROM
    tb_node n
LEFT JOIN
    tb_vending_machine v ON n.id = v.node_id
GROUP BY
    n.id;
</code></pre>
<pre><code class="java">package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Node;
import com.dkd.manage.domain.Partner;
import com.dkd.manage.domain.Region;
import lombok.Data;

@Data
public class NodeVo extends Node &#123;
    // 设备数量
    private Integer vmCount;
    // 区域信息
    private Region region;
    // 合作商信息
    private Partner partner;
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/NodeMapper.java
/**
     *  查询点位管理列表
     * @param node
     * @return
     */
    public List&lt;NodeVo&gt; selectNodeVoList(Node node);
</code></pre>
<pre><code class="xml">&lt;!--
resultType=&quot;com.dkd.manage.domin.vo.NodeVo&quot;&gt;...
这个是mybatis以前搞的自动映射封装直接把结果映射给了NodeVo的实体类了
嵌套查询就不能使用resultType自动映射 要改为resultMap做自动映射
&lt;resultMap type=&quot;NodeVo&quot; id=&quot;NodeVoResult&quot;&gt;
多表查询一定要起别名噢 不然会报错没有指明where的子句是来自tb_node表的region_id  还是来自tb_vending_machine表的region_id
--&gt;

&lt;select id=&quot;selectNodeVoList&quot; parameterType=&quot;Node&quot; resultMap=&quot;NodeVoResult&quot;&gt;
        SELECT
        n.id,
        n.node_name,
        n.address,
        n.business_type,
        n.region_id,
        n.partner_id,
        n.create_time,
        n.update_time,
        n.create_by,
        n.update_by,
        n.remark,
        COUNT(v.id) AS vm_count
        FROM
        tb_node n
        LEFT JOIN
        tb_vending_machine v ON n.id = v.node_id
        &lt;where&gt;
            &lt;if test=&quot;nodeName != null  and nodeName != &#39;&#39;&quot;&gt; and n.node_name like concat(&#39;%&#39;, #&#123;nodeName&#125;, &#39;%&#39;)&lt;/if&gt;
            &lt;if test=&quot;regionId != null &quot;&gt; and n.region_id = #&#123;regionId&#125;&lt;/if&gt;
            &lt;if test=&quot;partnerId != null &quot;&gt; and n.partner_id = #&#123;partnerId&#125;&lt;/if&gt;
        &lt;/where&gt;
        GROUP BY
        n.id
    &lt;/select&gt;
</code></pre>
<pre><code class="xml">多对一标签用association
&lt;resultMap type=&quot;NodeVo&quot; id=&quot;NodeVoResult&quot;&gt;
        &lt;result property=&quot;id&quot;    column=&quot;id&quot;    /&gt;
        &lt;result property=&quot;nodeName&quot;    column=&quot;node_name&quot;    /&gt;
        &lt;result property=&quot;address&quot;    column=&quot;address&quot;    /&gt;
        &lt;result property=&quot;businessType&quot;    column=&quot;business_type&quot;    /&gt;
        &lt;result property=&quot;regionId&quot;    column=&quot;region_id&quot;    /&gt;
        &lt;result property=&quot;partnerId&quot;    column=&quot;partner_id&quot;    /&gt;
        &lt;result property=&quot;createTime&quot;    column=&quot;create_time&quot;    /&gt;
        &lt;result property=&quot;updateTime&quot;    column=&quot;update_time&quot;    /&gt;
        &lt;result property=&quot;createBy&quot;    column=&quot;create_by&quot;    /&gt;
        &lt;result property=&quot;updateBy&quot;    column=&quot;update_by&quot;    /&gt;
        &lt;result property=&quot;remark&quot;    column=&quot;remark&quot;    /&gt;
        &lt;result property=&quot;vmCount&quot;    column=&quot;vm_count&quot;    /&gt;
&lt;!--
sql语法拿到region_id去执行区域当中的selectRegionById 方法执行的时候需要传递区域的id
原理：RegionMapper.java中的 public Region selectRegionById(Long id)把条件拿到手并封装给区域的Region对象 返回的Region对象最终映射给NodeVo.java的 private Region region;
怎么执行的映射呢？需要指定java属性名和执行的类型：
property=&quot;region&quot; 
javaType=&quot;Region&quot;
至此完成了mybatis的嵌套查询
--&gt;
        &lt;association property=&quot;region&quot; javaType=&quot;Region&quot; column=&quot;region_id&quot; select=&quot;com.dkd.manage.mapper.RegionMapper.selectRegionById&quot;/&gt;
        &lt;association property=&quot;partner&quot; javaType=&quot;Partner&quot; column=&quot;partner_id&quot; select=&quot;com.dkd.manage.mapper.PartnerMapper.selectPartnerById&quot;/&gt;
    &lt;/resultMap&gt;
</code></pre>
<pre><code class="java">&lt;resultMap&gt;......&lt;/resultMap&gt;   // 完成手动映射 为了实现多表映射情况组合查询

// 解决一对一 或 多对一 映射结果集只有一个对象时完成的ORM的映射封装
&lt;association&gt;......&lt;/association&gt;  #点位和点位1对1  点位和合作商1对多

// 解决一对多场景下来映射多个结果的集合 单个区域表+区域点位列表 映射的是集合！！
&lt;collection&gt;......&lt;/collection&gt; 


/*
// &lt;association&gt; 标签允许你在查询结果中嵌套另一个对象。
 这样可以方便地在 NodeVo 对象中直接访问 Region 和 Partner 的属性，而不需要额外的查询
 
property：指定 NodeVo 类中的属性名称，该属性将引用关联的对象。
javaType：指定关联对象的 Java 类型。
column：指定用于关联查询的列名，通常是外键。
select：指定一个子查询的方法，用于根据外键查询关联对象
*/
</code></pre>
<h4 id="NodeService"><a href="#NodeService" class="headerlink" title="NodeService"></a>NodeService</h4><pre><code class="java">/**
 * 查询点位管理列表
 * @param node
 * @return NodeVo集合
 */
public List&lt;NodeVo&gt; selectNodeVoList(Node node);
</code></pre>
<h4 id="NodeServiceImpl"><a href="#NodeServiceImpl" class="headerlink" title="NodeServiceImpl"></a>NodeServiceImpl</h4><pre><code class="java">/**
 * 查询点位管理列表
 *
 * @param node
 * @return NodeVo集合
 */
@Override
public List&lt;NodeVo&gt; selectNodeVoList(Node node) &#123;
    return nodeMapper.selectNodeVoList(node);
&#125;
</code></pre>
<h4 id="NodeController"><a href="#NodeController" class="headerlink" title="NodeController"></a>NodeController</h4><pre><code class="java">/**
 * 查询点位管理列表
 */
@PreAuthorize(&quot;@ss.hasPermi(&#39;manage:node:list&#39;)&quot;)
@GetMapping(&quot;/list&quot;)
public TableDataInfo list(Node node)
&#123;
    startPage();
    List&lt;NodeVo&gt; voList = nodeService.selectNodeVoList(node);
    return getDataTable(voList);
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/NodeMapper.java
/**
     *  查询点位管理列表
     * @param node
     * @return
     */
    public List&lt;NodeVo&gt; selectNodeVoList(Node node);
</code></pre>
<h4 id="node-x2F-index-vue"><a href="#node-x2F-index-vue" class="headerlink" title="node&#x2F;index.vue"></a>node&#x2F;index.vue</h4><pre><code class="vue">&lt;!-- 点位列表 --&gt;
&lt;el-table v-loading=&quot;loading&quot; :data=&quot;nodeList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;
  &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
  &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
  &lt;el-table-column label=&quot;点位名称&quot; align=&quot;center&quot; prop=&quot;nodeName&quot; /&gt;
  &lt;el-table-column label=&quot;所在区域&quot; align=&quot;center&quot; prop=&quot;region.regionName&quot; /&gt;
  &lt;el-table-column label=&quot;商圈类型&quot; align=&quot;center&quot; prop=&quot;businessType&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
      &lt;dict-tag :options=&quot;business_type&quot; :value=&quot;scope.row.businessType&quot; /&gt;
    &lt;/template&gt;
  &lt;/el-table-column&gt;
  &lt;el-table-column label=&quot;合作商&quot; align=&quot;center&quot; prop=&quot;partner.partnerName&quot; /&gt;
  &lt;el-table-column label=&quot;详细地址&quot; align=&quot;center&quot; prop=&quot;address&quot; show-overflow-tooltip=&quot;true&quot;/&gt;
  &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
      &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:node:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
      &lt;el-button link type=&quot;primary&quot; icon=&quot;Delete&quot; @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:node:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
    &lt;/template&gt;
  &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre>
<h3 id="区域管理改造-地区详情新增查看详情"><a href="#区域管理改造-地区详情新增查看详情" class="headerlink" title="区域管理改造-地区详情新增查看详情"></a>区域管理改造-地区详情<del>新增查看详情</del></h3><pre><code class="html">src\views\manage\region\index.vue
&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;el-button link type=&quot;primary&quot;  @click=&quot;getRegionInfo(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:list&#39;]&quot;&gt;查看详情&lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;

&lt;!-- 
template 插槽：
#default=&quot;scope&quot;：定义默认插槽，scope 是当前行的数据对象。

@click=&quot;getRegionInfo(scope.row)&quot;：点击按钮时调用 getRegionInfo 函数，并传入当前行的数据。
--&gt;

...
...

/* 查看详情操作按钮 */
function getRegionInfo(row) &#123;
  // 查询区域信息
  reset();
  const _id = row.id
  getRegion(_id).then(response =&gt; &#123;
    form.value = response.data
  &#125;);
&#125;

&lt;!-- 
nodeList 变量：

const nodeList = ref([])：定义一个响应式数组 nodeList，用于存储点位列表。
getRegionInfo 函数：

reset()：调用 reset 函数，可能用于重置表单或其他状态。
const _id = row.id：获取当前行的 id。
getRegion(_id).then(response =&gt; &#123; form.value = response.data &#125;)：调用 getRegion 函数查询区域信息，并将返回的数据赋值给 form.value。
loadAllParams.regionId = row.id：设置 loadAllParams 对象的 regionId 属性为当前行的 id。
listNode(loadAllParams).then(response =&gt; &#123; nodeList.value = response.rows &#125;)：调用 listNode 函数查询点位列表，并将返回的行数据赋值给 nodeList.value。
--&gt;
</code></pre>
<h5 id="区域管理里引入点位的api文件"><a href="#区域管理里引入点位的api文件" class="headerlink" title="区域管理里引入点位的api文件"></a>区域管理里引入点位的api文件</h5><pre><code class="js">import &#123; listNode &#125; from &quot;@/api/manage/node&quot;;
import &#123; loadAllParams &#125; from &quot;@/api/page&quot;;
...
/* 查看详情操作按钮 */
const nodeList = ref([]);
function getRegionInfo(row) &#123;
  // 查询区域信息
  reset();
  const _id = row.id
  getRegion(_id).then(response =&gt; &#123;
    form.value = response.data
  &#125;);
  // 查看点位列表
  loadAllParams.regionId=row_id
  listNode(loadAllParams).then(response =&gt; &#123;
    nodeList.value = response.rows;
  &#125;);
&#125;
</code></pre>
<h6 id="添加区域管理对话框"><a href="#添加区域管理对话框" class="headerlink" title="添加区域管理对话框"></a>添加区域管理对话框</h6><pre><code class="html"> &lt;!-- 添加或修改区域管理对话框 --&gt;
    &lt;el-dialog :title=&quot;title&quot; v-model=&quot;open&quot; width=&quot;500px&quot; append-to-body&gt;
      &lt;el-form ref=&quot;regionRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt;
        &lt;el-form-item label=&quot;区域名称&quot; prop=&quot;regionName&quot;&gt;
          &lt;el-input v-model=&quot;form.regionName&quot; placeholder=&quot;请输入区域名称&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;备注说明&quot; prop=&quot;remark&quot;&gt;
          &lt;el-input v-model=&quot;form.remark&quot; type=&quot;textarea&quot; placeholder=&quot;请输入内容&quot; /&gt;
        &lt;/el-form-item&gt;
      &lt;/el-form&gt;
      &lt;template #footer&gt;
        &lt;div class=&quot;dialog-footer&quot;&gt;
          &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm&quot;&gt;确 定&lt;/el-button&gt;
          &lt;el-button @click=&quot;cancel&quot;&gt;取 消&lt;/el-button&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/el-dialog&gt;
   &lt;!-- 查看详情对话框 --&gt;
&lt;el-dialog title=&quot;区域详情&quot; v-model=&quot;regionInfoOpen&quot; width=&quot;500px&quot; append-to-body&gt;
    &lt;el-form-item label=&quot;区域名称&quot; prop=&quot;regionName&quot;&gt;
        &lt;el-input v-model=&quot;form.regionName&quot; disabled /&gt;
    &lt;/el-form-item&gt;
    &lt;label&gt;包含点位：&lt;/label&gt;
    &lt;el-table :data=&quot;nodeList&quot;&gt;
        &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; /&gt;
        &lt;el-table-column label=&quot;点位名称&quot; align=&quot;center&quot; prop=&quot;nodeName&quot; /&gt;
        &lt;el-table-column label=&quot;设备数量&quot; align=&quot;center&quot; prop=&quot;vmCount&quot; /&gt;
    &lt;/el-table&gt;
&lt;/el-dialog&gt;
</code></pre>
<pre><code class="js">/* 查看详情操作按钮 */
const nodeList = ref([]);
const regionInfoOpen=ref(false);
function getRegionInfo(row) &#123;
  // 查询区域信息
  reset();
  const _id = row.id
  getRegion(_id).then(response =&gt; &#123;
    form.value = response.data
  &#125;);
  // 查看点位列表
  loadAllParams.regionId=row_id
  listNode(loadAllParams).then(response =&gt; &#123;
    nodeList.value = response.rows;
  &#125;);
  regionInfoOpen.value=true;
&#125;
</code></pre>
<h5 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h5><ul>
<li>在删除区域或合作商数据时，关联的点位数据该如何处理？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/05e49c8d5a61f85f41c20ded647d7f32c03ae296/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7_%E5%AD%97%E6%AE%B5%E4%BE%9D%E8%B5%96.png"></p>
<blockquote>
<p>tb_region(区域表)                     tb_node(点位表)                       tb_partner(合作商表)<br>id           ←region_id:id ←        region_id                                                  id<br>                                                    partner_id             partner_id:id →→→↑     </p>
</blockquote>
<p>找到设置外键约束<del>(取消约束)</del><code>dkd → tb_node → Modify Table(old)</code> 找到<code>Foreign Keys</code>  双击打开后将<u>Update rule</u>和<u>Delete rule</u>修改为：<strong>no action</strong></p>
<blockquote>
<p>**CASCADE（级联操作）:**当父表中的某行记录被删除或更新时，与其关联的所有子表中的匹配行也会自动被删除或更新。这种方式适用于希望保持数据一致性的场景，即父记录不存在时，相关的子记录也应该被移除。</p>
<p>**SET NULL（设为空）:**若父表中的记录被删除或更新，子表中对应的外键字段会被设置为NULL。选择此选项的前提是子表的外键列允许为NULL值。这适用于那些子记录不再需要明确关联到任何父记录的情况。</p>
<p>**RESTRICT（限制）:**在尝试删除或更新父表中的记录之前，数据库首先检查是否有相关联的子记录存在。如果有，则拒绝执行删除或更新操作，以防止意外丢失数据或破坏数据关系的完整性。这是一种保守策略，确保数据间的引用完整性。</p>
<p>**NO ACTION（无操作）:**在标准SQL中，NO ACTION是一个关键字，它要求数据库在父表记录被删除或更新前，检查是否会影响子表中的相关记录。在MySQL中，NO ACTION的行为与RESTRICT相同，即如果子表中有匹配的行，则禁止执行父表的删除或更新操作。这意味着如果存在依赖关系，操作将被阻止，从而保护数据的参照完整性。</p>
</blockquote>
<p>修改完毕后，如果你尝试进行删除操作，会发现数据库的完整性约束生效了，它会阻止删除操作并给出错误提示。但是，这个错误提示信息可能对于用户来说不够友好，可能会让用户感到困惑。</p>
<p><code>SQLIntegrityConstraintViolationException</code>是Java中的一个异常类，这个类通常用于表示SQL数据库操作中的完整性约束违反异常</p>
<p>例如：外键约束、唯一约束等。当数据库操作违反了这些约束时，就会抛出这个异常。</p>
<p>这个错误是由于外键约束导致的。它表明在删除或更新父表的行时，存在外键约束，子表中的相关行会受到影响。</p>
<p>是因为在删除tb_region表中的行时，tb_node表中的region_id外键约束会阻止操作。</p>
<p>如果你在使用Spring框架进行数据库操作，可能会先遇到DataIntegrityViolationException，它是对SQLIntegrityConstraintViolationException的一个更高层次的抽象，旨在提供一种更加面向应用的错误表示。</p>
<p>而SQLIntegrityConstraintViolationException是更底层的异常，直接来源于数据库驱动，包含更多底层数据库相关的细节。</p>
<p>在实际开发中，推荐捕获并处理DataIntegrityViolationException，因为它更符合Spring应用的异常处理模式，同时也可以通过其内部的cause（原因）属性来获取具体的SQLIntegrityConstraintViolationException，进而获取详细的错误信息。</p>
<p>为了提升用户体验，我们可以使用Spring Boot框架的全局异常处理器来捕获这些错误信息，并返回更友好的提示信息给用户。这样，当用户遇到这种情况时，他们将收到一个清晰、易懂的提示，告知他们操作无法完成的原因。</p>
<pre><code class="java">com/dkd/framework/web/exception/GlobalExceptionHandler.java
/**
     * 数据完整性异常
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public AjaxResult handleDataIntegrityViolationException(DataIntegrityViolationException e) &#123;
        log.error(e.getMessage(), e);
        if (e.getMessage().contains(&quot;foreign&quot;)) &#123;
            return AjaxResult.error(&quot;无法删除该数据，有其他数据引用&quot;);
        &#125;
        return AjaxResult.error(&quot;数据完整性异常，请联系管理员&quot;);
    &#125;
</code></pre>
<p>16</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/03/后端/若依-AI & 帝可得/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/10/31/面试/Java八股文专项/">
        <h2>
            Java面试专项
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/10/31
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><h6 id="我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？"><a href="#我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？" class="headerlink" title="我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？"></a><span style = "color:red">我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？</span></h6><ul>
<li>验证你项目场景的真实性，二是为了深入发问的切入点</li>
<li><strong>缓存</strong> 缓存三兄弟(穿透、击穿、雪崩)、双写一致、持久化、数据过期策略、数据淘汰策略</li>
<li><strong>分布式锁</strong> setnx、redisson</li>
<li><strong>消息队列、延迟队列</strong> 何种数据类型</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><p><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong><br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</p>
</li>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<p><strong>bitmap（位图）</strong>：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大    </p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给某一个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[不设置过期时间] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值</li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<pre><code class="java">《缓存三兄弟》
穿透无中生有key，布隆过滤null隔离。
缓存击穿过期key，锁与非期解难题。
雪崩大量过期key，过期时间要随机。
面试必考三兄弟，可用限流来保底。
</code></pre>
<h6 id="redis作为缓存，mysql的数据如何与redis进行同步呢？-双写一致性"><a href="#redis作为缓存，mysql的数据如何与redis进行同步呢？-双写一致性" class="headerlink" title="redis作为缓存，mysql的数据如何与redis进行同步呢？(双写一致性)"></a><span style = "color:red">redis作为缓存，mysql的数据如何与redis进行同步呢？(双写一致性)</span></h6><p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行<br><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】</p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知</strong>&#x3D;&#x3D;： <u>异步通知保证数据的最终一致性</u>(需要保证MQ的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先将数据写入Redis，然后通过异步通知机制触发数据库的更新操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<h6 id="Redis作为缓存，数据的持久化是怎么做的？"><a href="#Redis作为缓存，数据的持久化是怎么做的？" class="headerlink" title="Redis作为缓存，数据的持久化是怎么做的？"></a><span style = "color:red">Redis作为缓存，数据的持久化是怎么做的？</span></h6><p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果</p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照哦</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h6 id="假如Redis的key过期之后，会立即删除吗"><a href="#假如Redis的key过期之后，会立即删除吗" class="headerlink" title="假如Redis的key过期之后，会立即删除吗"></a><span style = "color:red">假如Redis的key过期之后，会立即删除吗</span></h6><p>Redis对数据设置数据的有效时间，数据过期以后就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略(数据过期策略)</p>
<p>&#x3D;&#x3D;<strong>Redis数据删除策略-惰性删除</strong>&#x3D;&#x3D;</p>
<p>惰性删除：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</p>
<pre><code class="mysql">set name zhangsan 10
get name # 发现name过期了，直接删除key
</code></pre>
<p><strong>优点：</strong>对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不会浪费时间进行过期检查<br><strong>缺点：</strong>对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p>
<p><strong>&#x3D;&#x3D;Redis数据删除策略-定期删除&#x3D;&#x3D;</strong></p>
<p>定期删除：每隔一段时间，我们就会对一些key进行检查，删除里面过期的key (从一定数量的数据库中取出一定数量的<strong>随机key</strong>进行检查，并删除其中的过期key)</p>
<p><strong>定期清理的两种模式：</strong></p>
<ul>
<li><strong>SLOW模式</strong>是定时模式，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件<code>redis.conf</code>的hz选项来调整这个次数</li>
<li><strong>FAST模式</strong>执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li>
</ul>
<p><strong>优点：</strong>可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存<br><strong>难点：</strong>难以确定删除操作执行的时长和频率</p>
<p><strong>Redis过期删除策略：</strong> <strong><u>惰性删除 + 定期删除</u></strong> 两种策略进行配合使用</p>
<h6 id="假如缓存过多，内存是有限的，内存被占满了怎么办？"><a href="#假如缓存过多，内存是有限的，内存被占满了怎么办？" class="headerlink" title="假如缓存过多，内存是有限的，内存被占满了怎么办？"></a><span style = "color:red">假如缓存过多，内存是有限的，内存被占满了怎么办？</span></h6><p>&#x3D;&#x3D;<strong>数据淘汰策略</strong>&#x3D;&#x3D;</p>
<p>当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据制除掉，这种数据的制除规则被称之为内存的淘汰策略</p>
<p><strong>Redis支持8种不同策略来选择要删除的key:</strong></p>
<ul>
<li><p><strong>noeviction：</strong>不淘汰任何key，但是内存满时不允许写入新数据，<strong>默认就是这种策略</strong></p>
<blockquote>
<h6 id="maxmemory-policy-noeviction"><a href="#maxmemory-policy-noeviction" class="headerlink" title="maxmemory-policy noeviction"></a>maxmemory-policy noeviction</h6></blockquote>
</li>
<li><p><strong>volatile-ttl</strong>：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰 (<u>TTL:过期时间的key</u>)</p>
</li>
<li><p><strong>allkeys-random</strong>：对全体key，随机进行淘汰</p>
</li>
<li><p><strong>volatile-random</strong>：对设置了TTL的key，随机进行淘汰</p>
</li>
<li><p><strong>allkeys-lru</strong>：对全体key，基于LRU算法进行淘汰</p>
<blockquote>
<p><strong>LRU</strong>(Least <strong>Recently</strong> Used)：<strong>最近最少使用</strong>，用当前时间减去最后一次访问时间，这个值越大测淘汰优先级越高 [逐出访问时间最少的]<br><strong>LFU</strong>(Least <strong>Frequently</strong> Used)：<strong>最少频率使用</strong>。会统计每个key的访问频率，值越小淘汰优先级越高。[逐出频率最低的] 【电商会应用】</p>
</blockquote>
</li>
<li><p><strong>allkeys-lfu</strong>：对全体key，基于LFU算法进行淘汰</p>
</li>
<li><p><strong>volatile-lfu</strong>：对设置了TTL的key，基于LFU算法进行淘汰</p>
</li>
</ul>
<p><strong>淘汰策略 - 使用建议</strong></p>
<p>1.优先使用 <code>allkeys-lru</code> 策略。充分利用LRU算法的优势，把最近最常访问的数据留在缓存中，如果业务有明显的冷热数据区分，建议使用。<br>2.如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用<code>allkeys-random</code>，随机选择淘汰<br>3.如果业务中有置顶的需求，可以使用<code>volatile-lru</code>策略，同时<strong>置顶数据不设置过期时间</strong>，这些数据就一直不会被删除，会淘汰其他设置过期时间的数据<br>4.如果业务中有<strong>短时高频</strong>访问的数据，可以使用<code>allkeys-lfu</code>或<code>volatile-lfu</code>策略</p>
<h6 id="数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？"><a href="#数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？" class="headerlink" title="数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？"></a>数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？</h6><ul>
<li>使用<code>allkeys-lru</code>(挑选最近最少使用的数据淘汰) 淘汰策略，留下来的都是经常访问的热点数据</li>
</ul>
<h6 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h6><ul>
<li>主要看数据淘汰策略是什么？如果是默认的配置(noeviction)，会直接报错</li>
</ul>
<h6 id="redis分布式锁，是如何实现的？"><a href="#redis分布式锁，是如何实现的？" class="headerlink" title="redis分布式锁，是如何实现的？"></a><span style = "color:red">redis分布式锁，是如何实现的？</span></h6><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题<br><img src="https://raw.githubusercontent.com/P-luminary/images/0f81d6fe238b4774d88facda4329c5ebe4921aa0/Redis%E9%9D%A2%E8%AF%95_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg"></p>
<p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、EX是设置超时时间<br><strong>SET lock value NX EX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h6 id="Redis实现分布式锁如何合理的控制锁的有效时长？"><a href="#Redis实现分布式锁如何合理的控制锁的有效时长？" class="headerlink" title="Redis实现分布式锁如何合理的控制锁的有效时长？"></a><span style = "color:red">Redis实现分布式锁如何合理的控制锁的有效时长？</span></h6><ul>
<li>根据业务执行时间预估</li>
<li><strong>给锁续期</strong></li>
</ul>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责<strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h6 id="Redis集群有哪些方案？"><a href="#Redis集群有哪些方案？" class="headerlink" title="Redis集群有哪些方案？"></a><span style = "color:red">Redis集群有哪些方案？</span></h6><ul>
<li><p>&#x3D;&#x3D;<strong>主从复制</strong>&#x3D;&#x3D; </p>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离<br><u>主节点写操作→增删改</u>     <u>从节点读操作→查</u></p>
<h6 id="介绍一下redis的主从同步"><a href="#介绍一下redis的主从同步" class="headerlink" title="介绍一下redis的主从同步"></a><span style = "color:red">介绍一下redis的主从同步</span></h6><blockquote>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就要搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据</p>
</blockquote>
<p><strong>主从数据同步原理：</strong></p>
<ul>
<li><span style="color:blue"><u>主从<strong>全量同步</strong></u>：</span></li>
</ul>
<p>slave从节点执行replicaof命令建立链接 → 请求master主节点数据同步(<u>replid+offset</u>) → master判断是否是第一次同步(判断replid是否一致) → 是第一次, 返回master的数据版本信息(<u>replid+offset</u>)  → slave保存版本信息 → master执行bgsave, 生成RDB → 发送RDB文件给slave → slave清空本地数据加载RDB数据 → 此时master记录RDB期间所有命令<code>repl_balklog</code> → 发送repl_backlog中的命令 → slave执行接收到的命令</p>
<p><strong>Replication ld</strong>: 简称<u>replid</u>，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid,slave则会继承master节点的replid<br><strong>offset</strong>: 偏移量，随着记录在repl baklog中的数据增多而逐渐增大。save完成同步时也会记录当前同步的ofset，如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p>
<blockquote>
<p>简述全量同步的流程？</p>
<p>• slave节点请求增量同步</p>
<p>• master节点判断replid，发现不一致，拒绝增量同步</p>
<p>• master将完整内存数据生成RDB，发送RDB到slave</p>
<p>• slave清空本地数据，加载master的RDB</p>
<p>• master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</p>
<p>• slave执行接收到的命令，保持与master之间的同步</p>
</blockquote>
<p><span style = "color:red"><strong>能说一下，主从同步数据的流程吗？</strong></span></p>
<p><span style="color:pink"><strong>全量同步</strong></span></p>
<blockquote>
<p>1.从节点请求主节点同步数据(replication id、offset)<br>2.主节点判断是否为第一次请求，是第一次就与从节点同步版本信息(replication id和offset)<br>3.主节点执行bgsave, 生成RDB文件后, 发送给从节点去执行<br>4.在RDB生成执行期间, 主节点会从命令的方式记录到缓冲区(日志文件)</p>
</blockquote>
<ul>
<li><span style="color:blue"><u>主从<strong>增量同步</strong></u></span><br>主从增量同步(slave重启或后期数据变化)</li>
</ul>
<p>① slave重启后 → 携带(replid+offset)找master → master判断请求replid是否一致 → 是第一次, 返回主节点replid和offset → 保存版本信息<br>② slave重启后 → 携带(replid+offset)找master → master判断请求replid是否一致 → 不是第一次, 回复continue向slave → master 去repl_baklog中获取offset后的数据 → 发送offset后的命令给slave → 执行命令</p>
<p><span style="color:pink"><strong>增量同步</strong></span></p>
<blockquote>
<p>1.从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值<br>2.主节点从命令日志中获取offset值后的数据，发送给节点进行数据同步</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>简述全量同步和增量同步区别？</p>
<p>•全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</p>
<p>•增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</p>
<p>什么时候执行全量同步？</p>
<p>•slave节点第一次连接master节点时</p>
<p>•slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</p>
<p>什么时候执行增量同步？</p>
<p>•slave节点断开又恢复，并且在repl_baklog中能找到offset时</p>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>哨兵模式</strong>&#x3D;&#x3D;~~搭过集群，具体多少个节点是组长那边，不太清楚<del>[并发量不是太多 搭哨兵可以节省一点资源]</del><br>Redis提供了<strong>哨兵</strong>(Sentinel)机制来实现主从集群的自动故障恢复</p>
<ul>
<li><strong>监控</strong>：Sentinel会不断检查您的master和slave是否按预期工作</li>
<li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为一个master。当故障实例恢复后也以新的master为主</li>
<li><strong>通知：</strong>Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<p><span style="color:blue"><strong>服务状态监控</strong></span><br>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令 <code>期待回复pong</code></p>
<ul>
<li><strong>主观下线</strong>：如果某sentinel节点发现或某实例未在规定时间相应，则认为该实例<strong>主观下线</strong></li>
<li><strong>客观下线</strong>：若超过指定数量(quorum)的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>，quorum值最好超过Sentinel实例数量的一半</li>
</ul>
<p><span style="color:blue"><strong>哨兵选主规则</strong></span></p>
<ul>
<li>首先判断主与从节点断开时间长短，如超过指定值就排该从节点</li>
<li>然后判断从节点的slave-priority值，越小优先级越高</li>
<li><strong><u>如果slave-priority值一样，则判断slave节点的offset值，越大优先级越高</u></strong> (数据是最全的)</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高</li>
</ul>
<p><strong><span style="color:blue">redis集群(哨兵模式) 脑裂</span></strong><br>因网络问题 主节点和从节点分别在不同的网络分区 这样sentinel只会监控到一部分从节点网络分区 导致RedisClient继续写主节点的数据，这时网络恢复了，哨兵会将老的master强制降级到slave(携带着脑裂前的最新数据)，这个时候slave就会把自己数据清空去同步master数据，这时就存在真正的数据丢失了</p>
<p><strong>怎么解决</strong>？</p>
<blockquote>
<p>redis中有两个配置参数：【若不能达成就拒绝客户端请求 这样就会避免大量数据丢失】<br>min-replicas-to-write 1      <strong>表示最少的salve节点为1</strong><br>min-replicas-max-lag 5      <strong>表示数据复制和同步的延迟不能超过5秒</strong></p>
</blockquote>
<p><span style = "color:red"><strong>怎么保证Redis的高并发高可用呢？</strong></span></p>
<blockquote>
<p>哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知)</p>
</blockquote>
<p><span style = "color:red"><strong>你们使用redis是单点还是集群，哪种集群？</strong></span></p>
<blockquote>
<p>主从(1主1从) + 哨兵就可以了。单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点</p>
</blockquote>
<p><span style = "color:red"><strong>redis集群脑裂，该怎么解决？</strong></span></p>
<blockquote>
<p><strong>集群脑裂</strong>是由于主节点和从节点和sentinel处于不同网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当为网络恢复后，sentinel会将老的主节点降为从节点，此时再从新master同步数据，就会导致数据丢失<br><strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，这样就会避免大量数据丢失。</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>分片集群</strong>&#x3D;&#x3D;</p>
<p>主从和哨兵可以解决高可用、高并发读的问题，但是依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题</li>
</ul>
<p>使用分片集群可用解决上述问题，分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可用有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可用访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
<p><strong><span style="color:blue">分片集群结果 - 数据读写</span></strong></p>
<p>Redis分片集群引入了<strong>哈希槽</strong>的概念，Redis集群有16384个哈希值，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>
<blockquote>
<p>存数据流程：<br>set name itheima → CRC16计算name的hash值(666666) → 666666%16384&#x3D;11306 → 根据11306找寻所对应哈希槽的范围 并且插入数据</p>
</blockquote>
<p><span style = "color:red"><strong>redis的分片集群有什么用？</strong></span></p>
<blockquote>
<ul>
<li>集群中有多个master，每个master保存不同数据。(解决高并发<strong>写</strong>的问题)</li>
<li>每个master都可以有多个slave节点。(解决高并发<strong>读</strong>的问题)</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可用访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>redis的分片集群中数据是怎么存储和读取的？</strong></span></p>
<blockquote>
<ul>
<li>Redis 分片集群引入了哈希槽的概念，Redis 集群有16384个哈槽</li>
<li>将16384个插槽分配到不同的实例</li>
<li>读写数据:根据key的**<u>有效部分</u>**计算哈希值，对16384取余(有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分)余数做为播槽，寻找插所在的实例</li>
</ul>
</blockquote>
</li>
</ul>
<p><span style = "color:red"><strong>Redis是单线程的，但是为什么还那么快</strong></span></p>
<blockquote>
<ul>
<li>Redis是纯内存操作，执行速度非常快</li>
<li>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</li>
<li>使用<strong>I&#x2F;O多路复用</strong>模型，非阻塞IO</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>解释一下I&#x2F;O多路复用模型？</strong></span></p>
<blockquote>
<p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度，I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p>
<ul>
<li><p>是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源，目前的I&#x2F;O多路复用都是采用的epol模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要换个历Socket来判断是否就绪，提升了性能</p>
</li>
<li><p><strong>Redis网络模型</strong>:</p>
<p>就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求</p>
<ul>
<li><p>连接应答处理器</p>
</li>
<li><p>命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</p>
</li>
<li><p>命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>用户空间和内核空间</strong>&#x3D;&#x3D;</p>
<ul>
<li>Linux系统中一个进程使用的内存情况划分两部分：<strong>内核空间、用户空间</strong></li>
<li><strong>用户空间</strong>只能执行受限的命令RIng3，而且不能直接调用系统资源必须通过内核提供的接口来访问</li>
<li><strong>内核空间</strong>可以执行特权命令Ring0，调用一切系统资源</li>
</ul>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区</p>
<ul>
<li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li>
<li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li>
</ul>
</li>
<li><p><strong>常见的IO模型</strong></p>
<ul>
<li><p><strong>&#x3D;&#x3D;阻塞IO&#x3D;&#x3D;</strong></p>
<p>阻塞IO就是两个阶段都必须阻塞等待：<br><strong>阶段一：</strong></p>
<ul>
<li>用户进程尝试读取数据(网卡数据等)</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>此时用户进程也处于阻塞状态</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li>数据到达并拷贝到内核缓冲区，代表已就绪</li>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>非阻塞</strong>IO&#x3D;&#x3D;</p>
<p><strong>阶段一</strong>：</p>
<ul>
<li>用户进程尝试读取数据(比如网卡数据)</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>返回异常给用户进程</li>
<li>用户进程拿到error后，再次尝试读取</li>
<li>循环往复，直到数据就绪</li>
</ul>
<p><strong>阶段二</strong>:</p>
<ul>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;IO<strong>多路复用</strong>&#x3D;&#x3D;</p>
<p>是利用单个线程来同时监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源</p>
<p><strong>IO多路复用</strong>是利用单个线程来同步监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听Socket的方式、通知的方式又有多种实现</p>
<ul>
<li><strong>select</strong></li>
<li><strong>poll</strong></li>
<li><strong>epoll</strong></li>
</ul>
<p><strong>差异:</strong><br>★ select和polI只会通知用户进程有Socket就绪，但不确定具体是哪个Socket，需要用户进程逐个历Socket来确认<br>★ epoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间,</p>
<p><strong>阶段一</strong>:</p>
<ul>
<li>用户进程调用select，指定要监听的Socket集合</li>
<li>内核监听对应的多个socket</li>
<li>任意一个或多个sacket数据就绪则返回readable</li>
<li>此过程中用户进程阻塞</li>
</ul>
<p><strong>阶段二</strong>:</p>
<ul>
<li>用户进程找别就格的socket</li>
<li>依次调用recvfrom读取数据</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redis网络模型</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9490d2cd8e67cb8fae7520ad15c0849821dbfac0/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"></p>
<h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span></p>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、SKywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>那这个SQL语句执行很慢，如何分析呢？</strong></span></p>
<blockquote>
<p>可以采用MySQL自带的分析工具 EXPLAIN</p>
<ul>
<li>通过key和key_len检查是否命中了索引(索引本身存在是否有失效的情况)</li>
<li>通过type字段查看sql是否有进一步的优化空间，是否存在<strong>全索引扫描</strong>或<strong>全盘扫描</strong></li>
<li>通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li>
</ul>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询 → <strong><u>新增临时表的数据</u></strong></li>
<li>多表查询 → <strong><u>优化SQL语句结构</u></strong></li>
<li>表数据量过大查询 → <strong><u>添加索引</u></strong></li>
<li>深度分页查询</li>
</ul>
</blockquote>
<h5 id="一个SQL语句执行很慢，如何分析？"><a href="#一个SQL语句执行很慢，如何分析？" class="headerlink" title="一个SQL语句执行很慢，如何分析？"></a>一个SQL语句执行很慢，如何分析？</h5><p>可以采用<code>EXPLAIN</code>或者<code>DESC</code>命令获取MySQL如何执行SELECT语句的信息</p>
<pre><code class="mysql"># 直接在select语句之前加上关键字 explain/desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
</code></pre>
<blockquote>
<p>mysql &gt; explain select * from t_user where id &#x3D; ‘1’</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>t_user</td>
<td>NULL</td>
<td>const</td>
<td>PRIMARY</td>
<td>PRIMARY</td>
<td>98</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
</tbody></table>
<ul>
<li><strong>possible_key</strong>：当前sql可能会使用到的索引</li>
<li><strong>key：</strong>当前sql实际命中的索引     <u>通过它俩查看是否可能会命中索引</u></li>
<li><strong>key_len</strong>：索引占用的大小          <u>通过它俩查看是否可能会命中索引</u></li>
<li><strong>Extra</strong>：额外的优化建议</li>
</ul>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Using where; Using Index</td>
<td>查找使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据</td>
</tr>
<tr>
<td>Using index condition</td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody></table>
<ul>
<li><strong>type：</strong>这条sql的连接的类型，性能由好到差为 <ul>
<li>NULL</li>
<li>system：查询系统中的表</li>
<li>const：根据主键查询</li>
<li>eq_ref：主键索引查询或唯一索引查询</li>
<li>ref：索引查询</li>
<li>range：范围查询</li>
<li><em>index：索引树扫描</em></li>
<li><em>all：全盘扫描</em></li>
</ul>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>了解过索引吗？（什么是索引）</strong></span></p>
<blockquote>
<p>索引(index)是帮助MySQL高效获取数据的数据结构(有序)，在数据之外，数据库系统还维护着满足特定查找算法的数据结构**(B+树)**，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p>
<ul>
<li>索引(index)是帮助MySQL高效获取数据的数据结构(有序)</li>
<li>提高数据检索的效率，降低数据库的IO成本(不需要全表扫描)</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li>**聚簇索引(聚集索引)**：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个</li>
<li>**非聚簇索引(二级索引)**：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<p><span style = "color:red"><strong>知道什么叫覆盖索引吗？</strong></span></p>
<blockquote>
<p>覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到</p>
<ul>
<li>使用id查询，直接走聚集索引查询，一次索引描述，直接返回数据，性能高</li>
<li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用 **select *** <del>[除非用的聚簇索引(主键)]</del></li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;<strong>覆盖索引</strong>&#x3D;&#x3D;是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</p>
<table>
<thead>
<tr>
<th align="center"><span style = "color:red">id</span></th>
<th align="center"><span style = "color:red">name</span></th>
<th align="center">gender</th>
<th align="center">createdate</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">Arm</td>
<td align="center">1</td>
<td align="center">2021-01-01</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Lily</td>
<td align="center">0</td>
<td align="center">2021-05-04</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">Rose</td>
<td align="center">0</td>
<td align="center">2021-04-21</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">Zoo</td>
<td align="center">1</td>
<td align="center">2021-07-31</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Doc</td>
<td align="center">1</td>
<td align="center">2021-02-26</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">Lee</td>
<td align="center">1</td>
<td align="center">2021-09-11</td>
</tr>
</tbody></table>
<ul>
<li><strong>id为主键，默认是主键索引</strong></li>
<li><strong>name字段为普通索引</strong></li>
</ul>
<pre><code class="mysql">select * from tb_user where id = 1;                     【覆盖索引】
select id, name from tb_user where name = &#39;Arm&#39;         【覆盖索引】
select id, name, gender from tb_user where name = &#39;Arm&#39; 【非覆盖索引】(需要回表查询)
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9b20975f94b299a861457b2214bd985ff4b2625d/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.jpg"></p>
<p><span style = "color:red"><strong>MySQL超大分页怎么处理？</strong></span></p>
<blockquote>
<p>问题：再数据量比较大时，limit分页查询，需要对数据进行排序，效率低<br><strong>解决方案：</strong>可以用<strong>覆盖索引</strong> + <strong>子查询</strong>处理<br>[我们先分页查询获取表中的id 并且对表的id进行排序 就能筛选出分页后的id集合(因为id是覆盖索引效率高)  最后再根据id集合到原来的表中做关联查询就可以得到提升了]</p>
</blockquote>
<p>在数据量比较大时，如果用limit分页查询，在查询时，越往后，分页查询效率越低</p>
<pre><code class="mysql">mysql &gt; select * from tb_sku limit 0,10;
10 rows in set (0.00 sec)

mysql &gt; select * from tb_sku limit 9000000,10;
10 rows in set (11.05 sec)
</code></pre>
<p>因为，当在进行分页查询时，如果执行 limit  9000000,10，此时需要MySQL排序前9000010记录，仅仅返回9000000 - 9000010 的记录，其他记录丢失，查询排序的代价非常大。</p>
<p>&#x3D;&#x3D;<strong>MySQL超大分页查询优化思路</strong>&#x3D;&#x3D;：一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好地提高性能，可以通过<strong>覆盖索引</strong>加<strong>子查询</strong>形式进行优化</p>
<pre><code class="mysql"># 超大分页处理：先通过覆盖索引找到符合条件的id，再通过这个id的覆盖索引查询到所有的列
select * 
from tb_sku t,
(select id from tb_sku order by id limit 9000000,10) a
where t.id = a.id

# 10 rows in set (7.15 sec)
</code></pre>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong><br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><br>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<h6 id="创建索引的方式"><a href="#创建索引的方式" class="headerlink" title="创建索引的方式"></a>创建索引的方式</h6><pre><code class="mysql">① SQL的方式
ALTER TABLE user_innodb ADD INDEX idx_name(name)

② 在建表的时候 去指定索引
...
PRIMARY KEY(&#39;id&#39;),
KEY &#39;idx_name&#39; (&#39;name&#39;) USING HASH

③ 通过界面化工具去指定索引
字段旁边有个`索引` 可以去添加

=============================================
单个字段的索引 → 单列索引
多个字段的索引 → 联合索引
</code></pre>
<h6 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h6><p><u>索引可以增加查询速度 同时也增加了更新&#x2F;修改速度</u><del>因为更新的第一步就是查询</del></p>
<blockquote>
<p>① <strong>普通索引</strong>   经过特殊设计的数据结构<br>② <strong>唯一索引</strong>   唯一约束<br>[索引必须是唯一的 比如name就不行 因为名字可以很多建立普通索引]<br>③ <strong>主键索引</strong>   在主键索引上添加了<strong>非空约束</strong><br>④ <strong>全文索引</strong>   一般使用搜索引擎，因为对中文的搜索不太友好<del>美国英文开发的</del><br>[特殊的sql：select * from 表名 where match(字段名) against(‘马士兵教育’ IN NATURAL LANGUAGE MODE);]</p>
<p>AVL树 右右型左旋 <strong><u>左子树与右子树的深度差绝对值不超过1</u></strong><br>树的节点里应该放：<strong>键值</strong>+<strong>Value值</strong>+<strong>左右子树的地址</strong><del>left+right</del><br>Innodb一次会加载16k(<u>16384字节&#x3D;Redis的槽位</u>) 内存到内存<br>不选红黑树是因为它是二叉的，我们需要多叉树<br>要用&#x3D;&#x3D;<strong>B+树</strong>&#x3D;&#x3D;全盘扫描能力更强 叶子节点是双向链表<br>因为稳定性比较好  B树非所见所得 B+树是稳定几层的查找数据<del>因为数据都在最后一层叶子节点上</del><br>Innodb的索引方法是BTREE 不能改成HASH</p>
</blockquote>
<p>**<u><span style = "color:red">数据结构可视化网</span></u>**：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a></p>
<ul>
<li>针对数据量较大，且查询比较频繁的表建立索引。<strong>单表超过10万数据(增加用户体验)</strong></li>
<li>针对常作为<strong>查询条件(where)、排序(order by)、分组(group by)</strong> 操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 (比如address都在北京市)</li>
<li>如果是字符串类型的字段，字段的长度越长(描述信息…)，可以针对于字段的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引(避免回表)，节省存储空间，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ul>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行运算操作，索引将失效</li>
<li>字符串不加单引号，造成索引失效。(类型转换)</li>
<li>以%开头的Like模糊查询，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><strong>怎么哪块读判断索引是否失效了呢</strong>？</p>
<pre><code class="mysql"># 执行计划explain
</code></pre>
<p>【2024最新版MySQL索引讲解！一个视频带你彻底搞懂MySQL索引！！【马士兵】】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17z421i7Kb?vd_source=5966d6c3cf3709c10b3c53b278b0f4d3">https://www.bilibili.com/video/BV17z421i7Kb?vd_source=5966d6c3cf3709c10b3c53b278b0f4d3</a></p>
<p><strong>什么情况下索引会失效？</strong><br>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引：<br><img src="https://github.com/P-luminary/images/blob/master/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png?raw=true" style="zoom:80%;" /></p>
<p><span style = "color:red"><strong>谈谈你对sql的优化经验？</strong></span></p>
<blockquote>
<ul>
<li>表的设计优化，数据类型的选择</li>
<li>索引优化，索引创建原则</li>
<li>sql语句优化，避免索引失效，避免使用select</li>
<li>主从复制、读写分离，不让数据的写入，影响读操作</li>
<li>分库分表</li>
</ul>
</blockquote>
<ul>
<li><p>表的设计优化(<strong>参考阿里开发手册《嵩山版》</strong>)</p>
<ul>
<li>比如设置合适的数值(tinyint、int、bigint) ，要根据实际情况选择</li>
<li>比如设置合适的字符串类型(char和varchar) char定长效率高，varchar可变长度，效率低</li>
</ul>
<blockquote>
<p>候选人: 这个我们主要参考的阿里出的那个开发手册《嵩山版》，就比如，在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint、int、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型</p>
</blockquote>
</li>
<li><p><strong>索引优化</strong>(参考优化创建原则和索引失效)</p>
</li>
<li><p><strong>SQL语句优化</strong></p>
<ul>
<li><p>SELECT语句务必指明字段名称 (避免直使用select *)<del>回表</del></p>
</li>
<li><p>SQL语句要避免造成索引失效的写法</p>
</li>
<li><p>尽量使用union all代替union，union(不会重复)会多一次过滤, 效率低</p>
<pre><code class="mysql">select * from t_user where id &gt; 2
union all | union
select * from t_user where id &lt; 5
</code></pre>
</li>
<li><p>避免在where子句中对字段进行表达式操作</p>
</li>
<li><p>join优化 能用inner join 就不用left join,  right 如必须使用 一定要以小表为驱动；内链接会对两个表进行优化，<strong>优先把小表放到外边，把大表放到里边</strong>。left join 或 right  join，不会重新调整顺序</p>
<pre><code class="java">for(int i = 0; i &lt; 3; i++)&#123; //只链接查询3次
 for(int j = 0; j &lt; 1000; j++)&#123;

 &#125;  
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>主从复制、读写分离</strong>(在生产环境下一般会搭建主库和从库 分开读操作和写操作)</p>
<p>如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。读写分离解决的是，<strong>数据库的写入</strong>，影响了查询的效率。[Master(写) 和 Slave(读)]</p>
</li>
<li><p><strong>分库分表(后面有介绍)</strong></p>
</li>
</ul>
<p><span style = "color:red"><strong>事务的特性是什么？可以详细的说一下吗？</strong></span>【ACID】</p>
<blockquote>
<p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>候选人：嗯，这个比较清楚，ACID，分别指的是:原子性、一致性、隔离性、持久性;<br><strong>我举个例子</strong>：A向B转账500，转账成功，A扣除500元，B增加500元，原子操作体现在<u>要么都成功，要么都失败</u>。<br>在转账的过程中，数据要一致，A扣除了500，B必须增加500<br>在转账的过程中，隔离性体现在A像B转账，不能受其他事务干扰<br>在转账的过程中，持久性体现在事务提交后，要把数据持久化(可以说是落盘操作)</p>
</blockquote>
<ul>
<li>**原子性(**Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li><strong>一致性</strong>(Consistency)：事务完成时，必须使所有的数据都保持一致状态。</li>
<li><strong>隔离性</strong>(lsolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境运行</li>
<li><strong>持久性</strong>(Durabiity)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p><span style = "color:red"><strong>并发事务带来哪些问题？怎么解决这些问题？MySQL默认隔离级别是？</strong></span></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;<strong>并发事务问题</strong>&#x3D;&#x3D;：脏读、不可重复读、幻读</li>
<li>&#x3D;&#x3D;<strong>隔离级别</strong>&#x3D;&#x3D;：读未提交、读已提交、<strong>可重复读</strong>、串行化</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">脏读</td>
<td>一个事务读到另外一个事务还没有提交的数据</td>
</tr>
<tr>
<td align="center">不可重复读</td>
<td>一个事务先后读取同一条事务，但两次读取的数据不同，称之为不可重复读</td>
</tr>
<tr>
<td align="center">幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，这同时另一个事务B(insert且commit)了事务，此时事务A在插入数据时候，又发现这行数据已经存在了，好像出现了”幻影“</td>
</tr>
</tbody></table>
<h6 id="怎么解决并发事务的问题呢？？"><a href="#怎么解决并发事务的问题呢？？" class="headerlink" title="怎么解决并发事务的问题呢？？"></a>怎么解决并发事务的问题呢？？</h6><p><strong>对事务进行隔离</strong> (× 是代表可以解决此问题)</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Read uncommitted 未提交读</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Read committed 读已提交</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">&#x3D;&#x3D;<strong>Repeatable Read(默认) 可重复读</strong>&#x3D;&#x3D;</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Serializable 串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>注意：**<u>事务隔离级别越高，数据越安全，但是性能越低</u>**</p>
<p><span style = "color:red"><strong>undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是数据页的物理变化，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undolog保证了事务的原子性和一致性</p>
</blockquote>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
<p><span style = "color:red"><strong>事务中的隔离性是如何保证的呢？</strong></span></p>
<blockquote>
<p>排他锁 (如果一个事务获取到了一哥数据行的排他锁，其他事务就不能再获取该行的其他锁)<br>mvcc: 多版本并发控制  让MySQL中的多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突<br><strong>隐藏字段</strong>:<br>① trx _id(事务id)，记录每一次操作的事务id，是自增的<br>② roll _pointer(回滚指针)，指向上一个版本的事务版本记录地址</p>
<p><strong>undo log</strong>:<br>① 回滚日志，存储老版本数据<br>② 版本链:多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过rollpointer指针形成一个链表</p>
<p><strong>readView</strong>：解决的是一个事务查询选择版本的问题<br>根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据》不同的隔离级别快照读是不一样的，最终的访问的结果不一样RC:每一次执行快照读时生成ReadView<br>RR:仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
</blockquote>
<blockquote>
<p><strong>面试官</strong>: 事务中的隔离性是如何保证的呢?(你解释一下MVCC)<br><strong>候选人</strong>: 事务的隔离性是由锁和mvcc实现的。<br>其中mnvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是<u>隐藏字段</u>，第二个是<u>undolog日志</u>，第三个是<u>readView读视图</u><br>隐藏字段是指:在mysq!中给每个表都设置了隐藏字段，有一个是x_id(事务id)，记录每一次操作的事务id，是自增的;另一个字段是roll-pointer(回滚指针)，指向上一个版本的事务版本记录地址<br>undolog主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行探作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表<br>readview解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是r隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
</blockquote>
<p><span style = "color:red"><strong>解释一下MVCC？</strong></span></p>
<p>全程 <strong>Multi-Version Concurrency Control</strong>，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突</p>
<h6 id="问题的来源：-橙色的-查询的是哪个事务版本的记录？"><a href="#问题的来源：-橙色的-查询的是哪个事务版本的记录？" class="headerlink" title="问题的来源：(橙色的)查询的是哪个事务版本的记录？"></a>问题的来源：(橙色的)查询的是哪个事务版本的记录？</h6><table>
<thead>
<tr>
<th align="center">事务2</th>
<th align="center">事务3</th>
<th align="center">事务4</th>
<th align="center">事务5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
</tr>
<tr>
<td align="center">修改id为30记录, age改为3</td>
<td align="center"></td>
<td align="center">查询id为30的记录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">修改id为30记录, name改为A3</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><span style = "color:orange"><strong>查询id为30的记录</strong></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">提交文件</td>
<td align="center">修改id为30的记录, age改为10</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">查询id为30的记录</td>
<td align="center"><span style = "color:orange"><strong>查询id为30的记录</strong></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
</tbody></table>
<h6 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC-实现原理"></a>MVCC-实现原理</h6><ul>
<li><strong>记录中的隐藏字段</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">age</th>
<th align="center">name</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PTR</th>
<th align="center">DB_ROW_ID</th>
</tr>
</thead>
</table>
<ul>
<li><strong>DB_TRX_ID</strong>：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong>：回滚指针，指向这条记录的上一个版本，用于配合undo log, 指向上一个版本</li>
<li><strong>DB_ROW_ID</strong>：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</li>
</ul>
<h6 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h6><ul>
<li>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</li>
<li>当insert的时候，产生的undolog日志只在回滚时需要，在事务提交后，可被立即删除。</li>
<li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除。</li>
</ul>
<h6 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h6><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录</p>
<ul>
<li><strong>readview</strong></li>
</ul>
<p>ReadView(读视图) 是 <strong>快照读</strong> SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id</p>
<p>ReadView中包含了四个核心字段</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">m_ids</td>
<td align="center">当前活跃的事务ID集合</td>
</tr>
<tr>
<td align="center">min_trx_id</td>
<td align="center">最小活跃事务ID</td>
</tr>
<tr>
<td align="center">max_trx_id</td>
<td align="center">预分配事务ID, 当前最大事务ID+1 (事务ID是自增的)</td>
</tr>
<tr>
<td align="center">creator_trx_id</td>
<td align="center">ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<ul>
<li><strong>当前读</strong></li>
</ul>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select .. lock in share mode(共享锁)，select .. for update、update、insert、delete(排他锁)都是一种当前读。</p>
<ul>
<li><strong>快照读</strong></li>
</ul>
<p>简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。<br><strong>Read Committed</strong>:每次select，都生成一个快照读。<br><strong>Repeatable Read</strong>:开启事务后第一个select语句才是快照读的地方。</p>
<p><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></p>
<blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<p><span style = "color:red"><strong>你们项目用过分库分表吗？</strong></span></p>
<blockquote>
<ul>
<li><p>业务介绍<br>1，根据自己简历上的项目，想一个数据量较大业务(请求数多或业务累积大)<br>2，达到了什么样的量级(单表1000万或超过20G)</p>
</li>
<li><p>具体拆分策略<br>1，水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题<br>2，水平分表，解决单表存储和性能的问题<br>3，垂直分库，根据业务进行拆分，高并发下提高磁盘I0和网络连接数<br>4，垂直分表，冷热数据分离，多表互不影响</p>
</li>
</ul>
</blockquote>
<p><strong>分担了访问压力、解决存储压力</strong></p>
<p>分库分表的时机：</p>
<p>① <strong>前提</strong>：项目业务数据逐渐增多，业务发展比较迅速【单表数据量达1000W或20G以后】<br>② 优化解决不了性能问题(主从读写分离、查询索引)<br>③ <strong>IO瓶颈</strong>(磁盘IO、网络IO)、<strong>CPU瓶颈</strong>(聚合查询、连接数太多)</p>
<p><strong>拆分策略</strong>【垂直 ≈ 微服务、水平 ≈ 分配数值】</p>
<ul>
<li>&#x3D;&#x3D;<strong>垂直拆分</strong>&#x3D;&#x3D;<ul>
<li><strong>垂直分库</strong>：以表为依据，根据业务将不同表拆分到不同库中<br>(特点：按业务对数据分级管理、维护、监控、扩展；在高并发下，提高磁盘IO和数据量连接数)<ul>
<li>tb_user → 用户微服务 </li>
<li>tb_order → 订单微服务</li>
<li>tb_sku → 商品微服务</li>
</ul>
</li>
<li><strong>垂直分表</strong>：以字段为依据，根据字段属性将不同字段拆分到不同表中<br>(把不常用的字段单独放在一张表；把<strong>text, blob</strong>等大字段[描述]拆分出来放在附表中)<br>(特点：冷热数据分离、减少IO过渡争抢，两表互不影响)</li>
</ul>
</li>
<li>&#x3D;&#x3D;<strong>水平拆分</strong>&#x3D;&#x3D;<ul>
<li><strong>水平分库</strong>：将一个库的数据拆分到多个库中<br>(解决了单库大数量，高并发的性能瓶颈问题；提高了系统的稳定性和可用性)<br><u>路由规则</u><ul>
<li>根据id节点取模</li>
<li>按id也就是范围路由，节点1(1-100万)，节点2(100万-200万)</li>
</ul>
</li>
<li><strong>水平分表</strong>：将一个库的数据拆分到多个表中(可以在同一个库内)<br>(优化单一表数据量过大而产生的性能问题；避免IO争抢并减少锁表的几率)</li>
</ul>
</li>
</ul>
<h6 id="分库后的问题：↓↓"><a href="#分库后的问题：↓↓" class="headerlink" title="分库后的问题：↓↓"></a>分库后的问题：↓↓</h6><ul>
<li>分布式事务一致性问题</li>
<li>跨节点关联查询</li>
<li>跨节点分页、排序函数</li>
<li>主键避重</li>
</ul>
<h6 id="使用分库分表中间件"><a href="#使用分库分表中间件" class="headerlink" title="使用分库分表中间件"></a>使用分库分表中间件</h6><ul>
<li><span style = "color:blue"><strong>sharding-sphere</strong></span></li>
<li><span style = "color:blue"><strong>mycat</strong></span></li>
</ul>
<p><span style = "color:red"><strong>Spring框架中的单例bean是线程安全的吗？</strong></span></p>
<blockquote>
<p>不是线程安全的，是这样的</p>
<p>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑(成员方法)，如果该处理逻辑中有对该单列状态的修改(体现为该单例的成员属性)，则必须考虑线程同步问题。</p>
<p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。<br>比如:我们通常在项目中使用的Springbean都是不可可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。</p>
<p>如果你的bean有多种状态的话(比如 View Model对象)，就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“singleton”变更为“prototype”。</p>
</blockquote>
<blockquote>
<p>Spring框架中的bean是单例的1</p>
<pre><code class="java">@Service
@Scope(&quot;singleton&quot;)
public class UserServiceImpl implements UserService&#123;
    
&#125;
</code></pre>
<ul>
<li><strong>singleton</strong>：bean在每个Spring IOC容器中只有一个实例</li>
<li><strong>prototype：</strong>一个bean的定义可以有多个实例</li>
</ul>
<p>Spring bean并没有可变的状态(比如Service类和DAO类), 所以在某种程度上说Spring的单例bean是线程安全的。但要尽可能的少创造可变参数比如count</p>
<pre><code class="java">@Controller
@RequeestMapping(&quot;/user&quot;)
public class UserController&#123;
    private int count; //成员方法需要考虑线程安全问题

    @Autowired
    private UserService userService;
    
    @GetMapping(&quot;/getById/&#123;id&#125;&quot;)
    public User getById(@PathVariable(&quot;id&quot;) Integer id)&#123;
        count++;
        sout(count);
        return userService.getById(id);
    &#125;
&#125;
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>什么是AOP，你们项目中有没有用到AOP？</strong></span></p>
<p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”(Aspect)，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<h6 id="常见AOP使用场景："><a href="#常见AOP使用场景：" class="headerlink" title="常见AOP使用场景："></a>常见AOP使用场景：</h6><ul>
<li><p><strong>记录操作日志</strong></p>
<blockquote>
<p>nginx → 新增用户 → @Around(“pointcut()”) <u><strong>环绕通知</strong></u></p>
</blockquote>
</li>
<li><p><strong>缓存处理</strong></p>
</li>
<li><p><strong>Spring中内置的事务处理</strong></p>
</li>
</ul>
<p><strong>Spring中的事务是如何实现的</strong><br>Spring支持 <strong>编程式事务管理</strong> 和 <strong>声明式事务</strong> 管理两种方式。</p>
<ul>
<li><strong>编程式事务控制</strong>：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li>
<li><strong>声明式事务管理</strong>：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li>
</ul>
<p><span style = "color:red"><strong>Spring中事务失效的场景有哪些？</strong></span></p>
<blockquote>
<p>异常捕获处理，自己处理了异常，没有抛出，解决:手动抛出<br>抛出检查异常，配置rollbackFor属性为Exception<br>非public方法导致的事务失效，改为public</p>
</blockquote>
<p>考察对spring框架的深入理解、复杂业务的编码经验</p>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>异常捕获处理</strong>&#x3D;&#x3D;</p>
<p><strong>原因</strong>：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉</p>
<p><strong>解决</strong>：<u>在catch块添加throw new RuntimeException(“转账失败”)</u> 抛出</p>
</li>
<li><p>&#x3D;&#x3D;<strong>抛出检查异常</strong>&#x3D;&#x3D;</p>
<p><strong>原因</strong>：Spring默认只会回滚非检查异常</p>
<pre><code class="java">@Transactional
public void update(...) throw FileNotFoundException&#123;
    ...
    new FileInputStream(&quot;dddd&quot;)
    ...
&#125;
</code></pre>
<p><strong>解决：</strong>配置<code>rollbackFor</code>属性</p>
<pre><code class="java">@Transcational(rollbackFor=Exception.class)
</code></pre>
</li>
<li><p>&#x3D;&#x3D;<strong>非public方法</strong>&#x3D;&#x3D;</p>
<pre><code class="java">@Transcational(rollbackFor=Exception.class)
void update(...) throw FileNotFoundException&#123;
    ...
    new FileInputStream(&quot;dddd&quot;)
    ...
&#125;
</code></pre>
<p><strong>原因：</strong>Spring为方法创建代理、添加事务通知、<u>前提条件都是该方法是<strong>public</strong>的</u><br><strong>解决：</strong>把方法改为<code>public</code></p>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>Spring的bean的生命周期？</strong></span></p>
<blockquote>
<p>Spring容器是如何管理和创建bean实力<br>方便调试和解决问题</p>
<p>① 通过BeanDefinition获取bean的定义信息<br>② 调用构造函数实例化bean<br>③ bean的依赖注入<br>④ 处理Aware接囗(BeanNameAware、BeanFactoryAware、ApplicationContextAware)<br>⑤ Bean的后置处理器BeanPostProcessor-前置<br>⑥ 初始化方法(InitializingBean、init-method)<br>⑦ Bean的后置处理器BeanPostProcessor-后置<br>⑧ 销毁bean</p>
</blockquote>
<p><strong>BeanDefinition</strong></p>
<p>Spring容器在进行实例化时，会将xml配置的&lt; bean &gt;的信息封装成一个<strong>BeanDefinition</strong>对象，<u>Spring根据BeanDefinition来创建Bean对象，里面有很多的属性来描述Bean</u></p>
<pre><code class="java">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaolmpl&quot; lazy-init=&quot;true&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.UserServicelmpl&quot; scope=&quot;singleton&quot;&gt;
  &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><img src="https://github.com/P-luminary/images/blob/master/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?raw=true"></p>
<p><span style = "color:red"><strong>Spring中的循环引用？</strong></span></p>
<blockquote>
<p>★ <strong>循环依赖</strong>:循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A<br>★ 循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖<br>  ☆ <strong>一级缓存</strong>:单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象<br>  ☆ <strong>二级缓存</strong>:缓存早期的bean对象(生命周期还没走完)<br>  ☆ <strong>三级缓存</strong>:缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p>
</blockquote>
<p><span style = "color:red"><strong>构造方法出现了循环依赖怎么解决？</strong></span></p>
<blockquote>
<p>A依赖于B，B依赖于A，注入的方式是构造函数<br><strong>原因</strong>：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入<br><strong>解决方案</strong>：使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建</p>
<p>public A(@Lazy B b){<br>    sout(“A的构造方法执行了”);<br>    this.b&#x3D;b;<br>}</p>
</blockquote>
<blockquote>
<p>@Component                                     @Component<br>public class A{          →      ←             public class B{<br>    @Autowired         ↑          ↑                 @Autowired<br>    private B b;       →↑          ↑←                private A a;<br>}                                                             } </p>
</blockquote>
<h6 id="什么是Spring的循环依赖？？"><a href="#什么是Spring的循环依赖？？" class="headerlink" title="什么是Spring的循环依赖？？"></a>什么是Spring的循环依赖？？</h6><p><u>&#x3D;&#x3D;<strong>一级缓存</strong>&#x3D;&#x3D;作用：限制bean在beanFactory中只存一份，即实现singleton scope，解决不了循环依赖</u></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/14e03913c1c2b7ca24702d5d2226a886bcc373de/%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%961.jpg"></p>
<p><u>如果想打破循环依赖，就需要一个中间人的参与，这个中间人就是&#x3D;&#x3D;<strong>二级缓存</strong>&#x3D;&#x3D;</u><del>如果一个对象是代理对象(被增强了)就不行</del><br><img src="https://github.com/P-luminary/images/blob/master/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%962.jpg?raw=true"></p>
<p><u>针对如果是代理对象的话如何解决呢？</u> → &#x3D;&#x3D;<strong>三级缓存</strong>&#x3D;&#x3D;<br><img src="https://github.com/P-luminary/images/blob/master/%E4%B8%89%E6%AC%A1%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.jpg?raw=true"></p>
<h6 id="那如果构造方法出现了循环依赖怎么解决？"><a href="#那如果构造方法出现了循环依赖怎么解决？" class="headerlink" title="那如果构造方法出现了循环依赖怎么解决？"></a>那如果构造方法出现了循环依赖怎么解决？</h6><blockquote>
<p>@Component                                                                   @Component<br>public class A{                           →      ←                          public class B{<br>    private B b;                             ↑          ↑                             private A a;<br>    public A(B c){                       →↑          ↑←                        public B(A c){<br>          sout(“A的构造方法执行了”)                                          sout(“B的构造方法执行了”)<br>          this.b&#x3D;b;                                                                                 this.b&#x3D;b;<br>    }                                                                                               }<br>}                                                                                            } </p>
<p>报错信息：Is there an unresolvable circular reference?<br>解决：<code>@Lazy </code> 延迟加载→什么时候需要对象的时候什么时候实例化对象</p>
<pre><code class="java">public A(@Lazy B b)&#123;
    sout(&quot;A的构造方法执行了&quot;);
    this.b=b;
&#125;
</code></pre>
</blockquote>
<p><strong>Spring解决循环依赖是通过三级缓存</strong></p>
<pre><code class="java">// 单实例对象注册器
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123;
private static final int SUPPRESSED EXCEPTIONS LIMIT= 100;  
private final Map&lt;String, Object&gt;singletonObjects = new ConcurrentHashMap(256); 一级缓存
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16); 三级缓存
private final Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap(16); 二级缓存 
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>缓存名称</th>
<th>源码名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td>singletonObject</td>
<td>单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</td>
</tr>
<tr>
<td>二级缓存</td>
<td>earlySingletonObjects</td>
<td>缓存早期的bean对象(生命周期还没走完)</td>
</tr>
<tr>
<td>三级缓存</td>
<td>singletonFactories</td>
<td>缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringMVC的执行流程知道吗？</strong></span></p>
<blockquote>
<ul>
<li>视图阶段(老旧JSP等)</li>
<li>前后端分离阶段(接口开发，异步)</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/67d750afe8d0ece9e5cc289483dc164a9897e165/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg"></p>
<p>&#x3D;&#x3D;<strong>视图阶段(jsp)</strong>&#x3D;&#x3D; </p>
<ul>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping(处理器映射器)</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)</li>
<li>DispatcherServlet调用HandlerAdapter(处理器适配器)HandlerAdapter经过适配调用具体的处理器(Handler&#x2F;Controller)Controller执行完成返回</li>
<li>ModelAndView对象HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover(视图解析器)</li>
<li>ViewReslover解析后返回具体View(视图)</li>
<li>DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)</li>
<li>DispatcherServlet响应用户</li>
</ul>
<p>&#x3D;&#x3D;<strong>前后端分离阶段(接口开发，异步请求)</strong>&#x3D;&#x3D;</p>
<ul>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping(处理器映射器)</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter(处理器适配器)</li>
<li>HandlerAdapter经过适配调用具体的处理器(Handler&#x2F;Controller)</li>
</ul>
<p><span style = "color:red"><strong>SpringBoot自动配置原理？</strong></span></p>
<blockquote>
<p>SpringBoot中最高频的一道面试题，也是框架最核心的思想<br>&#x3D;&#x3D;<code>@SpringBootConfiguration</code>&#x3D;&#x3D;：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类<br>&#x3D;&#x3D;<code>@ComponentScan</code>&#x3D;&#x3D;：组件扫描，默认扫描当前引导类所在包及其子包<br>&#x3D;&#x3D;<code>@EnableAutoConfiguration</code>&#x3D;&#x3D;：SpringBoot实现自动化配置的核心注解</p>
<p>1，在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是:</p>
<ul>
<li>@SpringBootConfiquration</li>
<li>@EnableAutoConfiquration</li>
<li>@ComponentScan</li>
</ul>
<p>2，其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解。该注解通过<code>@Import</code>注解导入对应的配置选择器。内部就是读取了该项目和该项目引用的jar包的的classpath路径下<code>META-INF/spring.factories</code>文件中的所配置的类的全类名。在这些配置类中所定义的Bean会根据条件注解<strong>所指定的条件来决定</strong>是否需要将其导入到Spring容器中。</p>
<p>3，条件判断会有像<code>@ConditionalOnClass</code>这样的注解，<u>判断是否有对应的class文件</u>，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p>
</blockquote>
<pre><code class="java">package com.itheima;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// SpringBoot的启动类
// 注意: 我们写的代码要在启动类的包或者子包中
// @SpringBootApplication注解中包含了 @ComponentScan，没有指定扫描哪个包，默认扫描当前类所在的包和子包
@SpringBootApplication
public class Day15TliasManagement01IocDiApplication &#123;
    // 启动项目, 内嵌的Tomcat会启动, 把项目部署到这个内嵌Tomcat中
    public static void main(String[] args) &#123;
        SpringApplication.run(Day15TliasManagement01IocDiApplication.class, args);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>按住<code>ctrl+左键</code>点击<code>@SpringBootApplication</code>会弹到<code>SpringBootApplication.class</code>界面</p>
</blockquote>
<pre><code class="mysql">@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = &#123;@Filter(
    type = FilterType.CUSTOM,
    classes = &#123;TypeExcludeFilter.class&#125;
), @Filter(
    type = FilterType.CUSTOM,
    classes = &#123;AutoConfigurationExcludeFilter.class&#125;
)&#125;
)
</code></pre>
<blockquote>
<p>按住<code>ctrl+左键</code>点击<code>@EnableAutoConfiguration</code>会弹到<code>EnableAutoConfiguration.class</code>界面</p>
</blockquote>
<pre><code class="mysql"># @Import(&#123;AutoConfigurationImportSelector.class&#125;)
# AutoConfigurationImportSelector是自动配置的选择器 
# 会加载META-INF中的spring.factories文件的自动配置类...AutoConfiguration...
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.boot.autoconfigure;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.context.annotation.Import;

@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(&#123;AutoConfigurationImportSelector.class&#125;)
public @interface EnableAutoConfiguration &#123;
    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;

    Class&lt;?&gt;[] exclude() default &#123;&#125;;

    String[] excludeName() default &#123;&#125;;
&#125;
</code></pre>
<p><span style = "color:red"><strong>Spring框架常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围<del>默认单例的</del></td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定Spring在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程(AOP)</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringMVC框架常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping</td>
<td>用于映射请求路径，可以定义在类上和方法上。用于类上，则标识类中的所有的方法都是以该地址作为父路径</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>注解实现接收http请求的json数据，将json转换为java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数的名称</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径中获取请求参数(<code>/user/&#123;id&#125;</code>)，传递给方法的形式参数</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>注解实现将Controller方法返回对象转换成json对象响应给客户端</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>获取指定的请求头数据</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringBoot常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@SpringBootConfiguration</td>
<td>组合了 <code>-@Configuration注解</code>，实现配置文件的功能</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>打开自动配置的功能，也可以关闭某个自动配置的选项</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>Spring组件扫描</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/aa2405d532d8e6606845f6a1a4da8456b797e115/%E6%B3%A8%E8%A7%A3%E5%A4%A7%E6%B1%87%E6%80%BB.png"></p>
<p><span style = "color:red"><strong>MyBatis执行流程？</strong></span></p>
<blockquote>
<ul>
<li>读取MyBatis配置文件:mybatis-config.xml加载运行环境和映射文件</li>
<li>构造会话工厂SqlSessionFactory</li>
<li>会话工厂创建SqlSession对象(包含了执行SQL语句的所有方法)</li>
<li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li>
<li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射</li>
<li>输出结果映射</li>
</ul>
</blockquote>
<ul>
<li>理解了各个组件的关系</li>
<li>Sql的执行过程(参数映射、sql解析、执行和结果处理)</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/7263f0a583711bca127933c0053e2b1fef476cb7/MyBatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" style="zoom:80%;" />



<p><span style = "color:red"><strong>MyBatis是否支持延迟加载？</strong></span></p>
<blockquote>
<ul>
<li>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</li>
<li>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载</li>
<li>在<code>Mybatis配置文件</code>中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true/false</code>，默认是关闭的</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>延迟加载的底层原理知道吗？</strong></span></p>
<blockquote>
<ul>
<li>使用<strong>CGLIB</strong>创建目标对象的代理对象</li>
<li>当调用目标方法时，进入拦截器<strong>invoke</strong>方法，发现目标方法是nul值，执行sql查询</li>
<li>获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</li>
</ul>
</blockquote>
<blockquote>
<p>查询用户的时候，把用户所属的订单数据也查询出来，这个是&#x3D;&#x3D;<strong>立即加载</strong>&#x3D;&#x3D;<br>查询**<u>用户的(sql)</u><strong>时候，暂时不查询订单数据，当需要订单的时候，再查询</strong><u>订单(sql)</u>**，这个就是&#x3D;&#x3D;<strong>延迟加载</strong>&#x3D;&#x3D;</p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/1fdf519599da660621e27393d18b48f4b2bdb802/MyBatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86.png"  />

<p><span style = "color:red"><strong>MyBatis的一级、二级缓存用过吗？</strong></span></p>
<blockquote>
<ul>
<li>一级缓存:基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</li>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用PerpetualCache，HashMap 存储。需要单独开启，一个是核心配置，一个是mapper映射文件</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>MyBatis的二级缓存什么时候会清理缓存中的数据？</strong></span></p>
<blockquote>
<ul>
<li>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ul>
</blockquote>
<ul>
<li>本地缓存，基于PerpetualCache，本质是一个HashMap</li>
<li><strong>一级缓存</strong>：作用域是session级别<ul>
<li>基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，<strong>默认打开一级缓存</strong></li>
</ul>
</li>
<li><strong>二级缓存</strong>：作用域是namespace和mapper的作用域，不依赖于session<ul>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用 PerpetualCache<br>HashMap 存储</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d5f133abb10da579732fe734073e28b0713a3b63/Mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.jpg"></p>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear</li>
<li>二级缓存需要缓存的数据实现Serializable接口</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li>
</ul>
<h2 id="SpringCloud篇"><a href="#SpringCloud篇" class="headerlink" title="SpringCloud篇"></a><span style = "color:blue">SpringCloud篇</span></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/a556069d277599cc45e30c8e2e719fba7ff392cb/SpringCloud%E9%9D%A2%E8%AF%95%E9%A2%98.jpg"></p>
<p><span style = "color:red"><strong>SpringCloud 5大组件有哪些？</strong></span></p>
<p>回答原则：简单的问题不能答错</p>
<table>
<thead>
<tr>
<th>通常情况</th>
<th>SpringCloudAlibba</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka：注册中心</td>
<td>Nacos：注册中心&#x2F;配置中心</td>
</tr>
<tr>
<td>Ribbon：负载均衡</td>
<td>Ribbon：负载均衡</td>
</tr>
<tr>
<td>Feign：远程调用</td>
<td>Feign：远程调用</td>
</tr>
<tr>
<td>Hystrix：服务熔断</td>
<td>sentinel：服务保护</td>
</tr>
<tr>
<td>Zuul&#x2F;Gateway：网关</td>
<td>Gateway：服务网关</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/39f10dd62358b96346cdf42dd3f893f0d0920bcc/SpringCloud5%E5%A4%A7%E7%BB%84%E4%BB%B6.jpg"></p>
<p><span style = "color:red"><strong>服务注册和发现是什么意思？ SpringCloud 如何实现服务注册发现？</strong></span></p>
<blockquote>
<ul>
<li>我们当时项目采用的<code>eureka</code>作为注册中心，这个也是SpringCloud体系的一个核心嘴贱</li>
<li><strong>服务注册</strong>：服务提供者需要把自己的信息注册到eureka来保存这些信息，比如<strong>服务名称、ip、端口</strong>等等</li>
<li><strong>服务发现</strong>：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者利用<strong>负载均衡</strong>算法，选择一个发起调用</li>
<li><strong>服务监控</strong>：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没有收到心跳，从eureka中剔除</li>
</ul>
</blockquote>
<ul>
<li>微服务中必须要使用的组件，考虑我们使用微服务的程度</li>
<li>注册中心的核心作用是：服务注册和发现</li>
<li>常见的注册中心：<strong>eureka、nocas</strong>、zookeeper</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b4f4fe573949c4168cd4114f6cc6a28679f84181/Eureka%E4%BD%9C%E7%94%A8.jpg"></p>
<p><span style = "color:red"><strong>请你说一下nacos与eureka的区别？</strong></span></p>
<blockquote>
<ul>
<li><strong>Nacos与Eureka的共同点</strong> (<u>注册中心</u>)<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务者心跳方式做健康检测</li>
</ul>
</li>
<li><strong>Nacos与Eureka的区别</strong> (<u>注册中心</u>)<ul>
<li>Nacos支持服务端主动检测提供者状态：<strong>临时实例采用心跳模式，非临时实例采用主动检测模式</strong></li>
<li><strong>临时实例心跳不正常会被剔除，非临时实例则不会被提出</strong></li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式<del>高可用模式</del>，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
<li>Nacos还支持了配置中心，Eureka只有注册中心，也是选择选用nacos的一个重要原因</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3c304f59104d2917c35ecb658f95f7073365ed9c/Eureka%E5%92%8CNacos%E5%8C%BA%E5%88%AB.jpg"></p>
<p><span style = "color:red"><strong>把RestTemplate替换成OpenFeign后它们的底层还是一样的吗？</strong></span></p>
<p>OpenFeign的底层原理也是根据服务名称，首先去远程注册中心拉取服务列表，底层也会在本地缓存一份，也会根据负载均衡选出一个实例，又运用了jdk的动态代理生成代理类，也会涉及到反射机制，最终拼出完整的url，发起http远程调用</p>
<p><span style = "color:red"><strong>你们项目负载均衡如何实现的？</strong></span><del>图1.1</del></p>
<blockquote>
<p>微服务的负载均衡主要使用了一个组件Ribbon，比如，我们再使用feign远程调用的过程中，底层的负载均衡就是使用了Ribbon</p>
</blockquote>
<ul>
<li>负载均衡Ribbon，发起远程调用feign就会使用Ribbon</li>
<li>Ribbon负载均衡策略有哪些</li>
<li>如果想自定义负载均衡策略如何实现？</li>
</ul>
<h6 id="Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring-Cloud-LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进"><a href="#Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring-Cloud-LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进" class="headerlink" title="Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring Cloud LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进"></a>Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring Cloud LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/2a6397006f0e74e16de4222ac7ab2758e98aa96c/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0.png"></p>
<p><span style = "color:red"><strong>Ribbon负载均衡策略有哪些？</strong></span></p>
<ul>
<li><span style="color:blue"><strong>RoundRobinRule</strong>：简单<u>轮询服务列表</u>来选择服务器</span></li>
<li><span style="color:blue"><strong>WeightedResponseTimeRule</strong>：按照<u>权重</u>来选择服务器，响应时间越长，权重越小</span></li>
<li><span style="color:blue"><strong>RandomRule</strong>：<u>随机选择</u>一个可用的服务器</span></li>
<li>BestAvaliableRule：忽略那些短路的服务器，并选择并发数较低的服务器</li>
<li>RetryRule：重试机制的选择逻辑</li>
<li>AvaliabilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例</li>
<li><span style="color:blue"><strong>ZoneAvoidanceRule</strong>：以<u>区域可用</u>的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可用理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询</span></li>
</ul>
<p><span style = "color:red"><strong>如果想自定义负载均衡策略如何实现？</strong></span><del>图1.2</del></p>
<blockquote>
<ul>
<li>创建类实现IRule接口，可以指定负载均衡策略（全局）</li>
<li>在客户端的配置文件中，可以配置某一个服务调用的负载均衡（局部）</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>SpringCloud中什么是服务雪崩，怎么解决这个问题？</strong></span></p>
<ul>
<li>什么是&#x3D;&#x3D;<strong>服务雪崩</strong>&#x3D;&#x3D;？<del>一个服务失败，导致整条链路的服务都失败的情形</del></li>
</ul>
<blockquote>
<ul>
<li>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9900715f7f6943c509f9312dc31f4cf581e0af49/%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9.jpg"></p>
<ul>
<li>&#x3D;&#x3D;<u><strong>熔断降级</strong></u>&#x3D;&#x3D; &amp;&amp; &#x3D;&#x3D;<strong>服务熔断</strong>&#x3D;&#x3D;（解决）<strong>Hystix 服务熔断降级</strong></li>
</ul>
<blockquote>
<p><strong><u>服务降级</u></strong><del>部分服务不可用</del>：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，<span style = "color:orange"><strong>一般在实际开发中与Feign接口整合，编写降级逻辑</strong></span></p>
</blockquote>
<blockquote>
<p><strong><u>服务熔断</u></strong><del>整个服务不可用</del>：默认关闭，需要手动打开，如果监测到<span style = "color:orange"><strong>10秒内请求的失败率超过50%</strong></span>，就触发熔断机制。之后<span style = "color:orange"><strong>每隔5秒重新尝试请求</strong></span>微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a3195c4ca2d1f63815e09a802354a9c28209893b/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5.jpg"></p>
<ul>
<li><strong>限流（预防）</strong><del>微服务限流(漏桶算法、令牌桶算法)</del></li>
</ul>
<p><span style = "color:red"><strong>你们项目中有没有做到限流？怎么做的？&amp;&amp; 限流常见的算法有哪些？？</strong></span></p>
<blockquote>
<p>① 先来介绍一下业务，什么情况下去做限流，需要说明<strong>QPS</strong>具体是多少</p>
<ul>
<li>我们有一个活动，到了假期就会抢购优惠券，QPS最高可以达到2000，平时10-50之间，为了应对突发流量，需要做限流</li>
<li>常规限流，为了防止恶意攻击，保护系统正常运行，我们当时系统能够承受最大的QPS是多少(压测结果)</li>
</ul>
<p>② <strong>nginx限流</strong></p>
<ul>
<li>控制速率(突发流量)，使用的漏桶算法来实现过滤，让请求以固定的速率处理请求，可以应对突发流量</li>
<li>控制并发数，限制单个ip的连接数和并发链接的总数</li>
</ul>
<p>③ <strong>网关限流</strong></p>
<ul>
<li>在SpringCloudGateway中支持局部过滤器RequestRateLimiter来做限流，使用的是令牌桶算法</li>
<li>可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</li>
</ul>
</blockquote>
<blockquote>
<h4 id="解释原理："><a href="#解释原理：" class="headerlink" title="解释原理："></a>解释原理：</h4><p>QPS（Queries Per Second，每秒查询率）是衡量一个系统处理请求能力的指标，它表示服务器在一秒钟内能够处理的查询数量。这个指标常用于数据库和web服务器等应用，以评估系统在高并发情况下的性能。<br>以下是对您提到的两句话的分析：</p>
<ol>
<li><strong>活动期间的高并发处理：</strong></li>
</ol>
<ul>
<li><strong>背景知识：</strong> 在电子商务等应用中，促销活动往往会引起用户的大量点击和购买行为，导致短时间内流量剧增。</li>
<li><strong>限流原理：</strong> 为了应对这种突发的高流量，系统需要实施限流措施。限流是为了保护系统资源不被过度消耗，确保系统的稳定性和可靠性。常见的限流算法有固定窗口、滑动窗口、令牌桶和漏桶等。</li>
<li><strong>实施方式：</strong> 在您提到的情况下，可以采用以下策略：<ul>
<li><strong>预判性扩容：</strong> 根据历史数据和活动规模预测流量，提前进行服务器资源的扩容。</li>
<li><strong>动态限流：</strong> 在活动期间，根据实时监控的QPS数据动态调整限流阈值，保证系统平稳运行。</li>
<li><strong>排队处理：</strong> 对于超出系统处理能力的请求，可以采用队列进行缓冲，分批次处理。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>常规限流与系统最大承受QPS：</strong></li>
</ol>
<ul>
<li><strong>背景知识：</strong> 常规限流是为了在日常运行中防止恶意攻击（如DDoS攻击）和保护系统资源不被滥用。</li>
<li><strong>压测结果：</strong> 系统的最大承受QPS是通过压力测试得出的。压力测试（也称为负载测试）是通过模拟高并发访问来测试系统的极限性能，以确定系统在保证稳定运行的前提下能够承受的最大QPS。</li>
<li><strong>原理分析：</strong> <ul>
<li><strong>保护系统：</strong> 通过设定一个QPS上限，可以防止系统过载，保障系统的正常运行。</li>
<li><strong>资源分配：</strong> 了解系统的最大承受QPS有助于合理分配资源，如数据库连接、内存和CPU等。</li>
<li><strong>用户体验：</strong> 适当的限流可以保证用户的体验，避免因系统过载导致的响应缓慢或服务不可用。<br>在实施限流策略时，还需要考虑以下因素：</li>
</ul>
</li>
<li><strong>业务优先级：</strong> 对于不同的业务请求，可能需要有不同的限流策略，优先保证核心功能的可用性。</li>
<li><strong>用户体验：</strong> 限流策略应尽量减少对用户体验的影响，例如通过友好的错误提示或降级方案。</li>
<li><strong>数据监控：</strong> 实时监控系统的QPS和其他关键指标，以便快速响应并调整限流策略。<br>综上所述，限流是确保系统在高并发情况下稳定运行的重要措施，而了解系统的最大承受QPS是制定合理限流策略的基础。</li>
</ul>
</blockquote>
<p>为什么要限流？</p>
<ul>
<li>并发业务量大(突发流量)</li>
<li>防止用户恶意刷接口</li>
</ul>
<h6 id="限流的实现方式："><a href="#限流的实现方式：" class="headerlink" title="限流的实现方式："></a>限流的实现方式：</h6><ul>
<li><p>&#x3D;&#x3D;<strong>Tomcat</strong>&#x3D;&#x3D;<del>单体项目可以,分布式不行</del>：可以设置最大连接数 <code>&lt;Connector port=&quot;8080&quot;...maxThreads=&quot;150&quot;...&gt;</code></p>
</li>
<li><p>&#x3D;&#x3D;<strong>Nginx</strong>&#x3D;&#x3D;：<strong>漏桶算法</strong><del>固定速率露出(平滑)</del></p>
<p>控制速率(突发流量)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/8090ab914e03e67198de3dd121167624b5c3a541/Nginx%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E9%99%90%E6%B5%81.png" style="zoom: 200%;" />
</li>
<li><p>&#x3D;&#x3D;<strong>网关</strong>&#x3D;&#x3D;：<strong>令牌桶算法</strong></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/e32511e92db5c1c27f7fad58f5078039014016a6/%E7%BD%91%E5%85%B3%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png" style="zoom: 200%;" />
</li>
<li><p>自定义拦截器</p>
</li>
</ul>
<p><span style = "color:red"><strong>你们的微服务是怎么监控的？</strong></span></p>
<blockquote>
<p><strong>我们项目中采用的skywalking进行监控的</strong></p>
<ul>
<li>skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</li>
<li>我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</li>
</ul>
</blockquote>
<h6 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h6><p>一个分布式系统的应用程序性能监控工具(Application Performance Management), 提供了完善的链路追踪能力，apache的顶级项目(前华为产品经理吴晟主导开源)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/889f98186e8bf25ea018e80457f9333fef009d07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A71.jpg"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/33749d5ca478f04bee93c83339a877330485f51a/skywalking%E7%9B%91%E6%8E%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1.png"></p>
<p><span style = "color:red"><strong>解释一下CAP和BASE<del>分布式系统理论</del></strong></span></p>
<blockquote>
<ul>
<li>CAP 定理(一致性、可用性、分区容错性)</li>
</ul>
<ol>
<li>分布式系统节点通过网络连接，一定会出现分区问题(P)</li>
<li>当分区出现时，系统的一致性(C)和可用性(A)就无法同时满足</li>
</ol>
<ul>
<li>BASE理论</li>
</ul>
<ol>
<li>基本可用</li>
<li>软状态</li>
<li>最终一致</li>
</ol>
<ul>
<li>解决分布式事务的思想和模型</li>
</ul>
<ol>
<li><u>最终一致思想</u>：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据(AP)</li>
<li><u>强一致思想</u>：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚(CP)</li>
</ol>
</blockquote>
<ul>
<li>分布式事务方案的指导</li>
<li>分布式系统设计方向</li>
<li>根据业务指导使用正确的技术选择</li>
</ul>
<h5 id="x3D-x3D-CAP定理-x3D-x3D-分布式系统无法同时满足三个指标"><a href="#x3D-x3D-CAP定理-x3D-x3D-分布式系统无法同时满足三个指标" class="headerlink" title="&#x3D;&#x3D;CAP定理&#x3D;&#x3D;分布式系统无法同时满足三个指标"></a>&#x3D;&#x3D;CAP定理&#x3D;&#x3D;<del>分布式系统无法同时满足三个指标</del></h5><ul>
<li>&#x3D;&#x3D;<strong>Consistency</strong>&#x3D;&#x3D;（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。<del>主从一致</del></li>
<li>&#x3D;&#x3D;<strong>Availability</strong>&#x3D;&#x3D;（可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</li>
<li>&#x3D;&#x3D;<strong>Partition</strong> tolerance&#x3D;&#x3D;（分区容错性）：当出现网络分区现象后，系统能够继续运行<ul>
<li>Partition（分区）：因为网络故障或其他原因导致分布式系统中的部分节点与其他节点失去链接，形成独立分区</li>
<li>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务</li>
</ul>
</li>
</ul>
<p>结论：</p>
<ul>
<li>分布式系统节点之间肯定是需要网络链接的，<strong>分区 (P) 必然存在</strong></li>
<li><u>如果保证访问的高可用性（<strong>A</strong>）可以持续对外提供服务</u>，但不能保证数据的强一致性 <strong>AP</strong></li>
<li><u>如果保证访问的数据强一致性（C）就要放弃高可用性</u> <strong>CP</strong></li>
</ul>
<h5 id="x3D-x3D-BASE理论-x3D-x3D"><a href="#x3D-x3D-BASE理论-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;BASE理论&#x3D;&#x3D;"></a>&#x3D;&#x3D;BASE理论&#x3D;&#x3D;</h5><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li>&#x3D;&#x3D;<strong>Basically Avaliable</strong>&#x3D;&#x3D;（基本可用）：分布式系统在出现故时，允许损失部分可用性，即保证核心可用</li>
<li>&#x3D;&#x3D;<strong>Soft State</strong>&#x3D;&#x3D;（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态</li>
<li>&#x3D;&#x3D;<strong>Eventually Consistent</strong>&#x3D;&#x3D;（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3f0f7a676a51ce6dded96d7c6a910a7c6b763d99/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%92%88%E5%AF%B9CAP%E7%9A%84BASE%E7%90%86%E8%AE%BA.jpg"></p>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/data/CAP%E5%AE%9A%E7%90%86.jpg?raw=true"></p>
<p><span style = "color:red"><strong>你们采用哪种分布式事务解决方案？</strong></span></p>
<blockquote>
<p>● 简历上写的微服务，只要是发生了多个服务之间的<strong>写操作</strong>，都需要进行分布式事务控制</p>
<p>● 描述项目中采用的哪种方案(seataMQ)<br>⚪ seata的XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差 (<span style = "color:red"><strong>银行业务</strong></span> )<br>⚪ seata的AT模式，AP，底层使用undolog 实现，性能好 (<span style = "color:red"><strong>互联网业务</strong></span> )<br>⚪ seata的TCC模式，AP，性能较好，不过需要人工编码实现 (<span style = "color:red"><strong>银行业务</strong></span> )<br>⚪ MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务异步，性能最好 (<span style = "color:red"><strong>互联网业务</strong></span> )</p>
</blockquote>
<ul>
<li>Seata框架(XA、AT、TCC)</li>
<li>MQ</li>
</ul>
<h4 id="Seata架构"><a href="#Seata架构" class="headerlink" title="Seata架构"></a>Seata架构</h4><ul>
<li><strong>TC</strong>(Transaction Coordinator) - <strong>事务协调者</strong>：<u>维护全局和分支事务的状态，协调全局事务提交或回滚</u></li>
<li><strong>TM</strong>(Transaction Manager) - <strong>事务管理器</strong>：定义全局事务的范围、开启全局事务、提交或回滚全局事务</li>
<li><strong>RM</strong>(Resource Manager) - <strong>资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/30dd6983ec4340d3f3f4118f3d5ccf89e4199555/XA%2CAT%2CTCC.png"></p>
<p><span style = "color:red"><strong>分布式服务的<u>接口幂等性</u>如何设计？</strong></span></p>
<blockquote>
<ul>
<li>幕等: 多次调用方法或者接口不务状态，可以<strong>保证重复调用的结果和单次调用的结果一致</strong></li>
<li>如果是**<u>新增数据</u>**，可以使用数据库的唯一索引</li>
<li>如果是**<u>新增或修改数据</u>**<ul>
<li>分布式锁，性能较低</li>
<li>使用token+redis来实现，性能较好<br>●  第一次请求，生成一个唯一token存入redis，返回给前端<br>●  第二次请求，业务处理，携带之前的token，到redis进行验证，如果存在，可以执行业务，删除token; 如果不存在，则直接返回，不处理业务</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>幂等</strong>：<u>多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</u></p>
<h6 id="需要幂等场景"><a href="#需要幂等场景" class="headerlink" title="需要幂等场景"></a>需要幂等场景</h6><ul>
<li>用户重复点击(网络波动)</li>
<li>MQ消息重复</li>
<li>应用使用失败或超时</li>
</ul>
<table>
<thead>
<tr>
<th>请求方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>查询操作，天然幂等</td>
</tr>
<tr>
<td>POST</td>
<td>新增操作，请求一次与请求多次造成的结果不同，<strong>不是幂等的</strong></td>
</tr>
<tr>
<td>PUT</td>
<td>更新操作，如果是以绝对值更新，则是幂等的。如果是通过增量的方式更新，则<strong>不是幂等的</strong></td>
</tr>
<tr>
<td>DELETE</td>
<td>删除操作，根据唯一值删除，是幂等的</td>
</tr>
</tbody></table>
<pre><code class="mysql">update a set money = 500 where id = 1 【幂等】
update a set money = money + 500 where id = 1; 【非幂等】
</code></pre>
<ul>
<li><p><strong>数据库唯一索引</strong>【新增】</p>
</li>
<li><p><strong>&#x3D;&#x3D;token + redis&#x3D;&#x3D;</strong> 【新增+修改】**<u>AND</u>**  <strong>&#x3D;&#x3D;分布式锁&#x3D;&#x3D;</strong> 【新增+修改】</p>
<h6 id="创建商品、提交订单、转账、支付等操作"><a href="#创建商品、提交订单、转账、支付等操作" class="headerlink" title="创建商品、提交订单、转账、支付等操作"></a>创建商品、提交订单、转账、支付等操作</h6></li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/58b8b5385bf3e40c1661e824f613b15f57686549/token+redis%20AND%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" style="zoom:200%;" />



<p><span style = "color:red"><strong>你们项目中使用了什么分布式任务调度</strong></span></p>
<p><code>xxl-job</code> 是一个分布式任务调度平台，它致力于解决分布式场景下的任务调度问题，主要由调度中心和执行器两部分组成。调度中心负责统一管理任务调度，而执行器则是负责接收调度并执行任务逻辑的客户端。</p>
<ul>
<li><p><span style = "color:red"><strong>xxl-job路由策略有哪些？</strong></span></p>
<blockquote>
<p>xxl-job提供了很多的路由策略，我们平时用的较多的就是：<strong>轮询、故障转移、分片广播</strong></p>
</blockquote>
</li>
<li><p><span style = "color:red"><strong>xxl-job任务执行失败怎么解决？</strong></span></p>
<blockquote>
<ul>
<li>路由策略选择<strong>故障转移</strong>，使用健康的实例来执行任务</li>
<li>设置重试次数</li>
<li>查看<strong>日志+邮件</strong>警告来通知相关负责人解决</li>
</ul>
</blockquote>
</li>
<li><p><span style = "color:red"><strong>如果有大数据量的任务同时都现需要执行，怎么解决？</strong></span></p>
<blockquote>
<ul>
<li>让多个实例一块去执行(部署集群)，路由策略<strong>分片广播</strong></li>
<li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行</li>
</ul>
</blockquote>
</li>
</ul>
<h6 id="xxl-job解决的问题"><a href="#xxl-job解决的问题" class="headerlink" title="xxl-job解决的问题"></a>xxl-job解决的问题</h6><ul>
<li>解决集群任务的重复执行问题                   xxl-job路由策略有哪些？</li>
<li>cron表达式定义灵活<del>在页面上</del>                      xxl-job任务执行失败怎么解决？</li>
<li>定时任务失败了，重试和统计                   如果有大数据量的任务同时都需要执行，怎么解决？</li>
<li>任务量大，分片执行</li>
</ul>
<blockquote>
<h4 id="场景-1-定时处理过期订单"><a href="#场景-1-定时处理过期订单" class="headerlink" title="场景 1: 定时处理过期订单"></a>场景 1: <strong>定时处理过期订单</strong></h4><p>假设用户下单后如果订单超过了某个时间没有支付，平台需要自动取消该订单并释放库存。这个任务需要在每天的某个固定时间（比如凌晨 2 点）运行。</p>
<h5 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>定时任务调度</strong>：XXL-Job 可以轻松管理该任务的执行时间和周期，确保每天准时执行，不需要开发者手动触发。</li>
<li><strong>任务失败重试</strong>：如果该任务因为某些原因执行失败，XXL-Job 可以自动进行重试，并设置重试次数，确保任务最终被执行。</li>
<li><strong>分布式执行</strong>：假设电商平台是一个分布式系统，订单数据存储在多个数据库中，XXL-Job 可以通过分布式执行确保每个数据库的订单都被正确处理</li>
</ol>
<p><u>假设每晚 2 点有一个任务需要取消未支付的订单</u>：</p>
<pre><code class="java">public class OrderJob &#123;
    @JobHandler(&quot;orderCancelJobHandler&quot;)
    public void cancelUnpaidOrders() &#123;
        // 查询所有未支付的订单
        List&lt;Order&gt; unpaidOrders = orderService.findUnpaidOrders();
        for (Order order : unpaidOrders) &#123;
            if (order.isExpired()) &#123;
                orderService.cancelOrder(order);
                inventoryService.releaseStock(order.getProductId(), order.getQuantity());
                // 发送订单取消通知给用户
                notificationService.sendOrderCancelledNotification(order.getUserId());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="场景-2-定时更新商品库存"><a href="#场景-2-定时更新商品库存" class="headerlink" title="场景 2: 定时更新商品库存"></a>场景 2: <strong>定时更新商品库存</strong></h4><p>假设电商平台上销售的是一些有时效性的商品，商家需要定期更新商品的库存状态（例如，库存数量达到一定阈值时，自动下架商品，或者增加库存数量）。这个任务同样需要定时执行。</p>
<h5 id="解决的问题：-1"><a href="#解决的问题：-1" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>任务分片</strong>：在商品很多的情况下，XXL-Job 可以通过任务分片的方式并行处理不同商品的库存更新，提升任务的执行效率。</li>
<li><strong>任务优先级</strong>：根据不同商品的重要程度，XXL-Job 可以设置任务的优先级，确保关键商品的库存更新优先执行。</li>
</ol>
<pre><code class="java">public class InventoryJob &#123;
    @JobHandler(&quot;inventoryUpdateJobHandler&quot;)
    public void updateProductInventory() &#123;
        // 获取需要更新库存的商品
        List&lt;Product&gt; productsToUpdate = productService.findProductsForInventoryUpdate();
        for (Product product : productsToUpdate) &#123;
            inventoryService.updateInventory(product);
            if (product.getStockQuantity() &lt;= product.getLowStockThreshold()) &#123;
                productService.deactivateProduct(product);
                // 发送商品下架通知
                notificationService.sendOutOfStockNotification(product.getId());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="场景-3-定时发送促销活动通知"><a href="#场景-3-定时发送促销活动通知" class="headerlink" title="场景 3: 定时发送促销活动通知"></a>场景 3: <strong>定时发送促销活动通知</strong></h4><p>假设电商平台有一个促销活动，每个活动的开始和结束时间都由后台系统控制。需要在活动开始前 1 小时、活动结束时发送通知给用户。这些通知可以是短信、邮件或 APP 推送通知。</p>
<h5 id="解决的问题：-2"><a href="#解决的问题：-2" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>定时任务管理</strong>：XXL-Job 可以定时触发通知任务，确保用户在活动前后及时收到通知。</li>
<li><strong>高并发支持</strong>：在促销活动开始或结束时，平台可能会有大量的通知需要发送，XXL-Job 支持任务的并行处理，可以帮助我们高效地分发通知，避免性能瓶颈。</li>
<li><strong>任务状态监控</strong>：XXL-Job 提供任务的实时监控功能，平台可以随时查看任务的执行情况，确保通知任务按时执行。</li>
</ol>
<pre><code class="java">public class PromotionJob &#123;
    @JobHandler(&quot;promotionNotifyJobHandler&quot;)
    public void sendPromotionNotifications() &#123;
        // 获取当前正在进行的促销活动
        List&lt;Promotion&gt; activePromotions = promotionService.findActivePromotions();
        for (Promotion promotion : activePromotions) &#123;
            if (promotion.isStartingSoon()) &#123;
                notificationService.sendStartNotification(promotion);
            &#125; else if (promotion.isEndingSoon()) &#123;
                notificationService.sendEndNotification(promotion);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</blockquote>
<h6 id="xxl-job路由策略有哪些？"><a href="#xxl-job路由策略有哪些？" class="headerlink" title="xxl-job路由策略有哪些？"></a>xxl-job路由策略有哪些？</h6><p>实例找任务项执行任务 这种<strong>找机器的方式</strong>就是路由策略</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0ee1e805b34b443e5fed49434ec33e59c264894b/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5.png"></p>
<h3 id="消息中间件RabbitMQ-Kafka"><a href="#消息中间件RabbitMQ-Kafka" class="headerlink" title="消息中间件RabbitMQ+Kafka"></a>消息中间件<del>RabbitMQ+Kafka</del></h3><h6 id="消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦"><a href="#消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦" class="headerlink" title="消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦"></a>消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦</h6><p><strong>RabbitMQ</strong>：**<u>消息不丢失、消息重复消费、消息堆积、延迟队列、死信队列、高可用机制</u>**<br><strong>Kafka</strong>：**<u>消息不丢失、消息重复消费、高可用机制、高性能设计</u><del>吞吐量达到百万级</del>、<u>数据存储和清理</u>**</p>
<p><span style = "color:red"><strong>RabbitMQ-如何保证消息不丢失？</strong></span></p>
<blockquote>
<ul>
<li><p><u>开启<strong>生产者确认机制</strong>，确保生产者的消息能到达队列</u><br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
<blockquote>
<p>达到队列成功返回<code>ack</code>，失败返回<code>nack</code>【<u><strong>n</strong>egative <strong>ack</strong>nowledgment</u>】</p>
<ol>
<li>生产者发送消息到交换机。</li>
<li>交换机收到消息后，根据绑定规则（是否有匹配的队列）决定消息是否被正确路由。</li>
<li>如果消息成功路由到队列，交换机会向生产者返回 <code>ack</code> 确认。</li>
<li>如果消息没有成功路由到任何队列，交换机会通过 <code>return</code> 将消息退回给生产者。</li>
<li>生产者收到 <code>ack</code> 或 <code>nack</code>，可以处理消息确认或重试逻辑。</li>
</ol>
</blockquote>
</li>
<li><p><u>开启<strong>持久化功能</strong>，确保消息未消费前在队列中不会丢失</u><br>万一broker挂掉就惨了 保证至少成功一次消费<br>MQ是默认内存存储信息，开启持久化功能可以确保缓存在MQ中的消息不丢失[把数据存在磁盘上]</p>
</li>
<li><p><u>开启<strong>消费者确认机制</strong>为auto，由spring确认消息处理成功后完成ack</u><br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：**<u>消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息</u>**，而Spring AMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h5 id="x3D-x3D-生产者确认机制-x3D-x3D"><a href="#x3D-x3D-生产者确认机制-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;生产者确认机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;生产者确认机制&#x3D;&#x3D;</h5><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ad3b4f558db898d6e3a53744beb5512a958f9f57/MQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1.png"></p>
<p><span style = "color:red"><strong>RabbitMQ消息的重复消费问题如何解决的？</strong></span></p>
<blockquote>
<p>我们当时消费者是设置了自动确认机制，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息，这样就重复消费了<br><u>因为我们当时处理的支付（订单|业务唯一标识），它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。<strong>如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了</strong></u>。</p>
</blockquote>
<h6 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h6><ul>
<li>网络抖动</li>
<li>消费者挂了</li>
</ul>
<p>解决方案：<del>适用于任何MQ(Kafka，RabbitMQ，RocketMQ)</del></p>
<ul>
<li><strong>每条消息设置一个唯一的标识id</strong></li>
<li>幂等方案：【<strong>分布式锁</strong>、数据库锁(悲观锁、乐观锁)】</li>
</ul>
<p><span style = "color:red"><strong>RabbitMQ中死信交换机？(RabbitMQ延迟队列有了解过吗)</strong></span></p>
<p>如果用原来的定时任务 也可以但是 可能会有订单空窗期 如果没人消费的时候 它内部还是回去sql查询<strong>已下单</strong> +(now()-下单时间)?15min : true, false</p>
<blockquote>
<ul>
<li>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布）</li>
<li>其中<strong>延迟队列</strong>就用到了<strong>死信交换机</strong>和<strong>TTL</strong>（消息存活时间）实现的</li>
<li>消息超时未消费就会变成死信（死信的其他情况：<strong>拒绝被消费，队列满了</strong>）</li>
</ul>
<p>延迟队列插件实现延迟队列<code>DelayExchange</code></p>
<ul>
<li>声明一个交换机，添加delayed属性为true</li>
<li>发送消息时，添加<code>x-delay</code>头，值为超过时间</li>
</ul>
<pre><code class="java">什么样的消息会成为死信？
★ 消费者返回reject或者nack，且requeue参数设置为false【消息被拒绝并且不重入队列】
★ 消息超时未消费
★ 队列满了

如何给队列绑定死信交换机？
★ 给队列设置dead-letter-exchange属性，指定一个交换机
★ 给队列设置dead-letter-routing-key属性，设置死信交换机与死信队列的RoutingKey

------------------------------------------------------------------------
★ ★ ★ 使用 Spring AMQP 配置 ★ ★ ★ 
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig &#123;

    // 定义普通队列
    @Bean
    public Queue normalQueue() &#123;
        return new Queue(&quot;normalQueue&quot;, true, false, false, 
                Map.of(&quot;x-dead-letter-exchange&quot;, &quot;dlx_exchange&quot;, 
                       &quot;x-dead-letter-routing-key&quot;, &quot;dlx_routing_key&quot;));
    &#125;

    // 定义死信队列
    @Bean
    public Queue dlxQueue() &#123;
        return new Queue(&quot;dlxQueue&quot;, true);
    &#125;

    // 定义普通交换机
    @Bean
    public Exchange normalExchange() &#123;
        return new TopicExchange(&quot;normal_exchange&quot;);
    &#125;

    // 定义死信交换机
    @Bean
    public Exchange dlxExchange() &#123;
        return new TopicExchange(&quot;dlx_exchange&quot;);
    &#125;

    // 将普通队列与交换机绑定
    @Bean
    public Binding bindNormalQueue() &#123;
        return BindingBuilder.bind(normalQueue()).to(normalExchange()).with(&quot;normal.routing.key&quot;).noargs();
    &#125;

    // 将死信队列与死信交换机绑定
    @Bean
    public Binding bindDLXQueue() &#123;
        return BindingBuilder.bind(dlxQueue()).to(dlxExchange()).with(&quot;dlx_routing_key&quot;).noargs();
    &#125;
&#125;
------------------------------------------------------------------------
如果你希望将死信队列配置成带有过期时间或其他特殊属性的队列，可以在定义 dlxQueue 时增加更多的设置，例如 TTL（过期时间）。
例如，设置死信队列的 TTL：

@Bean
public Queue dlxQueue() &#123;
    return QueueBuilder.durable(&quot;dlxQueue&quot;)
            .withArgument(&quot;x-message-ttl&quot;, 60000) // 设置TTL为60秒
            .build();
&#125;
</code></pre>
</blockquote>
<h6 id="延迟队列-x3D-死信交换机-TTL-生存时间"><a href="#延迟队列-x3D-死信交换机-TTL-生存时间" class="headerlink" title="延迟队列 &#x3D; 死信交换机 + TTL (生存时间)"></a><span style = "color:blue">延迟队列 &#x3D; 死信交换机 + TTL (生存时间)</span></h6><ul>
<li><strong>延迟队列</strong>：进入队列的消息会被延迟消费的队列</li>
<li><strong>场景</strong>：超时订单、限时优惠，定时发布</li>
</ul>
<h6 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h6><p>当一个队列中的消息满足下列情况之一时，可以成为<strong>死信</strong>(dead letter)：</p>
<ul>
<li>消费者使用basic.reject 或 basic.nack声明消费失败，并且信息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果该队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>(Dead Letter Exchange，简称DLX)</p>
<pre><code class="java">@Bean
public QUeue ttlQueue()&#123;
    return QueueBuilder.durable(&quot;simple.queue&quot;) // 指定队列名称，并持久化
        .ttl(10000) // 设置队列的超时时间 10秒
        .deadLetterExchange(&quot;dl.direct&quot;) // 指定死信交换机
        .build();
&#125;
</code></pre>
<h6 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h6><p>TTL(Time-To-Live)。如果一个队列中的消息TTL结束仍未消费，则会变成死信，ttl超时分为两种情况：</p>
<ul>
<li><strong>消息所在的队列设置了存活时间</strong></li>
<li><strong>消息本身设置了存活时间</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/50eb7d1338c4fdae6ee9c65274b3116ac361514d/%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="死信图片"></p>
<p><span style = "color:red"><strong>RabbitMQ如果有100万消息堆积在MQ，如何解决(消息堆积怎么解决)？</strong><br></span></p>
<blockquote>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li><strong>增加更多消费者</strong>，提高消费速度</li>
<li>在消费者内<strong>开启线程池</strong>加快消息处理速度</li>
<li><strong>扩大队列容积</strong>，提高堆积上限<ul>
<li>在声明队列的时候可以设置<code>x-queue-model</code>为lazy，即为惰性队列</li>
<li>基于磁盘存储，消息上限高</li>
<li>性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低</li>
</ul>
</li>
</ul>
</blockquote>
<p>当<strong>生产者发送消息的速度超过了消费者处理消息的速度</strong>，就会导致队列中的<strong>消息堆积</strong>，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h6 id="达到上限发送的消息会变成死信，那我为什么不搞个死信交换机-而是用了上面的三种思路？？"><a href="#达到上限发送的消息会变成死信，那我为什么不搞个死信交换机-而是用了上面的三种思路？？" class="headerlink" title="达到上限发送的消息会变成死信，那我为什么不搞个死信交换机 而是用了上面的三种思路？？"></a>达到上限发送的消息会变成死信，那我为什么不搞个死信交换机 而是用了上面的三种思路？？</h6><blockquote>
<p>使用死信交换机（DLX, Dead Letter Exchange）是另一种处理消息堆积的方式，但它的作用更偏向于“消息过期”或“处理失败”的情况下将消息转发到另一个队列。并不直接解决生产者发送消息过快或消费者处理速度过慢的问题。通过死信交换机，你可以将无法处理的消息转发到其他队列，方便你后续进行分析或处理，但它并不能提高消费者处理消息的速度。</p>
<p>针对消息堆积的本质问题，解决方式更多的是优化消费者处理能力，而不是仅依赖死信交换机。具体而言，死信交换机和你的三种思路的关系如下：</p>
<ol>
<li><strong>死信交换机（DLX）</strong>：当消息达到队列上限或无法消费时，消息被转发到死信队列。你可以分析死信队列中的消息，了解原因，并决定是重试、丢弃还是进行其他处理。它的作用是<strong>不丢失消息</strong>，但并不能帮助消除堆积。</li>
<li><strong>增加消费者</strong>：这是直接针对堆积的根本解决方案，通过增加消费者数量来加速消息的处理。死信交换机无法直接解决消费者处理能力不足的问题。</li>
<li><strong>开启消费者线程池</strong>：在单个消费者上开启线程池，可以提高消费者的处理能力，减少堆积。死信交换机并不能增加消息处理速度，它只是用来应对消费失败的情况。</li>
<li><strong>扩大队列容量并使用惰性队列</strong>：惰性队列可以将消息存储在磁盘上，而非内存中，减轻内存压力，但这也会降低时效性，并不能解决生产者生产过快或消费者消费过慢的问题。死信交换机同样无法直接解决这一点。</li>
</ol>
<p>总结来说，死信交换机是处理消息丢失或无法消费的方式，它和通过增加消费者、线程池、队列优化这些手段并不冲突，但也无法替代这些更直接的解决方案。你可以结合这两者，使用死信交换机来保障消息不丢失，同时采取上述方法来提高消息消费速度。</p>
</blockquote>
<h6 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h6><p>惰性队列特征如下：</p>
<ul>
<li>接收到消息后直接存入磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<pre><code class="java">@Bean
public Queue lazyQueue()&#123;
    return QueueBuilder
            .durable(&quot;lazy.queue&quot;)
            .lazy()
            .build();
&#125;
</code></pre>
<pre><code class="java">@RabbitListener(queuesToDeclare = @Queue)&#123;
    name = &quot;lazy.queue&quot;,
    durable = &quot;true&quot;,
    arguments = @Argument(name = &quot;x-queue-mode&quot;), value=&quot;lazy&quot;
&#125;
public void listenLazyQUeue(String msg)&#123;
    log.info(&quot;接收到lazy.queue的消息：&#123;&#125;&quot;,msg);
&#125;
</code></pre>
<p><strong><span style = "color:red">RabbitMQ高可用机制有了解过吗？ &amp;&amp;  请描述 RabbitMQ 镜像队列的工作原理及其在高可用性场景下的优缺点<br></span></strong></p>
<blockquote>
<p>我们当时的项目在生产环境下，采用的是镜像模式搭建的集群，共有3个节点<br>镜像队列结构是一主多从(从就是镜像)，所有(写)操作都是主节点完成，然后同步给镜像节点<br>主宕机后，镜像节点会代替成为新的主(如果在主从同步完成前，主就已经宕机，可能出现数据丢失)</p>
</blockquote>
<p><span style = "color:red"><strong>那出现丢数据怎么解决呢？</strong><br></span></p>
<blockquote>
<p>我们可以采用<strong>仲裁队列</strong>，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致性，并且使用起来也非常简单，不需要格外的配置，<strong>在声明队列的时候只需要指定这个是仲裁队列即可</strong></p>
</blockquote>
<ul>
<li>在生产环境下，使用集群来保证高可用性</li>
<li>普通集群、<strong>镜像集群</strong>、仲裁队列</li>
</ul>
<h5 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h5><p>普通集群，或者叫标准集群(classic cluster)</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的信息</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<h5 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h5><p>镜像集群：本质是<strong>主从模式</strong>，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</li>
<li>创建队列的节点被称为该队列的<strong>主节点</strong>，备份到的其他节点叫做该队列的<strong>镜像</strong>节点</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/59b655f55c1f3031f72c5790425b8ae8e76e9d1f/%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4.png" style="zoom:150%;" />

<h5 id="仲裁队列：-quorum"><a href="#仲裁队列：-quorum" class="headerlink" title="仲裁队列：.quorum()"></a>仲裁队列：<del>.quorum()</del></h5><p>仲裁队列是<strong>3.8版本</strong>以后才有的新功能，用来替代镜像队列</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于<strong>Raft</strong>协议，强一致性</li>
</ul>
<p>仲裁队列的工作原理如下：</p>
<ol>
<li><strong>主从模式</strong>：仲裁队列也是主从模式，支持主从数据同步。</li>
<li><strong>Raft 协议</strong>：主从同步基于 Raft 协议，确保数据的一致性和可靠性。</li>
<li><strong>强一致性</strong>：所有写操作必须得到大多数节点的确认后才能完成，避免了数据丢失。</li>
</ol>
<p>仲裁队列通过以下机制保证数据不丢失：</p>
<ul>
<li><strong>多数派确认</strong>：<u>每次写操作需要得到大多数节点的确认，确保数据已经成功复制到多个节点</u>。</li>
<li><strong>自动故障转移</strong>：如果主节点宕机，<strong>Raft 协议</strong>会自动选举新的主节点，确保服务的连续性。</li>
<li><strong>数据一致性</strong>：<u>Raft 协议保证了数据的<strong>强一致性</strong></u>，即使在网络分区或节点宕机的情况下，也不会出现数据不一致的问题。</li>
</ul>
<p>仲裁队列的优点是配置简单、数据强一致，但需要至少 3 个节点，并且在写操作上的延迟和资源消耗可能会比镜像队列高。</p>
<pre><code class="java">@Bean
public Queue quorumQueue()&#123;
    return QueueBuilder
            .durable(&quot;quorum.queue&quot;) // 持久化
            .quorum() // 仲裁队列
            .build();
&#125;
</code></pre>
<p><span style = "color:red"><strong>Kafka是如何保证消息不丢失？</strong><br></span></p>
<blockquote>
<p>需要从三个层面去解决这个问题</p>
<ul>
<li><p>生产者发送消息到Brocker丢失</p>
<ul>
<li>设置异步发送，发送失败使用回调进行记录或重发</li>
<li>失败重试，参数配置，可以设置重试次数消息</li>
</ul>
</li>
<li><p>在Brocker中存储丢失</p>
<p>发送确认acks，选择all，让所有的副本都参与保存数据后确认</p>
</li>
<li><p>消费者从Brocker接收消息丢失</p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式：最好是<strong>同步+异步提交</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>使用Kafka在消息的收发过程中都会出现消息丢失，Kafka分别给出了解决方案</p>
<ul>
<li>生产者发送消息到Brocker丢失</li>
<li>消息在Brocker中存储丢失</li>
<li>消费者从Brocker接收消息丢失</li>
</ul>
</blockquote>
<p>kafka-高产出的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/ckafka?from_column=20065&from=20065">分布式消息系统</a>(A high-throughput distributed messaging system)。</p>
<p>Kafka是一个高吞吐、分布式、基于发布订阅的消息系统，利用Kafka技术可以在廉价的PC Server上搭建起大规模消息系统。</p>
<h5 id="Kafka的特性："><a href="#Kafka的特性：" class="headerlink" title="Kafka的特性："></a><strong>Kafka的特性：</strong></h5><ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作；</li>
<li>可扩展性：kafka集群支持热扩展；</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/backup?from_column=20065&from=20065">数据备份</a>防止数据丢失；</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）；</li>
<li>高并发：支持数千个客户端同时读写；</li>
<li>支持实时在线处理和离线处理：可以使用Storm这种实时流处理系统对消息进行实时进行处理，同时还可以使用Hadoop这种批处理系统进行离线处理；</li>
</ul>
<p>Kafka和其他组件比较，具有消息持久化、高吞吐、分布式、多客户端支持、实时等特性，适用于离线和在线的消息消费，如常规的消息收集、网站活性跟踪、聚合统计系统运营数据（监控数据）、日志收集等大量数据的互联网服务的数据收集场景。</p>
<ol>
<li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如Hadoop、Hbase、Solr等；</li>
<li>消息系统：解耦和生产者和消费者、缓存消息等；</li>
<li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到Hadoop、数据仓库中做离线分析和挖掘；</li>
<li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告；</li>
<li>流式处理：比如spark streaming和storm；</li>
<li>事件源；</li>
<li>kafka在FusionInsight中的位置：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/fcebf13cb4e2d12dc10727d9d5942720bbd114e6/Kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1.png"></p>
<p><span style = "color:red"><strong>Kafka是如何保证消费的顺序性？</strong><br></span></p>
<blockquote>
<p><strong>问题原因：</strong><br>一个topic的数据可能存储在不同的分区中 ，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p>
<p>&#x3D;&#x3D;<strong>解决方案：</strong>&#x3D;&#x3D;</p>
<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key</li>
</ul>
</blockquote>
<blockquote>
<p>应用场景：</p>
<ul>
<li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li>
<li>充值转账两个渠道在同一个时间进行金额变更，短信通知必须要有顺序</li>
</ul>
</blockquote>
<p>承接上图<code>消费者从Brocker接收消息丢失</code>：<br><strong>如何做</strong>？→ topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<pre><code class="java">// 指定分区
kafkaTemplate.sent(&quot;springboot-kafka-topic&quot;,0,&quot;key-001&quot;,&quot;value-001&quot;);
// 相同的业务key
kafkaTemplate.sent(&quot;springboot-kafka-topic&quot;,&quot;key-001&quot;,&quot;value-001&quot;);
</code></pre>
<p>会计算key的hashcode值推断出它在哪个分区，如果要求有顺序性 就可以设置同一个key，此时hash值都是一样的 就可以在同一个分区存储</p>
<p><span style = "color:red"><strong>Kafka的高可用机制有了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>集群模式</strong>&#x3D;&#x3D;</p>
<p>一个kafka集群由多个broker实例组成，即使某一台宕机，也不会耽误其他broker继续对外提供服务</p>
</li>
<li><p>&#x3D;&#x3D;<strong>分区备份机制</strong>&#x3D;&#x3D;</p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>解释一下复制机制中的ISR？</strong><br></span></p>
<blockquote>
<p>ISR (in-sync replica) 需要同步复制保存的follower<br>分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉后，会优先从ISR副本列表中选取一个作为leader</p>
</blockquote>
<pre><code class="java">// 一个topic默认分区的replication个数，不能大于集群中broker的个数。默认为1
default.replication.factor=3
// 最小的ISR副本个数
min.insync.replicas=2
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b273ced4f6ca9b43b9fb5279e651199e7ad52e9f/Kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6(%E9%9B%86%E7%BE%A4+%E5%88%86%E5%8C%BA%E5%A4%87%E4%BB%BD%E6%9C%BA%E5%88%B6).png"></p>
<p><span style = "color:red"><strong>Kafka数据清理机制了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li>kafka文件存储机制<ul>
<li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li>
<li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxx.log)的形式存储</li>
<li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理</li>
</ul>
</li>
<li>数据清理机制<ul>
<li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认168小时(7天)</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息(默认关闭)</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dbab52581ab3ed1350e8310825216f279c66d7f7/Kafka%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86.png"></p>
<p><span style = "color:red"><strong>Kafka中实现高性能的设计有了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li><span style = "color:blue">消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</span></li>
<li><span style = "color:blue">顺序读写：磁盘顺序读写，提升读写效率</span></li>
<li><span style = "color:blue">页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</span></li>
<li><span style = "color:blue">零拷贝：减少上下文切换及数据拷贝</span></li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：将消息打包批量发送，减少网络开销</li>
</ul>
</blockquote>
<h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/86a930ef22442fc6b9460ee88b64b21983cc9847/kafka%E9%9B%B6%E6%8B%B7%E8%B4%9D.png"></p>
<h2 id="集合面试篇"><a href="#集合面试篇" class="headerlink" title="集合面试篇"></a><span style = "color:red"><strong>集合面试篇</strong></span></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/9f0a0968283f4255bf0047d1761499c7b493ed97/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BBpng.png"></p>
<p><span style = "color:orange"><strong>算法复杂度分析</strong><br></span></p>
<blockquote>
<p>什么是算法时间复杂度？</p>
<ul>
<li>时间复杂度表示了算法的<strong>执行时间</strong>与<strong>数据规模</strong>之间的增长关系</li>
</ul>
<p>常见的时间复杂度有哪些？<del>口诀：常对幂指阶</del></p>
<ul>
<li>O(1)、O(n)、O(n^2)、O(logn)</li>
</ul>
<p>什么是算法的空间复杂度？</p>
<ul>
<li>表示算法占用的额外<code>存储空间</code>和<code>数据规模之间</code>的增长关系<br>常见的空间复杂度：O(1)、O(n)、O(n^2)</li>
</ul>
</blockquote>
<h6 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h6><ul>
<li>指导你编写出性能更优的代码</li>
<li>评判别人写的代码的好坏</li>
</ul>
<h6 id="时间复杂度分析：来评估代码的执行耗时的"><a href="#时间复杂度分析：来评估代码的执行耗时的" class="headerlink" title="时间复杂度分析：来评估代码的执行耗时的"></a>时间复杂度分析：来评估代码的执行耗时的</h6><ul>
<li><p>大O表示法：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong></p>
</li>
<li><p>只要代码的执行时间**<u>不随着n的增大而增大</u><strong>，这样的代码复杂度都是</strong>O(1)**</p>
</li>
<li><p>复杂度分析就是要弄清楚代码的<strong>执行次数</strong>和<strong>数据规模n</strong>之间的关系</p>
</li>
</ul>
<h6 id="时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系"><a href="#时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系" class="headerlink" title="时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系"></a>时间复杂度：全称是<code>渐进空间复杂度</code>，表示算法占用的额外<code>存储空间</code>和<code>数据规模之间</code>的增长关系</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/a0d4930dbc47574f03c8f4db7b995944fb4418e3/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png"></p>
<h3 id="List相关面试题"><a href="#List相关面试题" class="headerlink" title="List相关面试题"></a><span style = "color:red"><strong>List相关面试题</strong></span></h3><blockquote>
<ul>
<li><p>数组是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数组的线性数据结构</p>
</li>
<li><p>数组下标为什么从0开始</p>
<p>寻址公式是：<code>baseAddress + i * data TypeSize</code> 计算下标的内存地址效率较高</p>
</li>
<li><p>查找的时间复杂度</p>
<ul>
<li>随机(<strong>通过下标</strong>)查询的时间复杂度是O(1)</li>
<li>查找元素(<strong>未知下标</strong>)的时间复杂度是O(n)</li>
<li>查找元素(<strong>未知下标但排序</strong>)通过二分查找的时间复杂度是O(logn)</li>
</ul>
</li>
<li><p>插入和删除时间复杂度</p>
<p>插入和删除的时候，为了保证数组的内存连续性，需要挪动数组元素，平均复杂度为O(n)</p>
</li>
</ul>
</blockquote>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><ul>
<li>数据结构—数组</li>
<li>ArrayList源码分析</li>
</ul>
<h6 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h6><ul>
<li>ArrayList底层的实现原理是什么</li>
<li>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次</li>
<li>如何实现数组和List之间的转换</li>
<li>ArrayList和LinkedList的区别是什么</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9c400fc7d26d51223654eb4c997ae331fed38ac8/%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%B8%BA%E4%BB%80%E4%B9%880%E5%BC%80%E5%A7%8B.png"></p>
<p><span style = "color:red"><strong>ArrayList源码分析</strong></span></p>
<blockquote>
<p>List&lt; Integer &gt; list &#x3D; new ArrayList&lt; Integer &gt;();<br>list.add(1)</p>
</blockquote>
<pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;

    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 用于空实例的共享空数组实例
     */
    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;

    /**
     * 用于默认大小的空实例的共享空数组实例
     * 与上面的区分开，以了解添加第一个元素时要膨胀多少
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;
  
    /* 存储ArrayList元素的数组缓冲区，ArrayList的容量就是这个数组缓冲区的长度 */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList的大小(包含的元素数量)
     * @serial
     */
    private int size;
...
&#125;

--------------------------------------------------------------------------------

public ArrayList(int initialCapacity) &#123;
        if (initialCapacity &gt; 0) &#123;
       // 创建一个真正存储集合位置的数组
            this.elementData = new Object[initialCapacity];
        &#125; else if (initialCapacity == 0) &#123;
    // 如果容量是0则创建一个新的数组给elementData
            this.elementData = EMPTY_ELEMENTDATA;
        &#125; else &#123;
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        &#125;
    &#125;
    public ArrayList() &#123; 
         // 无参构造函数，默认创建空集合
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    &#125;

-------------------------------------------------------------------------------
// Collection是所有单列集合的父接口
// 将 Collection 对象转换成数组，然后将数组的地址赋给 elementData
 public ArrayList(Collection&lt;? extends E&gt; c) &#123;
        elementData = c.toArray();
        if ((size = elementData.length) != 0) &#123;
            // 判断集合类型是否为不为object[] 
            // 在其他jdk此处是 ?? == ArrayList.class
            if (elementData.getClass() != Object[].class)
                // 不是的话就拷贝到数组elementData中
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        &#125; else &#123;
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        &#125;
    &#125;
</code></pre>
<h6 id="ArrayList源码分析-添加和扩容操作-第1次添加数据"><a href="#ArrayList源码分析-添加和扩容操作-第1次添加数据" class="headerlink" title="ArrayList源码分析-添加和扩容操作(第1次添加数据)"></a>ArrayList源码分析-添加和扩容操作(第1次添加数据)</h6><img src="https://raw.githubusercontent.com/P-luminary/images/94991acfd36ad12ca17dfd7578011cfeffe34022/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.png" style="zoom: 67%;" />



<p><span style = "color:red"><strong>ArrayList底层的实现原理是什么</strong></span></p>
<ul>
<li>ArrayList底层是用<strong>动态数组</strong>实现的</li>
<li>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</li>
<li>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</li>
<li>ArrayList在添加数据的时候<ul>
<li>确保数组已使用长度(size)加1之后足够存下下一个数据</li>
<li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用<code>grow</code>方法扩容<del>(原来的1.5倍)</del></li>
<li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上</li>
<li>返回添加成功布尔值</li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次</strong></span></p>
<ul>
<li>该语句只是声明和实例了一个<code>ArrayList</code>，指定了容量为10，未扩容</li>
</ul>
<p><span style = "color:red"><strong>如何实现数组和List之间的转换</strong></span></p>
<ul>
<li>数组转List，使用JDK中<code>java.util.Arrays</code>工具类的<code>asList</code>方法</li>
<li>List转数组，使用List的<code>toArray</code>方法，无参toArray方法返回Object数组，传入初始化长度的数组对象，返回该对象数组</li>
</ul>
<blockquote>
<p>使用 Hutool 工具库可以非常方便地实现数组和 <code>List</code> 之间的转换。Hutool 提供了 <code>ArrayUtil</code> 和 <code>CollUtil</code> 工具类来处理数组和集合之间的转换。</p>
<p>问：我不能用BeanUtil吗？<br>答：<code>BeanUtil</code> 是 Hutool 工具库中用于 <strong>Java Bean 操作</strong>的工具类，主要用于 <strong>对象属性拷贝</strong>、<strong>Bean 转 Map</strong>、<strong>Map 转 Bean</strong> 等操作。它并不适用于 <strong>数组和 List 之间的转换</strong>。</p>
<p>如果你误以为 <code>BeanUtil</code> 可以用于数组和 List 的转换，可能是因为它的名字容易让人误解。实际上，数组和 List 的转换应该使用 <code>ArrayUtil</code> 或 <code>CollUtil</code>。</p>
<h3 id="正确的工具类选择"><a href="#正确的工具类选择" class="headerlink" title="正确的工具类选择"></a>正确的工具类选择</h3><ol>
<li><strong>数组转 List</strong>：使用 <code>ArrayUtil.toList</code>。</li>
<li><strong>List 转数组</strong>：使用 <code>CollUtil.toArray</code>。</li>
<li><strong>Bean 属性拷贝</strong>：使用 <code>BeanUtil.copyProperties</code>。</li>
<li><strong>Bean 转 Map</strong>：使用 <code>BeanUtil.beanToMap</code>。</li>
<li><strong>Map 转 Bean</strong>：使用 <code>BeanUtil.fillBeanWithMap</code>。</li>
</ol>
<h6 id="更多的Hutool工具使用高能预警"><a href="#更多的Hutool工具使用高能预警" class="headerlink" title="更多的Hutool工具使用高能预警"></a>更多的Hutool工具使用<del>高能预警</del></h6><h5 id="1-字符串工具类：StrUtil"><a href="#1-字符串工具类：StrUtil" class="headerlink" title="1. 字符串工具类：StrUtil"></a>1. <strong>字符串工具类：<code>StrUtil</code></strong></h5><ul>
<li><strong>功能</strong>：字符串操作，如判空、格式化、截取、替换等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>StrUtil.isEmpty()</code>：判断字符串是否为空。</li>
<li><code>StrUtil.format()</code>：格式化字符串。</li>
<li><code>StrUtil.split()</code>：拆分字符串。</li>
<li><code>StrUtil.join()</code>：连接字符串。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-日期时间工具类：DateUtil"><a href="#2-日期时间工具类：DateUtil" class="headerlink" title="2. 日期时间工具类：DateUtil"></a>2. <strong>日期时间工具类：<code>DateUtil</code></strong></h5><ul>
<li><strong>功能</strong>：日期和时间的格式化、解析、计算等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>DateUtil.now()</code>：获取当前时间。</li>
<li><code>DateUtil.format()</code>：格式化日期。</li>
<li><code>DateUtil.parse()</code>：解析字符串为日期。</li>
<li><code>DateUtil.offsetDay()</code>：日期加减。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-文件工具类：FileUtil"><a href="#3-文件工具类：FileUtil" class="headerlink" title="3. 文件工具类：FileUtil"></a>3. <strong>文件工具类：<code>FileUtil</code></strong></h5><ul>
<li><strong>功能</strong>：文件和目录的操作，如读写、复制、删除等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>FileUtil.readUtf8String()</code>：读取文件内容为字符串。</li>
<li><code>FileUtil.writeUtf8String()</code>：将字符串写入文件。</li>
<li><code>FileUtil.copy()</code>：复制文件或目录。</li>
<li><code>FileUtil.del()</code>：删除文件或目录。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-JSON-工具类：JSONUtil"><a href="#4-JSON-工具类：JSONUtil" class="headerlink" title="4. JSON 工具类：JSONUtil"></a>4. <strong>JSON 工具类：<code>JSONUtil</code></strong></h5><ul>
<li><strong>功能</strong>：JSON 的解析和生成。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>JSONUtil.parseObj()</code>：将 JSON 字符串解析为 JSON 对象。</li>
<li><code>JSONUtil.parseArray()</code>：将 JSON 字符串解析为 JSON 数组。</li>
<li><code>JSONUtil.toJsonStr()</code>：将对象转换为 JSON 字符串。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-集合工具类：CollUtil"><a href="#5-集合工具类：CollUtil" class="headerlink" title="5. 集合工具类：CollUtil"></a>5. <strong>集合工具类：<code>CollUtil</code></strong></h5><ul>
<li><strong>功能</strong>：集合操作，如创建集合、判空、过滤、分组等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>CollUtil.newArrayList()</code>：快速创建 ArrayList。</li>
<li><code>CollUtil.isEmpty()</code>：判断集合是否为空。</li>
<li><code>CollUtil.filter()</code>：过滤集合。</li>
<li><code>CollUtil.group()</code>：对集合进行分组。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-反射工具类：ReflectUtil"><a href="#6-反射工具类：ReflectUtil" class="headerlink" title="6. 反射工具类：ReflectUtil"></a>6. <strong>反射工具类：<code>ReflectUtil</code></strong></h5><ul>
<li><strong>功能</strong>：反射操作，如调用方法、获取字段、创建对象等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ReflectUtil.invoke()</code>：调用方法。</li>
<li><code>ReflectUtil.getFieldValue()</code>：获取字段值。</li>
<li><code>ReflectUtil.newInstance()</code>：创建对象实例。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-HTTP-工具类：HttpUtil"><a href="#7-HTTP-工具类：HttpUtil" class="headerlink" title="7. HTTP 工具类：HttpUtil"></a>7. <strong>HTTP 工具类：<code>HttpUtil</code></strong></h5><ul>
<li><strong>功能</strong>：HTTP 请求的发送和响应处理。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>HttpUtil.get()</code>：发送 GET 请求。</li>
<li><code>HttpUtil.post()</code>：发送 POST 请求。</li>
<li><code>HttpUtil.downloadFile()</code>：下载文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-加密解密工具类：SecureUtil"><a href="#8-加密解密工具类：SecureUtil" class="headerlink" title="8. 加密解密工具类：SecureUtil"></a>8. <strong>加密解密工具类：<code>SecureUtil</code></strong></h5><ul>
<li><strong>功能</strong>：常见的加密解密操作，如 MD5、SHA、AES 等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>SecureUtil.md5()</code>：计算 MD5 值。</li>
<li><code>SecureUtil.sha256()</code>：计算 SHA-256 值。</li>
<li><code>SecureUtil.aes()</code>：AES 加密解密。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="9-IO-工具类：IoUtil"><a href="#9-IO-工具类：IoUtil" class="headerlink" title="9. IO 工具类：IoUtil"></a>9. <strong>IO 工具类：<code>IoUtil</code></strong></h5><ul>
<li><strong>功能</strong>：IO 流操作，如读写、关闭流等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>IoUtil.read()</code>：读取流内容。</li>
<li><code>IoUtil.write()</code>：写入流内容。</li>
<li><code>IoUtil.close()</code>：关闭流。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="10-随机工具类：RandomUtil"><a href="#10-随机工具类：RandomUtil" class="headerlink" title="10. 随机工具类：RandomUtil"></a>10. <strong>随机工具类：<code>RandomUtil</code></strong></h5><ul>
<li><strong>功能</strong>：生成随机数、随机字符串等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>RandomUtil.randomInt()</code>：生成随机整数。</li>
<li><code>RandomUtil.randomString()</code>：生成随机字符串。</li>
<li><code>RandomUtil.randomEle()</code>：从集合中随机选择一个元素。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="11-验证工具类：Validator"><a href="#11-验证工具类：Validator" class="headerlink" title="11. 验证工具类：Validator"></a>11. <strong>验证工具类：<code>Validator</code></strong></h5><ul>
<li><strong>功能</strong>：数据验证，如邮箱、手机号、身份证等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>Validator.isEmail()</code>：验证是否为邮箱。</li>
<li><code>Validator.isMobile()</code>：验证是否为手机号。</li>
<li><code>Validator.isCitizenId()</code>：验证是否为身份证号。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="12-缓存工具类：CacheUtil"><a href="#12-缓存工具类：CacheUtil" class="headerlink" title="12. 缓存工具类：CacheUtil"></a>12. <strong>缓存工具类：<code>CacheUtil</code></strong></h5><ul>
<li><strong>功能</strong>：简单的缓存操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>CacheUtil.newTimedCache()</code>：创建定时缓存。</li>
<li><code>CacheUtil.put()</code>：添加缓存。</li>
<li><code>CacheUtil.get()</code>：获取缓存。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="13-线程工具类：ThreadUtil"><a href="#13-线程工具类：ThreadUtil" class="headerlink" title="13. 线程工具类：ThreadUtil"></a>13. <strong>线程工具类：<code>ThreadUtil</code></strong></h5><ul>
<li><strong>功能</strong>：线程操作，如睡眠、创建线程池等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ThreadUtil.sleep()</code>：线程睡眠。</li>
<li><code>ThreadUtil.newExecutor()</code>：创建线程池。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="14-Excel-工具类：ExcelUtil"><a href="#14-Excel-工具类：ExcelUtil" class="headerlink" title="14. Excel 工具类：ExcelUtil"></a>14. <strong>Excel 工具类：<code>ExcelUtil</code></strong></h5><ul>
<li><strong>功能</strong>：Excel 文件的读写操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ExcelUtil.getReader()</code>：读取 Excel 文件。</li>
<li><code>ExcelUtil.getWriter()</code>：写入 Excel 文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="15-压缩工具类：ZipUtil"><a href="#15-压缩工具类：ZipUtil" class="headerlink" title="15. 压缩工具类：ZipUtil"></a>15. <strong>压缩工具类：<code>ZipUtil</code></strong></h5><ul>
<li><strong>功能</strong>：文件或目录的压缩和解压缩。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ZipUtil.zip()</code>：压缩文件或目录。</li>
<li><code>ZipUtil.unzip()</code>：解压缩文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="16-日志工具类：Log"><a href="#16-日志工具类：Log" class="headerlink" title="16. 日志工具类：Log"></a>16. <strong>日志工具类：<code>Log</code></strong></h5><ul>
<li><strong>功能</strong>：简化日志操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>Log.get()</code>：获取日志对象。</li>
<li><code>Log.info()</code>：输出日志信息。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="17-数学工具类：MathUtil"><a href="#17-数学工具类：MathUtil" class="headerlink" title="17. 数学工具类：MathUtil"></a>17. <strong>数学工具类：<code>MathUtil</code></strong></h5><ul>
<li><strong>功能</strong>：数学计算，如四舍五入、最大值、最小值等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>MathUtil.round()</code>：四舍五入。</li>
<li><code>MathUtil.max()</code>：获取最大值。</li>
<li><code>MathUtil.min()</code>：获取最小值。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="18-网络工具类：NetUtil"><a href="#18-网络工具类：NetUtil" class="headerlink" title="18. 网络工具类：NetUtil"></a>18. <strong>网络工具类：<code>NetUtil</code></strong></h5><ul>
<li><strong>功能</strong>：网络相关操作，如获取本机 IP、Ping 等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>NetUtil.getLocalhost()</code>：获取本机 IP。</li>
<li><code>NetUtil.ping()</code>：Ping 测试。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>用<code>Arrays.asList</code>转List后，如果修改了数组内容，list受影响吗</li>
<li>List用<code>toArray</code>转数组后，如果修改了List内容，数组受影响吗</li>
</ul>
<h6 id="再答："><a href="#再答：" class="headerlink" title="再答："></a>再答：</h6><ul>
<li>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</li>
<li>list用了toArray转数组后，如果修改了list内容，数组不会受影响，当调用了toArray以后，在底层是它进行了数组拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2a0e6fcd9e82104de79aeb269b64bee2fe250a37/%E6%95%B0%E7%BB%84%E5%92%8Clist%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p>
<p><span style = "color:red"><strong>LinkedList的数据结构—链表</strong></span></p>
<p><strong>单向链表</strong></p>
<ul>
<li>链表中的每一个元素称之为结点(Node)</li>
<li>物理存储单元上，非连续、非顺序的存储结构</li>
<li>单向链表：每个结点包括两个部分:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针 next</li>
</ul>
<h6 id="1-单向链表和双向链表的区别是什么"><a href="#1-单向链表和双向链表的区别是什么" class="headerlink" title="1.单向链表和双向链表的区别是什么"></a>1.单向链表和双向链表的区别是什么</h6><ul>
<li>单向链表只有一个方向，结点只有一个后继指针 next。</li>
<li>双向链表它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点</li>
</ul>
<h6 id="2-链表操作数据的时间复杂度是多少"><a href="#2-链表操作数据的时间复杂度是多少" class="headerlink" title="2.链表操作数据的时间复杂度是多少"></a>2.链表操作数据的时间复杂度是多少</h6><table>
<thead>
<tr>
<th></th>
<th>查询</th>
<th>新增删除</th>
</tr>
</thead>
<tbody><tr>
<td>单向链表</td>
<td>头O(1), 其他O(n)</td>
<td>头O(1), 其他O(n)</td>
</tr>
<tr>
<td>双向链表</td>
<td>头尾O(1), 其他O(n), 给定节点O(1)</td>
<td>头尾O(1), 其他O(n), 给定节点O(1)</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/89cd60c5af783394daee166cbfce512c0b796d0f/LinkedList%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E9%93%BE%E8%A1%A8.png"></p>
<p><span style = "color:red"><strong>ArrayList和LinkedList的区别</strong></span></p>
<ul>
<li><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a><span style = "color:blue">底层数据结构</span></h5><ul>
<li>ArrayList 是<strong>动态数组</strong>的数据结构实现</li>
<li>LinkedList 是<strong>双向链表</strong>的数据结构实现</li>
</ul>
</li>
<li><p><strong>操作数组效率</strong></p>
<ul>
<li><p>ArrayList  按照下标查询的时间复杂度O(1);【内存是连续的，根据寻址公式】，LinkedList不支持下标查询</p>
</li>
<li><p>查找(未知索引)：ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)</p>
</li>
<li><p><strong>新增</strong>和<strong>删除</strong></p>
<ul>
<li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li>
<li>LinkedList 头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内存空间占用</strong></p>
<ul>
<li>ArrayList 底层是数组，内存连续，节省内存</li>
<li>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</li>
</ul>
</li>
<li><p><strong>线程安全</strong></p>
<ul>
<li><p>ArrayList和LinkedList都不是线程安全的</p>
</li>
<li><p>如果要保证线程安全，有两种方法</p>
<ul>
<li><p>在方法内使用，局部变量则是线程安全的</p>
</li>
<li><p>使用线程安全的ArrayList和LinkedList</p>
<pre><code class="java">List&lt;Object&gt; syncArrayList = Collections.synchronizedList(new ArrayList&lt;&gt;());
List&lt;Object&gt; syncLinkedList = Collections.synchronizedList(new LinkedList&lt;&gt;());
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HashMap相关面试题"><a href="#HashMap相关面试题" class="headerlink" title="HashMap相关面试题"></a><span style = "color:red"><strong>HashMap相关面试题</strong></span></h3><ul>
<li><p><strong>二叉树</strong></p>
<ul>
<li><p>满二叉树</p>
</li>
<li><p>完全二叉树</p>
</li>
<li><p><strong>二叉搜索树</strong></p>
<p>二叉搜索树又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p>
</li>
<li><p><strong>红黑树</strong></p>
</li>
</ul>
</li>
<li><p><strong>红黑树</strong></p>
</li>
<li><p><strong>散列表</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/678118180d1bda0ac019f934c04c3db01eff5cf8/%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p>
<p><span style = "color:red"><strong>数据结构—红黑树 什么是红黑树？</strong></span></p>
<ul>
<li>红黑树：也是一种自平衡的二叉搜索树(BST)</li>
<li>所有的红黑规则都是希望红黑树能够保证平衡</li>
<li>红黑树的时间复杂度：查找、添加、删除都是O(logn)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d52e3005e6dbb2c546a407bdb237c51cbdab9694/%E7%BA%A2%E9%BB%91%E6%A0%91.png"></p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><span style = "color:red"><strong>散列表</strong></span></h4><p><span style = "color:red"><strong>什么是散列表？</strong></span></p>
<blockquote>
<ul>
<li>散列表(Hash Table)又叫哈希表&#x2F;Hash表</li>
<li>根据键(Key)直接访问再内存存储位置值(Value)的数据结构</li>
<li>由数组演化而来的，利用了数组支持按照下标进行随机访问数据</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>散列冲突</strong></span></p>
<blockquote>
<ul>
<li>散列冲突又成为哈希冲突，哈希碰撞</li>
<li>指多个key映射到同一个数组下标位置</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>散列冲突—链表法(拉链)</strong></span></p>
<blockquote>
<ul>
<li>数组的每个下标位置称之为<strong>桶</strong>(bucket) 或者 <strong>槽</strong>(slot)</li>
<li>每个桶(槽)会对应一条链表</li>
<li>hash冲突后的元素都放到相同槽位对应的链表中或红黑树中</li>
</ul>
</blockquote>
<p>在<strong>HashMap</strong>中的最重要的一个数据结构就是散列表，在散列表中又用到了<strong>红黑树</strong>和<strong>链表</strong><br>散列表(Hash Table)又名为<strong>哈希表</strong>&#x2F;Hash表，是<strong>根据键(Key)直接访问</strong>在内存存储位置<strong>值(value)<strong>的数据结构，它是</strong>由数组演化而来的</strong>，利用了数组支持按照下标进行随机访问数据的特性<del>[根据寻址公式,时间复杂度O(1)]</del></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6dd0e10d2aaa9a064fde0c973b9d942ae149d17c/%E6%95%A3%E5%88%97%E8%A1%A8.png"></p>
<h4 id="说一下HashMap的实现原理"><a href="#说一下HashMap的实现原理" class="headerlink" title="说一下HashMap的实现原理"></a><span style = "color:red"><strong>说一下HashMap的实现原理</strong></span></h4><blockquote>
<p>1.说一下HashMap的实现原理</p>
<ul>
<li><p>HashMap的数据结构：底层使用hash表数据结构，即数组和链表或红黑树</p>
</li>
<li><p>添加数据时，计算key的值确定元素在数组中的下标</p>
<ul>
<li>key相同则替换</li>
<li>不同则存入链表或红黑树中</li>
</ul>
<p>获取数据通过key的hash计算数组下标获取元素</p>
</li>
</ul>
<p>2.HashMap的jdk1.7和jdk1.8有什么区别</p>
<ul>
<li>JDK1.8之前采用的拉链法，数组+链表</li>
<li>JDK1.8之后采用数组+链表+红黑树<br>链表长度大于8且数组长度大于64则会从链表转化为红黑树</li>
</ul>
</blockquote>
<p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算</p>
<p>出当前对象的元素在数组中的下标</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/27826dde4b711105a212f30f6381f8097eca69ba/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<h4 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a><span style = "color:red"><strong>HashMap的put方法的具体流程</strong></span></h4><blockquote>
<p>1.判断键值对数组table是否为空或为null，否则执行resize()进行扩容 [初始化]<br>2.根据键值key计算hash值得到数组索引<br>3.判断table[i] &#x3D;&#x3D; null，条件成立，直接新建节点添加<br>4.如果table[i] &#x3D;&#x3D; null，不成立<br>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value<br>4.2 判断table[i]是否为<strong>treeNode</strong>，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对<br>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d2fa5788e2f2f5c7e75e724c8bef242b6661c10c/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>讲一下HashMap的扩容机制</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c4e2b5bca4f89ece679358c70cdb042f8028aa81/HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6.png"></p>
<p><span style = "color:red"><strong>HashMap源码分析</strong></span></p>
<p>桶下标是hash值取模数组(长度)下标 capacity</p>
<p><span style = "color:red"><strong>HashMap的寻址算法</strong></span></p>
<p>Hash值右移16位后与原来的hash值进行异或运算【扰动算法<del>hash值更加均匀,减少hash冲突</del>】<br>数组长度必须是2的n次幂 按位<strong>与运算</strong>的效果才能代替取模</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/85bdc4d076df91ec3d29294926d65f55713b2d26/HashMap%E5%AF%BB%E5%9D%80%E7%AE%97w%E6%B3%95.png"></p>
<p><span style = "color:red"><strong>HashMap在1.7情况下的多线程死循环问题</strong></span></p>
<p>jdk7的数据结构是：数组+链表<br>在数组进行扩容的时候，因为链表是<strong>头插法</strong>，在进行数据迁移的过程中，有可能导致死循环</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1be6d73360d8cdf5baa6b2fea0b1fc8fa8b7fadc/HashMap%E5%9C%A81.7%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98.png"></p>
<h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a><span style = "color:red">进程和线程的区别？</span></h4><blockquote>
<h6 id="两者对比："><a href="#两者对比：" class="headerlink" title="两者对比："></a>两者对比：</h6><ul>
<li>进程是整个在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ul>
</blockquote>
<p>程序由<strong>指令</strong>和<strong>数据</strong>组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备，<strong>进程</strong>就是用来加载指令、管理内存、管理IO的。<br>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个**<u>进程</u>**</p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。一个进程之内可以分为一到多个线程</p>
<blockquote>
<p>core → 线程1[指令1，指令2，指令3…]   线程2[指令1，指令2，指令3…] </p>
</blockquote>
<h4 id="并行和并发的区别？"><a href="#并行和并发的区别？" class="headerlink" title="并行和并发的区别？"></a><span style = "color:red">并行和并发的区别？</span></h4><blockquote>
<p>现在都是多核CPU，在多核CPU下</p>
<ul>
<li>并发是<strong>同一时间</strong>应对多件事情的能力，多个线程<strong>轮流使用</strong>一个或多个CPU</li>
<li>并行是<strong>同一时间</strong>动手做多件事的能力，4核CPU<strong>同时执行</strong>4个线程</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;<strong>单核CPU</strong>&#x3D;&#x3D; → 单核CPU下线程实际还是串行执行的</p>
<ul>
<li>操作系统中有一个组件叫做任务调度器，将cpu的时间片(windows下时间片最小约为15ms)分给不同的程序使用，只是由于cpu在线程间(时间片很短)的切换非常快，人类感觉是同时运行的</li>
<li>每个时间片只能用有一个线程被执行</li>
<li>总结一句话：**<u>微观串行，宏观并行</u>**</li>
<li>一般会将这种线程轮流使用CPU的做法称为并发(concurrent)</li>
</ul>
<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片1</th>
<th>时间片2</th>
<th>时间片3</th>
</tr>
</thead>
<tbody><tr>
<td>core</td>
<td>线程1</td>
<td>线程2</td>
<td>线程3</td>
</tr>
</tbody></table>
<p><strong>&#x3D;&#x3D;多核CPU&#x3D;&#x3D;</strong> → 每个核(core)都可以调度运行线程，这个时候线程是可以并行的</p>
<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片1</th>
<th>时间片2</th>
<th>时间片3</th>
<th>时间片4</th>
</tr>
</thead>
<tbody><tr>
<td>core1</td>
<td>线程1</td>
<td>线程2</td>
<td>线程3</td>
<td>线程3</td>
</tr>
<tr>
<td>core2</td>
<td>线程2</td>
<td>线程4</td>
<td>线程2</td>
<td>线程4</td>
</tr>
</tbody></table>
<blockquote>
<p>并发 (concurrent) 是同一时间<strong>应对</strong> (dealing with) 多件事情的能力<br>并行 (parallel) 是同一时间<strong>动手做</strong> (doing) 多件事情的能力</p>
<ul>
<li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这么多件事，这就是<strong>并发</strong>【单核CPU】</li>
<li>家庭主妇雇了个保姆，她们一起做这些事，这时既有并发，也有并行【会产生竞争，例如锅只有一个，一个人用锅时，另一个人就要等待】</li>
<li>雇了3个保姆，一个专门做饭，一个专门打扫卫生，一个专门喂奶，互不干扰，这就是<strong>并行</strong></li>
</ul>
</blockquote>
<h4 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a><span style = "color:red">创建线程的方式有哪些？</span></h4><ul>
<li><h5 id="继承Thread类，重写run方法"><a href="#继承Thread类，重写run方法" class="headerlink" title="继承Thread类，重写run方法"></a>继承Thread类，重写run方法</h5></li>
</ul>
<pre><code class="java">public class MyThread extends Thread&#123;
    @Override
    public void run()&#123;
        sout(&quot;MyThread...run...&quot;);
    &#125;
    public static void main(String[] args)&#123;
        // 创建MyThread对象
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        
        // 调用start方法启动线程
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Runnable接口，重写run方法"><a href="#实现Runnable接口，重写run方法" class="headerlink" title="实现Runnable接口，重写run方法"></a>实现Runnable接口，重写run方法</h5></li>
</ul>
<pre><code class="java">public class MyRunnable implements Runnable &#123;

    @Override
    public void run() &#123;
        // 在这里编写要执行的任务
        System.out.println(&quot;线程正在执行任务...&quot;);
    &#125;
    public static void main(String[] args) &#123;
        // 创建MyRunnable实例
        MyRunnable myRunnable = new MyRunnable();
        
        // 创建线程并启动
        Thread t1 = new Thread(myRunnable);
        Thread t2 = new Thread(myRunnable);
        // 调用start方法启动线程
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Callable-lt-T-gt-接口，重写call方法泛型和重写方法一致"><a href="#实现Callable-lt-T-gt-接口，重写call方法泛型和重写方法一致" class="headerlink" title="实现Callable&lt; T &gt;接口，重写call方法泛型和重写方法一致"></a>实现Callable&lt; T &gt;接口，重写call方法<del>泛型和重写方法一致</del></h5></li>
</ul>
<pre><code class="java">public class MyCallable implements Callable&lt;String&gt; &#123;
 @Override
    public String call() throws Exception &#123;
        sout(Thread.currentThread().getName());
        return &quot;ok&quot;;
    &#125;
     public static void main(String[] args) &#123;
        // 创建MyCallable实例
        MyCallable myCallable = new MyCallable();
        
        // 使用FutureTask来包装Callable对象
        FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;(myCallable);
        
        // 创建并启动线程
        Thread t1 = new Thread(ft);
        t1.start();
        // 调用ft的get方法获取执行结果
        String result = ft.get();
        sout(result)
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="线程池创建线程-项目中使用的方式"><a href="#线程池创建线程-项目中使用的方式" class="headerlink" title="线程池创建线程 (项目中使用的方式)"></a><span style = "color:blue">线程池创建线程 (项目中使用的方式)</span></h5></li>
</ul>
<pre><code class="java">public class MyExecutors implements Runnable&#123;
    @Override
    public void run()&#123;
        sout(&quot;MyRunnable...run...&quot;);
    &#125;
    public static void main(String[] args)&#123;
        // 创建线程池对象
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        threadPool.submit(new MyExecutors()); 
        //submit用来提交线程
        
        // 关闭线程池
        threadPool.shutdown();
    &#125;
&#125;
</code></pre>
<h6 id="刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？"><a href="#刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？" class="headerlink" title="刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？"></a><span style = "color:red">刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？</span></h6><blockquote>
<ul>
<li>Runnable接口run方法<strong>没有返回值</strong></li>
<li><strong>Callable</strong>接口call方法<strong>有返回值</strong>，要结合FutureTask配合可以用来获取异步执行的结果</li>
</ul>
<blockquote>
<p><strong><code>FutureTask</code></strong> 是 <strong><code>Future</code></strong> 的实现类，它可以包装一个 <code>Callable</code> 或 <code>Runnable</code> 对象，并允许我们在任务执行完毕后获取执行结果或取消任务。</p>
<p><strong><code>FutureTask</code></strong> 可以在子线程中异步执行任务，而主线程可以通过调用 <code>FutureTask.get()</code> 方法获取任务执行的结果。</p>
</blockquote>
<ul>
<li>Callable接口的call()方法<strong>允许抛出异常</strong>；而Runnabble接口的run()方法的异常只能在<strong>内部消化</strong>，不能继续上抛</li>
</ul>
<pre><code class="java">import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class CallableExample &#123;

    public static void main(String[] args) throws Exception &#123;
        // 创建一个Callable任务
        Callable&lt;Integer&gt; task = new Callable&lt;Integer&gt;() &#123;
            @Override
            public Integer call() throws Exception &#123;
                System.out.println(&quot;Task is running in the background...&quot;);
                // 模拟耗时操作
                Thread.sleep(2000);
                return 42; // 返回计算结果
            &#125;
        &#125;;

        // 创建FutureTask对象，包装Callable任务
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task);

        // 启动线程执行FutureTask
        Thread thread = new Thread(futureTask);
        thread.start();

        // 主线程可以做一些其他工作
        System.out.println(&quot;Main thread is doing something else...&quot;);

        // 获取异步执行结果，阻塞直到任务完成
        Integer result = futureTask.get(); // 这会阻塞主线程直到获取到结果
        System.out.println(&quot;Task result: &quot; + result); // 打印任务执行结果
    &#125;
&#125;
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>在启动线程的时候，可以使用run方法吗？run()和start()有什么区别？</strong></span></p>
<p>start()是开启一个线程   run()跟开启普通方法一样</p>
<blockquote>
<p><strong>start()：</strong>用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。<strong>start方法只能被调用一次</strong><br><strong>run()：</strong>封装了要被线程执行的代码，<strong>可以被调用多次</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/807ae461bb166b0aa6a755a66e43d57c0166323c/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9.png"></p>
<h4 id="线程包括哪些状态，状态之间是如何变化的？"><a href="#线程包括哪些状态，状态之间是如何变化的？" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的？"></a><span style = "color:red"><strong>线程包括哪些状态，状态之间是如何变化的？</strong></span></h4><blockquote>
<p>状态：<br><strong>新建</strong>New、<strong>可运行</strong>Runnable、<strong>阻塞</strong>Blocked、<strong>等待</strong>Waiting、<strong>时间等待</strong>Timed_waiting、<strong>终止</strong>Terminated</p>
<p>线程状态之间如何变化：</p>
<ul>
<li>创建线程对象是<strong>新建状态</strong></li>
<li>调用了start()方法转变为<strong>可执行状态</strong></li>
<li>线程获取到了CPU的执行权，执行结束是<strong>终止状态</strong></li>
<li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态<ul>
<li>如果没有获取锁(synchronized或lock) 进入<strong>阻塞状态</strong>，获得锁再切换为可执行状态</li>
<li>如果线程调用了wait()方法进入<strong>等待状态</strong>，其他线程调用notify()唤醒后可转换为可执行状态</li>
<li>如果线程调用了sleep(50)方法，进入<strong>计时等待状态</strong>，到时间后可切换为可执行状态</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code class="java">Thread.java
public enum State &#123;
    /**
     * 新建状态。线程已经被创建，但尚未启动。
     */
    NEW,

    /**
     * 可运行状态。线程在JVM中是可运行的，这并不意味着它一定在运行，它可能在等待其他线程或操作系统的资源。
     */
    RUNNABLE,

    /**
     * 阻塞状态。线程正在等待监视器锁，以进入一个同步块/方法，或者在调用Object.wait后等待重新进入同步块/方法。
     */
    BLOCKED,

    /**
     * 等待状态。线程在等待另一个线程执行特定操作。例如，一个线程调用了Thread.join，它在等待指定的线程终止。
     */
    WAITING,

    /**
     * 超时等待状态。线程在等待另一个线程执行特定操作，但它设置了超时时间。如果线程在指定时间内没有等待到所需条件，它将自动返回。
     */
    TIMED_WAITING,

    /**
     * 终止状态。线程已经完成了执行。
     */
    TERMINATED;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/981d7e954005439be7e8261b142100e3e87f800b/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p>
<p><span style = "color:red"><strong>新建T1、T2、T3三个线程，如何保证它们按顺序执行？</strong></span></p>
<p>可以使用线程中的join方法解决<br><code>join() 等待线程运行结束</code></p>
<pre><code class="java">t.join() 阻塞调用此方法的线程进入timed_waiting 直到线程t执行完毕后，此线程再继续执行
</code></pre>
<pre><code class="java">Thread t1 = new Thread(()-&gt;&#123;
    sout(&quot;t1&quot;);
&#125;);
Thread t2 = new Thread(()-&gt;&#123;
    try&#123;
        t1.join();
    &#125;catch(InterruptedException e)&#123;
        e.printStackTrance();
    &#125;
    sout(&quot;t2&quot;);
&#125;)
Thread t3 = new Thread(()-&gt;&#123;
    try&#123;
        t2.join();
    &#125;catch(InterruptedException e)&#123;
        e.printStackTrance();
    &#125;
    sout(&quot;t3&quot;);
&#125;);
// 启动线程
t1.start();
t2.start();
t3.start();
</code></pre>
<p><span style = "color:red"><strong>notify() 和 notifyAll() 有什么区别？</strong></span></p>
<blockquote>
<ul>
<li><strong>notifyAll</strong>：唤醒所有wait的线程</li>
<li><strong>notify</strong>：只随机唤醒一个wait线程</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>java中wait和sleep方法有什么区别？</strong></span><del>wait要和synchronized一起使用</del></p>
<h6 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h6><p>wait()，wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态</p>
<h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul>
<li><p>方法归属不同</p>
<ul>
<li>sleep(long)是Thread的静态方法</li>
<li>而wait()，wait(long)都是Object的成员方法，每个对象都有</li>
</ul>
</li>
<li><p>醒来时机不同</p>
<ul>
<li>执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来</li>
<li>wait(long)和wait()还可以被notify唤醒，wait()如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><p><strong>锁特性不同</strong>【重点】</p>
<ul>
<li>wait方法的调用必须先获取wait对象的锁，而sleep则无此限制</li>
<li>wait方法执行后会释放锁对象，允许其他线程获得该锁对象 (我放弃cpu，但你们还可以用)</li>
<li>而sleep如果在synchronized代码块中执行，并不会释放锁对象 (我放弃cpu，你们也用不了)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5541d691652184639a4936426271a2f6ea03d2fb/wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.png"></p>
<p><span style = "color:red"><strong>如何停止一个正在运行的线程？</strong></span></p>
<h6 id="有三种方式可以停止线程"><a href="#有三种方式可以停止线程" class="headerlink" title="有三种方式可以停止线程"></a>有三种方式可以停止线程</h6><ul>
<li>使用退出标志，使线程<strong>正常退出</strong>，也就是当run方法完成后线程终止</li>
<li>使用<strong>stop方法</strong>强行终止(不推荐，方法已作废)</li>
<li>使用<strong>interrupt</strong>方法中断线程<ul>
<li>打断阻塞的线程(sleep, wait, join)的线程，线程会抛出InterruptedException异常</li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/64f320ea60791a6cc20d9e238d50be95345d1485/%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>synchronized关键字的底层原理？</strong></span><del>底层：Monitor</del></p>
<blockquote>
<ul>
<li>synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</li>
<li>它的底层由monitor实现的，monitor**是jvm级别的现象(C++实现)**，线程获得锁需要使用对象(锁)关联monitor</li>
<li>在monitor内部有三个属性，分别是<code>owner、entrylist、waitset</code><ul>
<li>owner是关联的获得锁的线程，并且只能关联一个线程；</li>
<li>entrylist关联的是处于阻塞状态的线程；</li>
<li>waitset关联的是处于Waiting状态的线程；</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4fd1c205a0d2d906c28c4a924b883b4082605a78/Synchronized%E4%B8%8ELock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>synchronized关键字的底层原理—进阶</strong></span></p>
<p><span style = "color:red"><strong><u>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</u></strong></span></p>
<blockquote>
<h4 id="一旦锁发生了竞争，都会升级为重量级锁"><a href="#一旦锁发生了竞争，都会升级为重量级锁" class="headerlink" title="一旦锁发生了竞争，都会升级为重量级锁"></a>一旦锁发生了竞争，都会升级为重量级锁</h4><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>重量级锁</td>
<td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 【有多个线程来抢】</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程加锁的时间是错开的(也就是没有竞争)可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li>Monitor实现的锁属于重量级锁，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<h6 id="Monitor重量级锁"><a href="#Monitor重量级锁" class="headerlink" title="Monitor重量级锁"></a>Monitor重量级锁</h6><p>每个Java对象都可以关联一个Monitor对象，如果使用 synchronized 给对象上锁(重量级)之后，该对象头的Mark Word中就被设置指向Monitor对象的指针</p>
<h6 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h6><ul>
<li>在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</li>
<li>通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</li>
<li>如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为nul，起到了一个重入计数器的作用。</li>
<li>如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</li>
</ul>
<h6 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h6><ul>
<li>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record.</li>
<li>如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</li>
<li>如果Lock Record的 Mark Word不为nul，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</li>
</ul>
<h6 id="偏向锁性能比轻量级锁好"><a href="#偏向锁性能比轻量级锁好" class="headerlink" title="偏向锁性能比轻量级锁好"></a>偏向锁<del>性能比轻量级锁好</del></h6><ul>
<li>轻量级锁在没有竞争时(就自己这个线程)每次重入仍然需要执行 CAS 操作。</li>
<li>Java6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d930bb7ad0d897e72b69faa5bb15fa1f387b728a/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%5B%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%5D%E2%80%94%E8%BF%9B%E9%98%B6%E7%AF%87.png"></p>
<h4 id="你谈谈JMM-Java内存模型"><a href="#你谈谈JMM-Java内存模型" class="headerlink" title="你谈谈JMM (Java内存模型)"></a><span style = "color:red"><strong>你谈谈JMM (Java内存模型)</strong></span></h4><h6 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h6><ul>
<li>JMM(Java Memory Model)Java内存模型，定义了<strong>共享内存</strong>中<strong>多线程程序读写操作</strong>的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li>
<li>JMM把内存分为两块，一块是私有线程的工作区域(工作内存)，一块是所有线程的共享区域(主内存)</li>
<li>线程跟线程之间是相互隔离，线程跟线程相互需要通过主内存</li>
</ul>
<p><span style = "color:red"><strong>CAS你知道吗？</strong></span></p>
<blockquote>
<ul>
<li>CAS全称是：Compare And Swap(比较再交换)，它体现的一种<strong>乐观锁</strong>的思想，在无锁情况下保证线程操作共享数据的原子性。</li>
<li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li>
<li>在操作共享变量的时候使用自旋锁，效率上更高一些</li>
<li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</li>
</ul>
</blockquote>
<p>在JUC(java.util.concurrent)包下实现的很多类都用到了CAS操作</p>
<ul>
<li>AbstractQueuedSynchronizer (AQS框架)</li>
<li>AtomicXXX类</li>
</ul>
<p><span style = "color:red"><strong>乐观锁和悲观锁的区别？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ed89cde4cab6a88d6f2a86f3430be2b28a5e3626/JMM%20(Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)+CAS.png"></p>
<p><span style = "color:red"><strong>谈一谈你对volatile的理解？</strong></span></p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li><h5 id="保证线程间的可见性"><a href="#保证线程间的可见性" class="headerlink" title="保证线程间的可见性"></a>保证线程间的可见性</h5><p>用volatile修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p>
</li>
<li><h5 id="禁止进行指令重排序"><a href="#禁止进行指令重排序" class="headerlink" title="禁止进行指令重排序"></a>禁止进行指令重排序</h5><p>用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ce52eb544e19cacdc7c7d22cb6fa3135b27e6a3/volatile%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%90%86%E8%A7%A3[%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8F%AF%E8%A7%81+%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F].png"></p>
<p><span style = "color:red"><strong>什么是AQS？</strong></span></p>
<blockquote>
<ul>
<li>是多线程中的队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li>AQS内部维护了一个**<u>先进先出的双向队列</u>**，队列中存储的排队的线程</li>
<li>在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0(无所状态)，如果队列中有一个线程修改成功了state为1，则当前线程就相当于获取了资源。</li>
<li>在对state修改的时候使用CAS(compare and swap)操作，保证多个线程修改的情况下原子性</li>
</ul>
</blockquote>
<p>AQS(<strong>A</strong>bstract<strong>Q</strong>ueued<strong>S</strong>ynchronizer)，即抽象队列同步器。它是构建锁或者其他同步组件的<strong>基础框架</strong></p>
<h6 id="AQS与Synchronized的区别"><a href="#AQS与Synchronized的区别" class="headerlink" title="AQS与Synchronized的区别"></a>AQS与Synchronized的区别</h6><table>
<thead>
<tr>
<th align="center">synchronized</th>
<th align="center">AQS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关键字，C++语言实现</td>
<td align="center">java语言实现</td>
</tr>
<tr>
<td align="center">悲观锁，自动释放锁</td>
<td align="center">悲观锁，手动开启和关闭</td>
</tr>
<tr>
<td align="center">锁竞争激励都会升级为<strong>重量级锁</strong>，性能差</td>
<td align="center">锁竞争激烈的情况下，提供了多种解决方案</td>
</tr>
</tbody></table>
<h6 id="AQS常见的实现类"><a href="#AQS常见的实现类" class="headerlink" title="AQS常见的实现类"></a>AQS常见的实现类</h6><ul>
<li><strong>ReentrantLock 阻塞式锁</strong></li>
<li>Semaphore 信号量</li>
<li>CountDownLatch 倒计时锁</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dd56a7110e36eebc67c093ce454bd7052a1ad30/%E4%BB%80%E4%B9%88%E6%98%AFAQS.png"></p>
<p><span style = "color:red"><strong>ReentrantLock [rɪ’entrənt]lock 的实现原理？</strong></span><del>[关联HashMap线程不安全需加锁(synchronized或ReentrantLock)]</del></p>
<blockquote>
<p>ReentrantLock主要利用<strong>CAS+AQS队列</strong><del>CompareAndSwap+AbstractQueuedSynchronized</del>来实现。**<u>它支持公平锁和非公平锁</u><strong>，两者的实现类似构造方法接受一个可选的公平参数(<strong>默认非公平锁</strong>)，</strong><u>当设置为true时，表示公平锁，否则为非公平锁</u>**。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p>
</blockquote>
<p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p>
<ul>
<li>可中断<del>synchronized不可中断</del></li>
<li>可设置超时时间<del>没有获得锁时只能进入等待</del>[<u>没有获取锁可以放弃锁</u>]</li>
<li>可以设置公平锁<del>synchronized只有非公平锁</del>[也支持非公平锁]</li>
<li>支持多个条件变量</li>
<li>与synchronized一样，都支持重入</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9279a890a6163298e551a9f594f3c0b921a438ad/ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>synchronized和Lock有什么区别？</strong></span></p>
<ul>
<li><strong>语法层面</strong></li>
</ul>
<p>synchronized是关键字，源码在jvm中，用c++语言实现<br>Lock是接口，源码由jdk提供，用java语言实现<br>使用synchronized时，退出同步代码块锁会<strong>自动释放</strong>，而使用Lock时，需要<strong>手动</strong>调用unlock方法<strong>释放锁</strong></p>
<ul>
<li><strong>功能层面</strong></li>
</ul>
<p><strong>二者均属于悲观锁</strong>、都具备基本的互斥、同步、锁重入功能<br>Lock提供了许多synchronized不具备的功能，例如<strong>公平锁、可打断、可超时、多条件变量</strong><br>Lock有适合不同场景的实现，如ReentrantLock、ReentrantReadWeiteLock(读写锁)</p>
<p><span style = "color:red"><strong>死锁产生的条件是什么</strong></span></p>
<p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<h6 id="如何进行死锁诊断-？"><a href="#如何进行死锁诊断-？" class="headerlink" title="如何进行死锁诊断 ？"></a>如何进行死锁诊断 ？</h6><p>当程序出现了死锁现象，我们可以使用jdk自带的工具：<strong>jps</strong>和<strong>jstack</strong></p>
<ul>
<li><strong>jps</strong>：输出JVM中运行的<strong>进程状态</strong>信息</li>
<li><strong>jstack</strong>：查看java进程内<strong>线程的堆栈</strong>信息</li>
</ul>
<p>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack -l &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<h6 id="其他解决工具，可视化工具"><a href="#其他解决工具，可视化工具" class="headerlink" title="其他解决工具，可视化工具"></a>其他解决工具，可视化工具</h6><ul>
<li><strong>jconsole</strong></li>
</ul>
<p>用于对jvm的 <u>内存，线程，类</u>  的监控，是一个基于jmx的GUI性能监控工具<br>打开方式：java安装目录 bin目录下 直接启动 <code>jconsole.exe</code>就行</p>
<ul>
<li><strong>VisualVM</strong>：故障处理工具</li>
</ul>
<p>能够监控线程，内存情况，查看方法的cpu时间和内存中的对象，已被GC的对象，反向查看分配的堆栈<br>打开方式：java安装目录 bin目录下 直接启动 <code>jvisualvm.exe</code>就行</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e76fa529b0f5ed6e555f615f22b4ad646e02f0d6/%E6%AD%BB%E9%94%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<p><span style = "color:red"><strong>聊一下ConcurrentHashMap</strong></span></p>
<p><code>ConcurrentHashMap</code>是一种线程安全的高效Map集合<br><strong>底层数据结构</strong>：</p>
<ul>
<li><p>JDK1.7底层采用分段的数组+链表实现</p>
</li>
<li><p>JDK1.8采用的数数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：<code>数组+红黑树+链表</code>，采用CAS + Synchronized来保证并发安全进行实现</p>
<ul>
<li>CAS控制数组节点的添加</li>
<li>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题，效率得到提升</li>
</ul>
</li>
</ul>
<p><strong>加锁的方式</strong>：</p>
<ul>
<li>JDK1.7采用<code>Segment</code>分段锁，底层使用的是<code>ReentrantLock</code></li>
<li>JDK1.8采用<code>CAS</code><del>自旋锁</del>添加新节点，采用<code>synchronized</code>锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/fc8e6e126e8fff5692b8c53102ac3237b913310d/%E8%81%8A%E4%B8%80%E8%81%8AConcurrentHashMap.png"></p>
<h4 id="导致并发程序出现问题的根本原因是什么-Java程序中怎么保证多线程的执行安全"><a href="#导致并发程序出现问题的根本原因是什么-Java程序中怎么保证多线程的执行安全" class="headerlink" title="导致并发程序出现问题的根本原因是什么 (Java程序中怎么保证多线程的执行安全)"></a><span style = "color:red"><strong>导致并发程序出现问题的根本原因是什么 (Java程序中怎么保证多线程的执行安全)</strong></span></h4><h6 id="Java并发编程三大特性"><a href="#Java并发编程三大特性" class="headerlink" title="Java并发编程三大特性"></a>Java并发编程三大特性</h6><ul>
<li><span style = "color:blue"><strong>原子性<del>synchronized、lock</del></strong></span>：一个线程在CPU中操作不可暂停，也不可中断，要么执行完成，要么不执行</li>
</ul>
<pre><code class="java">int ticketNum = 10;
public void getTicket()&#123;
    if(ticketNum &lt;= 0)&#123;
        return;
    &#125;
    sout(Thread.currentThread().getName() + &quot;抢到一张票，剩余：&quot; + ticketNum);
    // 非原子性操作
    ticketNum--;
&#125;
main&#123;
    TicketDemo demo = new TicketDemo();
    for(int i = 0; i &lt; 20; i++)&#123;
        new Thread(demo::getTicket).start();
    &#125;
&#125;
</code></pre>
<h6 id="不是原子操作，怎么保证原子操作呢？"><a href="#不是原子操作，怎么保证原子操作呢？" class="headerlink" title="不是原子操作，怎么保证原子操作呢？"></a>不是原子操作，怎么保证原子操作呢？</h6><ol>
<li>synchronized：同步加锁</li>
<li>JUC里面的lock：加锁</li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4fd1c205a0d2d906c28c4a924b883b4082605a78/Synchronized%E4%B8%8ELock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<ul>
<li><strong><span style = "color:blue">可见性<del>volatile、synchronized、lock</del></span></strong></li>
</ul>
<h6 id="内存可见性：让一个线程对共享变量的修改对另一个线程可见"><a href="#内存可见性：让一个线程对共享变量的修改对另一个线程可见" class="headerlink" title="内存可见性：让一个线程对共享变量的修改对另一个线程可见"></a>内存可见性：让一个线程对共享变量的修改对另一个线程可见</h6><pre><code class="java">public class VolatileDemo&#123;
    private static boolean flag = false;
    public static void main(String[] args) throws InterruptedException&#123;
        new Thread(()-&gt;&#123;
            while(!flag)&#123;
                sout(&quot;第一个线程执行完毕...&quot;);
            &#125;
        &#125;).start();
        Thread.sleep(100);
        new Thread(()-&gt;&#123;
            flag = true;
            sout(&quot;第二个线程执行完毕...&quot;);
        &#125;).start();
    &#125;
&#125;
</code></pre>
<p><strong>解决方案：synchronized、<u>volatile</u>、LOCK</strong> </p>
<p>volatile：加在共享变量上面即可 →  private static <strong>volatile</strong> boolean flag &#x3D; false;</p>
<ul>
<li><strong><span style = "color:blue">有序性<del>volatile</del></span></strong></li>
</ul>
<p><strong>指令重排</strong>：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p>
<pre><code class="java">int x;
int y;
@Actor
public void actor1()&#123;
    x = 1;
    y = 1;
&#125;
@Actor
public void actor2(II_Result r)&#123;
    r.r1 = y;
    r.r2 = x;
&#125;
</code></pre>
<p><strong>解决办法</strong>：在前面加上<code>volatile</code></p>
<p><span style = "color:red"><strong>说一下线程池的核心参数</strong></span></p>
<p>为什么要创建线程池 因为每次创建线程的时候就要占用一定的内存空间 无限创建线程回浪费内存<del>严重会导致内存溢出</del><br>CPU有限的同一时刻只能同时处理一个线程 大量线程来的话就没有线程权 会造成线程等待 造成大量线程在之间切换也会导致性能变慢</p>
<pre><code class="java">在这个例子中，我们创建了一个线程池，核心线程数为5，最大线程数为10，如果线程池中的线程数大于核心线程数，则空闲线程在60秒后会被终止。工作队列使用ArrayBlockingQueue，其容量为100。

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolExample &#123;
    public static void main(String[] args) &#123;
        // 核心线程数
        int corePoolSize = 5;
        // 最大线程数 = （核心线程 + 救急线程的最大数目）
        int maximumPoolSize = 10;
        // 线程池中超过 corePoolSize 数量的空闲线程最大存活时间
        long keepAliveTime = 60L;
        // 时间单位 - 救急线程的生存时间单位，如秒、毫秒等
        TimeUnit unit = TimeUnit.SECONDS;
        // 工作队列，用于存放提交的任务 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务
        ArrayBlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;&gt;(100);
        // 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等
        ThreadFactory threadFactory = new ThreadFactory;
        // 拒绝策略 - 当所有线程豆繁忙，workQueue也繁忙时，会触发拒绝策略
        RejectedExecutionHandler handler = new RejectedExecutionHandler;
        
        // 创建线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                corePoolSize,
                maximumPoolSize,
                keepAliveTime,
                unit,
                workQueue
        );

        // 示例：向线程池提交任务  threadPoolExecutor.submit()/.execute()
        for (int i = 0; i &lt; 20; i++) &#123;
            int taskNumber = i;
            threadPoolExecutor.execute(() -&gt; &#123;
                System.out.println(&quot;Executing task &quot; + taskNumber);
                // 模拟任务执行时间
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;);
        &#125;

        // 关闭线程池
        threadPoolExecutor.shutdown();
    &#125;
&#125;
</code></pre>
<p>一开始new的时候没有 是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><span style = "color:red"><strong>线程池中有哪些常见的阻塞队列</strong></span></p>
<p><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>workQueue - 阻塞队列常用的队列</u>：当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
<li>DelayedWorkQueue：是一个优先级队列，它可以保证每次出队的任务都是当前队列中时间最靠前的</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作</li>
</ol>
<table>
<thead>
<tr>
<th align="center">ArrayBlockingQueue</th>
<th align="center"><span style = "color:red">LinkedBlockingQueue<del>不给值默认最大值</del></span></th>
</tr>
</thead>
<tbody><tr>
<td align="center">强制有界</td>
<td align="center">默认无界，支持有界</td>
</tr>
<tr>
<td align="center">底层是数组</td>
<td align="center">底层是链表</td>
</tr>
<tr>
<td align="center">提前初始化Node数组</td>
<td align="center">是懒惰的，创建节点的时候添加数据</td>
</tr>
<tr>
<td align="center">Node需要是提前创建好的</td>
<td align="center">入队会生成新Node</td>
</tr>
<tr>
<td align="center">一把锁</td>
<td align="center">两把锁(头尾)<del>可以一边入队,一边出队</del></td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>如何确定核心线程数</strong></span></p>
<blockquote>
<p>① 高并发、任务执行时间短 → (CPU核数 + 1)，减少线程上下文的切换<br>② 并发不高、任务执行时间长</p>
<ul>
<li><strong>IO密集型任务 → (CPU核数 * 2 + 1)</strong></li>
<li>计算密集型任务 → (CPU核数 + 1)</li>
</ul>
<p>③ <strong>并发高、业务执行时间长</strong>，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置参考②</p>
</blockquote>
<ul>
<li>IO密集型任务：文件读写、DB读写、网络请求等                            <span style = "color:blue"><strong>核心线程数大小设置为2N+1</strong></span></li>
<li>CPU密集型任务：计算型代码、Bitmap转换、Gson转换等            <span style = "color:blue"><strong>核心线程数大小设置为N+1</strong></span></li>
</ul>
<pre><code class="java">// 查看机器的CPU核数
public static void main(String[] args)&#123;
    // 查看机器的CPU核数
    System.out.println(Runtime.getRuntime().avaliableProcessors());
&#125;
</code></pre>
<p><span style = "color:red"><strong>线程池的种类有哪些</strong></span></p>
<p>在<code>java.util.concurrent.Executors</code>类中提供了大量创建线程池的静态方法，常见的有四种</p>
<h6 id="①-创建使用固定线程数的线程池"><a href="#①-创建使用固定线程数的线程池" class="headerlink" title="① 创建使用固定线程数的线程池"></a>① 创建使用固定线程数的线程池</h6><p><span style = "color:blue">适用于任务已知，相对耗时的任务</span></p>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads)&#123;
    return new ThreadPoolExecutor(nThreads, nThreads,0L,TimeUnit.MILLISECONDS.new LinkedBlockingQueue&lt;Runnable&gt;)
&#125;
</code></pre>
<ul>
<li>核心线程数与最大线程数一样，没有<code>救急线程 = 最大线程数 - 核心线程数</code></li>
<li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li>
</ul>
<h6 id="②-单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-执行→-先进先出"><a href="#②-单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-执行→-先进先出" class="headerlink" title="② 单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO)执行→[先进先出]"></a>② 单线程化的线程池<del>它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO)执行→[先进先出]</del></h6><p><span style = "color:blue">适用于按照顺序执行的任务</span></p>
<pre><code class="java">public static ExecutorService newSingleThreadExecutor()&#123;
    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));
&#125;
</code></pre>
<ul>
<li>核心线程数和最大线程数都是1</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code>，最大容量为<code>Integer.MAX_VALUE</code></li>
</ul>
<h6 id="③-可缓存线程池"><a href="#③-可缓存线程池" class="headerlink" title="③ 可缓存线程池"></a>③ 可缓存线程池</h6><pre><code class="java">public static ExecutorService newCachedThreadPool()&#123;
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());
&#125;
</code></pre>
<ul>
<li>核心线程数为0</li>
<li>最大线程数是<code>Integer.MAX_VALUE</code></li>
<li>阻塞队列是<code>SynchronousQueue</code>: 不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作</li>
</ul>
<h6 id="④-提供了-延迟-和-周期执行-功能的ThreadPoolExecutor"><a href="#④-提供了-延迟-和-周期执行-功能的ThreadPoolExecutor" class="headerlink" title="④ 提供了 延迟 和 周期执行 功能的ThreadPoolExecutor"></a>④ 提供了 <code>延迟</code> 和 <code>周期执行</code> 功能的ThreadPoolExecutor</h6><pre><code class="java">public ScheduledThreadPoolExecutor(int corePoolSize)&#123;
    super(corePoolSize, Integer.MAX_VALUE,0,NANOSECONDS,new DelayedWorkQueue());
&#125;
</code></pre>
<p><span style = "color:red"><strong>为什么不建议使用Executors创建线程池？</strong></span></p>
<p>参考阿里开发手册</p>
<pre><code class="java">【强制】 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors返回的线程池对象的弊端如下：
1. FixedThreadPool 和 SingleThreadPool：
允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM
2. CachedThreadPool：
允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程，从而导致OOM
</code></pre>
<p><span style = "color:red"><strong>线程池的使用场景①：ES数据批量导入</strong></span></p>
<h6 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h6><p>CountDownLatch(闭锁&#x2F;倒计时锁)用来进行线程同步协作，等待所有线程完成倒计时时(一个或多个线程，等待其他多个线程完成某件事情之后才能执行)</p>
<ul>
<li>其中构造参数用来初始化等待计数值</li>
<li><code>await()</code>用来等待计数归零</li>
<li><code>countDown()</code>用来让计数减一</li>
</ul>
<h6 id="多线程使用场景一-es数据批量导入"><a href="#多线程使用场景一-es数据批量导入" class="headerlink" title="多线程使用场景一 (es数据批量导入)"></a>多线程使用场景一 (es数据批量导入)</h6><p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右一次性读取数据肯定不行(oom异常)，当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制就能避免一次性加载过多，防止内存溢出</p>
<p>DB(一千万) → 线程池(CountDownLatch) → Elasticearch</p>
<pre><code class="java">       批量导入  →  查询总条数   →       DB
                      ↓               ↑          批量导入到ES中     →   ES
(固定每页2000条)        计算总页数            ↑  (countDownLatch.countDown())
                        ↓               ↑                ↑
(总页数)         CountDownLatch        ↑                ↑
                        ↓               ↑                ↑
                分页查询文章数据 → [查询当前页的文章 → 创建任务批量导入ES → 提交到线程池执行]循环
                                             (文章列表, countDownLatch)
                                                          ↓
                                                countDownLatch.await()
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a8e33cd1bf93eca7f789f20cee1a67770b426f68/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-CountDownLatch%E7%94%A8ES%E6%89%B9%E9%87%8F.png"></p>
<p><span style = "color:red"><strong>线程池的使用场景②：数据汇总</strong></span></p>
<ul>
<li>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息;这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢?<ul>
<li>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口(或部分接口)的没有依赖关系，就可以使用线程池+future来提升性能<br>[<u>统计的图文发布量、点赞数量、收藏数量、评论数量若不在同一台微服务下 或者 部分没有依赖关系</u>]</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b9ec7c6d685bab18893fbfa3b6637c48f3384ecf/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%94%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB.png"></p>
<p><span style = "color:red"><strong>线程池的使用场景③：异步调用</strong></span></p>
<p>为了避免下一级方法影响上一级方法(性能考虑)，可使用<strong>异步线程调用</strong>下一个方法(不需要下一级方法返回值)，可以提升方法相应时间</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8b9788570956b65f8073f31b82bada34a8ddb799/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png"></p>
<p><span style = "color:red"><strong>如何控制某个方法允许并发访问线程的数量</strong></span></p>
<p>Semaphore信号量，是JUC包下的一个工具类，底层是AQS，我们可以通过其限制执行的线程数量<br><strong>适用场景</strong>：<br>通常用于那些资源有明确访问数量限制的场景，常用于限流</p>
<h6 id="Semaphore使用步骤"><a href="#Semaphore使用步骤" class="headerlink" title="Semaphore使用步骤"></a>Semaphore使用步骤</h6><ul>
<li>创建Semaphore对象，可以给一个容器</li>
<li>semaphore.acquire()：请求一个信号量，这时候的信号量个数 -1 (<u>一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量</u>)</li>
<li>semaphore.release()：释放一个信号量，此时信号量个数 +1</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76cde79a53b36086d940f2874f8aa7ffd93ce6ef/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F.png"></p>
<p><span style = "color:red"><strong>谈一谈你对ThreadLocal的理解</strong></span></p>
<blockquote>
<ul>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
<li>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线<br>程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中査找关联的资源值</li>
<li>调用remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
</li>
<li>ThreadLocal内存泄漏问题ThreadLocalMap 中的key是弱引用，值为强引用; key会被Gc释放内存，关联 value的内存并不会释放。建议主动remove 释放 key，value</li>
</ul>
</blockquote>
<h6 id="ThreadLocal概述"><a href="#ThreadLocal概述" class="headerlink" title="ThreadLocal概述"></a>ThreadLocal概述</h6><p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会<strong>为每个线程都分配一个独立的线程副本</strong>从而解决了变量并发访问冲突的问题。ThreadLocal同时实现了线程内的资源共享</p>
<p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p>
<p><strong>ThreadLocal基本使用</strong></p>
<ul>
<li>set(value) 设置值</li>
<li>get() 获取值</li>
<li>remove() 清除值</li>
</ul>
<h6 id="ThreadLocal的实现原理-amp-源码解析"><a href="#ThreadLocal的实现原理-amp-源码解析" class="headerlink" title="ThreadLocal的实现原理 &amp; 源码解析"></a>ThreadLocal的实现原理 &amp; 源码解析</h6><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离<br><img src="https://raw.githubusercontent.com/P-luminary/images/4471cf0ff69616926ff6fab93392d3d9fa5aba32/%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3.png"></p>
<h2 id="JVM相关面试题"><a href="#JVM相关面试题" class="headerlink" title="JVM相关面试题"></a>JVM相关面试题</h2><p><span style = "color:red"><strong>什么是JVM？</strong></span></p>
<p>JVM &#x3D; <code>Java Virtual Machine</code>  是java程序的运行环境<br>JVM是运行在操作系统中的 屏蔽了操作系统的差异</p>
<p><strong>好处</strong>：</p>
<ul>
<li>一次编码，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a325bf161b1cdb5a49058d007d4e21a05f2a1fc5/JVM%E7%94%B1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png"></p>
<p><span style = "color:red"><strong>什么是程序计数器？</strong></span></p>
<p><strong>程序计数器</strong>：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址</p>
<p><code>javap -v xx.class</code>：打印堆栈大小，局部变量的数量和方法的参数</p>
<blockquote>
<p>找到Application的class文件后 → Build → Rebuild Project<del>编译一下</del> → 找到该Application的class文件<del>黄色的</del> → Open in → Terminal → javap -v Application.class</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f1c8f0c34bb891c12d945dd852ab575a787a2112/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png"></p>
<p><span style = "color:red"><strong>你能给我详细介绍Java堆吗？</strong></span></p>
<p><strong>线程共享的区域：</strong>主要用来保存<strong>对象实例、数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展，则抛出<code>OutOfMemoryError</code>异常</p>
<ul>
<li>组成：<strong>年轻代 + 老年代</strong><ul>
<li><strong>年轻代</strong>被划分为三部分，Eden区和两个大小严格相同的Survivor区<del>幸存者区</del></li>
<li><strong>老年代</strong>主要保存生命周期长的对象，一般是一些老的对象</li>
</ul>
</li>
<li>jdk1.7和1.8的区别<ul>
<li>1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码</li>
<li>1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5e6f155423b028b82378d40f63a3713073b75410/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86.png"></p>
<p><span style = "color:red"><strong>什么是虚拟机栈？</strong></span></p>
<p><code>Java Virtual machine Stacks</code>(Java虚拟机栈)</p>
<ul>
<li>每个线程运行时所需要的内存，称为<strong>虚拟机栈</strong>，先进后出</li>
<li>每个栈由多个栈帧(frame)组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<p><span style = "color:blue">垃圾回收是否涉及栈内存？</span></p>
<p>不涉及，因为垃圾回收主要指的是<strong>堆内存</strong>。<br>这里当栈帧弹栈后，内存就会释放</p>
<p><span style = "color:blue">栈内存分配越大越好吗？</span></p>
<p>未必，默认的栈内存通常为1024k<br>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p>
<p><span style = "color:blue">方法内的局部变量是否线程安全？</span></p>
<p>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的<br>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p>
<p><span style = "color:blue">什么情况下会导致栈内存溢出？</span></p>
<p>栈帧过多导致栈内存溢出，经典问题：递归调用<br>栈帧过大导致栈内存溢出</p>
<p><span style = "color:blue">堆栈的区别是什么？</span></p>
<p>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会<br>栈内存是线程私有的，而堆内存是线程共有的。<br>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常<br>  栈空间不足:java.lang.StackOverFlowError。<br>  堆空间不足:java.ang.OutOfMemoryError。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/420de72ff7c225960e7aff5d59f20c14e93ecb0a/%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p>
<p><span style = "color:red"><strong>能不能解释一下方法区</strong></span></p>
<ul>
<li>方法区(Method Area)是各个线程<strong>共享的内存区域</strong></li>
<li>主要存储类的信息、运行时常量池</li>
<li>虚拟机启动的时候创建，关闭虚拟机时释放</li>
<li>如果方法区域中的内存无法满足分配请求，则会抛出<code>OutOfMemoryError: Metaspace</code></li>
</ul>
<h6 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h6><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息<br>在<strong>Terminal</strong>中执行：<code>javap -v Application.class</code><br>可以查看字节码结构 (<strong><u>类的基本信息、常量池、方法定义</u></strong>)<br>当类被加载，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dea620655b2b4c7234ba3b2f4fcedbf76a0bb9a8/%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA.png"></p>
<p><span style = "color:red"><strong>你听过直接内存吗？</strong></span></p>
<p><strong>直接内存</strong>：并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存，常见于NIO操作时，用于数据缓冲区，它分配回收成本较高，但读写能力高。[平时的是BIO]</p>
<p>直接内存并不属于JVM中的内存结构，不由VM进行管理。是虚拟机的系统内存常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5823b0e711a3e4029e411438f0a85468af5dfa3f/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.png"></p>
<p><span style = "color:red"><strong>什么是类加载器，类加载器有哪些？</strong></span></p>
<h6 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h6><p>JVM只会运行二进制文件，类加载器的作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来</p>
<ol>
<li><strong>引导类加载器（Bootstrap ClassLoader）</strong>：<del>加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的库</del><ul>
<li>这是最顶层的类加载器，它用于加载Java的核心库，这些库位于<code>&lt;JAVA_HOME&gt;/jre/lib</code>目录（比如<code>rt.jar</code>、<code>resources.jar</code>等），或者被<code>-Xbootclasspath</code>参数指定的路径中。</li>
<li><u><strong>引导类加载器是用原生代码（如C&#x2F;C++）实现的</strong></u>，它属于JVM的一部分。</li>
<li>它并不继承自<code>java.lang.ClassLoader</code>，而是由JVM自身实现。</li>
</ul>
</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：<del>加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类</del><ul>
<li>它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录中，或者由系统属性<code>java.ext.dirs</code>指定的路径中的类库。</li>
<li>它是<code>sun.misc.Launcher$ExtClassLoader</code>类的实例。</li>
</ul>
</li>
<li><strong>系统类加载器（System ClassLoader）</strong>：<del>用于加载classPath下的类</del><ul>
<li>也称为应用类加载器（Application ClassLoader），它负责加载用户类路径（Classpath）上的所有类库。</li>
<li>系统类加载器是<code>sun.misc.Launcher$AppClassLoader</code>类的实例。</li>
<li>它是程序中默认的类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>方法获取。</li>
</ul>
</li>
<li><strong>自定义加载器（CustomizeClassLoader）</strong><del>自定义继承ClassLoader，实现自定义类加载规则</del><ul>
<li>用户还可以自定义类加载器。自定义类加载器通过继承<code>java.lang.ClassLoader</code>类并重写相应的方法来实现。自定义类加载器可以用于特定的需求，例如在Web容器中加载类，或者在运行时从网络或其他地方动态加载类。</li>
</ul>
</li>
</ol>
<p><span style = "color:red"><strong>什么是双亲委派模型？</strong></span></p>
<p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类</p>
<h6 id="JVM为什么采用双亲委派机制？"><a href="#JVM为什么采用双亲委派机制？" class="headerlink" title="JVM为什么采用双亲委派机制？"></a>JVM为什么采用双亲委派机制？</h6><ul>
<li>通过双亲委派机制可以<strong>避免某一个类被重复加载</strong>，当父类已经加载后则无需重复加载，保证唯一性</li>
<li>为了安全，保证类库API不会被修改</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/994e5705a6bdb7a164308d3496942d154c877b36/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p>
<p><span style = "color:red"><strong>说一下类装载的执行过程？</strong></span></p>
<blockquote>
<p><strong>加载</strong>：查找和导入class文件<br><strong>验证</strong>：保证加载类的准确性<br><strong>准备</strong>：为类变量分配内存并设置类变量初始值<br><strong>解析</strong>：把类中的符号引用转换为直接引用<br><strong>初始化</strong>：对类的静态变量，静态代码块执行初始化操作<br><strong>使用</strong>：JVM 开始从入口方法开始执行用户的程序代码<br><strong>卸载</strong>：当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象</p>
</blockquote>
<p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：<strong>加载、验证、准备、解析、初始化、使用</strong>和<strong>卸载</strong>这7个阶段。其中，验证、准备和解析这三个部分统称为连接(linking)</p>
<ul>
<li>通过类的全名，获得类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构(Java类模型)</li>
<li>创建<code>java.lang.Class</code>类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6e58e968ea6bb8bb002556d37d5cc31b73f820e3/%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B1.png"></p>
<p><span style = "color:red"><strong>对象什么时候可以被垃圾器回收</strong></span></p>
<p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收</p>
<h6 id="怎么确定什么是垃圾？"><a href="#怎么确定什么是垃圾？" class="headerlink" title="怎么确定什么是垃圾？"></a>怎么确定什么是垃圾？</h6><ul>
<li><p><strong>引用计数法</strong></p>
<p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<p>采用的都是通过可达性分析算法来确定哪些内容是垃圾</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e29795c3537bdedf4f596d20c78cda8b7f8abc8c/%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6.png"></p>
<p><span style = "color:red"><strong>JVM垃圾回收算法有哪些？</strong></span></p>
<ul>
<li><p><strong>标记清除算法</strong></p>
<p>是将垃圾回收分为2个阶段，分别为<strong>标记</strong>和<strong>清除</strong></p>
<ul>
<li>根据可达性分析算法得出的垃圾进行标记</li>
<li>对这些标记为可回收的内容进行垃圾回收</li>
</ul>
</li>
<li><p><strong>复制算法</strong></p>
<p>将原有的内存空间一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收；无碎片，内存使用率低</p>
</li>
<li><p><strong>标记清理算法</strong><del>一般用于老年代</del></p>
<p>标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，无碎片，对象需要移动，效率低</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/da45a9b399c0614bb286b0dfef59d0d737ee7b38/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png"></p>
<p><span style = "color:red"><strong>JVM的分代回收是什么？</strong></span></p>
<h6 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h6><p>在java8时，堆被分为了两份：<strong>新生代和老年代</strong>[1:2]<br>对于新生代，内部又分为了三个区域，Eden区，幸存者区survivor(分成from和to)【8:1:1】</p>
<h6 id="MinorGC、MixedGC、FullGC的区别是什么"><a href="#MinorGC、MixedGC、FullGC的区别是什么" class="headerlink" title="MinorGC、MixedGC、FullGC的区别是什么"></a>MinorGC、MixedGC、FullGC的区别是什么</h6><ul>
<li>MinorGC<del>(youngGC)</del>发生在新生代的垃圾回收，暂停时间短(STW)</li>
<li>MixedGC：新生代 + 老年代 <strong>部分</strong>区域的垃圾回收，G1收集器特有</li>
<li>FullGC：新生代 + 老年代 <strong>完整</strong>垃圾回收，暂停时间长(STW)，应尽力避免</li>
</ul>
<p><code>STW(Stop-The-World)</code>：<u>暂停所有应用程序线程，等待垃圾回收的完成</u></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3cf5dfdf35165c472440a0b24f3561c6bef9b81a/JVM%E7%9A%84%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%80%E4%B9%88.png"></p>
<p><span style = "color:red"><strong>JVM有哪些垃圾回收器？</strong></span></p>
<p>在jvm中，实现了多种垃圾收集器，包括：</p>
<ul>
<li><p><strong>串行垃圾收集器</strong></p>
<p><strong>Serial</strong>和<strong>Serial Old</strong>串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p>
<ul>
<li>Serial 作用于新生代，采用复制算法</li>
<li>Serial Old 作用于老年代，采用标记-整理算法垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成</li>
</ul>
</li>
<li><p><strong>并行垃圾收集器</strong></p>
<p>Parallel New和Parallel Old是一个<strong>并行</strong>垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p>
<ul>
<li><p>Parallel New作用于新生代，采用复制算法</p>
</li>
<li><p>Parallel Old作用于老年代，采用标记-整理算法</p>
<p>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成。</p>
</li>
</ul>
</li>
<li><p><strong>CMS(并发)垃圾收集器</strong></p>
<p>CMS全称 Concurrent Mark Sweep，是一款<strong>并发</strong>的、使用<strong>标记-清除</strong>算法的垃圾回收器，该回收器是<strong>针对老年代垃圾回收的</strong>，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行</p>
</li>
<li><p><strong>G1垃圾收集器</strong></p>
<p>作用在新生代和老年代</p>
</li>
</ul>
<p><span style = "color:red"><strong>详细聊一下G1垃圾回收器</strong></span></p>
<ul>
<li>应用于新生代和老年代，<strong>在JDK9之后默认使用G1</strong></li>
<li>划分成多个区域，每个区域都可以充当<strong>eden，survivor，old，humongous</strong>，其中<code>humongous</code>专为大对象准备</li>
<li>采用复制算法</li>
<li>响应时间与吞吐量兼顾</li>
<li>分成三个阶段：新生代回收(STW)、并发标记(重新标记STW)、混合收集</li>
<li>如果并发失败(即回收速度赶不上创建新对象速度)，就会触发<code>Full GC</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1a968a17f25b1bbd6bdde1c89b08cb064802b868/%E8%AF%A6%E7%BB%86%E8%81%8A%E4%B8%80%E4%B8%8BG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
<p><span style = "color:red"><strong>强引用、软引用、弱引用、虚引用的区别</strong></span></p>
<blockquote>
<p><strong>强引用</strong>：只要所有 GC Roots 能找到，就不会被回收<br><strong>软引用</strong>：需要配合<code>SoftReference</code>使用，当垃圾多次回收，内存依然不够时候会回收软引用对象<br><strong>弱引用</strong>：需要配合<code>WeakReference</code>使用，只要进行了垃圾回收，就会把引用对象回收<br><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</p>
</blockquote>
<ul>
<li><strong>强引用</strong>：只有所有 <code>GCRoots</code> 对象都不通过【强引用】 引用该对象，该对象才能被垃圾回收</li>
</ul>
<pre><code class="java">User user = new User();
</code></pre>
<p>  <u>GC Root → User对象</u></p>
<ul>
<li><strong>软引用</strong>：仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足</strong>时会再次触发垃圾回收</li>
</ul>
<pre><code class="java">User user = new User();
SoftReference softReference = new SoftReference(user);
</code></pre>
<p>  <u>GC Root → SoftReference对象 →→<del>虚线</del> User对象</u><br>  一开始并不会对User对象进行回收 此时User对象就是软引用 如果内存还是不够 马上又再次进行了垃    圾回收 此时软引用的User就会被回收</p>
<ul>
<li><strong>弱引用</strong>：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
</ul>
<pre><code class="java">User user = new User();
WeakReference weakReference = new WeakReference(user)
</code></pre>
<p>  <u>GC Root → WeakReference对象 →→<del>虚线</del> User对象</u></p>
<blockquote>
<p>延申话题：ThreadLocal内存泄露问题</p>
<pre><code class="java">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;&#123;
    Object value;
    Entry(ThreadLocal&lt;?&gt;k, Object v)&#123;
        super(k); // k是弱引用
        value = v; // 强引用，不会被回收
    &#125;
&#125;
</code></pre>
</blockquote>
<ul>
<li><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</li>
</ul>
<pre><code class="java">User user = new User();
ReferenceQueue referenceQueue = new ReferenceQueue();
PhantomReference phantomReference = new PhantomReference(user, queue);
</code></pre>
<p><span style = "color:red"><strong>JVM调优的参数可以在哪里设置？</strong></span></p>
<ul>
<li><p><code>war包</code>部署在<code>tomcat</code>中设置</p>
<p>修改 <code>TOMCAT_HOME/bin/catalina.sh</code> 文件<br><code>D:\apache-tomcat-8.5.93\bin\catalina.sh</code></p>
<pre><code class="mysql"># OS specific support.  $var _must_ be set to either true or false.
JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot;
cygwin=false
darwin=false
os400=false
hpux=false
</code></pre>
</li>
<li><p><code>jar包</code>部署在<code>启动参数</code>设置</p>
<p>通常在linux系统下直接加参数启动SpringBoot项目<del>—VM</del></p>
<p><code>nohup java -Xms512m -Xmx1024n -jar xxxx.jar --spring.profiles.active=prod &amp;</code></p>
</li>
</ul>
<p><strong>nohup</strong>：用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行<br>**参数<code>&amp;</code>**：让命令在后台执行，终端退出后命令仍然执行</p>
<p><span style = "color:red"><strong>JVM调优的参数都有哪些？</strong></span></p>
<p>对于JVM调优，主要就是调整 <code>年轻代、老年代、元空间</code> 的内存大小及使用的垃圾回收器类型</p>
<ul>
<li><p><strong>设置堆空间大小</strong></p>
<p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p>
<pre><code class="java">-Xms: 设置堆的初始化大小
-Xmx: 设置堆的最大大小
// 不指定单位默认为字节
-Xms：1024
-Xms：1024k
</code></pre>
<p>堆内存设置多少合适？</p>
<ul>
<li>最大大小的默认值是物理内存的1&#x2F;4，<strong>初始大小是物理内存的1&#x2F;64</strong><del>【不设置的情况下】</del></li>
<li>堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生STW，暂停用户线程</li>
<li>堆内存大肯定是好的，存在风险，假如发生了fullgc，它会扫描整个堆空间，暂停用户线程的时间长</li>
</ul>
</li>
<li><p><strong>虚拟机栈的设置</strong></p>
<p>虚拟机栈的设置：<strong>每个线程默认会开启1M的内存</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>
<p><code>-Xss 对每个线程stack大小的调整，-Xss128k</code></p>
</li>
<li><p><strong>年轻代中Eden区和两个Survivor区的大小比例</strong></p>
<p>设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。通过增大Eden区的大小来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p>
<p><code>-XXSurvivorRatio=8，表示年轻代中的分配比率：survivor:eden = 2:8</code></p>
</li>
<li><p><strong>年前代晋升老年代阈值</strong>【默认值为15，取值范围0-15】</p>
<p><code>-XX:MaxTenuringThreshold=threshold</code></p>
</li>
<li><p><strong>设置垃圾回收收集器</strong></p>
<p>通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器</p>
<p><code>-XX:+UseParallelGC</code><br><code>-XX:+UseParallelOldGC</code></p>
<p><code>-XX:+UserG1GC</code></p>
</li>
</ul>
<p><span style = "color:red"><strong>JVM调优的参数都有哪些？</strong></span></p>
<ul>
<li><p><strong>命令工具</strong></p>
<ul>
<li><p><strong>jps</strong> 进程状态信息</p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
</li>
<li><p><strong>jmap</strong> 查看堆栈信息[生成堆转内存快照,内存使用信息]</p>
<pre><code class="java">jmap -head pid 显示Java堆的信息
jmap -dump:format=b,file=heap.hprof pid
</code></pre>
<ul>
<li><p>format&#x3D;b 表示以hprof二进制格式存储Java堆的内存</p>
</li>
<li><p>file&#x3D;&lt; filename  &gt; 用于指定快照dump文件的文件名</p>
<p><code>dump</code>：它是我们都可以通过工个进程或系统在某一给定的时间的快照。比如在进程崩溃时，甚至是任何时候，具将系统或某进程的内存备份出来供调试分析用，dump文件中包含了程序运行的模块信息、线程信息、堆调用信息、异常信息等数据，方便系统技术人品进行错误排查</p>
</li>
</ul>
</li>
<li><p><strong>jhat</strong> 堆转储快照分析工具</p>
</li>
<li><p><strong>jstat</strong> JVM统计监测工具[可以用来显示垃圾回收信息、类加载信息、新生代统计信息等]</p>
<ul>
<li>总结垃圾回收统计：<code>jstat -gcutil pid</code></li>
<li>垃圾回收统计：<code>jstat -gc pid</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可视化工具</strong></p>
<ul>
<li><strong>jconsole</strong> 用于对jvm的内存，线程，类的监控, 是一个可视化工具<br><code>D:\java\jdk-11.0.20\bin\jconsole.exe</code></li>
<li><strong>VisualVM</strong> 能够监控线程，内存情况<del>只有jdk1.8有</del><br><code>D:\java\jdk1.8.0_181\bin\jvisualvm.exe</code></li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>Java内存泄露的排查思路？</strong></span></p>
<blockquote>
<p>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况<br>1、通过jmap或设置jvm参数获取堆内存快照dump<br>2、通过工具，VisualVM去分析dump文件，VisualVM可以加载离线的dump文件<br>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题<br>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
</blockquote>
<p>JVM  Stacks <strong>虚拟机栈</strong> → <code>StackOverFlowError</code><br>Heap <strong>堆</strong> → <code>OutOfMemoryError：java heap space</code><br>Method Are&#x2F; MateSpace <strong>方法区&#x2F;元空间</strong> → <code>OutOfMemoryError: Metaspace</code></p>
<p>模拟堆空间溢出场景：-VM设置参数 → <code>-Xmx10m</code></p>
<pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
while(true)&#123;
    list.add(&quot;北京&quot;);
&#125;
-------------------------------------------
// OutOfMemoryError：java heap space
</code></pre>
<h6 id="如何排查启动闪退、运行一段时间宕机"><a href="#如何排查启动闪退、运行一段时间宕机" class="headerlink" title="如何排查启动闪退、运行一段时间宕机"></a>如何排查启动闪退、运行一段时间宕机</h6><ul>
<li><p>获取堆内存快照dump</p>
<ul>
<li>使用jmap命令获取运行中程序的dump文件<del>【只有在项目运行时候才可以用】</del></li>
</ul>
<pre><code class="java">jmap -head pid 显示Java堆的信息
jmap -dump:format=b,file=heap.hprof pid 【只有在项目运行时候才可以用】
</code></pre>
<ul>
<li><p><strong>使用vm参数获取dump文件</strong></p>
<p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式生成dump文件</p>
</li>
</ul>
<pre><code class="java">-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/home/app/dumps/
</code></pre>
</li>
<li><p>VisualVM区分析dump文件</p>
</li>
<li><p>通过查看堆内存的信息，定位内存溢出问题</p>
</li>
</ul>
<p><span style = "color:red"><strong>CPU飙高排查方案与思路？</strong></span></p>
<blockquote>
<p>1.使用top命令查看占用cpu的情况<br>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>3.使用ps命令查看进程中的线程信息<br>4.使用jstack命令查看进程中哪些线程出现了问题，最终定位问题</p>
</blockquote>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程转换十六进程<br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><span style = "color:red">设计模式</span></h2><h5 id="框架中的设计模式-项目中的设计模式"><a href="#框架中的设计模式-项目中的设计模式" class="headerlink" title="框架中的设计模式 + 项目中的设计模式"></a>框架中的设计模式 + 项目中的设计模式</h5><p><span style = "color:red"><strong>简单工厂模式</strong></span></p>
<p>简单工厂包含如下角色</p>
<ul>
<li><strong>抽象产品</strong>：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li><strong>具体产品</strong> ：实现或者继承抽象产品的子类</li>
<li><strong>具体工厂</strong>：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<p>需求：设计一个咖啡店点餐系统。<br>设计一个咖啡类(Coffee)，并定义其两个子类(美式咖啡【AmericanCofee】和拿铁咖啡【LatteCoffee】); 再设计一个咖啡店类(CoffeeStore)，咖啡店具有点咖啡的功能。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d91b96f4466457e253dd9a8b298f99c098e4501c/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<p><span style = "color:red"><strong>工厂方法模式</strong></span><del>完全遵循开闭原则</del></p>
<p>方法模式的主要角色:<br><strong>抽象工厂</strong>(Abstract Factory)：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。<br><strong>具体工厂</strong>(ConcreteFactory)：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。<br><strong>抽象产品</strong>(Product)：定义了产品的规范，描述了产品的主要特性和功能。<br><strong>具体产品</strong>(ConcreteProduct)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一 一对应。</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/55e41a4a745af324a0d0a18d0af0694fb0d319e9/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" style="zoom: 67%;" />



<p><span style = "color:red"><strong>抽象工厂模式</strong></span></p>
<p>工厂方法模式只考虑生产同等级的产品，抽象工厂可以处理等级产品的生产<br>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产–个等级的产品，而抽象工厂模式可生产多个等级的产品<strong>。一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dc778be8350e592f74d23beeee7c256826204f4/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<p><span style = "color:red"><strong>策略模式</strong></span></p>
<ul>
<li>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</li>
<li>它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</li>
</ul>
<p>策略模式的主要角色如下:<br><strong>抽象策略(Strategy)类</strong>：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口<br><strong>具体策略(Concrete Strategy)类</strong>：实现了抽象策略定义的接口，提供具体的算法实现或行为。<br><strong>环境(Context)类</strong>：持有一个策略类的引用，最终给客户端调用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b29eac1685bcdf60e7adde25286c276ddbeb43a7/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F+%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA.png"></p>
<h4 id="策略模式—登录案例-工厂模式-策略模式"><a href="#策略模式—登录案例-工厂模式-策略模式" class="headerlink" title="策略模式—登录案例 (工厂模式 + 策略模式)"></a><span style = "color:red"><strong>策略模式—登录案例 (工厂模式 + 策略模式)</strong></span></h4><blockquote>
<ul>
<li><p>什么是策略模式</p>
<ul>
<li><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</p>
</li>
<li><p>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中</p>
</li>
</ul>
</li>
<li><p>案例(工厂方法+策略)</p>
<ul>
<li>介绍业务(登录、支付、解析excel、优惠等级…)</li>
<li>提供了很多种策略，都让spring容器管理</li>
<li>提供一个工厂：准备策略对象，根据参数提供对象</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>一句话总结</strong>：只要代码中有冗长的if-else 或switch 分支判断都可以采用策略模式优化</p>
<p><span style = "color:blue"><strong>举一反三</strong></span></p>
<ul>
<li>订单的支付策略(支付宝、微信、银行卡..)</li>
<li>解析不同类型excel(xls格式、xlsx格式)</li>
<li>打折促销(满300元9折、满500元8折、满1000元7折..)</li>
<li>物流运费阶梯计算(5kg以下、5-10kg、10-20kg、20kg以上)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/69c802f411142a1bdabf991a27b8a48662cc8ca9/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E6%8B%9F.png" alt="策略模式和工厂方法模拟.png"></p>
<p><span style = "color:red"><strong>责任链模式—概述及案例</strong></span></p>
<p>责任链模式：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<ul>
<li><strong>抽象处理者(Handler)角色</strong>：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li><strong>具体处理者(Concrete Handler)角色</strong>：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li><strong>客户类(Cient)角色</strong>：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<p><span style = "color:blue"><strong>举一反三</strong></span></p>
<ul>
<li>内容审核(视频、文章、课程)</li>
<li>订单创建</li>
<li>简易流程审批</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c73c212f673d69975c55ad134b045e433a6f1e23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F2.png"></p>
<h3 id="常见技术场景题"><a href="#常见技术场景题" class="headerlink" title="常见技术场景题"></a><span style = "color:red">常见技术场景题</span></h3><h6 id="单点登录这块怎么实现的？"><a href="#单点登录这块怎么实现的？" class="headerlink" title="单点登录这块怎么实现的？"></a><span style = "color:red">单点登录这块怎么实现的？</span></h6><p>单点登录的英文名：Single Sign On (<strong>SSO</strong>)，只需要登录一次，就可以访问所有信任的应用系统</p>
<p>① 先解释什么是单点登录：单点登录的英文名叫做:Single SignOn(简称SSO)<br>② 介绍自己项目中涉及到的单点登录(即使没涉及过，也可以说实现的思路)<br>③ 介绍单点登录的解决方案，以JWT为例<br>    用户访问其他系统，会在网关判断token是否有效<br>    如果token无效则会返回401(认证失败)前端跳转到登录页面<br>    用户发送登录请求，返回浏览器一个token，浏览器把token保存到cookie<br>    再去访问其他服务的时候，都需要携带token，由网关统一验证后路由到目标服务</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b3389992651a50673831641a3ae5dd61aa8e344a/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%BF%99%E5%9D%97%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.png"></p>
<h6 id="权限认证是如何实现的？"><a href="#权限认证是如何实现的？" class="headerlink" title="权限认证是如何实现的？"></a><span style = "color:red">权限认证是如何实现的？</span></h6><p>后台的管理系统，更注重权限控制，最常见的就是<strong>RBAC</strong>模型来指导实现权限<br>RBAC(Role-Based Access Control)基于角色的访问控制</p>
<ul>
<li>3个基础部分组成：<strong>用户、角色、权限</strong></li>
<li>具体实现：<ul>
<li>5张表：<strong>用户表、角色表、权限表、用户角色中间表、角色权限中间表</strong></li>
<li>7张表：<strong>用户表、角色表、权限表、菜单表、用户角色中间表、角色权限中间表、权限菜单中间表</strong></li>
</ul>
</li>
</ul>
<p>张三具有什么权限呢？<br>流程：张三登录系统 → 查询张三拥有的角色列表 → 再根据角色查询拥有的权限</p>
<p>权限框架：<code>Apache shiro</code>、<code>Spring Security（推荐）</code><br><img src="https://raw.githubusercontent.com/P-luminary/images/ed40dce8c09b42689021c6ee66a4565a314acc69/RBAC%E6%A8%A1%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<h6 id="上传数据的安全性你们怎么控制？"><a href="#上传数据的安全性你们怎么控制？" class="headerlink" title="上传数据的安全性你们怎么控制？"></a><span style = "color:red">上传数据的安全性你们怎么控制？</span></h6><p>主要说的是数据在网络上传输如何保证安全</p>
<p>使用**非对称加密(或对称加密)**，给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据</p>
<h6 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h6><p>文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9886840e455bef1ee39b93c8c75495b6e80fe6fb/%E5%AF%B9%E7%A7%B0+%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png"></p>
<h6 id="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1-3"><a href="#你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1-3" class="headerlink" title="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1+3"></a><span style = "color:red">你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？</span><del>1+3</del></h6><blockquote>
<p>其次你也可以说说aop的实现，比如你们操作日志记录等，利用aop切面思想，通过环绕通知等但需封装出出个切面工具类。建议你们说说sql调优，比如商品列表页需要分页查询，但是几百万商品导致查询慢，如何优化的，这是一个</p>
</blockquote>
<h6 id="①-设计模式在项目中的应用"><a href="#①-设计模式在项目中的应用" class="headerlink" title="① 设计模式在项目中的应用"></a><span style = "color:blue">① 设计模式在项目中的应用</span></h6><p>是为了遵循一系列的开发原则【工厂、策略、责任链】</p>
<ul>
<li>什么背景[技术问题] → 登录的例子</li>
<li>过程[解决问题的过程]</li>
<li>最终落地方案</li>
</ul>
<h6 id="②-线上BUGJVM-多线程"><a href="#②-线上BUGJVM-多线程" class="headerlink" title="② 线上BUGJVM+多线程"></a><span style = "color:blue">② 线上BUG<del>JVM+多线程</del></span></h6><ul>
<li>CPU飙高</li>
<li>内存泄露</li>
<li>线程死锁</li>
</ul>
<h6 id="③-调优"><a href="#③-调优" class="headerlink" title="③ 调优"></a><span style = "color:blue">③ 调优</span></h6><ul>
<li>慢接口</li>
<li>慢SQL</li>
<li>缓存方案</li>
</ul>
<p><span style = "color:blue"><strong>④ 组件封装</strong></span></p>
<ul>
<li>分布式锁</li>
<li>接口幂等</li>
<li>分布式事务</li>
<li>支付通用</li>
</ul>
<h6 id="你们项目中日志怎么采集的？"><a href="#你们项目中日志怎么采集的？" class="headerlink" title="你们项目中日志怎么采集的？"></a><span style = "color:red">你们项目中日志怎么采集的？</span></h6><blockquote>
<p>我们搭建了ELK日志采集系统<br>介绍ELK的三个组件:<br><strong>Elasticsearch</strong>是全文搜索分析引擎，可以对数据存储、搜索、分析<br><strong>Logstash</strong>是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置<br><strong>Kibana</strong>是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示</p>
</blockquote>
<ul>
<li><strong>为什么要采集日志</strong>？</li>
</ul>
<p>日志是定位系统问题的重要手段，可以根据日志信息快速定位系统中的问题</p>
<ul>
<li><strong>采集日志的方式有哪些</strong><ul>
<li><span style = "color:orange"><strong>ELK</strong>：即<code>ElasticSearch、LogStash、Kibanna</code>三个软件的首字母</span></li>
<li><strong>常规采集</strong>：按天保存到一个日志文件</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b737bd7a31bb44363954ebefe0f32095096a3793/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E6%80%8E%E4%B9%88%E9%87%87%E9%9B%86%E7%9A%84.png"></p>
<h6 id="查看日志的命令？查看是否在线查看过日志"><a href="#查看日志的命令？查看是否在线查看过日志" class="headerlink" title="查看日志的命令？查看是否在线查看过日志"></a><span style = "color:red">查看日志的命令？</span><del>查看是否在线查看过日志</del></h6><ul>
<li><p><strong>实时监控日志的变化</strong><br>实时监控某一个日志文件的变化：<code>tail -f xx.log</code><br>实时监控日志文件最后100行的变化：<code>tail -n 100 -f xx.log</code></p>
</li>
<li><p><strong>按照行号查询</strong><br>查询日志尾部最后100行日志：<code>tail -n 100 xx.log</code><br>查询日志头部开始100行日志：<code>head -n 100 xx.log</code><br>查询某一个日志行号区间：<code>cat -n xx.log | tail -n +100 | head -n 100</code>(查询100行至200行的日志)</p>
</li>
<li><p><strong>按照关键字找日志的信息</strong><br>查询日志文件中包含debug的日志行号：<code>cat -n xx.log | grep &quot;debug&quot;</code></p>
</li>
<li><p><strong>按照日期查询</strong><del>日期必须在日志中出现过</del></p>
<p><code>sed -n &#39;/2025-01-14 14:22:31.070/,/ 2025-01-14 14:27:18.158/p&#39; xx.log</code></p>
</li>
<li><p><strong>日志太多，处理方式</strong></p>
<ul>
<li>分页查询日志信息：<code>cat -n xx.log | grep &quot;debug&quot; | more</code></li>
<li>筛选过滤后，输出到一个文件：<code>cat -n xx.log | grep &quot;debug&quot; &gt; debug.txt</code></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9ee9064d3f9fa8ae290a4ccfe1da9af84b88e584/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4.png"></p>
<h6 id="生产问题怎么排查？本地调试远程代码"><a href="#生产问题怎么排查？本地调试远程代码" class="headerlink" title="生产问题怎么排查？本地调试远程代码"></a><span style = "color:red">生产问题怎么排查？</span><del>本地调试远程代码</del></h6><p>已经上线的bug排查的思路:</p>
<ul>
<li>先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题</li>
<li>远程debug(通常公司的正式环境(生产环境)是<strong>不允许远程debug的</strong>。一般远程debug都是公司的测试环<br>境，方便调试代码)</li>
</ul>
<p><strong>远程debug</strong></p>
<p>前提条件：<strong>远程的代码和本地的代码要保持一致</strong></p>
<p><strong>①</strong> 远程代码需要配置启动参数，把项目打包放到服务器后启动项目的参数：</p>
<p><code>java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 project-1.0-SNAPSHOT.jar</code></p>
<p><strong>②</strong> idea中设置远程debug，找到idea中的<code>Edit Configurations...</code> → 添加一个<code>Remote JVM debug</code> → 右侧要配置<code>Configuration</code>的Host → 添加上面的代码…</p>
<p><strong>③</strong> 在项目中点debug(绿色小虫子)</p>
<p><strong>④</strong> 访问远程服务器，在本地代码中打断点即可调试远程</p>
<p><span style = "color:red"><strong>怎么快速定位系统的瓶颈？</strong></span></p>
<ul>
<li>压测(性能测试)，<strong>项目上线之前测评系统的压力</strong><ul>
<li>压测目的：给出系统当前的性能状况;定位系统性能瓶颈或潜在性能瓶颈</li>
<li>指标：响应时间、QPS、并发数、吞吐量、CPU利用率、内存使用率、磁盘IO、错误率</li>
<li>压测工具：LoadRunner、Apache Jmeter …</li>
<li>后端工程师：根据压测的结果进行解决或调优(接口、代码报错、并发达不到要求.)</li>
</ul>
</li>
<li>监控工具、链路追踪工具，<strong>项目上线之后监控</strong><ul>
<li>监控工具：Prometheus+Grafana</li>
<li>链路追踪工具：skywalking、Zipkin</li>
</ul>
</li>
<li>线上诊断工具Arthas(阿尔萨斯)，<strong>项目上线之后监控、排查</strong><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></li>
<li>核心功能:Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。<br>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决:<ul>
<li>这个类从哪个jar 包加载的?为什么会报各种类相关的 Exception?</li>
<li>我改的代码为什么没有执行到?难道是我没 commit?分支搞错了?</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗?</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现!</li>
<li>是否有一个全局视角来查看系统的运行状况?</li>
<li>有什么办法可以监控到 JVM 的实时运行状态?</li>
<li>怎么快速定位应用的热点，生成火焰图?</li>
<li>怎样直接从 JVM 内查找某个类的实例?</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2025-x2F-1-x2F-14-20-35-地点广州-完结撒花"><a href="#2025-x2F-1-x2F-14-20-35-地点广州-完结撒花" class="headerlink" title="2025&#x2F;1&#x2F;14 20:35 地点广州 完结撒花"></a><span style = "color:red">2025&#x2F;1&#x2F;14 20:35 地点广州 完结撒花</span></h3>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/面试" style=color:#1bccbc>
                面试
            </a>
        </span>
        
    </div>

    <a href="/2024/10/31/面试/Java八股文专项/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/10/21/后端/SpringBoot趣味实战课/">
        <h2>
            SpringBoot趣味实战课
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/10/21
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="Swagger-Mariadb-Hibernate-实现极简CRUD"><a href="#Swagger-Mariadb-Hibernate-实现极简CRUD" class="headerlink" title="Swagger + Mariadb + Hibernate 实现极简CRUD"></a>Swagger + Mariadb + Hibernate 实现极简CRUD</h3><pre><code class="yaml">application.yaml
spring:
  application:
    name: Pluminary
  datasource:
    driver-class-name: org.mariadb.jdbc.Driver
    url: jdbc:mariadb://localhost:3306/pcy?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;nullCatalogMeansCurrent=true
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MariaDB103Dialect
  springdoc:
    api-docs:
      path: /v3/api-docs
    swagger-ui:
      path: /swagger-ui.html

  server:
    port: 8080
    servlet:
      context-path: /springboot
      session:
        timeout: 60
  debug: true
</code></pre>
<pre><code class="java">com/pcy/Swagger/SwaggerConfig.java
package com.pcy.Swagger;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;) //这里是扫描包
                .build();
    &#125;

    @Bean
    public OpenAPI customOpenAPI() &#123;
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Spring Boot 实战&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Spring Boot 实战的 RESTFul 接口文档说明&quot;)
                        .contact(new Contact()
                                .name(&quot;Pluminary&quot;)
                                .url(&quot;https://github.com/P-luminary&quot;)
                                .email(&quot;390415030@qq.com&quot;)));
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserRepository.java //【这个是持久化接口 实现CRUD】
package com.pcy.service;

import com.pcy.dao.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">com/pcy/controller/UserController.java
package com.pcy.controller;

import com.pcy.dao.User;
import com.pcy.service.UserRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/users&quot;)
@Tag(name = &quot;User Controller&quot;, description = &quot;用户相关操作&quot;)
public class UserController &#123;

    @Autowired
    private UserRepository userRepository;

    @Operation(summary = &quot;根据ID获取用户信息&quot;, description = &quot;通过用户ID获取用户详细信息&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功获取用户信息&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;未找到用户&quot;)
    &#125;)
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User get(@PathVariable int id) &#123;
        return userRepository.findById(id).orElse(null);
    &#125;

    @Operation(summary = &quot;创建用户&quot;, description = &quot;创建一个新的用户&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功创建用户&quot;),
            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;无效的输入&quot;)
    &#125;)
    @PostMapping
    public User create(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;更新用户&quot;, description = &quot;更新用户信息&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功更新用户信息&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;未找到用户&quot;)
    &#125;)
    @PutMapping
    public User update(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;删除用户&quot;, description = &quot;根据ID删除用户&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功删除用户&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;未找到用户&quot;)
    &#125;)
    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void delete(@PathVariable int id) &#123;
        userRepository.deleteById(id);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.pcy&lt;/groupId&gt;
    &lt;artifactId&gt;Pluminary&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;Pluminary&lt;/name&gt;
    &lt;description&gt;Pluminary&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.swagger.core.v3&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.2.15&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;!--        &lt;dependency&gt;--&gt;
&lt;!--            &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;
&lt;!--            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;
&lt;!--            &lt;version&gt;8.0.33&lt;/version&gt;--&gt;
&lt;!--        &lt;/dependency&gt;--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;2.7.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
            &lt;version&gt;6.1.7.Final&lt;/version&gt; &lt;!-- 选择与 Spring Boot 3.3.2 兼容的版本 --&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h3 id="增加分页、排序"><a href="#增加分页、排序" class="headerlink" title="增加分页、排序"></a>增加分页、排序</h3><pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;获取用户列表&quot;, description = &quot;获取用户列表&quot;)
    @GetMapping
    public Page&lt;User&gt; list(@RequestParam(defaultValue = &quot;id&quot;) String property,
 @RequestParam(defaultValue = &quot;ASC&quot;)Sort.Direction direction,
 @RequestParam(defaultValue = &quot;0&quot;) Integer page,
 @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123;
    Pageable pageable = PageRequest.of(page, pageSize, direction, property);
        return userRepository.findAll(pageable);
    &#125;
</code></pre>
<h3 id="根据姓名查用户"><a href="#根据姓名查用户" class="headerlink" title="根据姓名查用户"></a>根据姓名查用户</h3><pre><code class="java">com/pcy/controller/UserController.java    
    @Operation(summary = &quot;根据姓名查用户&quot;,description = &quot;根据姓名查用户&quot;)
    @GetMapping(&quot;/name&quot;)
    public List&lt;User&gt; getByName(String name)&#123;
        return userRepository.findByNameContaining(name);
    &#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserRepository.java
package com.pcy.service;

import com.pcy.dao.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;
    List&lt;User&gt; findByNameContaining(String name);
&#125;
</code></pre>
<h3 id="根据生日查用户、删除User表"><a href="#根据生日查用户、删除User表" class="headerlink" title="根据生日查用户、删除User表"></a>根据生日查用户、删除User表</h3><pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;根据生日获取用户信息①&quot;,description = &quot;根据生日获取用户信息①&quot;)
    @GetMapping(&quot;/birthdayOne&quot;)
    public List&lt;User&gt; getBirthDayOne(LocalDate birthDay)&#123;
        return userRepository.findByBirthDay(birthDay);
    &#125;

    @Operation(summary = &quot;根据生日获取用户信息②&quot;,description = &quot;根据生日获取用户信息②&quot;)
    @GetMapping(&quot;/birthdayTwo&quot;)
    public List&lt;User&gt; getBirthDayTwo(LocalDate birthDay)&#123;
        return userRepository.findByBirthDayNative(birthDay);
    &#125;

    @Operation(summary = &quot;删除User&quot;,description = &quot;删除User&quot;)
    @GetMapping(&quot;/delete&quot;)
    public void delete()&#123;
        userRepository.delete();
    &#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserRepository.java
@Query(&quot;SELECT u FROM User u WHERE u.birthday=?1&quot;)
    List&lt;User&gt; findByBirthDay(LocalDate birthDay);

    @Query(value = &quot;SELECT * FROM user WHERE birth_day =:birthDay&quot;,nativeQuery = true)
    List&lt;User&gt; findByBirthDayNative(LocalDate birthDay);

    @Modifying
    @Transactional
    @Query(value = &quot;DELETE FROM User&quot;)
    int delete();
</code></pre>
<h3 id="增加审计"><a href="#增加审计" class="headerlink" title="增加审计"></a>增加审计</h3><pre><code class="java">com/pcy/MallApplication.java //【增加@EnableJpaAuditing】
package com.pcy;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@EnableJpaAuditing
@SpringBootApplication
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/dao/BaseEntity.java //【没有必要为每个实体类都编写 直接封装导一个类 User去继承】
package com.pcy.dao;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Data;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Data
@MappedSuperclass
//该注解用于监听实体类，在save、update之后的状态
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity &#123;
    @CreatedBy
    @Column(updatable = false)
    private String creator;

    @LastModifiedBy
    private String modifier;

    @CreatedDate
    @Column(updatable = false) //不可修改的
    private LocalDateTime createTime;

    @LastModifiedDate
    private LocalDateTime updateTime;
&#125;
</code></pre>
<pre><code class="java">com/pcy/dao/User.java //【增加@EqualsAndHashCode 与 extends BaseEntity】
@Data
@Entity
@EqualsAndHashCode(callSuper = true)
//@Schema(name=&quot;用户信息&quot;)
@Table(indexes = &#123;@Index(name = &quot;uk_email&quot;,columnList = &quot;email&quot;,unique = true)&#125;)
public class User extends BaseEntity&#123;
    @Id
//    @Schema(description = &quot;用户ID&quot;)
//    @NotBlank(message = &quot;Id不能为空&quot;)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    ...
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/AuditorAwareImpl.java
package com.pcy.service.impl;

import org.springframework.data.domain.AuditorAware;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class AuditorAwareImpl implements AuditorAware&lt;String&gt; &#123;

    @Override
    public Optional&lt;String&gt; getCurrentAuditor() &#123;
        // 添加一个随机数
        return Optional.of(&quot;管理员&quot;+(int)(Math.random()));
    &#125;
&#125;
</code></pre>
<h3 id="引入Mybatis-Plus-FreeMarker"><a href="#引入Mybatis-Plus-FreeMarker" class="headerlink" title="引入Mybatis-Plus + FreeMarker"></a>引入Mybatis-Plus + FreeMarker</h3><pre><code class="xml">pom.xml
&lt;dependency&gt;
  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;3.4.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">//根据你提供的实体类BaseEntity和User，我为你设计了一个基于MyBatis-Plus 3.5.x版本的代码生成器MysqlGenerator，它将自动生成与这些实体类相关的代码，如Mapper、Service、Controller等。以下是生成器的代码示例
【仅供查看学习 实际代码爆红无法导入】
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.core.toolkit.StringPool;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.*;
import com.baomidou.mybatisplus.generator.config.builder.*;
import com.baomidou.mybatisplus.generator.config.po.TableInfo;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;
import com.baomidou.mybatisplus.generator.fill.Property;
import com.baomidou.mybatisplus.generator.keywords.MySqlKeyWordsHandler;

import java.util.Collections;

public class MysqlGenerator &#123;

    // 项目路径
    private static final String PROJECT_PATH = System.getProperty(&quot;user.dir&quot;);
    // 输出路径
    private static final String OUTPUT_DIR = PROJECT_PATH + &quot;/src/main/java&quot;;
    // 作者
    private static final String AUTHOR = &quot;YourName&quot;;
    // 包名
    private static final String BASE_PACKAGE = &quot;com.pcy&quot;;
    // 数据源配置
    private static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/your_database&quot;;
    private static final String DATABASE_USERNAME = &quot;root&quot;;
    private static final String DATABASE_PASSWORD = &quot;password&quot;;
    private static final String DATABASE_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;

    public static void main(String[] args) &#123;
        // 1. 全局配置
        GlobalConfig.Builder globalConfig = new GlobalConfig.Builder()
            .outputDir(OUTPUT_DIR)
            .author(AUTHOR)
            .enableSwagger()
            .fileOverride()
            .disableOpenDir(); // 不自动打开输出目录

        // 2. 数据源配置
        DataSourceConfig.Builder dataSourceConfig = new DataSourceConfig.Builder(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD)
            .dbQuery(new MySqlQuery())
            .schema(&quot;public&quot;)
            .dbType(DbType.MYSQL)
            .keyWordsHandler(new MySqlKeyWordsHandler())
            .driverName(DATABASE_DRIVER);

        // 3. 包配置
        PackageConfig.Builder packageConfig = new PackageConfig.Builder()
            .parent(BASE_PACKAGE)
            .entity(&quot;dao&quot;)
            .mapper(&quot;mapper&quot;)
            .service(&quot;service&quot;)
            .controller(&quot;controller&quot;);

        // 4. 策略配置
        StrategyConfig.Builder strategyConfig = new StrategyConfig.Builder()
            .addInclude(&quot;user&quot;) // 生成指定表
            .addTablePrefix(&quot;t_&quot;) // 去掉表前缀
            .entityBuilder()
                .superClass(BaseEntity.class)
                .enableLombok()
                .addSuperEntityColumns(&quot;id&quot;, &quot;creator&quot;, &quot;modifier&quot;, &quot;create_time&quot;, &quot;update_time&quot;)
                .logicDeleteColumnName(&quot;deleted&quot;)
                .addTableFills(new Property(&quot;create_time&quot;, FieldFill.INSERT))
                .addTableFills(new Property(&quot;update_time&quot;, FieldFill.INSERT_UPDATE))
                .enableActiveRecord()
                .naming(NamingStrategy.underline_to_camel)
                .columnNaming(NamingStrategy.underline_to_camel)
            .controllerBuilder()
                .enableRestStyle()
                .enableHyphenStyle()
            .serviceBuilder()
                .formatServiceFileName(&quot;%sService&quot;)
                .formatServiceImplFileName(&quot;%sServiceImpl&quot;)
            .mapperBuilder()
                .enableBaseResultMap()
                .enableBaseColumnList();

        // 5. 模板配置
        TemplateConfig.Builder templateConfig = new TemplateConfig.Builder();

        // 6. 自定义配置
        InjectionConfig.Builder injectionConfig = new InjectionConfig.Builder()
            .beforeOutputFile((tableInfo, objectMap) -&gt; objectMap.put(&quot;parent&quot;, BASE_PACKAGE));

        // 7. 整合配置
        AutoGenerator autoGenerator = new AutoGenerator(dataSourceConfig.build())
            .global(globalConfig.build())
            .packageInfo(packageConfig.build())
            .strategy(strategyConfig.build())
            .template(templateConfig.build())
            .injection(injectionConfig.build())
            .templateEngine(new FreemarkerTemplateEngine()); // 选择模板引擎

        // 8. 执行
        autoGenerator.execute();
    &#125;
&#125;
/*
关键配置说明：
GlobalConfig：设置代码生成的全局配置，包括作者、输出目录、是否覆盖已有文件等。
DataSourceConfig：配置数据库连接信息，使用MySQL数据库。
PackageConfig：指定生成的代码所在的包路径。
StrategyConfig：配置生成策略，包括实体类的继承关系、使用Lombok、Rest风格的控制器等。
TemplateConfig：模板配置，可定制生成的模板。
InjectionConfig：自定义配置，用于在生成文件前注入自定义的变量或逻辑。
AutoGenerator：整合所有配置并执行代码生成。

生成的文件包括：
实体类：根据数据库表生成实体类，并继承BaseEntity。
Mapper接口：生成Mapper接口用于数据库操作。
Service接口和实现类：生成Service接口及其实现类。
Controller类：生成Rest风格的控制器类。

使用方法：
修改数据库连接信息（DATABASE_URL、DATABASE_USERNAME、DATABASE_PASSWORD）。
配置需要生成代码的表名（addInclude(&quot;user&quot;)）。
运行MysqlGenerator.java的main方法，代码将会生成在指定的输出目录中。
*
</code></pre>
<pre><code class="java">//【以下都是自动生成的代码】
com/pcy/mapper/UserMapper.java
package com.pcy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.pcy.entity.User;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserService.java
package com.pcy.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.pcy.entity.User;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * &lt;p&gt;
 * 用户表 服务类
 * &lt;/p&gt;
 */
public interface UserService extends IService&lt;User&gt; &#123;
// 在Spring中使用事务
    @Transactional(propagation = Propagation.REQUIRED)
    void addWithRequired(User user);

    @Transactional(propagation = Propagation.REQUIRED)
    void addWithRequiredAndException(User user);

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void addWithRequiredNew(User user);

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void addWithRequiredNewAndException(User user);

    @Transactional(propagation = Propagation.NESTED)
    void addWithNested(User user);

    @Transactional(propagation = Propagation.NESTED)
    void addWithNestedAndException(User user);
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/UserServiceImpl.java
package com.pcy.service.impl;


import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.pcy.entity.User;
import com.pcy.mapper.UserMapper;
import com.pcy.service.UserService;
import com.pcy.mapper.UserMapper;
import com.pcy.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * &lt;p&gt;
 * 用户表 服务实现类
 * &lt;/p&gt;
 */
@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;

    @Autowired
    private UserMapper mapper;
    
    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void addWithRequired(User user) &#123;
        mapper.insert(user);
    &#125;

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void addWithRequiredAndException(User user) &#123;
        mapper.insert(user);
        throw new RuntimeException();
    &#125;

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void addWithRequiredNew(User user) &#123;
        mapper.insert(user);
    &#125;

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void addWithRequiredNewAndException(User user) &#123;
        mapper.insert(user);
        throw new RuntimeException();
    &#125;

    @Override
    @Transactional(propagation = Propagation.NESTED)
    public void addWithNested(User user) &#123;
        mapper.insert(user);
    &#125;

    @Override
    @Transactional(propagation = Propagation.NESTED)
    public void addWithNestedAndException(User user) &#123;
        mapper.insert(user);
        throw new RuntimeException();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">resources/mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.pcy.mapper.UserMapper&quot;&gt;

    &lt;!-- 通用查询映射结果 --&gt;
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.pcy.entity.User&quot;&gt;
    &lt;result column=&quot;id&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;creator&quot; property=&quot;creator&quot; /&gt;
    &lt;result column=&quot;modifier&quot; property=&quot;modifier&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; /&gt;
    &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot; /&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
        &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;
        &lt;result column=&quot;birth_day&quot; property=&quot;birthDay&quot; /&gt;
    &lt;/resultMap&gt;

    &lt;!-- 通用查询结果列 --&gt;
    &lt;sql id=&quot;Base_Column_List&quot;&gt;
        id,
        creator,
        modifier,
        create_time,
        update_time,
        name, email, birth_day
    &lt;/sql&gt;

&lt;/mapper&gt;
</code></pre>
<pre><code class="java">//【提问：爆bug  &quot;Could not autowire. No beans of &#39;UserMapper&#39; type found&quot;】 深度解析
1. @MapperScan 注解的原理 //启动类里面的 @MapperScan(&quot;com.pcy.mapper&quot;)
@MapperScan 是 MyBatis-Spring 提供的一个注解，用于指定要扫描的 Mapper 接口所在的包路径。它的作用是告诉 Spring 框架应该在哪些包路径下寻找 Mapper 接口，并将它们注册为 Spring 的 Bean。
扫描 Mapper 接口：Spring Boot 在启动时，会扫描你指定的包路径下的所有接口，并检测这些接口是否包含 MyBatis 的 Mapper 注解或者继承了 BaseMapper 等相关接口。
注册为 Bean：一旦找到这些接口，Spring 会自动为这些接口生成一个实现类，并将它们注册为 Spring 容器中的 Bean，这样你就可以通过 @Autowired 注入这些 Mapper。

2. @Mapper 注解的原理
@Mapper 是 MyBatis 提供的一个注解，用于标记一个接口为 MyBatis 的 Mapper 接口。被标记为 @Mapper 的接口会被 MyBatis-Spring 扫描到，并且 MyBatis 会为该接口生成一个实现类，负责执行 SQL 语句。
当你在 UserMapper 接口上添加 @Mapper 注解时，即使没有使用 @MapperScan，MyBatis 也会知道这个接口是一个 Mapper 接口，并将其注册为一个 Bean。这使得你可以在 UserServiceImpl 中通过 @Autowired 注入它。

3. 为什么使用 @MapperScan 和 @Mapper 不会报错
自动注册 Bean：@MapperScan 会自动扫描指定包路径下的所有 Mapper 接口，并将它们注册为 Spring 容器中的 Bean。这意味着在 UserServiceImpl 中，当你使用 @Autowired 注入 UserMapper 时，Spring 可以找到对应的 Bean，从而避免 Could not autowire 错误。
手动注册 Bean：当你在 Mapper 接口上直接使用 @Mapper 注解时，Spring 也会将该接口注册为一个 Bean，这样你同样可以通过 @Autowired 进行注入，而不会出现 Bean 找不到的问题。
</code></pre>
<pre><code class="java">//【提问：MysqlGenerator 逆向生成那些包的原理】
MyBatis-Plus 提供的 MyBatis-Plus Generator 是一个非常强大的代码生成工具，可以通过数据库表结构生成对应的 Java 代码，包括实体类、Mapper 接口、Mapper XML 文件、Service 类、Controller 类等。这个过程通常被称为“逆向工程”或“代码生成”。
1. MyBatis-Plus Generator 的工作原理
 1.1 读取数据库表结构
数据源配置：首先，MyBatis-Plus Generator 通过配置的数据源连接到指定的数据库。它会读取数据库中的表结构信息，包括表名、字段名、数据类型、主键、外键、索引等信息。
&gt; DataSourceConfig dsc = new DataSourceConfig.Builder(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD)
    .driverName(DATABASE_DRIVER)
    .build();

元数据解析：MyBatis-Plus Generator 通过 JDBC 获取数据库的元数据 (Metadata)，并解析每个表的结构，将其转换为可以用于代码生成的数据结构。

 1.2 生成代码
代码生成器：AutoGenerator 是核心的代码生成器类。它根据从数据库中获取的表结构信息，生成相应的 Java 类文件。
&gt; AutoGenerator generator = new AutoGenerator(dsc);

模板引擎：MyBatis-Plus Generator 使用模板引擎（例如 Freemarker）来渲染代码模板。通过模板和解析后的元数据，生成代码文件。每个生成的 Java 类文件都对应着一个模板文件，模板文件中包含了如何生成特定类型文件的逻辑。
&gt; generator.templateEngine(new FreemarkerTemplateEngine());

 1.3 生成的包和文件
实体类 (entity)：根据表结构生成对应的 Java 实体类。每个实体类与数据库表一一对应，包含表中字段的定义。
&gt; strategyConfig.entityBuilder().enableLombok().naming(NamingStrategy.underline_to_camel);

Mapper 接口 (mapper)：生成的 Mapper 接口用于与数据库交互，执行基本的增删改查操作。Mapper 接口通常继承自 BaseMapper，提供基本的 CRUD 操作。
&gt; strategyConfig.mapperBuilder().enableBaseResultMap().enableBaseColumnList();
Mapper XML 文件 (mapper.xml)：生成的 Mapper XML 文件包含了 Mapper 接口中对应的方法的 SQL 语句。这些 XML 文件用于定义复杂的查询、更新语句等。

Service 接口和实现类 (service, service.impl)：Service 层是业务逻辑层。生成的 Service 接口提供了业务操作的定义，Service 实现类则实现这些业务操作。
&gt; strategyConfig.serviceBuilder().formatServiceFileName(&quot;%sService&quot;);

Controller 类 (controller)：生成的 Controller 类用于处理 HTTP 请求，调用 Service 层的方法进行业务处理，然后返回结果。Controller 通常与前端交互，处理用户请求。
&gt; strategyConfig.controllerBuilder().enableRestStyle().enableHyphenStyle();


2. MyBatis-Plus Generator 如何生成这些包和文件
 2.1 代码生成策略 (StrategyConfig)
StrategyConfig 类用于配置代码生成的策略，如生成哪些表，生成哪些类，类的命名规则，是否使用 Lombok 等。
StrategyConfig strategyConfig = new StrategyConfig.Builder()
    .addInclude(&quot;user&quot;) // 生成指定表
    .entityBuilder().enableLombok() // 实体类配置
    .mapperBuilder().enableBaseResultMap() // Mapper 配置
    .serviceBuilder().formatServiceFileName(&quot;%sService&quot;) // Service 配置
    .controllerBuilder().enableRestStyle() // Controller 配置
    .build();

 2.2 模板文件
MyBatis-Plus Generator 使用的模板文件可以自定义，通常位于 resources/templates 目录下。每个模板文件对应一个需要生成的 Java 文件类型，例如 entity.java.ftl 对应实体类，mapper.java.ftl 对应 Mapper 接口。
     
模板文件中可以使用变量和逻辑来决定生成的代码内容。例如，$&#123;className&#125; 会被替换为实际的类名，&lt;#if useLombok&gt; @Data &lt;/#if&gt; 会根据条件生成代码。
     
 2.3 文件输出配置 (InjectionConfig 和 FileOutConfig)
通过 InjectionConfig 和 FileOutConfig，可以控制生成文件的路径、名称、以及自定义生成的文件内容。例如，可以指定某个表的实体类生成到特定的包下，或者将 XML 文件输出到特定的路径。
InjectionConfig cfg = new InjectionConfig.Builder()
    .beforeOutputFile((tableInfo, objectMap) -&gt; &#123;
        // 自定义处理逻辑
    &#125;)
    .build();
</code></pre>
<h3 id="用MyBatis-Plus的分页"><a href="#用MyBatis-Plus的分页" class="headerlink" title="用MyBatis Plus的分页"></a>用MyBatis Plus的分页</h3><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.pcy&lt;/groupId&gt;
    &lt;artifactId&gt;Pluminary&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;Pluminary&lt;/name&gt;
    &lt;description&gt;Pluminary&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.swagger.core.v3&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.2.15&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;!--        &lt;dependency&gt;--&gt;
&lt;!--            &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;
&lt;!--            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;
&lt;!--            &lt;version&gt;8.0.33&lt;/version&gt;--&gt;
&lt;!--        &lt;/dependency&gt;--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
            &lt;version&gt;6.1.7.Final&lt;/version&gt; &lt;!-- 选择与 Spring Boot 3.3.2 兼容的版本 --&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.5&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
                    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
            &lt;version&gt;3.5.5&lt;/version&gt; &lt;!-- 版本对齐 --&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">//【添加MyBatis-Plus的分页插件】
com/pcy/utils/MyBatisPlusConfig.java
package com.pcy.utils;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
//@Configuration 用于定义配置类，被注解的类内部包含有一个或多个被@Bean注解的方法
// 用于构建bean定义，初始化Spring容器
@Configuration
public class MyBatisPlusConfig &#123;
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MARIADB));
        return interceptor;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/controller/UserController.java //【增加listPage】
package com.pcy.controller;

import com.pcy.entity.User;
import com.pcy.service.UserRepository;
import com.pcy.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping(&quot;/users&quot;)
@Tag(name = &quot;User Controller&quot;, description = &quot;用户相关操作&quot;)
public class UserController &#123;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserService userService;

    @Operation(summary = &quot;根据ID获取用户信息&quot;, description = &quot;通过用户ID获取用户详细信息&quot;)
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User get(@PathVariable int id) &#123;
        return userRepository.findById(id).orElse(null);
    &#125;

    @Operation(summary = &quot;创建用户&quot;, description = &quot;创建一个新的用户&quot;)
    @PostMapping
    public User create(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;更新用户&quot;, description = &quot;更新用户信息&quot;)
    @PutMapping
    public User update(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;删除用户&quot;, description = &quot;根据ID删除用户&quot;)
    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void delete(@PathVariable int id) &#123;
        userRepository.deleteById(id);
    &#125;

    @Operation(summary = &quot;获取用户列表&quot;, description = &quot;获取用户列表&quot;)
    @GetMapping(&quot;/list&quot;)
    public org.springframework.data.domain.Page&lt;User&gt; list(@RequestParam(defaultValue = &quot;id&quot;) String property,
                                                           @RequestParam(defaultValue = &quot;ASC&quot;) Sort.Direction direction,
                                                           @RequestParam(defaultValue = &quot;0&quot;) Integer page,
                                                           @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123;
        Pageable pageable = PageRequest.of(page, pageSize, direction, property);
        return userRepository.findAll(pageable);
    &#125;

    @Operation(summary = &quot;根据生日获取用户信息①&quot;, description = &quot;根据生日获取用户信息①&quot;)
    @GetMapping(&quot;/birthdayOne&quot;)
    public List&lt;User&gt; getBirthDayOne(@RequestParam LocalDate birthDay) &#123;
        return userRepository.findByBirthDay(birthDay);
    &#125;

    @Operation(summary = &quot;根据生日获取用户信息②&quot;, description = &quot;根据生日获取用户信息②&quot;)
    @GetMapping(&quot;/birthdayTwo&quot;)
    public List&lt;User&gt; getBirthDayTwo(@RequestParam LocalDate birthDay) &#123;
        return userRepository.findByBirthDayNative(birthDay);
    &#125;

    @Operation(summary = &quot;删除所有用户&quot;, description = &quot;删除所有用户&quot;)
    @DeleteMapping(&quot;/deleteAll&quot;)
    public void deleteAll() &#123;
        userRepository.deleteAll();
    &#125;

    @Operation(summary = &quot;分页查询用户列表&quot;, description = &quot;分页查询用户列表&quot;)
    @GetMapping(&quot;/page&quot;)
    public Page&lt;User&gt; listPage(@RequestParam(defaultValue = &quot;1&quot;) Integer page,
                               @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123;
        return userService.page(new Page&lt;&gt;(page, pageSize));
    &#125;
&#125;
</code></pre>
<h3 id="高级SQL语句-Lambda"><a href="#高级SQL语句-Lambda" class="headerlink" title="高级SQL语句(Lambda)"></a>高级SQL语句(Lambda)</h3><pre><code class="java">wrapper.lambda().like(user -&gt; user.getName(), &quot;p&quot;);
/*
Lambda 表达式:

user -&gt; user.getName() 是一个 Lambda 表达式。
user 是 User 类的一个实例，作为 Lambda 表达式的输入参数。
user.getName() 是对 user 对象的 getName() 方法的调用，返回 name 字段的值。
作用:

这行代码告诉 MyBatis-Plus：在生成的 SQL 查询中，查找 name 字段值中包含 &quot;p&quot; 的所有记录。
wrapper.lambda() 返回一个 LambdaQueryWrapper&lt;User&gt; 对象，支持使用 Lambda 表达式进行条件构建。
.like() 方法添加了一个 LIKE 条件，表示在 SQL 查询中进行模糊匹配。
*/


wrapper.lambda().like(User::getName, &quot;p&quot;);
/*
方法引用:

User::getName 是一种方法引用，它引用了 User 类的 getName() 方法。
方法引用是对 Lambda 表达式的一种简写。它表示将某个方法作为函数式接口的实现。
作用:

这行代码与第一行代码的作用相同，都是在生成的 SQL 查询中查找 name 字段值中包含 &quot;p&quot; 的所有记录。
User::getName 告诉 MyBatis-Plus：使用 User 类中的 getName() 方法来获取要参与条件判断的字段。
*/
</code></pre>
<pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;自定义查询&quot;, description = &quot;自定义查询&quot;)
    @GetMapping(&quot;/Dingyi&quot;)
    public List&lt;User&gt; getWrapper() &#123; //类型List&lt;User&gt; 可以返回数据库列表
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
//        wrapper.eq(&quot;name&quot;, &quot;潘春尧&quot;);
//        wrapper.lambda().ge(User::getBirthDay, LocalDate.parse(&quot;2011-01-01&quot;));
//        wrapper.between(User::getBirthDay, &quot;2011-01-01&quot;, &quot;2011-12-31&quot;);
        wrapper.lambda().like(User::getName, &quot;string&quot;);

//      wrapper.lambda().like(user -&gt; user.getName(), &quot;p&quot;);
//        wrapper.select(&quot;name,count(*)&quot;).groupBy(&quot;name&quot;);
//        return (QueryWrapper&lt;User&gt;) userMapper.selectList(wrapper);
//        wrapper.in(CollectionUtils.isNotEmpty(nameList), User::getName, nameList);
        return userMapper.selectList(wrapper);
    &#125;
</code></pre>
<h3 id="自动填充、填充实现策略"><a href="#自动填充、填充实现策略" class="headerlink" title="自动填充、填充实现策略"></a>自动填充、填充实现策略</h3><pre><code class="java">com/pcy/utils/MyMetaObjectHandler.java
package com.pcy.utils;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;

import java.time.LocalDateTime;

public class MyMetaObjectHandler implements MetaObjectHandler &#123;
    @Override
    public void insertFill(MetaObject metaObject) &#123;
        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime::now, LocalDateTime.class);
        this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime::now, LocalDateTime.class);
        this.strictInsertFill(metaObject, &quot;creator&quot;, this::getCurrentUser, String.class);
        this.strictInsertFill(metaObject, &quot;modifier&quot;, this::getCurrentUser, String.class);
    &#125;

    @Override
    public void updateFill(MetaObject metaObject) &#123;
        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime::now, LocalDateTime.class);
        this.strictUpdateFill(metaObject, &quot;modifier&quot;, this::getCurrentUser, String.class);
    &#125;
    
    // 模拟获取当前用户
    private String getCurrentUser()&#123;
        return &quot;管理员&quot; + (int) (Math.random() * 10);
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 这是自动填充的原理
default MetaObjectHandler strictFillStrategy(MetaObject metaObject, String fieldName, Supplier&lt;?&gt; fieldVal) &#123;
        if (metaObject.getValue(fieldName) == null) &#123;
            Object obj = fieldVal.get();
            if (Objects.nonNull(obj)) &#123;
                metaObject.setValue(fieldName, obj);
            &#125;
        &#125;
        return this;
    &#125;
</code></pre>
<h3 id="强大的Druid"><a href="#强大的Druid" class="headerlink" title="强大的Druid"></a>强大的Druid</h3><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.5&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">// Druid和MariaDB是两种不同类型的数据库系统
1、类型和用途：
Druid：Druid是一种分布式的实时分析数据库，主要用于处理高吞吐量的时间序列数据或事件数据。它专为快速查询和分析大规模数据而设计，常用于数据仓库、在线分析处理（OLAP）以及实时数据分析等场景。
MariaDB：MariaDB是一种关系型数据库管理系统（RDBMS），它是MySQL的一个分支，广泛用于常规的事务处理、数据存储和管理。MariaDB通常用于传统的OLTP（在线事务处理）场景，如web应用、内容管理系统等。

2、适用场景：
Druid：适合用于实时数据分析、日志分析、时间序列分析、用户行为分析等需要快速响应的场景。
MariaDB：适合传统的数据库应用，如电子商务系统、内容管理系统、ERP、CRM等需要强事务处理能力的场景。
    
总结来说，Druid和MariaDB各自适用于不同的数据处理需求，Druid更侧重于实时分析和大规模数据处理，而MariaDB更侧重于事务处理和关系型数据管理
</code></pre>
<h3 id="Spring-Data-JPA与MyBatis-Plus的区别并且简单举例说明"><a href="#Spring-Data-JPA与MyBatis-Plus的区别并且简单举例说明" class="headerlink" title="Spring Data JPA与MyBatis-Plus的区别并且简单举例说明"></a>Spring Data JPA与MyBatis-Plus的区别并且简单举例说明</h3><pre><code class="java">Spring Data JPA: //【实现接口】

@Entity
public class User &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    // Other fields, getters, and setters
&#125;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;
    List&lt;User&gt; findByName(String name);
&#125;
</code></pre>
<pre><code class="java">Spring Data JPA: //【实现控制类】
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/jpa/users&quot;)
public class UserJpaController &#123;

    @Autowired
    private UserRepository userRepository;

    @GetMapping
    public List&lt;User&gt; getAllUsers() &#123;
        return userRepository.findAll();
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User getUserById(@PathVariable Long id) &#123;
        return userRepository.findById(id)
                             .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));
    &#125;

    @PostMapping
    public User createUser(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;
    @PutMapping(&quot;/&#123;id&#125;&quot;)
    public User updateUser(@PathVariable Long id, @RequestBody User userDetails) &#123;
        User user = userRepository.findById(id)
                                  .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));

        user.setName(userDetails.getName());
        // Update other fields here
        return userRepository.save(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void deleteUser(@PathVariable Long id) &#123;
        User user = userRepository.findById(id)
                                  .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));

        userRepository.delete(user);
    &#125;

    @GetMapping(&quot;/search&quot;)
    public List&lt;User&gt; searchUsersByName(@RequestParam String name) &#123;
        return userRepository.findByName(name);
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<pre><code class="java">MyBatis Plus: //【实现接口】

@TableName(&quot;user&quot;)
public class User &#123;
    private Long id;
    private String name;
    // Other fields, getters, and setters
&#125;

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
    // Custom SQL
    @Select(&quot;SELECT * FROM user WHERE name = #&#123;name&#125;&quot;)
    List&lt;User&gt; selectByName(@Param(&quot;name&quot;) String name);
&#125;
</code></pre>
<pre><code class="java">MyBatis-Plus: //【实现控制类】
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/mybatis/users&quot;)
public class UserMyBatisController &#123;

    @Autowired
    private UserMapper userMapper;

    @GetMapping
    public List&lt;User&gt; getAllUsers() &#123;
        return userMapper.selectList(null);
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User getUserById(@PathVariable Long id) &#123;
        return userMapper.selectById(id);
    &#125;

    @PostMapping
    public void createUser(@RequestBody User user) &#123;
        userMapper.insert(user);
    &#125;

    @PutMapping(&quot;/&#123;id&#125;&quot;)
    public void updateUser(@PathVariable Long id, @RequestBody User userDetails) &#123;
        User user = userMapper.selectById(id);
        if (user == null) &#123;
            throw new ResourceNotFoundException(&quot;User not found with id: &quot; + id);
        &#125;

        user.setName(userDetails.getName());
        // Update other fields here
        userMapper.updateById(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void deleteUser(@PathVariable Long id) &#123;
        User user = userMapper.selectById(id);
        if (user == null) &#123;
            throw new ResourceNotFoundException(&quot;User not found with id: &quot; + id);
        &#125;

        userMapper.deleteById(id);
    &#125;

    @GetMapping(&quot;/search&quot;)
    public List&lt;User&gt; searchUsersByName(@RequestParam String name) &#123;
        return userMapper.selectByName(name);
    &#125;
&#125;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 构建查询条件的包装类，它使用 Lambda 表达式避免了手写字符串可能导致的字段错误。
// 这种方式非常适合需要根据多个条件动态生成SQL查询的场景，使用LambdaQueryWrapper不仅能提高代码的可读性，还能减少由于硬编码字符串导致的错误。
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/mybatis/users&quot;)
public class UserMyBatisController &#123;

    @Autowired
    private UserMapper userMapper;

    @GetMapping(&quot;/search&quot;)
    public List&lt;User&gt; searchUsersByName(@RequestParam String name) &#123;
        // 使用 LambdaQueryWrapper 构建模糊查询条件
        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.like(User::getName, name); // 类似于 SQL 中的 &quot;WHERE name LIKE &#39;%name%&#39;&quot;

        // 执行查询并返回结果
        return userMapper.selectList(queryWrapper);
    &#125;
    // 其他CRUD方法与前面的示例相同
&#125;
</code></pre>
<h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><h6 id="经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。"><a href="#经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。" class="headerlink" title="经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。"></a>经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。</h6><pre><code class="xml">pom.xml
          &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/pcy/service/impl/UserServiceImpl.java
@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;
    private static final Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);
    @Autowired
    private UserMapper mapper;

    public User getById(int id) &#123;
        logger.info(&quot;id为：&quot;,id);
        return mapper.selectById(id);
    &#125;
......
&#125;
</code></pre>
<h6 id="这是测试Service"><a href="#这是测试Service" class="headerlink" title="这是测试Service"></a>这是测试Service</h6><pre><code class="java">test/java  com/pcy/service/impl/UserServiceImplTest.java //【用Mock改造 + log4j】
// 检查 UserServiceImpl 是否在测试中被 @MockBean 或其他方式替换为Mock对象。如果使用了Mock对象，测试时不会真正访问数据库，而是使用模拟数据。
package com.pcy.service.impl;

import com.pcy.entity.User;
import com.pcy.mapper.UserMapper;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class UserServiceImplTest &#123;
    @InjectMocks
    UserServiceImpl userService;

    @Mock
    UserMapper userMapper;

    @Test
    @DisplayName(&quot;Test Service getById&quot;)
    void getById() &#123;
        // 模拟userMapper的selectById方法返回一个User对象
        User mockUser = new User().setId(1).setName(&quot;qwe&quot;).setEmail(&quot;1234@qq.com&quot;);
        Mockito.when(userMapper.selectById(1)).thenReturn(mockUser);

        // 调用userService的getById方法，并验证返回结果
        User user = userService.getById(1);

        System.out.println(user);
        Assertions.assertEquals(&quot;qwe&quot;, user.getName());
    &#125;
&#125;
=====================================================================
Java HotSpot(TM) 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended
2024-08-12T21:18:07.805+08:00  INFO 31512 --- [Pluminary] [           main] com.pcy.service.impl.UserServiceImpl     : id为：
User(id=1, name=qwe, age=0, email=1234@qq.com, birthDay=null)
</code></pre>
<pre><code class="java">com/pcy/entity/User.java
//你的 User 类同时使用了 Lombok 注解 (@Data, @Accessors(chain = true)) 和手动定义的 getter/setter 方法。由于 Lombok 已经生成了这些方法，手动定义的 getter/setter 方法会覆盖 Lombok 自动生成的方法，这可能导致链式调用的 setEmail 和其他类似方法无法正确解析。
package com.pcy.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

import java.time.LocalDate;

@Data
@Entity
@EqualsAndHashCode(callSuper = true)
//@Schema(name=&quot;用户信息&quot;)
@Table(indexes = &#123;@Index(name = &quot;uk_email&quot;,columnList = &quot;email&quot;,unique = true)&#125;)
@Accessors(chain = true) // 允许链式调用
public class User extends BaseEntity&#123;
    @Id
//    @Schema(description = &quot;用户ID&quot;)
//    @NotBlank(message = &quot;Id不能为空&quot;)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

//    @Schema(description = &quot;用字&quot;)
//    @NotBlank(message = &quot;名字不能为空&quot;)
    @Column(nullable = false, columnDefinition = &quot;varchar(20) comment &#39;姓名&#39;&quot;)
    private String name;

//    @Transient //注解修饰
//    @Schema(description = &quot;年龄&quot;)
//    @Min(value = 1, message = &quot;年龄不能小于1&quot;)
    private int age;

//    @Schema(description = &quot;邮箱&quot;)
//    @Email(message = &quot;E-mail格式不正确&quot;)
    @Column(nullable = false, length = 50)
    private String email;

//    @Schema(description = &quot;生日&quot;)
//    @Past(message = &quot;生日必须为过去的时间&quot;)
    private LocalDate birthDay;
&#125;
</code></pre>
<h6 id="这是测试Controller"><a href="#这是测试Controller" class="headerlink" title="这是测试Controller"></a>这是测试Controller</h6><pre><code class="java">test/java  com/pcy/controller/UserControllerTest.java
// Controller层的单元测试需要用到一个特定的类——MockMvc 专门为SpringMVC提供支持的
package com.pcy.controller;

import com.pcy.entity.User;
import com.pcy.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.annotation.Before;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.BDDMockito;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import static org.junit.jupiter.api.Assertions.*;
@Slf4j
@SpringBootTest
class UserControllerTest &#123;
    MockMvc mockMvc;

    @Mock
    UserService userService;

    @InjectMocks
    UserController userController;

    @BeforeEach
    void setUp()&#123;
        mockMvc = MockMvcBuilders.standaloneSetup(userController).build();
    &#125;

    @Test
    @DisplayName(&quot;Test Controller get&quot;)
    void get() throws Exception &#123;
        Mockito.when(userService.getById(1)).thenReturn(new User().setName(&quot;刘水镜&quot;).setEmail(&quot;liushuijing@mail.com&quot;));
        BDDMockito.given(userService.getById(1)).willReturn(new User().setName(&quot;刘水镜&quot;).setEmail(&quot;liushuijing@mail.com&quot;));
        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/&#123;id&#125;&quot;, 1)
                        .accept(&quot;application/json;charset=UTF-8&quot;)
                        .contentType(&quot;application/json;charset=UTF-8&quot;))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.name&quot;).value(&quot;刘水镜&quot;))
                .andDo(MockMvcResultHandlers.print())
                .andReturn();
        log.info(&quot;Test Controller get&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><pre><code class="java">/*
一、@RestControllerAdvice 注解的作用
@RestControllerAdvice 是 Spring Framework 为我们提供的一个复合注解，它是 @ControllerAdvice 和 @ResponseBody 的结合体。

@ControllerAdvice：该注解标志着一个类可以为所有的 @RequestMapping 处理方法提供通用的异常处理和数据绑定等增强功能。当应用到一个类上时，该类中定义的方法将在所有控制器类的请求处理链中生效。

@ResponseBody：表示方法的返回值将被直接写入 HTTP 响应体中，通常配合 Jackson 或 Gson 等 JSON 库将对象转换为 JSON 格式的响应。

因此，@RestControllerAdvice 就是专门为 RESTful 控制器设计的全局异常处理器，它的方法返回值将自动转换为响应体。
*/
</code></pre>
<h6 id="“全球”异常"><a href="#“全球”异常" class="headerlink" title="“全球”异常"></a>“全球”异常</h6><pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;异常查询&quot;, description = &quot;异常查询&quot;)
    @GetMapping(value = &quot;/&#123;id&#125;&quot;)
    public Result&lt;User&gt; get(@PathVariable Integer id) &#123;
        User user = userService.getById(id);
        if (user == null)&#123;
            throw new RuntimeException(&quot;找不到id信息&quot; + id);
        &#125;
        return Result.success(userService.getById(id));
    &#125;
/*
当输入id信息错误的时候
&#123;
  &quot;code&quot;: 200,
  &quot;message&quot;: &quot;操作成功&quot;,
  &quot;data&quot;: &#123;
    &quot;creator&quot;: null,
    &quot;modifier&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null,
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;潘春尧&quot;,
    &quot;age&quot;: 1,
    &quot;email&quot;: &quot;390@qq.com&quot;,
    &quot;birthDay&quot;: &quot;2024-08-10&quot;
  &#125;
&#125;


当输入id信息错误的时候
&#123;
  &quot;code&quot;: 500,
  &quot;message&quot;: &quot;找不到id信息3323&quot;,
  &quot;data&quot;: null
&#125;
*/
</code></pre>
<pre><code class="java">com/pcy/utils/GlobalExceptionHandler.java
package com.pcy.utils;

import com.pcy.entity.MessageEnum;
import com.pcy.entity.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler &#123;
//@ExceptionHandler注解用于在Spring MVC控制器中处理特定类型的异常。它可以应用于方法上
//当控制器方法抛出指定类型的异常时，@ExceptionHandler注解的方法将被调用来处理该异常
    @ExceptionHandler(Exception.class)
    public Result&lt;Boolean&gt; globalException(Exception e)&#123;
        Result&lt;Boolean&gt; result = new Result&lt;&gt;();
        result.setCode(MessageEnum.ERROR.getCode());
        result.setMessage(e.getMessage() == null ? MessageEnum.ERROR.getMessage() : e.getMessage());
        log.error(e.getMessage(), e);
        return result;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/entity/MessageEnum.java
package com.pcy.entity;

import lombok.Getter;

@Getter
public enum MessageEnum &#123;
    SUCCESS(200, &quot;操作成功&quot;),
    ERROR(500, &quot;操作失败&quot;);

    private final Integer code;
    private final String message;
    MessageEnum(Integer code, String message)&#123;
        this.code = code;
        this.message = message;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/entity/Result.java
package com.pcy.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result&lt;T&gt; &#123;
   private Integer code;
   private String message;
   private T data;
   // 用于生成一个没有具体数据内容的成功响应
   public static &lt;T&gt; Result&lt;T&gt; success()&#123;
       return success(null);
   &#125;
   // 用于生成包含数据的成功响应
    public static &lt;T&gt; Result&lt;T&gt; success(T data)&#123;
        return new Result&lt;&gt;(MessageEnum.SUCCESS.getCode(), MessageEnum.SUCCESS.getMessage(), data);
    &#125;
    // 用于生成一个没有具体错误信息的默认错误响应
    public static&lt;T&gt; Result&lt;T&gt; error()&#123;
        return error(MessageEnum.ERROR);
    &#125;
    // 用于生成带有特定错误信息的错误响应，MessageEnum 是一个枚举类型，包含了不同的错误信息和代码。
    public static&lt;T&gt; Result&lt;T&gt; error(MessageEnum messageEnum)&#123;
        return new Result&lt;&gt;(messageEnum.ERROR.getCode(), messageEnum.getMessage(), null);
    &#125;
    // 用于生成包含自定义错误信息的错误响应
    public static &lt;T&gt; Result&lt;T&gt; error(String message) &#123;
        return error(message, MessageEnum.ERROR.getCode());
    &#125;
    // 用于生成包含自定义错误信息和自定义状态码的错误响应
    protected static &lt;T&gt; Result&lt;T&gt; error(String message, Integer code) &#123;
        return new Result&lt;&gt;(code, message, null);
    &#125;
&#125;
</code></pre>
<h6 id="写个小异常"><a href="#写个小异常" class="headerlink" title="写个小异常"></a>写个小异常</h6><pre><code class="java">com/pcy/controller/ExceptionController.java
package com.pcy.controller;

import com.pcy.entity.Result;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/exception&quot;)
@Tag(name = &quot;Exception&quot;, description = &quot;异常操作&quot;)
public class ExceptionController &#123;
    @GetMapping(&quot;/runtimeexception&quot;)
    public Result&lt;Boolean&gt; runtimeException()&#123;
        throw new RuntimeException();
    &#125;
&#125;
/*
开启全局异常处理的返回值
&#123;
  &quot;code&quot;: 500,
  &quot;message&quot;: &quot;操作失败&quot;,
  &quot;data&quot;: null
&#125;

没有全局异常处理的错误返回值
&#123;
  &quot;timestamp&quot;: &quot;2024-08-13T08:21:43.192+00:00&quot;,
  &quot;status&quot;: 500,
  &quot;error&quot;: &quot;Internal Server Error&quot;,
  &quot;path&quot;: &quot;/exception/runtimeexception&quot;
&#125;
*/
</code></pre>
<pre><code class="java">//在SwaggerConfig中添加扫描路径 &quot;/exception/**&quot;  不然接口无法获取
package com.pcy.Swagger;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
// http://localhost:8080/swagger-ui/index.html
@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;, &quot;/exception/**&quot;)
                // .addPathsToMatch(&quot;/exception/**&quot;)
                .build();
    &#125;

    @Bean
    public OpenAPI customOpenAPI() &#123;
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Spring Boot 实战&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Spring Boot 实战的 RESTFul 接口文档说明&quot;)
                        .contact(new Contact()
                                .name(&quot;Pluminary&quot;)
                                .url(&quot;https://github.com/P-luminary&quot;)
                                .email(&quot;390415030@qq.com&quot;)));
    &#125;
&#125;
</code></pre>
<pre><code class="java">你提到的 GlobalExceptionHandler 和 ExceptionController 是用于统一处理 Spring MVC 控制器中的异常。让我逐步分析它们的作用，以及为什么在某些情况下它返回错误值。

//1. GlobalExceptionHandler 的作用
@RestControllerAdvice：这个注解用来全局处理控制器层的异常。它会拦截所有抛出的异常，并根据异常类型调用相应的 @ExceptionHandler 方法。

@ExceptionHandler(Exception.class)：这个注解标注的方法会在控制器抛出 Exception 或其子类时执行。它用来捕获并处理全局的异常，比如你代码中的 RuntimeException。

globalException(Exception e)：这是一个全局异常处理方法。当控制器中出现 Exception 时，这个方法会被调用。它将返回一个带有错误状态码的 Result&lt;Boolean&gt; 对象，并且会将错误信息记录到日志中。

//2. ExceptionController 的作用
@RestController：声明这个类是一个 Spring MVC 控制器，处理 Web 请求并返回数据。

runtimeException() 方法：在这个方法中，你手动抛出了一个 RuntimeException，这会触发 GlobalExceptionHandler 中的 globalException 方法，并返回一个包含错误信息的 Result&lt;Boolean&gt; 对象。

//3. 为什么只有引用 runtimeException() 才返回错误值
runtimeException() 方法直接抛出了一个 RuntimeException，因此会被 GlobalExceptionHandler 捕获并处理。这就是为什么在访问 /exception/runtimeexception 时，你会看到返回的是错误信息。

//4. 在 get() 方法中返回 200 状态码的原因
在 get() 方法中，如果你传入的 id 是无效的，返回的 Result&lt;User&gt; 仍然会是 Result.success(userService.getById(id))，即使 userService.getById(id) 返回的是 null。这种情况下，你的 Result.success(null) 仍然会返回状态码 200，因为 Result.success() 的设计是用于表示成功状态的，且你没有抛出任何异常。

//5. 如何让 get() 方法在出错时返回错误信息
你可以通过以下方法来确保在 get() 方法中传入无效的 id 时，抛出异常并触发全局异常处理器：

手动抛出异常：

java
复制代码
@GetMapping(value = &quot;/&#123;id&#125;&quot;)
public Result&lt;User&gt; get(@PathVariable Integer id) &#123;
    User user = userService.getById(id);
    if (user == null) &#123;
        throw new RuntimeException(&quot;User not found with id: &quot; + id);
    &#125;
    return Result.success(user);
&#125;
在 userService.getById(id) 方法中抛出异常：如果你的业务逻辑要求在找不到用户时抛出异常，那么可以在 userService.getById(id) 方法中实现这个逻辑。

//6. 总结
GlobalExceptionHandler 用于捕获和处理全局异常。
当你手动抛出 RuntimeException 或其他异常时，它会捕获并返回带有错误信息的 Result。
在 get() 方法中，如果你想要在找不到用户时返回错误信息，需要手动抛出异常，这样才能触发 GlobalExceptionHandler。
</code></pre>
<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><h6 id="方法一：直接编写使用"><a href="#方法一：直接编写使用" class="headerlink" title="方法一：直接编写使用"></a>方法一：直接编写使用</h6><pre><code class="java">// [配置方法：一种是直接在application.yml文件中配置、另一种是在外置logback-spring.xml文件中配置]
logging:
  pattern:
    console: &quot;%d - %m%n&quot;
</code></pre>
<h6 id="方法二：引用外置xml文件"><a href="#方法二：引用外置xml文件" class="headerlink" title="方法二：引用外置xml文件"></a>方法二：引用外置xml文件</h6><pre><code class="xml">resources/pom.xml               &lt;引用外部的配置&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
&lt;/dependency&gt;

resources/application.yaml
logging:
  config: classpath:logback-spring.xml
</code></pre>
<pre><code class="xml">               &lt;如果你有更多样的配置需求，就需要使用外置XML文件的配置方式&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;

&lt;configuration&gt;

    &lt;!--    日志文件存放路径--&gt;
    &lt;property name=&quot;PATH&quot; value=&quot;C:/Users/Pluminary/Desktop/log&quot;/&gt;

    &lt;!-- 彩色日志依赖的渲染类 --&gt;
    &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot;/&gt;
    &lt;conversionRule conversionWord=&quot;wex&quot;
                    converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;/&gt;
    &lt;conversionRule conversionWord=&quot;wEx&quot;
                    converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;/&gt;
    &lt;!-- 彩色日志格式 --&gt;
    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;
              value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt;
    &lt;!-- 文件日志格式 --&gt;
    &lt;property name=&quot;FILE_LOG_PATTERN&quot;
              value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; -%msg%n&quot;/&gt;

    &lt;!-- 控制台输出配置--&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;!--日志输出格式--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;pattern&gt;
                $&#123;CONSOLE_LOG_PATTERN&#125;
            &lt;/pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;!-- INFO 级别日志文件输出配置--&gt;
    &lt;appender name=&quot;info&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!--按级别过滤日志，只输出 INFO 级别--&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
            &lt;level&gt;INFO&lt;/level&gt;
            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
        &lt;/filter&gt;
        &lt;!--当天日志文件名--&gt;
        &lt;File&gt;$&#123;PATH&#125;/info.log&lt;/File&gt;
        &lt;!--按天分割日志文件--&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!--历史日志文件名规则--&gt;
            &lt;fileNamePattern&gt;$&#123;PATH&#125;/info.log.%d&#123;yyyy-MM-dd&#125;.%i&lt;/fileNamePattern&gt;
            &lt;!--按大小分割同一天的日志--&gt;
            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;
                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
            &lt;!--日志文件保留天数--&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;!--日志输出格式--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;Pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/Pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;!-- ERROR 级别日志文件输出配置--&gt;
    &lt;appender name=&quot;error&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!--按级别过滤日志，只输出 ERROR 及以上级别--&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
            &lt;level&gt;ERROR&lt;/level&gt;
        &lt;/filter&gt;
        &lt;!--当天日志文件名--&gt;
        &lt;File&gt;$&#123;PATH&#125;/error.log&lt;/File&gt;
        &lt;!--按天分割日志文件--&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!--历史日志文件名规则--&gt;
            &lt;fileNamePattern&gt;$&#123;PATH&#125;/error.log.%d&#123;yyyy-MM-dd&#125;.%i&lt;/fileNamePattern&gt;
            &lt;!--按大小分割同一天的日志--&gt;
            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;
                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
            &lt;!--日志文件保留天数--&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;!--日志输出格式--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;Pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/Pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;!--日志级别--&gt;
    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
        &lt;appender-ref ref=&quot;info&quot;/&gt;
        &lt;appender-ref ref=&quot;error&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
                   
                   
&lt;
Logback 能够精确区分并输出特定日志级别的错误，是通过 Appender 配置中的 Filter 机制实现的。在你的 Logback 配置文件中，RollingFileAppender 使用了不同的 Filter 来确保只有指定级别的日志信息会被记录到特定的日志文件中。

工作原理
LevelFilter 和 ThresholdFilter:

LevelFilter: 这个过滤器允许你指定只接受特定日志级别的日志。例如，LevelFilter 被配置为只接受 INFO 级别的日志，而拒绝其他级别的日志。&lt;level&gt;INFO&lt;/level&gt; 表示只记录 INFO 级别的日志。
ThresholdFilter: 这个过滤器允许你指定一个日志级别的下限，只有高于或等于这个级别的日志才会被记录。例如，ThresholdFilter 被配置为只接受 ERROR 级别及以上的日志（例如 ERROR 和 FATAL）。
日志级别的传递:

日志框架从最底层（比如 TRACE）开始逐级向上检查日志的级别，直到它与 Appender 中配置的 Filter 级别匹配。例如，如果一个 ERROR 级别的日志被触发，RollingFileAppender 的 ThresholdFilter 将检测到这个日志并允许它通过，然后将日志写入指定的 error.log 文件。
日志级别匹配:

当应用程序运行时，它会生成不同级别的日志信息（如 DEBUG、INFO、WARN、ERROR 等）。每个 Appender 都会根据它的 Filter 规则检查这些日志条目。只有符合条件的日志条目才会被记录到相应的日志文件中。
&gt;
</code></pre>
<h3 id="AOP切面"><a href="#AOP切面" class="headerlink" title="AOP切面"></a>AOP切面</h3><pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/pcy/controller/AspectController.java
package com.pcy.controller;

import com.pcy.entity.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@RequestMapping(&quot;/aspect&quot;)
public class AspectController &#123;
    @GetMapping
    public Result aspect(String message)&#123;
        log.info(&quot;aspect controller&quot;);
        return Result.success(message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/Swagger/SwaggerConfig.java //【增加&quot;/aspect/**&quot;】
package com.pcy.Swagger;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
// http://localhost:8080/swagger-ui/index.html
@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;, &quot;/exception/**&quot;,&quot;/aspect/**&quot;)
                // .addPathsToMatch(&quot;/exception/**&quot;)
                .build();
    &#125;

    @Bean
    public OpenAPI customOpenAPI() &#123;
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Spring Boot 实战&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Spring Boot 实战的 RESTFul 接口文档说明&quot;)
                        .contact(new Contact()
                                .name(&quot;Pluminary&quot;)
                                .url(&quot;https://github.com/P-luminary&quot;)
                                .email(&quot;390415030@qq.com&quot;)));
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/utils/WebAspect.java
package com.pcy.utils;

import com.pcy.entity.Result;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@Aspect
@Component
public class WebAspect &#123;
// ★★★★★★★★★★★ 一定要注意这个AOP切面扫描的包 ★★★★★★★★★★★
    @Pointcut(&quot;execution(public * com.pcy.controller.*.*(..))&quot;)
    public void pointCut() &#123;
    &#125;

    @Before(value = &quot;pointCut()&quot;)
    public void before(JoinPoint joinPoint) &#123;
        System.out.println(&quot;======================================== 这是@Before ========================================&quot;);
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getName();
        Object[] args = joinPoint.getArgs();
        String[] parameterNames = ((MethodSignature) joinPoint.getSignature()).getParameterNames();

        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();

        Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; parameterNames.length; i++) &#123;
            paramMap.put(parameterNames[i], args[i]);
        &#125;

        log.info(&quot;before path：&#123;&#125;&quot;,request.getServletPath());
        log.info(&quot;before class name：&#123;&#125;&quot;,className);
        log.info(&quot;before method name：&#123;&#125;&quot;,methodName);
        log.info(&quot;before args：&#123;&#125;&quot;,paramMap.toString());
    &#125;

    @After(value = &quot;pointCut()&quot;)
    public void after(JoinPoint joinPoint) &#123;
        System.out.println(&quot;======================================== 这是@After =========================================&quot;);
        log.info(&quot;&#123;&#125; after&quot;, joinPoint.getSignature().getName());
    &#125;

    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;returnVal&quot;)
    public void afterReturning(JoinPoint  joinPoint, Object returnVal) &#123;
        System.out.println(&quot;==================================== 这是@AfterReturning ====================================&quot;);
        log.info(&quot;&#123;&#125; after return, returnVal: &#123;&#125;&quot;, joinPoint.getSignature().getName(), returnVal);
    &#125;
&#125;

/*
2024-08-14 18:28:20.249  INFO 3296 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
2024-08-14 18:28:20.249  INFO 3296 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#39;dispatcherServlet&#39;
2024-08-14 18:28:20.250  INFO 3296 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
2024-08-14 18:28:20.261  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：18:28:20:261 毫秒
======================================== 这是@Before ========================================
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before path：/aspect
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before method name：aspect
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before args：&#123;message=www&#125;
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.controller.AspectController      : aspect controller
==================================== 这是@AfterReturning ====================================
2024-08-14 18:28:20.279  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : aspect after return, returnVal: Result(code=200, message=操作成功, data=www)
======================================== 这是@After =========================================
2024-08-14 18:28:20.280  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : aspect after
2024-08-14 18:28:20.308  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：18:28:20:308 毫秒
2024-08-14 18:28:20.308  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-14 18:28:20.309  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：47 毫秒

*/
</code></pre>
<h6 id="若是调用UserController的get接口"><a href="#若是调用UserController的get接口" class="headerlink" title="若是调用UserController的get接口"></a>若是调用UserController的get接口</h6><pre><code class="java">com/pcy/controller/UserController.java
...
    @Operation(summary = &quot;根据ID获取用户信息&quot;, description = &quot;通过用户ID获取用户详细信息&quot;)
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    public User get(@PathVariable int id) &#123;
        return userRepository.findById(id).orElse(null);
    &#125;
...

Console控制台的报错信息：
/*
2024-08-14 18:33:22.383  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：18:33:22:383 毫秒
======================================== 这是@Before ========================================
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before path：/users/user/2
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.UserController
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before method name：get
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before args：&#123;id=2&#125;
==================================== 这是@AfterReturning ====================================
2024-08-14 18:33:22.425  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : get after return, returnVal: User(id=2, name=we2, age=2, email=2, birthDay=2024-08-10)
======================================== 这是@After =========================================
2024-08-14 18:33:22.426  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : get after
2024-08-14 18:33:22.428  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：18:33:22:428 毫秒
2024-08-14 18:33:22.428  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-14 18:33:22.428  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：45 毫秒
*/
</code></pre>
<h6 id="异常善后处理"><a href="#异常善后处理" class="headerlink" title="异常善后处理"></a>异常善后处理</h6><pre><code class="java">com/pcy/controller/AspectController.java //【浏览exception接口的时候会报错】
package com.pcy.controller;

import com.pcy.entity.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@RequestMapping(&quot;/aspect&quot;)
public class AspectController &#123;
    @GetMapping
    public Result aspect(String message)&#123;
        log.info(&quot;aspect controller&quot;);
        return Result.success(message);
    &#125;
    @GetMapping(&quot;/exception&quot;)
    public Result exception()&#123;//抛出异常
        throw new RuntimeException(&quot;runtime exception&quot;);
    &#125;
&#125;


/*
======================================== 这是@Before ========================================
2024-08-15 15:09:20.586  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before path：/aspect/exception
2024-08-15 15:09:20.586  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-15 15:09:20.586  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before method name：exception
2024-08-15 15:09:20.587  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before args：&#123;&#125;
2024-08-15 15:09:20.587  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : exception after throwing, message: runtime exception
======================================== 这是@After =========================================
2024-08-15 15:09:20.587  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : exception after
2024-08-15 15:09:20.588 ERROR 4200 --- [nio-8080-exec-4] com.pcy.utils.GlobalExceptionHandler     : runtime exception
*/
</code></pre>
<pre><code class="java">com/pcy/utils/WebAspect.java
@AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;e&quot;)
    public void afterThrowing(JoinPoint  joinPoint, Exception e) &#123;
        log.info(&quot;&#123;&#125; after throwing, message: &#123;&#125;&quot;, joinPoint.getSignature().getName(), e.getMessage());
    &#125;
</code></pre>
<h6 id="综上所述：after方法不关心方法是否成功，当方法执行完成之后就会被执行；afterReturning方法必须在目标方法成果return之后才会被执行；afterThrowing方法则会在目标方法抛出异常后被执行"><a href="#综上所述：after方法不关心方法是否成功，当方法执行完成之后就会被执行；afterReturning方法必须在目标方法成果return之后才会被执行；afterThrowing方法则会在目标方法抛出异常后被执行" class="headerlink" title="综上所述：after方法不关心方法是否成功，当方法执行完成之后就会被执行；afterReturning方法必须在目标方法成果return之后才会被执行；afterThrowing方法则会在目标方法抛出异常后被执行"></a><span style = "color:red">综上所述：<span style = "color:blue">after</span>方法不关心方法是否成功，当方法执行完成之后就会被执行；<span style = "color:blue">afterReturning</span>方法必须在目标方法成果return之后才会被执行；<span style = "color:blue">afterThrowing</span>方法则会在目标方法抛出异常后被执行</span></h6><h5 id="性能统计"><a href="#性能统计" class="headerlink" title="性能统计"></a>性能统计</h5><blockquote>
<p>Around可以囊括以上所有能力</p>
</blockquote>
<pre><code class="java">com/pcy/controller/AspectController.java
@Slf4j
@RestController
@RequestMapping(&quot;/aspect&quot;)
public class AspectController &#123;
  @GetMapping(&quot;/sleep/&#123;time&#125;&quot;)
    public Result sleep(@PathVariable(&quot;time&quot;) long time) &#123;
        log.info(&quot;sleep&quot;);
        try &#123;
            Thread.sleep(time);
        &#125; catch (InterruptedException e) &#123;
           log.error(&quot;error&quot;, e);
        &#125;
        if (time == 1000) &#123;
            throw new RuntimeException(&quot;runtime exception&quot;);
        &#125;
        log.info(&quot;wake up&quot;);
        return Result.success(&quot;wake up&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Around(&quot;pointCut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) &#123;
        log.info(&quot;around start&quot;);
        long startTime = System.currentTimeMillis();
        Object result = null;
        try &#123;
            result = joinPoint.proceed();
        &#125; catch (Throwable e) &#123;
            log.error(&quot;around error&quot;,e);
        &#125;
        long endTime = System.currentTimeMillis();
        log.info(&quot;execute time：&#123;&#125; ms&quot;,endTime - startTime);
        return result;
    &#125;
</code></pre>
<pre><code class="java">//【当输入time值为2004时】
2024-08-15 15:27:21.987  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：15:27:21:987 毫秒
2024-08-15 15:27:21.990  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : around start
======================================== 这是@Before ========================================
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before path：/aspect/sleep/2004
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before method name：sleep
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before args：&#123;time=2004&#125;
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.controller.AspectController      : sleep
2024-08-15 15:27:23.996  INFO 10844 --- [nio-8080-exec-6] com.pcy.controller.AspectController      : wake up
==================================== 这是@AfterReturning ====================================
2024-08-15 15:27:23.997  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : sleep after return, returnVal: Result(code=200, message=操作成功, data=wake up)
======================================== 这是@After =========================================
2024-08-15 15:27:23.997  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : sleep after
2024-08-15 15:27:23.997  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : execute time：2007 ms
2024-08-15 15:27:23.999  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：15:27:23:999 毫秒
2024-08-15 15:27:23.999  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-15 15:27:23.999  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：12 毫秒


//【当输入time值为1000时】
2024-08-15 15:28:19.596  INFO 10844 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：15:28:19:596 毫秒
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : around start
======================================== 这是@Before ========================================
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before path：/aspect/sleep/1000
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before method name：sleep
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before args：&#123;time=1000&#125;
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.controller.AspectController      : sleep
2024-08-15 15:28:20.607  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : sleep after throwing, message: runtime exception
======================================== 这是@After =========================================
2024-08-15 15:28:20.607  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : sleep after
2024-08-15 15:28:20.607 ERROR 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : around error

java.lang.RuntimeException: runtime exception
    at com.pcy.controller.AspectController.sleep(AspectController.java:32)
    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
    at java.base/java.lang.reflect.Method.invoke(Method.java:578)
......
</code></pre>
<h6 id="同一切面内的执行顺序"><a href="#同一切面内的执行顺序" class="headerlink" title="同一切面内的执行顺序"></a>同一切面内的执行顺序</h6><blockquote>
<p>先执行before方法，再执行afterReturning &#x2F; afterThrowing方法，最后执行after方法<br>要验证的关键点是around方法和它们之间的先后关系</p>
<p>around方法早于before方法开始执行，并且晚于after方法结束执行，刚好将其他同志完全包裹了起来</p>
</blockquote>
<pre><code class="java">//【注释掉WebAspect.java里面的代码不然会叠叠乐累加】
com/pcy/utils/AspectOne.java
package com.pcy.utils;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Slf4j
@Aspect
@Component
public class AspectOne &#123;
    @Pointcut(&quot;execution(public * com.pcy.controller.*.*(..))&quot;)
    public void pointCut()&#123;&#125;
    @Before(value = &quot;pointCut()&quot;)
    public void before()&#123;
        log.info(&quot;before one&quot;);
    &#125;
    @After(value = &quot;pointCut()&quot;)
    public void after()&#123;
        log.info(&quot;after one&quot;);
    &#125;
    @AfterReturning(value = &quot;pointCut()&quot;)
    public void afterReturning()&#123;
        log.info(&quot;afterReturning one&quot;);
    &#125;

    @Around(value = &quot;pointCut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) &#123;
        log.info(&quot;around one start&quot;);
        Object result = null;
        try &#123;
            result = joinPoint.proceed();
        &#125; catch (Throwable e) &#123;
            log.error(&quot;around error&quot;, e);
        &#125;
        log.info(&quot;around one end&quot;);
        return result;
    &#125;
&#125;

/*
2024-08-15 16:12:12.819  INFO 28788 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
2024-08-15 16:12:12.819  INFO 28788 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#39;dispatcherServlet&#39;
2024-08-15 16:12:12.820  INFO 28788 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 0 ms
2024-08-15 16:12:12.839  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：16:12:12:839 毫秒
2024-08-15 16:12:12.864  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : around one start
2024-08-15 16:12:12.864  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : before one
2024-08-15 16:12:12.864  INFO 28788 --- [nio-8080-exec-1] com.pcy.controller.AspectController      : aspect controller
2024-08-15 16:12:12.865  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : afterReturning one
2024-08-15 16:12:12.865  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : after one
2024-08-15 16:12:12.865  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : around one end
2024-08-15 16:12:12.908  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：16:12:12:908 毫秒
2024-08-15 16:12:12.909  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-15 16:12:12.909  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：69 毫秒
*/
</code></pre>
<h6 id="不同切面间的执行顺序"><a href="#不同切面间的执行顺序" class="headerlink" title="不同切面间的执行顺序"></a>不同切面间的执行顺序</h6><blockquote>
<p>将AspectOne复制两份命名AspectTwo和AspectThree [<strong>执行后是One→Three→Two</strong>]<br>在Spring中的加载顺序是根据类名升序排列的，Three字母排序排在Two前面<br>那如何指定执行顺序按照One Two Three？<br>分别为AspectOne&#x2F;Two&#x2F;Three加上@Order(1)，@Order(2)，@Order(3)</p>
</blockquote>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h6 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h6><pre><code class="xml">pom.xml
       &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
                    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">spring:
  application:
    name: Pluminary
  datasource:
    driver-class-name: org.mariadb.jdbc.Driver
    url: jdbc:mariadb://localhost:3306/pcy?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;nullCatalogMeansCurrent=true
    username: root
    password: root

    redis:
      host: localhost port:6379
      connect-timeout: 1000
      jedis:
        pool:
          min-idle: 5
          max-active: 10
          max-idle: 10
          max-wait: 2000
</code></pre>
<pre><code class="java">com/pcy/controller/HelloController.java
@Slf4j
@RestController
@RequestMapping(&quot;/test&quot;)
public class HelloController &#123;
 @Autowired
    private StringRedisTemplate stringRedisTemplate;
    @GetMapping(&quot;/hello&quot;)
    public String hello()&#123;
        stringRedisTemplate.opsForValue().set(&quot;hello&quot;,&quot;world&quot;);
        return stringRedisTemplate.opsForValue().get(&quot;hello&quot;);
    &#125;
&#125;

//先访问hello接口 再去redis-cli中尝试访问自己定义的内容
http://localhost:8080/swagger-ui/index.html#/hello-controller/hello

/*
127.0.0.1:6379&gt; get hello
&quot;world&quot;
*/
</code></pre>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/pcy/controller/HelloController.java
package com.pcy.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
@Slf4j
@RestController
@RequestMapping(&quot;/test&quot;)
public class HelloController &#123;
    @GetMapping(&quot;/hi&quot;)
//  http://localhost:8080/hi
    public String hi()&#123;
        log.info(&quot;hi&quot;);
        return &quot;ok!&quot;;
    &#125;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    @GetMapping(&quot;/hello&quot;)
    public String hello()&#123;
        stringRedisTemplate.opsForValue().set(&quot;hello&quot;,&quot;world&quot;);
        return stringRedisTemplate.opsForValue().get(&quot;hello&quot;);
    &#125;
&#125;

/* Console:
Using generated security password: 4147707e-58d6-46d9-b5cc-19865a2c523f
*/

账号：user
密码：4147707e-58d6-46d9-b5cc-19865a2c523f
</code></pre>
<pre><code class="java">com/pcy/config/SecurityConfig.java
package com.pcy.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;

    // 配置HTTP安全性
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeRequests(authorizeRequests -&gt;
                        authorizeRequests
//          .antMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll() // 允许访问Swagger UI和API文档
                                .anyRequest().authenticated() // 所有请求都需要认证
                )
                .httpBasic(withDefaults()); // 使用HTTP Basic认证

        return http.build();
    &#125;

    // 配置认证管理器
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception &#123;
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .inMemoryAuthentication()
                .withUser(&quot;pcy&quot;)
                .password(passwordEncoder().encode(&quot;123456&quot;))
                .roles(&quot;admin&quot;);

        return authenticationManagerBuilder.build();
    &#125;

    // 配置密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() &#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;

/*
你可能无法访问 http://localhost:8080/swagger-ui/index.html 的原因可能与 Spring Security 配置有关。由于你启用了 Spring Security，默认情况下，所有请求都需要经过身份认证，这可能会阻止你访问 Swagger UI。

为了确保你能够访问 Swagger UI，你需要在 Spring Security 的配置中添加一个例外规则，允许对 /swagger-ui/** 和相关的 Swagger 资源进行无认证访问。

添加代码：.antMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll()


账号：pcy
密码：123456
*/
</code></pre>
<h3 id="从数据库中获取用户信息"><a href="#从数据库中获取用户信息" class="headerlink" title="从数据库中获取用户信息"></a>从数据库中获取用户信息</h3><pre><code class="java">com/pcy/config/SecurityConfig.java
package com.pcy.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;
    @Autowired
    private UserDetailsService userDetailsService; // 使用 Spring Security 的 UserDetailsService

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeHttpRequests(authorizeRequests -&gt;
                        authorizeRequests
                                .anyRequest().authenticated()
                )
                .userDetailsService(userDetailsService) // 设置 UserDetailsService
                .httpBasic(withDefaults())
                .csrf(csrf -&gt; csrf.disable());

        return http.build();
    &#125;

    // 配置认证管理器
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception &#123;
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .userDetailsService(userDetailsService)  // 使用数据库中的用户信息
                .passwordEncoder(passwordEncoder());

        return authenticationManagerBuilder.build();
    &#125;

    // 配置密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() &#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/UserDetailsServiceImpl.java
package com.pcy.service.impl;

import com.baomidou.mybatisplus.core.toolkit.Wrappers;
import com.pcy.entity.SysUser;
import com.pcy.service.SysUserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
//确保你的 UserDetailsServiceImpl 类被 Spring 管理，且实现了 Spring Security 的 UserDetailsService 接口
@Service
public class UserDetailsServiceImpl implements UserDetailsService  &#123;

    @Autowired
    private SysUserService sysUserService;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
        SysUser sysUser = sysUserService.getOne(Wrappers.&lt;SysUser&gt;lambdaQuery().eq(SysUser::getUsername, username));
        if (sysUser == null) &#123;
            throw new UsernameNotFoundException(&quot;User not found with username: &quot; + username);
        &#125;
        return User.builder()
                .username(sysUser.getUsername())
                .password(sysUser.getPassword())
                .authorities(AuthorityUtils.commaSeparatedStringToAuthorityList(sysUser.getRole()))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/entity/SysUser.java
package com.pcy.entity;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.extension.activerecord.Model;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

import java.io.Serializable;

@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@Schema(name = &quot;SysUser对象&quot;, description = &quot;系统用户表&quot;)
public class SysUser extends Model&lt;SysUser&gt; &#123;

    private static final long serialVersionUID = 1L;

    @Schema(description = &quot;主键 id&quot;)
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Integer id;

    @Schema(description = &quot;用户名&quot;)
    private String username;

    @Schema(description = &quot;密码&quot;)
    private String password;

    @Schema(description = &quot;角色&quot;)
    private String role;


    @Override
    public Serializable pkVal() &#123;
        return this.id;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/SysUserService.java
package com.pcy.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.pcy.entity.SysUser;

public interface SysUserService extends IService&lt;SysUser&gt; &#123;
    String getCurrentUser();
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/SysUserServiceImpl.java
package com.pcy.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.pcy.common.ApiException;
import com.pcy.entity.SysUser;
import com.pcy.mapper.SysUserMapper;
import com.pcy.service.SysUserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
@Slf4j
@Service
public class SysUserServiceImpl extends ServiceImpl&lt;SysUserMapper, SysUser&gt; implements SysUserService &#123;
    @Override
    public String getCurrentUser() &#123;
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        // 非匿名用户访问才能获得用户信息
        if (!(authentication instanceof AnonymousAuthenticationToken)) &#123;
            String userName = authentication.getName();
            log.info(&quot;userName by SecurityContextHolder: &#123;&#125;&quot;, userName);
            return userName;
        &#125;
        throw new ApiException(&quot;用户不存在！&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/mapper/SysUserMapper.java
package com.pcy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.pcy.entity.SysUser;

/**
 * &lt;p&gt;
 * 系统用户表 Mapper 接口
 * &lt;/p&gt;
 */
public interface SysUserMapper extends BaseMapper&lt;SysUser&gt; &#123;

&#125;
</code></pre>
<pre><code class="java">com/pcy/common/ApiException.java
package com.pcy.common;

import com.pcy.entity.MessageEnum;
import lombok.Data;

@Data
public class ApiException extends RuntimeException &#123;

    private Integer code;

    public ApiException(MessageEnum messageEnum) &#123;
        super(messageEnum.getMessage());
        this.code = messageEnum.getCode();
    &#125;

    public ApiException(String message) &#123;
        super(message);
        this.code = 500;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//【由于数据库的密码要被加密后的形式保存到数据中】
com/pcy/common/test.java
package com.pcy.common;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

public class test &#123;
    public static void main(String[] args) &#123;
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        String encodedPassword = encoder.encode(&quot;123456&quot;);
        System.out.println(encodedPassword);
    &#125;
&#125;

//$2a$10$GzDPdLyrzC9NudmE937AAetR2bef2VQzuSbP6KM6Y.I3045OuT/xC
</code></pre>
<h6 id="修改创建SysUser用户的时候用Spring-Security-登录的时候就可以用自己创建的了"><a href="#修改创建SysUser用户的时候用Spring-Security-登录的时候就可以用自己创建的了" class="headerlink" title="修改创建SysUser用户的时候用Spring Security [登录的时候就可以用自己创建的了]"></a>修改创建SysUser用户的时候用Spring Security [登录的时候就可以用自己创建的了]</h6><pre><code class="java">com/pcy/controller/UserController.java
/* 对比User数据
    @Operation(summary = &quot;创建User用户&quot;, description = &quot;创建一个新的User用户&quot;)
    @PostMapping(&quot;/create/&quot;)
    public User create(@RequestBody User User) &#123;
        return userRepository.save(User);
    &#125;
*/
    @Autowired
    private SysUserService sysUserService;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Operation(summary = &quot;创建SysUser用户&quot;, description = &quot;创建一个新的SysUser用户&quot;)
    @PostMapping(&quot;/create/test&quot;)
    public SysUser create(@RequestBody SysUser sysUser) &#123;
        sysUser.setPassword(passwordEncoder.encode(sysUser.getPassword()));
        sysUserService.save(sysUser);
        return sysUser;
    &#125;
</code></pre>
<pre><code class="java">package com.pcy.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.pcy.entity.SysUser;
public interface SysUserService extends IService&lt;SysUser&gt;&#123;

    String getCurrentUser();
&#125;
</code></pre>
<pre><code class="java">@Slf4j
@Service
public class SysUserServiceImpl extends ServiceImpl&lt;SysUserMapper, SysUser&gt; implements SysUserService &#123;

 @Override
    public boolean save(SysUser sysUser) &#123;
        return SqlHelper.retBool(this.baseMapper.insert(sysUser));
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/mapper/SysUserMapper.java
package com.pcy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.pcy.entity.SysUser;

/**
 * &lt;p&gt;
 * 系统用户表 Mapper 接口
 * &lt;/p&gt;
 */
public interface SysUserMapper extends BaseMapper&lt;SysUser&gt; &#123;

&#125;
</code></pre>
<h6 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h6><pre><code class="java">com/pcy/config/SecurityConfig.java
package com.pcy.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;
    @Autowired
    private UserDetailsService userDetailsService; // 使用 Spring Security 的 UserDetailsService

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeHttpRequests(authorizeRequests -&gt; authorizeRequests
                        .requestMatchers(&quot;/security/permitall&quot;).permitAll() // 允许所有人访问
                        .requestMatchers(&quot;/security/anonymous&quot;).anonymous() // 仅允许匿名用户访问
                        .requestMatchers(&quot;/security/config&quot;).hasAuthority(&quot;ROLE_config&quot;) // 仅拥有 ROLE_config 权限的用户可以访问
                        .requestMatchers(&quot;/security/Secured&quot;).hasRole(&quot;Secured&quot;) // 仅拥有 ROLE_Secured 的用户可以访问
                        .requestMatchers(&quot;/security/preAuthorize&quot;).hasAuthority(&quot;PreAuthorize&quot;) // 仅拥有 PreAuthorize 权限的用户可以访问
                        .anyRequest().authenticated() // 其他所有请求需要认证
                )
                .userDetailsService(userDetailsService) // 设置 UserDetailsService
                .httpBasic(withDefaults()) // 使用 HTTP Basic 认证
                .csrf(csrf -&gt; csrf.disable()); // 禁用 CSRF

        return http.build();
    &#125;

    // 配置认证管理器
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception &#123;
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .userDetailsService(userDetailsService)  // 使用数据库中的用户信息
                .passwordEncoder(passwordEncoder());

        return authenticationManagerBuilder.build();
    &#125;

    // 配置密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() &#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/controller/SecurityController.java
package com.pcy.controller;

import com.pcy.entity.Result;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.security.access.annotation.Secured;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/security&quot;)
@Tag(name = &quot;权限控制&quot;, description = &quot;权限控制&quot;)
public class SecurityController &#123;
    // Anyone
    @Operation(summary = &quot;permitAll 权限&quot;)
    @GetMapping(value = &quot;/permitall&quot;)
    public Result&lt;String&gt; permitAll()&#123;
        return Result.success(&quot;permitAll&quot;);
    &#125;
    // 未登录时可以访问
    @Operation(summary = &quot;anonymous 权限&quot;)
    @GetMapping(value = &quot;/anonymous&quot;)
    public Result&lt;String&gt; anonymous()&#123;
        return Result.success(&quot;anonymous&quot;);
    &#125;
    // xiaopan可以访问
    @Operation(summary = &quot;config 权限&quot;)
    @GetMapping(value = &quot;/config&quot;)
    public Result&lt;String&gt; config()&#123;
        return Result.success(&quot;permitAll&quot;);
    &#125;
    // xiaochun可以访问
    @Operation(summary = &quot;Secured 权限&quot;)
    @GetMapping(value = &quot;/Secured&quot;)
    @Secured(&#123;&quot;ROLE_Secured&quot;&#125;)
    public Result&lt;String&gt; Secured()&#123;
        return Result.success(&quot;Secured&quot;);
    &#125;
    // panchunyao可以访问
    @Operation(summary = &quot;PreAuthorize 权限&quot;)
    @GetMapping(value = &quot;/preAuthorize&quot;)
    @PreAuthorize(&quot;hasAnyAuthority(&#39;PreAuthorize&#39;)&quot;)
    public Result&lt;String&gt; PreAuthorize()&#123;
        return Result.success(&quot;PreAuthorize&quot;);
    &#125;
&#125;

/*
首先，确保在数据库中创建几个测试用户，并为每个用户分配不同的角色或权限。假设你有以下几个用户：
User 1: Username: xiaopan, Password: 123456, Role: ROLE_config
User 2: Username: xiaochun, Password: 123456, Role: ROLE_Secured
User 3: Username: panchun, Password: 123456, Authority: PreAuthorize

尝试使用不同用户登录:
使用 xiaopan 登录后，尝试访问 /security/config。
使用 xiaochun 登录后，尝试访问 /security/Secured。
使用 panchunyao 登录后，尝试访问 /security/preAuthorize。

检查响应:
/security/config: 只有 xiaopan 能访问，其他用户会被拒绝访问。
/security/Secured: 只有 xiaochun 能访问，其他用户会被拒绝访问。
/security/preAuthorize: 只有 panchunyao 能访问，其他用户会被拒绝访问。
/security/permitall: 所有用户都可以访问。
/security/anonymous: 只有未登录的用户可以访问，登录的用户会被拒绝。

验证权限控制
每个请求的响应应该反映你在 SecurityConfig 中配置的权限。
如果用户没有适当的角色或权限，应该会返回 403 Forbidden 或其他错误响应。
*/
</code></pre>
<pre><code class="java">@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;, &quot;/exception/**&quot;,&quot;/aspect/**&quot;,&quot;/test/**&quot;,&quot;/security/**&quot;)
                // .addPathsToMatch(&quot;/exception/**&quot;)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 【问答环节】
我的数据库创建的是Role字段但是为什么 下面这些有.hasAuthority 有.hasRole 还有其他的 这是怎么匹配到我数据库 按照你的方式设置的数据的

/*
1. hasRole() 和 hasAuthority() 的区别

hasRole(String role):
hasRole 方法通常用于检查用户是否拥有特定的角色。
Spring Security 会在你传递的角色名称前自动加上 &quot;ROLE_&quot; 前缀。因此，当你使用 hasRole(&quot;Secured&quot;) 时，实际上它会检查用户是否有 &quot;ROLE_Secured&quot; 这个权限。

hasAuthority(String authority):
hasAuthority 方法用于检查用户是否拥有特定的权限（或授权）。
hasAuthority 不会自动添加任何前缀。所以当你使用 hasAuthority(&quot;ROLE_config&quot;) 时，它会直接匹配 &quot;ROLE_config&quot;，而不会添加任何前缀。


2. 匹配数据库中的角色和权限
hasRole(&quot;Secured&quot;):
代码中的 hasRole(&quot;Secured&quot;) 实际上会匹配数据库中的 ROLE_Secured，因为 hasRole 方法会自动加上 &quot;ROLE_&quot; 前缀。

hasAuthority(&quot;ROLE_config&quot;):
代码中的 hasAuthority(&quot;ROLE_config&quot;) 会直接匹配数据库中的 &quot;ROLE_config&quot;，没有任何前缀变化。

hasAuthority(&quot;PreAuthorize&quot;):
代码中的 hasAuthority(&quot;PreAuthorize&quot;) 会直接匹配数据库中的 &quot;PreAuthorize&quot;，因为没有添加任何前缀。
*/
    
它为什么能查到我数据库的role字段里面的数据 如果我把这个字段换成test这个名字 它又是怎么去匹配到的呢
/*
Spring Security 默认会使用 UserDetails 接口中的 getAuthorities() 方法来获取用户的权限或角色信息。这些权限或角色信息通常是通过你在 UserDetailsService 实现类中定义的逻辑从数据库中获取的。
而在SecurityConfig中有代码：
@Autowired // 使用 Spring Security 的UserDetailsService
private UserDetailsService userDetailsService; 
回顾securityFilterChain代码
下面会有 .userDetailsService(userDetailsService) // 设置 UserDetailsService

Spring Security 本身并不直接访问你的数据库表或字段。它依赖于你在 UserDetailsService 中提供的 UserDetails 对象的 getAuthorities() 方法的返回值。因此，当你在 SecurityConfig 中使用 hasRole() 或 hasAuthority() 方法时，它实际上是在检查用户的权限信息，即 UserDetails 对象中的 authorities。
===========================================================================
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
    SysUser sysUser = sysUserService.getOne(Wrappers.&lt;SysUser&gt;lambdaQuery().eq(SysUser::getUsername, username));
    if (sysUser == null) &#123;
        throw new UsernameNotFoundException(&quot;User not found with username: &quot; + username);
    &#125;
    return User.builder()
            .username(sysUser.getUsername())
            .password(sysUser.getPassword())
            .authorities(AuthorityUtils.commaSeparatedStringToAuthorityList(sysUser.getTest()))  // 修改为使用 &#39;test&#39; 字段
            .build();
&#125;

*/
</code></pre>
<h3 id="记住我-√-Remember-Me"><a href="#记住我-√-Remember-Me" class="headerlink" title="记住我               √ Remember Me"></a>记住我               √ Remember Me</h3><h6 id="基于SpringSession的方式"><a href="#基于SpringSession的方式" class="headerlink" title="基于SpringSession的方式"></a>基于SpringSession的方式</h6><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
            &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">//【要新搞个登录界面 .ftl】
application.yaml

spring:
  freemarker:
    template-loader-path: /templates/
    suffix: .ftl
</code></pre>
<pre><code class="html">resources/templates/loginPage.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Login&lt;/h1&gt;
&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;
    &lt;div&gt;
        &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;
        &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; required&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;
        &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; required&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;input type=&quot;checkbox&quot; id=&quot;remember-me&quot; name=&quot;remember-me&quot;&gt;
        &lt;label for=&quot;remember-me&quot;&gt;Remember me&lt;/label&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/pcy/controller/LoginController.java
package com.pcy.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class LoginController &#123;
    @GetMapping(&quot;/login&quot;) // 修改为 &quot;/custom-login&quot;
    public String login() &#123;
        return &quot;loginPage&quot;; // 返回的视图名仍然是 &quot;loginPage&quot;
    &#125;
&#125;

/*
http://localhost:8080/login

Please sign in
Username
    panchunyao
Password
    •••••••••••••
√ Remember me on this computer.


127.0.0.1:6379&gt; keys spring*
1) &quot;spring:session:sessions:96c83240-f939-4fd1-ac2c-93542f883aef&quot;
2) &quot;spring:session:sessions:56baf3c6-7a5c-483b-b04a-422b8a2be1b7&quot;
*/
</code></pre>
<pre><code class="java">com/pcy/config/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;
    @Autowired
    private UserDetailsService userDetailsService; // 使用 Spring Security 的 UserDetailsService

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeHttpRequests(authorizeRequests -&gt; authorizeRequests
                        .requestMatchers(&quot;/security/permitall&quot;).permitAll() // 允许所有人访问
                        .requestMatchers(&quot;/security/anonymous&quot;).anonymous() // 仅允许匿名用户访问
                        .requestMatchers(&quot;/security/config&quot;).hasAuthority(&quot;ROLE_config&quot;) // 仅拥有 ROLE_config 权限的用户可以访问
                        .requestMatchers(&quot;/security/Secured&quot;).hasRole(&quot;Secured&quot;) // 仅拥有 ROLE_Secured 的用户可以访问
                        .requestMatchers(&quot;/security/preAuthorize&quot;).hasAuthority(&quot;PreAuthorize&quot;) // 仅拥有 PreAuthorize 权限的用户可以访问
                        .anyRequest().authenticated() // 其他所有请求需要认证
                )
                .formLogin(form -&gt; form
//                        .loginPage(&quot;/custom-login&quot;) // 将登录页面的路径改为 &quot;/custom-login&quot; 打开会循环重定向
                        .defaultSuccessUrl(&quot;http://localhost:8080/swagger-ui/index.html&quot;, true) // 登录成功后的跳转路径
                        .permitAll()
                )
                .rememberMe(rememberMe -&gt; rememberMe
                        .rememberMeServices(rememberMeServices()) // 配置 Remember Me 服务
                )
                .userDetailsService(userDetailsService) // 设置 UserDetailsService
                .httpBasic(withDefaults()) // 使用 HTTP Basic 认证
                .csrf(csrf -&gt; csrf.disable()); // 禁用 CSRF

        return http.build();
    &#125;
&#125;
......
</code></pre>
<pre><code class="java">//【问答环节】
分析一下freemarker这个配置的含义
    freemarker:
      template-loader-path: /templates/
      suffix: .ftl
/*
这些配置项的含义如下：
template-loader-path: /templates/: 这个配置指定了 Freemarker 模板文件的加载路径，也就是 /templates/ 目录。Spring Boot 会在这个目录下寻找所有的 .ftl 模板文件。

suffix: .ftl: 这个配置指定了 Freemarker 模板文件的文件后缀，也就是 .ftl。在控制器中返回视图名称时，Spring 会自动添加这个后缀来查找相应的模板文件。


配置的工作原理
@Controller
public class LoginController &#123;
    @GetMapping(&quot;/login&quot;)
    public String login() &#123;
        return &quot;loginPage&quot;; // 返回的视图名
    &#125;
&#125;
在 LoginController 中的 login() 方法中，你返回的是 &quot;loginPage&quot;：
因为在 application.yaml 中已经配置了 template-loader-path 和 suffix，Spring Boot 会根据这些配置来查找模板文件：
它会在 template-loader-path 配置的 /templates/ 目录下寻找文件。
它会在视图名称 &quot;loginPage&quot; 后面自动添加 .ftl 后缀。
因此，最终 Spring Boot 会查找路径 /templates/loginPage.ftl，并使用这个模板文件来渲染登录页面。这就是为什么当你在控制器中返回 &quot;loginPage&quot; 时，Freemarker 能正确地找到并渲染 loginPage.ftl 模板。

如果你想修改 Freemarker 模板文件的目录或后缀，可以调整 application.yaml 中的相应配置。
视图名称在 return 中不需要包含目录或后缀，Spring 会根据配置自动处理。
*/
</code></pre>
<h1 id="SpringBoot-Vue企业级狐狸"><a href="#SpringBoot-Vue企业级狐狸" class="headerlink" title="SpringBoot + Vue企业级狐狸"></a>SpringBoot + Vue企业级狐狸</h1><pre><code class="mysql">@RequestMapping 注解指定控制器类中的方法可以处理哪些格式的URL请求
@RequestMapping(&quot;/hello&quot;) 说明该方法将接收并处理格式为/hello的HTTP请求
@RestController 注解指定本类承担着SpringBoot项目的&#39;控制器&#39;效果
</code></pre>
<table>
<thead>
<tr>
<th>包名</th>
<th>所放置的业务代码类型</th>
</tr>
</thead>
<tbody><tr>
<td>common</td>
<td>放置了通用的参数和业务方法</td>
</tr>
<tr>
<td>controller</td>
<td>放置了针对各业务请求的控制类</td>
</tr>
<tr>
<td>domain</td>
<td>放置了各种业务实体类</td>
</tr>
<tr>
<td>mapper</td>
<td>放置了针对MyBatis框架的映射关系类</td>
</tr>
<tr>
<td>service</td>
<td>放置了诸多实现业务逻辑的类</td>
</tr>
</tbody></table>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/10/21/后端/SpringBoot趣味实战课/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/09/28/后端/苍穹外卖/">
        <h2>
            苍穹外卖
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/9/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="苍穹外卖"><a href="#苍穹外卖" class="headerlink" title="苍穹外卖"></a>苍穹外卖</h1><h3 id="软件开发整体介绍"><a href="#软件开发整体介绍" class="headerlink" title="软件开发整体介绍"></a>软件开发整体介绍</h3><h4 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h4><h6 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h6><ul>
<li>需求规格说明书(word)、产品原型</li>
</ul>
<h6 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h6><ul>
<li>UI设计、数据库设计、接口设计</li>
</ul>
<h6 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h6><ul>
<li>项目代码、单元测试</li>
</ul>
<h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><ul>
<li>测试用例、测试报告</li>
</ul>
<h6 id="上线运维"><a href="#上线运维" class="headerlink" title="上线运维"></a>上线运维</h6><ul>
<li>软件环境安装、配置</li>
</ul>
<h5 id="角色分工"><a href="#角色分工" class="headerlink" title="角色分工"></a>角色分工</h5><ul>
<li><strong>项目经理</strong>：对整个项目负责，任务分配、把控进度</li>
<li><strong>产品经理</strong>：进行需求调研，输出需求调研文档、产品原型等</li>
<li><strong>UI设计师</strong>：根据产品原型输出界面效果图</li>
<li><strong>架构师</strong>：项目整体架构设计、技术选型等</li>
<li><span style = "color:red"><strong>开发工程师</strong></span>：代码实现</li>
<li><strong>测试工程师</strong>：编写测试用例，输出测试报告</li>
<li><strong>运维工程师</strong>：软件环境搭建、项目上线</li>
</ul>
<h5 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h5><ul>
<li><p>开发环境：开发人员在开发阶段使用的环境</p>
</li>
<li><p>测试环境：专门给测试人员使用的环境，用于项目测试</p>
</li>
<li><p>生产环境：线上环境</p>
</li>
</ul>
<h2 id="第二轮补充知识点复习-会以橙色标注"><a href="#第二轮补充知识点复习-会以橙色标注" class="headerlink" title="第二轮补充知识点复习 会以橙色标注"></a><span style = "color:orange"><strong>第二轮补充知识点复习 会以橙色标注</strong></span></h2><h3 id="苍穹外卖项目介绍"><a href="#苍穹外卖项目介绍" class="headerlink" title="苍穹外卖项目介绍"></a>苍穹外卖项目介绍</h3><h5 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h5><ul>
<li>定位：专门为餐饮制定的一款软件产品[<strong>管理端</strong> 与 <strong>用户端</strong>]</li>
</ul>
<h5 id="功能架构-体现项目中的业务功能模块"><a href="#功能架构-体现项目中的业务功能模块" class="headerlink" title="功能架构 (体现项目中的业务功能模块)"></a>功能架构 (体现项目中的业务功能模块)</h5><ul>
<li><strong>管理端</strong>：员工、分类、菜品、套餐、订单管理、工作台、数据统计、来单提醒</li>
<li><strong>用户端</strong>：微信登录、商品浏览、购物车、用户下单、微信支付、历史订单、地址管理、用户催单</li>
</ul>
<h5 id="产品原型“在文件里有用户端和管理端”-用于展示项目的业务功能-一般由产品经理进行设计"><a href="#产品原型“在文件里有用户端和管理端”-用于展示项目的业务功能-一般由产品经理进行设计" class="headerlink" title="产品原型“在文件里有用户端和管理端” (用于展示项目的业务功能 一般由产品经理进行设计)"></a><span style = "color:red">产品原型<del>“在文件里有用户端和管理端”</del></span> (用于展示项目的业务功能 一般由产品经理进行设计)</h5><h5 id="技术选型-展示项目中使用到的技术框架和中间件"><a href="#技术选型-展示项目中使用到的技术框架和中间件" class="headerlink" title="技术选型 (展示项目中使用到的技术框架和中间件)"></a>技术选型 (展示项目中使用到的技术框架和中间件)</h5><ul>
<li><p><strong>用户层</strong>：node.js、VUE.js、ElementUI、微信小程序、apache echarts</p>
</li>
<li><p><strong>网关层</strong>：Nginx</p>
</li>
<li><p><strong>应用层</strong>：SpringBoot、SpringMVC、SpringTask、httpclient、SpringCache、JWT、阿里云OSS、Swagger、POI(操作excel表格)、WebSocket(网络协议&lt;催单…&gt;)</p>
</li>
<li><p><strong>数据层</strong>：MySQL、Redis、MyBatis、PageHelper、Spring Data Redis</p>
</li>
<li><p><strong>工具</strong>：Git、Maven、Junit、PostMan</p>
</li>
</ul>
<h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><p><strong>前端</strong>：管理端(Web<del>基于Nginx</del>)、用户端(小程序)</p>
<blockquote>
<p>前端环境位置：<br>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day01\前端运行环境\nginx-1.20.2\html\sky</p>
<p>D:\nginx-1.20.2 [放在英文目录下 双击 nginx.exe] 默认端口号80</p>
<p><strong>[苍穹外卖]</strong> (<a target="_blank" rel="noopener" href="http://localhost/#/login">http://localhost/#/login</a>)</p>
</blockquote>
<p><strong>后端</strong>：后端服务(Java)</p>
<blockquote>
<p>后端环境位置：<br>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day01\后端初始工程\sky-take-out</p>
<p>把sky-take-out导入到idea</p>
</blockquote>
<ul>
<li><strong>sky-take-out</strong> [maven父工程，<strong>统一管理依赖版本</strong>，<strong>聚合其他子模块</strong>]<ul>
<li>sky-common [子模块，存放公共类(工具类、常量类、异常类)]</li>
<li>sky-pojo [子模块，存放实体类、VO、DTO等]</li>
<li>sky-server [子模块，后端服务，存放配置文件、Controller、Service、Mapper等]</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Entity</td>
<td>实体，通常和数据库中的表对应</td>
</tr>
<tr>
<td>DTO</td>
<td>数据传输对象，通常用程序中各层之间传递数据</td>
</tr>
<tr>
<td>VO</td>
<td>视图对象，为前端展示数据提供的对象</td>
</tr>
<tr>
<td>POJO</td>
<td>普通Java对象，只有属性和对应的Getter和Setter</td>
</tr>
</tbody></table>
<p><span style = "color:orange"><strong>深刻理解POJO</strong></span></p>
<blockquote>
<p><strong>POJO</strong>的内在含义是指：那些没有继承任何类、也没有实现任何接口[可以实现]，更没有被其它框架侵入的java对象。<br><strong>POJO是一个简单的、普通Java对象，它包含业务逻辑处理或持久化逻辑等，但不是JavaBean、EntityBean等</strong>不具有任何特殊角色，不继承或不实现任何其它Java框架的类或接口。 <strong><u>可以包含类似与JavaBean属性和对属性访问的setter和getter方法的</u></strong><br>一般在web应用程序中建立一个<strong>数据库</strong>的映射对象时，我们只能称它为POJO。</p>
<ul>
<li><strong>POJO持久化之后</strong>&#x3D;&#x3D;〉PO（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）</li>
<li><strong>POJO传输过程中</strong>&#x3D;&#x3D;&gt; DTO</li>
<li><strong>POJO用作表示层</strong>&#x3D;&#x3D;&gt; VO</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解PO、DTO、VO</strong></span></p>
<blockquote>
<p><strong>PO</strong>(persistent object)：就是将对象与关系数据库绑定，用对象来表示关系数据，<br>最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。</p>
<ul>
<li>有时也被称为Data对象，对应数据库的entity，简单认为一个PO对应数据库中的一条记录</li>
<li>PO中不应该包含任何对数据库的操作</li>
<li><strong>PO的属性是跟数据表的字段一一对应的</strong></li>
<li>PO对象需要实现序列化接口</li>
</ul>
<hr>
<p><strong>DTO</strong>(<u>Data Transfer Object</u>)： → 数据传输对象<br>主要用于远程调用需要大量传输对象的地方<br>我们可以将PO中的部分属性抽取出来，就形成了DTO<br><strong>举例说明</strong>：<br>比如我们有一张表有100个字段，那么对应的PO就有100个属性<br>但是我们界面上需要显示10个字段，客户端用WEB service来获取数据，没必要把整个PO对象传递到客户端，这时<u>我们就可以用只有这10个属性的DTO来传递结果到客户端</u>，这样就<u><strong>不会暴露服务端表结构</strong></u>，到达客户端后，<u>如果用这个对象来对应界面显示，那么此时它的身份就转为了<strong>VO</strong>(View Object)</u></p>
<hr>
<p><strong>VO</strong><br>VO(value object) 是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 VO是什么？它是值对象，准确地讲，它是业务对象，是生活在业务层的，是业务逻辑需要了解，需要使用的，再简单地讲，它是概念模型转换得到的。<br><strong>重点</strong>：<br>一个VO可以只是PO的一部分，也可以是多个PO构成，同样也等同于一个PO(指的是属性)。正因为这样，PO独立出来，<u>数据持久层</u>也就独立出来了，它不会受到任何业务的影响和干涉。又因为这样，<u>业务逻辑层</u>也独立开来，它不会受到数据持久层的影响，业务层只关心业务逻辑的处理，怎么存和读都交给别人。</p>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解什么是DAO</strong></span></p>
<blockquote>
<p><strong>DAO</strong>(Data Access Object)：数据访问对象<br>主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO。<br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO，提供数据库的CRUD操作…</p>
<ul>
<li><p>主要用来封装对DB（数据库）的访问（CRUD操作）。</p>
</li>
<li><p>通过接收业务层的数据，把POJO持久化为PO。</p>
</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解JavaBean</strong></span></p>
<blockquote>
<p><strong>JavaBean是一个遵循特定写法的Java类，是一种Java语言编写的可重用组件，它的方法命名，构造及行为必须符合特定的约定：</strong></p>
<p><strong>1、这个类必须具有一个公共的(public)无参构造函数；</strong><br><strong>2、所有属性私有化（private）；</strong><br><strong>3、私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。</strong><br><strong>4、这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）</strong><br>JavaBean在JavaEE开发中，通常用于<strong>封装数据</strong><br>许多开发者会把<strong>JavaBean</strong>看作村从特定命名约定的<strong>POJO</strong><del>POJO按照JavaBean的规则来就可以变成JavaBean</del><br><strong>当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个JavaBean</strong><br>JavaBean是一种组件技术，就好像你做了一个扳手，而这个扳手会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳手扳、锤、撬等等)，而这个扳手就是一个组件。</p>
</blockquote>
<p><span style = "color:orange"><strong>common里的constant、context、properties代表什么意思</strong></span></p>
<pre><code class="java">constant:
用于存放常量类。这些常量可能是项目中频繁使用的固定值，如状态码、错误码、系统配置项等。
常量类中的变量一般使用public static final修饰，确保其不可变性。
    
context:
用于存放上下文类。上下文类通常用来保存和传递运行时环境信息或状态。
在Spring框架中，ApplicationContext就是一个典型的上下文对象，它提供了对Bean的访问以及配置信息的管理。
    
properties:
用于存放属性文件。这些文件通常以.properties为扩展名，用于存储配置信息，如数据库连接字符串、系统参数等。
属性文件可以通过Properties类来读取和写入，方便在运行时动态调整系统行为。
</code></pre>
<p><span style = "color:orange"><strong>Final的巩固</strong></span></p>
<pre><code class="java">问：对于引用类型（如String、Object等），final变量的引用不能被改变，但引用的对象内部状态可以改变。 这句话是什么意思？

答：当一个引用类型的变量被声明为final时，这个变量的引用（即指向的对象）不能被改变，但该对象的内部状态是可以改变的。我们可以通过具体的例子来理解这一点。
public class Example &#123;
    public static final String EMP_ID = &quot;empId&quot;;
    public static void main(String[] args)&#123;
        // 下面这行代码会编译失败，因为EMP_ID是final的
        // EMP_ID = &quot;newEmpId&quot;; // 编译错误
        
// 但是可以创建一个新的String对象并使用EMP_ID内容
    String anotherId = EMP_ID + &quot;123&quot;;
    sout(anotherId) =&gt; empId123;
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>解析context (实现上下类的逻辑原理) 内的代码</strong></span></p>
<pre><code class="java">package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
//ThreadLocal 是一个线程局部变量，每个线程都有自己的独立副本。这意味着不同线程之间不会共享同一个 ThreadLocal实例的数据，从而避免了多线程环境下的数据竞争问题。
    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;
&#125;
/*
这个类通常用于需要在多线程环境中传递和管理线程上下文信息的场景。例如：

Web应用：在处理HTTP请求时，可能需要将用户ID或其他上下文信息绑定到当前线程，以便在整个请求处理过程中都能访问到这些信息。

日志记录：在日志记录中，可能需要记录每个操作的执行者ID，通过 ThreadLocal 可以方便地在日志记录器中获取当前操作者的ID。

事务管理：在分布式事务中，可能需要将事务ID绑定到当前线程，以便在事务的各个阶段都能访问到这个ID。

内存泄漏：如果 ThreadLocal 中存储的对象没有及时释放，可能会导致内存泄漏。因此，建议在不再需要 ThreadLocal 中的数据时，调用 remove 方法将其移除。

线程池：在使用线程池时，特别需要注意 ThreadLocal 的管理。线程池中的线程是复用的，如果不及时清理 ThreadLocal 中的数据，可能会导致数据混淆或内存泄漏。
*/
</code></pre>
<p><span style = "color:orange"><strong>静态变量解析</strong></span></p>
<pre><code class="java">//静态变量 (static)
静态变量：在 Java 中，静态变量属于类而不是类的实例。这意味着无论创建多少个类的实例，静态变量都只有一份拷贝，并且所有实例共享这份拷贝。
作用域：静态变量在类加载时初始化，并且在类卸载时销毁。它们存在于类的生命周期内，而不是实例的生命周期内。

//结合 static 和 ThreadLocal
在 BaseContext 类中，threadLocal 被声明为 static，这意味着所有 BaseContext 实例共享同一个 ThreadLocal 实例。但这并不意味着所有线程共享同一个 ThreadLocal 实例的数据。相反，每个线程都有自己独立的 ThreadLocal 数据副本。
    
静态变量：
public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
这行代码声明了一个静态的 ThreadLocal 变量 threadLocal，所有 BaseContext 实例共享这个 ThreadLocal 实例。
</code></pre>
<h3 id="使用Git进行版本控制"><a href="#使用Git进行版本控制" class="headerlink" title="使用Git进行版本控制"></a>使用Git进行版本控制</h3><ul>
<li>创建Git本地仓库</li>
<li>创建Git远程仓库[GitHub、Gitee]</li>
<li>将本地文件推送到Git远程仓库</li>
</ul>
<pre><code class="java">.gitignore[文件设置]
    
//忽略git管理的文件
**/target/
.idea
*.iml
*.class
*Test.java
**/test/
</code></pre>
<blockquote>
<p><strong>创建远程仓库流程</strong>：【提交到本地】<br>VCS → Create Git Repository → sky-take-out → √ → Unversinoed Files(All)  → Commit</p>
<p><strong>去创建一个仓库</strong>：[Pluminary&#x2F;sky-take-out (gitee.com)] (<a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out">https://gitee.com/Pluminary/sky-take-out</a>)</p>
<p><strong>推送代码到Gitee远程仓库</strong>：Idea右上角的↗ → 定义一下本地和远程仓库关联 点击Define remote → Name: origin<br>URL: <a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out.git">https://gitee.com/Pluminary/sky-take-out.git</a> (这个是在Gitee上创建仓库后复制的代码)</p>
<p><strong>推送成功</strong>：[Pluminary&#x2F;sky-take-out (gitee.com)] (<a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out">https://gitee.com/Pluminary/sky-take-out</a>)</p>
</blockquote>
<h3 id="后端环境搭建"><a href="#后端环境搭建" class="headerlink" title="后端环境搭建"></a>后端环境搭建</h3><h6 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h6><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42914989/article/details/113155204">Unknown collation: ‘utf8mb4_0900_ai_ci‘的解决方法_unknown collation utf8mb4-CSDN博客</a></p>
<h6 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h6><pre><code class="java">浏览器

↓
Controller:
1.接收并封装参数
2.调用service方法查询数据库
3.封装结果并相应

↓
Service：
1.调用mapper查询数据库
2.密码对比
3.返回结果

↓
Mapper：
1.select * from employee where username = ? 

↓
数据库
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tlk20071/article/details/103629336">IDEA中导入多module的Maven项目无法识别module的解决办法_idea modules太多 mvn clean 对某个module不起作用-CSDN博客</a></p>
<blockquote>
<p>Maven → <strong>compile</strong>(编译聚合模块 )</p>
<p>[INFO] ————————————————————————<br>[INFO] Reactor Summary for sky-take-out 1.0-SNAPSHOT:<br>[INFO]<br>[INFO] sky-take-out ………………………………… SUCCESS [  0.003 s]<br>[INFO] sky-common ………………………………….. SUCCESS [  2.761 s]<br>[INFO] sky-pojo ……………………………………. SUCCESS [  2.227 s]<br>[INFO] sky-server ………………………………….. SUCCESS [  1.294 s]<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS</p>
</blockquote>
<p><span style="color:red">在数据库中 <u>新建查询</u> <strong>→</strong> <u>SELECT VERSION()</u>; <strong>→</strong> 引擎是8.0.33的是正规操作mysql此时对应的任务管理器<strong>服务</strong>里搜索mysql(名称:MySQL80)开启这个 <strong>→</strong> 如果开启了服务里的MySQL那<u>SELECT VERSION()</u>查询就是11.0.5-MariaDB</span></p>
<blockquote>
<p>handler：全局异常处理器</p>
</blockquote>
<p><span style = "color:orange"><strong>右侧Maven的具体用途</strong></span></p>
<blockquote>
<ol>
<li><p><strong>clean</strong><br> 功能：<strong>清除项目构建过程中生成的所有文件，通常包括 target 目录下的内容</strong>。<br> 命令：mvn clean<br> 使用场景：<br> 在每次构建之前，确保没有旧的构建产物干扰新构建。<br> 清理项目目录，准备进行新的构建。</p>
</li>
<li><p><strong>validate</strong><br> 功能：<strong>验证项目的正确性，确保所有必要的信息都已就绪</strong>。<br> 命令：mvn validate<br> 使用场景：<br> 在构建过程的早期阶段，检查项目配置是否正确。<br> **<u>确保所有依赖项和资源都可用</u>**。</p>
</li>
<li><p><span style = "color:red"><strong>compile</strong></span><br> 功能：<strong>编译项目的源代码</strong>。<br> 命令：mvn compile<br> 使用场景：<br> <u>编译项目源代码，生成 .class 文件。</u><br> <u><strong>通常在开发过程中频繁使用</strong>，<strong>确保代码可以成功编译</strong>。</u></p>
</li>
<li><p><strong>test</strong><br> 功能：运行项目的单元测试。<br> 命令：mvn test<br> 使用场景：<br> 在代码提交前，确保所有单元测试通过。<br> 持续集成（CI）过程中，自动运行测试以确保代码质量。</p>
</li>
<li><p><span style = "color:red"><strong>package</strong></span><br> 功能：<strong>将编译后的代码打包成可分发的格式，如 JAR、WAR 等</strong>。<br> 命令：mvn package<br> 使用场景：<br> 构建项目并生成可部署的包。<br> <strong>通常在开发和部署过程中使用，生成最终的可发布版本。</strong></p>
</li>
<li><p><strong>verify</strong><br> 功能：<strong>运行任何检查以验证包的完整性和有效性。</strong><br> 命令：mvn verify<br> 使用场景：<br> 在发布前，进行更严格的验证，确保包的质量。<br> <strong>运行集成测试、性能测试</strong>等。</p>
</li>
<li><p><span style = "color:red"><strong>install</strong></span><br> <strong>功能：将包安装到本地 Maven 仓库，供其他项目使用</strong>。<br> 命令：mvn install<br> 使用场景：<br> 将项目依赖安装到本地仓库，以便其他项目可以引用。<br> 通常在开发和测试环境中使用，确保依赖项可用。</p>
</li>
<li><p><strong>site</strong><br> 功能：生成项目的站点文档，包括项目报告、测试覆盖率等。<br> 命令：mvn site<br> 使用场景：<br> 生成项目文档，供团队成员和外部用户查阅。<br> 文档生成和发布，提高项目的透明度和可维护性。</p>
</li>
<li><p><strong>deploy</strong><br> 功能：将最终的包部署到远程仓库，如 Nexus、Artifactory 等。<br> 命令：mvn deploy<br> 使用场景：<br> 将项目发布到远程仓库，供其他团队或项目使用。<br> 通常在持续集成和持续部署（CI&#x2F;CD）流程中使用，确保发布的版本可用。</p>
</li>
</ol>
<p>  <strong>总结</strong><br>  clean：清理构建产物。<br>  validate：验证项目配置。<br>  compile：编译源代码。<br>  test：运行单元测试。<br>  package：打包项目。<br>  verify：验证包的完整性和有效性。<br>  install：安装到本地仓库。<br>  site：生成项目文档。<br>  deploy：部署到远程仓库。</p>
</blockquote>
<h6 id="思考：前端发送的请求，是如何请求到后端服务的？"><a href="#思考：前端发送的请求，是如何请求到后端服务的？" class="headerlink" title="思考：前端发送的请求，是如何请求到后端服务的？"></a>思考：前端发送的请求，是如何请求到后端服务的？</h6><pre><code class="java">前端请求地址：http://localhost/api/employee/login
后端接口地址：http://localhost:8080/admin/employee/login
</code></pre>
<ul>
<li><p><strong>nginx</strong>反向代理，就是将前端发送的动态请求由nginx转发到后端服务器</p>
</li>
<li><p><strong>浏览器</strong> → <a target="_blank" rel="noopener" href="http://localhost/api/employee/login">http://localhost/api/employee/login</a> → <strong>Nginx</strong> → <a target="_blank" rel="noopener" href="http://localhost:8080/admin/employee/login">http://localhost:8080/admin/employee/login</a> → <strong>Tomcat</strong></p>
</li>
<li><p>nginx反向代理的好处：提高访问速度、进行负载均衡<del>(否则前端就只能访问一台服务器)</del>、保证后端服务安全<del>(不对外开放)</del></p>
</li>
</ul>
<h6 id="nginx-反向代理的配置方式"><a href="#nginx-反向代理的配置方式" class="headerlink" title="nginx 反向代理的配置方式"></a>nginx 反向代理的配置方式</h6><pre><code class="java">nginx.conf

server&#123;
    listen 80;
    server_name localhost;
    location /api/&#123;
        proxy_pass http://localhost:8080/admin/;  #反向代理
    &#125;
&#125;
</code></pre>
<h6 id="nginx-负载均衡的配置方法-平均转发到多台后端服务器"><a href="#nginx-负载均衡的配置方法-平均转发到多台后端服务器" class="headerlink" title="nginx 负载均衡的配置方法(平均转发到多台后端服务器)"></a>nginx 负载均衡的配置方法(平均转发到多台后端服务器)</h6><pre><code class="java">nginx.conf

upstream webservers&#123;
    server 192.168.100.128:8080;
    server 192.168.100.129:8080;
&#125;

server&#123;
    listen 80;
    server_name localhost;
    location /api/&#123;
        proxy_pass http://webservers/admin/;  #反向代理
    &#125;
&#125;
</code></pre>
<h6 id="nginx-负载均衡策略："><a href="#nginx-负载均衡策略：" class="headerlink" title="nginx 负载均衡策略："></a>nginx 负载均衡策略：</h6><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式，默认为1，权重越高，被分配的客户端请求就越多</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式，这样每个访客可以固定访问一个后端服务</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据url分配方式，这样相同的url会被分配到同一个后端服务</td>
</tr>
<tr>
<td>fair</td>
<td>依据相应时间方式，响应时间短的服务将会被优先分配</td>
</tr>
</tbody></table>
<h3 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h3><h6 id="问题：员工表中的密码是明文存储，安全性太低"><a href="#问题：员工表中的密码是明文存储，安全性太低" class="headerlink" title="问题：员工表中的密码是明文存储，安全性太低"></a>问题：员工表中的密码是明文存储，安全性太低</h6><ul>
<li><p>将密码加密后存储，提高安全性</p>
</li>
<li><p>使用<strong>MD5</strong>加密方式对明文密码加密 <strong>[不可逆]</strong></p>
</li>
<li><p>修改数据库中的明文代码，改为MD5加密后的密文</p>
</li>
<li><p>修改Java代码，前端提交的代码进行MD5加密后再跟数据库中密码比对</p>
</li>
</ul>
<p><span style = "color:yellow"><strong>在Idea中有 “&#x2F;&#x2F;TODO” 这代表着标记处 此处还未完成一些操作 标记后可以在idea的下面快速定位到TODO</strong></span></p>
<blockquote>
<p>MD5密码加密后 也区分大小写 如果相同的密文但是大小写不同 结果还是不同的</p>
</blockquote>
<h6 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a><span style ="color:orange">修改密码</span></h6><pre><code class="java">com/sky/controller/admin/EmployeeController.java
 @PutMapping(&quot;/editPassword&quot;)
    @ApiOperation(&quot;修改密码&quot;)
    public Result editPassword(@RequestBody PasswordEditDTO passwordEditDTO) &#123;
        log.info(&quot;修改密码：&#123;&#125;&quot;, passwordEditDTO);
        employeeService.updatePassword(passwordEditDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">com/sky/service/EmployeeService.java
/**
     * 更改密码
     * @param passwordEditDTO
     */
    void updatePassword(PasswordEditDTO passwordEditDTO);
</code></pre>
<pre><code class="java">com/sky/service/impl/EmployeeServiceImpl.java
 /**
     * 更改密码
     * @param passwordEditDTO
     */
    @Override
    public void updatePassword(PasswordEditDTO passwordEditDTO) &#123;
    //getCurrentId 方法：public static Long getCurrentId() 方法用于获取当前线程的用户ID。

        Long empId = BaseContext.getCurrentId();
    //select * from employee where id = #&#123;id&#125;   根据id查员工的所有
        Employee employee = employeeMapper.getById(empId);
    //用md根据从前端传来的oldpassword 去判断employee的原始代码是否相同
        if (!employee.getPassword().equals(DigestUtils.md5DigestAsHex(passwordEditDTO.getOldPassword().getBytes()))) &#123; 
            throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);
        &#125;
        String newPassword = DigestUtils.md5DigestAsHex(passwordEditDTO.getNewPassword().getBytes());
        employee.setPassword(newPassword);
        employeeMapper.update(employee);
    &#125;
</code></pre>
<h3 id="导入接口文档"><a href="#导入接口文档" class="headerlink" title="导入接口文档"></a>导入接口文档</h3><h6 id="前后端分离开发流程"><a href="#前后端分离开发流程" class="headerlink" title="前后端分离开发流程"></a>前后端分离开发流程</h6><ul>
<li><strong>定制接口</strong>(定义规范) → <strong>前端开发</strong>(mock数据) + <strong>后端开发</strong>(后端自测) → <strong>连调</strong>(校验格式) → <strong>提测</strong>(自动化测试)</li>
</ul>
<h6 id="操作步骤-YApi-Pro-高效、易用、功能强大的可视化接口管理平台"><a href="#操作步骤-YApi-Pro-高效、易用、功能强大的可视化接口管理平台" class="headerlink" title="操作步骤 YApi Pro-高效、易用、功能强大的可视化接口管理平台"></a>操作步骤 <a target="_blank" rel="noopener" href="https://yapi.pro/">YApi Pro-高效、易用、功能强大的可视化接口管理平台</a></h6><blockquote>
<p>将课程资料中提供的项目接口导入YApi<br>苍穹外卖-管理端接口.json<br>苍穹外卖-用户端接口.json<br>苍穹外卖-管理端+用户端接口 → 数据管理 → 数据导入(json 随后把json文件拖入) → 点击接口可查看</p>
</blockquote>
<h3 id="Swagger介绍和使用方式"><a href="#Swagger介绍和使用方式" class="headerlink" title="Swagger介绍和使用方式"></a>Swagger介绍和使用方式</h3><p><strong>Knife4j</strong>是为Java MVC框架集成Swagger生成Api文档的增强解决方案</p>
<pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h6><ul>
<li>导入knife4j的maven坐标</li>
<li>在配置类中加入knife4j相关配置</li>
</ul>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
/**
 * 通过knife4j生成接口文档
 * @return
*/ 
@Bean
    public Docket docket() &#123;
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                    //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller&quot;))
                .paths(PathSelectors.any())
                .build();
        return docket;
    &#125;
</code></pre>
<ul>
<li>设置静态资源映射，否则接口文档页面无法访问</li>
</ul>
<pre><code class="java">/**
 * 设置静态资源映射
 * @param registry
*/
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;
</code></pre>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a>) 这个文档是解析<code>EmployeeController</code>来的</p>
<h6 id="通过Swagger就可以生成接口文档，那么我们不需要Yapi了？"><a href="#通过Swagger就可以生成接口文档，那么我们不需要Yapi了？" class="headerlink" title="通过Swagger就可以生成接口文档，那么我们不需要Yapi了？"></a>通过Swagger就可以生成接口文档，那么我们不需要Yapi了？</h6><ul>
<li>Yapi是设计阶段使用的工具，管理和维护接口</li>
<li>Swagger在开发阶段使用的框架，帮助后端开发人员做后端的接口测试</li>
</ul>
<p><strong>编写接口文档 在企业中需要注意：</strong></p>
<pre><code class="java">测试：
为每个API编写单元测试和集成测试，确保API的正确性和稳定性。
使用自动化测试工具（如Postman, JUnit等）来定期验证API的行为。
</code></pre>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Api</strong></td>
<td>用在类上，例如<strong>Controller</strong>，表明对类的说明</td>
</tr>
<tr>
<td>@ApiModel</td>
<td>用在类上，例如entity、DTO、VO</td>
</tr>
<tr>
<td>@ApiModelProperty</td>
<td>用在属性上，描述属性信息</td>
</tr>
<tr>
<td><strong>@ApiOperation</strong></td>
<td>用在方法上，例如Controller的方法，说明方法的用途、作用</td>
</tr>
</tbody></table>
<pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
package com.sky.controller.admin;

import com.sky.constant.JwtClaimsConstant;
import com.sky.dto.EmployeeLoginDTO;
import com.sky.entity.Employee;
import com.sky.properties.JwtProperties;
import com.sky.result.Result;
import com.sky.service.EmployeeService;
import com.sky.utils.JwtUtil;
import com.sky.vo.EmployeeLoginVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

/**
 * 员工管理
 */
@RestController
@RequestMapping(&quot;/admin/employee&quot;)
@Slf4j
@Api(tags = &quot;员工相关接口&quot;)
public class EmployeeController &#123;

    @Autowired
    private EmployeeService employeeService;
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping(&quot;/login&quot;)
    @ApiOperation(value = &quot;员工登录&quot;)
    public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) &#123;
        log.info(&quot;员工登录：&#123;&#125;&quot;, employeeLoginDTO);

        Employee employee = employeeService.login(employeeLoginDTO);

        //登录成功后，生成jwt令牌
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
        String token = JwtUtil.createJWT(
                jwtProperties.getAdminSecretKey(),
                jwtProperties.getAdminTtl(),
                claims);

        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return Result.success(employeeLoginVO);
    &#125;

    /**
     * 退出
     *
     * @return
     */
    @PostMapping(&quot;/logout&quot;)
    @ApiOperation(value = &quot;员工退出&quot;)
    public Result&lt;String&gt; logout() &#123;
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/vo/EmployeeLoginVO.java
// 这里是最后返回的数据vo [已经经历过由po→DTO→vo的过程] 这里的po应该就是Employee
package com.sky.vo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ApiModel(description = &quot;员工登录返回的数据格式&quot;)
public class EmployeeLoginVO implements Serializable &#123;

    @ApiModelProperty(&quot;主键值&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String userName;

    @ApiModelProperty(&quot;姓名&quot;)
    private String name;

    @ApiModelProperty(&quot;jwt令牌&quot;)
    private String token;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/dto/EmployeeLoginDTO.java
// 这里的DTO是传输中的数据
package com.sky.dto;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.io.Serializable;

@Data
@ApiModel(description = &quot;员工登录时传递的数据模型&quot;)
public class EmployeeLoginDTO implements Serializable &#123;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;密码&quot;)
    private String password;

&#125;
</code></pre>
<p><span style = "color:orange"><strong>Getter与Setter无中生有？？    以及快速创建对象builder</strong>  </span></p>
<blockquote>
<p>在上述VO和DTO代码中很显然没有看到常见的Getter和Setter<br>这是因为代码使用了 Lombok 注解，Lombok 是一个 Java 库，可以通过注解自动生成常见的样板代码，如 getter、setter、toString、equals 和 hashCode 等方法。</p>
<p><u>Lombok 注解解释</u>：<br>@<strong>Data</strong>：<br>作用：这是一个组合注解，包含了 @ToString、@EqualsAndHashCode、<u>@Getter、@Setter</u> 和 @RequiredArgsConstructor。<br><span style = "color:pink"><strong>效果：自动生成所有字段的 getter 和 setter 方法，toString 方法，equals 和 hashCode 方法，以及一个包含所有 final 字段和 @NonNull 字段的构造函数。</strong></span></p>
<p>@<strong>Builder</strong>：<br>作用：生成一个构建器模式的类，使得对象的创建更加灵活和可读。<br>效果：自动生成一个静态内部类 EmployeeLoginVO.EmployeeLoginVOBuilder，并提供构建方法。</p>
<ul>
<li><p>生成的构建器类包含所有字段的设置方法，并提供一个 build 方法来最终构建对象</p>
</li>
<li><p>使用构建器模式可以让你在创建对象时更清晰地指定各个字段的值，特别是在对象有很多字段时。<br>构建器模式允许你按需设置字段，而不需要为每个字段组合创建多个构造函数。</p>
</li>
<li><p>生成的构建器类：<br>Lombok 会自动生成一个静态内部类 EmployeeLoginVOBuilder，包含所有字段的设置方法和一个 build 方法。</p>
<ul>
<li>设置字段：<br>你可以按需调用构建器的设置方法来设置字段值，例如 id(1L)、userName(“john_doe”) 等。</li>
<li>构建对象：<br>最后调用 build 方法来创建 EmployeeLoginVO 对象。</li>
</ul>
</li>
</ul>
<pre><code class="java"> // 使用构建器创建 EmployeeLoginVO 对象
        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(1L)
                .userName(&quot;john_doe&quot;)
                .name(&quot;John Doe&quot;)
                .token(&quot;eyJhbGciOiJIUzI1NiJ9...&quot;)
                .build();

        System.out.println(employeeLoginVO);
</code></pre>
<p>@<strong>NoArgsConstructor</strong>：<br>作用：生成一个无参构造函数。<br>效果：自动生成一个不带任何参数的构造函数。</p>
<p>@<strong>AllArgsConstructor</strong>：<br>作用：生成一个全参构造函数。<br>效果：自动生成一个包含所有字段的构造函数。</p>
</blockquote>
<p><span style = "color:orange"><strong>详细解析@GetMapping 与 @PostMapping</strong></span></p>
<blockquote>
<p>选择使用 @GetMapping 还是 @PostMapping 主要取决于Http请求的性质和用途<br><strong>@GetMapping</strong></p>
<p>作用：</p>
<ul>
<li><p>@GetMapping专门用于处理HTTP GET请求</p>
</li>
<li><p>GET请求通常用于从服务器获取资源，不会对服务器上的数据进行修改</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li>请求参数通常附加在URL中 <code>@GetMapping(&quot;/xxx/&#123;id&#125;&quot;)</code> 底下会跟 <code>@PathVariable</code></li>
<li>请求是安全的不会修改服务器状态</li>
</ul>
<p><span style = "color:orange"><strong>适用场景：</strong></span></p>
<ul>
<li>查询数据：获取<strong>用户列表、搜索结果</strong></li>
<li>获取静态资源：图片、css文件</li>
<li>获取单个资源：获取某个用户的详细信息</li>
</ul>
<p>@<strong>PostMapping</strong></p>
<p>作用：</p>
<ul>
<li>@PostMapping专门用于处理HTTP POST请求</li>
<li>POST请求通常用于向服务器发送数据，可能会对服务器上的数据进行修改</li>
</ul>
<p>特点：</p>
<ul>
<li>请求参数放在请求体中，不会显示在URL这种 <code>@PostMapping(&quot;/users&quot;)</code>底下会跟<code>@RequestBody</code></li>
<li>请求体的大小没有固定限制，可以发送大量数据</li>
<li>多次相同的POST请求可能会产生不同的结果，可能会修改服务器状态</li>
<li>请求是不安全的，可能会修改服务器状态</li>
</ul>
<p><span style = "color:orange"><strong>适用场景：</strong></span></p>
<ul>
<li>创建新资源：注册新用户、添加新订单</li>
<li>更新现有资源：修改用户信息、更新订单状态</li>
<li>发送表单数据：登录、提交评论</li>
<li>上传文件：图片、文档</li>
</ul>
</blockquote>
<blockquote>
<p>以下是一些可能的原因，解释了为什么您看到的前端项目代码不是“正经的网页代码”：</p>
<ul>
<li><strong>构建过程</strong>：现代前端项目通常有一个构建过程，使用工具如Webpack、Rollup或Parcel等将源代码转换和打包。原始的代码可能在<code>src</code>目录中，而您看到的是构建后的<code>dist</code>目录，其中包含了转换和压缩后的文件。</li>
<li><strong>模块化和组件化</strong>：前端框架和库鼓励开发者将UI拆分成可复用的模块和组件。这意味着不再有传统的HTML、CSS和JavaScript混合在一起的代码，而是分别在不同的文件中定义。</li>
<li><strong>框架和库的使用</strong>：现代前端开发往往依赖于各种框架和库，这些框架和库有自己的文件结构和编写方式，可能和您熟悉的传统网页代码写法有很大不同。</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>根据@PutMapping(“&#x2F;{Id}”)提问</strong></span></p>
<h6 id="我为什么-PutMapping-“-x2F-id-”-是id呢-是不是因为我后面需要数据库where-id-x3D-id-查询才这样传输-如果-我想以name去查询呢"><a href="#我为什么-PutMapping-“-x2F-id-”-是id呢-是不是因为我后面需要数据库where-id-x3D-id-查询才这样传输-如果-我想以name去查询呢" class="headerlink" title="我为什么@PutMapping(“&#x2F;{id}”)是id呢 是不是因为我后面需要数据库where id &#x3D; #{id} 查询才这样传输 如果 我想以name去查询呢"></a>我为什么@PutMapping(“&#x2F;{id}”)是id呢 是不是因为我后面需要数据库where id &#x3D; #{id} 查询才这样传输 如果 我想以name去查询呢</h6><blockquote>
<p>在RESTful API设计中，资源通常通过其唯一标识符（如ID）来访问和操作。<code>@PutMapping(&quot;/&#123;id&#125;&quot;)</code>使用<code>&#123;id&#125;</code>作为路径变量是因为ID是数据库中记录的唯一标识，这使得通过ID查找和更新特定的记录变得直接和高效。</p>
<p>如果你想要通过<code>name</code>来查询和更新记录，这在理论上是可行的，但需要注意以下几点：</p>
<ol>
<li><code>name</code>字段可能不是唯一的，这意味着可能有多条记录具有相同的名称。</li>
<li>使用非唯一字段作为更新依据可能会导致数据不一致或错误更新。</li>
</ol>
</blockquote>
<p><span style = "color:orange"><strong>更新员工 前后端联调原理</strong></span></p>
<pre><code class="javascript">★ 在前端使用Ajax与后端URL对应时，你需要确保Ajax请求的URL与后端控制器中定义的映射相匹配。在你提供的例子中，后端使用@PutMapping(&quot;/&#123;id&#125;&quot;)来定义更新员工信息的端点，因此前端的Ajax URL应该包含员工的ID

// 绑定更新按钮的点击事件
$(&#39;#updateBtn&#39;).click(function() &#123;
    var employee = &#123;
        id: $(&#39;#id&#39;).val(), // 假设这是员工的唯一标识符
        name: $(&#39;#name&#39;).val(),
        email: $(&#39;#email&#39;).val(),
        department: $(&#39;#department&#39;).val()
    &#125;;

    // 发起Ajax PUT请求，URL中包含员工的ID
    $.ajax(&#123;
        url: `/api/employees/$&#123;employee.id&#125;`, // 注意这里的URL与后端的@PutMapping(&quot;/&#123;id&#125;&quot;)对应
        type: &#39;PUT&#39;,
        contentType: &#39;application/json&#39;, // 指定发送给服务器的数据类型
        data: JSON.stringify(employee), // 将JavaScript对象转换为JSON字符串
        success: function(response) &#123;
            // 请求成功，可以在这里处理响应数据
            alert(&#39;Employee information updated successfully!&#39;);
            // 如果需要，可以在这里更新页面上的表单数据
        &#125;,
        error: function(xhr, status, error) &#123;
            // 请求失败，可以在这里处理错误信息
            alert(&#39;Error updating employee information: &#39; + xhr.responseText);
        &#125;
    &#125;);
&#125;);

//在这个例子中，employee.id是从表单中获取的员工ID，它被拼接到URL字符串中，以形成完整的请求URL。这个URL应该与后端控制器中定义的@PutMapping(&quot;/&#123;id&#125;&quot;)相对应。当点击更新按钮时，Ajax请求会被发送到后端，后端会根据提供的ID找到对应的员工记录并进行更新。
</code></pre>
<pre><code class="java"> @PutMapping(&quot;/&#123;id&#125;&quot;)
    public ResponseEntity&lt;Employee&gt; updateEmployee(@PathVariable Long id, @RequestBody Employee employeeDetails) &#123;
        Employee employee = employeeService.getEmployeeById(id);
        if (employee != null) &#123;
            employee.setName(employeeDetails.getName());
            employee.setEmail(employeeDetails.getEmail());
            employee.setDepartment(employeeDetails.getDepartment());
            Employee updatedEmployee = employeeService.updateEmployee(employee);
            return ResponseEntity.ok(updatedEmployee);
        &#125; else &#123;
            return ResponseEntity.notFound().build();
        &#125;
    &#125;
&#125;
//这里&#123;id&#125;是路径变量，它会匹配Ajax请求URL中的employee.id。这样，前后端的URL就正确对应起来了。
</code></pre>
<h3 id="新增员工-Post-Json提交格式"><a href="#新增员工-Post-Json提交格式" class="headerlink" title="新增员工(Post+Json提交格式)"></a>新增员工(Post+Json提交格式)</h3><h4 id="需求分析和设计"><a href="#需求分析和设计" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h4><h6 id="账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456"><a href="#账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456" class="headerlink" title="账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456"></a>账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456</h6><p><strong>本项目约定</strong>：</p>
<ul>
<li><strong>管理端</strong>发出的请求，统一使用 <strong>&#x2F;admin</strong> 作为前缀</li>
<li><strong>用户端</strong>发出的请求，统一使用 <strong>&#x2F;user</strong> 作为前缀</li>
</ul>
<h4 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h4><p>根据新增员工接口设计对应的DTO<br>注意：当前提交的数据和实体类中对应的属性差别比较大时，建议使用DTO(数据传输)来封装数据</p>
<pre><code class="java">sky-pojo  com/sky/dto/EmployeeDTO.java
package com.sky.dto;

import lombok.Data;

import java.io.Serializable;

@Data
public class EmployeeDTO implements Serializable &#123;

    private Long id;

    private String username;

    private String name;

    private String phone;

    private String sex;

    private String idNumber;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
/**
     * 新增员工
     * @param employeeDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增员工&quot;)
    public Result save(@RequestBody  EmployeeDTO employeeDTO)&#123;
    // 因为是JSON格式 要加@RequestBody
        log.info(&quot;新增员工：&#123;&#125;&quot;,employeeDTO);
        employeeService.save(employeeDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
package com.sky.service;

import com.sky.dto.EmployeeDTO;
import com.sky.dto.EmployeeLoginDTO;
import com.sky.entity.Employee;

public interface EmployeeService &#123;

    /**
     * 员工登录
     * @param employeeLoginDTO
     * @return
     */
    Employee login(EmployeeLoginDTO employeeLoginDTO);

    /**
     * 新增员工
     * @param employeeDTO
     */
    void save(EmployeeDTO employeeDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
 /**
     * 新增员工
     * @param employeeDTO
     */
    @Override
    public void save(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
        //employee.setName(employeeDTO.getName()); 太多了 用对象属性拷贝
        BeanUtils.copyProperties(employeeDTO,employee); //其余的要手动设置
        //设置账号状态，默认正常状态 1正常 0锁定  规范封装
        employee.setStatus(StatusConstant.ENABLE);
        //设置密码，默认密码123456
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
        //设置当前记录的创建时间和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        //设置当前记录创建人id和修改人id
        //TODO 后期需要改为当前登录用户的id
        employee.setCreateUser(10L);
        employee.setUpdateUser(10L);

        employeeMapper.insert(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/entity/Employee.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Employee implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    private String name;

    private String password;

    private String phone;

    private String sex;

    private String idNumber;

    private Integer status;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime createTime;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime updateTime;

    private Long createUser;

    private Long updateUser;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
/**
 * 插入员工数据
*/
    @Insert(&quot;insert into employee (name,username,password,phone,sex,id_number,create_time,update_time,create_user,update_user))&quot; +
            &quot;values&quot; +
            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)
    void insert(Employee employee);
</code></pre>
<p><span style = "color:orange"><strong>@Builder 和 @JsonFormat</strong></span></p>
<blockquote>
<p>@Builder 是 Lombok 提供的一个注解，用于自动生成构建器模式的代码。<br>它会在编译时生成一个静态的 Builder 类和相关的方法，使得对象的创建更加灵活和可读。<br>需要<strong>创建不可变对象</strong>时，可以使用 @Builder 结合 @Value 注解。<br>需要<strong>创建复杂的对象</strong>时，可以通过构建器模式逐步设置属性，提高代码的可读性和可维护性</p>
<p>@JsonFormat 是 Jackson 库提供的注解，用于指定日期时间字段在 JSON 序列化和反序列化时的格式。<br>通过设置 pattern 属性，可以控制日期时间字段的格式化方式。<br>当需要将 LocalDateTime、Date 等日期时间类型的字段转换为特定格式的字符串时。<br>在 RESTful API 中，返回的 JSON 数据需要符合特定的日期时间格式要求。</p>
<h6 id="使用-Builder-的场景"><a href="#使用-Builder-的场景" class="headerlink" title="使用 @Builder 的场景"></a>使用 @Builder 的场景</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        // 使用 @Builder 创建 Employee 对象
        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .createUser(1L)
                .updateUser(1L)
                .build();

        System.out.println(employee);
    &#125;
&#125;
</code></pre>
<h6 id="使用-JsonFormat-的场景"><a href="#使用-JsonFormat-的场景" class="headerlink" title="使用 @JsonFormat 的场景"></a>使用 @JsonFormat 的场景</h6><pre><code class="java">//创建 RESTful API
Employee里面的pojo就不详细写了
    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime createTime;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime updateTime;
==========================================================================

@RestController
public class EmployeeController &#123;

    @GetMapping(&quot;/employee&quot;)
    public ResponseEntity&lt;String&gt; getEmployee() throws Exception &#123;
        // 创建 Employee 对象
        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .createUser(1L)
                .updateUser(1L)
                .build();

        // 使用 ObjectMapper 将 Employee 对象转换为 JSON 字符串
        ObjectMapper objectMapper = new ObjectMapper();
        String json = objectMapper.writeValueAsString(employee);

        return ResponseEntity.ok(json);
    &#125;
&#125;
===========================================================================
// 除了 @JsonFormat 注解，还有其他方式可以指定日期时间格式，具体取决于你的需求和使用的库。
 public static void main(String[] args) &#123;
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String formattedDateTime = now.format(formatter);

        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(now)
                .updateTime(now)
                .createUser(1L)
                .updateUser(1L)
                .build();

        System.out.println(&quot;Formatted Create Time: &quot; + formattedDateTime);
        System.out.println(&quot;Formatted Update Time: &quot; + formattedDateTime);
    &#125;
</code></pre>
<p>@<strong>Builder</strong>：<br>通过 Employee.builder() 创建了一个构建器对象。<br>使用链式调用设置各个属性，最后调用 build() 方法生成 Employee 实例。<br>这种方式使得创建对象的代码更加简洁和易读，特别是当对象属性较多时。</p>
<p>@<strong>JsonFormat</strong>：<br>在 createTime 和 updateTime 字段上使用了 @JsonFormat 注解，指定了日期时间的格式为 “yyyy-MM-dd HH:mm:ss”。<br><u><strong>当 Employee 对象被转换为 JSON 字符串</strong></u>时，这两个字段会被格式化为指定的日期时间格式。<br>这样可以确保返回的 JSON 数据符合预期的格式要求。</p>
</blockquote>
<p><span style = "color:orange"><strong>RESTful风</strong></span></p>
<blockquote>
<p><strong>可缓存性：</strong><br>RESTful API 可以利用 HTTP 缓存机制，减少网络请求，提高性能。<br>客户端可以缓存响应，减少服务器的负载。</p>
<p>易于集成：<br>RESTful API 使用标准的 HTTP 协议，几乎所有的编程语言和框架都支持 HTTP 请求。<br>这使得不同系统之间的集成变得更加容易。</p>
<p>可读性强：<br>RESTful API 的 URL 设计通常非常直观，易于理解和记忆。<br>例如，&#x2F;users&#x2F;123 表示用户 ID 为 123 的资源，&#x2F;users&#x2F;123&#x2F;orders 表示该用户的订单资源。</p>
<p>灵活性：<br>RESTful API 支持多种数据格式（如 JSON、XML 等），可以根据需要选择合适的格式。<br>客户端和服务器可以通过协商确定数据格式，提高了灵活性。</p>
<p>  GET &#x2F;users<br>  GET &#x2F;users&#x2F;{id}<br>  POST &#x2F;users<br>  PUT &#x2F;users&#x2F;{id}</p>
</blockquote>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><h6 id="功能测试方式："><a href="#功能测试方式：" class="headerlink" title="功能测试方式："></a>功能测试方式：</h6><ul>
<li>通过接口文档测试</li>
<li>通过前后端联调测试</li>
</ul>
<p>注意：由于开发阶段前后端是并行开发的，后端完成某个功能后，此时前端对应的功能可能还没有开发完成，导致无法进行前后端联调测试。所以在开发阶段，后端测试主要以接口文档测试为主</p>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/documentManager/GlobalParameters-default">http://localhost:8080/doc.html#/documentManager/GlobalParameters-default</a>)</p>
<p><span style = "color:red">首先要拿到<strong>JWT令牌</strong>(去接口进行一次登录测试后会有) → 全局参数设置 → 添加参数</span><br><strong>注意</strong>：这个jwt→json是有有效期的(2小时&#x3D;7200000秒)</p>
<pre><code class="xml">sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 7200000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
</code></pre>
<blockquote>
<p>{<br>  “code”: 1,<br>  “msg”: null,<br>  “data”: {<br>    “id”: 1,<br>    “userName”: “admin”,<br>    “name”: “管理员”,<br>    “token”: “eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI3NjAxMTAxfQ.rnxaRc7fjPzMYwGHk3VzKA4EOxRFrYkKzesxEQsCQUc”<br>  }<br>}</p>
<hr>
<p>新增参数：<br>  参数名称：token<br>  参数值：eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI3NjAxMTAxfQ.rnxaRc7fjPzMYwGHk3VzKA4EOxRFrYkKzesxEQsCQUc<br>  参数类型：header</p>
<p>新增员工接口<br>{<br>  “idNumber”: “1321321312”,<br>  “name”: “张三”,<br>  “phone”: “11111111111”,<br>  “sex”: “1”,<br>  “username”: “zhangsan”<br>}</p>
<p>响应内容：<br>{<br>  “code”: 1,<br>  “msg”: null,<br>  “data”: null<br>}</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/interceptor/JwtTokenAdminInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component  //将该类注册为 Spring 管理的 Bean。
@Slf4j //使用 Lombok 自动生成日志记录器
public class JwtTokenAdminInterceptor implements HandlerInterceptor &#123;
// 包含 JWT 相关的配置属性，如令牌名称和密钥
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
//检查当前拦截到的是否是 Controller 的方法。如果不是，直接放行
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/properties/JwtProperties.java
package com.sky.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &quot;sky.jwt&quot;)
@Data
public class JwtProperties &#123;

    /**
     * 管理端员工生成jwt令牌相关配置
     */
    private String adminSecretKey;
    private long adminTtl;
    private String adminTokenName;

    /**
     * 用户端微信用户生成jwt令牌相关配置
     */
    private String userSecretKey;
    private long userTtl;
    private String userTokenName;
&#125;
</code></pre>
<h4 id="代码完善"><a href="#代码完善" class="headerlink" title="代码完善"></a>代码完善</h4><h6 id="程序存在的问题："><a href="#程序存在的问题：" class="headerlink" title="程序存在的问题："></a>程序存在的问题：</h6><ul>
<li>录入的用户名已存在，抛出异常后没有处理</li>
<li>新增员工时，创建人id和修改人id设置了固定值</li>
</ul>
<blockquote>
<p>当你在 Maven 中执行 compile 命令时，它会强制 Maven 重新编译整个项目，包括所有的类和资源。这一过程会清除任何旧的编译结果，确保所有的依赖和代码都是最新的。这可能导致以下几种情况，从而解决了你的问题：</p>
<p>**<u>重新编译：</u>**Maven 会重新编译所有的源代码，包括你修改或新增的类，这样就能解决因为旧的编译缓存而引起的引用问题。<br>**<u>更新依赖：</u>**如果你在项目中添加或修改了依赖，执行 compile 可以确保这些依赖被正确加载和引用。<br><u><strong>清理旧缓存</strong>：</u>在编译过程中，Maven 会清理旧的缓存和临时文件，避免由于这些文件造成的潜在冲突。<br>**<u>IDE 同步：</u>**有时候，IDE 的状态可能与 Maven 项目状态不一致，执行 Maven 命令可以帮助 IDE 重新同步项目的状态。</p>
</blockquote>
<h6 id="问题①"><a href="#问题①" class="headerlink" title="问题①"></a>问题①</h6><pre><code class="java">sky-server  com/sky/handler/GlobalExceptionHandler.java
package com.sky.handler;

import com.sky.constant.MessageConstant;
import com.sky.exception.BaseException;
import com.sky.result.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常处理器，处理项目中抛出的业务异常
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler &#123;

    /**
     * 捕获业务异常
     * @param ex
     * @return
     */
    @ExceptionHandler
    public Result exceptionHandler(BaseException ex)&#123;
        log.error(&quot;异常信息：&#123;&#125;&quot;, ex.getMessage());
        return Result.error(ex.getMessage());
    &#125;

    @ExceptionHandler
    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex) &#123;
        String message = ex.getMessage();
        if (message.contains(&quot;Duplicate entry&quot;)) &#123;
            // Duplicate entry &#39;zhangsan&#39; for key &#39;employee.idx_username&#39;
// 在这里，我们使用 split(&quot;&#39;&quot;) 将字符串分割为多个部分。这样，parts[1] 将得到 zhangsan，因为它位于单引号之间。这种方式可以正确提取用户名。
            String[] split = message.split(&quot;&#39;&quot;);
            String username = split[1];
//            String msg = username + &quot;已存在&quot;;
            String msg = username + MessageConstant.ALREADY_EXISTS;
            return Result.error(msg);
        &#125;else &#123;
            return Result.error(MessageConstant.UNKNOWN_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>Split的深入学习</strong></span></p>
<blockquote>
<ul>
<li><strong>正则表达式</strong></li>
</ul>
<p>split 方法接受一个<strong>正则表达式</strong>作为参数，因此分隔符可以是复杂的模式，而不仅仅是单个字符。<br>例如，<strong>split(“\s+”)</strong> 可以用来按一个或多个空白字符（包括空格、制表符、换行符等）进行分割。</p>
<ul>
<li><strong>限制分割次数</strong></li>
</ul>
<p>split 方法还有一个重载版本 split(String regex, int limit)，可以限制分割的次数。<br>例如，split(“‘“, 3) 只会进行两次分割，结果数组最多包含三个元素。</p>
</blockquote>
<h3 id="问题②-解析出员工登录id后，如何转递给Service的save方法？→-ThreadLocal"><a href="#问题②-解析出员工登录id后，如何转递给Service的save方法？→-ThreadLocal" class="headerlink" title="问题②  解析出员工登录id后，如何转递给Service的save方法？→ ThreadLocal"></a>问题②  <span style = "color:orange"><strong>解析出员工登录id后，如何转递给Service的save方法？</strong></span>→ <span style = "color:red">ThreadLocal</span></h3><img src="https://raw.githubusercontent.com/P-luminary/images/2dd9f9e12ba173719123c685949c277632af5ce4/data/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E7%99%BB%E5%BD%95%E5%8F%8A%E6%A0%A1%E9%AA%8C.jpg" style="zoom:150%;" />

<h6 id="前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id："><a href="#前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id：" class="headerlink" title="前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id："></a>前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id：</h6><pre><code class="java">        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
</code></pre>
<h6 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h6><p>ThreadLocal并不是一个Thread，Thread的局部变量<br><strong>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获得到对应的值，线程外则不能访问</strong></p>
<pre><code class="java">sky-common  com/sky/context/BaseContext.java
package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/interceptor/JwtTokenAdminInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor &#123;

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
// ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
            BaseContext.setCurrentId(empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 新增员工
     * @param employeeDTO
     */
    @Override
    public void save(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
//        employee.setName(employeeDTO.getName()); 太多了 用对象属性拷贝
        BeanUtils.copyProperties(employeeDTO,employee); //其余的要手动设置
        //设置账号状态，默认正常状态 1正常 0锁定  规范封装
        employee.setStatus(StatusConstant.ENABLE);
        //设置密码，默认密码123456
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
        //设置当前记录的创建时间和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        //设置当前记录创建人id和修改人id
        //TODO 后期需要改为当前登录用户的id
//        employee.setCreateUser(10L);
// ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        employee.setCreateUser(BaseContext.getCurrentId());
        employee.setUpdateUser(BaseContext.getCurrentId());
    
        employeeMapper.insert(employee);
    &#125;

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 如果想单独针对22行代码 测试部分的值是多少 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
// 左键选中&#39;BaseContext.getCurrentId()&#39; 右键Evaluate Expression单独计算即可
</code></pre>
<p><span style = "color:orange"><strong>将员工登录ID放在 ThreadLocal 中的原因</strong></span></p>
<blockquote>
<p>在多线程环境中，使用 ThreadLocal 来存储和传递员工的完整信息是一个常见的做法。这样可以确保每个线程都有独立的变量副本，避免并发问题。以下是一些步骤和最佳实践，帮助你在 ThreadLocal 中安全地传递和存储员工的完整信息。<br>ThreadLocal 主要用于在同一个线程内传递和存储数据，确保每个线程都有独立的变量副本。在你的例子中，ThreadLocal 用于存储员工ID，确保在多线程环境下员工ID的安全传递。</p>
<ul>
<li><strong>线程隔离</strong>：ThreadLocal 确保每个线程都有独立的员工ID副本，避免了多线程环境下的并发问题。<br>防止篡改：<u><strong>只有当前线程可以访问和修改 ThreadLocal 中的员工ID</strong></u>，其他线程无法访问，确保了ID的安全性。</li>
<li><strong>员工其他信息的安全性</strong><br><u>数据库查询</u>：员工的其他信息是从数据库中查询的，而不是从 ThreadLocal 中获取的。数据库查询本身是安全的，只要数据库连接和查询操作是安全的。<br><u>权限控制</u>：确保只有经过认证的用户才能执行查询操作，防止未授权访问。<br><u>数据加密</u>：敏感信息（如密码）在存储和传输过程中应进行加密，确保数据的安全性。</li>
</ul>
<p><strong>线程安全</strong>：<br>ThreadLocal 为每个线程提供独立的变量副本，避免了多线程环境下的并发问题。每个线程都可以安全地读取和修改自己的 ThreadLocal 变量，而不会影响其他线程。</p>
<p><strong>简化代码</strong>：<br>在 Web 应用中，通常需要在多个方法或组件之间传递用户身份信息（如员工登录ID）。使用 ThreadLocal 可以避免在每个方法调用中显式传递这些信息，从而简化代码。</p>
<p><strong>全局访问</strong>：<br>在同一个线程内，任何地方都可以访问 ThreadLocal 中存储的值，这使得在复杂的业务逻辑中传递和使用员工登录ID变得非常方便。</p>
<p><strong>避免传递参数</strong>：<br>在多层调用中，如果需要传递员工登录ID，通常需要在每个方法签名中添加相应的参数。使用 ThreadLocal 可以避免这种繁琐的参数传递，提高代码的可读性和可维护性。</p>
<pre><code class="java">// 设置员工登录ID：
在用户登录成功后，将员工登录ID设置到 ThreadLocal 中。
@PostMapping(&quot;/login&quot;)
public ResponseEntity&lt;?&gt; login(@RequestBody LoginRequest loginRequest) &#123;
    // 验证用户名和密码
    User user = userService.validateUser(loginRequest.getUsername(), loginRequest.getPassword());
    if (user != null) &#123;
        // 设置当前线程的员工登录ID
        BaseContext.setCurrentId(user.getId());
        // 返回登录成功信息
        return ResponseEntity.ok(&quot;Login successful&quot;);
    &#125; else &#123;
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(&quot;Invalid username or password&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 获取员工登录ID
在需要使用员工登录ID的地方，直接从 ThreadLocal 中获取
@Service
public class OrderService &#123;

    public void createOrder(Order order) &#123;
        Long currentUserId = BaseContext.getCurrentId();
        if (currentUserId != null) &#123;
            order.setCreatedBy(currentUserId);
            orderRepository.save(order);
        &#125; else &#123;
            throw new RuntimeException(&quot;User ID not found in context&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>将员工登录ID放在 ThreadLocal 中，可以确保每个线程都有独立的变量副本，避免多线程环境下的并发问题。同时，这种方式简化了代码，提供了全局访问的能力，避免了繁琐的参数传递，使得在复杂的业务逻辑中传递和使用员工登录ID变得非常方便。</p>
</blockquote>
<h3 id="员工分页查询"><a href="#员工分页查询" class="headerlink" title="员工分页查询"></a>员工分页查询</h3><h5 id="需求分析和设计-1"><a href="#需求分析和设计-1" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h5><h6 id="业务规则：-查询-→-get"><a href="#业务规则：-查询-→-get" class="headerlink" title="业务规则：(查询 → get)"></a>业务规则：(查询 → get)</h6><ul>
<li>根据页码展示员工信息</li>
<li>每页展示10条数据</li>
<li>分页查询时可以根据需要，输入员工姓名进行查询</li>
</ul>
<h5 id="代码开发-1"><a href="#代码开发-1" class="headerlink" title="代码开发"></a>代码开发</h5><h6 id="根据分页查询接口设计对应的DTO"><a href="#根据分页查询接口设计对应的DTO" class="headerlink" title="根据分页查询接口设计对应的DTO:"></a>根据分页查询接口设计对应的DTO:</h6><p><strong>Query</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>是否必须</th>
<th>示例</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>否</td>
<td>张三</td>
<td>员工姓名</td>
</tr>
<tr>
<td>page</td>
<td>是</td>
<td>1</td>
<td>页码</td>
</tr>
<tr>
<td>pageSize</td>
<td>是</td>
<td>10</td>
<td>每页记录数</td>
</tr>
</tbody></table>
<pre><code class="java">@Data
public class EmployeePageQueryDTO implements Serializable&#123;
    private String name;
    private int page;
    private int pageSize;
&#125;
</code></pre>
<h6 id="后面所有的分页查询，统一都封装成PageResult对象"><a href="#后面所有的分页查询，统一都封装成PageResult对象" class="headerlink" title="后面所有的分页查询，统一都封装成PageResult对象"></a>后面所有的分页查询，统一都封装成PageResult对象</h6><pre><code class="java">/*封装分页查询结果*/
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable&#123;
    private long total; 
    private List records;
&#125;
</code></pre>
<h6 id="员工信息分页查询后端返回的对象类型为：Result-lt-PageResult-gt"><a href="#员工信息分页查询后端返回的对象类型为：Result-lt-PageResult-gt" class="headerlink" title="员工信息分页查询后端返回的对象类型为：Result &lt; PageResult &gt;"></a>员工信息分页查询后端返回的对象类型为：<strong>Result &lt; PageResult &gt;</strong></h6><pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
/**
     * 员工分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    public Result&lt;PageResult&gt; page(EmployeePageQueryDTO employeePageQueryDTO)&#123;
        //格式不是JSON不用加 @RequestBody
        log.info(&quot;员工分页查询，参数为：&#123;&#125;&quot;, employeePageQueryDTO);
        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
        return Result.success(pageResult);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
/**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @Override
    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;
        // select * from employee limit 0,10
        // 开始分页查询 动态拼接
        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
        Page&lt;Employee&gt; page =  employeeMapper.pageQuery(employeePageQueryDTO);

        long total = page.getTotal();
        List&lt;Employee&gt; records = page.getResult();

        return new PageResult(total, records);
&#125;
</code></pre>
<p><span style = "color:orange"><strong>逐行研究分页查询</strong></span></p>
<blockquote>
<ul>
<li><p>PageHelper.startPage 是 MyBatis 分页插件提供的方法，用于开启分页功能</p>
<ul>
<li><p>employeePageQueryDTO.getPage() 获取当前页码。</p>
</li>
<li><p>employeePageQueryDTO.getPageSize() 获取每页显示的记录数</p>
<p>这一行代码的作用是告诉 MyBatis 在接下来的查询中启用分页，并设置分页参数</p>
</li>
</ul>
</li>
<li><p>employeeMapper.pageQuery(employeePageQueryDTO) 是调用 MyBatis 的 Mapper 接口方法，执行分页查询。</p>
<ul>
<li>employeePageQueryDTO 包含了查询条件，如关键字、排序字段等。</li>
<li>查询结果会被封装成 Page<Employee> 对象，其中包含了分页数据和分页元数据。</li>
</ul>
</li>
<li><p>page.getTotal() 获取分页查询的总记录数。</p>
<ul>
<li>总记录数用于计算总页数和其他分页相关的计算</li>
</ul>
</li>
<li><p>List<Employee> records &#x3D; page.getResult();</p>
<ul>
<li>page.getResult() 获取分页查询的实际数据列表。</li>
<li>这个列表包含了当前页的员工记录</li>
</ul>
</li>
<li><p>return new PageResult(total, records);</p>
</li>
<li><p>new PageResult(total, records) 创建一个新的 PageResult 对象，将总记录数和分页数据列表封装起来</p>
</li>
<li><p>PageResult 类通常包含 total 和 records 属性，用于返回给客户端</p>
</li>
<li><p>假设 employeePageQueryDTO.getPage() 返回 2，employeePageQueryDTO.getPageSize() 返回 10，那么 MyBatis 生成的 SQL 可能类似于：</p>
</li>
</ul>
<pre><code class="mysql">SELECT * FROM employee
WHERE ... -- 根据 employeePageQueryDTO 中的查询条件
LIMIT 10 OFFSET 10;
</code></pre>
<p>LIMIT 10：表示每页显示 10 条记录。<br>OFFSET 10：表示从第 11 条记录开始（因为页码从 1 开始，所以第 2 页的偏移量是 10）。</p>
<ul>
<li><p><strong>PageResult 类</strong>：用于封装分页查询的结果，包括总记录数和当前页的数据集合。<br>使用场景：在分页查询服务中，将查询结果封装为 PageResult 对象，通过控制器返回给客户端。</p>
</li>
<li><p><strong>Serializable 接口</strong>：是 Java 中的一个标记接口，没有定义任何方法。实现 Serializable 接口的类的对象可以被序列化，即将对象的状态转换为字节流，以便在网络上传输或持久化存储。反序列化则是将字节流恢复为对象的过程。 </p>
<ul>
<li><strong>序列化</strong></li>
</ul>
<p><u>对象状态转换</u>：将对象的状态（即对象的字段值）转换为字节流。<br>默认序列化机制：Java 提供了默认的序列化机制，通过 ObjectOutputStream 类的 writeObject 方法实现。<br><u>自定义序列化</u>：可以通过实现 writeObject 和 readObject 方法来自定义序列化和反序列化过程。</p>
<ul>
<li><strong>持久化</strong></li>
</ul>
<p>持久化：序列化的主要目的是将对象的状态保存到存储介质中，或者通过网络传输对象。</p>
</li>
</ul>
<p>查询结果会被封装到 PageResult 对象中，其中 total 表示总记录数，records 表示当前页的数据集合。</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
 /**
     * 分页查询 [动态sql 不用注解了 写道 EmployeeMapper.xml]
     * @param employeePageQueryDTO
     * @return
     */
    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
</code></pre>
<pre><code class="xml">sky-server  mapper/EmployeeMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.EmployeeMapper&quot;&gt;
    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Employee&quot;&gt;
        select * from employee
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
        &lt;/where&gt;
        order by create_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
&lt;!--
and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)：
如果条件成立，生成的 SQL 条件为 AND name LIKE &#39;%$&#123;name&#125;%&#39;，实现名称的模糊匹配
--&gt;
</code></pre>
<p>[员工管理] (<a target="_blank" rel="noopener" href="http://localhost/#/employee">http://localhost/#/employee</a>)</p>
<h5 id="代码完善-1"><a href="#代码完善-1" class="headerlink" title="代码完善"></a>代码完善</h5><h6 id="问题：创建-x2F-更新时间那边传入的数据不是想要的"><a href="#问题：创建-x2F-更新时间那边传入的数据不是想要的" class="headerlink" title="问题：创建&#x2F;更新时间那边传入的数据不是想要的"></a>问题：创建&#x2F;更新时间那边传入的数据不是想要的</h6><pre><code class="java">// 2024929214237
&quot;createTime&quot;: [
          2024,
          9,
          29,
          22,
          10,
          37
        ],
        &quot;updateTime&quot;: [
          2024,
          9,
          29,
          22,
          10,
          37
        ],
</code></pre>
<h6 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h6><ul>
<li><p><strong>方法一</strong>：在属性上加注解，对日期进行格式化<del>(只能处理单独一个属性)</del></p>
<pre><code class="java">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
private LocalDateTime updateTime;
------------------------------------------------------------------------
 &quot;createTime&quot;: &quot;2024-09-29 22:10:37&quot;,
</code></pre>
</li>
<li><p><strong>方法二</strong>：在<code>WebMvcConfiguration</code>中扩展Spring MVC的消息转换器，统一对日期类型进行格式化处理</p>
</li>
</ul>
<blockquote>
<p>重写父类方法 去扩展 消息转换器</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
 /**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        log.info(&quot;扩展消息转换器...&quot;);
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转化器加入容器中
        converters.add(0,converter);
    &#125;
</code></pre>
<pre><code class="java">package com.sky.json;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper &#123;

    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;
    //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;;
    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;

    public JacksonObjectMapper() &#123;
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    &#125;
&#125;
</code></pre>
<h3 id="启用禁用员工账号"><a href="#启用禁用员工账号" class="headerlink" title="启用禁用员工账号"></a>启用禁用员工账号</h3><h5 id="需求分析和设计-2"><a href="#需求分析和设计-2" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h5><h6 id="业务规则："><a href="#业务规则：" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>可以对状态为 “启用” 的员工账号进行 “禁用” 操作</li>
<li>可以对状态为 “禁用” 的员工账号进行 “启用” 操作</li>
<li>状态为 “禁用” 的员工账号不能登录系统</li>
</ul>
<pre><code class="java">sky-server
/**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;启用禁用员工账号&quot;)
    //因为上面的和下面的参数都是一致 不然需要@PathVariable(&quot;status&quot;)解释一下
    public Result startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id) &#123;
        log.info(&quot;启用禁用员工账号: &#123;&#125;,&#123;&#125;&quot;,status,id);
        employeeService.startOrStop(status, id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
 /**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @Override
    public void startOrStop(Integer status, Long id) &#123;
        // update employee set status = ? where id = ?
        Employee employee = new Employee();
        employee.setStatus(status);
        employee.setId(id);

/** 要在Employee.java中添加@Builder 才能使用这种风格
 *      Employee employee = Employee.builder()
 *              .status(status)
 *              .id(id)
 *              .build();
 */
        employeeMapper.update(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
/**
     * 根据主键动态修改属性
     * @param employee
     */
    void update(Employee employee);
</code></pre>
<pre><code class="java">sky-server  mapper/EmployeeMapper.xml
&lt;update id=&quot;update&quot; parameterType=&quot;Employee&quot;&gt;
        update employee
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt;
            &lt;if test=&quot;username != null&quot;&gt;username = #&#123;username&#125;,&lt;/if&gt;
            &lt;if test=&quot;password != null&quot;&gt;password = #&#123;password&#125;,&lt;/if&gt;
            &lt;if test=&quot;phone != null&quot;&gt;phone = #&#123;phone&#125;,&lt;/if&gt;
            &lt;if test=&quot;sex != null&quot;&gt;sex = #&#123;sex&#125;,&lt;/if&gt;
            &lt;if test=&quot;idNumber != null&quot;&gt;id_Number = #&#123;idNumber&#125;,&lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;update_Time = #&#123;updateTime&#125;,&lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;update_User = #&#123;updateUser&#125;,&lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125;,&lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
</code></pre>
<h3 id="编辑员工"><a href="#编辑员工" class="headerlink" title="编辑员工"></a>编辑员工</h3><h4 id="需求分析和设计-回写数据"><a href="#需求分析和设计-回写数据" class="headerlink" title="需求分析和设计[回写数据]"></a>需求分析和设计[回写数据]</h4><h6 id="编辑员工功能涉及到两个接口："><a href="#编辑员工功能涉及到两个接口：" class="headerlink" title="编辑员工功能涉及到两个接口："></a>编辑员工功能涉及到两个接口：</h6><ul>
<li>根据id查询员工信息</li>
<li>编辑员工信息</li>
</ul>
<h4 id="代码开发-2"><a href="#代码开发-2" class="headerlink" title="代码开发"></a>代码开发</h4><pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
    /**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询员工信息&quot;)
    public Result&lt;Employee&gt; getById(@PathVariable Long id)&#123;
        Employee employee = employeeService.getById(id);
        return Result.success(employee);
    &#125;

    /**
     * 编辑员工信息
     * @param employeeDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;编辑员工信息&quot;)
    public Result update(@RequestBody EmployeeDTO employeeDTO)&#123;
        log.info(&quot;编辑员工信息：&#123;&#125;&quot;, employeeDTO);
        employeeService.update(employeeDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
/**
     * 根据id查询员工
     * @param id
     * @return
     */
    Employee getById(Long id);

    /**
     * 编辑员工信息
     * @param employeeDTO
     */
    void update(EmployeeDTO employeeDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 根据id查询员工
     * @param id
     * @return
     */
    public Employee getById(Long id) &#123;
        Employee employee = employeeMapper.getById(id);
        employee.setPassword(&quot;****&quot;);
        return employee;
    &#125;

    /**
     * 编辑员工信息
     * @param employeeDTO
     */
    public void update(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
        BeanUtils.copyProperties(employeeDTO, employee);

        //employee.setUpdateTime(LocalDateTime.now());
        //employee.setUpdateUser(BaseContext.getCurrentId());

        employeeMapper.update(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
 /**
     * 根据主键动态修改属性
     * @param employee
     */
    void update(Employee employee);

    /**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)
    Employee getById(Long id);
</code></pre>
<blockquote>
<ul>
<li>前端提交表单：<br>用户在前端页面编辑员工信息并提交表单。<br>表单数据被序列化为 JSON 格式，通过 HTTP PUT 请求发送到后端。</li>
<li>后端接收数据：<br>控制器方法 update 接收到 EmployeeDTO 对象。<br>记录日志，输出接收到的员工信息。<br>调用服务层的 update 方法，处理员工信息的更新。</li>
<li>服务层处理：<br>创建一个新的 Employee 对象。<br>使用 BeanUtils.copyProperties 将 EmployeeDTO 的属性复制到 Employee 对象中。<br>调用 MyBatis 的 employeeMapper，执行更新操作。</li>
<li>MyBatis 更新操作：<br>生成动态 SQL 语句，只更新传入的非 null 属性。<br>例如，如果 name 和 phone 不为 null，生成的 SQL 语句如下：</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>数据回写的具体过程</strong></span></p>
<blockquote>
<ul>
<li>前端请求获取员工信息   &#x2F;&#x2F; 根据id查询员工信息<br>当你点击编辑按钮时，前端会发起一个 HTTP GET 请求，从后端获取员工的详细信息。这些信息将被用来填充表单字段。</li>
<li>后端处理 GET 请求<br>后端需要提供一个接口来处理这个 GET 请求，并返回员工的详细信息。</li>
<li>前端处理响应并填充表单<br>前端接收到后端返回的员工信息后，将其填充到表单字段中</li>
</ul>
<pre><code class="java">/**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @GetMapping(&quot;&#123;/id&#125;&quot;)
    @ApiOperation(&quot;根据id查询员工信息&quot;)
    public Result&lt;Employee&gt; getById(@PathVariable Long id) &#123;
        log.info(&quot;根据id查询员工信息：&#123;&#125;&quot;, id);
        Employee employee = employeeService.getById(id);
        return Result.success(employee);
    &#125;
</code></pre>
<pre><code class="vue">&lt;script&gt;export default &#123;
  data() &#123;
    return &#123;
      employee: &#123;
        id: null,
        name: &#39;&#39;,
        username: &#39;&#39;,
        password: &#39;&#39;,
        phone: &#39;&#39;,
        sex: &#39;&#39;,
        idNumber: &#39;&#39;
      &#125;
    &#125;;
  &#125;,
  methods: &#123;
    async fetchEmployee(id) &#123;
      try &#123;
        const response = await this.$axios.get(`/employees/$&#123;id&#125;`);
        this.employee = response.data.data;
      &#125; catch (error) &#123;
        console.error(&#39;获取员工信息失败&#39;, error);
      &#125;
    &#125;,
    async updateEmployee() &#123;
      try &#123;
        await this.$axios.put(&#39;/employees&#39;, this.employee);
        alert(&#39;员工信息更新成功&#39;);
      &#125; catch (error) &#123;
        console.error(&#39;更新员工信息失败&#39;, error);
      &#125;
    &#125;
  &#125;,
  mounted() &#123;
    const id = this.$route.params.id; // 假设通过路由参数传递员工ID
    this.fetchEmployee(id);
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<ul>
<li>提交表单<br>当用户编辑完表单并点击保存按钮时，前端会发起一个 HTTP PUT 请求，将更新后的员工信息发送到后端进行处理</li>
</ul>
<p><strong>总结</strong><br>前端请求获取员工信息：点击编辑按钮时，前端发起 GET 请求获取员工的详细信息。<br>后端处理 GET 请求：后端提供一个接口处理 GET 请求，返回员工的详细信息。<br>前端处理响应并填充表单：前端接收到员工信息后，将其填充到表单字段中。<br>提交表单：用户编辑完表单并点击保存按钮，前端发起 PUT 请求，将更新后的员工信息发送到后端进行处理。</p>
</blockquote>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/default/%E5%91%98%E5%B7%A5%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/updateUsingPUT">http://localhost:8080/doc.html#/default/员工相关接口/updateUsingPUT</a>)</p>
<h4 id="导入分类管理功能代码"><a href="#导入分类管理功能代码" class="headerlink" title="导入分类管理功能代码"></a>导入分类管理功能代码</h4><h6 id="业务规则：-1"><a href="#业务规则：-1" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>分类名称必须是<strong>唯一</strong>的</li>
<li>分类按章类型可分为<strong>菜品分类</strong>和<strong>套餐分类</strong></li>
<li>新添加的分类状态默认认为 “<strong>禁用</strong>“</li>
</ul>
<h6 id="接口设计："><a href="#接口设计：" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li>新增分类</li>
<li>分类分页查询</li>
<li>根据id删除分类</li>
<li>修改分类</li>
<li>启用禁止分类</li>
<li>根据类型调查分类</li>
</ul>
<p><strong>数据库设计(category表)</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/CategoryController.java
package com.sky.controller.admin;

import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import com.sky.result.Result;
import com.sky.service.CategoryService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

/**
 * 分类管理
 */
@RestController
@RequestMapping(&quot;/admin/category&quot;)
@Api(tags = &quot;分类相关接口&quot;)
@Slf4j
public class CategoryController &#123;

    @Autowired
    private CategoryService categoryService;

    /**
     * 新增分类
     * @param categoryDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增分类&quot;)
    public Result&lt;String&gt; save(@RequestBody CategoryDTO categoryDTO)&#123;
        log.info(&quot;新增分类：&#123;&#125;&quot;, categoryDTO);
        categoryService.save(categoryDTO);
        return Result.success();
    &#125;

    /**
     * 分类分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;分类分页查询&quot;)
    public Result&lt;PageResult&gt; page(CategoryPageQueryDTO categoryPageQueryDTO)&#123;
        log.info(&quot;分页查询：&#123;&#125;&quot;, categoryPageQueryDTO);
        PageResult pageResult = categoryService.pageQuery(categoryPageQueryDTO);
        return Result.success(pageResult);
    &#125;

    /**
     * 删除分类
     * @param id
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;删除分类&quot;)
    public Result&lt;String&gt; deleteById(Long id)&#123;
        log.info(&quot;删除分类：&#123;&#125;&quot;, id);
        categoryService.deleteById(id);
        return Result.success();
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改分类&quot;)
    public Result&lt;String&gt; update(@RequestBody CategoryDTO categoryDTO)&#123;
        categoryService.update(categoryDTO);
        return Result.success();
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;启用禁用分类&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id)&#123;
        categoryService.startOrStop(status,id);
        return Result.success();
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据类型查询分类&quot;)
    public Result&lt;List&lt;Category&gt;&gt; list(Integer type)&#123;
        List&lt;Category&gt; list = categoryService.list(type);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/CategoryService.java
package com.sky.service;

import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增分类
     * @param categoryDTO
     */
    void save(CategoryDTO categoryDTO);

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    void deleteById(Long id);

    /**
     * 修改分类
     * @param categoryDTO
     */
    void update(CategoryDTO categoryDTO);

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/CategoryServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.context.BaseContext;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.CategoryMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 分类业务层
 */
@Service
@Slf4j
public class CategoryServiceImpl implements CategoryService &#123;

    @Autowired
    private CategoryMapper categoryMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 新增分类
     * @param categoryDTO
     */
    public void save(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        //属性拷贝
        BeanUtils.copyProperties(categoryDTO, category);

        //分类状态默认为禁用状态0
        category.setStatus(StatusConstant.DISABLE);

        //设置创建时间、修改时间、创建人、修改人
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContext.getCurrentId());
        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.insert(category);
    &#125;

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123;
        PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());
        //下一条sql进行分页，自动加入limit关键字分页
        Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 根据id删除分类
     * @param id
     */
    public void deleteById(Long id) &#123;
        //查询当前分类是否关联了菜品，如果关联了就抛出业务异常
        Integer count = dishMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
        &#125;

        //查询当前分类是否关联了套餐，如果关联了就抛出业务异常
        count = setmealMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);
        &#125;

        //删除分类数据
        categoryMapper.deleteById(id);
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     */
    public void update(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO,category);

        //设置修改时间、修改人
        category.setUpdateTime(LocalDateTime.now());
        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.update(category);
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        Category category = Category.builder()
                .id(id)
                .status(status)
                .updateTime(LocalDateTime.now())
                .updateUser(BaseContext.getCurrentId())
                .build();
        categoryMapper.update(category);
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    public List&lt;Category&gt; list(Integer type) &#123;
        return categoryMapper.list(type);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/CategoryMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.enumeration.OperationType;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;

@Mapper
public interface CategoryMapper &#123;

    /**
     * 插入数据
     * @param category
     */
    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +
            &quot; VALUES&quot; +
            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)
    void insert(Category category);

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    Page&lt;Category&gt; pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    @Delete(&quot;delete from category where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);

    /**
     * 根据id修改分类
     * @param category
     */
    void update(Category category);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  mapper/CategoryMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.CategoryMapper&quot;&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Category&quot;&gt;
        select * from category
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;type != null&quot;&gt;
                and type = #&#123;type&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by sort asc , create_time desc
    &lt;/select&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;Category&quot;&gt;
        update category
        &lt;set&gt;
            &lt;if test=&quot;type != null&quot;&gt;
                type = #&#123;type&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;sort != null&quot;&gt;
                sort = #&#123;sort&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;Category&quot;&gt;
        select * from category
        where status = 1
        &lt;if test=&quot;type != null&quot;&gt;
            and type = #&#123;type&#125;
        &lt;/if&gt;
        order by sort asc,create_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface DishMapper &#123;

    /**
     * 根据分类id查询菜品数量
     * @param categoryId
     * @return
     */
    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long categoryId);

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface SetmealMapper &#123;

    /**
     * 根据分类id查询套餐的数量
     * @param id
     * @return
     */
    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long id);

&#125;
</code></pre>
<h2 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h2><h4 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h4><p>业务表中的公共字段：(后期会很多[菜品&#x2F;套餐管理])</p>
<h6 id="问题：代码冗余不利于后期维护"><a href="#问题：代码冗余不利于后期维护" class="headerlink" title="问题：代码冗余不利于后期维护"></a>问题：代码冗余不利于后期维护</h6><table>
<thead>
<tr>
<th>序号</th>
<th>字段名</th>
<th>含义</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>create_time</td>
<td>创建时间</td>
<td>datetime</td>
</tr>
<tr>
<td>2</td>
<td>create_user</td>
<td>创建人id</td>
<td>bigint</td>
</tr>
<tr>
<td>3</td>
<td>update_time</td>
<td>修改时间</td>
<td>datetime</td>
</tr>
<tr>
<td>4</td>
<td>update_user</td>
<td>修改人id</td>
<td>bigint</td>
</tr>
</tbody></table>
<h6 id="解决：技术点-→-枚举、注解、AOP、反射"><a href="#解决：技术点-→-枚举、注解、AOP、反射" class="headerlink" title="解决：技术点 → 枚举、注解、AOP、反射"></a>解决：技术点 → 枚举、注解、AOP、反射</h6><table>
<thead>
<tr>
<th>序号</th>
<th>字段名</th>
<th>含义</th>
<th>数据类型</th>
<th>操作类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>create_time</td>
<td>创建时间</td>
<td>datetime</td>
<td>insert</td>
</tr>
<tr>
<td>2</td>
<td>create_user</td>
<td>创建人id</td>
<td>bigint</td>
<td>insert</td>
</tr>
<tr>
<td>3</td>
<td>update_time</td>
<td>修改时间</td>
<td>datetime</td>
<td>insert、update</td>
</tr>
<tr>
<td>4</td>
<td>update_user</td>
<td>修改人id</td>
<td>bigint</td>
<td>insert、update</td>
</tr>
</tbody></table>
<ul>
<li>自定义注解 <strong>AutoFill</strong>，用于标识需要进行公共字段自动填充的方法</li>
<li>自定义切面 <strong>AutoFillAspect</strong>，统一拦截加入了 <strong>AutoFill</strong> 注解的方法，通过反射为公共字段赋值</li>
<li>在 <strong>Mapper</strong> 的方法上加入 <strong>AutoFill</strong> 注解</li>
</ul>
<h4 id="代码开发1"><a href="#代码开发1" class="headerlink" title="代码开发1"></a>代码开发1</h4><pre><code class="java">sky-server  com/sky/annotation/AutoFill.java
package com.sky.annotation;

import com.sky.enumeration.OperationType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill &#123;
// 枚举数据库操作类型：UPDATE INSERT [只要在这情况才有必要设置]
    OperationType value();
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/aspect/AutoFillAspect.java
package com.sky.aspect;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
//只在update和insert里加
@Mapper
public interface EmployeeMapper &#123;
 /**
     * 插入员工数据
     * @param employee
     */
    @Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user,status) &quot; +
            &quot;values &quot; +
            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)
    @AutoFill(value = OperationType.INSERT)
    void insert(Employee employee);
/**
     * 分页查询 [动态sql 不用注解了 写道 EmployeeMapper.xml]
     * @param employeePageQueryDTO
     * @return
     */
    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
    @AutoFill(value = OperationType.UPDATE)
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/CategoryMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.annotation.AutoFill;
import com.sky.enumeration.OperationType;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;
@Mapper
public interface CategoryMapper &#123;

    /**
     * 插入数据
     * @param category
     */
    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +
            &quot; VALUES&quot; +
            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)
    void insert(Category category);

    /**
     * 根据id修改分类
     * @param category
     */
    void update(Category category);
&#125;
</code></pre>
<p><span style = "color:orange"><strong>详细讲解@AutoFill</strong></span></p>
<blockquote>
<p><strong><u>@Target(ElementType.<em>METHOD</em>)</u></strong><br>使用<code>@Target</code>注解指定自定义注解@AutoFill可以应用的目标元素类，这里指定了<code>ElementType.METHOD</code>，表示@AutoFill**<u>只能应用于方法上</u>**</p>
<p><strong><u>@Retention(RetentionPolicy.RUNTIME)</u></strong><br>使用 <code>@Retention</code> 注解指定自定义注解 @AutoFill 的保留策略。这里指定了 <code>RetentionPolicy.RUNTIME</code>，表示 @AutoFill 注解会在运行时保留，可以通过反射获取到。</p>
<p><strong><u>public @interface AutoFill {…}</u></strong><br>@interface：关键字，用于定义一个新的注解类型。<br>AutoFill：注解的名称，表示这个注解就叫做AutoFill</p>
<p>区分普通接口：<code>@interface</code> 与普通的 <code>interface</code> 不同，普通的interface用于定义接口，而@interface用于定义注解，@符号帮助编译器区分这两者</p>
<pre><code class="java">package com.sky.enumeration;

/**
 * 数据库操作类型
 */
public enum OperationType &#123;
    /**
     * 更新操作
     */
    UPDATE,

    /**
     * 插入操作
     */
    INSERT
&#125;
</code></pre>
<hr>
<p>@<strong><u>Aspect</u></strong><br>使用<code>@Aspect</code>注解将这个类标记为一个切面，切面是AOP(面向切面编程)，用于定义切面关注点(日志记录、事务管理)</p>
<p>@<strong><u>Component</u></strong><br>使用<code>@Component</code>注解将这个类标记为Spring管理的Bean，这样Spring容器会自动扫描并管理这个类的实例</p>
<p>@<strong><u>Slf4j</u></strong><br>使用 <code>@Slf4j</code> 注解生成一个日志记录器（Logger）实例。这个注解来自 Lombok 库，可以简化日志记录器的创建</p>
<pre><code class="java">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;
</code></pre>
<p>使用<code>@Pointcut</code>注解定义一个切入点<code>autoFillPointCut</code></p>
<ul>
<li><code>execution(* com.sky.mapper.*.*(..))</code>：匹配<code>com.sky.mapper</code>包下所有类的所有方法</li>
<li><code>&amp;&amp; @annotation(com.sky.annotation.AutoFill)</code>：并且这些方法必须带有<code>@AutoFill</code>注解</li>
<li>public void autoFillPointCut()：定义一个空的方法，用于标识这个切入点</li>
</ul>
<pre><code class="java">/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);
    &#125;
&#125;
</code></pre>
<p>使用<code>@Before</code>注解定义一个前置通知<code>autoFill</code>，这个通知会在切入点方法执行前被调用</p>
<ul>
<li><code>@Before(&quot;autoFillPointCut()&quot;)</code>：指定这个通知应用于<code>autoFillPointCut</code>切入点</li>
<li><code>public void autoFill(JoinPoint joinPoint)</code>：定义通知方法，接收一个<code>JoinPoint</code>参数，<code>JoinPoint</code>包含了连接点的信息，如被拦截的方法、参数等</li>
</ul>
</blockquote>
<h4 id="代码开发2"><a href="#代码开发2" class="headerlink" title="代码开发2"></a>代码开发2</h4><blockquote>
<p>公共属性赋值后 Service里的 save(Employee employee) → employee.setCreateUser(BaseContext.getCurrentId())就不用再去赋值了</p>
</blockquote>
<h6 id="这个写完后-就可以把Service里的一些employee-setXXX的删除了-因为公共属性只需要加-AutoFill"><a href="#这个写完后-就可以把Service里的一些employee-setXXX的删除了-因为公共属性只需要加-AutoFill" class="headerlink" title="这个写完后 就可以把Service里的一些employee.setXXX的删除了 因为公共属性只需要加@AutoFill"></a>这个写完后 就可以把Service里的一些employee.setXXX的删除了 因为公共属性只需要加@AutoFill</h6><pre><code class="java">sky-server  com/sky/annotation/AutoFill.java 不变
sky-server  com/sky/aspect/AutoFillAspect.java
package com.sky.aspect;

import com.sky.annotation.AutoFill;
import com.sky.constant.AutoFillConstant;
import com.sky.context.BaseContext;
import com.sky.enumeration.OperationType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;

/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);

        // 获取当前被拦截的方法上的数据库操作类型(Update/Insert)
        MethodSignature signature = (MethodSignature)joinPoint.getSignature(); //方法签名对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class); //获得方法上的注解对象
        OperationType operationType = autoFill.value();//获得数据库操作类型

        // 获取当当前被拦截的方法的参数--实体对象 (Employee employee)
        Object[] args = joinPoint.getArgs();
        if (args == null || args.length == 0) &#123; //没有参数不执行
            return;
        &#125;
        Object entity = args[0]; //获得第一个

        // 准备赋值数据
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();

        // 根据当前不同的操作类型，对对应的属性通过反射来赋值
        if (operationType == OperationType.INSERT) &#123;
            // 为4个公共字段赋值
            Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
            Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);


            //通过反射对对象赋值属性
            setCreateTime.invoke(entity,now);
            setCreateUser.invoke(entity,currentId);
            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        &#125; else if (operationType == OperationType.UPDATE) &#123;
            // 为2个公共字段赋值
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

            //通过反射对对象赋值属性
            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h3><h6 id="业务规则：-2"><a href="#业务规则：-2" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>菜品名称必须是唯一的</li>
<li>菜品必须属于某个分类下，不能单独存在</li>
<li>新增菜品时可以根据选择情况菜品的口味</li>
<li>每个菜品必须对应一张图片</li>
</ul>
<h6 id="接口设计：-1"><a href="#接口设计：-1" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>根据类型查询分类(已完成) <code>/admin/category/list    GET</code></p>
<p><u>这里要注意数据返回 因为它里面的口味算一个集合</u></p>
</li>
<li><p>文件上传 <code>/admin/common/upload    POST</code>   </p>
</li>
<li><p>新增菜品 <code>/admin/dish    POST</code></p>
</li>
</ul>
<h6 id="数据库设计："><a href="#数据库设计：" class="headerlink" title="数据库设计："></a>数据库设计：</h6><ul>
<li>dish菜品表 [一个菜品对应着多种口味]</li>
<li>dish_flavour口味表</li>
</ul>
<h6 id="开发文件上传接口："><a href="#开发文件上传接口：" class="headerlink" title="开发文件上传接口："></a>开发文件上传接口：</h6><p>浏览器 → 后端服务 → 阿里云OSS</p>
<pre><code class="java">sky-common  com/sky/utils/AliOssUtil.java
package com.sky.utils;

import com.aliyun.oss.ClientException;
import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.OSSException;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;


import java.io.ByteArrayInputStream;

@Data
@AllArgsConstructor
@Slf4j
public class AliOssUtil &#123;
// 通过配置类初始化这些数据
    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;

    /**
     * 文件上传
     *
     * @param bytes
     * @param objectName
     * @return
     */
    public String upload(byte[] bytes, String objectName) &#123;

 // 创建OSSClient实例。 将字节数组转换为输入流，并将其上传到指定的bucket和objectName
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

        try &#123;
            // 创建PutObject请求。
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));
        &#125; catch (OSSException oe) &#123;
            System.out.println(&quot;Caught an OSSException, which means your request made it to OSS, &quot;
                    + &quot;but was rejected with an error response for some reason.&quot;);
            System.out.println(&quot;Error Message:&quot; + oe.getErrorMessage());
            System.out.println(&quot;Error Code:&quot; + oe.getErrorCode());
            System.out.println(&quot;Request ID:&quot; + oe.getRequestId());
            System.out.println(&quot;Host ID:&quot; + oe.getHostId());
        &#125; catch (ClientException ce) &#123;
            System.out.println(&quot;Caught an ClientException, which means the client encountered &quot;
                    + &quot;a serious internal problem while trying to communicate with OSS, &quot;
                    + &quot;such as not being able to access the network.&quot;);
            System.out.println(&quot;Error Message:&quot; + ce.getMessage());
        &#125; finally &#123;
            if (ossClient != null) &#123;
                ossClient.shutdown();
            &#125;
        &#125;

        //文件访问路径规则 https://BucketName.Endpoint/ObjectName
        StringBuilder stringBuilder = new StringBuilder(&quot;https://&quot;);
        stringBuilder
                .append(bucketName)
                .append(&quot;.&quot;)
                .append(endpoint)
                .append(&quot;/&quot;)
                .append(objectName);
        log.info(&quot;文件上传成功，访问路径：&#123;&#125;&quot;, stringBuilder);

        return stringBuilder.toString();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-common  com/sky/constant/AutoFillConstant.java
package com.sky.constant;

/**
 * 公共字段自动填充相关常量
 */
public class AutoFillConstant &#123;
    /**
     * 实体类中的方法名称
     */
    public static final String SET_CREATE_TIME = &quot;setCreateTime&quot;;
    public static final String SET_UPDATE_TIME = &quot;setUpdateTime&quot;;
    public static final String SET_CREATE_USER = &quot;setCreateUser&quot;;
    public static final String SET_UPDATE_USER = &quot;setUpdateUser&quot;;
&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
sky:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    host: localhost
    port: 3306
    database: sky_take_out
    username: root
    password: root
  alioss:
    endpoint: XXXXXXXXX
    access-key-id: XXXXXXXXXXXX
    access-key-secret: XXXXXXXXXXX
    bucketName: XXXXXXXXX
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/CommonController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.utils.AliOssUtil;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.UUID;

/**
 * 通用接口
 */
@RestController
@RequestMapping(&quot;/admin/common&quot;)
@Api(tags = &quot;通用接口&quot;)
@Slf4j
public class CommonController &#123;
    @Autowired
    private AliOssUtil aliOssUtil;
    @PostMapping(&quot;/upload&quot;)
    @ApiOperation(&quot;文件上传&quot;)
    // 如果要测试文件上传 只能用postman或者前后端联调
    public Result&lt;String&gt; upload(MultipartFile file) &#123;
        log.info(&quot;文件上传：&#123;&#125;&quot;, file);
        // 防止重名覆盖
        try &#123;
            // 原始文件名
            String filename = file.getOriginalFilename();
            // 截取原始文件名的后缀
            String extension = filename.substring(filename.lastIndexOf(&quot;.&quot;));
            // 构造新文件名UUID
            String objectName = UUID.randomUUID().toString() + extension;

            // 文件的请求路径
            String filepath = aliOssUtil.upload(file.getBytes(), objectName);
            log.info(&quot;文件上传成功，访问路径：&#123;&#125;&quot;, filepath);
            return Result.success(filepath);
        &#125; catch (IOException e) &#123;
            log.error(&quot;文件上传失败：&#123;&#125;&quot;, e);
        &#125;
        return Result.error(MessageConstant.UPLOAD_FAILED);
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>如何让application.yml识别到我在application-dev.yml里设置的值呢？</strong></span></p>
<pre><code class="yaml">server:
  port: 8080

spring:
  profiles:
    active: dev

你已经在 application.yml 中指定了 spring.profiles.active: dev，这样在启动应用程序时，Spring Boot 会自动加载 application-dev.yml 中的配置

如果你使用的是 IDE（如 IntelliJ IDEA 或 Eclipse），你可以在运行配置中指定激活的环境配置文件。例如，在 IntelliJ IDEA 中：
打开 Run -&gt; Edit Configurations。
选择你的应用程序配置。
在 VM options 中添加 -Dspring.profiles.active=dev。

# 在 VM options 中配置的原理：
在 VM options 中添加 -Dspring.profiles.active=dev 的原理是通过 Java 虚拟机（JVM）的系统属性来设置 Spring Boot 应用程序的活动配置文件。以下是详细的解释：
原理
JVM 系统属性：
JVM 提供了一种机制，允许你在启动时通过命令行参数传递系统属性。这些系统属性可以在应用程序中通过 System.getProperty 方法访问。
-D 前缀用于设置系统属性。例如，-Dkey=value 会将 key 设置为 value。
Spring Boot 配置：
Spring Boot 会读取 spring.profiles.active 系统属性来确定当前激活的配置文件。
当你通过 -Dspring.profiles.active=dev 设置系统属性时，Spring Boot 会在启动时读取这个属性，并根据其值加载相应的配置文件（如 application-dev.yml）。
</code></pre>
<h6 id="新增菜品重要代码"><a href="#新增菜品重要代码" class="headerlink" title="新增菜品重要代码"></a>新增菜品重要代码</h6><pre><code class="java">sky-pojo  com/sky/dto/DishDTO.java
package com.sky.dto;

import com.sky.entity.DishFlavor;
import lombok.Data;
import java.io.Serializable;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Data
public class DishDTO implements Serializable &#123;
    //dish属性封装成dto

    private Long id;
    //菜品名称
    private String name;
    //菜品分类id
    private Long categoryId;
    //菜品价格
    private BigDecimal price;
    //图片
    private String image;
    //描述信息
    private String description;
    //0 停售 1 起售
    private Integer status;
    //口味[因为有多种口味要区分]
    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();

&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/entity/DishFlavor.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 菜品口味
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DishFlavor implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;
    //菜品id
    private Long dishId;

    //口味名称
    private String name;

    //口味数据list
    private String value;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
package com.sky.controller.admin;

import com.sky.dto.DishDTO;
import com.sky.result.Result;
import com.sky.service.DishService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 菜品管理
 */
@RestController
@RequestMapping(&quot;/admin/dish&quot;)
@Api(tags = &quot;菜品相关接口&quot;)
@Slf4j
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @PostMapping
    @ApiOperation(&quot;新增菜品&quot;)
    //@RequestBody 封装JSON格式的数据
    public Result save(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);
        dishService.saveWithFlavour(dishDTO);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);
&#125;
</code></pre>
<pre><code class="java">com/sky/service/impl/DishServiceImpl.java
package com.sky.service.impl;

import com.sky.dto.DishDTO;
import com.sky.entity.Dish;
import com.sky.entity.DishFlavor;
import com.sky.mapper.DishFlavorMapper;
import com.sky.mapper.DishMapper;
import com.sky.service.DishService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@Slf4j

public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    @Override
    @Transactional //保证事务一致性
    public void saveWithFlavour(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        //直接new出来是空的需要先赋值 属性拷贝[属性命名要一致]
        BeanUtils.copyProperties(dishDTO,dish);

        // 向菜品表插入1条数据
        dishMapper.insert(dish);
        // 前端无法传 要获取dishId
// &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; 获取主键值
        Long dishId = dish.getId();

        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishId);
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
package com.sky.mapper;

import com.sky.annotation.AutoFill;
import com.sky.entity.Dish;
import com.sky.enumeration.OperationType;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface DishMapper &#123;

    /**
     * 根据分类id查询菜品数量
     * @param categoryId
     * @return
     */
    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long categoryId);

    /**
     * 插入菜品数据
     */
    @AutoFill(value = OperationType.INSERT)
    void insert(Dish dish);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/DishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;
    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,
                          update_user, status)
        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;,
                #&#123;updateUser&#125;, #&#123;status&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
package com.sky.mapper;

import com.sky.entity.DishFlavor;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface DishFlavorMapper &#123;
    /**
     * 批量插入口味数据
     */
    void insertBatch(List&lt;DishFlavor&gt; flavors);
&#125;
</code></pre>
<pre><code class="java">sky-server  mapper/DishFlavorMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishFlavorMapper&quot;&gt;

    &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish_flavor (dish_id, name, value) values
        &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;
            (#&#123;df.dishId&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="菜品分页查询"><a href="#菜品分页查询" class="headerlink" title="菜品分页查询"></a>菜品分页查询</h3><blockquote>
<p>菜品名称[         ]     菜品分类[         ]     售卖状态[         ]         [搜索]<br>菜品名称、图片、菜品分类、售价、售卖状态、最后操作事件、操作[修改 删除 启售,停售]<br>                                                                                                                            右下角 分页操作</p>
</blockquote>
<h6 id="业务规则：-3"><a href="#业务规则：-3" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>根据页码展示菜品信息</li>
<li>每页展示10条数据</li>
<li>分页查询时可以根据需要输入<strong>菜品名称、菜品分类、菜品状态</strong>进行查询</li>
</ul>
<h6 id="接口设计：-2"><a href="#接口设计：-2" class="headerlink" title="接口设计："></a>接口设计：</h6><p><strong>Path</strong>：&#x2F;admin&#x2F;dish&#x2F;page<br><strong>Method</strong>：GET</p>
<h6 id="代码开发："><a href="#代码开发：" class="headerlink" title="代码开发："></a>代码开发：</h6><p>根据菜品分页查询接口定义设计对应的<strong>DTO</strong><br>根据菜品分页查询接口定义设计对应的<strong>VO</strong>[转成Json数据给前端]</p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
@GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;菜品分页查询&quot;)
    public Result&lt;PageResult&gt; page(DishPageQueryDTO dishPageQueryDTO)&#123;
        log.info(&quot;菜品分页查询：&#123;&#125;&quot;, dishPageQueryDTO);
        PageResult pageResult = dishService.pageQuery(dishPageQueryDTO);
        return Result.success(pageResult);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.result.PageResult;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
@Service
@Slf4j
public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
 @Override
    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;
  // 1. 开启分页功能，设置当前页和每页显示的数量
        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
 // 2. 调用 dishMapper 的 pageQuery 方法进行分页查询，返回一个 Page&lt;DishVO&gt; 对象
        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);
     // 3. 创建并返回 PageResult 对象，包含总记录数和查询结果列表
        return new PageResult(page.getTotal(), page.getResult());
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    Page&lt;DishVO&gt; pageQuery(DishPageQueryDTO dishPageQueryDTO);
</code></pre>
<pre><code class="mysql">sky-server  mapper/DishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;
    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,
                          update_user, status)
        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;,
                #&#123;updateUser&#125;, #&#123;status&#125;)
    &lt;/insert&gt;
    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;
        select d.*, c.name as categoryName
        from dish d
            left join category c
                on d.category_id=c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and d.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and d.status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by d.update_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><span style="color:orange"><strong>分页查询SQL语句分析</strong></span></p>
<blockquote>
<pre><code class="mysql">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;
        select d.*, c.name as categoryName
        from dish d
            left join category c
                on d.category_id=c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and d.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and d.status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by d.update_time desc
    &lt;/select&gt;
</code></pre>
<p>从 dish 表中选择所有列，并从 category 表中选择 name 列，别名为 categoryName。<br>使用左连接 (left join) 将 dish 表和 category 表连接起来，连接条件是 d.category_id &#x3D; c.id。</p>
<p>动态生成WHERE子句，&lt; where &gt;标签会自动处理AND和OR关键字的添加，并且会忽略第一个条件前的ADN和OR</p>
</blockquote>
<h3 id="删除菜品"><a href="#删除菜品" class="headerlink" title="删除菜品"></a>删除菜品</h3><blockquote>
<p>单个删除、批量删除、先停售后删除</p>
</blockquote>
<h6 id="业务规则：-4"><a href="#业务规则：-4" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>可以一次删除一个菜品，也可以批量删除菜品</li>
</ul>
<blockquote>
<p><strong>Path</strong>: &#x2F;admin&#x2F;dish<br><strong>Method</strong>: DELETE<br><strong>数据库设计</strong>：<br>dish表 → id 【菜品】<br>dish_flavor表 → dish_id 【口味】<br>setmeal_dish表 → dish_id</p>
</blockquote>
<ul>
<li>起售中的菜品不能删除</li>
<li>被套餐关联的菜品不能删除</li>
<li>删除菜品后，关联的口味数据也需要删除</li>
</ul>
<h6 id="代码开发：-1"><a href="#代码开发：-1" class="headerlink" title="代码开发："></a>代码开发：</h6><pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除菜品&quot;)
    //@RequestParam MVC动态解析字符串 ids提取出来
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123; //ids
        log.info(&quot;批量删除菜品：&#123;&#125;&quot;, ids);
        dishService.deleteBatch(ids);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    void deleteBatch(List&lt;Long&gt; ids);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @Override
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        // 判断当前菜品是否能够删除--是否存在起售中的菜品？？ 取出id
        for (Long id : ids) &#123;
            Dish dish = dishMapper.getById(id);
            if (dish.getStatus() == StatusConstant.ENABLE) &#123;
                //当前菜品处于起售中，不能删除
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            &#125;
        &#125;

        // 判断当前菜品是否能够删除--是否被套餐关联了
        List&lt;Long&gt; setMealIds = setmealDishMapper.getSetmealIdsByDishId(ids);
        if (setMealIds != null &amp;&amp; setMealIds.size() &gt; 0) &#123; //存在不允许删除
            // 当前菜品被套餐关联了，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        &#125;
        // 删除菜品表中的菜品数据
        for (Long id : ids) &#123;
            dishMapper.deleteById(id);
            // 删除菜品关联的口味数据
            dishFlavorMapper.deleteByDishId(id);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 根据主键删除菜品数据
     */

    @Delete(&quot;delete from dish where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
/**
     * 根据菜品id删除对应的 口味数据
     * @param id
     */
    @Delete(&quot;delete from dish_flavor where dish_id = #&#123;id&#125;&quot;)
    void deleteByDishId(Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealDishMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface SetmealDishMapper &#123;
    /**
     * 根据菜品id查询对应的套餐id
     * @param dishIds
     * @return
     */
    // select setmeal_id from setmeal_dish where dish_id in (1,2,3)
    // 在mapper.xml中dishIds是形参  &lt;foreach collection=&quot;dishIds&quot;&gt;
    List&lt;Long&gt; getSetmealIdsByDishId(List&lt;Long&gt; dishIds);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealDishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealDishMapper&quot;&gt;

    &lt;select id=&quot;getSetmealIdsByDishId&quot; resultType=&quot;java.lang.Long&quot;&gt;
        SELECT setmeal_id
        FROM setmeal_dish
        WHERE dish_id IN
        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
           #&#123;dishId&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
&lt;/mapper&gt;

&lt;!--
★ foreach 标签用于遍历集合，并生成相应的 SQL 语句。
★ collection=&quot;dishIds&quot;：指定要遍历的集合名称，即传入的参数 dishIds。
★ item=&quot;dishId&quot;：指定集合中的每个元素的别名，即每次迭代时的变量名。
★ separator=&quot;,&quot;：指定每个元素之间的分隔符，这里是逗号 ,。
★ open=&quot;(&quot; 和 close=&quot;)&quot;：指定生成的 SQL 语句的开始和结束符号，这里是括号 ( 和 )。
--&gt;
</code></pre>
<p><span style="color:orange">@<strong>RequestParm详细分析</strong></span></p>
<blockquote>
<p><code>public Result delete(@RequestParam List&lt;Long&gt; ids)</code></p>
<p><code>@RequestParam</code>：注解用于将请求参数绑定到方法参数上。具体来说，它可以从请求的查询参数中提取出指定的参数值，并将其转换为方法参数的类型；在这个例子中，@RequestParam List<Long> ids 表示从请求的查询参数中提取 ids 参数，并将其转换为 List<Long> 类型。</p>
</blockquote>
<h3 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h3><h6 id="数据回显"><a href="#数据回显" class="headerlink" title="数据回显"></a>数据回显</h6><p><strong>接口设计：</strong></p>
<ul>
<li>根据id查询菜品</li>
</ul>
<blockquote>
<p>口味也要回显<br><strong>Path:</strong>  &#x2F;admin&#x2F;dish&#x2F;{id}<br><strong>Method：</strong>GET</p>
</blockquote>
<ul>
<li>根据类型查询分类(已实现)</li>
<li>文件上传(已实现)</li>
<li>修改菜品</li>
</ul>
<blockquote>
<p>根据ID修改<br><strong>Path：</strong>&#x2F;admin&#x2F;dish<br><strong>Method：</strong>PUT</p>
</blockquote>
<h6 id="代码开发：-2"><a href="#代码开发：-2" class="headerlink" title="代码开发："></a>代码开发：</h6><p><strong>根据id查询菜品进行信息回显</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询菜品&quot;)
//  @PathVariable 注解用于从 URL 路径中的占位符参数中提取值，并将其绑定到方法参数上
    public Result&lt;DishVO&gt; getById(@PathVariable long id) &#123;
        log.info(&quot;根据id查询菜品：&#123;&#125;&quot;, id);
        DishVO dishVO = dishService.getByIdWithFlavor(id);
        return Result.success(dishVO);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    DishVO getByIdWithFlavor(long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @Override
    public DishVO getByIdWithFlavor(long id) &#123;
        // 根据id查询菜品数据
        Dish dish = dishMapper.getById(id);
        // 根据菜品id查询口味数据
        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);

        // 将查询到的数据封装到VO
        DishVO dishVO = new DishVO();
            // 属性拷贝
        BeanUtils.copyProperties(dish,dishVO);
        dishVO.setFlavors(dishFlavors);

        return dishVO;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
/**
     * 根据菜品id查询对应的口味数据
     * @param id
     * @return
     */
    @Select(&quot;select * from dish_flavor where dish_id = #&#123;id&#125;&quot;)
    List&lt;DishFlavor&gt; getByDishId(long id);
</code></pre>
<p><strong>修改菜品接口</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改菜品&quot;)
    public Result update(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);
        dishService.updateWithFlavor(dishDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    void updateWithFlavor(DishDTO dishDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    @Override
    public void updateWithFlavor(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // 修改菜品表基本信息 只是基础信息噢
        dishMapper.update(dish);
        // 先删掉原先的
        dishFlavorMapper.deleteByDishId(dishDTO.getId());
        // 再重新插入新的
        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishDTO.getId());
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;
/*
这段代码中，将 dishDTO 的属性复制到 dish 对象的主要原因有以下几点：
数据模型分离：
dishDTO 通常用于数据传输，包含前端传来的所有数据。
dish 是数据库实体类，只包含数据库表中的字段。
安全性：
使用 BeanUtils.copyProperties 可以避免将不必要的字段（如前端传来的额外属性）写入数据库。
确保只有预期的字段被更新。
数据校验：
dishDTO 可以包含更多的验证逻辑或额外的属性，而 dish 对象则严格遵循数据库模型。
通过这种方式，可以在更新前对数据进行进一步校验。
事务管理：
添加 @Transactional 注解确保整个更新过程在一个事务中完成。
如果任何一步出错，整个事务都会回滚，保证数据一致性。
*/
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
 /**
     * 根据id修改菜品和对应的口味数据
     * @param dish
     */
    //有时间和修改人 不要忘记自动填充
    @AutoFill(value = OperationType.UPDATE)
    void update(Dish dish);
</code></pre>
<pre><code class="xml">sky-server  mapper/DishMapper.xml
&lt;update id=&quot;update&quot;&gt;
        update dish
        &lt;set&gt;
            &lt;if
                test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
</code></pre>
<h5 id="菜品起售停售"><a href="#菜品起售停售" class="headerlink" title="菜品起售停售"></a>菜品起售停售</h5><pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;菜品起售停售&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id) &#123;
        dishService.startOrStop(status, id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 菜品起售停售
     * @param status
     * @param id
     */
@Override
    public void startOrStop(Integer status, Long id) &#123;
        Dish dish = Dish.builder()
                .id(id)
                .status(status)
                .build();
        dishMapper.update(dish);

        if (status == StatusConstant.DISABLE) &#123;
            // 如果是停售操作，还需要将包含当前菜品的套餐也停售
            List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();
            dishIds.add(id);
            // select setmeal_id from setmeal_dish where dish_id in (?,?,?)
            List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);
            if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;
                for (Long setmealId : setmealIds) &#123;
                    Setmeal setmeal = Setmeal.builder()
                            .id(setmealId)
                            .status(StatusConstant.DISABLE)
                            .build();
                    setmealMapper.update(setmeal);
                &#125;
            &#125;

        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
/**
     * 根据id修改套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.UPDATE)
    void update(Setmeal setmeal);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java

    /**
     * 根据套餐id查询菜品
     * @param setmealId
     * @return
     */
    @Select(&quot;select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = #&#123;setmealId&#125;&quot;)
    List&lt;Dish&gt; getBySetmealId(Long setmealId);
/*
在 SQL 查询中添加筛选条件。
确保返回的结果集中，setmeal_dish 表中的 setmeal_id 字段值与传入的 setmealId 参数值相匹配，从而获取与指定套餐 ID 相关的菜品列表。
*/
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;
    &lt;resultMap id=&quot;setmealAndDishMap&quot; type=&quot;com.sky.vo.SetmealVO&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;setmealDishes&quot; ofType=&quot;SetmealDish&quot;&gt;
            &lt;result column=&quot;sd_id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;setmeal_id&quot; property=&quot;setmealId&quot;/&gt;
            &lt;result column=&quot;dish_id&quot; property=&quot;dishId&quot;/&gt;
            &lt;result column=&quot;sd_name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;sd_price&quot; property=&quot;price&quot;/&gt;
            &lt;result column=&quot;copies&quot; property=&quot;copies&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;
        update setmeal
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                category_id = #&#123;categoryId&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;price != null&quot;&gt;
                price = #&#123;price&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;description != null&quot;&gt;
                description = #&#123;description&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;image != null&quot;&gt;
                image = #&#123;image&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">@Mapper
public interface SetmealDishMapper &#123;
    /**
     * 根据菜品id查询对应的套餐id
     * @param dishIds
     * @return
     */
    // select setmeal_id from setmeal_dish where dish_id in (1,2,3)
    // 在mapper.xml中dishIds是形参  &lt;foreach collection=&quot;dishIds&quot;&gt;
    List&lt;Long&gt; getSetmealIdsByDishIds(List&lt;Long&gt; dishIds);
</code></pre>
<pre><code class="xml">SetmealDishMapper.xml
&lt;select id=&quot;getSetmealIdsByDishIds&quot; resultType=&quot;java.lang.Long&quot;&gt;
        select setmeal_id from setmeal_dish where dish_id in
        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
            #&#123;dishId&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
</code></pre>
<h4 id="修改套餐那些事"><a href="#修改套餐那些事" class="headerlink" title="修改套餐那些事"></a>修改套餐<del>那些事</del></h4><pre><code class="java">sky-server  com/sky/controller/admin/SetmealController.java
package com.sky.controller.admin;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.result.PageResult;
import com.sky.result.Result;
import com.sky.service.SetmealService;
import com.sky.vo.SetmealVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * 套餐管理
 */
@RestController
@RequestMapping(&quot;/admin/setmeal&quot;)
@Api(tags = &quot;套餐相关接口&quot;)
@Slf4j
public class SetmealController &#123;

    @Autowired
    private SetmealService setmealService;

    /**
     * 新增套餐
     *
     * @param setmealDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,key = &quot;#setmealDTO.categoryId&quot;)//key: setmealCache::100
    public Result save(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.saveWithDish(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;分页查询&quot;)
    public Result&lt;PageResult&gt; page(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        PageResult pageResult = setmealService.pageQuery(setmealPageQueryDTO);
        return Result.success(pageResult);
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;
        setmealService.deleteBatch(ids);
        return Result.success();
    &#125;

    /**
     * 根据id查询套餐，用于修改页面回显数据
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询套餐&quot;)
    public Result&lt;SetmealVO&gt; getById(@PathVariable Long id) &#123;
        SetmealVO setmealVO = setmealService.getByIdWithDish(id);
        return Result.success(setmealVO);
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result update(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.update(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 套餐起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;套餐起售停售&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result startOrStop(@PathVariable Integer status, Long id) &#123;
        setmealService.startOrStop(status, id);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/SetmealService.java
package com.sky.service;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.result.PageResult;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;

import java.util.List;

public interface SetmealService &#123;

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    void saveWithDish(SetmealDTO setmealDTO);

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询套餐和关联的菜品数据
     *
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    void update(SetmealDTO setmealDTO);

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    List&lt;DishItemVO&gt; getDishItemById(Long id);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/SetmealServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.SetmealDish;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.exception.SetmealEnableFailedException;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 套餐业务实现
 */
@Service
@Slf4j
public class SetmealServiceImpl implements SetmealService &#123;

    @Autowired
    private SetmealMapper setmealMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private DishMapper dishMapper;


    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    @Transactional
    public void saveWithDish(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //向套餐表插入数据
        setmealMapper.insert(setmeal);

        //获取生成的套餐id
        Long setmealId = setmeal.getId();

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);

        //保存套餐和菜品的关联关系
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        int pageNum = setmealPageQueryDTO.getPage();
        int pageSize = setmealPageQueryDTO.getPageSize();

        PageHelper.startPage(pageNum, pageSize);
        Page&lt;SetmealVO&gt; page = setmealMapper.pageQuery(setmealPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        ids.forEach(id -&gt; &#123;
            Setmeal setmeal = setmealMapper.getById(id);
            if (StatusConstant.ENABLE == setmeal.getStatus()) &#123;
                //起售中的套餐不能删除
                throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
            &#125;
        &#125;);

        ids.forEach(setmealId -&gt; &#123;
            //删除套餐表中的数据
            setmealMapper.deleteById(setmealId);
            //删除套餐菜品关系表中的数据
            setmealDishMapper.deleteBySetmealId(setmealId);
        &#125;);
    &#125;
/**
ids.forEach(id -&gt; &#123; ... &#125;)：对ids集合中的每个元素id执行大括号内的操作。
id -&gt; &#123; ... &#125;：定义了一个接受单个参数id的函数，并执行大括号内的逻辑。
在大括号内，根据id查询数据库获取套餐信息，并检查其状态，若状态符合启用条件，则抛出异常。
**/
    
    /**
     * 根据id查询套餐和套餐菜品关系
     *
     * @param id
     * @return
     */
    public SetmealVO getByIdWithDish(Long id) &#123;
        SetmealVO setmealVO = setmealMapper.getByIdWithDish(id);
        return setmealVO;
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    @Transactional
    public void update(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //1、修改套餐表，执行update
        setmealMapper.update(setmeal);

        //套餐id
        Long setmealId = setmealDTO.getId();

        //2、删除套餐和菜品的关联关系，操作setmeal_dish表，执行delete
        setmealDishMapper.deleteBySetmealId(setmealId);

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);
        //3、重新插入套餐和菜品的关联关系，操作setmeal_dish表，执行insert
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        //起售套餐时，判断套餐内是否有停售菜品，有停售菜品提示&quot;套餐内包含未启售菜品，无法启售&quot;
        if (status == StatusConstant.ENABLE) &#123;
            //select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = ?
            List&lt;Dish&gt; dishList = dishMapper.getBySetmealId(id);
            if (dishList != null &amp;&amp; dishList.size() &gt; 0) &#123;
                dishList.forEach(dish -&gt; &#123;
                    if (StatusConstant.DISABLE == dish.getStatus()) &#123;
                        throw new SetmealEnableFailedException(MessageConstant.SETMEAL_ENABLE_FAILED);
                    &#125;
                &#125;);
            &#125;
        &#125;

        Setmeal setmeal = Setmeal.builder()
                .id(id)
                .status(status)
                .build();
        setmealMapper.update(setmeal);
    &#125;

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    public List&lt;Setmeal&gt; list(Setmeal setmeal) &#123;
        List&lt;Setmeal&gt; list = setmealMapper.list(setmeal);
        return list;
    &#125;

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    public List&lt;DishItemVO&gt; getDishItemById(Long id) &#123;
        return setmealMapper.getDishItemBySetmealId(id);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.annotation.AutoFill;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.enumeration.OperationType;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;
import java.util.Map;

@Mapper
public interface SetmealMapper &#123;

    /**
     * 根据分类id查询套餐的数量
     *
     * @param id
     * @return
     */
    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long id);

    /**
     * 根据id修改套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.UPDATE)
    void update(Setmeal setmeal);

    /**
     * 新增套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.INSERT)
    void insert(Setmeal setmeal);

    /**
     * 分页查询
     * @param setmealPageQueryDTO
     * @return
     */
    Page&lt;SetmealVO&gt; pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 根据id查询套餐
     * @param id
     * @return
     */
    @Select(&quot;select * from setmeal where id = #&#123;id&#125;&quot;)
    Setmeal getById(Long id);

    /**
     * 根据id删除套餐
     * @param setmealId
     */
    @Delete(&quot;delete from setmeal where id = #&#123;id&#125;&quot;)
    void deleteById(Long setmealId);

    /**
     * 根据id查询套餐和套餐菜品关系
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 动态条件查询套餐
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据套餐id查询菜品选项
     * @param setmealId
     * @return
     */
    @Select(&quot;select sd.name, sd.copies, d.image, d.description &quot; +
            &quot;from setmeal_dish sd left join dish d on sd.dish_id = d.id &quot; +
            &quot;where sd.setmeal_id = #&#123;setmealId&#125;&quot;)
    List&lt;DishItemVO&gt; getDishItemBySetmealId(Long setmealId);

    /**
     * 根据条件统计套餐数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;
    &lt;resultMap id=&quot;setmealAndDishMap&quot; type=&quot;com.sky.vo.SetmealVO&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;setmealDishes&quot; ofType=&quot;SetmealDish&quot;&gt;
            &lt;result column=&quot;sd_id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;setmeal_id&quot; property=&quot;setmealId&quot;/&gt;
            &lt;result column=&quot;dish_id&quot; property=&quot;dishId&quot;/&gt;
            &lt;result column=&quot;sd_name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;sd_price&quot; property=&quot;price&quot;/&gt;
            &lt;result column=&quot;copies&quot; property=&quot;copies&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;
        update setmeal
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                category_id = #&#123;categoryId&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;price != null&quot;&gt;
                price = #&#123;price&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;description != null&quot;&gt;
                description = #&#123;description&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;image != null&quot;&gt;
                image = #&#123;image&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

&lt;!--
    &lt;insert&gt;：表示这是一个插入操作。
    id=&quot;insert&quot;：指定这个 SQL 语句的唯一标识符，通常用于在 MyBatis 映射文件中引用此 SQL 语句。
    parameterType=&quot;Setmeal&quot;：指定插入操作的参数类型为 Setmeal 类型。
    useGeneratedKeys=&quot;true&quot;：指示 MyBatis 在执行插入操作后自动获取自动生成的主键。
    keyProperty=&quot;id&quot;：指定将自动生成的主键值设置到对象的 id 属性上。
--&gt;
    &lt;insert id=&quot;insert&quot; parameterType=&quot;Setmeal&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into setmeal
        (category_id, name, price, status, description, image, create_time, update_time, create_user, update_user)
        values (#&#123;categoryId&#125;, #&#123;name&#125;, #&#123;price&#125;, #&#123;status&#125;, #&#123;description&#125;, #&#123;image&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;,
                #&#123;createUser&#125;, #&#123;updateUser&#125;)
    &lt;/insert&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.SetmealVO&quot;&gt;
        select
        s.*,c.name categoryName
        from
        setmeal s
        left join
        category c
        on
        s.category_id = c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                and s.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and s.status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and s.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by s.create_time desc
    &lt;/select&gt;

    &lt;select id=&quot;getByIdWithDish&quot; parameterType=&quot;long&quot; resultMap=&quot;setmealAndDishMap&quot;&gt;
        select a.*,
               b.id    sd_id,
               b.setmeal_id,
               b.dish_id,
               b.name  sd_name,
               b.price sd_price,
               b.copies
        from setmeal a
                 left join
             setmeal_dish b
             on
                 a.id = b.setmeal_id
        where a.id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;list&quot; parameterType=&quot;Setmeal&quot; resultType=&quot;Setmeal&quot;&gt;
        select * from setmeal
        &lt;where&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;

    &lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from setmeal
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="Redis入门-调整营业状态"><a href="#Redis入门-调整营业状态" class="headerlink" title="Redis入门 [调整营业状态]"></a>Redis入门 [调整营业状态]</h3><p>Redis是一个基于<strong>内存</strong>的 key-value 结构数据库</p>
<ul>
<li>基于内存存储，读写性能高</li>
<li>适合存储热点数据 (热点商品、资讯、新闻) 访问量较大</li>
<li>企业应用广泛</li>
</ul>
<h3 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h3><h5 id="Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型："><a href="#Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：" class="headerlink" title="Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型："></a>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</h5><ul>
<li>字符串 string：普通字符串</li>
<li>哈希 hash：散列，类似于java中的HashMap结构</li>
<li>列表 list：按照插入顺序排序，可以有重复元素，类似于java中的LinkedList</li>
<li>集合 set：无序集合，没有重复元素，类似于java中的HashSet</li>
<li>有序集合 sorted set &#x2F; zset：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素</li>
</ul>
<h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><ul>
<li><p><strong>字符串操作命令</strong></p>
<blockquote>
<p>ValueOperations valueOperations &#x3D; redisTemplate.opsForValue();</p>
</blockquote>
<ul>
<li>SET key value                      设置指定key的值</li>
<li>GET key                                获取指定key的值</li>
<li>SETEX key seconds value  设置指定key的值，并将key的过期时间设为 seconds秒</li>
<li>SETNX key value                 只有在key不存在时设置key的值</li>
</ul>
</li>
<li><p><strong>哈希操作命令</strong> [<strong>key → value(field1 value1,  field2 value2)</strong>]</p>
<blockquote>
<p>HashOperations hashOperations &#x3D; redisTemplate.opsForHash();</p>
</blockquote>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</p>
<ul>
<li>HSET key field value   将哈希表key中的字段field的值设为value</li>
<li>HGET key field             获取存储在哈希表中指定字段的值</li>
<li>HDEL key field             删除存储在哈希表中的指定字段</li>
<li>HKEYS key                    获取哈希表中所有字段</li>
<li>HVALS key                    获取哈希表中所有值</li>
</ul>
</li>
<li><p><strong>列表操作命令</strong></p>
<blockquote>
<p>ListOperations listOperations &#x3D; redisTemplate.opsForList();</p>
</blockquote>
<ul>
<li>LPUSH key value1 [value2]      将一个或多个值插入到列表头部</li>
<li>LRANGE key start stop             获取列表指定范围内的元素</li>
<li>RPOP key                                    移除并获取列表最后一个元素</li>
<li>LLEN key                                     获取列表长度</li>
</ul>
</li>
<li><p><strong>集合操作命令</strong></p>
<blockquote>
<p>SetOperations setOperations &#x3D; redisTemplate.opsForSet();</p>
</blockquote>
<p>Redis set是string类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据</p>
<ul>
<li>SADD key member1 [member2]           向集合添加一个或多个成员 [无序插入]</li>
<li>SMEMBERS key                                         返回集合中的所有成员</li>
<li>SCARD key                                                  获取集合的成员数</li>
<li>SINTER key1 [key2]                                   返回给定所有集合的交集</li>
<li>SUNION key1 [key2]                                 返回所有给定集合的并集</li>
<li>SREM key member1 [member2]            删除集合中一个或多个成员</li>
</ul>
</li>
<li><p><strong>有序列表操作命令</strong></p>
<blockquote>
<p>ZSetOperations zSetOperations &#x3D; redisTemplate.opsForZSet();</p>
</blockquote>
<p>Redis有序集合是string类型元素的集合，且不允许重复成员。每个元素都会关联一个double类型的分数</p>
<ul>
<li>ZADD key score1 member1 [score2 member2]  向有序集合添加一个或多个成员</li>
<li>ZRANGE key start stop [WITHSCORES]                 通过索引区间返回有序集合中指定区间内的成员</li>
<li>ZINCRBY key increment member                          有序集合中对指定成员的分数加上增量increment</li>
<li>ZREM key member [member …]                            移除有序集合中的一个或多个成员</li>
</ul>
</li>
<li><p><strong>通用命令</strong></p>
<p>Redis的通用命令是不分数据类型的，都可以使用的命令</p>
<ul>
<li>KEYS pattern            查找所有符合给定模式(pattern)的key</li>
<li>EXISTS key                检查给定key是否存在</li>
<li>TYPE key                   返回key所存储的值的类型</li>
<li>DEL key                     该命令用于在key存在是删除key</li>
</ul>
</li>
</ul>
<h3 id="在java中操作Redis-SpringDataRedis"><a href="#在java中操作Redis-SpringDataRedis" class="headerlink" title="在java中操作Redis_SpringDataRedis"></a>在java中操作Redis_SpringDataRedis</h3><p><span style = "color:red">序列化器：<strong>redisTemplate.setKeySerializer(new StringRedisSerializer());</strong></span></p>
<h6 id="Redis的Java客户端很多"><a href="#Redis的Java客户端很多" class="headerlink" title="Redis的Java客户端很多"></a>Redis的Java客户端很多</h6><ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Spring Data Redis</li>
</ul>
<p>Spring Data Redis 是 Spring 的一部分，对Redis底层开发包进行了高度封装<br>在Spring项目中，可以使用Spring Data Redis来简化操作</p>
<h5 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h5><ul>
<li><p>导入Spring Data Redis的maven坐标</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>配置Redis数据源</p>
<pre><code class="yaml">spring:
 redis:
  host: localhost
  port: 6379
  password:
</code></pre>
</li>
<li><p>编写配置类，创建RedisTemplate对象</p>
<pre><code class="java">package com.sky.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@Slf4j
public class RedisConfiguration &#123;

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
        log.info(&quot;开始创建redis模板对象...&quot;);
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis key的序列化器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    &#125;
&#125;
</code></pre>
</li>
<li><p>通过RedisTemplate对象操作Redis</p>
</li>
</ul>
<h6 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h6><pre><code class="yaml">application.yml
  redis:
    host: $&#123;sky.redis.host&#125;
    port: $&#123;sky.redis.port&#125;
    database: $&#123;sky.redis.database&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
  redis:
    host: localhost
    port: 6379
    database: 1
</code></pre>
<pre><code class="java">sky-server  com/sky/config/RedisConfiguration.java
package com.sky.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@Slf4j
public class RedisConfiguration &#123;
    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
        log.info(&quot;开始创建redis模板对象...&quot;);
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis key的序列化器 在图形化界面不出现乱码
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server【测试类】 com/sky/test/SpringDataRedisTest.java
package com.sky.test;

import com.mysql.cj.util.TimeUtil;
import net.sf.jsqlparser.statement.select.KSQLWindow;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.*;

import java.util.concurrent.TimeUnit;

@SpringBootTest //测试完记得注释 不然每次启动类就会运行这个测试类
public class SpringDataRedisTest &#123;
    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void testRedisTemplate()&#123;
        System.out.println(redisTemplate);
        //创建根据字符串、哈希、列表、集合、有序列表、通用命令的代码
        ValueOperations valueOperations = redisTemplate.opsForValue();
        HashOperations hashOperations = redisTemplate.opsForHash();
        ListOperations listOperations = redisTemplate.opsForList();
        SetOperations setOperations = redisTemplate.opsForSet();
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();
    &#125;

    /**
     * 操作字符串类型的数据
     */
    @Test
    public void testString()&#123;
        // set get setex setnx
        redisTemplate.opsForValue().set(&quot;city&quot;,&quot;北京&quot;);
        String city = (String) redisTemplate.opsForValue().get(&quot;city&quot;);
        System.out.println(city); // 北京

        redisTemplate.opsForValue().set(&quot;code&quot;, &quot;1234&quot;, 3, TimeUnit.MINUTES);
        // 第一次调用可以设置成功
        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1&quot;);
        // 第二次不可以成功
        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;2&quot;);
        Object lock = redisTemplate.opsForValue().get(&quot;lock&quot;);
        System.out.println(lock); // 1

        Object lock2 = redisTemplate.opsForValue().get(&quot;locwwk&quot;);
        System.out.println(lock2);// null
    &#125;
    
    /**
     * 操作哈希类型的数据
     */
    @Test
    public void testHash()&#123;
        //hset hget hdel hkeys havls
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.put(&quot;100&quot;,&quot;name&quot;,&quot;tom&quot;);
        hashOperations.put(&quot;100&quot;,&quot;age&quot;,&quot;20&quot;);

        String name = (String) hashOperations.get(&quot;100&quot;,&quot;name&quot;);
        System.out.println(name);

        Set keys = hashOperations.keys(&quot;100&quot;);
        System.out.println(keys);

        List values = hashOperations.values(&quot;100&quot;);
        System.out.println(values);

        hashOperations.delete(&quot;100&quot;,&quot;age&quot;);
/**
     * 操作列表类型的数据
     */
    @Test
    public void testList()&#123;
        //lpush lrange rpop llen
        ListOperations listOperations = redisTemplate.opsForList();

        listOperations.leftPushAll(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);
        listOperations.leftPush(&quot;mylist&quot;,&quot;d&quot;);

        List mylist = listOperations.range(&quot;mylist&quot;, 0, -1);
        System.out.println(mylist);

        listOperations.rightPop(&quot;mylist&quot;);

        Long size = listOperations.size(&quot;mylist&quot;);
        System.out.println(size);
    &#125;

    /**
     * 操作集合类型的数据
     */
    @Test
    public void testSet()&#123;
        //sadd smembers scard sinter sunion srem
        SetOperations setOperations = redisTemplate.opsForSet();

        setOperations.add(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
        setOperations.add(&quot;set2&quot;,&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;);

        Set members = setOperations.members(&quot;set1&quot;);
        System.out.println(members);

        Long size = setOperations.size(&quot;set1&quot;);
        System.out.println(size);

        Set intersect = setOperations.intersect(&quot;set1&quot;, &quot;set2&quot;);
        System.out.println(intersect);

        Set union = setOperations.union(&quot;set1&quot;, &quot;set2&quot;);
        System.out.println(union);

        setOperations.remove(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;);
    &#125;

    /**
     * 操作有序集合类型的数据
     */
    @Test
    public void testZset()&#123;
        //zadd zrange zincrby zrem
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();

        zSetOperations.add(&quot;zset1&quot;,&quot;a&quot;,10);
        zSetOperations.add(&quot;zset1&quot;,&quot;b&quot;,12);
        zSetOperations.add(&quot;zset1&quot;,&quot;c&quot;,9);

        Set zset1 = zSetOperations.range(&quot;zset1&quot;, 0, -1);
        System.out.println(zset1);

        zSetOperations.incrementScore(&quot;zset1&quot;,&quot;c&quot;,10);

        zSetOperations.remove(&quot;zset1&quot;,&quot;a&quot;,&quot;b&quot;);
    &#125;

    /**
     * 通用命令操作
     */
    @Test
    public void testCommon()&#123;
        //keys exists type del
        Set keys = redisTemplate.keys(&quot;*&quot;);
        System.out.println(keys);

        Boolean name = redisTemplate.hasKey(&quot;name&quot;);
        Boolean set1 = redisTemplate.hasKey(&quot;set1&quot;);

        for (Object key : keys) &#123;
            DataType type = redisTemplate.type(key);
            System.out.println(type.name());
        &#125;

        redisTemplate.delete(&quot;mylist&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="店铺营业状态设置-【存入Redis】"><a href="#店铺营业状态设置-【存入Redis】" class="headerlink" title="店铺营业状态设置 【存入Redis】"></a>店铺营业状态设置 【存入Redis】</h3><h6 id="接口设计：-3"><a href="#接口设计：-3" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>设置营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;admin&#x2F;shop&#x2F;{status}<br><strong>Method</strong>：PUT<br>status   1    店铺营业状态：1为营业，0为打样</p>
</blockquote>
</li>
<li><p>管理端查询营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;<strong>admin</strong>&#x2F;shop&#x2F;status<br><strong>Method</strong>：GET</p>
</blockquote>
</li>
<li><p>用户端查询营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;<strong>user</strong>&#x2F;shop&#x2F;status<br><strong>Method</strong>：GET</p>
</blockquote>
</li>
</ul>
<p>★ ★ <strong>本项目约定</strong> ★ ★</p>
<ul>
<li><strong>管理端</strong>发出的请求，统一使用**&#x2F;admin**作为前缀</li>
<li><strong>用户端</strong>发出的请求，统一使用**&#x2F;user**作为前缀</li>
</ul>
<p>营业状态数据存储方式：基于Redis的字符串来进行存储<br>key: SHOP_STATUS     value: 1                1为营业，0为打样</p>
<h6 id="代码开发：-3"><a href="#代码开发：-3" class="headerlink" title="代码开发："></a>代码开发：</h6><pre><code class="java">sky-server  com/sky/controller/admin/ShopController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;

@RestController(&quot;adminShopController&quot;)
@RequestMapping(&quot;/admin/shop&quot;)
@Api(tags = &quot;店铺相关接口&quot;)
@Slf4j
public class ShopController &#123;
    public static final String KEY = &quot;SHOP_STATUS&quot;;

    @Autowired
    private RedisTemplate redisTemplate;
    /**
     * 设置店铺营业状态
     * @param status
     * @return
     */
    @PutMapping(&quot;/&#123;status&#125;&quot;) //动态取到status
    @ApiOperation(&quot;设置店铺营业状态&quot;)
    public Result setStatus(@PathVariable Integer status) &#123;
        log.info(&quot;设置店铺的营业状态为：&#123;&#125;&quot;, status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        redisTemplate.opsForValue().set(KEY, status);
        return Result.success();
    &#125;

    /**
     * 获取店铺的营业状态
     * @return
     */
    @GetMapping(&quot;/status&quot;)
    @ApiOperation(&quot;获取店铺的营业状态&quot;)
    public Result&lt;Integer&gt; getStatus()&#123;
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info(&quot;获取到的店铺营业状态为：&#123;&#125;&quot;,status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        return Result.success(status);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/ShopController.java
package com.sky.controller.user;

import com.sky.result.Result;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;
//@RestController(&quot;userShopController&quot;) 指定了这个控制器的名称为 userShopController
//这有助于在应用中唯一标识这个控制器，便于管理和调用
@RestController(&quot;userShopController&quot;)
@RequestMapping(&quot;/user/shop&quot;)
@Api(tags = &quot;店铺相关接口&quot;)
@Slf4j
public class ShopController &#123;
    public static final String KEY = &quot;SHOP_STATUS&quot;;

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 获取店铺的营业状态
     * @return
     */
    @GetMapping(&quot;/status&quot;)
    @ApiOperation(&quot;获取店铺的营业状态&quot;)
    public Result&lt;Integer&gt; getStatus()&#123;
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info(&quot;获取到的店铺营业状态为：&#123;&#125;&quot;,status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        return Result.success(status);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
// 设置两个接口文档方便在前端文档处调试【管理端+用户端】
package com.sky.config;

import com.sky.interceptor.JwtTokenAdminInterceptor;
import com.sky.interceptor.JwtTokenUserInterceptor;
import com.sky.json.JacksonObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

import java.util.List;

/**
 * 配置类，注册web层相关组件
 */
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    @Autowired
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;
    @Autowired
    private JwtTokenUserInterceptor jwtTokenUserInterceptor;

    /**
     * 注册自定义拦截器
     * @param registry
     */
    protected void addInterceptors(InterceptorRegistry registry) &#123;
        log.info(&quot;开始注册自定义拦截器...&quot;);
        registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns(&quot;/admin/**&quot;)
                .excludePathPatterns(&quot;/admin/employee/login&quot;);

        registry.addInterceptor(jwtTokenUserInterceptor)
                .addPathPatterns(&quot;/user/**&quot;)
                .excludePathPatterns(&quot;/user/user/login&quot;)
                .excludePathPatterns(&quot;/user/shop/status&quot;);
    &#125;

    @Bean
    public Docket docket1()&#123;
        log.info(&quot;准备生成接口文档...&quot;);
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;管理端接口&quot;)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller.admin&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    @Bean
    public Docket docket2()&#123;
        log.info(&quot;准备生成接口文档...&quot;);
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;用户端接口&quot;)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller.user&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    /**
     * 设置静态资源映射，主要是访问接口文档（html、js、css）
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        log.info(&quot;开始设置静态资源映射...&quot;);
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;

    /**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        log.info(&quot;扩展消息转换器...&quot;);
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转化器加入容器中
        converters.add(0,converter);
    &#125;
&#125;
</code></pre>
<p><span style="color:orange"><strong>回顾拦截器原理</strong></span></p>
<h3 id="HttpClient-amp-微信小程序开发"><a href="#HttpClient-amp-微信小程序开发" class="headerlink" title="HttpClient &amp; 微信小程序开发"></a>HttpClient &amp; 微信小程序开发</h3><h5 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h5><p>HttpClient 是 Apache Jakarta Common下的子项目，可以用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
    &lt;version&gt;4.5.13&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>核心API：</p>
<ul>
<li>HttpClient</li>
<li><strong>HttpClients</strong></li>
<li>CloseableHttpClient</li>
<li>HttpGet</li>
<li>HttpPost</li>
</ul>
<p>发送请求步骤：</p>
<ul>
<li>创建HttpClient对象</li>
<li>创建Http请求对象</li>
<li>调用HttpClient的execute方法发送请求</li>
</ul>
<h5 id="发送GET方式请求-要先把项目跑起来"><a href="#发送GET方式请求-要先把项目跑起来" class="headerlink" title="发送GET方式请求 [要先把项目跑起来]"></a>发送GET方式请求 [要先把项目跑起来]</h5><pre><code class="java">sky-server  com/sky/test/HttpClientTest.java
package com.sky.test;

import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.IOException;

@SpringBootTest
public class HttpClientTest &#123;
    /**
     * 测试通过httpclient发送GET方式的请求
     */

    @Test
    public void testGET() throws IOException &#123;
        // 创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        // 创建请求对象接口 (GET请求方式+请求地址)
        HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/user/shop/status&quot;);

        // 发送请求，接受响应结果
        CloseableHttpResponse response = httpClient.execute(httpGet);

        // 获取服务端返回的状态码
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println(&quot;服务端返回的状态码为：&quot; + statusCode);


        HttpEntity entity = response.getEntity();// 获得请求体
        String body = EntityUtils.toString(entity);
        System.out.println(&quot;服务端返回的数据为：&quot; + body);

        // 关闭资源
        response.close();
        httpClient.close();
    &#125;

    /**
     * 测试通过httpclient发送POST方式的请求
     */
&#125;
--------------------------------------------------------------------------------
服务端返回的状态码为：200
服务端返回的数据为：&#123;&quot;code&quot;:1,&quot;msg&quot;:null,&quot;data&quot;:0&#125;
</code></pre>
<h5 id="发送POST方式请求-要先把项目跑起来"><a href="#发送POST方式请求-要先把项目跑起来" class="headerlink" title="发送POST方式请求 [要先把项目跑起来]"></a>发送POST方式请求 [要先把项目跑起来]</h5><pre><code class="java">sky-server   com/sky/test/HttpClientTest.java
/**
     * 测试通过httpclient发送POST方式的请求
     */
    @Test
    public void testPOST() throws Exception&#123;
        // 创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        // 创建请求对象
        HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/admin/employee/login&quot;);
        // 以json方式请求提交参数
        JSONObject jsonObject = new JSONObject();
        jsonObject.put(&quot;username&quot;,&quot;admin&quot;);
        jsonObject.put(&quot;password&quot;,&quot;123456&quot;);

        StringEntity entity = new StringEntity(jsonObject.toString());
        // 指定请求编码方式
        entity.setContentEncoding(&quot;utf-8&quot;);
        // 数据格式
        entity.setContentType(&quot;application/json&quot;);
        httpPost.setEntity(entity);

        // 发送请求
        CloseableHttpResponse response = httpClient.execute(httpPost);

        // 解析返回结果
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println(&quot;响应码为：&quot; + statusCode);

        HttpEntity entity1 = response.getEntity();
        String body = EntityUtils.toString(entity1);
        System.out.println(&quot;响应数据为：&quot; + body);

        // 关闭资源
        response.close();
        httpClient.close();
    &#125;
--------------------------------------------------------------------------------
响应码为：200
响应数据为：&#123;&quot;code&quot;:1,&quot;msg&quot;:null,&quot;data&quot;:&#123;&quot;id&quot;:1,&quot;userName&quot;:&quot;admin&quot;,&quot;name&quot;:&quot;管理员&quot;,&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI4MTMyMzczfQ.8M2nIkgtHx8wpORNfhKEWjbprBV6OwC82wgYjAMxe2I&quot;&#125;&#125;
</code></pre>
<h6 id="封装后的HttpClientUtil"><a href="#封装后的HttpClientUtil" class="headerlink" title="封装后的HttpClientUtil"></a>封装后的HttpClientUtil</h6><pre><code class="java">package com.sky.utils;

import com.alibaba.fastjson.JSONObject;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Http工具类
 */
public class HttpClientUtil &#123;

    static final  int TIMEOUT_MSEC = 5 * 1000;

    /**
     * 发送GET方式请求
     * @param url
     * @param paramMap
     * @return
     */
    public static String doGet(String url,Map&lt;String,String&gt; paramMap)&#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        String result = &quot;&quot;;
        CloseableHttpResponse response = null;

        try&#123;
            URIBuilder builder = new URIBuilder(url);
            if(paramMap != null)&#123;
                for (String key : paramMap.keySet()) &#123;
                    builder.addParameter(key,paramMap.get(key));
                &#125;
            &#125;
            URI uri = builder.build();

            //创建GET请求
            HttpGet httpGet = new HttpGet(uri);

            //发送请求
            response = httpClient.execute(httpGet);

            //判断响应状态
            if(response.getStatusLine().getStatusCode() == 200)&#123;
                result = EntityUtils.toString(response.getEntity(),&quot;UTF-8&quot;);
            &#125;
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            try &#123;
                response.close();
                httpClient.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return result;
    &#125;

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost(String url, Map&lt;String, String&gt; paramMap) throws IOException &#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;

        try &#123;
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            // 创建参数列表
            if (paramMap != null) &#123;
                List&lt;NameValuePair&gt; paramList = new ArrayList();
                for (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;
                    paramList.add(new BasicNameValuePair(param.getKey(), param.getValue()));
                &#125;
                // 模拟表单
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);
                httpPost.setEntity(entity);
            &#125;

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            try &#123;
                response.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return resultString;
    &#125;

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost4Json(String url, Map&lt;String, String&gt; paramMap) throws IOException &#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;

        try &#123;
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            if (paramMap != null) &#123;
                //构造json格式数据
                JSONObject jsonObject = new JSONObject();
                for (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;
                    jsonObject.put(param.getKey(),param.getValue());
                &#125;
                StringEntity entity = new StringEntity(jsonObject.toString(),&quot;utf-8&quot;);
                //设置请求编码
                entity.setContentEncoding(&quot;utf-8&quot;);
                //设置数据类型
                entity.setContentType(&quot;application/json&quot;);
                httpPost.setEntity(entity);
            &#125;

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            try &#123;
                response.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return resultString;
    &#125;
    private static RequestConfig builderRequestConfig() &#123;
        return RequestConfig.custom()
                .setConnectTimeout(TIMEOUT_MSEC)
                .setConnectionRequestTimeout(TIMEOUT_MSEC)
                .setSocketTimeout(TIMEOUT_MSEC).build();
    &#125;
&#125;
</code></pre>
<h3 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&token=244469372">小程序 (qq.com)</a></p>
<blockquote>
<p>详情 → 本地设置 → [取消勾选]不校验合法域名…</p>
</blockquote>
<h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ul>
<li><p>了解小程序目录结构</p>
<p>小程序包含一个<strong>描述整体程序</strong>的<u>app</u>和多个和<strong>描述各自页面</strong>的<u>page</u>，一个小程序主体部分由三个文件组村，必须放在项目的根目录</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>app.js</td>
<td>是</td>
<td>小程序逻辑</td>
</tr>
<tr>
<td>app.json</td>
<td>是</td>
<td>小程序公共配置</td>
</tr>
<tr>
<td>app.wxss</td>
<td>否</td>
<td>小程序公共样式表</td>
</tr>
</tbody></table>
<h6 id="一个小程序页面由四个文件组成-pages-→-index-→-…"><a href="#一个小程序页面由四个文件组成-pages-→-index-→-…" class="headerlink" title="一个小程序页面由四个文件组成 [pages → index → …]"></a>一个小程序页面由四个文件组成 [pages → index → …]</h6><table>
<thead>
<tr>
<th>文件类型</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>js</td>
<td>是</td>
<td>页面逻辑</td>
</tr>
<tr>
<td>wxml</td>
<td>是</td>
<td>页面结构</td>
</tr>
<tr>
<td>json</td>
<td>否</td>
<td>页面配置</td>
</tr>
<tr>
<td>wxss</td>
<td>否</td>
<td>页面样式表</td>
</tr>
</tbody></table>
</li>
<li><p>编写测试小程序代码</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23385943/article/details/142336381?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-142336381-blog-119914069.235%5Ev43%5Epc_blog_bottom_relevance_base6&spm=1001.2101.3001.4242.1&utm_relevant_index=3">微信getUserProfile不弹出授权框_wx.getuserprofile没有弹窗-CSDN博客</a></p>
<pre><code class="json">app.json 【外面一层】
&#123;
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;: &#123;
    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,
    &quot;navigationBarTitleText&quot;: &quot;Sky-Delivery&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;
  &#125;,
  &quot;style&quot;: &quot;v2&quot;,
  &quot;componentFramework&quot;: &quot;glass-easel&quot;,
  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;,
  &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;
&#125;
</code></pre>
<pre><code class="xml">pages/index/index.wxml
&lt;view class=&quot;container&quot;&gt;
  &lt;view&gt;
    &#123;&#123;msg&#125;&#125;
  &lt;/view&gt;

  &lt;view&gt;
    &lt;button bindtap=&quot;getUserInfo&quot; type=&quot;primary&quot;&gt;获取用户信息&lt;/button&gt;
    昵称：&#123;&#123;nickName&#125;&#125;
    &lt;image src=&quot;&#123;&#123;url&#125;&#125;&quot; style=&quot;width: 200px;height: 200px;&quot;&gt;&lt;/image&gt;
    &lt;button bindtap=&quot;wxLogin&quot; type=&quot;warn&quot;&gt;微信登录&lt;/button&gt;
    授权码：&#123;&#123;code&#125;&#125;
  &lt;/view&gt;

  &lt;view&gt;
    &lt;button bindtap=&quot;sendRequest&quot; type=&quot;default&quot;&gt;发送请求&lt;/button&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="js">pages/index/index.js
Page(&#123;
  data: &#123;
    msg: &#39;hello world&#39;,
    nickName: &#39;&#39;,
    url:&#39;&#39;,
    code:&#39;&#39;,
  &#125;,

  // 获取微信用户的头像和昵称
  getUserInfo(e)&#123;
    wx.getUserProfile(&#123;
      desc: &#39;获取用户信息&#39;,
      success: (res) =&gt; &#123;
        console.log(res.userInfo);
        // 为数据赋值
        this.setData(&#123;
          nickName: res.userInfo.nickName,
          url: res.userInfo.avatarUrl
        &#125;)
      &#125;,
      fail:(err) =&gt; &#123;
        console.error(&#39;获取用户信息失败&#39;, err);
      &#125;
    &#125;);
  &#125;,
  
  //微信登录，获取微信用户的授权码 
  //拿到后可以去请求微信服务器获得openId
  //授权码提交到后端去调用服务器
  wxLogin()&#123;
    wx.login(&#123;
      success: (res) =&gt; &#123;
        console.log(res.code)
        this.setData(&#123;
          code: res.code
        &#125;)
      &#125;
    &#125;)
  &#125;,

  //发送请求
  sendRequest()&#123;
    wx.request(&#123;
      url: &#39;http://localhost:8080/user/shop/status&#39;,
      method: &#39;GET&#39;,
      success: (res)=&gt;&#123;
        // data是后端响应回来的整个数据
        console.log(res.data)
      &#125;
    &#125;)
  &#125;
&#125;);
</code></pre>
</li>
<li><p>编译小程序</p>
</li>
</ul>
<h3 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h3><h5 id="导入小程序代码"><a href="#导入小程序代码" class="headerlink" title="导入小程序代码"></a>导入小程序代码</h5><blockquote>
<p>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day06\微信小程序代码\mp-weixin<br>【注意：导入后有很多包名错误common、components】</p>
</blockquote>
<h5 id="微信登录流程"><a href="#微信登录流程" class="headerlink" title="微信登录流程"></a>微信登录流程</h5><blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">开放能力 &#x2F; 用户信息 &#x2F; 小程序登录 (qq.com)</a><br><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg"></p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>appid</td>
<td>string</td>
<td></td>
<td>是</td>
<td>小程序 appId</td>
</tr>
<tr>
<td>secret</td>
<td>string</td>
<td></td>
<td>是</td>
<td>小程序 appSecret</td>
</tr>
<tr>
<td>js_code</td>
<td>string</td>
<td></td>
<td>是</td>
<td>登录时获取的 code</td>
</tr>
<tr>
<td>grant_type</td>
<td>string</td>
<td></td>
<td>是</td>
<td>授权类型，此处只需填写 authorization_code</td>
</tr>
</tbody></table>
<blockquote>
<p>PostMan测试 →<br>GET：<a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/jscode2session?appid=wxa33b4bae9165c5a5&amp;secret=c2d6fc237953d711146c4ad5db3ef947&amp;js_code=0f1hdA200TsYYS1ghD100c3GZJ1hdA2w&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/jscode2session?appid=wxa33b4bae9165c5a5&amp;secret=c2d6fc237953d711146c4ad5db3ef947&amp;js_code=0f1hdA200TsYYS1ghD100c3GZJ1hdA2w&amp;grant_type=authorization_code</a></p>
<p>返回：<br>{“session_key”:”HsYD32ryqarcnrCXbEyWhg&#x3D;&#x3D;”,”openid”:”obaex5N3w1_oAP6a4h-c-CkQBsZQ”}</p>
</blockquote>
<h6 id="需求分析和设计-3"><a href="#需求分析和设计-3" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h6><p>数据库设计(user表)</p>
<h6 id="代码开发-3"><a href="#代码开发-3" class="headerlink" title="代码开发"></a>代码开发</h6><pre><code class="yaml">sky-server  application.yml
sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 7200000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
    user-secret-key: itheima
    user-ttl: 7200000
    user-token-name: authentication
  alioss:
    endpoint: $&#123;sky.alioss.endpoint&#125;
    access-key-id: $&#123;sky.alioss.access-key-id&#125;
    access-key-secret: $&#123;sky.alioss.access-key-secret&#125;
    bucket: $&#123;sky.alioss.bucket&#125;
  wechat:
    appid: $&#123;sky.wechat.appid&#125;
    secret: $&#123;sky.wechat.secret&#125;
</code></pre>
<pre><code class="java">sky-server  application-dev.yml
  wechat:
    appid: xxxxxxx
    secret: xxxxxxx
</code></pre>
<pre><code class="java">sky-common  com/sky/properties/WeChatProperties.java
package com.sky.properties;

import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &quot;sky.wechat&quot;)
@Data
public class WeChatProperties &#123;

    private String appid; //小程序的appid
    private String secret; //小程序的秘钥
    private String mchid; //商户号
    private String mchSerialNo; //商户API证书的证书序列号
    private String privateKeyFilePath; //商户私钥文件
    private String apiV3Key; //证书解密的密钥
    private String weChatPayCertFilePath; //平台证书
    private String notifyUrl; //支付成功的回调地址
    private String refundNotifyUrl; //退款成功的回调地址
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/UserController.java
package com.sky.controller.user;

import com.sky.constant.JwtClaimsConstant;
import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;
import com.sky.properties.JwtProperties;
import com.sky.result.Result;
import com.sky.service.UserService;
import com.sky.utils.JwtUtil;
import com.sky.vo.UserLoginVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping(&quot;/user/user&quot;)
@Api(tags = &quot;C端用户相关接口&quot;)
@Slf4j
public class UserController &#123;
    @Autowired
    private UserService userService;
    @Autowired
    private JwtProperties jwtProperties;
    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    @PostMapping(&quot;/login&quot;)
    @ApiOperation(&quot;微信登录&quot;)
    public Result&lt;UserLoginVO&gt; login(@RequestBody UserLoginDTO userLoginDTO) &#123;
        log.info(&quot;微信登录：&#123;&#125;&quot;, userLoginDTO.getCode());
        //微信登录
        User user = userService.wxLogin(userLoginDTO);

        //为微信用户生成jwt令牌
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(JwtClaimsConstant.USER_ID, user.getId());
        String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(),jwtProperties.getUserTtl(),claims);
        UserLoginVO userLoginVO = UserLoginVO.builder()
                .id(user.getId())
                .openid(user.getOpenid())
                .token(token)
                .build();
        return Result.success(userLoginVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/UserService.java
package com.sky.service;

import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;

public interface UserService &#123;
    /**
     * 微信登录
     * @return
     */
    User wxLogin(UserLoginDTO userLoginDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/UserServiceImpl.java
package com.sky.service.impl;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.sky.constant.MessageConstant;
import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;
import com.sky.exception.LoginFailedException;
import com.sky.mapper.UserMapper;
import com.sky.properties.WeChatProperties;
import com.sky.service.UserService;
import com.sky.utils.HttpClientUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class UserServiceImpl implements UserService &#123;
    // 微信服务接口地址
    public static final String WX_LOGIN = &quot;https://api.weixin.qq.com/sns/jscode2session&quot;;

    @Autowired
    private WeChatProperties weChatProperties;
    @Autowired
    private UserMapper userMapper;
    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    @Override
    public User wxLogin(UserLoginDTO userLoginDTO) &#123;
        String openid = getOpenid(userLoginDTO.getCode());
        // 判断openId是否真的获取到 如果为空代表失败 业务异常
        if (openid == null)&#123;
            throw new LoginFailedException(MessageConstant.LOGIN_FAILED);
        &#125;
        // openId是否在表里 可判断是否为新用户
        User user = userMapper.getByOpenid(openid);
        // 如果是新用户，自动完成注册
        if (user == null) &#123;
            user = User.builder()
                    .openid(openid)
                    .createTime(LocalDateTime.now())
                    .build();
            userMapper.insert(user);
        &#125;
        // 返回这个用户对象
        return user;
    &#125;

    /**
     * 调用微信接口服务，获取微信用户的openid
     * @param code
     * @return
     */
    //只有当前类用到
    private String getOpenid(String code) &#123;
        // 调用微信服务器接口 获得当前用户的openid
        // 四个请求参数
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;appid&quot;, weChatProperties.getAppid());
        map.put(&quot;secret&quot;, weChatProperties.getSecret());
        map.put(&quot;js_code&quot;, code);
        map.put(&quot;grant_type&quot;, &quot;authorization_code&quot;);
        String json = HttpClientUtil.doGet(WX_LOGIN, map);

        // 获得json对象
        JSONObject jsonObject = JSON.parseObject(json);
        String openid = jsonObject.getString(&quot;openid&quot;);
        return openid;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
package com.sky.mapper;

import com.sky.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface UserMapper &#123;
    /**
     * 根据openid查询用户
     * @param openid
     * @return
     */
    @Select(&quot;select * from user where openid = #&#123;openid&#125;&quot;)
    User getByOpenid(String openid);

    /**
     * 新增用户
     * @param user
     */
    void insert(User user);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.UserMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into user (openid, name, phone, sex, id_number, avatar, create_time)
        values (#&#123;openid&#125;, #&#123;name&#125;, #&#123;phone&#125;, #&#123;sex&#125;, #&#123;idNumber&#125;, #&#123;avatar&#125;, #&#123;createTime&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">【检测小程序用户是否登陆性】
sky-server  com/sky/interceptor/JwtTokenUserInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenUserInterceptor implements HandlerInterceptor &#123;

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getUserTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);
            Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());
            log.info(&quot;当前用户的id：&quot;, userId);
            BaseContext.setCurrentId(userId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java 【增加jwtTokenUserInterceptor】
/**
 * 配置类，注册web层相关组件
 */
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    @Autowired
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;
    @Autowired
    private JwtTokenUserInterceptor jwtTokenUserInterceptor;

    /**
     * 注册自定义拦截器
     * @param registry
     */
    protected void addInterceptors(InterceptorRegistry registry) &#123;
        log.info(&quot;开始注册自定义拦截器...&quot;);
        registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns(&quot;/admin/**&quot;)
                .excludePathPatterns(&quot;/admin/employee/login&quot;);

        registry.addInterceptor(jwtTokenUserInterceptor)
                .addPathPatterns(&quot;/user/**&quot;)
                .excludePathPatterns(&quot;/user/user/login&quot;)
                .excludePathPatterns(&quot;/user/shop/status&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="导入商品浏览功能代码"><a href="#导入商品浏览功能代码" class="headerlink" title="导入商品浏览功能代码"></a>导入商品浏览功能代码</h4><h6 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h6><ul>
<li><p>查询分类</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;category&#x2F;list<br>Method：GET<br>请求参数<br>Type： 分类类型→1.菜品分类  2.套餐分类</p>
</blockquote>
</li>
<li><p>根据分类id查询菜品</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;dish&#x2F;list<br>Method：GET<br>请求参数<br>categoryId 分类id</p>
</blockquote>
</li>
<li><p>根据分类id查询套餐</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;setmeal&#x2F;list?category&#x3D;111<br>Method：GET<br>请求参数<br>categoryId 分类id</p>
</blockquote>
</li>
<li><p>根据套餐id查询包含的菜品</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;setmeal&#x2F;dish&#x2F;10<br>Method：GET<br>请求参数<br>id 套餐id<br>返回数据：<br>copies 份数<br>description 菜品描述<br>image 菜品图片<br>name 菜品名称</p>
</blockquote>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/user/DishController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Dish;
import com.sky.result.Result;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userDishController&quot;)
@RequestMapping(&quot;/user/dish&quot;)
@Slf4j
@Api(tags = &quot;C端-菜品浏览接口&quot;)
public class DishController &#123;
    @Autowired
    private DishService dishService;

    /**
     * 根据分类id查询菜品
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询菜品&quot;)
    public Result&lt;List&lt;DishVO&gt;&gt; list(Long categoryId) &#123;
        Dish dish = new Dish();
        dish.setCategoryId(categoryId);
        dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品

        List&lt;DishVO&gt; list = dishService.listWithFlavor(dish);

        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.result.PageResult;
import com.sky.vo.DishVO;

import java.util.List;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);

    /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    DishVO getByIdWithFlavor(long id);

    /**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    void updateWithFlavor(DishDTO dishDTO);

    /**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据分类id查询菜品
     * @param categoryId
     * @return
     */
    List&lt;Dish&gt; list(Long categoryId);

    /**
     * 条件查询菜品和口味
     * @param dish
     * @return
     */
    List&lt;DishVO&gt; listWithFlavor(Dish dish);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.DishFlavor;
import com.sky.entity.Setmeal;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.DishFlavorMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

@Service
@Slf4j

public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private SetmealMapper setmealMapper;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    @Override
    @Transactional //保证事务一致性
    public void saveWithFlavour(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        //直接new出来是空的需要先赋值 属性拷贝[属性命名要一致]
        BeanUtils.copyProperties(dishDTO,dish);

        // 向菜品表插入1条数据
        dishMapper.insert(dish);
        // 前端无法传 要获取dishId
// &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; 获取主键值
        Long dishId = dish.getId();

        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishId);
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    @Override
    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;
        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        // 判断当前菜品是否能够删除--是否存在起售中的菜品？？ 取出id
        for (Long id : ids) &#123;
            Dish dish = dishMapper.getById(id);
            if (dish.getStatus() == StatusConstant.ENABLE) &#123;
                //当前菜品处于起售中，不能删除
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            &#125;
        &#125;

        // 判断当前菜品是否能够删除--是否被套餐关联了
        List&lt;Long&gt; setMealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);
        if (setMealIds != null &amp;&amp; setMealIds.size() &gt; 0) &#123; //存在不允许删除
            // 当前菜品被套餐关联了，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        &#125;
        // 删除菜品表中的菜品数据
        for (Long id : ids) &#123;
            dishMapper.deleteById(id);
            // 删除菜品关联的口味数据
            dishFlavorMapper.deleteByDishId(id);
        &#125;
    &#125;

    /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @Override
    public DishVO getByIdWithFlavor(long id) &#123;
        // 根据id查询菜品数据
        Dish dish = dishMapper.getById(id);
        // 根据菜品id查询口味数据
        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);

        // 将查询到的数据封装到VO
        DishVO dishVO = new DishVO();
            // 属性拷贝
        BeanUtils.copyProperties(dish,dishVO);
        dishVO.setFlavors(dishFlavors);

        return dishVO;
    &#125;



    /**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    @Override
    public void updateWithFlavor(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // 修改菜品表基本信息 只是基础信息噢
        dishMapper.update(dish);
        // 先删掉原先的
        dishFlavorMapper.deleteByDishId(dishDTO.getId());
        // 再重新插入新的
        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishDTO.getId());
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;

    /**
     * 菜品起售停售
     * @param status
     * @param id
     */
    @Override
    public void startOrStop(Integer status, Long id) &#123;
        Dish dish = Dish.builder()
                .id(id)
                .status(status)
                .build();
        dishMapper.update(dish);

        if (status == StatusConstant.DISABLE) &#123;
            // 如果是停售操作，还需要将包含当前菜品的套餐也停售
            List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();
            dishIds.add(id);
            // select setmeal_id from setmeal_dish where dish_id in (?,?,?)
            List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);
            if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;
                for (Long setmealId : setmealIds) &#123;
                    Setmeal setmeal = Setmeal.builder()
                            .id(setmealId)
                            .status(StatusConstant.DISABLE)
                            .build();
                    setmealMapper.update(setmeal);
                &#125;
            &#125;

        &#125;
    &#125;

    /**
     * 根据分类id查询菜品
     * @param categoryId
     * @return
     */
    public List&lt;Dish&gt; list(Long categoryId) &#123;
        Dish dish = Dish.builder()
                .categoryId(categoryId)
                .status(StatusConstant.ENABLE)
                .build();
        return dishMapper.list(dish);
    &#125;

    /**
     * 条件查询菜品和口味
     * @param dish
     * @return
     */
    public List&lt;DishVO&gt; listWithFlavor(Dish dish) &#123;
        List&lt;Dish&gt; dishList = dishMapper.list(dish);

        List&lt;DishVO&gt; dishVOList = new ArrayList&lt;&gt;();

        for (Dish d : dishList) &#123;
            DishVO dishVO = new DishVO();
            BeanUtils.copyProperties(d,dishVO);

            //根据菜品id查询对应的口味
            List&lt;DishFlavor&gt; flavors = dishFlavorMapper.getByDishId(d.getId());

            dishVO.setFlavors(flavors);
            dishVOList.add(dishVO);
        &#125;

        return dishVOList;
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">sky-server  com/sky/controller/user/SetmealController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Setmeal;
import com.sky.result.Result;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userSetmealController&quot;)
@RequestMapping(&quot;/user/setmeal&quot;)
@Api(tags = &quot;C端-套餐浏览接口&quot;)
public class SetmealController &#123;
    @Autowired
    private SetmealService setmealService;

    /**
     * 条件查询
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询套餐&quot;)
    public Result&lt;List&lt;Setmeal&gt;&gt; list(Long categoryId) &#123;
        Setmeal setmeal = new Setmeal();
        setmeal.setCategoryId(categoryId);
        setmeal.setStatus(StatusConstant.ENABLE);

        List&lt;Setmeal&gt; list = setmealService.list(setmeal);
        return Result.success(list);
    &#125;

    /**
     * 根据套餐id查询包含的菜品列表
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/dish/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据套餐id查询包含的菜品列表&quot;)
    public Result&lt;List&lt;DishItemVO&gt;&gt; dishList(@PathVariable(&quot;id&quot;) Long id) &#123;
        List&lt;DishItemVO&gt; list = setmealService.getDishItemById(id);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/SetmealService.java
package com.sky.service;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.result.PageResult;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;

import java.util.List;

public interface SetmealService &#123;

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    void saveWithDish(SetmealDTO setmealDTO);

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询套餐和关联的菜品数据
     *
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    void update(SetmealDTO setmealDTO);

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    List&lt;DishItemVO&gt; getDishItemById(Long id);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/SetmealServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.SetmealDish;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.exception.SetmealEnableFailedException;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 套餐业务实现
 */
@Service
@Slf4j
public class SetmealServiceImpl implements SetmealService &#123;

    @Autowired
    private SetmealMapper setmealMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private DishMapper dishMapper;


    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    @Transactional
    public void saveWithDish(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //向套餐表插入数据
        setmealMapper.insert(setmeal);

        //获取生成的套餐id
        Long setmealId = setmeal.getId();

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);

        //保存套餐和菜品的关联关系
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        int pageNum = setmealPageQueryDTO.getPage();
        int pageSize = setmealPageQueryDTO.getPageSize();

        PageHelper.startPage(pageNum, pageSize);
        Page&lt;SetmealVO&gt; page = setmealMapper.pageQuery(setmealPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        ids.forEach(id -&gt; &#123;
            Setmeal setmeal = setmealMapper.getById(id);
            if (StatusConstant.ENABLE == setmeal.getStatus()) &#123;
                //起售中的套餐不能删除
                throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
            &#125;
        &#125;);

        ids.forEach(setmealId -&gt; &#123;
            //删除套餐表中的数据
            setmealMapper.deleteById(setmealId);
            //删除套餐菜品关系表中的数据
            setmealDishMapper.deleteBySetmealId(setmealId);
        &#125;);
    &#125;

    /**
     * 根据id查询套餐和套餐菜品关系
     *
     * @param id
     * @return
     */
    public SetmealVO getByIdWithDish(Long id) &#123;
        SetmealVO setmealVO = setmealMapper.getByIdWithDish(id);
        return setmealVO;
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    @Transactional
    public void update(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //1、修改套餐表，执行update
        setmealMapper.update(setmeal);

        //套餐id
        Long setmealId = setmealDTO.getId();

        //2、删除套餐和菜品的关联关系，操作setmeal_dish表，执行delete
        setmealDishMapper.deleteBySetmealId(setmealId);

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);
        //3、重新插入套餐和菜品的关联关系，操作setmeal_dish表，执行insert
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        //起售套餐时，判断套餐内是否有停售菜品，有停售菜品提示&quot;套餐内包含未启售菜品，无法启售&quot;
        if (status == StatusConstant.ENABLE) &#123;
            //select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = ?
            List&lt;Dish&gt; dishList = dishMapper.getBySetmealId(id);
            if (dishList != null &amp;&amp; dishList.size() &gt; 0) &#123;
                dishList.forEach(dish -&gt; &#123;
                    if (StatusConstant.DISABLE == dish.getStatus()) &#123;
                        throw new SetmealEnableFailedException(MessageConstant.SETMEAL_ENABLE_FAILED);
                    &#125;
                &#125;);
            &#125;
        &#125;

        Setmeal setmeal = Setmeal.builder()
                .id(id)
                .status(status)
                .build();
        setmealMapper.update(setmeal);
    &#125;

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    public List&lt;Setmeal&gt; list(Setmeal setmeal) &#123;
        List&lt;Setmeal&gt; list = setmealMapper.list(setmeal);
        return list;
    &#125;

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    public List&lt;DishItemVO&gt; getDishItemById(Long id) &#123;
        return setmealMapper.getDishItemBySetmealId(id);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">sky-server  com/sky/controller/user/CategoryController.java
package com.sky.controller.user;

import com.sky.entity.Category;
import com.sky.result.Result;
import com.sky.service.CategoryService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userCategoryController&quot;)
@RequestMapping(&quot;/user/category&quot;)
@Api(tags = &quot;C端-分类接口&quot;)
public class CategoryController &#123;

    @Autowired
    private CategoryService categoryService;

    /**
     * 查询分类
     * @param type
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;查询分类&quot;)
    public Result&lt;List&lt;Category&gt;&gt; list(Integer type) &#123;
        List&lt;Category&gt; list = categoryService.list(type);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/CategoryService.java
package com.sky.service;

import com.sky.annotation.AutoFill;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增分类
     * @param categoryDTO
     */
    void save(CategoryDTO categoryDTO);
    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    void deleteById(Long id);

    /**
     * 修改分类
     * @param categoryDTO
     */
    void update(CategoryDTO categoryDTO);

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/CategoryServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.context.BaseContext;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.CategoryMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 分类业务层
 */
@Service
@Slf4j
public class CategoryServiceImpl implements CategoryService &#123;

    @Autowired
    private CategoryMapper categoryMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 新增分类
     * @param categoryDTO
     */
    public void save(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        //属性拷贝
        BeanUtils.copyProperties(categoryDTO, category);

        //分类状态默认为禁用状态0
        category.setStatus(StatusConstant.DISABLE);
/**  公共属性
        //设置创建时间、修改时间、创建人、修改人
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContext.getCurrentId());
        category.setUpdateUser(BaseContext.getCurrentId());
 **/

        categoryMapper.insert(category);
    &#125;

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123;
        PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());
        //下一条sql进行分页，自动加入limit关键字分页
        Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 根据id删除分类
     * @param id
     */
    public void deleteById(Long id) &#123;
        //查询当前分类是否关联了菜品，如果关联了就抛出业务异常
        Integer count = dishMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
        &#125;

        //查询当前分类是否关联了套餐，如果关联了就抛出业务异常
        count = setmealMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);
        &#125;

        //删除分类数据
        categoryMapper.deleteById(id);
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     */
    public void update(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO,category);

        //设置修改时间、修改人 (公共属性)
//        category.setUpdateTime(LocalDateTime.now());
//        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.update(category);
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        Category category = Category.builder()
                .id(id)
                .status(status) // 下面注释是公共属性AOP有写
//                .updateTime(LocalDateTime.now())
//                .updateUser(BaseContext.getCurrentId())
                .build();
        categoryMapper.update(category);
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    public List&lt;Category&gt; list(Integer type) &#123;
        return categoryMapper.list(type);
    &#125;
&#125;
</code></pre>
<h3 id="缓存菜品-【redis】"><a href="#缓存菜品-【redis】" class="headerlink" title="缓存菜品 【redis】"></a>缓存菜品 【redis】</h3><h5 id="问题说明："><a href="#问题说明：" class="headerlink" title="问题说明："></a>问题说明：</h5><p>用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问压力随之增大</p>
<h5 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h5><p>通过Redis来缓存菜品数据，减少数据库查询操作</p>
<p>开始→(查询菜品)→后端服务→缓存是否存在→(是)→读取缓存<br>                                                                               (否)→查询数据库→载入缓存</p>
<h5 id="缓存逻辑分析："><a href="#缓存逻辑分析：" class="headerlink" title="缓存逻辑分析："></a>缓存逻辑分析：</h5><ul>
<li><p>每个分类下的菜品保存一份缓存数据</p>
<p><strong>key</strong>：dish_1<br><strong>value</strong>：string(…) [List集合]</p>
</li>
</ul>
<pre><code class="java">sky-server com/sky/controller/user/DishController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Dish;
import com.sky.result.Result;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userDishController&quot;)
@RequestMapping(&quot;/user/dish&quot;)
@Slf4j
@Api(tags = &quot;C端-菜品浏览接口&quot;)
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 根据分类id查询菜品
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询菜品&quot;)
    public Result&lt;List&lt;DishVO&gt;&gt; list(Long categoryId) &#123;

        //构造redis中的key，规则：dish_分类id
        String key = &quot;dish_&quot; + categoryId;

        //查询redis中是否存在菜品数据
        List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);
        if(list != null &amp;&amp; list.size() &gt; 0)&#123;
            //如果存在，直接返回，无须查询数据库
            return Result.success(list);
        &#125;

        Dish dish = new Dish();
        dish.setCategoryId(categoryId);
        dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品

        //如果不存在，查询数据库，将查询到的数据放入redis中
        list = dishService.listWithFlavor(dish);
        redisTemplate.opsForValue().set(key, list);

        return Result.success(list);
    &#125;
&#125;
</code></pre>
<h5 id="清理缓存数据"><a href="#清理缓存数据" class="headerlink" title="清理缓存数据"></a>清理缓存数据</h5><h6 id="防止-新增-x2F-更改-x2F-删除-x2F-起售停售-后无法及时在用户手机端接收"><a href="#防止-新增-x2F-更改-x2F-删除-x2F-起售停售-后无法及时在用户手机端接收" class="headerlink" title="防止 新增&#x2F;更改&#x2F;删除&#x2F;起售停售 后无法及时在用户手机端接收"></a>防止 <u>新增&#x2F;更改&#x2F;删除&#x2F;起售停售</u> 后无法及时在用户手机端接收</h6><p>修改管理端接口 <code>DishController</code> 加入清理缓存的逻辑 (新增菜品、修改菜品、批量删除菜品、起售停售菜品)</p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
 * 菜品管理
 */
@RestController
@RequestMapping(&quot;/admin/dish&quot;)
@Api(tags = &quot;菜品相关接口&quot;)
@Slf4j
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @Autowired
    private RedisTemplate redisTemplate;
    @PostMapping
    @ApiOperation(&quot;新增菜品&quot;)
    //@RequestBody 封装JSON格式的数据
    public Result save(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);
        dishService.saveWithFlavour(dishDTO);

        //清理缓存数据(精确查询)
        String key = &quot;dish_&quot; + dishDTO.getCategoryId();
        cleanCache(key);
        return Result.success();
    &#125;
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除菜品&quot;)
    //@RequestParam MVC动态解析字符串 ids提取出来
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123; //ids
        log.info(&quot;批量删除菜品：&#123;&#125;&quot;, ids);
        dishService.deleteBatch(ids);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);
        return Result.success();
    &#125;
/**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改菜品&quot;)
    public Result update(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);
        dishService.updateWithFlavor(dishDTO);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);;
        return Result.success();
    &#125;
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;菜品起售停售&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id) &#123;
        dishService.startOrStop(status, id);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);

        return Result.success();
    &#125;
private void cleanCache(String pattern)&#123;
        /** 因为单独清理每个菜品可能会有关联套餐 就直接清理全部
         * 1. 先获取到所有的key
         * 2. 遍历key，判断是否以pattern开头
         * 3. 删除所有的key
         */
        Set keys = redisTemplate.keys(pattern);
        redisTemplate.delete(keys);
    &#125;
&#125;
</code></pre>
<h2 id="缓存套餐-【SpringCache】"><a href="#缓存套餐-【SpringCache】" class="headerlink" title="缓存套餐 【SpringCache】"></a>缓存套餐 【SpringCache】</h2><p>Spring Cache 是一个框架，实现了基于<strong>注解</strong>的缓存功能，只需要简单地加一个<strong>注解</strong>，就能实现缓存功能<br>Spring Cache 提供了一层抽象，底层可以切换不同的缓存实现</p>
<ul>
<li>EHCache</li>
<li>Caffeine</li>
<li>Redis</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h6><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span style="color:red">@<strong>EnableCaching</strong></span></td>
<td>开启缓存注解功能，通常加在<strong>启动类</strong>上</td>
</tr>
<tr>
<td><span style="color:red">@<strong>Cacheable</strong></span></td>
<td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td>
</tr>
<tr>
<td><span style="color:red">@<strong>CachePut</strong></span></td>
<td>将方法的返回值放到缓存中</td>
</tr>
<tr>
<td><span style="color:red">@<strong>CacheEvict</strong></span></td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
</tbody></table>
<pre><code class="java">@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;

     @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#user.id&quot;)
// 将方法的返回值放到缓存中
    // 如果使用Spring Cache缓存数据，key的生成&quot;#user.id&quot;
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    @CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    @CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;

    @GetMapping
    @Cacheable(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
// 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;
</code></pre>
<h5 id="SpringCache入门案例"><a href="#SpringCache入门案例" class="headerlink" title="SpringCache入门案例"></a>SpringCache入门案例</h5><h6 id="初始资源："><a href="#初始资源：" class="headerlink" title="初始资源："></a>初始资源：</h6><pre><code class="java">package com.itheima.controller;

import com.itheima.entity.User;
import com.itheima.mapper.UserMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;

    @Autowired
    private UserMapper userMapper;

    @PostMapping
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;

    @GetMapping
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;

&#125;
</code></pre>
<pre><code class="java">package com.itheima.mapper;

import com.itheima.entity.User;
import org.apache.ibatis.annotations.*;

@Mapper
public interface UserMapper&#123;

    @Insert(&quot;insert into user(name,age) values (#&#123;name&#125;,#&#123;age&#125;)&quot;)
    @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)
    void insert(User user);

    @Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);

    @Delete(&quot;delete from user&quot;)
    void deleteAll();

    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)
    User getById(Long id);
&#125;
</code></pre>
<pre><code class="java">package com.itheima.entity;

import lombok.Data;
import java.io.Serializable;

@Data
public class User implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    private String name;

    private int age;

&#125;
</code></pre>
<pre><code class="java">package com.itheima.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    /**
     * 生成接口文档配置
     * @return
     */
    @Bean
    public Docket docket()&#123;
        log.info(&quot;准备生成接口文档...&quot;);

        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.itheima.controller&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    /**
     * 设置静态资源映射
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        log.info(&quot;开始设置静态资源映射...&quot;);
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">application.yml
server:
  port: 8888
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/spring_cache_demo?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true
      username: root
      password: root
  redis:
    host: localhost
    port: 6379
    database: 1
logging:
  level:
    com:
      itheima:
        mapper: debug
        service: info
        controller: info
</code></pre>
<pre><code class="sql">springcachedemo.sql
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(45) DEFAULT NULL,
  `age` int DEFAULT NULL,
  PRIMARY KEY (`id`)
);
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.3&lt;/version&gt;
        &lt;relativePath/&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;springcache-demo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.20&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.76&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-lang&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.2.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.7.3&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<hr>
<hr>
<h5 id="开始调试咯"><a href="#开始调试咯" class="headerlink" title="开始调试咯"></a>开始调试咯</h5><pre><code class="java">com/itheima/CacheDemoApplication.java
package com.itheima;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
//@EnableCaching 放在 Application 类上，这样整个应用就启用了缓存支持
@Slf4j
@SpringBootApplication
@EnableCaching
public class CacheDemoApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(CacheDemoApplication.class,args);
        log.info(&quot;项目启动成功...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/controller/UserController.java
package com.itheima.controller;

import com.itheima.entity.User;
import com.itheima.mapper.UserMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;
    /*
    set a:b:c:d: itheima 这个就是树形结构在Redis里面 文件夹包着文件夹
    */
    @Autowired
    private UserMapper userMapper;

    @PostMapping
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#result.id&quot;) 对象导航
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#p0.id&quot;)
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#root.args[0]&quot;)
    @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#user.id&quot;)
// 将方法的返回值放到缓存中
    // 如果使用Spring Cache缓存数据，key的生成&quot;#user.id&quot;
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    @CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    @CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;


    @GetMapping
    @Cacheable(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
// 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;
&#125;
</code></pre>
<h4 id="缓存套餐-代码开发"><a href="#缓存套餐-代码开发" class="headerlink" title="缓存套餐_代码开发"></a>缓存套餐_代码开发</h4><h6 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h6><ul>
<li>导入 <strong>Spring Cache</strong> 和 <strong>Redis</strong> 相关maven坐标</li>
<li>在<u><strong>启动类</strong></u>上加入 <strong>@EnableCaching</strong> 注解，开启缓存注解功能</li>
<li>在<u><strong>用户端</strong></u>接口 <strong>SetmealController</strong> 的 <strong>list</strong> 方法上加入 <strong>@Cacheable</strong> 注解</li>
<li>在<u><strong>管理端</strong></u>接口 <strong>SetmealController</strong> 的 <strong>save、delete、update、startOrStop</strong> 等方法上<br>加入**@CacheEvict** 注解<del>保证数据一致性</del></li>
</ul>
<pre><code class="java">com/sky/SkyApplication.java
package com.sky;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication
@EnableTransactionManagement //开启注解方式的事务管理
@Slf4j
@EnableCaching //开启缓存注解
public class SkyApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SkyApplication.class, args);
        log.info(&quot;server started&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/SetmealController.java
@RestController(&quot;userSetmealController&quot;)
@RequestMapping(&quot;/user/setmeal&quot;)
@Api(tags = &quot;C端-套餐浏览接口&quot;)
public class SetmealController &#123;
    @Autowired
    private SetmealService setmealService;

    /**
     * 条件查询
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询套餐&quot;)
    @Cacheable(cacheNames = &quot;setmealCache&quot;,key = &quot;#categoryId&quot;) //key: setmealCache::100
    public Result&lt;List&lt;Setmeal&gt;&gt; list(Long categoryId) &#123;
        Setmeal setmeal = new Setmeal();
        setmeal.setCategoryId(categoryId);
        setmeal.setStatus(StatusConstant.ENABLE);

        List&lt;Setmeal&gt; list = setmealService.list(setmeal);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/SetmealController.java

/**
 * 套餐管理
 */
@RestController
@RequestMapping(&quot;/admin/setmeal&quot;)
@Api(tags = &quot;套餐相关接口&quot;)
@Slf4j
public class SetmealController &#123;

    @Autowired
    private SetmealService setmealService;

    /**
     * 新增套餐
     *
     * @param setmealDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,key = &quot;#setmealDTO.categoryId&quot;)//key: setmealCache::100
    public Result save(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.saveWithDish(setmealDTO);
        return Result.success();
    &#125;
 /**
     * 批量删除套餐
     *
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;
        setmealService.deleteBatch(ids);
        return Result.success();
    &#125;
/**
     * 修改套餐
     *
     * @param setmealDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result update(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.update(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 套餐起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;套餐起售停售&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result startOrStop(@PathVariable Integer status, Long id) &#123;
        setmealService.startOrStop(status, id);
        return Result.success();
    &#125;
&#125;
</code></pre>
<h3 id="添加购物车"><a href="#添加购物车" class="headerlink" title="添加购物车"></a>添加购物车</h3><blockquote>
<p>套餐直接点击加号<br>菜品＋ 或者有口味数据的选择后才可以加入购物车</p>
</blockquote>
<h6 id="接口设计：-4"><a href="#接口设计：-4" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li>请求方式：<strong>POST</strong></li>
<li>请求路径：&#x2F;user&#x2F;shoppingCart&#x2F;add</li>
<li>请求参数：<strong>菜品id</strong>(dish_id)、<strong>口味</strong>(dish_flavor) 或 <strong>套餐id</strong>(setmeal_id) (JSON请求体)</li>
<li>返回结果：code、data、msg</li>
</ul>
<h6 id="数据库设计-shopping-cart表-设置冗余字段可提高数据库效率"><a href="#数据库设计-shopping-cart表-设置冗余字段可提高数据库效率" class="headerlink" title="数据库设计(shopping_cart表):设置冗余字段可提高数据库效率"></a>数据库设计(shopping_cart表):<del>设置冗余字段可提高数据库效率</del></h6><ul>
<li>作用：暂时存放所选商品的地方</li>
<li>选的什么商品</li>
<li>每个商品都买了几个</li>
<li>不同用户的购物车需要区分开</li>
</ul>
<pre><code class="java">sky-pojo  com/sky/dto/ShoppingCartDTO.java
package com.sky.dto;

import lombok.Data;
import java.io.Serializable;

@Data
public class ShoppingCartDTO implements Serializable &#123;

    private Long dishId;
    private Long setmealId;
    private String dishFlavor;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
package com.sky.controller.user;

import com.sky.dto.ShoppingCartDTO;
import com.sky.result.Result;
import com.sky.service.ShoppingCartService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/user/shoppingCart&quot;)
@Slf4j
@Api(tags = &quot;C端添加购物车接口&quot;)
public class ShoppingCartController &#123;
    @Autowired
    private ShoppingCartService shoppingCartService;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     * @return
     */
    @PostMapping(&quot;/add&quot;)
    @ApiOperation(&quot;添加购物车&quot;)
    public Result add(@RequestBody ShoppingCartDTO shoppingCartDTO)&#123;
        log.info(&quot;添加购物车，商品信息为：&#123;&#125;&quot;,shoppingCartDTO);
        shoppingCartService.addShoppingCart(shoppingCartDTO);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
package com.sky.service;

import com.sky.dto.ShoppingCartDTO;
import org.springframework.stereotype.Service;

public interface ShoppingCartService &#123;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     */
    void addShoppingCart(ShoppingCartDTO shoppingCartDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
package com.sky.service.impl;

import com.sky.context.BaseContext;
import com.sky.dto.ShoppingCartDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.ShoppingCart;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.ShoppingCartService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
@Service
@Slf4j
public class ShoppingCartServiceImpl implements ShoppingCartService &#123;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     */
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;
    @Override
    public void addShoppingCart(ShoppingCartDTO shoppingCartDTO) &#123;
        // 判断当前加入购物车中的商品是否已经存在了 (user_id + setmeal_id)
        ShoppingCart shoppingCart = new ShoppingCart();
        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
        Long userId = BaseContext.getCurrentId();
        shoppingCart.setUserId(userId);

        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);

        // 如果已经存在了，只需要将数量+1
        if (list != null &amp;&amp; list.size() &gt; 0) &#123;
            ShoppingCart cart = list.get(0);
            cart.setNumber(cart.getNumber() + 1);
            // update shopping_cart set number = ? where id = ?
            shoppingCartMapper.updateNumberById(cart);
        &#125; else &#123;
            // 如果不存在，需要插入一条购物车数据
            // [先确定套餐or菜品]
            // 判断本次添加到购物车的是菜品还是套餐
            Long dishId = shoppingCartDTO.getDishId();
            if (dishId != null) &#123;
                //本次添加到购物车的是菜品
                Dish dish = dishMapper.getById(dishId);
                shoppingCart.setName(dish.getName());
                shoppingCart.setImage(dish.getImage());
                shoppingCart.setAmount(dish.getPrice());
            &#125; else &#123;
                //本次添加到购物车的是套餐 查菜品表
                Long setmealId = shoppingCartDTO.getSetmealId();
                Setmeal setmeal = setmealMapper.getById(setmealId);
                shoppingCart.setName(setmeal.getName());
                shoppingCart.setImage(setmeal.getImage());
                shoppingCart.setAmount(setmeal.getPrice());

            &#125;
            shoppingCart.setNumber(1);
            shoppingCart.setCreateTime(LocalDateTime.now());
            shoppingCartMapper.insert(shoppingCart);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
package com.sky.mapper;

import com.sky.entity.ShoppingCart;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Update;

import java.util.List;

@Mapper
public interface ShoppingCartMapper &#123;
    List&lt;ShoppingCart&gt; list(ShoppingCart shoppingCart);

    /**
     * 根据id修改商品数量
     * @param shoppingCart
     */
    @Update(&quot;update shopping_cart set number = #&#123;number&#125; where id = #&#123;id&#125;&quot;)
    void updateNumberById(ShoppingCart shoppingCart);

    /**
     * 插入购物车数据
     * @param shoppingCart
     */
    @Insert(&quot;insert into shopping_cart (name, user_id, dish_id, setmeal_id, dish_flavor, number, amount, image, create_time) &quot; +
            &quot; values (#&#123;name&#125;,#&#123;userId&#125;,#&#123;dishId&#125;,#&#123;setmealId&#125;,#&#123;dishFlavor&#125;,#&#123;number&#125;,#&#123;amount&#125;,#&#123;image&#125;,#&#123;createTime&#125;)&quot;)
    void insert(ShoppingCart shoppingCart);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/ShoppingCartMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.ShoppingCartMapper&quot;&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;com.sky.entity.ShoppingCart&quot;&gt;
        select * from shopping_cart
        &lt;where&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;dishId != null&quot;&gt;
                and dish_id = #&#123;dishId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;setmealId != null&quot;&gt;
                and setmeal_id = #&#123;setmealId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;dishFlavor != null&quot;&gt;
                and dish_flavor = #&#123;dishFlavor&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="删除购物车"><a href="#删除购物车" class="headerlink" title="删除购物车"></a>删除购物车</h3><pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 删除购物车
     * @param shoppingCartDTO
     * @return
     */
    @PostMapping(&quot;/sub&quot;)
    @ApiOperation(&quot;删除购物车&quot;)
    public Result sub(@RequestBody ShoppingCartDTO shoppingCartDTO)&#123;
        log.info(&quot;删除购物车，商品信息为：&#123;&#125;&quot;,shoppingCartDTO);
        shoppingCartService.subShoppingCart(shoppingCartDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
    /**
     * 删除购物车
     * @param shoppingCartDTO
     */
    void subShoppingCart(ShoppingCartDTO shoppingCartDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 删除购物车中的商品
     * @param shoppingCartDTO
     */
    @Override
    public void subShoppingCart(ShoppingCartDTO shoppingCartDTO) &#123;
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
        shoppingCart.setUserId(userId);

        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);
        if (list != null &amp;&amp; list.size() &gt; 0) &#123;
            ShoppingCart cart = list.get(0);
            if (cart.getNumber() &gt; 1) &#123;
                // 如果 number &gt;1， 则需要将 number - 1
                cart.setNumber(cart.getNumber() - 1);
                shoppingCartMapper.updateNumberById(cart);
            &#125; else &#123;
                // 如果 number &lt;=1，则直接删除该购物车数据
                shoppingCartMapper.deleteById(cart.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
/**
     * 根据id删除购物车数据
     * @param id
     */
    @Delete(&quot;delete from shopping_cart where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);
</code></pre>
<h3 id="查看购物车"><a href="#查看购物车" class="headerlink" title="查看购物车"></a>查看购物车</h3><blockquote>
<p>名称、价格、商品、数量<br>Path：&#x2F;user&#x2F;shoppingCart&#x2F;list<br>            PUT</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 查看购物车
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;查看购物车&quot;)
    public Result&lt;List&lt;ShoppingCart&gt;&gt; list()&#123;
       List&lt;ShoppingCart&gt; list = shoppingCartService.showShoppingCart();
       return Result.success(list);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
    /**
     * 查看购物车
     * @return
     */
    List&lt;ShoppingCart&gt; showShoppingCart();
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 查看购物车
     * @return
     */
    @Override
    public List&lt;ShoppingCart&gt; showShoppingCart() &#123;
        // 获取到当前微信用户的id
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = ShoppingCart.builder()
                .userId(userId)
                .build();
        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);
        return list;
    &#125;
</code></pre>
<h3 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h3><blockquote>
<p>Path：user&#x2F;shoppingCart&#x2F;clean<br>Method：DELETE<br>返回：code <strong>date</strong> msg</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 清空购物车
     * @return
     */
    @DeleteMapping(&quot;/clean&quot;)
    @ApiOperation(&quot;清空购物车&quot;)
    public Result clean() &#123;
        shoppingCartService.cleanShoppingCart();
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
/**
     * 清空购物车 删除自己的购物车
     */
    void cleanShoppingCart();
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 清空购物车
     */
    @Override
    public void cleanShoppingCart() &#123;
        //获取到当前用户的id
        Long userId = BaseContext.getCurrentId();
        shoppingCartMapper.deleteByUserId(userId);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
/**
     * 根据用户id清空购物车
     * @param userId
     */
    @Delete(&quot;delete from shopping_cart where user_id = #&#123;userId&#125;&quot;)
    void deleteByUserId(Long userId);
</code></pre>
<h3 id="支付接口"><a href="#支付接口" class="headerlink" title="支付接口"></a>支付接口</h3><h5 id="导入地址簿功能代码"><a href="#导入地址簿功能代码" class="headerlink" title="导入地址簿功能代码"></a>导入地址簿功能代码</h5><p><strong>业务功能：</strong></p>
<ul>
<li><p>查询地址列表</p>
</li>
<li><p>新增地址</p>
</li>
<li><p>修改地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook<br>Method：PUT</p>
</blockquote>
</li>
<li><p>删除地址</p>
</li>
<li><p>设置默认地址</p>
</li>
<li><p>查询默认地址</p>
</li>
</ul>
<p><strong>接口设计：</strong></p>
<ul>
<li><p>新增地址</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;addressBook<br>Method: POST</p>
</blockquote>
</li>
<li><p>查询当前登录用户的所有地址信息</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;addressBook&#x2F;list<br>Method: GET</p>
</blockquote>
</li>
<li><p>查询默认地址</p>
</li>
<li><p>根据id修改地址</p>
</li>
<li><p>根据id删除地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook<br>Method：DELETE</p>
</blockquote>
</li>
<li><p>根据id查询地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook&#x2F;{id}<br>Method：GET</p>
</blockquote>
</li>
<li><p>设置默认地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook&#x2F;default<br>Method：PUT</p>
</blockquote>
</li>
</ul>
<h6 id="数据库设计-address-book表"><a href="#数据库设计-address-book表" class="headerlink" title="数据库设计(address_book表)"></a>数据库设计(address_book表)</h6><h4 id="用户下单"><a href="#用户下单" class="headerlink" title="用户下单"></a>用户下单</h4><h6 id="在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货"><a href="#在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货" class="headerlink" title="在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货"></a>在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货</h6><p>用户下单后会产生订单相关数据，订单数据需要体现信息：</p>
<ul>
<li><strong>订单总金额是多少</strong>？</li>
<li><strong>哪个用户下的单</strong>？</li>
<li><strong>买的哪些商品</strong>？</li>
<li><strong>每个商品数量是多少</strong>？</li>
<li><strong>收货地址是哪</strong>？</li>
<li><strong>用户手机号是多少</strong>？</li>
</ul>
<p>餐盒费：用数量算</p>
<h5 id="用户下单接口设计"><a href="#用户下单接口设计" class="headerlink" title="用户下单接口设计"></a>用户下单接口设计</h5><blockquote>
<p><strong>请求方式</strong>：POST<br><strong>请求路径：</strong>&#x2F;user&#x2F;order&#x2F;submit</p>
<p><strong>参数：</strong></p>
<ul>
<li>地址簿id<del>addressBookId</del></li>
<li>配送状态(立即送出、选择送出时间)<del>deliveryStatus</del></li>
<li>打包费<del>packAmount</del></li>
<li>总金额<del>amount</del></li>
<li>备注<del>remark</del></li>
<li>餐具数量<del>tablewareNumber</del></li>
</ul>
</blockquote>
<h5 id="支付订单接口设计"><a href="#支付订单接口设计" class="headerlink" title="支付订单接口设计"></a>支付订单接口设计</h5><blockquote>
<p><strong>返回数据：</strong></p>
<ul>
<li>下单时间</li>
<li>订单总金额</li>
<li>订单号</li>
<li>订单id</li>
</ul>
</blockquote>
<h5 id="数据库设计订单表orders、订单明细表order-detail"><a href="#数据库设计订单表orders、订单明细表order-detail" class="headerlink" title="数据库设计订单表orders、订单明细表order_detail"></a>数据库设计<del>订单表orders、订单明细表order_detail</del></h5><ul>
<li>订单表 <strong>orders</strong><ul>
<li>谁的订单？</li>
<li>送哪去？</li>
<li>打哪个电话联系？</li>
<li>多少钱？</li>
<li>什么时间下的单？</li>
<li>什么时间支付的？</li>
<li>订单的状态？</li>
<li>订单号是多少？</li>
</ul>
</li>
<li>订单明细表 <strong>order_detail</strong><ul>
<li>当前明细属于哪个订单？</li>
<li>具体点的是什么商品？</li>
<li>这个商品点了几份？</li>
</ul>
</li>
</ul>
<h4 id="代码开发-4"><a href="#代码开发-4" class="headerlink" title="代码开发"></a>代码开发</h4><h6 id="用户下单1"><a href="#用户下单1" class="headerlink" title="用户下单1"></a>用户下单1</h6><h5 id="根据用户下单接口的参数设计DTO："><a href="#根据用户下单接口的参数设计DTO：" class="headerlink" title="根据用户下单接口的参数设计DTO："></a>根据用户下单接口的参数设计DTO：</h5><pre><code class="java">sky-pojo  com/sky/dto/OrdersSubmitDTO.java
package com.sky.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
public class OrdersSubmitDTO implements Serializable &#123;
    //地址簿id
    private Long addressBookId;
    //付款方式
    private int payMethod;
    //备注
    private String remark;
    //预计送达时间
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime estimatedDeliveryTime;
    //配送状态  1立即送出  0选择具体时间
    private Integer deliveryStatus;
    //餐具数量
    private Integer tablewareNumber;
    //餐具数量状态  1按餐量提供  0选择具体数量
    private Integer tablewareStatus;
    //打包费
    private Integer packAmount;
    //总金额
    private BigDecimal amount;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/vo/OrdersSubmitVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderSubmitVO implements Serializable &#123;
    //订单id
    private Long id;
    //订单号
    private String orderNumber;
    //订单金额
    private BigDecimal orderAmount;
    //下单时间
    private LocalDateTime orderTime;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/OrderController.java
package com.sky.controller.user;

import com.sky.dto.OrdersSubmitDTO;
import com.sky.result.Result;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController(&quot;userOrderController&quot;)
@RequestMapping(&quot;/user/order&quot;)
@Api(tags = &quot;用户订单相关接口&quot;)
@Slf4j
public class OrderController &#123;
    @Autowired
    private OrderService orderService;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @PostMapping(&quot;/submit&quot;)
    @ApiOperation(&quot;用户下单&quot;)
    public Result&lt;OrderSubmitVO&gt; submit(@RequestBody OrdersSubmitDTO ordersSubmitDTO) &#123;
        log.info(&quot;用户下单,参数为：&#123;&#125;&quot;, ordersSubmitDTO);
        OrderSubmitVO orderSubmitVO = orderService.submitOrder(ordersSubmitDTO);
        return Result.success(orderSubmitVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/OrderService.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderSubmitVO implements Serializable &#123;
    //订单id
    private Long id;
    //订单号
    private String orderNumber;
    //订单金额
    private BigDecimal orderAmount;
    //下单时间
    private LocalDateTime orderTime;
&#125;
</code></pre>
<h6 id="用户下单2"><a href="#用户下单2" class="headerlink" title="用户下单2"></a>用户下单2</h6><pre><code class="java">sky-pojo  com/sky/entity/AddressBook.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 地址簿
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AddressBook implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    //用户id
    private Long userId;

    //收货人
    private String consignee;

    //手机号
    private String phone;

    //性别 0 女 1 男
    private String sex;

    //省级区划编号
    private String provinceCode;

    //省级名称
    private String provinceName;

    //市级区划编号
    private String cityCode;

    //市级名称
    private String cityName;

    //区级区划编号
    private String districtCode;

    //区级名称
    private String districtName;

    //详细地址
    private String detail;

    //标签
    private String label;

    //是否默认 0否 1是
    private Integer isDefault;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.MessageConstant;
import com.sky.context.BaseContext;
import com.sky.dto.OrdersSubmitDTO;
import com.sky.entity.AddressBook;
import com.sky.entity.Orders;
import com.sky.entity.ShoppingCart;
import com.sky.exception.AddressBookBusinessException;
import com.sky.exception.ShoppingCartBusinessException;
import com.sky.mapper.AddressBookMapper;
import com.sky.mapper.OrderDetailMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private OrderDetailMapper orderDetailMapper;
    @Autowired
    private AddressBookMapper addressBookMapper;
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @Override
    public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) &#123;

        // 1.处理各种业务异常(地址簿为空，购物车数据为空)
        AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
        if (addressBook == null) &#123;
            // 抛出业务异常
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        &#125;
        // 查询当前用户购物车信息
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        shoppingCart.setUserId(userId);
        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);
        if (shoppingCartList == null || shoppingCartList.size() == 0) &#123;
            // 抛出业务异常
            throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        &#125;

        // 2.向订单表插入1条数据
        Orders orders = new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO, orders);
        orders.setOrderTime(LocalDateTime.now());
        orders.setPayStatus(Orders.UN_PAID);
        orders.setStatus(Orders.PENDING_PAYMENT);
        orders.setNumber(String.valueOf(System.currentTimeMillis()));//订单号
        orders.setPhone(addressBook.getPhone());
        orders.setConsignee(addressBook.getConsignee());
        orders.setUserId(userId);
        orderMapper.insert(orders);

        // 3.向订单明细表插入n条数据

        // 4,清空当前用户的购物车数据

        // 5.封装VO返回结果
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
package com.sky.mapper;

import com.sky.entity.Orders;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface OrderMapper &#123;
    /**
     * 用户下单
     * @param orders
     */
    void insert(Orders orders);
&#125;
</code></pre>
<h5 id="代码开发3"><a href="#代码开发3" class="headerlink" title="代码开发3"></a>代码开发3</h5><pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.MessageConstant;
import com.sky.context.BaseContext;
import com.sky.dto.OrdersSubmitDTO;
import com.sky.entity.AddressBook;
import com.sky.entity.OrderDetail;
import com.sky.entity.Orders;
import com.sky.entity.ShoppingCart;
import com.sky.exception.AddressBookBusinessException;
import com.sky.exception.ShoppingCartBusinessException;
import com.sky.mapper.AddressBookMapper;
import com.sky.mapper.OrderDetailMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private OrderDetailMapper orderDetailMapper;
    @Autowired
    private AddressBookMapper addressBookMapper;
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @Transactional
    public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) &#123;

        // 1.处理各种业务异常(地址簿为空，购物车数据为空)
        AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
        if (addressBook == null) &#123;
            // 抛出业务异常
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        &#125;
        // 查询当前用户购物车信息
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        shoppingCart.setUserId(userId);
        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);
        if (shoppingCartList == null || shoppingCartList.size() == 0) &#123;
            // 抛出业务异常
            throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        &#125;

        // 2.向订单表插入1条数据
        Orders orders = new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO, orders);
        orders.setOrderTime(LocalDateTime.now());
        orders.setPayStatus(Orders.UN_PAID);
        orders.setStatus(Orders.PENDING_PAYMENT);
        orders.setNumber(String.valueOf(System.currentTimeMillis()));//订单号
        orders.setPhone(addressBook.getPhone());
        orders.setConsignee(addressBook.getConsignee());
        orders.setUserId(userId);
        orderMapper.insert(orders);

        //批量插入订单明细数据
        List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;();
        // 3.向订单明细表插入n条数据
        for (ShoppingCart cart : shoppingCartList) &#123;
            OrderDetail orderDetail = new OrderDetail(); //订单明细
            BeanUtils.copyProperties(cart, orderDetail);
            orderDetail.setOrderId(orders.getId()); //设置当前订单明细关联的订单id
            orderDetailList.add(orderDetail);
        &#125;
        orderDetailMapper.insertBatch(orderDetailList);
        // 4.清空当前用户的购物车数据
        shoppingCartMapper.deleteByUserId(userId);
        // 5.封装VO返回结果
        OrderSubmitVO ordersubmitVO = OrderSubmitVO.builder()
                .id(orders.getId())
                .orderNumber(orders.getNumber())
                .orderAmount(orders.getAmount())
                .orderTime(orders.getOrderTime())
                .build();
        return ordersubmitVO;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderDetailMapper.java
package com.sky.mapper;

import com.sky.entity.OrderDetail;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface OrderDetailMapper &#123;
    /**
     * 批量插入订单明细数据
     */
    void insertBatch(List&lt;OrderDetail&gt; orderDetailList);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderDetailMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderDetailMapper&quot;&gt;

    &lt;insert id=&quot;insertBatch&quot;&gt;
        insert into order_detail (name, image, order_id, dish_id, setmeal_id, dish_flavor, number, amount)
        values
        &lt;foreach collection=&quot;orderDetailList&quot; item=&quot;od&quot; separator=&quot;,&quot;&gt;
            (#&#123;od.name&#125;,#&#123;od.image&#125;,#&#123;od.orderId&#125;,#&#123;od.dishId&#125;,#&#123;od.setmealId&#125;,#&#123;od.dishFlavor&#125;,#&#123;od.number&#125;,#&#123;od.amount&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="订单支付"><a href="#订单支付" class="headerlink" title="订单支付"></a>订单支付</h3><h5 id="微信支付产品-微信支付"><a href="#微信支付产品-微信支付" class="headerlink" title="微信支付产品 + 微信支付"></a>微信支付产品 + 微信支付</h5><p>参考：<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/static/product/product_index.shtml">https://pay.weixin.qq.com/static/product/product_index.shtml</a></p>
<h5 id="微信支付接入流程："><a href="#微信支付接入流程：" class="headerlink" title="微信支付接入流程："></a>微信支付接入流程：</h5><p>提交资料 → 签署协议 → 绑定场景</p>
<h6 id="微信小程序支付时序图："><a href="#微信小程序支付时序图：" class="headerlink" title="微信小程序支付时序图："></a>微信小程序支付时序图：</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/a0ad040fbbc2a25f299e2b9b93c5386ced4068ea/data/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg"></p>
<p><strong>JSAPI下单：</strong>商户系统调用该接口在微信支付服务后台生成预支付交易单</p>
<blockquote>
<p><strong>请求URL</strong>：<a target="_blank" rel="noopener" href="https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi">https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi</a></p>
</blockquote>
<h5 id="获取微信支付平台证书、商户私钥文件："><a href="#获取微信支付平台证书、商户私钥文件：" class="headerlink" title="获取微信支付平台证书、商户私钥文件："></a>获取微信支付平台证书、商户私钥文件：</h5><h4 id="内网穿透工具"><a href="#内网穿透工具" class="headerlink" title="内网穿透工具"></a>内网穿透工具</h4><blockquote>
<p>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day08\安装包<code>cpolar_amd64.msi</code></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://dashboard.cpolar.com/auth">cpolar - secure introspectable tunnels to localhost</a><br>验证<br>你的隧道<br>[复制token] → 在cpolar文件里&#x2F;cmd[C:\Program Files\cpolar] → cpolar.exe authtoken xxxx[Authtoken：这个是在网站验证里复制的] → cpolar.exe http 8080</p>
<p>cpolar by @bestexpresser                                                                                (Ctrl+C to quit)</p>
<p>Tunnel Status       online<br>Account             Pluminary (Plan: Free)<br>Version             2.86.16&#x2F;3.18<br>Web Interface       127.0.0.1:4042<br>Forwarding          <a target="_blank" rel="noopener" href="http://22d34b67.r9.cpolar.top/">http://22d34b67.r9.cpolar.top</a> -&gt; <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a><br>Forwarding          <a target="_blank" rel="noopener" href="https://22d34b67.r9.cpolar.top/">https://22d34b67.r9.cpolar.top</a> -&gt; <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a></p>
<p>Conn              0</p>
<p>Avg Conn Time       0.00ms</p>
<p>启动穿透地址：[22d34b67.r9.cpolar.top&#x2F;doc.html] (<a target="_blank" rel="noopener" href="https://22d34b67.r9.cpolar.top/doc.html">https://22d34b67.r9.cpolar.top/doc.html</a>)</p>
<p>此时正在下载资源<br>HTTP Requests</p>
<hr>
<p>GET &#x2F;v2&#x2F;api-docs              200<br>GET &#x2F;swagger-resources        200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-3b888a6 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-589faee 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-2d0bd79 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-0fd6771 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-0c58d94 200<br>GET &#x2F;webjars&#x2F;css&#x2F;chunk-62d2fe 200<br>GET &#x2F;webjars&#x2F;js&#x2F;app.0f2f48b5. 200</p>
<p>随后就可以访问到接口文档了！！<br><strong>原理：使用内网穿透工具临时获得一个域名</strong></p>
</blockquote>
<blockquote>
<p><strong>CPolar</strong> 和 <strong>SwitchHosts</strong> 是两种不同类型的软件，它们的功能和用途有所区别。</p>
<p>CPolar 是一款内网穿透软件，主要用于将本地运行的服务暴露到公网上，使得外网可以访问。它通过在本地和公网服务器之间建立一个安全的隧道，使得用户可以在任何地方通过互联网访问到本地的服务，比如网站、SSH、数据库等。</p>
<p>SwitchHosts 则是一款用于管理和切换本地hosts文件的软件。Hosts文件是操作系统用于将一些域名解析到特定的IP地址的一个文本文件。SwitchHosts 允许用户方便地添加、切换、备份不同的hosts规则，对于开发者来说，这在开发过程中进行域名映射和测试非常有用。</p>
<p>总结来说，CPolar主要用于内网穿透，而SwitchHosts用于hosts文件管理。两者解决的问题和适用场景不同，不是同一种软件。</p>
<hr>
<p>内网、公网、外网和CPolar这几个概念在网络通信中扮演着不同的角色，以下是它们的定义和它们之间的联系：</p>
<ol>
<li>内网（Local Network 或 Intranet）： 内网是指一个私有网络，通常是在家庭、办公室或企业内部使用。内网中的设备通常通过路由器连接，并使用私有IP地址（如192.168.x.x或10.x.x.x）。内网中的设备一般不能直接从外部互联网访问，它们之间的通信受到防火墙和NAT（网络地址转换）的保护。</li>
<li>公网（Public Network 或 Internet）： 公网是指全球范围内的开放网络，即互联网。公网上的设备使用公网IP地址，这些地址是全球唯一的，可以通过互联网被其他设备访问。网站、电子邮件服务器和其他在线服务都部署在公网上。</li>
<li>外网（External Network）： 外网通常是指相对于内网而言的任何外部网络，特别是指互联网。当说“外网”时，通常是指从内网之外访问的资源或服务。</li>
<li>CPolar： CPolar是一款内网穿透工具，它的主要作用是帮助内网中的设备暴露服务到公网上，使得这些服务可以被外网访问。以下是CPolar与内网、公网、外网之间的联系：</li>
</ol>
<ul>
<li>内网到公网：CPolar在本地设备上运行一个客户端，该客户端与CPolar的服务器建立连接。当外部网络（公网）尝试访问CPolar服务器上配置的特定端口时，CPolar服务器会将这些请求转发到运行CPolar客户端的内网设备上。</li>
<li>公网访问：通过CPolar，内网中的服务可以被赋予一个公网可访问的地址（通常是CPolar服务器的一个子域名或自定义域名），这样外网的任何用户都可以通过这个地址访问到内网的服务。</li>
</ul>
<p>简而言之，CPolar是实现内网服务与公网之间通信的桥梁，它使得原本只能在局域网内部访问的服务能够被外网的用户访问。这对于远程工作、调试、以及需要在公网上提供服务的内网应用来说非常有用</p>
</blockquote>
<h5 id="导入功能代码【由于没有微信凭证-此接口未能正常开发-但代码均可学习】"><a href="#导入功能代码【由于没有微信凭证-此接口未能正常开发-但代码均可学习】" class="headerlink" title="导入功能代码【由于没有微信凭证 此接口未能正常开发 但代码均可学习】"></a>导入功能代码【由于没有微信凭证 此接口未能正常开发 但代码均可学习】</h5><pre><code class="yaml">sky-server  application-dev.yml
 wechat:
    appid: wxffb3637a228223b8
    secret: 84311df9199ecacdf4f12d27b6b9522d
    mchid : 1561414331
    mchSerialNo: 4B3B3DC35414AD50B1B755BAF8DE9CC7CF407606
    privateKeyFilePath: D:\pay\apiclient_key.pem
    apiV3Key: CZBK51236435wxpay435434323FFDuv3
    weChatPayCertFilePath: D:\pay\wechatpay_166D96F876F45C7D07CE98952A96EC980368ACFC.pem
    notifyUrl: https://58869fb.r2.cpolar.top/notify/paySuccess
    refundNotifyUrl: https://58869fb.r2.cpolar.top/notify/refundSuccess
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/OrderController.java
/**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    @PutMapping(&quot;/payment&quot;)
    @ApiOperation(&quot;订单支付&quot;)
    public Result&lt;OrderPaymentVO&gt; payment(@RequestBody OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        log.info(&quot;订单支付：&#123;&#125;&quot;, ordersPaymentDTO);
        OrderPaymentVO orderPaymentVO = orderService.payment(ordersPaymentDTO);
        log.info(&quot;生成预支付交易单：&#123;&#125;&quot;, orderPaymentVO);
        return Result.success(orderPaymentVO);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/OrderService.java
/**
     * 订单支付
     * @param ordersPaymentDTO
     * @return
     */
    OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception;

    /**
     * 支付成功，修改订单状态
     * @param outTradeNo
     */
    void paySuccess(String outTradeNo);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
 @Autowired
    private UserMapper userMapper;
 @Autowired
    private WeChatPayUtil weChatPayUtil;

    
    /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        // 查询订单
        Orders order = orderMapper.getByOrderNumber(ordersPaymentDTO.getOrderNumber());
        if (order == null) &#123;
            throw new OrderBusinessException(&quot;订单不存在&quot;);
        &#125;

        // 检查订单支付状态
        if (order.getPayStatus() == 1) &#123; // 1 表示已支付
            throw new OrderBusinessException(&quot;该订单已支付&quot;);
        &#125;
        order.setPayStatus(1);

        // 更新订单支付状态为已支付
        order.setPayStatus(Orders.PAID);
        order.setCheckoutTime(LocalDateTime.now());
        order.setPayMethod(ordersPaymentDTO.getPayMethod());
        order.setStatus(Orders.CONFIRMED);

        orderMapper.update(order);

        // 构造并返回支付结果对象
        OrderPaymentVO orderPaymentVO = new OrderPaymentVO();
        orderPaymentVO.setOrderNumber(order.getNumber()); // 订单号
        orderPaymentVO.setPaymentTime(new Date());
        orderPaymentVO.setPaymentStatus(&quot;SUCCESS&quot;);

        return orderPaymentVO;
    &#125;
    /**
     * 支付成功，修改订单状态
     *
     * @param outTradeNo
     */
    public void paySuccess(String outTradeNo) &#123;
        // 当前登录用户id
        Long userId = BaseContext.getCurrentId();

        // 根据订单号查询当前用户的订单
        Orders ordersDB = orderMapper.getByNumberAndUserId(outTradeNo, userId);

        // 根据订单id更新订单的状态、支付方式、支付状态、结账时间
        Orders orders = Orders.builder()
                .id(ordersDB.getId())
                .status(Orders.TO_BE_CONFIRMED)
                .payStatus(Orders.PAID)
                .checkoutTime(LocalDateTime.now())
                .build();

        orderMapper.update(orders);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.dto.GoodsSalesDTO;
import com.sky.dto.OrdersPageQueryDTO;
import com.sky.entity.Orders;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Mapper
public interface OrderMapper &#123;
    /**
     * 插入订单数据
     * @param order
     */
    void insert(Orders order);

    /**
     * 根据订单号和用户id查询订单
     * @param orderNumber
     * @param userId
     */
    @Select(&quot;select * from orders where number = #&#123;orderNumber&#125; and user_id= #&#123;userId&#125;&quot;)
    Orders getByNumberAndUserId(String orderNumber, Long userId);

    /**
     * 修改订单信息
     * @param orders
     */
    void update(Orders orders);
    /**
     * 根据id查询订单
     * @param id
     */
    @Select(&quot;select * from orders where id = #&#123;id&#125;&#125;&quot;)
    Orders getById(Long id);
&#125;
</code></pre>
<pre><code class="xml">resources/mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;Orders&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into orders
        (number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark,
         phone, address, consignee, estimated_delivery_time, delivery_status, pack_amount, tableware_number,
         tableware_status)
        values (#&#123;number&#125;, #&#123;status&#125;, #&#123;userId&#125;, #&#123;addressBookId&#125;, #&#123;orderTime&#125;, #&#123;checkoutTime&#125;, #&#123;payMethod&#125;,
                #&#123;payStatus&#125;, #&#123;amount&#125;, #&#123;remark&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;consignee&#125;,
                #&#123;estimatedDeliveryTime&#125;, #&#123;deliveryStatus&#125;, #&#123;packAmount&#125;, #&#123;tablewareNumber&#125;, #&#123;tablewareStatus&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.sky.entity.Orders&quot;&gt;
        update orders
        &lt;set&gt;
            &lt;if test=&quot;cancelReason != null and cancelReason!=&#39;&#39; &quot;&gt;
                cancel_reason=#&#123;cancelReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;rejectionReason != null and rejectionReason!=&#39;&#39; &quot;&gt;
                rejection_reason=#&#123;rejectionReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;cancelTime != null&quot;&gt;
                cancel_time=#&#123;cancelTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payStatus != null&quot;&gt;
                pay_status=#&#123;payStatus&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payMethod != null&quot;&gt;
                pay_method=#&#123;payMethod&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;checkoutTime != null&quot;&gt;
                checkout_time=#&#123;checkoutTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;deliveryTime != null&quot;&gt;
                delivery_time = #&#123;deliveryTime&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
        
        &lt;!-- 根据订单号查询订单 --&gt;
    &lt;select id=&quot;getByOrderNumber&quot; parameterType=&quot;String&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders where number = #&#123;orderNumber&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
  @Select(&quot;select * from user where id = #&#123;id&#125;&#125;&quot;)
    User getById(Long userId);
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/notify/PayNotifyController.java
package com.sky.controller.notify;

import com.alibaba.druid.support.json.JSONUtils;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
//import com.sky.annotation.IgnoreToken;
import com.sky.properties.WeChatProperties;
import com.sky.service.OrderService;
import com.wechat.pay.contrib.apache.httpclient.util.AesUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.entity.ContentType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;

/**
 * 支付回调相关接口
 */
@RestController
@RequestMapping(&quot;/notify&quot;)
@Slf4j
public class PayNotifyController &#123;
    @Autowired
    private OrderService orderService;
    @Autowired
    private WeChatProperties weChatProperties;

    /**
     * 支付成功回调
     *
     * @param request
     */
//  @IgnoreToken
    @RequestMapping(&quot;/paySuccess&quot;)
    public void paySuccessNotify(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        //读取数据
        String body = readData(request);
        log.info(&quot;支付成功回调：&#123;&#125;&quot;, body);

        //数据解密
        String plainText = decryptData(body);
        log.info(&quot;解密后的文本：&#123;&#125;&quot;, plainText);

        JSONObject jsonObject = JSON.parseObject(plainText);
        String outTradeNo = jsonObject.getString(&quot;out_trade_no&quot;);//商户平台订单号
        String transactionId = jsonObject.getString(&quot;transaction_id&quot;);//微信支付交易号

        log.info(&quot;商户平台订单号：&#123;&#125;&quot;, outTradeNo);
        log.info(&quot;微信支付交易号：&#123;&#125;&quot;, transactionId);

        //业务处理，修改订单状态、来单提醒
        orderService.paySuccess(outTradeNo);

        //给微信响应
        responseToWeixin(response);
    &#125;

    /**
     * 读取数据
     *
     * @param request
     * @return
     * @throws Exception
     */
    private String readData(HttpServletRequest request) throws Exception &#123;
        BufferedReader reader = request.getReader();
        StringBuilder result = new StringBuilder();
        String line = null;
        while ((line = reader.readLine()) != null) &#123;
            if (result.length() &gt; 0) &#123;
                result.append(&quot;\n&quot;);
            &#125;
            result.append(line);
        &#125;
        return result.toString();
    &#125;

    /**
     * 数据解密
     *
     * @param body
     * @return
     * @throws Exception
     */
    private String decryptData(String body) throws Exception &#123;
        JSONObject resultObject = JSON.parseObject(body);
        JSONObject resource = resultObject.getJSONObject(&quot;resource&quot;);
        String ciphertext = resource.getString(&quot;ciphertext&quot;);
        String nonce = resource.getString(&quot;nonce&quot;);
        String associatedData = resource.getString(&quot;associated_data&quot;);

        AesUtil aesUtil = new AesUtil(weChatProperties.getApiV3Key().getBytes(StandardCharsets.UTF_8));
        //密文解密
        String plainText = aesUtil.decryptToString(associatedData.getBytes(StandardCharsets.UTF_8),
                nonce.getBytes(StandardCharsets.UTF_8),
                ciphertext);

        return plainText;
    &#125;

    /**
     * 给微信响应
     * @param response
     */
    private void responseToWeixin(HttpServletResponse response) throws Exception&#123;
        response.setStatus(200);
        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, &quot;SUCCESS&quot;);
        map.put(&quot;message&quot;, &quot;SUCCESS&quot;);
        response.setHeader(&quot;Content-type&quot;, ContentType.APPLICATION_JSON.toString());
        response.getOutputStream().write(JSONUtils.toJSONString(map).getBytes(StandardCharsets.UTF_8));
        response.flushBuffer();
    &#125;
&#125;
</code></pre>
<h3 id="查询历史订单"><a href="#查询历史订单" class="headerlink" title="查询历史订单"></a>查询历史订单</h3><p>业务规则</p>
<ul>
<li>分页查询历史订单</li>
<li>可以根据订单状态查询</li>
<li>展示订单数据时，需要展示的数据包括：下单时间、订单状态、订单金额、订单明细（商品名称、图片）</li>
</ul>
<p>接口设计：参见接口文档</p>
<h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><h4 id="1-2-1-user-x2F-OrderController"><a href="#1-2-1-user-x2F-OrderController" class="headerlink" title="1.2.1 user&#x2F;OrderController"></a>1.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 历史订单查询
     *
     * @param page
     * @param pageSize
     * @param status   订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
     * @return
     */
    @GetMapping(&quot;/historyOrders&quot;)
    @ApiOperation(&quot;历史订单查询&quot;)
    public Result&lt;PageResult&gt; page(int page, int pageSize, Integer status) &#123;
        PageResult pageResult = orderService.pageQuery4User(page, pageSize, status);
        return Result.success(pageResult);
    &#125;
</code></pre>
<h4 id="1-2-2-OrderService"><a href="#1-2-2-OrderService" class="headerlink" title="1.2.2 OrderService"></a>1.2.2 OrderService</h4><pre><code class="java">    /**
     * 用户端订单分页查询
     * @param page
     * @param pageSize
     * @param status
     * @return
     */
    PageResult pageQuery4User(int page, int pageSize, Integer status);
</code></pre>
<h4 id="1-2-3-OrderServiceImpl"><a href="#1-2-3-OrderServiceImpl" class="headerlink" title="1.2.3 OrderServiceImpl"></a>1.2.3 OrderServiceImpl</h4><pre><code class="java">/**
     * 用户端订单分页查询
     *
     * @param pageNum
     * @param pageSize
     * @param status
     * @return
     */
    public PageResult pageQuery4User(int pageNum, int pageSize, Integer status) &#123;
        // 设置分页
        PageHelper.startPage(pageNum, pageSize);

        OrdersPageQueryDTO ordersPageQueryDTO = new OrdersPageQueryDTO();
        ordersPageQueryDTO.setUserId(BaseContext.getCurrentId());
        ordersPageQueryDTO.setStatus(status);

        // 分页条件查询
        Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);

        List&lt;OrderVO&gt; list = new ArrayList();

        // 查询出订单明细，并封装入OrderVO进行响应
        if (page != null &amp;&amp; page.getTotal() &gt; 0) &#123;
            for (Orders orders : page) &#123;
                Long orderId = orders.getId();// 订单id

                // 查询订单明细
                List&lt;OrderDetail&gt; orderDetails = orderDetailMapper.getByOrderId(orderId);

                OrderVO orderVO = new OrderVO();
                BeanUtils.copyProperties(orders, orderVO);
                orderVO.setOrderDetailList(orderDetails);

                list.add(orderVO);
            &#125;
        &#125;
        return new PageResult(page.getTotal(), list);
    &#125;
</code></pre>
<h4 id="1-2-4-OrderMapper"><a href="#1-2-4-OrderMapper" class="headerlink" title="1.2.4 OrderMapper"></a>1.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 分页条件查询并按下单时间排序
     * @param ordersPageQueryDTO
     */
    Page&lt;Orders&gt; pageQuery(OrdersPageQueryDTO ordersPageQueryDTO);
</code></pre>
<h4 id="1-2-5-OrderMapper-xml"><a href="#1-2-5-OrderMapper-xml" class="headerlink" title="1.2.5 OrderMapper.xml"></a>1.2.5 OrderMapper.xml</h4><pre><code class="xml">    &lt;select id=&quot;pageQuery&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders
        &lt;where&gt;
            &lt;if test=&quot;number != null and number!=&#39;&#39;&quot;&gt;
                and number like concat(&#39;%&#39;,#&#123;number&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;phone != null and phone!=&#39;&#39;&quot;&gt;
                and phone like concat(&#39;%&#39;,#&#123;phone&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;beginTime != null&quot;&gt;
                and order_time &amp;gt;= #&#123;beginTime&#125;
            &lt;/if&gt;
            &lt;if test=&quot;endTime != null&quot;&gt;
                and order_time &amp;lt;= #&#123;endTime&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by order_time desc
    &lt;/select&gt;
</code></pre>
<h4 id="1-2-6-OrderDetailMapper"><a href="#1-2-6-OrderDetailMapper" class="headerlink" title="1.2.6 OrderDetailMapper"></a>1.2.6 OrderDetailMapper</h4><pre><code class="java">    /**
     * 根据订单id查询订单明细
     * @param orderId
     * @return
     */
    @Select(&quot;select * from order_detail where order_id = #&#123;orderId&#125;&quot;)
    List&lt;OrderDetail&gt; getByOrderId(Long orderId);
</code></pre>
<h3 id="查询订单详情"><a href="#查询订单详情" class="headerlink" title="查询订单详情"></a>查询订单详情</h3><h4 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h4><h6 id="2-2-1-user-x2F-OrderController"><a href="#2-2-1-user-x2F-OrderController" class="headerlink" title="2.2.1 user&#x2F;OrderController"></a>2.2.1 user&#x2F;OrderController</h6><pre><code class="java">    /**
     * 查询订单详情
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/orderDetail/&#123;id&#125;&quot;)
    @ApiOperation(&quot;查询订单详情&quot;)
    public Result&lt;OrderVO&gt; details(@PathVariable(&quot;id&quot;) Long id) &#123;
        OrderVO orderVO = orderService.details(id);
        return Result.success(orderVO);
    &#125;
</code></pre>
<h4 id="2-2-2-OrderService"><a href="#2-2-2-OrderService" class="headerlink" title="2.2.2 OrderService"></a>2.2.2 OrderService</h4><pre><code class="java">    /**
     * 查询订单详情
     * @param id
     * @return
     */
    OrderVO details(Long id);
</code></pre>
<h4 id="2-2-3-OrderServiceImpl"><a href="#2-2-3-OrderServiceImpl" class="headerlink" title="2.2.3 OrderServiceImpl"></a>2.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 查询订单详情
     *
     * @param id
     * @return
     */
    public OrderVO details(Long id) &#123;
        // 根据id查询订单
        Orders orders = orderMapper.getById(id);

        // 查询该订单对应的菜品/套餐明细
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());

        // 将该订单及其详情封装到OrderVO并返回
        OrderVO orderVO = new OrderVO();
        BeanUtils.copyProperties(orders, orderVO);
        orderVO.setOrderDetailList(orderDetailList);

        return orderVO;
    &#125;
</code></pre>
<h4 id="2-2-4-OrderMapper"><a href="#2-2-4-OrderMapper" class="headerlink" title="2.2.4 OrderMapper"></a>2.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 根据id查询订单
     * @param id
     */
    @Select(&quot;select * from orders where id=#&#123;id&#125;&quot;)
    Orders getById(Long id);
</code></pre>
<h3 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h3><p>业务规则：</p>
<ul>
<li>待支付和待接单状态下，用户可直接取消订单</li>
<li>商家已接单状态下，用户取消订单需电话沟通商家</li>
<li>派送中状态下，用户取消订单需电话沟通商家</li>
<li>如果在待接单状态下取消订单，需要给用户退款</li>
<li>取消订单后需要将订单状态修改为“已取消”</li>
</ul>
<h4 id="3-2-1-user-x2F-OrderController"><a href="#3-2-1-user-x2F-OrderController" class="headerlink" title="3.2.1 user&#x2F;OrderController"></a>3.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 用户取消订单
     *
     * @return
     */
    @PutMapping(&quot;/cancel/&#123;id&#125;&quot;)
    @ApiOperation(&quot;取消订单&quot;)
    public Result cancel(@PathVariable(&quot;id&quot;) Long id) throws Exception &#123;
        orderService.userCancelById(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="3-2-2-OrderService"><a href="#3-2-2-OrderService" class="headerlink" title="3.2.2 OrderService"></a>3.2.2 OrderService</h4><pre><code class="java">    /**
     * 用户取消订单
     * @param id
     */
    void userCancelById(Long id) throws Exception;
</code></pre>
<h4 id="3-2-3-OrderServiceImpl"><a href="#3-2-3-OrderServiceImpl" class="headerlink" title="3.2.3 OrderServiceImpl"></a>3.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 用户取消订单
     *
     * @param id
     */
    public void userCancelById(Long id) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在
        if (ordersDB == null) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_NOT_FOUND);
        &#125;

        //订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
        if (ordersDB.getStatus() &gt; 2) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());

        // 订单处于待接单状态下取消，需要进行退款
        if (ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;
            //调用微信支付退款接口
            weChatPayUtil.refund(
                    ordersDB.getNumber(), //商户订单号
                    ordersDB.getNumber(), //商户退款单号
                    new BigDecimal(0.01),//退款金额，单位 元
                    new BigDecimal(0.01));//原订单金额

            //支付状态修改为 退款
            orders.setPayStatus(Orders.REFUND);
        &#125;

        // 更新订单状态、取消原因、取消时间
        orders.setStatus(Orders.CANCELLED);
        orders.setCancelReason(&quot;用户取消&quot;);
        orders.setCancelTime(LocalDateTime.now());
        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="再来一单"><a href="#再来一单" class="headerlink" title="再来一单"></a>再来一单</h3><h4 id="4-2-1-user-x2F-OrderController"><a href="#4-2-1-user-x2F-OrderController" class="headerlink" title="4.2.1 user&#x2F;OrderController"></a>4.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     * @return
     */
    @PostMapping(&quot;/repetition/&#123;id&#125;&quot;)
    @ApiOperation(&quot;再来一单&quot;)
    public Result repetition(@PathVariable Long id) &#123;
        orderService.repetition(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="4-2-2-OrderService"><a href="#4-2-2-OrderService" class="headerlink" title="4.2.2 OrderService"></a>4.2.2 OrderService</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     */
    void repetition(Long id);
</code></pre>
<h4 id="4-2-3-OrderServiceImpl"><a href="#4-2-3-OrderServiceImpl" class="headerlink" title="4.2.3 OrderServiceImpl"></a>4.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     */
   @Override
    public void repetition(Long id) &#123;
        //查询当前用户id
        Long userId = BaseContext.getCurrentId();
        //根据订单id查询当前订单详情
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(id);

        // 将订单详情对象转换为购物车对象
        // 这一行使用 map 方法对每个 OrderDetail 对象进行转换操作，x 是当前遍历的 OrderDetail 对象
        List&lt;ShoppingCart&gt; shoppingCartList = orderDetailList.stream().map(x -&gt; &#123;
            //表示一个函数，该函数接受一个参数 x 并返回一个新对象
            ShoppingCart shoppingCart = new ShoppingCart();

            // 将原订单详情里面的菜品信息重新复制到购物车对象中
            BeanUtils.copyProperties(x, shoppingCart, &quot;id&quot;);
            shoppingCart.setUserId(userId);
            shoppingCart.setCreateTime(LocalDateTime.now());

            return shoppingCart;
        &#125;).collect(Collectors.toList());
// 使用 collect 方法将转换后的 ShoppingCart 对象收集到一个新的 List&lt;ShoppingCart&gt; 列表中
        // 将购物车对象批量添加到数据库
        shoppingCartMapper.insertBatch(shoppingCartList);
    &#125;
</code></pre>
<h4 id="4-2-4-ShoppingCartMapper"><a href="#4-2-4-ShoppingCartMapper" class="headerlink" title="4.2.4 ShoppingCartMapper"></a>4.2.4 ShoppingCartMapper</h4><pre><code class="java">    /**
     * 批量插入购物车数据
     *
     * @param shoppingCartList
     */
    void insertBatch(List&lt;ShoppingCart&gt; shoppingCartList);
</code></pre>
<h4 id="4-2-5-ShoppingCartMapper-xml"><a href="#4-2-5-ShoppingCartMapper-xml" class="headerlink" title="4.2.5 ShoppingCartMapper.xml"></a>4.2.5 ShoppingCartMapper.xml</h4><pre><code class="xml">&lt;insert id=&quot;insertBatch&quot; parameterType=&quot;list&quot;&gt;
        insert into shopping_cart
        (name, image, user_id, dish_id, setmeal_id, dish_flavor, number, amount, create_time)
        values
        &lt;foreach collection=&quot;shoppingCartList&quot; item=&quot;sc&quot; separator=&quot;,&quot;&gt;
            
        &lt;/foreach&gt;
&lt;/insert&gt;
</code></pre>
<h3 id="订单搜索"><a href="#订单搜索" class="headerlink" title="订单搜索"></a>订单搜索</h3><h4 id="1-2-1-admin-x2F-OrderController"><a href="#1-2-1-admin-x2F-OrderController" class="headerlink" title="1.2.1 admin&#x2F;OrderController"></a>1.2.1 admin&#x2F;OrderController</h4><p>在admin包下创建OrderController</p>
<pre><code class="java">/**
 * 订单管理
 */
@RestController(&quot;adminOrderController&quot;)
@RequestMapping(&quot;/admin/order&quot;)
@Slf4j
@Api(tags = &quot;订单管理接口&quot;)
public class OrderController &#123;

    @Autowired
    private OrderService orderService;

    /**
     * 订单搜索
     *
     * @param ordersPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/conditionSearch&quot;)
    @ApiOperation(&quot;订单搜索&quot;)
    public Result&lt;PageResult&gt; conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO) &#123;
        PageResult pageResult = orderService.conditionSearch(ordersPageQueryDTO);
        return Result.success(pageResult);
    &#125;
&#125;
</code></pre>
<h4 id="1-2-2-OrderService-1"><a href="#1-2-2-OrderService-1" class="headerlink" title="1.2.2 OrderService"></a>1.2.2 OrderService</h4><pre><code class="java">    /**
     * 条件搜索订单
     * @param ordersPageQueryDTO
     * @return
     */
    PageResult conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO);
</code></pre>
<h4 id="1-2-3-OrderServiceImpl-1"><a href="#1-2-3-OrderServiceImpl-1" class="headerlink" title="1.2.3 OrderServiceImpl"></a>1.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 订单搜索
     *
     * @param ordersPageQueryDTO
     * @return
     */
    public PageResult conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO) &#123;
        PageHelper.startPage(ordersPageQueryDTO.getPage(), ordersPageQueryDTO.getPageSize());

        Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);

        // 部分订单状态，需要额外返回订单菜品信息，将Orders转化为OrderVO
        List&lt;OrderVO&gt; orderVOList = getOrderVOList(page);

        return new PageResult(page.getTotal(), orderVOList);
    &#125;

    private List&lt;OrderVO&gt; getOrderVOList(Page&lt;Orders&gt; page) &#123;
        // 需要返回订单菜品信息，自定义OrderVO响应结果
        List&lt;OrderVO&gt; orderVOList = new ArrayList&lt;&gt;();

        List&lt;Orders&gt; ordersList = page.getResult();
        if (!CollectionUtils.isEmpty(ordersList)) &#123;
            for (Orders orders : ordersList) &#123;
                // 将共同字段复制到OrderVO
                OrderVO orderVO = new OrderVO();
                BeanUtils.copyProperties(orders, orderVO);
                String orderDishes = getOrderDishesStr(orders);

                // 将订单菜品信息封装到orderVO中，并添加到orderVOList
                orderVO.setOrderDishes(orderDishes);
                orderVOList.add(orderVO);
            &#125;
        &#125;
        return orderVOList;
    &#125;

    /**
     * 根据订单id获取菜品信息字符串
     *
     * @param orders
     * @return
     */
    private String getOrderDishesStr(Orders orders) &#123;
        // 查询订单菜品详情信息（订单中的菜品和数量）
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());

        // 将每一条订单菜品信息拼接为字符串（格式：宫保鸡丁*3；）
        List&lt;String&gt; orderDishList = orderDetailList.stream().map(x -&gt; &#123;
            String orderDish = x.getName() + &quot;*&quot; + x.getNumber() + &quot;;&quot;;
            return orderDish;
        &#125;).collect(Collectors.toList());

        // 将该订单对应的所有菜品信息拼接在一起
        return String.join(&quot;&quot;, orderDishList);
    &#125;
</code></pre>
<h3 id="各个状态的订单数量统计"><a href="#各个状态的订单数量统计" class="headerlink" title="各个状态的订单数量统计"></a>各个状态的订单数量统计</h3><h4 id="2-2-1-admin-x2F-OrderController"><a href="#2-2-1-admin-x2F-OrderController" class="headerlink" title="2.2.1 admin&#x2F;OrderController"></a>2.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     *
     * @return
     */
    @GetMapping(&quot;/statistics&quot;)
    @ApiOperation(&quot;各个状态的订单数量统计&quot;)
    public Result&lt;OrderStatisticsVO&gt; statistics() &#123;
        OrderStatisticsVO orderStatisticsVO = orderService.statistics();
        return Result.success(orderStatisticsVO);
    &#125;
</code></pre>
<h4 id="2-2-2-OrderService-1"><a href="#2-2-2-OrderService-1" class="headerlink" title="2.2.2 OrderService"></a>2.2.2 OrderService</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     * @return
     */
    OrderStatisticsVO statistics();
</code></pre>
<h4 id="2-2-3-OrderServiceImpl-1"><a href="#2-2-3-OrderServiceImpl-1" class="headerlink" title="2.2.3 OrderServiceImpl"></a>2.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     *
     * @return
     */
    public OrderStatisticsVO statistics() &#123;
        // 根据状态，分别查询出待接单、待派送、派送中的订单数量
        Integer toBeConfirmed = orderMapper.countStatus(Orders.TO_BE_CONFIRMED);
        Integer confirmed = orderMapper.countStatus(Orders.CONFIRMED);
        Integer deliveryInProgress = orderMapper.countStatus(Orders.DELIVERY_IN_PROGRESS);

        // 将查询出的数据封装到orderStatisticsVO中响应
        OrderStatisticsVO orderStatisticsVO = new OrderStatisticsVO();
        orderStatisticsVO.setToBeConfirmed(toBeConfirmed);
        orderStatisticsVO.setConfirmed(confirmed);
        orderStatisticsVO.setDeliveryInProgress(deliveryInProgress);
        return orderStatisticsVO;
    &#125;
</code></pre>
<h4 id="2-2-4-OrderMapper-1"><a href="#2-2-4-OrderMapper-1" class="headerlink" title="2.2.4 OrderMapper"></a>2.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 根据状态统计订单数量
     * @param status
     */
    @Select(&quot;select count(id) from orders where status = #&#123;status&#125;&quot;)
    Integer countStatus(Integer status);
</code></pre>
<h3 id="查询订单详情-1"><a href="#查询订单详情-1" class="headerlink" title="查询订单详情"></a>查询订单详情</h3><p>业务规则：</p>
<ul>
<li>订单详情页面需要展示订单基本信息（状态、订单号、下单时间、收货人、电话、收货地址、金额等）</li>
<li>订单详情页面需要展示订单明细数据（商品名称、数量、单价）</li>
</ul>
<h4 id="3-2-1-admin-x2F-OrderController"><a href="#3-2-1-admin-x2F-OrderController" class="headerlink" title="3.2.1 admin&#x2F;OrderController"></a>3.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 订单详情
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/details/&#123;id&#125;&quot;)
    @ApiOperation(&quot;查询订单详情&quot;)
    public Result&lt;OrderVO&gt; details(@PathVariable(&quot;id&quot;) Long id) &#123;
        OrderVO orderVO = orderService.details(id);
        return Result.success(orderVO);
    &#125;
</code></pre>
<h3 id="接单"><a href="#接单" class="headerlink" title="接单"></a>接单</h3><p>业务规则：</p>
<ul>
<li>商家接单其实就是将订单的状态修改为“已接单”</li>
</ul>
<h4 id="4-2-1-admin-x2F-OrderController"><a href="#4-2-1-admin-x2F-OrderController" class="headerlink" title="4.2.1 admin&#x2F;OrderController"></a>4.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 接单
     *
     * @return
     */
    @PutMapping(&quot;/confirm&quot;)
    @ApiOperation(&quot;接单&quot;)
    public Result confirm(@RequestBody OrdersConfirmDTO ordersConfirmDTO) &#123;
        orderService.confirm(ordersConfirmDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="4-2-2-OrderService-1"><a href="#4-2-2-OrderService-1" class="headerlink" title="4.2.2 OrderService"></a>4.2.2 OrderService</h4><pre><code class="java">    /**
     * 接单
     *
     * @param ordersConfirmDTO
     */
    void confirm(OrdersConfirmDTO ordersConfirmDTO);
</code></pre>
<h4 id="4-2-3-OrderServiceImpl-1"><a href="#4-2-3-OrderServiceImpl-1" class="headerlink" title="4.2.3 OrderServiceImpl"></a>4.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 接单
     *
     * @param ordersConfirmDTO
     */
    public void confirm(OrdersConfirmDTO ordersConfirmDTO) &#123;
        Orders orders = Orders.builder()
                .id(ordersConfirmDTO.getId())
                .status(Orders.CONFIRMED)
                .build();

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="拒单"><a href="#拒单" class="headerlink" title="拒单"></a>拒单</h3><p>业务规则：</p>
<ul>
<li>商家拒单其实就是将订单状态修改为“已取消”</li>
<li>只有订单处于“待接单”状态时可以执行拒单操作</li>
<li>商家拒单时需要指定拒单原因</li>
<li>商家拒单时，如果用户已经完成了支付，需要为用户退款</li>
</ul>
<h4 id="5-2-1-admin-x2F-OrderController"><a href="#5-2-1-admin-x2F-OrderController" class="headerlink" title="5.2.1 admin&#x2F;OrderController"></a>5.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 拒单
     *
     * @return
     */
    @PutMapping(&quot;/rejection&quot;)
    @ApiOperation(&quot;拒单&quot;)
    public Result rejection(@RequestBody OrdersRejectionDTO ordersRejectionDTO) throws Exception &#123;
        orderService.rejection(ordersRejectionDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="5-2-2-OrderService"><a href="#5-2-2-OrderService" class="headerlink" title="5.2.2 OrderService"></a>5.2.2 OrderService</h4><pre><code class="java">    /**
     * 拒单
     *
     * @param ordersRejectionDTO
     */
    void rejection(OrdersRejectionDTO ordersRejectionDTO) throws Exception;
</code></pre>
<h4 id="5-2-3-OrderServiceImpl"><a href="#5-2-3-OrderServiceImpl" class="headerlink" title="5.2.3 OrderServiceImpl"></a>5.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 拒单
     *
     * @param ordersRejectionDTO
     */
    public void rejection(OrdersRejectionDTO ordersRejectionDTO) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(ordersRejectionDTO.getId());

        // 订单只有存在且状态为2（待接单）才可以拒单
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        //支付状态
        Integer payStatus = ordersDB.getPayStatus();
        if (payStatus == Orders.PAID) &#123;
            //用户已支付，需要退款
            String refund = weChatPayUtil.refund(
                    ordersDB.getNumber(),
                    ordersDB.getNumber(),
                    new BigDecimal(0.01),
                    new BigDecimal(0.01));
            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);
        &#125;

        // 拒单需要退款，根据订单id更新订单状态、拒单原因、取消时间
        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        orders.setStatus(Orders.CANCELLED);
        orders.setRejectionReason(ordersRejectionDTO.getRejectionReason());
        orders.setCancelTime(LocalDateTime.now());

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="取消订单-1"><a href="#取消订单-1" class="headerlink" title="取消订单"></a>取消订单</h3><h4 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h4><h4 id="6-2-1-admin-x2F-OrderController"><a href="#6-2-1-admin-x2F-OrderController" class="headerlink" title="6.2.1 admin&#x2F;OrderController"></a>6.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 取消订单
     *
     * @return
     */
    @PutMapping(&quot;/cancel&quot;)
    @ApiOperation(&quot;取消订单&quot;)
    public Result cancel(@RequestBody OrdersCancelDTO ordersCancelDTO) throws Exception &#123;
        orderService.cancel(ordersCancelDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="6-2-2-OrderService"><a href="#6-2-2-OrderService" class="headerlink" title="6.2.2 OrderService"></a>6.2.2 OrderService</h4><pre><code class="java">    /**
     * 商家取消订单
     *
     * @param ordersCancelDTO
     */
    void cancel(OrdersCancelDTO ordersCancelDTO) throws Exception;
</code></pre>
<h4 id="6-2-3-OrderServiceImpl"><a href="#6-2-3-OrderServiceImpl" class="headerlink" title="6.2.3 OrderServiceImpl"></a>6.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 取消订单
     *
     * @param ordersCancelDTO
     */
    public void cancel(OrdersCancelDTO ordersCancelDTO) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(ordersCancelDTO.getId());

        //支付状态
        Integer payStatus = ordersDB.getPayStatus();
        if (payStatus == 1) &#123;
            //用户已支付，需要退款
            String refund = weChatPayUtil.refund(
                    ordersDB.getNumber(),
                    ordersDB.getNumber(),
                    new BigDecimal(0.01),
                    new BigDecimal(0.01));
            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);
        &#125;

        // 管理端取消订单需要退款，根据订单id更新订单状态、取消原因、取消时间
        Orders orders = new Orders();
        orders.setId(ordersCancelDTO.getId());
        orders.setStatus(Orders.CANCELLED);
        orders.setCancelReason(ordersCancelDTO.getCancelReason());
        orders.setCancelTime(LocalDateTime.now());
        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="派送订单"><a href="#派送订单" class="headerlink" title="派送订单"></a>派送订单</h3><p>业务规则：</p>
<ul>
<li>派送订单其实就是将订单状态修改为“派送中”</li>
<li>只有状态为“待派送”的订单可以执行派送订单操作</li>
</ul>
<h4 id="7-2-1-admin-x2F-OrderController"><a href="#7-2-1-admin-x2F-OrderController" class="headerlink" title="7.2.1 admin&#x2F;OrderController"></a>7.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @return
     */
    @PutMapping(&quot;/delivery/&#123;id&#125;&quot;)
    @ApiOperation(&quot;派送订单&quot;)
    public Result delivery(@PathVariable(&quot;id&quot;) Long id) &#123;
        orderService.delivery(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="7-2-2-OrderService"><a href="#7-2-2-OrderService" class="headerlink" title="7.2.2 OrderService"></a>7.2.2 OrderService</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @param id
     */
    void delivery(Long id);
</code></pre>
<h4 id="7-2-3-OrderServiceImpl"><a href="#7-2-3-OrderServiceImpl" class="headerlink" title="7.2.3 OrderServiceImpl"></a>7.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @param id
     */
    public void delivery(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在，并且状态为3
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.CONFIRMED)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        // 更新订单状态,状态转为派送中
        orders.setStatus(Orders.DELIVERY_IN_PROGRESS);

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="完成订单"><a href="#完成订单" class="headerlink" title="完成订单"></a>完成订单</h3><p>业务规则：</p>
<ul>
<li>完成订单其实就是将订单状态修改为“已完成”</li>
<li>只有状态为“派送中”的订单可以执行订单完成操作</li>
</ul>
<h4 id="8-2-1-admin-x2F-OrderController"><a href="#8-2-1-admin-x2F-OrderController" class="headerlink" title="8.2.1 admin&#x2F;OrderController"></a>8.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @return
     */
    @PutMapping(&quot;/complete/&#123;id&#125;&quot;)
    @ApiOperation(&quot;完成订单&quot;)
    public Result complete(@PathVariable(&quot;id&quot;) Long id) &#123;
        orderService.complete(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="8-2-2-OrderService"><a href="#8-2-2-OrderService" class="headerlink" title="8.2.2 OrderService"></a>8.2.2 OrderService</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @param id
     */
    void complete(Long id);
</code></pre>
<h4 id="8-2-3-OrderServiceImpl"><a href="#8-2-3-OrderServiceImpl" class="headerlink" title="8.2.3 OrderServiceImpl"></a>8.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @param id
     */
    public void complete(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在，并且状态为4
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.DELIVERY_IN_PROGRESS)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        // 更新订单状态,状态转为完成
        orders.setStatus(Orders.COMPLETED);
        orders.setDeliveryTime(LocalDateTime.now());

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="校验收货地址是否超出配送范围"><a href="#校验收货地址是否超出配送范围" class="headerlink" title="校验收货地址是否超出配送范围"></a>校验收货地址是否超出配送范围</h3><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>注册账号：<a target="_blank" rel="noopener" href="https://passport.baidu.com/v2/?reg&amp;tt=1671699340600&amp;overseas=&amp;gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&amp;tpl=pp&amp;u=https://lbsyun.baidu.com/index.php?title=%E9%A6%96%E9%A1%B5">https://passport.baidu.com/v2/?reg&amp;tt=1671699340600&amp;overseas=&amp;gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&amp;tpl=pp&amp;u=https%3A%2F%2Flbsyun.baidu.com%2Findex.php%3Ftitle%3D%E9%A6%96%E9%A1%B5</a></p>
<p>登录百度地图开放平台：<a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/">https://lbsyun.baidu.com/</a></p>
<p>进入控制台，创建应用，获取AK：</p>
<p>![image-20221222170049729](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170049729.png)</p>
<p>![image-20221222170256927](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170256927.png)</p>
<p>相关接口:</p>
<p><a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding">https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding</a></p>
<p><a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1">https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1</a></p>
<h2 id="2-代码开发"><a href="#2-代码开发" class="headerlink" title="2. 代码开发"></a>2. 代码开发</h2><h3 id="2-1-application-yml"><a href="#2-1-application-yml" class="headerlink" title="2.1 application.yml"></a>2.1 application.yml</h3><p>配置外卖商家店铺地址和百度地图的AK：</p>
<p>![image-20221222170819582](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170819582.png)</p>
<h3 id="2-2-OrderServiceImpl"><a href="#2-2-OrderServiceImpl" class="headerlink" title="2.2 OrderServiceImpl"></a>2.2 OrderServiceImpl</h3><p>改造OrderServiceImpl，注入上面的配置项：</p>
<pre><code class="java">com/sky/properties/BaiDuProperties.java
package com.sky.properties;

import lombok.Data;
import lombok.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
// 多个prefix
@ConfigurationProperties(prefix = &quot;sky.baidu&quot;)
@Data
public class BaiDuProperties &#123;
    private String shopAddress;
    private String ak;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
  baidu:
    ak: $&#123;sky.baidu.ak&#125;
    shopAddress: $&#123;sky.baidu.shopAddress&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
  baidu:
    ak: xxxxxxxxx
    shopAddress: 河北省唐山市丰润区燕山路街道美景花园
</code></pre>
<p>在OrderServiceImpl中提供校验方法：</p>
<pre><code class="java">/**
     * 检查客户的收货地址是否超出配送范围
     * @param address
     */
    private void checkOutOfRange(String address) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;address&quot;, baiDuProperties.getShopAddress());
        map.put(&quot;output&quot;, &quot;json&quot;);
        map.put(&quot;ak&quot;, baiDuProperties.getAk());

        //获取店铺的经纬度坐标
        String shopCoordinate = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/geocoding/v3&quot;, map);

        JSONObject jsonObject = JSON.parseObject(shopCoordinate);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;店铺地址解析失败&quot;);
        &#125;

        //数据解析
        JSONObject location = jsonObject.getJSONObject(&quot;result&quot;).getJSONObject(&quot;location&quot;);
        String lat = location.getString(&quot;lat&quot;);
        String lng = location.getString(&quot;lng&quot;);
        //店铺经纬度坐标
        String shopLngLat = lat + &quot;,&quot; + lng;

        map.put(&quot;address&quot;,address);
        //获取用户收货地址的经纬度坐标
        String userCoordinate = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/geocoding/v3&quot;, map);

        jsonObject = JSON.parseObject(userCoordinate);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;收货地址解析失败&quot;);
        &#125;

        //数据解析
        location = jsonObject.getJSONObject(&quot;result&quot;).getJSONObject(&quot;location&quot;);
        lat = location.getString(&quot;lat&quot;);
        lng = location.getString(&quot;lng&quot;);
        //用户收货地址经纬度坐标
        String userLngLat = lat + &quot;,&quot; + lng;

        map.put(&quot;origin&quot;,shopLngLat);
        map.put(&quot;destination&quot;,userLngLat);
        map.put(&quot;steps_info&quot;,&quot;0&quot;);

        //路线规划
        String json = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/directionlite/v1/driving&quot;, map);

        jsonObject = JSON.parseObject(json);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;配送路线规划失败&quot;);
        &#125;

        //数据解析
        JSONObject result = jsonObject.getJSONObject(&quot;result&quot;);
        JSONArray jsonArray = (JSONArray) result.get(&quot;routes&quot;);
        Integer distance = (Integer) ((JSONObject) jsonArray.get(0)).get(&quot;distance&quot;);

        if(distance &gt; 5000)&#123;
            //配送距离超过5000米
            throw new OrderBusinessException(&quot;超出配送范围&quot;);
        &#125;
    &#125;
</code></pre>
<p>在OrderServiceImpl的submitOrder方法中调用上面的校验方法：</p>
<pre><code class="java">   // 检查用户的收获地址是否超出配送范围
        checkOutOfRange(addressBook.getCityName() + addressBook.getDistrictName() + addressBook.getDetail());
</code></pre>
<p>![image-20221222171444981](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222171444981.png)</p>
<h3 id="SpringTask-定时任务-定时自动执行某段Java代码"><a href="#SpringTask-定时任务-定时自动执行某段Java代码" class="headerlink" title="SpringTask[定时任务]定时自动执行某段Java代码"></a>SpringTask[定时任务]<del>定时自动执行某段Java代码</del></h3><p>SpringTask是Spring框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ul>
<li>信用卡每月还款提醒</li>
<li>银行贷款每月还款提醒</li>
<li>火车票售票系统处理未支付订单</li>
<li>入职纪念日为用户发送通知</li>
</ul>
<h5 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h5><p>cron表达式其实就是一个字符串，通过cron表达式可以<strong>定义任务触发时间</strong><br>构成规则：分为6或7个域，由空格分隔开，每个域代表一个含义<br>每个域的含义分别为：<u>秒、分钟、小时、日、月、周、年</u>(可选)</p>
<h6 id="2022年10月12日上午9点整-对应的cron表达式（日-和-周-不能同时定义）"><a href="#2022年10月12日上午9点整-对应的cron表达式（日-和-周-不能同时定义）" class="headerlink" title="2022年10月12日上午9点整 对应的cron表达式（日 和 周 不能同时定义）"></a>2022年10月12日上午9点整 对应的cron表达式（日 和 周 不能同时定义）</h6><p>0 0 9 12 10 ？ 2022<br><a target="_blank" rel="noopener" href="https://cron.qqe2.com/">https://cron.qqe2.com</a></p>
<table>
<thead>
<tr>
<th>秒</th>
<th>分钟</th>
<th>小时</th>
<th>日</th>
<th>月</th>
<th>周</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>9</td>
<td>12</td>
<td>10</td>
<td>？</td>
</tr>
</tbody></table>
<h6 id="SpringTask使用步骤："><a href="#SpringTask使用步骤：" class="headerlink" title="SpringTask使用步骤："></a>SpringTask使用步骤：</h6><ul>
<li>导入maven坐标 spring-context（已存在）</li>
<li>启动类添加注解 <code>@EnableScheduling</code> 开启任务调度</li>
<li><strong>自定义定时任务类</strong></li>
</ul>
<pre><code class="java">sky-server  com/sky/task/MyTask.java
package com.sky.task;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import java.util.Date;

/**
 * 自定义定时任务类
 */
@Component
@Slf4j
public class MyTask &#123;

    /**
     * 定时任务 每隔5秒触发一次
     */
    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)
    public void executeTask()&#123;
        log.info(&quot;定时任务开始执行：&#123;&#125;&quot;, new Date());
    &#125;
&#125;
</code></pre>
<h3 id="订单状态定时处理"><a href="#订单状态定时处理" class="headerlink" title="订单状态定时处理"></a>订单状态定时处理</h3><h6 id="用户下单后可能存在的情况："><a href="#用户下单后可能存在的情况：" class="headerlink" title="用户下单后可能存在的情况："></a>用户下单后可能存在的情况：</h6><ul>
<li>下单后未支付，订单一直处于”<strong>待支付</strong>“状态</li>
<li>用户收获后管理端未点击完成按钮，订单一直处于<strong>“派送中”</strong>状态<ul>
<li>通过定时任务<strong>每分钟检查一次</strong>是否存在支付超时订单(超过15min)，如果存在则修改订单状态为”已取消”</li>
<li>通过定时任务<strong>每天凌晨1点检查一次</strong>是否存在”派送中”的订单，如果存在则修改订单状态为”已完成”</li>
</ul>
</li>
</ul>
<h5 id="代码开发：-4"><a href="#代码开发：-4" class="headerlink" title="代码开发："></a>代码开发：</h5><pre><code class="java">sky-server  com/sky/task/OrderTask.java
package com.sky.task;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

@Component
@Slf4j
public class OrderTask &#123;
    @Autowired
    private OrderMapper orderMapper;

    /**
     * 处理超时订单的方法
     */
    @Scheduled(cron = &quot;0 * * * * ?&quot;)//每分钟触发一次
    public void processTimeoutOrder()&#123;
        log.info(&quot;定时处理超时订单&quot;);
        // select * from orders where status = ? and order_time = (当前时间 - 15分钟)
        LocalDateTime time = LocalDateTime.now().plusMinutes(-15);
        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.PENDING_PAYMENT, time);
        if (ordersList != null &amp;&amp; ordersList.size() &gt; 0) &#123;
            for (Orders orders : ordersList) &#123;
                orders.setStatus(Orders.CANCELLED);
                orders.setCancelReason(&quot;订单超时，自动取消&quot;);
                orders.setCancelTime(LocalDateTime.now());
                orderMapper.update(orders);
            &#125;
        &#125;
    &#125;

    /**
     * 处理一直处于派送中状态的订单
     */
    @Scheduled(cron = &quot;0 0 1 * * ?&quot;)//每天凌晨一点
    public void processDeliveryOrder() &#123;
        log.info(&quot;定时处理处于派送中的订单&quot;);
        LocalDateTime time = LocalDateTime.now().plusMinutes(-60);
        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.DELIVERY_IN_PROGRESS, time);
        if (ordersList != null &amp;&amp; ordersList.size() &gt; 0) &#123;
            for (Orders orders : ordersList) &#123;
                orders.setStatus(Orders.COMPLETED);
                orderMapper.update(orders);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
    /**
     *
     * 根据订单状态和下单时间查询订单
     * @param status
     * @param orderTime
     * @return
     */
    @Select(&quot;select * from orders where status = #&#123;status&#125; and order_time &lt; #&#123;orderTime&#125;&quot;)
    List&lt;Orders&gt; getByStatusAndOrderTimeLT(Integer status, LocalDateTime orderTime);
</code></pre>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是基于TCP的一种新的<strong>网络协议</strong>，它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持续性</strong>连接，并进行<strong>双向</strong>数据传输</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/edb75e96dfbeebfac80f0c08ad92001201b8754c/data/WebSocket.png"></p>
<h6 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h6><ul>
<li>视频弹幕</li>
<li>网页聊天</li>
<li>体育实况更新</li>
<li>股票基金报价实时更新</li>
</ul>
<h5 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h5><p><strong>实现步骤：</strong></p>
<ul>
<li>直接使用<strong>websocket.html</strong>页面坐位WebSocket客户端</li>
<li>导入<strong>WebSocket</strong>的maven坐标</li>
<li>导入<strong>WebSocket</strong>服务端组件<strong>WebSocketServer</strong>，用于和客户端通信</li>
<li>导入配置类<strong>WebSocketConfiguration</strong>，注册WebSocket的服务端组件</li>
<li>导入定时人物类<strong>WebSocketTask</strong>，定时向客户端推送数据</li>
</ul>
<pre><code class="html">websocket.html
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;WebSocket Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;
    &lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt;
    &lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭连接&lt;/button&gt;
    &lt;div id=&quot;message&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var websocket = null;
    var clientId = Math.random().toString(36).substr(2);

    //判断当前浏览器是否支持WebSocket
    if(&#39;WebSocket&#39; in window)&#123;
        //连接WebSocket节点
        websocket = new WebSocket(&quot;ws://localhost:8080/ws/&quot;+clientId);
    &#125;
    else&#123;
        alert(&#39;Not support websocket&#39;)
    &#125;

    //连接发生错误的回调方法
    websocket.onerror = function()&#123;
        setMessageInnerHTML(&quot;error&quot;);
    &#125;;

    //连接成功建立的回调方法
    websocket.onopen = function()&#123;
        setMessageInnerHTML(&quot;连接成功&quot;);
    &#125;

    //接收到消息的回调方法
    websocket.onmessage = function(event)&#123;
        setMessageInnerHTML(event.data);
    &#125;

    //连接关闭的回调方法
    websocket.onclose = function()&#123;
        setMessageInnerHTML(&quot;close&quot;);
    &#125;

    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
    window.onbeforeunload = function()&#123;
        websocket.close();
    &#125;

    //将消息显示在网页上
    function setMessageInnerHTML(innerHTML)&#123;
        document.getElementById(&#39;message&#39;).innerHTML += innerHTML + &#39;&lt;br/&gt;&#39;;
    &#125;

    //发送消息
    function send()&#123;
        var message = document.getElementById(&#39;text&#39;).value;
        websocket.send(message);
    &#125;
    
    //关闭连接
    function closeWebSocket() &#123;
        websocket.close();
    &#125;
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/sky/websocket/WebSocketServer.java
package com.sky.websocket;

import org.springframework.stereotype.Component;
import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * WebSocket服务
 */
@Component //交给spring容器管理
@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)
public class WebSocketServer &#123;

    //存放会话对象
    private static Map&lt;String, Session&gt; sessionMap = new HashMap();

    /**
     * 连接建立成功调用的方法
     */
    @OnOpen
    public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;客户端：&quot; + sid + &quot;建立连接&quot;);
        sessionMap.put(sid, session);
    &#125;

    /**
     * 收到客户端消息后调用的方法
     *
     * @param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, @PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;收到来自客户端：&quot; + sid + &quot;的信息:&quot; + message);
    &#125;

    /**
     * 连接关闭调用的方法
     *
     * @param sid
     */
    @OnClose
    public void onClose(@PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;连接断开:&quot; + sid);
        sessionMap.remove(sid);
    &#125;

    /**
     * 群发
     *
     * @param message
     */
    public void sendToAllClient(String message) &#123;
        Collection&lt;Session&gt; sessions = sessionMap.values();
        for (Session session : sessions) &#123;
            try &#123;
                //服务器向客户端发送消息
                session.getBasicRemote().sendText(message);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/config/WebSocketConfiguration.java
package com.sky.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

/**
 * WebSocket配置类，用于注册WebSocket的Bean
 */
@Configuration
public class WebSocketConfiguration &#123;

    @Bean
    public ServerEndpointExporter serverEndpointExporter() &#123;
        return new ServerEndpointExporter();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/task/WebSocketTask.java
package com.sky.task;

import com.sky.websocket.WebSocketServer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Component
public class WebSocketTask &#123;
    @Autowired
    private WebSocketServer webSocketServer;

    /**
     * 通过WebSocket每隔5秒向客户端发送消息
     */
    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)
    public void sendMessageToClient() &#123;
        webSocketServer.sendToAllClient(&quot;这是来自服务端的消息：&quot; + DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;).format(LocalDateTime.now()));
    &#125;
&#125;
</code></pre>
<h3 id="来单提醒"><a href="#来单提醒" class="headerlink" title="来单提醒"></a>来单提醒</h3><p>用户下单并且支付成功后，需要第一时间通知外卖商家</p>
<ul>
<li><strong>语音播报</strong></li>
<li><strong>弹出提示框</strong></li>
</ul>
<h6 id="设计："><a href="#设计：" class="headerlink" title="设计："></a>设计：</h6><ul>
<li>通过WebSocket实现管理端页面和服务端保持长连接状态</li>
<li>当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息</li>
<li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报</li>
<li>约定服务器发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content<ul>
<li>type 为消息类型，1为来单提醒  2为客户催单</li>
<li>orderId 为订单id</li>
<li>content 为消息内容</li>
</ul>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
 /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        // 查询订单
        Orders order = orderMapper.getByOrderNumber(ordersPaymentDTO.getOrderNumber());
        if (order == null) &#123;
            throw new OrderBusinessException(&quot;订单不存在&quot;);
        &#125;

        // 检查订单支付状态
        if (order.getPayStatus() == 1) &#123; // 1 表示已支付
            throw new OrderBusinessException(&quot;该订单已支付&quot;);
        &#125;
        order.setPayStatus(1);

        // 更新订单支付状态为已支付
        order.setPayStatus(Orders.PAID);
        order.setCheckoutTime(LocalDateTime.now());
        order.setPayMethod(ordersPaymentDTO.getPayMethod());
        order.setStatus(Orders.TO_BE_CONFIRMED);

        // 支付成功后通过 WebSocket 向客户端推送消息
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;type&quot;, 1); // 1 表示来单提醒
        map.put(&quot;orderId&quot;, order.getId());
        map.put(&quot;content&quot;, &quot;订单号：&quot; + ordersPaymentDTO.getOrderNumber());

        webSocketServer.sendToAllClient(JSON.toJSONString(map));


        orderMapper.update(order);

        // 构造并返回支付结果对象
        OrderPaymentVO orderPaymentVO = new OrderPaymentVO();
        orderPaymentVO.setOrderNumber(order.getNumber()); // 订单号
        orderPaymentVO.setPaymentTime(new Date());
        orderPaymentVO.setPaymentStatus(&quot;SUCCESS&quot;);

        return orderPaymentVO;

    &#125;
</code></pre>
<h3 id="用户催单"><a href="#用户催单" class="headerlink" title="用户催单"></a>用户催单</h3><pre><code class="java">com/sky/controller/user/OrderController.java 
/**
     * 客户催单
     * @param id
     * @return
     */
    @GetMapping(&quot;/reminder/&#123;id&#125;&quot;)
    @ApiOperation(&quot;客户催单&quot;)
    public Result reminder(@PathVariable(&quot;id&quot;) Long id)&#123;
        orderService.reminder(id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">com/sky/service/OrderService.java
 /**
     * 用户催单
     * @param id
     */
    void reminder(Long id);
</code></pre>
<pre><code class="java">com/sky/service/impl/OrderServiceImpl.java
/**
     * 客户催单
     * @param id
     */
    public void reminder(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在
        if (ordersDB == null) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Map map = new HashMap();
        map.put(&quot;type&quot;,2); //1表示来单提醒 2表示客户催单
        map.put(&quot;orderId&quot;,id);
        map.put(&quot;content&quot;,&quot;订单号：&quot; + ordersDB.getNumber());

        //通过websocket向客户端浏览器推送消息
        webSocketServer.sendToAllClient(JSON.toJSONString(map));
    &#125;
</code></pre>
<h3 id="ApacheECharts"><a href="#ApacheECharts" class="headerlink" title="ApacheECharts"></a>ApacheECharts</h3><p><a target="_blank" rel="noopener" href="http://echarts.apache.org/zh/index.html">http://echarts.apache.org/zh/index.html</a></p>
<ul>
<li><strong>柱形图</strong> bar</li>
<li><strong>饼形图</strong></li>
<li><strong>折线图</strong></li>
</ul>
<p>使用Echarts，重点在于研究当前图标所需<strong>数据格式</strong>，通常是需要后端提供符合格式要求的动态数据，然后相应给前端来展示图表</p>
<h3 id="营业额统计"><a href="#营业额统计" class="headerlink" title="营业额统计"></a>营业额统计</h3><h6 id="业务规则"><a href="#业务规则" class="headerlink" title="业务规则"></a>业务规则</h6><ul>
<li>营业额指订单状态为已完成的订单金额合计</li>
<li>基于可视化报表的折线图展示营业额数据，x轴为日期，y轴为营业额</li>
<li>根据时间选择区间，展示每天的营业额数据</li>
</ul>
<h5 id="根据接口定义设计对应的vo："><a href="#根据接口定义设计对应的vo：" class="headerlink" title="根据接口定义设计对应的vo："></a>根据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/TurnoverReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TurnoverReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03 [开始到结束的每一天]
    private String dateList;

    //营业额，以逗号分隔，例如：406.0,1520.0,75.0 [营业额一一对应]
    private String turnoverList;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
 * 数据统计相关接口
 */
@RestController
@RequestMapping(&quot;/admin/report&quot;)
@Api(tags = &quot;数据统计接口&quot;)
@Slf4j
public class ReportController &#123;
    @Autowired
    private ReportService reportService;

    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/turnoverStatistics&quot;)
    public Result&lt;TurnoverReportVO&gt; turnoverStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate end) &#123;
        log.info(&quot;营业额统计:&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getTurnoverStatistics(begin,end));
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    TurnoverReportVO getTurnoverStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@Slf4j
public class ReportServiceImpl implements ReportService &#123;
    @Autowired
    private OrderMapper orderMapper;
    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    @Override
    public TurnoverReportVO getTurnoverStatistics(LocalDate begin, LocalDate end) &#123;
        // 当前集合用于存放从begin到end范围内的每天的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();
        dateList.add(begin);

        while (!begin.equals(end)) &#123;
            //日期计算，计算指定日期的后一天对应的日期
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        // 存放每天的营业额
        List&lt;Double&gt; turnoverList = new ArrayList&lt;&gt;();
        for (LocalDate date : dateList) &#123; //LocalDate只是年月日 而下单的Order有时分秒
            // 查询Date日期对应的营业额数据，数据额是指：订单状态为“已完成”的订单金额合计
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
        // select sum(count) from orders where order_time &gt; ? and order_time &lt; ? and status = 5
            Map map = new HashMap&lt;&gt;();
            map.put(&quot;begin&quot;, beginTime);
            map.put(&quot;end&quot;, endTime);
            map.put(&quot;status&quot;, Orders.COMPLETED);
            Double turnover = orderMapper.sumByMap(map);
            turnover = turnover == null ? 0.0 : turnover;//没有营业额则默认为0
            turnoverList.add(turnover);
        &#125;

        return TurnoverReportVO.builder()
                .dateList(StringUtils.join(dateList, &quot;,&quot;))
                .turnoverList(StringUtils.join(turnoverList, &quot;,&quot;))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
/**
     * 根据动态条件统计营业额数据
     * @param map
     * @return
     */
    Double sumByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;Orders&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into orders
        (number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark,
         phone, address, consignee, estimated_delivery_time, delivery_status, pack_amount, tableware_number,
         tableware_status)
        values (#&#123;number&#125;, #&#123;status&#125;, #&#123;userId&#125;, #&#123;addressBookId&#125;, #&#123;orderTime&#125;, #&#123;checkoutTime&#125;, #&#123;payMethod&#125;,
                #&#123;payStatus&#125;, #&#123;amount&#125;, #&#123;remark&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;consignee&#125;,
                #&#123;estimatedDeliveryTime&#125;, #&#123;deliveryStatus&#125;, #&#123;packAmount&#125;, #&#123;tablewareNumber&#125;, #&#123;tablewareStatus&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.sky.entity.Orders&quot;&gt;
        update orders
        &lt;set&gt;
            &lt;if test=&quot;cancelReason != null and cancelReason!=&#39;&#39; &quot;&gt;
                cancel_reason=#&#123;cancelReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;rejectionReason != null and rejectionReason!=&#39;&#39; &quot;&gt;
                rejection_reason=#&#123;rejectionReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;cancelTime != null&quot;&gt;
                cancel_time=#&#123;cancelTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payStatus != null&quot;&gt;
                pay_status=#&#123;payStatus&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payMethod != null&quot;&gt;
                pay_method=#&#123;payMethod&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;checkoutTime != null&quot;&gt;
                checkout_time=#&#123;checkoutTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;deliveryTime != null&quot;&gt;
                delivery_time = #&#123;deliveryTime&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders
        &lt;where&gt;
            &lt;if test=&quot;number != null and number!=&#39;&#39;&quot;&gt;
                and number like concat(&#39;%&#39;,#&#123;number&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;phone != null and phone!=&#39;&#39;&quot;&gt;
                and phone like concat(&#39;%&#39;,#&#123;phone&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;beginTime != null&quot;&gt;
                and order_time &amp;gt;= #&#123;beginTime&#125;
            &lt;/if&gt;
            &lt;if test=&quot;endTime != null&quot;&gt;
                and order_time &amp;lt;= #&#123;endTime&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by order_time desc
    &lt;/select&gt;
    &lt;!-- 根据订单号查询订单 --&gt;
    &lt;select id=&quot;getByOrderNumber&quot; parameterType=&quot;String&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders where number = #&#123;orderNumber&#125;
    &lt;/select&gt;
    &lt;select id=&quot;sumByMap&quot; resultType=&quot;java.lang.Double&quot;&gt;
        select sum(amount) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="用户统计"><a href="#用户统计" class="headerlink" title="用户统计"></a>用户统计</h3><p>业务规则：</p>
<ul>
<li>根据时间选择区间，展示每天的用户总量和新增用户量数据</li>
</ul>
<h5 id="据接口定义设计对应的vo："><a href="#据接口定义设计对应的vo：" class="headerlink" title="据接口定义设计对应的vo："></a>据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/UserReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //用户总量，以逗号分隔，例如：200,210,220
    private String totalUserList;

    //新增用户，以逗号分隔，例如：20,21,10
    private String newUserList;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
     * 用户统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/userStatistics&quot;)
    @ApiOperation(&quot;用户统计&quot;)
    public Result&lt;UserReportVO&gt; userStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate end)&#123;
        log.info(&quot;用户数据统计:&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getUserStatistics(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
   /**
     * 用户统计
     * @param begin
     * @param end
     * @return
     */
    UserReportVO getUserStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@Slf4j
public class ReportServiceImpl implements ReportService &#123;
    /**
     * 统计指定时间区间内的用户数据
     * @param begin
     * @param end
     * @return
     */
    @Override
    public UserReportVO getUserStatistics(LocalDate begin, LocalDate end) &#123;
        // 存放从begin 到 end之间的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();
        dateList.add(begin);
        while (!begin.equals(end)) &#123;
            //日期计算，计算指定日期的后一天的日期
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        // 存放每天新增用户数量 select count(id) from user where create_time &gt; ? and create_time &lt; ?
        List&lt;Integer&gt; newUserList = new ArrayList&lt;&gt;();
        // 存放每天的总用户数量 select count(id) from user where create_time &lt;= ?
        List&lt;Integer&gt; totalUserList = new ArrayList&lt;&gt;();

        for (LocalDate date : dateList) &#123;
        // 遍历每一天的用户总量和数量
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);

            Map map = new HashMap&lt;&gt;();
            map.put(&quot;end&quot;, endTime);

            // 总用户数量
            Integer integer = userMapper.countByMap(map);

            map.put(&quot;begin&quot;, beginTime);
            //新增用户数量
            Integer newUser = userMapper.countByMap(map);
            totalUserList.add(integer);
            newUserList.add(newUser);
        &#125;
        return UserReportVO.builder()
                .dateList(StringUtils.join(dateList, &quot;,&quot;))
                .totalUserList(StringUtils.join(totalUserList, &quot;,&quot;))
                .newUserList(StringUtils.join(newUserList, &quot;,&quot;))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
/**
     * 根据动态条件统计用户数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="订单统计"><a href="#订单统计" class="headerlink" title="订单统计"></a>订单统计</h3><h6 id="业务规则-1"><a href="#业务规则-1" class="headerlink" title="业务规则"></a>业务规则</h6><ul>
<li>根据时间选择区间，展示每天的订单总数和有效订单数</li>
<li>展示所选时间区间内的有效订单数、总订单数、订单完成率</li>
<li>订单完成率 &#x3D; 有效订单数 &#x2F; 总订单数 * 100%</li>
</ul>
<h6 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h6><ul>
<li>dataList 日期列表以逗号分隔</li>
<li>orderCompletionRate 订单完成率</li>
<li>orderCountList 订单数列表以逗号分隔</li>
<li>totalOrderCount 订单总数</li>
<li>validOrderCount 有效订单数</li>
<li>validOrderCountList 有效订单数列表以逗号分隔</li>
</ul>
<h5 id="据接口定义设计对应的vo：-1"><a href="#据接口定义设计对应的vo：-1" class="headerlink" title="据接口定义设计对应的vo："></a>据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/OrderReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //每日订单数，以逗号分隔，例如：260,210,215
    private String orderCountList;

    //每日有效订单数，以逗号分隔，例如：20,21,10
    private String validOrderCountList;

    //订单总数
    private Integer totalOrderCount;

    //有效订单数
    private Integer validOrderCount;

    //订单完成率
    private Double orderCompletionRate;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
     * 订单统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/ordersStatistics&quot;)
    @ApiOperation(&quot;订单统计&quot;)
    public Result&lt;OrderReportVO&gt; ordersStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)  LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end)&#123;
        log.info(&quot;订单数据统计：&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getOrderStatistics(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
 /**
     * 统计指定时间区间内的订单数据
     * @param begin
     * @param end
     * @return
     */
    OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

 /**
     * 统计指定时间区间内的订单数据
     * @param begin
     * @param end
     * @return
     */
    public OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end) &#123;
        //存放从begin到end之间的每天对应的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();

        dateList.add(begin);

        while (!begin.equals(end)) &#123;
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        //存放每天的订单总数
        List&lt;Integer&gt; orderCountList = new ArrayList&lt;&gt;();
        //存放每天的有效订单数
        List&lt;Integer&gt; validOrderCountList = new ArrayList&lt;&gt;();

        //遍历dateList集合，查询每天的有效订单数和订单总数
        for (LocalDate date : dateList) &#123;
            //查询每天的订单总数 select count(id) from orders where order_time &gt; ? and order_time &lt; ?
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
            Integer orderCount = getOrderCount(beginTime, endTime, null);

            //查询每天的有效订单数 select count(id) from orders where order_time &gt; ? and order_time &lt; ? and status = 5
            Integer validOrderCount = getOrderCount(beginTime, endTime, Orders.COMPLETED);

            orderCountList.add(orderCount);
            validOrderCountList.add(validOrderCount);
        &#125;

        //计算时间区间内的订单总数量
        Integer totalOrderCount = orderCountList.stream().reduce(Integer::sum).get();

        //计算时间区间内的有效订单数量
        Integer validOrderCount = validOrderCountList.stream().reduce(Integer::sum).get();

        Double orderCompletionRate = 0.0;
        if(totalOrderCount != 0)&#123;
            //计算订单完成率
            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
        &#125;

        return  OrderReportVO.builder()
                .dateList(StringUtils.join(dateList,&quot;,&quot;))
                .orderCountList(StringUtils.join(orderCountList,&quot;,&quot;))
                .validOrderCountList(StringUtils.join(validOrderCountList,&quot;,&quot;))
                .totalOrderCount(totalOrderCount)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .build();
    &#125;
    /**
     * 根据条件统计订单数量
     * @param begin
     * @param end
     * @param status
     * @return
     */
    private Integer getOrderCount(LocalDateTime begin, LocalDateTime end, Integer status)&#123;
        Map map = new HashMap();
        map.put(&quot;begin&quot;,begin);
        map.put(&quot;end&quot;,end);
        map.put(&quot;status&quot;,status);

        return orderMapper.countByMap(map);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
/**
     * 根据动态条件统计用户数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="销量排名Top10"><a href="#销量排名Top10" class="headerlink" title="销量排名Top10"></a>销量排名Top10</h3><h6 id="产品原型-查已完成的数据"><a href="#产品原型-查已完成的数据" class="headerlink" title="产品原型 (查已完成的数据)"></a>产品原型 (查已完成的数据)</h6><ul>
<li>此处的销量为商品销售的份数</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
/**
     * 销量排名统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/top10&quot;)
    @ApiOperation(&quot;销量排名top10&quot;)
    public Result&lt;SalesTop10ReportVO&gt; top10(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end)&#123;
        log.info(&quot;销量排名top10：&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getSalesTop10(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
/**
     * 销量排名统计
     * @param begin
     * @param end
     * @return
     */
    SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
    /**
     * 统计指定时间区间内的销量排名前10
     * @param begin
     * @param end
     * @return
     */
    @Override
    public SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end) &#123;
        LocalDateTime beginTime = LocalDateTime.of(begin, LocalTime.MIN);
        LocalDateTime endTime = LocalDateTime.of(end, LocalTime.MAX);

        List&lt;GoodsSalesDTO&gt; salesTop10 = orderMapper.getSalesTop10(beginTime, endTime);
        List&lt;String&gt; names = salesTop10.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList());
        String nameList = StringUtils.join(names, &quot;,&quot;);

        List&lt;Integer&gt; numbers = salesTop10.stream().map(GoodsSalesDTO::getNumber).collect(Collectors.toList());
        String numberList = StringUtils.join(numbers, &quot;,&quot;);

        //封装返回结果数据
        return SalesTop10ReportVO
                .builder()
                .nameList(nameList)
                .numberList(numberList)
                .build();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
  /**
     * 统计指定时间内的销量排名
     * @return
     */
    List&lt;GoodsSalesDTO&gt; getSalesTop10(LocalDateTime begin,LocalDateTime end);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;select id=&quot;getSalesTop10&quot; resultType=&quot;com.sky.dto.GoodsSalesDTO&quot;&gt;
        select od.name, sum(od.number) number
        from order_detail od,orders o
        where od.order_id = o.id and o.status = 5
        &lt;if test=&quot;begin != null&quot;&gt;
            and o.order_time &amp;gt; #&#123;begin&#125;
        &lt;/if&gt;
        &lt;if test=&quot;end != null&quot;&gt;
            and o.order_time &amp;lt; #&#123;end&#125;
        &lt;/if&gt;
        group by od.name
        order by number desc
        limit 0,10
    &lt;/select&gt;
</code></pre>
<h6 id="重装数据库"><a href="#重装数据库" class="headerlink" title="重装数据库"></a>重装数据库</h6><pre><code class="mysql">C:\Windows\System32&gt;cd D:\MySQL\MySQL Server 8.0\bin

C:\Windows\System32&gt;mysqld --install MySQL80
Service successfully installed.

C:\Windows\System32&gt;sc query | findstr MySQL

C:\Windows\System32&gt;net start MySQL80
MySQL80 服务正在启动 .
MySQL80 服务已经启动成功。
服务里的MySQL80是Mysql服务
-----------------------------------------------------------------------------------------

C:\Windows\System32&gt;cd D:\MariaDB 11.0\bin

C:\Windows\System32&gt;mysqld --install MariaDB
Service successfully installed.

C:\Windows\System32&gt;net start MariaDB
MariaDB 服务正在启动 .
MariaDB 服务无法启动。
服务里的MariaDB是MariaDB服务
</code></pre>
<h3 id="工作台"><a href="#工作台" class="headerlink" title="工作台"></a>工作台</h3><h5 id="工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率"><a href="#工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率" class="headerlink" title="工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率"></a>工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率</h5><p>功能工作台展示的数据：</p>
<ul>
<li>今日数据</li>
<li>订单管理</li>
<li>菜品总览</li>
<li>套餐总览</li>
<li>订单信息</li>
</ul>
<h6 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h6><ul>
<li>营业额：已完成订单的总金额</li>
<li>有效订单：已完成订单的数量</li>
<li>订单完成率：有效订单数 &#x2F; 总订单数 * 100%</li>
<li>平均客单价：营业额 &#x2F; 有效订单数</li>
<li>新增用户：新增用户的数量</li>
</ul>
<h6 id="接口设计：-5"><a href="#接口设计：-5" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>今日数据接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;businessData<br>Method: Get</p>
</blockquote>
</li>
<li><p>订单管理接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewOrders<br>Method: Get</p>
</blockquote>
</li>
<li><p>菜品总览接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewDishes<br>Method: Get</p>
</blockquote>
</li>
<li><p>套餐总览接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewSetmeals<br>Method: Get</p>
</blockquote>
</li>
<li><p>订单搜索(已完成)</p>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/admin/WorkSpaceController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.WorkspaceService;
import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * 工作台
 */
@RestController
@RequestMapping(&quot;/admin/workspace&quot;)
@Slf4j
@Api(tags = &quot;工作台相关接口&quot;)
public class WorkSpaceController &#123;

    @Autowired
    private WorkspaceService workspaceService;

    /**
     * 工作台今日数据查询
     * @return
     */
    @GetMapping(&quot;/businessData&quot;)
    @ApiOperation(&quot;工作台今日数据查询&quot;)
    public Result&lt;BusinessDataVO&gt; businessData()&#123;
        //获得当天的开始时间
        LocalDateTime begin = LocalDateTime.now().with(LocalTime.MIN);
        //获得当天的结束时间
        LocalDateTime end = LocalDateTime.now().with(LocalTime.MAX);

        BusinessDataVO businessDataVO = workspaceService.getBusinessData(begin, end);
        return Result.success(businessDataVO);
    &#125;

    /**
     * 查询订单管理数据
     * @return
     */
    @GetMapping(&quot;/overviewOrders&quot;)
    @ApiOperation(&quot;查询订单管理数据&quot;)
    public Result&lt;OrderOverViewVO&gt; orderOverView()&#123;
        return Result.success(workspaceService.getOrderOverView());
    &#125;

    /**
     * 查询菜品总览
     * @return
     */
    @GetMapping(&quot;/overviewDishes&quot;)
    @ApiOperation(&quot;查询菜品总览&quot;)
    public Result&lt;DishOverViewVO&gt; dishOverView()&#123;
        return Result.success(workspaceService.getDishOverView());
    &#125;

    /**
     * 查询套餐总览
     * @return
     */
    @GetMapping(&quot;/overviewSetmeals&quot;)
    @ApiOperation(&quot;查询套餐总览&quot;)
    public Result&lt;SetmealOverViewVO&gt; setmealOverView()&#123;
        return Result.success(workspaceService.getSetmealOverView());
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/WorkspaceService.java
package com.sky.service;

import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import java.time.LocalDateTime;

public interface WorkspaceService &#123;

    /**
     * 根据时间段统计营业数据
     * @param begin
     * @param end
     * @return
     */
    BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end);

    /**
     * 查询订单管理数据
     * @return
     */
    OrderOverViewVO getOrderOverView();

    /**
     * 查询菜品总览
     * @return
     */
    DishOverViewVO getDishOverView();

    /**
     * 查询套餐总览
     * @return
     */
    SetmealOverViewVO getSetmealOverView();

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/WorkspaceServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.StatusConstant;
import com.sky.entity.Orders;
import com.sky.mapper.DishMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.mapper.UserMapper;
import com.sky.service.WorkspaceService;
import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class WorkspaceServiceImpl implements WorkspaceService &#123;

    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private UserMapper userMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 根据时间段统计营业数据
     * @param begin
     * @param end
     * @return
     */
    public BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end) &#123;
        /**
         * 营业额：当日已完成订单的总金额
         * 有效订单：当日已完成订单的数量
         * 订单完成率：有效订单数 / 总订单数
         * 平均客单价：营业额 / 有效订单数
         * 新增用户：当日新增用户的数量
         */

        Map map = new HashMap();
        map.put(&quot;begin&quot;,begin);
        map.put(&quot;end&quot;,end);

        //查询总订单数
        Integer totalOrderCount = orderMapper.countByMap(map);

        map.put(&quot;status&quot;, Orders.COMPLETED);
        //营业额
        Double turnover = orderMapper.sumByMap(map);
        turnover = turnover == null? 0.0 : turnover;

        //有效订单数
        Integer validOrderCount = orderMapper.countByMap(map);

        Double unitPrice = 0.0;

        Double orderCompletionRate = 0.0;
        if(totalOrderCount != 0 &amp;&amp; validOrderCount != 0)&#123;
            //订单完成率
            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
            //平均客单价
            unitPrice = turnover / validOrderCount;
        &#125;

        //新增用户数
        Integer newUsers = userMapper.countByMap(map);

        return BusinessDataVO.builder()
                .turnover(turnover)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .unitPrice(unitPrice)
                .newUsers(newUsers)
                .build();
    &#125;


    /**
     * 查询订单管理数据
     *
     * @return
     */
    public OrderOverViewVO getOrderOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;begin&quot;, LocalDateTime.now().with(LocalTime.MIN));
        map.put(&quot;status&quot;, Orders.TO_BE_CONFIRMED);

        //待接单
        Integer waitingOrders = orderMapper.countByMap(map);

        //待派送
        map.put(&quot;status&quot;, Orders.CONFIRMED);
        Integer deliveredOrders = orderMapper.countByMap(map);

        //已完成
        map.put(&quot;status&quot;, Orders.COMPLETED);
        Integer completedOrders = orderMapper.countByMap(map);

        //已取消
        map.put(&quot;status&quot;, Orders.CANCELLED);
        Integer cancelledOrders = orderMapper.countByMap(map);

        //全部订单
        map.put(&quot;status&quot;, null);
        Integer allOrders = orderMapper.countByMap(map);

        return OrderOverViewVO.builder()
                .waitingOrders(waitingOrders)
                .deliveredOrders(deliveredOrders)
                .completedOrders(completedOrders)
                .cancelledOrders(cancelledOrders)
                .allOrders(allOrders)
                .build();
    &#125;

    /**
     * 查询菜品总览
     *
     * @return
     */
    public DishOverViewVO getDishOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;status&quot;, StatusConstant.ENABLE);
        Integer sold = dishMapper.countByMap(map);

        map.put(&quot;status&quot;, StatusConstant.DISABLE);
        Integer discontinued = dishMapper.countByMap(map);

        return DishOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    &#125;

    /**
     * 查询套餐总览
     *
     * @return
     */
    public SetmealOverViewVO getSetmealOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;status&quot;, StatusConstant.ENABLE);
        Integer sold = setmealMapper.countByMap(map);

        map.put(&quot;status&quot;, StatusConstant.DISABLE);
        Integer discontinued = setmealMapper.countByMap(map);

        return SetmealOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 根据条件统计菜品数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="java">sky-server  mapper/DishMapper.xml
&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from dish
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
/**
     * 根据条件统计套餐数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="java">sky-server  mapper/SetmealMapper.xml
&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from setmeal
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<h3 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h3><h6 id="在Java中操控Excel文件-读写操作"><a href="#在Java中操控Excel文件-读写操作" class="headerlink" title="在Java中操控Excel文件 [读写操作]"></a>在Java中操控Excel文件 [读写操作]</h6><p>Apache POI 是一个处理Miscrosoft Office各种文件格式的开源项目，POI都是用于操作Excel文件</p>
<h6 id="Apache-POI应用场景："><a href="#Apache-POI应用场景：" class="headerlink" title="Apache POI应用场景："></a>Apache POI应用场景：</h6><ul>
<li><strong>银行网银系统</strong>导出交易明细</li>
<li>各种业务系统到出Excel报表</li>
<li>批量导入业务数据</li>
</ul>
<pre><code class="java">sky-server  com/sky/test/POITest.java
package com.sky.test;

import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

public class POITest &#123;
    /**
     * 通过POI创建Excel文件并且写入文件内容
     */
    public static void write() throws Exception &#123;
        // 在内存中创建一个Excel文件
        XSSFWorkbook excel = new XSSFWorkbook();
        // 在Excel文件中创建一个sheet页
        XSSFSheet sheet = excel.createSheet(&quot;info&quot;);
        // 在Sheet中创建行对象, rownum编号从0开始
        XSSFRow row = sheet.createRow(1);
        // 创建单元格并写入文件内容
        row.createCell(1).setCellValue(&quot;姓名&quot;);
        row.createCell(2).setCellValue(&quot;城市&quot;);

        // 创建一个新行
        row = sheet.createRow(2);
        row.createCell(1).setCellValue(&quot;张三&quot;);
        row.createCell(2).setCellValue(&quot;北京&quot;);

        row = sheet.createRow(3);
        row.createCell(1).setCellValue(&quot;李四&quot;);
        row.createCell(2).setCellValue(&quot;南京&quot;);

        // 通过输出流将内存中的Excel文件写入到磁盘
        FileOutputStream out = new FileOutputStream(new File(&quot;C:\\Users\\Pluminary\\Desktop\\itcast.xlsx&quot;));
        excel.write(out);

        // 关闭资源
        out.close();
        excel.close();
    &#125;

    public static void main(String[] args) throws Exception &#123;
        write();
    &#125;
&#125;
</code></pre>
<h3 id="导出运营数据Excel报表"><a href="#导出运营数据Excel报表" class="headerlink" title="导出运营数据Excel报表"></a>导出运营数据Excel报表</h3><h6 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h6><ul>
<li>设计Excel模板文件</li>
<li>查询近30天的运营数据</li>
<li>将查询到的运营数据写入模板文件</li>
<li>通过输出流将Excel文件下载到客户端浏览器</li>
</ul>
<pre><code class="java">sky-pojo  com/sky/vo/BusinessDataVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 数据概览
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BusinessDataVO implements Serializable &#123;

    private Double turnover;//营业额

    private Integer validOrderCount;//有效订单数

    private Double orderCompletionRate;//订单完成率

    private Double unitPrice;//平均客单价

    private Integer newUsers;//新增用户数

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
/**
     * 导出运营数据报表
     * @param response
     */
    @GetMapping(&quot;/export&quot;)
    @ApiOperation(&quot;导出运营数据报表&quot;)
    public void export(HttpServletResponse response) &#123;
        reportService.exportBusinessData(response);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
 /**
     * 导出运营数据报表
     * @param response
     */
    void exportBusinessData(HttpServletResponse response);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
/**
     * 导出运营数据报表
     * @param response
     */
    @Override
    public void exportBusinessData(HttpServletResponse response) &#123;
        // 查询数据库 获取营业数据 -- 查询最近30天的营业数据
        LocalDate dateBegin = LocalDate.now().minusDays(30);
        LocalDate dateEnd = LocalDate.now().minusDays(1);
        // 查询概览数据
        BusinessDataVO businessDataVO = workspaceService.getBusinessData(LocalDateTime.of(dateBegin, LocalTime.MIN),LocalDateTime.of(dateEnd, LocalTime.MAX));

        // 查询的数据通过POI写入Excel文件中 (获得对象 获得类加载器 类加载器读取资源)
        InputStream in = this.getClass().getClassLoader().getResourceAsStream(&quot;template/运营数据报表模板.xlsx&quot;);
        try &#123;
            // 基于模板文件创建一个新的Excel文件
            XSSFWorkbook excel = new XSSFWorkbook();

            // 填充数据 [获取标签页]

            XSSFSheet sheet = excel.getSheet(&quot;Sheet1&quot;);
            // 获取第二行[索引是从0开始]
            sheet.getRow(1).createCell(1).setCellValue(&quot;时间：&quot; + dateBegin + &quot;至&quot; + dateEnd);

            // 获得第四行
            XSSFRow row = sheet.getRow(3);
            row.getCell(2).setCellValue(businessDataVO.getTurnover());//营业额
            row.getCell(4).setCellValue(businessDataVO.getOrderCompletionRate());//订单完成率
            row.getCell(6).setCellValue(businessDataVO.getNewUsers());//新增用户数

            // 获得第五行
            row = sheet.getRow(4);
            row.getCell(2).setCellValue(businessDataVO.getValidOrderCount());//有效订单数
            row.getCell(4).setCellValue(businessDataVO.getUnitPrice());//平均单品价格

            // 填充明细数据
            for (int i = 0; i &lt; 30; i++) &#123;
                LocalDate date = dateBegin.plusDays(i);
                // 查询某一天的营业数据
                workspaceService.getBusinessData(LocalDateTime.of(date, LocalTime.MIN), LocalDateTime.of(date, LocalTime.MAX));
                // 获得某一行
                row = sheet.getRow(7 + i);// 利用循环 超越循环
                row.getCell(1).setCellValue(date.toString());
                row.getCell(2).setCellValue(businessDataVO.getTurnover());
                row.getCell(3).setCellValue(businessDataVO.getValidOrderCount());
                row.getCell(6).setCellValue(businessDataVO.getOrderCompletionRate());
                row.getCell(4).setCellValue(businessDataVO.getUnitPrice());
                row.getCell(5).setCellValue(businessDataVO.getNewUsers());
            &#125;

            // 通过输出流将Excel文件下载到客户端浏览器
            ServletOutputStream out = response.getOutputStream();
            excel.write(out);

            // 关闭资源
            out.close();
            excel.close();
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/09/28/后端/苍穹外卖/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
    </div>

    <div class="page-index">

        

        <span class="current">
            1
        </span>

        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/12">
                <span class="page-num">
                    12
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>