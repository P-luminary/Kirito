
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2024/04/17/英语/2024万能论据/">
        <h2>
            2024万能论据
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><pre><code class="java">1.sth contribute to one&#39;s health by giving sb some physical exercise.
  某物能有助于身体健康通过给某人一些身体锻炼
2.sth is harmful to/bad for/detrimental to health.
  某物对健康有害
3.sth exert great pressure on sb.
  某物给某人施加重压
4.sb may become more solitary and even suffer from certain mental illness.
  某人可能变得孤僻甚至产生某些心理疾病
5.Exercise can enhance immune function.
  锻炼可以增强免疫力
6.adopt a healthy and meaningful life style.
  采取一个健康和有意义的生活方式
7.release pressure.
  ★减压 
</code></pre>
<h2 id="乐趣"><a href="#乐趣" class="headerlink" title="乐趣"></a>乐趣</h2><pre><code class="java">1.sth will make ones&#39;s life more enjoyable. That is to say, sth can add color to the dull routine of everyday life.
  某物可以使某人的生活更加有乐趣，也就是说，某物为每天枯燥的生活增添了一些色彩
2.sth have become the foucus of one&#39;s life and the source of one&#39;s happiness and contentment.
  某物已成为某人生活的中心和快乐的来源
</code></pre>
<h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><pre><code class="java">1.equip sb with the ability to do sth.
  ★使某人拥有做某事的能力
2.be competent enough to do sth.
  ★有能力做某事
3.tell the useful information from the useless one.
  ★从无用信息中挑出有用信息
4.sth will provide sb with more opportunities to develop one’s interpersonal skills, which may put them in a favorable position in the future job markets.
  某事会使某人有更多机会发展人际交往能力，而这对他（们）未来找工作是非常有好处的
5.By doing sth, sb can not only improve one’s academic studies, but gain many abilities which he will never be able to get from the textbooks.
  通过做某事，某人不仅能够提高他们的专业能力，而且能获得从课本上得不到的能力
6.tap one&#39;s potential.
  ★开发潜能
7.sth will help people foster one&#39;s independence.
  某物帮助某人培养独立
8.help strengthen one&#39;s sense of responsibility.
  ★帮助加强某人的责任感
9.achieve one&#39;s goal.
  ★达成某人的目标
10.learn from mistake.
  ★吸取教训
11.surmount difficulities
  ★战胜困难
</code></pre>
<h3 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h3><pre><code class="java">1.develop and cultivate character and interpersonal skills.
  ★培养性格和人际交往的能力
2.make eye contact.
  ★做眼神交流
3.live only in the virtual world.
  ★仅仅生活在虚拟世界
4.hinder communication.
  ★阻碍沟通
5.The over-dependence on mobile phones can harm the relationship among friends and family.
  过度依赖手机会伤害朋友以及家人的关系
6.At dinner tables, instead of chatting and laughing with each other, many people choose to chat with other friends online.
  在饭桌前，人们不是相互聊天谈笑，而是选择和朋友在网上聊天
7.Many people have become over-dependent on the Internet and neglected face-to-face communication.
  很多人变得太依赖网络并且忽略了面对面交流。
8.The Internet enables more effective communication in some situations, but over-dependence on it actually pulls people apart.
  网络在一些情况下使交流更有效，但是过度依赖它实际是人们更疏远
</code></pre>
<h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><pre><code class="java">1.Little by little, our knowledge will be well enriched, and our horizons will be greatly broadened.
  逐渐的，我们的知识会得到增加，我们的视野将会大大的拓宽
2.reduce study load 
  ★减轻学习负担
3.sth can broaden people&#39;s minds to the extent which may not be reached previously.
  某物可以扩大人们的视野到一个之前不能到达的程度
</code></pre>
<h3 id="方便"><a href="#方便" class="headerlink" title="方便"></a>方便</h3><pre><code class="java">1.sth can save sb a great deal of time, so sb would be able to concentrate more time and energy on one&#39;s academic work.
  某物能节省大量时间，这会使某人有更多的时间和精力放在学习上
2.sth have brought people great convenience in doing sth.
  某物在人们做某事时带来了巨大的方便
3.There is no denying that sth have greatly enhanced work/study efficiency.
  毋庸置疑，某物很大的提升了工作/学习效率
</code></pre>
<h3 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h3><pre><code class="java">1.relieve one&#39;s families&#39; financial burden to some extent.
  这在一定基础上可以缓解某人家庭的经济负担
2.The welfare and salary have been improved greatly.
  福利和收入得到了巨大的提升
3.Money is so indispensable in people’s lives that without it no material comforts or well-being can be guaranteed.
  钱在生活中必不可少，没有了钱，也就谈不上物质享受和幸福了
4.Money doesn&#39;t necessarily ensure happiness or well-being. 
  钱不一定能保证幸福
5.can afford the huge cost of sth.
  ★能够承担某物的高额
6.bring huge economic loss to sb.
  ★给某人带来巨大经济损失
</code></pre>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><pre><code class="java">1.sth pose a great threat to one&#39;s safety.
  某物对某人的安全造成巨大威胁
2.ensure the safety of sb. 
  ★确保某人的安全
3.sth add to the safety of sth.
  某物增加了某事的安全
4.food safety.
  ★食品安全
</code></pre>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><pre><code class="java">1.To balance economic growth with environmental protection is highly important.
  权衡经济发展和环境保护是高度重要的
2.We all should bear in mind that environmental protection is everybody&#39;s duty.
  我们都应该记住环境保护使每个人的职责
3.sth help to build harmonious cooperation and effective communication, which helps to create a pleasant working atmosphere.
  某事帮助建立和谐的合作关系和有效的沟通，这将帮助建立一个愉快的工作氛围
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#879cff>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2024/04/17/英语/2024万能论据/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/04/11/后端/SpringCloud基础-电商实战/">
        <h2>
            SpringCloud基础+电商实战
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring-Cloud基础介绍"><a href="#Spring-Cloud基础介绍" class="headerlink" title="Spring Cloud基础介绍"></a>Spring Cloud基础介绍</h1><ul>
<li>微服务的基本概念、设计与拆分原则</li>
<li>微服务和Spring Cloud的关系</li>
<li>微服务常见的组件和功能</li>
<li>课程查询案例基本介绍、系统架构设计和接口设计</li>
<li>分模块构建Spring Cloud项目</li>
<li>完成课程列表、课程价格服务开发</li>
<li>课程服务整合，服务注册与发现</li>
<li>整合Feign实现服务间调用</li>
<li>网关的集成与开发，并接入服务</li>
<li>引入服务的熔断与降级，并进行实操演练</li>
</ul>
<h2 id="微服务基础"><a href="#微服务基础" class="headerlink" title="微服务基础"></a>微服务基础</h2><ul>
<li><strong>什么是</strong>微服务？</li>
<li>微服务的<strong>特点</strong></li>
<li>微服务<strong>优缺点</strong></li>
<li>微服务的<strong>两大门派</strong> [Spring Cloud 和 Dubbo]</li>
<li>微服务<strong>拆分</strong></li>
<li>微服务<strong>扩展</strong></li>
<li>微服务<strong>重要模块</strong></li>
</ul>
<h3 id="微服务热度"><a href="#微服务热度" class="headerlink" title="微服务热度"></a>微服务热度</h3><h5 id="单体应用的痛点"><a href="#单体应用的痛点" class="headerlink" title="单体应用的痛点"></a>单体应用的痛点</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/ebd1e99f500608925cfe2623d05c22b5a75cb4a3/data/%E5%8D%95%E4%BD%93%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB.jpg"></p>
<h5 id="什么是服务化"><a href="#什么是服务化" class="headerlink" title="什么是服务化"></a>什么是服务化</h5><ul>
<li>把传统的单机应用中的本地方法调用，改造成通过<strong>RPC、HTTP</strong>产生的远程方法调用</li>
<li>把模块从单体应用中拆分出来，<strong>独立</strong>成一个服务部署</li>
</ul>
<h5 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h5><ul>
<li><p>一系列、一部分</p>
</li>
<li><p>是一种架构风格</p>
</li>
<li><p>开发单体应用作为一系列<strong>小型服务</strong>的套件，其中每个服务都运行再<strong>自己的进程</strong>中，并且通过<strong>轻量级</strong>的机制实现彼此间的通信，这通常是<strong>HTTP</strong>资源API</p>
</li>
<li><p>这些服务是围绕着业务功能构建的，并且可以通过完全<strong>自动化的部署</strong>机制进行独立部署</p>
</li>
<li><p>这些服务的集中式管理做到了最小化(例如<strong>docker</strong>相关技术)，每一种服务都可以通过<strong>不同的编程语言</strong>进行编写，并且可以使用<strong>不同的数据存储</strong>技术</p>
</li>
</ul>
<h3 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h3><ul>
<li><p>组件以<strong>服务</strong>形式来提供</p>
</li>
<li><p>产品不是项目</p>
</li>
<li><p>轻量级通信、独立进程</p>
</li>
<li><p><strong>分散</strong>治理、去中心化治理</p>
</li>
<li><p><strong>容错性</strong>设计</p>
</li>
<li><h6 id="会带来团队组织架构的调整"><a href="#会带来团队组织架构的调整" class="headerlink" title="会带来团队组织架构的调整"></a>会带来团队组织架构的调整</h6></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/82f8b26e0790184252e432ce2e28a606fb938e89/data/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AF%B9%E5%9B%A2%E9%98%9F%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84%E7%9A%84%E8%B0%83%E6%95%B4.jpg"></p>
<h3 id="微服务优缺点"><a href="#微服务优缺点" class="headerlink" title="微服务优缺点"></a>微服务优缺点</h3><ul>
<li>服务简单、便于学习和上手，相对<strong>易于维护</strong></li>
<li>独立部署，<strong>灵活</strong>扩展</li>
<li><strong>技术栈</strong>丰富</li>
</ul>
<h5 id="微服务缺点"><a href="#微服务缺点" class="headerlink" title="微服务缺点"></a>微服务缺点</h5><ul>
<li><strong>运维</strong>成本过高 [磁盘满 CPU高]</li>
<li>接口可能<strong>不匹配</strong></li>
<li>代码可能<strong>重复</strong> [要非常明确的定义每个API]</li>
<li><strong>架构复杂度</strong>提高</li>
</ul>
<h3 id="微服务两大门派"><a href="#微服务两大门派" class="headerlink" title="微服务两大门派"></a>微服务两大门派</h3><ul>
<li><strong>Spring Cloud</strong>：众多子项目【最大供应者：Netflix内容付费知识】</li>
<li><strong>dubbo</strong>：高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</li>
<li>dubbo提供的能力只是SpringCloud的一部分<strong>子集</strong></li>
</ul>
<h6 id="Dubbo虽然有很多不提供的组件-但是可以和其他供应商合作完成提供任务"><a href="#Dubbo虽然有很多不提供的组件-但是可以和其他供应商合作完成提供任务" class="headerlink" title="[Dubbo虽然有很多不提供的组件 但是可以和其他供应商合作完成提供任务]"></a>[Dubbo虽然有很多不提供的组件 但是可以和其他供应商合作完成提供任务]</h6><table>
<thead>
<tr>
<th>核心组件</th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册中心</td>
<td>Zookeeper</td>
<td>Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td>服务调用方式</td>
<td>RPC</td>
<td>REST API</td>
</tr>
<tr>
<td>服务网关</td>
<td>无</td>
<td>Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td>断路器</td>
<td>不完善</td>
<td>Spring Cloud Netflix Hystrix</td>
</tr>
<tr>
<td>分布式配置</td>
<td>无</td>
<td>Spring Cloud Config</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>无</td>
<td>Spring Cloud Sleuth</td>
</tr>
<tr>
<td>消息总线</td>
<td>无</td>
<td>Spring Cloud Bus</td>
</tr>
<tr>
<td>数据流</td>
<td>无</td>
<td>Spring Cloud Stream</td>
</tr>
<tr>
<td>批量任务</td>
<td>无</td>
<td>Spring Cloud Task</td>
</tr>
</tbody></table>
<h5 id="通信协议对比"><a href="#通信协议对比" class="headerlink" title="通信协议对比"></a>通信协议对比</h5><ul>
<li><strong>RPC</strong> vs <strong>REST</strong></li>
<li>服务提供方与调用方接口依赖方式太强</li>
<li>服务对平台敏感，难以简单复用</li>
</ul>
<h5 id="文档质量对比"><a href="#文档质量对比" class="headerlink" title="文档质量对比"></a>文档质量对比</h5><ul>
<li>Dubbo的文档可以说再国内开源框架中算是一流的，提供了中文与英文两种版本</li>
<li>Spring Cloud文档体量大，更多的是偏向整合，更深的使用方法还是需要查看整合组件的详细文档</li>
</ul>
<h5 id="两大门派选型建议"><a href="#两大门派选型建议" class="headerlink" title="两大门派选型建议"></a>两大门派选型建议</h5><ul>
<li>Dubbo &#x3D;&gt; 组装电脑 【中文文档多】</li>
<li>Spring Cloud &#x3D;&gt; 品牌机【稳定可靠】</li>
</ul>
<h3 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h3><h5 id="什么时候进行服务化拆分"><a href="#什么时候进行服务化拆分" class="headerlink" title="什么时候进行服务化拆分"></a>什么时候进行服务化拆分</h5><ul>
<li><strong>第一阶段</strong>的主要目标是快速开发和验证想法</li>
<li>进一步增加<strong>更多的新特性</strong>来吸引更多的目标用户</li>
<li>同时进行开发的人员<strong>超过10人</strong>，这个时候就该考虑到服务化拆分了</li>
</ul>
<h5 id="不适合拆分的情况"><a href="#不适合拆分的情况" class="headerlink" title="不适合拆分的情况"></a>不适合拆分的情况</h5><ul>
<li>小团队，技术基础较薄弱</li>
<li>流量不高，压力小，业务变化也不大</li>
<li>对延迟很敏感的低延迟高并发系统</li>
</ul>
<h5 id="服务化拆分的两种方式"><a href="#服务化拆分的两种方式" class="headerlink" title="服务化拆分的两种方式"></a>服务化拆分的两种方式</h5><ul>
<li>纵向拆分[上方区别图]</li>
<li>横向拆分</li>
<li>结合业务综合分析</li>
</ul>
<h3 id="服务扩展"><a href="#服务扩展" class="headerlink" title="服务扩展"></a>服务扩展</h3><h5 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/2f5e67f1d4e1d9f7acb927786096a1527bfd282b/data/%E7%BB%B4%E5%BA%A6-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95.jpg"></p>
<h5 id="自动按需扩展"><a href="#自动按需扩展" class="headerlink" title="自动按需扩展"></a>自动按需扩展</h5><ul>
<li>根据CPU负载程度、特定时间(比如周末)、消息中间件的队列长度、业务具体规则、预测等来决定是否扩展</li>
<li>自动分配一个新的服务实例，提高<strong>可用性</strong></li>
<li>提高了<strong>可伸缩性</strong>(双11之后，自动减少服务器)</li>
<li>具有<strong>最佳使用率</strong>，节约成本</li>
</ul>
<h3 id="微服务重要模块"><a href="#微服务重要模块" class="headerlink" title="微服务重要模块"></a>微服务重要模块</h3><ul>
<li>服务描述</li>
<li>注册中心</li>
<li>服务框架</li>
<li>负载均衡</li>
<li>熔断和降级</li>
<li>网关</li>
</ul>
<h1 id="Spring-Cloud课程查询"><a href="#Spring-Cloud课程查询" class="headerlink" title="Spring Cloud课程查询"></a><span style = "color:red">Spring Cloud课程查询</span></h1><ul>
<li>Spring Cloud简介</li>
<li>项目<strong>整体设计</strong></li>
<li>课程列表模块开发</li>
<li><span style = "color:red">课程价格模块开发</span> [模块间互相调用]</li>
<li>服务注册与发现<strong>Eureka</strong></li>
<li>服务间调用<strong>Feign</strong></li>
<li>负载均衡<strong>Ribbon</strong></li>
<li>熔断器<strong>Hystrix</strong> [兜底界面 默认返回]</li>
<li>网关<strong>Zuul</strong></li>
<li>整体测试</li>
</ul>
<h3 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h3><ul>
<li>成熟的微服务框架，定位为开发人员提供工具，以快速构建分布式系统</li>
</ul>
<h5 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h5><table>
<thead>
<tr>
<th align="center">核心组件</th>
<th align="center">Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务注册中心</td>
<td align="center">Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td align="center">服务调用方式</td>
<td align="center">REST API、Feign、Ribbon</td>
</tr>
<tr>
<td align="center">服务网关</td>
<td align="center">Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td align="center">熔断器</td>
<td align="center">Spring Cloud Netflix Hystrix</td>
</tr>
</tbody></table>
<h3 id="项目整体设计"><a href="#项目整体设计" class="headerlink" title="项目整体设计"></a>项目整体设计</h3><ul>
<li><p>项目介绍</p>
</li>
<li><h5 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h5><ul>
<li>课程列表</li>
<li>单个课程价格</li>
<li>整合课程列表和价格</li>
</ul>
</li>
<li><p><strong>表设计</strong></p>
</li>
</ul>
<h3 id="系统数据流向"><a href="#系统数据流向" class="headerlink" title="系统数据流向"></a>系统数据流向</h3><blockquote>
<p>【课程列表数据】→ 【课程列表服务】<br>                                                  ↓<br>【课程价格数据】→ 【课程价格服务】→ 【整体列表+价格】</p>
</blockquote>
<h3 id="新建多模块项目"><a href="#新建多模块项目" class="headerlink" title="新建多模块项目"></a>新建多模块项目</h3><pre><code class="java">创建一个 spring-cloud-course-pracice 并删除src文件夹
新建New → module → Maven → course-service → 删除src
    新建New → module → New Module → Maven → course-list → Parent：course-service 
    新建New → module → New Module → Maven → course-price → Parent：course-service 
D:\Java+4399\阶段5：Java分布与微服务实战\第32周 Spring Cloud基础\第2节 Spring Cloud开发课程查询功能\辅助材料\SpringCloud课程查询源码【优质it资源微信it-wangke18】.zip\SpringCloud课程查询源码\课程价格模块开发后\spring-cloud-course-practice
</code></pre>
<h5 id="course-service-course-list"><a href="#course-service-course-list" class="headerlink" title="course-service.course-list"></a>course-service.course-list</h5><pre><code class="xml">pom.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;course-service&lt;/artifactId&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;artifactId&gt;course-list&lt;/artifactId&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/course/controller/CourseListController.java
package com.imooc.course.controller;

import com.imooc.course.entity.Course;
import com.imooc.course.service.CourseListService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * CourseListController课程列表Controller
 */

@RestController
public class CourseListController &#123;
    //提供课程列表服务
    @Autowired //引入课程服务
    CourseListService courseListService;


    @GetMapping(&quot;/courses&quot;)
    public List&lt;Course&gt; courseList() &#123;
        //return → service
        return courseListService.getCourseList();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/CourseListService.java
package com.imooc.course.service;

import com.imooc.course.entity.Course;

import java.util.List;

/**
 * 课程列表服务
 */
public interface CourseListService &#123;
    List&lt;Course&gt; getCourseList();
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/impl/CourseListServiceImpl.java
package com.imooc.course.service.impl;

import com.imooc.course.dao.CourseMapper;
import com.imooc.course.entity.Course;
import com.imooc.course.service.CourseListService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 课程服务实现类
 */
@Service
public class CourseListServiceImpl implements CourseListService &#123;
    @Autowired
    CourseMapper courseMapper;
    @Override
    public List&lt;Course&gt; getCourseList() &#123;
        return courseMapper.findValidCourses();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/entity/Course.java
package com.imooc.course.entity;

import java.io.Serializable;

/**
 * Course的实体类
 */
public class Course implements Serializable &#123;
    Integer id;
    Integer courseId;
    String courseName;
    Integer valid;

    @Override
    public String toString() &#123;
        return &quot;Course&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, courseName=&#39;&quot; + courseName + &#39;\&#39;&#39; +
                &quot;, valid=&quot; + valid +
                &#39;&#125;&#39;;
    &#125;
    Getter+Setter  
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/dao/CourseMapper.java
package com.imooc.course.dao;

import com.imooc.course.entity.Course;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 描述课程的Mapper类
 */
@Mapper
@Repository
public interface CourseMapper &#123;
    @Select(&quot;SELECT * FROM course WHERE valid = 1&quot;)
    List&lt;Course&gt; findValidCourses();
&#125;
</code></pre>
<pre><code class="java">application.properties

server.port=8081
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_practice?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root
logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;
# entity的实体类与数据库名进行驼峰命名转换
mybatis.configuration.map-underscore-to-camel-case=true 
spring.application.name=course-list
</code></pre>
<pre><code class="java">com/imooc/course/CoursePriceApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CoursePriceApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(CoursePriceApplication.class, args);
    &#125;
&#125;
=====================================================================
</code></pre>
<pre><code class="mysql">数据库名：course_practice
   表名：course
   字段：id[自增]   course_id   course_name   valid
</code></pre>
<h5 id="课程列表模块开发-总结-注意点"><a href="#课程列表模块开发-总结-注意点" class="headerlink" title="课程列表模块开发-总结 [注意点]"></a>课程列表模块开发-总结 [注意点]</h5><ul>
<li>多模块开发</li>
<li>实体类实现Serializable接口、set方法</li>
<li>MyBatis的驼峰配置</li>
</ul>
<h5 id="course-list-course-price"><a href="#course-list-course-price" class="headerlink" title="course-list.course-price"></a>course-list.course-price</h5><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;course-service&lt;/artifactId&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;artifactId&gt;course-price&lt;/artifactId&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/course/controller/CoursePriceController.java
package com.imooc.course.controller;

import com.imooc.course.entity.CoursePrice;
import com.imooc.course.service.CoursePriceService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 课程价格控制器
 */

@RestController
public class CoursePriceController &#123;
    @Autowired
    CoursePriceService coursePriceService;
    @GetMapping(&quot;/price&quot;)
    public Integer getCoursePrice(Integer courseId)&#123;
        CoursePrice coursePrice = coursePriceService.getCoursePrice(courseId);
        return coursePrice.getPrice();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/CoursePriceService.java
package com.imooc.course.service;

import com.imooc.course.entity.CoursePrice;

import java.util.List;

/**
 * 课程价格服务
 */
public interface CoursePriceService &#123;
    CoursePrice getCoursePrice(Integer courseId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/impl/CoursepriceServiceImpl.java
package com.imooc.course.service.impl;

import com.imooc.course.dao.CoursePriceMapper;
import com.imooc.course.entity.CoursePrice;
import com.imooc.course.service.CoursePriceService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 课程价格的服务实现类
 */
@Service
public class CoursepriceServiceImpl implements CoursePriceService &#123;
    @Autowired
    CoursePriceMapper coursePriceMapper;
    @Override
    public CoursePrice getCoursePrice(Integer courseId) &#123;
        return coursePriceMapper.findCoursePrice(courseId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/entity/CoursePrice.java
package com.imooc.course.entity;

import java.io.Serializable;

/**
 * CoursePrice的实体类
 */
public class CoursePrice implements Serializable &#123;
    Integer id;
    Integer courseId;
    Integer price;

    @Override
    public String toString() &#123;
        return &quot;CoursePrice&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, price=&quot; + price +
                &#39;&#125;&#39;;
    &#125;
    Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/dao/CoursePriceMapper.java
package com.imooc.course.dao;

import com.imooc.course.entity.CoursePrice;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

/**
 * 课程价格Mapper类
 */
@Mapper
@Repository
public interface CoursePriceMapper &#123;
    @Select(&quot;SELECT * FROM course_price WHERE course_id = #&#123;courseId&#125;&quot;)
    CoursePrice findCoursePrice(Integer courseId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/CoursePriceApplication.java
package com.imooc.course;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CoursePriceApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(CoursePriceApplication.class, args);
    &#125;
&#125;
==========================================================
http://127.0.0.1:8082/price?courseId=409
</code></pre>
<pre><code class="mysql">数据库名：course_practice
   表名：course_price
   字段：id[自增]   course_id    price
</code></pre>
<h3 id="Eureka的作用和架构"><a href="#Eureka的作用和架构" class="headerlink" title="Eureka的作用和架构"></a>Eureka的作用和架构</h3><h5 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h5><ul>
<li>用于定位服务，直接找到组件中的各个服务地址</li>
<li>114[各种服务的提供者]、物业[维护各个住户的信息(注册中心)]</li>
</ul>
<h5 id="为什么需要服务注册与发现-移除不影响-但会有很多麻烦"><a href="#为什么需要服务注册与发现-移除不影响-但会有很多麻烦" class="headerlink" title="为什么需要服务注册与发现 [移除不影响 但会有很多麻烦]"></a>为什么需要服务注册与发现 [移除不影响 但会有很多麻烦]</h5><ul>
<li>IP变化</li>
<li>难以维护</li>
<li>改进<ul>
<li><strong>节点变化</strong>[服务的提供者和消费者] [消费者需要调用提供者的API来获得服务] 若提供者修改了ip 此时应该上传到注册中心，消费者此时需要得到IP和API 无需直接找提供者 直接去<strong>注册中心</strong>调用</li>
</ul>
</li>
</ul>
<h5 id="Eureka架构"><a href="#Eureka架构" class="headerlink" title="Eureka架构"></a>Eureka架构</h5><ul>
<li>EureKa <strong>Server</strong> 和 EureKa <strong>Client</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6a3bfcded810da5a827559f3b8f868a0de867787/data/Eureka%E6%9E%B6%E6%9E%84.png"></p>
<ul>
<li><strong>集群</strong> [只要能获得一个Eureka Server 就能获得整个信息]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f756e06eed90edb75c6b3b6f234eee57763d8811/data/Eureka%E6%9E%B6%E6%9E%84-%E9%9B%86%E7%BE%A4.png"></p>
<h3 id="引入Eureka"><a href="#引入Eureka" class="headerlink" title="引入Eureka"></a>引入Eureka</h3><ul>
<li><h6 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h6></li>
<li><h6 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h6></li>
<li><h6 id="启动注解"><a href="#启动注解" class="headerlink" title="启动注解"></a>启动注解</h6></li>
</ul>
<pre><code class="xml">pom.xml(eureka-server)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;spring-cloud-course-practice&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;eureka-server&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;!-- 模块名及描述信息 --&gt;
    &lt;name&gt;course-eureka-server&lt;/name&gt;
    &lt;description&gt;Spring Cloud Eureka&lt;/description&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">pom.xml(Spring-cloud-course-practice)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;modules&gt;
    &lt;module&gt;course-service&lt;/module&gt;
    &lt;module&gt;eureka-server&lt;/module&gt;
  &lt;/modules&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.12.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;com.imooc&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-course-practice&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;spring-cloud-course-practice&lt;/name&gt;
  &lt;description&gt;course project for Spring Cloud&lt;/description&gt;

  &lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;!--  表示Spring Cloud的版本--&gt;
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
        &lt;version&gt;Greenwich.SR5&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties(eureka-server)

spring.application.name=eureka-server
server.port=8000
eureka.instance.hostname=localhost
#fetch-registry???????????????????
eureka.client.fetch-registry=false
#register-with-eureka??????????Eureka Server????true?
eureka.client.register-with-eureka=false
eureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<pre><code class="mysql">application.properties(course-list)

server.port=8081
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_practice?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root
logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;
# entity?????????????????
mybatis.configuration.map-underscore-to-camel-case=true 
spring.application.name=course-list
#??????? eureka-server??application.properties?defaultZone????????????????
eureka.client.service-url.defaultZone=http://localhost:8000/eureka/
</code></pre>
<pre><code class="mysql">application.properties(course-price)

server.port=8082
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_practice?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root
logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;
mybatis.configuration.map-underscore-to-camel-case=true
spring.application.name=course-price
eureka.client.service-url.defaultZone=http://localhost:8000/eureka/
</code></pre>
<pre><code class="java">com/imooc/course/EurekaServerApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * Eureka的服务端
 */
@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaServerApplication.class, args);
    &#125;
&#125;
========================================================
http://127.0.0.1:8000/
</code></pre>
<h3 id="利用Feign实现服务间调用"><a href="#利用Feign实现服务间调用" class="headerlink" title="利用Feign实现服务间调用"></a>利用Feign实现服务间调用</h3><h5 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h5><ul>
<li>声明式、模板化的HTTP客户端，方便的调用远程的HTTP请求 [基于接口实现]</li>
</ul>
<h6 id="集成Feign"><a href="#集成Feign" class="headerlink" title="集成Feign"></a>集成Feign</h6><ul>
<li>引入依赖</li>
<li>配置文件</li>
<li>注解</li>
</ul>
<pre><code class="xml">pom.xml (course-price)
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
    &lt;/dependency&gt;

application.properties
eureka.client.service-url.defaultZone=http://localhost:8000/eureka/
</code></pre>
<pre><code class="java">com/imooc/course/controller/CoursePriceController.java
package com.imooc.course.controller;

import com.imooc.course.client.CourseListClient;
import com.imooc.course.entity.Course;
import com.imooc.course.entity.CoursePrice;
import com.imooc.course.service.CoursePriceService;
import java.util.List;
import javax.xml.ws.Action;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 描述：     课程价格控制器
 */
@RestController
public class CoursePriceController &#123;

    @Autowired
    CoursePriceService coursePriceService;

    @Autowired
    CourseListClient courseListClient;

    @GetMapping(&quot;/price&quot;)
    public Integer getCoursePrice(Integer courseId) &#123;
        CoursePrice coursePrice = coursePriceService.getCoursePrice(courseId);
        return coursePrice.getPrice();
    &#125;

    @GetMapping(&quot;/coursesInPrice&quot;)
    public List&lt;Course&gt; getCourseListInPrice(Integer courseId) &#123;
        List&lt;Course&gt; courses = courseListClient.courseList();
        return courses;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/client/CourseListClient.java[接口]
package com.imooc.course.client;

import com.imooc.course.entity.Course;
import java.util.List;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

/**
 * 描述：     课程列表的Feign客户端
 */
@FeignClient(&quot;course-list&quot;)
public interface CourseListClient &#123;

    @GetMapping(&quot;/courses&quot;)
    List&lt;Course&gt; courseList();
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/CoursePriceApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class CoursePriceApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(CoursePriceApplication.class, args);
    &#125;
&#125;
=============================================================
http://127.0.0.1:8082/coursesInPrice

[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 362,
        &quot;courseName&quot;: &quot;SpringCloud自学&quot;,
        &quot;valid&quot;: 1
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;courseId&quot;: 409,
        &quot;courseName&quot;: &quot;玩转Java并发工具&quot;,
        &quot;valid&quot;: 1
    &#125;
]
</code></pre>
<h3 id="负载均衡的两种类型"><a href="#负载均衡的两种类型" class="headerlink" title="负载均衡的两种类型"></a>负载均衡的两种类型</h3><ul>
<li><strong>客户端</strong>负载均衡(Ribbon)</li>
<li><strong>服务端</strong>负载均衡(Nginx)</li>
</ul>
<h5 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h5><ul>
<li>RandomRule 表示<strong>随机</strong>策略</li>
<li>RoundRobinRule 表示<strong>轮询</strong>策略</li>
<li>ResponseTimeWeightedRule<strong>加权</strong>，根据每一个Server的平均响应时间动态加权</li>
</ul>
<h5 id="配置不同的负载均衡方式"><a href="#配置不同的负载均衡方式" class="headerlink" title="配置不同的负载均衡方式"></a>配置不同的负载均衡方式</h5><ul>
<li>Ribbon.NFLoadBalancerRuleClassName</li>
</ul>
<pre><code class="java">application.properties(course-price)
course-list.ribbon.NFLoadBanlancerRuleClassName=com.netflix.loadbalancer.RoundRobinRule
</code></pre>
<h3 id="为什么要断路器"><a href="#为什么要断路器" class="headerlink" title="为什么要断路器"></a>为什么要断路器</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e441bfbcf0e2cf07f9d53564669b2dbd90533142/data/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%96%AD%E8%B7%AF%E5%99%A8.jpg"></p>
<h5 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h5><pre><code class="xml">pom.xml(course-price)   
&lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<pre><code class="java">application.properties(course-price)
feign.hystrix.enabled=true
</code></pre>
<pre><code class="java">com/imooc/course/CoursePriceApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableCircuitBreaker
public class CoursePriceApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(CoursePriceApplication.class, args);
    &#125;
&#125;
================================================================
所有服务都打开时 http://127.0.0.1:8082/coursesInPrice
[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 362,
        &quot;courseName&quot;: &quot;SpringCloud白学&quot;,
        &quot;valid&quot;: 1
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;courseId&quot;: 409,
        &quot;courseName&quot;: &quot;玩转Java并发工具&quot;,
        &quot;valid&quot;: 1
    &#125;
]
当把CouresListApplication服务关闭的时候
[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 1,
        &quot;courseName&quot;: &quot;默认课程&quot;,
        &quot;valid&quot;: 1
    &#125;
]
</code></pre>
<h3 id="整合两个服务"><a href="#整合两个服务" class="headerlink" title="整合两个服务"></a>整合两个服务</h3><pre><code class="java">com/imooc/course/controller/CoursePriceController.java
    @GetMapping(&quot;/coursesAndPrice&quot;)
    public List&lt;CourseAndPrice&gt; getCoursesAndPrice()&#123;
        List&lt;CourseAndPrice&gt; courseAndPrices = coursePriceService.getCourseAndPrice();
        return courseAndPrices;
    &#125;
=====================================================
http://127.0.0.1:8082/coursesAndPrice
[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 362,
        &quot;name&quot;: &quot;SpringCloud自学&quot;,
        &quot;price&quot;: 348
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;courseId&quot;: 409,
        &quot;name&quot;: &quot;玩转Java并发工具&quot;,
        &quot;price&quot;: 399
    &#125;
]
</code></pre>
<pre><code class="java">com/imooc/course/service/CoursePriceService.java
public interface CoursePriceService &#123;

    CoursePrice getCoursePrice(Integer courseId);
    List&lt;CourseAndPrice&gt; getCourseAndPrice();
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/impl/CoursePriceServiceImpl.java
package com.imooc.course.service.impl;

import com.imooc.course.client.CourseListClient;
import com.imooc.course.dao.CoursePriceMapper;
import com.imooc.course.entity.Course;
import com.imooc.course.entity.CourseAndPrice;
import com.imooc.course.entity.CoursePrice;
import com.imooc.course.service.CoursePriceService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

/**
 * 描述：     课程价格的服务实现类
 */
@Service
public class CoursePriceServiceImpl implements CoursePriceService &#123;

    @Autowired
    CoursePriceMapper coursePriceMapper;
    @Autowired
    CourseListClient courseListClient;

    @Override
    public CoursePrice getCoursePrice(Integer courseId) &#123;
        return coursePriceMapper.findCoursePrice(courseId);
    &#125;

    @Override
    public List&lt;CourseAndPrice&gt; getCourseAndPrice() &#123;
        List&lt;CourseAndPrice&gt; courseAndPrices = new ArrayList&lt;&gt;();
        List&lt;Course&gt; courses = courseListClient.courseList();
        for (int i = 0; i &lt; courses.size(); i++) &#123;
            Course course = courses.get(i);
            //inn
            if (course != null) &#123;
                CoursePrice coursePrice = getCoursePrice(course.getCourseId());
                CourseAndPrice courseAndPrice = new CourseAndPrice();
                courseAndPrice.setPrice(coursePrice.getPrice());
                courseAndPrice.setName(course.getCourseName());
                courseAndPrice.setId(coursePrice.getId());
                courseAndPrice.setCourseId(course.getCourseId());
                courseAndPrices.add(courseAndPrice);
            &#125;
        &#125;
        return courseAndPrices;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/entity/CourseAndPrice.java
package com.imooc.course.entity;

/**
 * 课程与价格的融合类
 */
public class CourseAndPrice &#123;
    Integer id;
    Integer courseId;
    String name;
    Integer price;
&#125;
</code></pre>
<h3 id="网关Zuul"><a href="#网关Zuul" class="headerlink" title="网关Zuul"></a>网关Zuul</h3><ul>
<li>为什么<strong>需要</strong>网关</li>
<li>签名校验、登录校验<strong>冗余</strong>问题</li>
<li>Spring Cloud <strong>Zuul</strong> 与 Spring Cloud</li>
<li>API网关允许您将API请求(内部或外部)路由到正确的位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1f9e4c61e576605cf2c814d0d8f069c61bcef0da/data/%E7%BD%91%E5%85%B3Zuul.jpg"></p>
<h3 id="集成Zuul-统一修改访问url地址"><a href="#集成Zuul-统一修改访问url地址" class="headerlink" title="集成Zuul [统一修改访问url地址]"></a>集成Zuul [统一修改访问url地址]</h3><ul>
<li>把自己注册到Eureka这个注册中心</li>
<li>引入依赖</li>
<li>配置路由地址</li>
</ul>
<pre><code class="xml">pom.xml(course-zuul)
     &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">com/imooc/course/ZuulGatewayApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;

/**
 * 网关启动类
 */
@EnableZuulProxy
@SpringCloudApplication
public class ZuulGatewayApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ZuulGatewayApplication.class, args);
    &#125;
&#125;
===============================================================
http://127.0.0.1:9000/imooc/price/coursesInPrice
[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 362,
        &quot;courseName&quot;: &quot;SpringCloud自学&quot;,
        &quot;valid&quot;: 1
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;courseId&quot;: 409,
        &quot;courseName&quot;: &quot;玩转Java并发工具&quot;,
        &quot;valid&quot;: 1
    &#125;
]
</code></pre>
<pre><code class="mysql">application.properties

spring.application.name=course-gateway
server.port=9000
logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;
mybatis.configuration.map-underscore-to-camel-case=true
eureka.client.service-url.defaultZone=http://localhost:8000/eureka/

zuul.prefix=/imooc
zuul.routes.course-list.path=/list/**
zuul.routes.course-list.service-id=course-list
zuul.routes.course-price.path=/price/**
zuul.routes.course-price.service-id=course-price
</code></pre>
<h3 id="利用网关实现过滤器"><a href="#利用网关实现过滤器" class="headerlink" title="利用网关实现过滤器"></a>利用网关实现过滤器</h3><ul>
<li><strong>pre</strong> 过滤器在路由请求之前运行</li>
<li>route 过滤器可以处理请求的实际路由</li>
<li><strong>post</strong> 路由请求后运行过滤器</li>
<li>error 如果在处理请求的过程中发生错误，则过滤器将运行</li>
</ul>
<pre><code class="java">com/imooc/course/filter/PreRequestFilter.java
package com.imooc.course.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;
import org.springframework.stereotype.Component;

/**
 * 记录请求时间
 */
@Component
public class PreRequestFilter extends ZuulFilter &#123;

    @Override
    public String filterType() &#123;
        //过滤器的类型
        return FilterConstants.PRE_TYPE;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 0;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        //是否启用过滤器
        return true;
    &#125;

    @Override
    public Object run() throws ZuulException &#123;
        //通过时间戳 获取上下文
        RequestContext currentContext = RequestContext.getCurrentContext();
        currentContext.set(&quot;startTime&quot;,System.currentTimeMillis());
        System.out.println(&quot;过滤器已经记录时间&quot;);
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/filter/PostRequestFilter.java
package com.imooc.course.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;
import org.springframework.stereotype.Component;

/**
 * 请求处理后的过滤器
 */
@Component //有了才能被spring捕捉到
public class PostRequestFilter extends ZuulFilter &#123;
    @Override
    public String filterType() &#123;
        return FilterConstants.POST_TYPE;
    &#125;

    @Override
    public int filterOrder() &#123; //在其之前-1 先运行
        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        return false;
    &#125;

    @Override
    public Object run() throws ZuulException &#123;
        RequestContext currentContext = RequestContext.getCurrentContext();
        Long startTime = (Long) currentContext.get(&quot;startTime&quot;);
        long duration = System.currentTimeMillis() - startTime;
        String requestURI = currentContext.getRequest().getRequestURI();
        System.out.println(&quot;uri:&quot; + requestURI + &quot;,处理时长：&quot; + duration);
        return null;
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<h3 id="Spring-Cloud电商实践"><a href="#Spring-Cloud电商实践" class="headerlink" title="Spring Cloud电商实践"></a>Spring Cloud电商实践</h3><ul>
<li>服务拆分过程分析和经验分享</li>
<li>完成用户、商品、购物车和订单等服务开发</li>
<li>通用common模块的拆分和应用</li>
<li>Eureka server注册中心开发，用Feign完成服务之间的调用</li>
<li>共享Session的处理方案</li>
<li>统一网关的集成与开发</li>
</ul>
<h3 id="Spring-Cloud电商项目"><a href="#Spring-Cloud电商项目" class="headerlink" title="Spring Cloud电商项目"></a>Spring Cloud电商项目</h3><ul>
<li>项目介绍<ul>
<li>在Spring Boot的基础上升级为<strong>Spring Cloud</strong></li>
<li>从0到1 (Spring Boot)</li>
<li><strong>从1到多</strong>、微服务</li>
</ul>
</li>
<li>模块拆分</li>
<li>Eureka-server开发</li>
<li><strong>用户模块开发</strong></li>
<li><strong>公共模块开发</strong></li>
<li><strong>网关模块开发</strong></li>
<li><strong>商品分类和商品模块开发</strong></li>
<li><strong>购物车和订单模块开发</strong></li>
<li>总结</li>
</ul>
<h3 id="模块拆分"><a href="#模块拆分" class="headerlink" title="模块拆分"></a>模块拆分</h3><ul>
<li><p><strong>粒度</strong>：过粗、适中、过细</p>
</li>
<li><p>人员的角度</p>
</li>
<li><p>业务的角度：相关、独立</p>
</li>
<li><p>Eureka-server模块</p>
</li>
<li><p>网关模块</p>
</li>
<li><p>公共模块 (md5、统一API返回、常量、异常、异常枚举、二维码、工具类模块……)</p>
</li>
<li><p>用户模块 (相对来说比较独立，登录的时候无需获得商品信息)</p>
</li>
<li><p><strong>商品分类和商品模块</strong></p>
</li>
<li><p><strong>购物车和订单模块</strong></p>
</li>
</ul>
<h3 id="功能模块介绍"><a href="#功能模块介绍" class="headerlink" title="功能模块介绍"></a>功能模块介绍</h3><ul>
<li><h4 id="项目功能："><a href="#项目功能：" class="headerlink" title="项目功能："></a>项目功能：</h4><ul>
<li><h5 id="前台-用户、商品分类、商品信息、购物车、订单"><a href="#前台-用户、商品分类、商品信息、购物车、订单" class="headerlink" title="前台  {用户、商品分类、商品信息、购物车、订单}"></a><span style = "color:red">前台  {用户、商品分类、商品信息、购物车、订单}</span></h5><ul>
<li><strong>用户模块</strong>{注册、登录、更新签名、身份认证、登出}</li>
<li><strong>商品分类模块</strong>{多级目录、递归查询、缓存}</li>
<li><strong>商品模块</strong>{商品搜索、商品排序、商品列表、目录展示、商品详情}</li>
<li><strong>购物车模块</strong>{加入商品、列表显示、数量更改、删除商品、勾选反选、全选全不选}</li>
<li><strong>订单模块</strong>{下单、订单流程、订单详情、取消订单、支付二维码、扫码支付、个人订单、确认收货}</li>
</ul>
</li>
<li><h5 id="后台-用户、商品分类、商品信息、订单"><a href="#后台-用户、商品分类、商品信息、订单" class="headerlink" title="后台  {用户、商品分类、商品信息、订单}"></a><span style = "color:red">后台  {用户、商品分类、商品信息、订单}</span></h5><ul>
<li><strong>管理员模块</strong>{登录登出、身份认证、安全限制}</li>
<li><strong>商品分类模块</strong>{分类列表、增加分类、修改分类、删除分类}</li>
<li><strong>商品模块</strong>{商品列表、新增商品、图片上传、更新删除、批量上下架}</li>
<li><strong>订单模块</strong>{订单列表、地址信息、发货、订单完结}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&#96;&#96;</p>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><h5 id="Eureka-server模块开发"><a href="#Eureka-server模块开发" class="headerlink" title="Eureka-server模块开发"></a>Eureka-server模块开发</h5><ul>
<li>引入依赖</li>
<li>配置文件</li>
<li>启动注解</li>
</ul>
<blockquote>
<p>由于是多模块开发，创建了maven项目后把cloud-mall-practice的src删除</p>
</blockquote>
<pre><code class="xml">pom.xml(cloud-mall-practice)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;cloud-mall-practice&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;cloud-mall-eureka-server&lt;/module&gt;
    &lt;/modules&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.12.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Greenwich.SR5&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.7&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;verbose&gt;true&lt;/verbose&gt;
                    &lt;overwrite&gt;true&lt;/overwrite&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">cloud-mall-eureka-server/com/imooc/cloud/mall/practice/eureka/EurekaServerApplication.java
package com.imooc.cloud.mall.practice.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * 1. Eureka Server的启动类，提供服务注册与发现
 * 2写其pom和resources的配置文件
 *
 */
@EnableEurekaServer //对外提供服务
@SpringBootApplication
public class EurekaServerApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaServerApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml(cloud-mall-eureka-server)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;cloud-mall-practice&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;cloud-mall-eureka-server&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;name&gt;
        cloud-mall-eureka-server
    &lt;/name&gt;
    &lt;description&gt;Spring cloud Eureka Server&lt;/description&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties

spring.application.name=eureka-server
server.port=8000
eureka.instance.hostname=localhost
#是否同步其他节点的信息
eureka.client.fetch-registry=false
#是否把自己作为服务注册在服务上
eureka.client.register-with-eureka=false
#eureka-server所在的地址
eureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<h3 id="用户模块知识点"><a href="#用户模块知识点" class="headerlink" title="用户模块知识点"></a>用户模块知识点</h3><blockquote>
<p>登录、注册[加盐md5]、重名校验[注册就不可注册]、密码加密存储、Session的使用、越权校验[不可编辑别人的签名]</p>
</blockquote>
<h5 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h5><ul>
<li>表设计</li>
<li>开发</li>
<li>测试</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_62117675/article/details/127938285">idea中如何将包名折叠或者或如何将折叠的包名展开_idea包名折叠-CSDN博客</a></p>
<h3 id="用户模块初始化"><a href="#用户模块初始化" class="headerlink" title="用户模块初始化"></a>用户模块初始化</h3><h5 id="公共模块"><a href="#公共模块" class="headerlink" title="公共模块"></a>公共模块</h5><ul>
<li>常量、异常、工具类</li>
<li>自身不是Spring Boot项目</li>
</ul>
<h6 id="进行模块各层级的重构-用户模块的测试"><a href="#进行模块各层级的重构-用户模块的测试" class="headerlink" title="进行模块各层级的重构 + 用户模块的测试"></a>进行模块各层级的重构 + 用户模块的测试</h6><pre><code class="mysql">一定要记得如果引用其他muder的时候 要在xml中假如其项目文件的依赖才可以跨项目引用
比如我这个项目是【一定要引用噢！！ 不然在非其项目的时候找不到import导包】
pom.xml(cloud-mall-zuul)
           &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-mall-user&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="网关模块开发"><a href="#网关模块开发" class="headerlink" title="网关模块开发"></a>网关模块开发</h3><pre><code class="xml">pom.xml(cloud-mall-zuul)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;cloud-mall-practice&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;cloud-mall-zuul&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties(cloud-mall-zuul)
server.port=8083

spring.datasource.name=imooc_mall_datasource
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=UTC
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root

mybatis.mapper-locations=classpath*:mappers/*.xml

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;

eureka.client.service-url.defaultZone=http://localhost:8000/eureka/

spring.application.name=cloud-mall-zuul

zuul.prefix=/
#凡是用户模块都要走/user地址
zuul.routes.cloud-mall-user.path=/user/**
#模块的名字
zuul.routes.cloud-mall-user.service-id=cloud-mall-user
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/zuul/filter/UserFilter.java
package com.imooc.cloud.mall.practice.zuul.filter;

import com.imooc.cloud.mall.practice.common.common.Constant;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import com.imooc.cloud.mall.practice.user.model.pojo.User;
import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

/**
 * 用户鉴权过滤器
 */
@Component
public class UserFilter extends ZuulFilter &#123;
    @Override
    public String filterType() &#123;
        return FilterConstants.PRE_TYPE;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 0;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
        String requestURI = request.getRequestURI();
        //不经过过滤器
        if (requestURI.contains(&quot;images&quot;) || requestURI.contains(&quot;pay&quot;)) &#123;
            return false;
        &#125;
        if (requestURI.contains(&quot;cart&quot;) || requestURI.contains(&quot;order&quot;)) &#123;//前置条件必须要登录！
            return true;
        &#125;
        return false;
    &#125;

    @Override
    //用户过滤器
    public Object run() throws ZuulException &#123;//返回true的时候执行的
        RequestContext currentContext = RequestContext.getCurrentContext();//获取request
        //获取session 因为user对象保存在里面  session.getAttribute取出session对象
        HttpServletRequest request = currentContext.getRequest();
        HttpSession session = request.getSession();
        //拿出User对象
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            //无需通过网关再去发送
            currentContext.setSendZuulResponse(false);
            //返回给前端的对象
            currentContext.setResponseBody(&quot;&#123;\n&quot;
                    + &quot;    \&quot;status\&quot;: 10007,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            currentContext.setResponseStatusCode(200);
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/zuul/filter/AdminFilter.java
package com.imooc.cloud.mall.practice.zuul.filter;

import com.imooc.cloud.mall.practice.common.common.Constant;
import com.imooc.cloud.mall.practice.user.model.pojo.User;
import com.imooc.cloud.mall.practice.zuul.feign.UserFeignClient;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

/**
 * 管理员鉴权过滤器
 */
@Component
public class AdminFilter extends ZuulFilter &#123;
    @Autowired
    UserFeignClient userFeignClient;

    @Override
    public String filterType() &#123;
        return FilterConstants.PRE_TYPE;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 0;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
        String requestURI = request.getRequestURI();
        //不经过过滤器
        if (requestURI.contains(&quot;adminLogin&quot;))&#123;
            return false;
        &#125;
        if (requestURI.contains(&quot;admin&quot;))&#123;
            return true;
        &#125;
        if (requestURI.contains(&quot;cart&quot;) || requestURI.contains(&quot;order&quot;)) &#123;//前置条件必须要登录！
            return true;
        &#125;
        return false;
    &#125;

    @Override
    //用户过滤器
    public Object run() throws ZuulException &#123;//返回true的时候执行的
        RequestContext currentContext = RequestContext.getCurrentContext();//获取request
        //获取session 因为user对象保存在里面  session.getAttribute取出session对象
        HttpServletRequest request = currentContext.getRequest();
        HttpSession session = request.getSession();
        //拿出User对象
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            //无需通过网关再去发送
            currentContext.setSendZuulResponse(false);
            //返回给前端的对象
            currentContext.setResponseBody(&quot;&#123;\n&quot;
                    + &quot;    \&quot;status\&quot;: 10010,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            currentContext.setResponseStatusCode(200);
            return null; //程序可以停止了
        &#125;
        //进一步判断是否是管理员
        Boolean adminRole = userFeignClient.checkAdminRole(currentUser);
        if (!adminRole)&#123;
            currentContext.setSendZuulResponse(false);
            //返回给前端的对象
            currentContext.setResponseBody(&quot;&#123;\n&quot;
                    + &quot;    \&quot;status\&quot;: 10011,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_ADMIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            currentContext.setResponseStatusCode(200);
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/zuul/feign/UserFeignClient.java
package com.imooc.cloud.mall.practice.zuul.feign;

import com.imooc.cloud.mall.practice.user.model.pojo.User;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

/**
 * UserFeignClient
 */
@FeignClient(value = &quot;cloud-mall-user&quot;)
public interface UserFeignClient &#123;
    @PostMapping(&quot;/checkAdminRole&quot;)
    public Boolean checkAdminRole(@RequestBody User user);
&#125;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/zuul/ZuulGatewayApplication.java
网关模块加上SpringBoot启动类

package com.imooc.cloud.mall.practice.zuul;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.cloud.openfeign.EnableFeignClients;

/**
 * 网关启动类
 */
@EnableZuulProxy
@EnableFeignClients
@SpringBootApplication
public class ZuulGatewayApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ZuulGatewayApplication.class, args);
    &#125;
&#125;
=================================================================
127.0.0.1:8083/user/login?userName=mumu9&amp;password=lihao123
&#123;
    &quot;status&quot;: 10000,
    &quot;msg&quot;: &quot;SUCCESS&quot;,
    &quot;data&quot;: &#123;
        &quot;id&quot;: 21,
        &quot;username&quot;: &quot;mumu9&quot;,
        &quot;password&quot;: null,
        &quot;personalizedSignature&quot;: &quot;乘风破浪的姐姐&quot;,
        &quot;role&quot;: 2,
        &quot;createTime&quot;: &quot;2024-04-17T18:08:15.000+0000&quot;,
        &quot;updateTime&quot;: &quot;2024-04-17T18:10:49.000+0000&quot;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>POSTMAN中cloud-mall-practice的注册新用户、用户登录、管理员登录、登出模块都通过网关共用地址的调用，但是更新个性签名不可以，提示需要登录，因为更新签名需要提前登录。但是问题的最主要的点就是没有拿到session所以并没有把用户信息传到个性签名中 这是就需要Session共享机制</p>
</blockquote>
<h3 id="Session共享机制"><a href="#Session共享机制" class="headerlink" title="Session共享机制"></a>Session共享机制</h3><h5 id="登录功能分析"><a href="#登录功能分析" class="headerlink" title="登录功能分析"></a>登录功能分析</h5><ul>
<li>登录状态需要保持</li>
<li>session的实现方案：登陆后，会保存用户信息到session</li>
<li>之后的访问，先从session中获取用户信息，然后再执行业务逻辑</li>
</ul>
<h6 id="目前遇到的障碍-记得去电脑端启动Redis"><a href="#目前遇到的障碍-记得去电脑端启动Redis" class="headerlink" title="目前遇到的障碍 [记得去电脑端启动Redis]"></a>目前遇到的障碍 [记得去电脑端启动Redis]</h6><ul>
<li>session被网关过滤</li>
<li><strong>共享session</strong> [现在是多模块项目 其他项目保存了session 另一个项目无法获得]</li>
<li><strong><span style ="color:red">EnableRedisHttpSession</span></strong>[需要通过中介Redis去调取]</li>
</ul>
<pre><code class="java">在cloud-mall-user/application.properties中
server.port=8081

spring.datasource.name=imooc_mall_datasource
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=UTC
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root

mybatis.mapper-locations=classpath*:mappers/*.xml

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;

eureka.client.service-url.defaultZone=http://localhost:8000/eureka/

spring.application.name=cloud-mall-user

spring.session.store-type=redis
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
</code></pre>
<pre><code class="java">在cloud-mall-zuul/application.properties中
server.port=8083

spring.datasource.name=imooc_mall_datasource
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=UTC
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root

mybatis.mapper-locations=classpath*:mappers/*.xml

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;

eureka.client.service-url.defaultZone=http://localhost:8000/eureka/

spring.application.name=cloud-mall-zuul

spring.session.store-type=redis
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=

#没有敏感的需要过滤
zuul.sensitive-headers=
zuul.host.connect-timeout-millis=15000
zuul.prefix=/
#凡是用户模块都要走/user地址
zuul.routes.cloud-mall-user.path=/user/**
#模块的名字
zuul.routes.cloud-mall-user.service-id=cloud-mall-user
</code></pre>
<pre><code class="java">之后在UserApplication和ZuulGatewayApplication前面加上@EnableRedisHttpSession

com/imooc/cloud/mall/practice/user/UserApplication.java
package com.imooc.cloud.mall.practice.user;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

/**
 * 启动类
 */
@SpringBootApplication
@EnableSwagger2
@MapperScan(basePackages = &quot;com.imooc.cloud.mall.practice.user.model.dao&quot;)
@EnableRedisHttpSession
public class UserApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(UserApplication.class, args);
    &#125;
&#125;

-------------------------------------------------------------------------------------

com/imooc/cloud/mall/practice/zuul/ZuulGatewayApplication.java
package com.imooc.cloud.mall.practice.zuul;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

/**
 * 网关启动类
 */
@EnableZuulProxy
@EnableFeignClients
@SpringBootApplication
@EnableRedisHttpSession
public class ZuulGatewayApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ZuulGatewayApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="商品分类与商品模块初始化"><a href="#商品分类与商品模块初始化" class="headerlink" title="商品分类与商品模块初始化"></a>商品分类与商品模块初始化</h3><h5 id="什么是商品分类"><a href="#什么是商品分类" class="headerlink" title="什么是商品分类"></a>什么是商品分类</h5><ul>
<li>条理清楚，层次分明</li>
<li>方便用户进行筛选和辨别</li>
<li>可以通过分类的设置快速的进入对应的商品列表页面进行商品选择</li>
</ul>
<h5 id="分类层级"><a href="#分类层级" class="headerlink" title="分类层级"></a>分类层级</h5><ul>
<li>在商品分类上需要继续做归类操作</li>
<li>分类设置成三级</li>
<li>层级太深的弊端：<ul>
<li>一是对用户不太友好，不利于寻找</li>
<li>二是对于后台管理人员不友好，不方便管理</li>
</ul>
</li>
</ul>
<blockquote>
<p>[cloud-mall-category-product]创造出来，将controller,model(dao,pojo),service,impi 里转入 Category来搞 因为在网关项目里写了关于管理员校验的方法 所以在此次处CategoryController把session里的校验删除</p>
</blockquote>
<pre><code class="xml">要让商品和商品目录用到User类 一定要去pom文件里添加依赖 不然idea找不到
pom.xml(cloud-mall-category-product)
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-mall-user&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/categoryproduct/config/CachingConfig.java
创建处理缓存的配置类 configpackage com.imooc.cloud.mall.practice.categoryproduct.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.RedisConnectionFactory;

import java.time.Duration;

*/**
* ** 57.缓存的配置类 想要运行成功保存序列化 要去弄个序列化接口
*   CategoryVO implements Serializable
* **/
*@Configuration
@EnableCaching
public class  CachingConfig &#123;
    @Bean
    public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory) &#123;

        RedisCacheWriter redisCacheWriter = RedisCacheWriter
                .lockingRedisCacheWriter(connectionFactory);
        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
        cacheConfiguration = cacheConfiguration.entryTtl(Duration.ofSeconds(30));

        RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter,
                cacheConfiguration);
        return redisCacheManager;
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">在网关中增加path和service-id
zuul.routes.cloud-mall-user.path=/user/**
zuul.routes.cloud-mall-user.service-id=cloud-mall-user

zuul.routes.cloud-mall-category-product.path=/category-product/**
zuul.routes.cloud-mall-category-product.service-id=cloud-mall-category-product
</code></pre>
<pre><code class="java">查端口  =&gt; netstat -ano | findstr :8083 [pid为7812]
杀死端口PID =&gt; taskkill /PID 7812 /f
</code></pre>
<h3 id="商品模块"><a href="#商品模块" class="headerlink" title="商品模块"></a>商品模块</h3><h5 id="更新和新增商品"><a href="#更新和新增商品" class="headerlink" title="更新和新增商品"></a>更新和新增商品</h5><ul>
<li>合并写法不可取</li>
<li>业务逻辑清晰、独立</li>
</ul>
<h5 id="批量上下架"><a href="#批量上下架" class="headerlink" title="批量上下架"></a>批量上下架</h5><ul>
<li>MyBatis遍历List</li>
<li>where语句拼接</li>
</ul>
<h5 id="商品列表：搜索功能"><a href="#商品列表：搜索功能" class="headerlink" title="商品列表：搜索功能"></a>商品列表：搜索功能</h5><h6 id="入参判空-→-加-通配符-→-like关键字"><a href="#入参判空-→-加-通配符-→-like关键字" class="headerlink" title="入参判空 → 加%通配符 → like关键字"></a>入参判空 → 加%通配符 → like关键字</h6><h5 id="对于查询目录的in处理"><a href="#对于查询目录的in处理" class="headerlink" title="对于查询目录的in处理"></a>对于查询目录的in处理</h5><ul>
<li>目录处理：如果查某个目录下的商品，不仅是需要查出来该目录的，还需要查出来子目录的所有商品</li>
<li>这里要拿到某一个目录Id下的所有子目录id的List</li>
</ul>
<h3 id="前台：商品列表"><a href="#前台：商品列表" class="headerlink" title="前台：商品列表"></a>前台：商品列表</h3><ul>
<li>排序功能</li>
<li>Mybatis PageHelper</li>
<li>枚举：order by</li>
</ul>
<pre><code class="java">把所有product的java都移动过去 controller/service/impl/modal.dao/modal.pojo/query.ProductListQuery/request.AddProductReq、ProductListReq、UpdateProductReq/resourcs.mappers.ProductMapper.xml
</code></pre>
<pre><code class="java">将Constant里的@Value(&quot;$&#123;file.upload.dir&#125;&quot;)的文件上传目录重构到category-product项目中
然后在其项目中的resources的application.properties中写一下路径
</code></pre>
<pre><code class="java">文件地址映射：config/imoocMallWebMvcConfig
</code></pre>
<h3 id="图片端口的特殊处理"><a href="#图片端口的特殊处理" class="headerlink" title="图片端口的特殊处理"></a>图片端口的特殊处理</h3><pre><code class="java">application.properties(cloud-mall-category-product)
file.upload.dir=/Users/Pluminary/Desktop/idea_Space/imooc-mall-prepare-static/

不能再通过获取getHost来配置了 根据实际情况去配置 没有办法获取到网关对外暴露的真正端口号
 private URI getHost(URI uri)&#123;
        URI effectiveURI;
        try &#123;
            effectiveURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(),null,null,null);
        &#125; catch (URISyntaxException e) &#123;
            effectiveURI = null; //如果新建失败 就返回回去
        &#125;
        return effectiveURI;
    &#125;

要改为com/imooc/cloud/mall/practice/categoryproduct/controller/ProductAdminController.java
/**
 * 58.后台商品管理Controller  pojo的product复制一份到request变成AddProductReq  59.需要ProductService.java
 */
@RestController
public class ProductAdminController &#123;

    @Autowired
    ProductService productService;

    @Value(&quot;$&#123;file.upload.ip&#125;&quot;)
    String ip;

    @Value(&quot;$&#123;file.upload.port&#125;&quot;)
    Integer port;

    @PostMapping(&quot;/admin/product/add&quot;)
    public ApiRestResponse addProduct(@Valid @RequestBody AddProductReq addProductReq) &#123;
        productService.add(addProductReq);
        return ApiRestResponse.success();
    &#125;

    @PostMapping(&quot;/admin/upload/file&quot;)
    public ApiRestResponse upload(HttpServletRequest httpServletRequest,
                                  @RequestParam(&quot;file&quot;) MultipartFile file) &#123;
        String fileName = file.getOriginalFilename();
        String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));
        //生成文件名称UUID
        UUID uuid = UUID.randomUUID();
        String newFileName = uuid.toString() + suffixName;
        //创建文件
        File fileDirectory = new File(ProductConstant.FILE_UPLOAD_DIR);
        File destFile = new File(ProductConstant.FILE_UPLOAD_DIR + newFileName);
        if (!fileDirectory.exists()) &#123;
            if (!fileDirectory.mkdir()) &#123;
                throw new ImoocMallException(ImoocMallExceptionEnum.MKDIR_FAILED);
            &#125;
        &#125;
        try &#123;
            file.transferTo(destFile);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            return ApiRestResponse
                    .success(getHost(new URI(httpServletRequest.getRequestURL() + &quot;&quot;)) + &quot;/category-product/images/&quot;
                            + newFileName);
        &#125; catch (URISyntaxException e) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.UPLOAD_FAILED);
        &#125;
    &#125;

    private URI getHost(URI uri) &#123;
        URI effectiveURI;
        try &#123;
            effectiveURI = new URI(uri.getScheme(), uri.getUserInfo(), ip, port,
                    null, null, null);
        &#125; catch (URISyntaxException e) &#123;
            effectiveURI = null;
        &#125;
        return effectiveURI;
    &#125;
</code></pre>
<h3 id="阶段性重难点和常见错误"><a href="#阶段性重难点和常见错误" class="headerlink" title="阶段性重难点和常见错误"></a>阶段性重难点和常见错误</h3><h5 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h5><ul>
<li>重难点：模块拆分设计、公共模块、<strong>Zuul(网关)过滤器</strong>、Session处理、Feign调用<br>Session在微服务的情况下就不容易处理到了可以共享Session，把其放<u>在Redis中实现</u>共享<br>Feign模块之间的接口调用[HTTP是手动调用]</li>
<li>常见错误：模块粒度不合适、无公共模块、各接口独立校验、session无法共享、HTTP手动调用</li>
</ul>
<h5 id="模块拆分-1"><a href="#模块拆分-1" class="headerlink" title="模块拆分"></a>模块拆分</h5><ul>
<li><strong>粒度</strong>：过粗、适中、过细</li>
<li>人员的角度</li>
<li>业务的角度：相关、独立</li>
</ul>
<h3 id="购物车与订单模块"><a href="#购物车与订单模块" class="headerlink" title="购物车与订单模块"></a>购物车与订单模块</h3><h5 id="购物车模块"><a href="#购物车模块" class="headerlink" title="购物车模块"></a>购物车模块</h5><ul>
<li><p>添加商品到购物车 → 商品是否在售、是否有库存 </p>
<ul>
<li><p>→[否] 提示用户</p>
</li>
<li><p>→[是] 该商品之前就在购物车里</p>
<ul>
<li>→[否] 添加新商品</li>
<li>→[是] 原有基础上添加数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">创建一个module 加入关于cart的controller/model.dao.pojo.vo/service.impl
其中ProductMapper productMapper会爆红是理所应当的 这样证明耦合不是很严重
利用远程调用Feign进行调用
思路：通过调查发现productMapper只用于挑选ID
Product product = productMapper.selectByPrimaryKey(productId);
所以可以去重构一下代码 回到商品模块的地方cloud-mall-category-product
其中controller中的ProductController
//com/imooc/cloud/mall/practice/categoryproduct/controller/ProductController.java
//这个是服务与服务之间的内部调用 不需要层层包装 只需要返回就好
    @GetMapping(&quot;product/detailForFeign&quot;)
    public Product detailForFeign(@RequestParam Integer id)&#123;
       Product product = productService.detail(id);
       return product;
    &#125;
//千万不要直接引用另一个项目的mapper 因为耦合有点严重 只要对面发生变化 就完蛋了
//com/imooc/cloud/mall/practice/cartorder/feign/ProductFeignClient.java
package com.imooc.cloud.mall.practice.cartorder.feign;

import com.imooc.cloud.mall.practice.categoryproduct.model.pojo.Product;
import org.springframework.web.bind.annotation.RequestParam;

public interface ProductFeignClient &#123;
    Product detailForFeign(@RequestParam Integer id);
&#125;
</code></pre>
<h3 id="用户模块提供获取当前用户接口"><a href="#用户模块提供获取当前用户接口" class="headerlink" title="用户模块提供获取当前用户接口"></a>用户模块提供获取当前用户接口</h3><pre><code class="java">com/imooc/cloud/mall/practice/user/controller/UserController.java
 @GetMapping(&quot;/getUser&quot;)
    @ResponseBody
    public User getUser(HttpSession session)&#123;
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        return currentUser;
    &#125; /**
     * 获取当前登录的User对象 为了避免暴露用户信息，可以再filter中对getUser进行拦截
     * @param session
     * @return
     */
    @GetMapping(&quot;/getUser&quot;)
    @ResponseBody
    public User getUser(HttpSession session)&#123;
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        return currentUser;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/cartorder/feign/UserFeignClient.java
package com.imooc.cloud.mall.practice.cartorder.feign;

import com.imooc.cloud.mall.practice.user.model.pojo.User;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

/**
 * UserFeign客户端
 */
@FeignClient(value = &quot;cloud-mall-user&quot;)
public interface UserFeignClient &#123;
    /**
     * 获取当前登录的user对象
     */
    @GetMapping(&quot;/getUser&quot;)
    User getUser();
&#125;
修改CaetMapper.xml的路径名
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/cartorder/feign/ProductFeignClient.java
package com.imooc.cloud.mall.practice.cartorder.feign;

import com.imooc.cloud.mall.practice.cartorder.pojo.Product;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
/**
 * 描述：     商品FeignClient
 */
@FeignClient(value = &quot;cloud-mall-category-product&quot;)
public interface ProductFeignClient &#123;
    //不经过网关 只是内部调用
    @GetMapping(&quot;product/detailForFeign&quot;)
    Product detailForFeign(@RequestParam Integer id);

    @PostMapping(&quot;product/updateStock&quot;)
    void updateStock(@RequestParam Integer productId, @RequestParam Integer stock);

&#125;
</code></pre>
<pre><code class="java">将新增模块加入到网关[前缀地址] zuul
zuul.routes.cloud-mall-user.path=/user/**
zuul.routes.cloud-mall-user.service-id=cloud-mall-user
zuul.routes.cloud-mall-category-product.path=/category-product/**
zuul.routes.cloud-mall-category-product.service-id=cloud-mall-category-product
zuul.routes.cloud-mall-cart-order.path=/cart-order/**
zuul.routes.cloud-mall-cart-order.service-id=cloud-mall-cart-order
</code></pre>
<h3 id="让Feign携带Session信息"><a href="#让Feign携带Session信息" class="headerlink" title="让Feign携带Session信息"></a>让Feign携带Session信息</h3><blockquote>
<p>错误新消息：500 Internal Server Error<br>在购物车中去调用User的getUser方法 是经过Feign<br>但是Feign的调用不经过网关 它是一个HTTP的调用<br>需要携带网关的Session信息</p>
</blockquote>
<ul>
<li><strong>FeignRequestInterceptor</strong> [对每一个发出的Feign进行拦截]<br>把网关的所有信息都复制到Feign的请求上 就不会遗漏相关信息</li>
</ul>
<pre><code class="java">com/imooc/cloud/mall/practice/cartorder/filter/FeignRequestInterceptor.java
package com.imooc.cloud.mall.practice.cartorder.filter;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import java.util.Enumeration;
import javax.servlet.http.HttpServletRequest;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

/**
 * 描述：     Feign请求拦截器
 */
@EnableFeignClients
@Configuration
public class FeignRequestInterceptor implements RequestInterceptor &#123;

    @Override
    public void apply(RequestTemplate requestTemplate) &#123;
        //通过RequestContextHolder获取到请求 拿到requestAttributes
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        if (requestAttributes == null) &#123;
            return;
        &#125;//类型转换 拿到Request
        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
        Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); //拿到所有Header名字
        if (headerNames != null) &#123;
            while (headerNames.hasMoreElements()) &#123; //如果还有新的元素 先获取
                String name = headerNames.nextElement(); //获取相关的值
                Enumeration&lt;String&gt; values = request.getHeaders(name);
                while (values.hasMoreElements()) &#123;//获取到当前元素
                    String value = values.nextElement();
                    requestTemplate.header(name, value);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="订单模块"><a href="#订单模块" class="headerlink" title="订单模块"></a>订单模块</h3><ul>
<li><h5 id="表设计和接口设计"><a href="#表设计和接口设计" class="headerlink" title="表设计和接口设计"></a>表设计和接口设计</h5></li>
</ul>
<pre><code class="java">&quot;订单编号的名字也要改 不能是以前的自增id 要变成order_no&quot;
order_no是每一种商品的id
否则黑客早上下一单 晚上下一单 相减 就可以估计客流量 
分成了很详细的字段名
product_id/name/img 都是之前购买过的订单产生的数据
</code></pre>
<h3 id="生成订单–用户下单"><a href="#生成订单–用户下单" class="headerlink" title="生成订单–用户下单"></a>生成订单–用户下单</h3><ul>
<li>入参</li>
<li>从购物车中查询已经勾选的商品</li>
<li>判断商品是否正在售卖中</li>
<li>判断库存，保证不超卖</li>
<li>调用商品服务扣库存 [及时更新库存]</li>
<li>删除购物车为中对应的商品</li>
<li>生成订单</li>
<li>订单号生成规则</li>
<li>循环保存每一个商品到order_item表</li>
</ul>
<h3 id="图片路径配置"><a href="#图片路径配置" class="headerlink" title="图片路径配置"></a>图片路径配置</h3><pre><code class="java">com/imooc/cloud/mall/practice/cartorder/config/ImoocMallWebMvcConfig.java
package com.imooc.cloud.mall.practice.cartorder.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 描述：     地址映射配置
 */
@Configuration
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;

    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    String FILE_UPLOAD_DIR;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + FILE_UPLOAD_DIR);
    &#125;

</code></pre>
<h3 id="购物车和订单模块-重难点"><a href="#购物车和订单模块-重难点" class="headerlink" title="购物车和订单模块-重难点"></a>购物车和订单模块-重难点</h3><ul>
<li>订单表[多个关联(订单编号+状态)]、订单状态设计</li>
<li>购物车流程</li>
<li>下单流程</li>
<li>Feign调用的处理</li>
</ul>
<h5 id="购物车和订单模块-常见错误"><a href="#购物车和订单模块-常见错误" class="headerlink" title="购物车和订单模块-常见错误"></a>购物车和订单模块-常见错误</h5><ul>
<li>Feign调用取不到User对象</li>
<li>URL错误拦截(图片url可以不拦截[订单+购物车])</li>
<li>路由配置错误(二维码&#x2F;图片不显示)</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/04/11/后端/SpringCloud基础-电商实战/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/04/04/后端/多线程与分布式/">
        <h2>
            多线程与分布式
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/4
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="多线程与分布式-周介绍"><a href="#多线程与分布式-周介绍" class="headerlink" title="多线程与分布式 [周介绍]"></a>多线程与分布式 [周介绍]</h1><ul>
<li><h6 id="线程池的基本使用、特点、注意点"><a href="#线程池的基本使用、特点、注意点" class="headerlink" title="线程池的基本使用、特点、注意点"></a>线程池的基本使用、特点、注意点</h6></li>
<li><h6 id="ThreadLoacal的基本使用、原理和注意事项"><a href="#ThreadLoacal的基本使用、原理和注意事项" class="headerlink" title="ThreadLoacal的基本使用、原理和注意事项"></a>ThreadLoacal的基本使用、原理和注意事项</h6></li>
<li><h6 id="分布式基础、核心概念"><a href="#分布式基础、核心概念" class="headerlink" title="分布式基础、核心概念"></a>分布式基础、核心概念</h6></li>
<li><h6 id="docker的下载、安装和基本命令"><a href="#docker的下载、安装和基本命令" class="headerlink" title="docker的下载、安装和基本命令"></a>docker的下载、安装和基本命令</h6></li>
<li><h6 id="独立制作docker容器"><a href="#独立制作docker容器" class="headerlink" title="独立制作docker容器"></a>独立制作docker容器</h6></li>
<li><h6 id="Nginx的安装、基本使用和使用命令"><a href="#Nginx的安装、基本使用和使用命令" class="headerlink" title="Nginx的安装、基本使用和使用命令"></a>Nginx的安装、基本使用和使用命令</h6></li>
<li><h6 id="使用Nginx搭建文件服务"><a href="#使用Nginx搭建文件服务" class="headerlink" title="使用Nginx搭建文件服务"></a>使用Nginx搭建文件服务</h6></li>
<li><h6 id="消息队列RabbitMQ的核心概念queue、message和exchange"><a href="#消息队列RabbitMQ的核心概念queue、message和exchange" class="headerlink" title="消息队列RabbitMQ的核心概念queue、message和exchange"></a>消息队列RabbitMQ的核心概念queue、message和exchange</h6></li>
<li><h6 id="RabbitMQ的四种交换机模式"><a href="#RabbitMQ的四种交换机模式" class="headerlink" title="RabbitMQ的四种交换机模式"></a>RabbitMQ的四种交换机模式</h6></li>
<li><h6 id="SpringBoot整合RabbitMQ案例"><a href="#SpringBoot整合RabbitMQ案例" class="headerlink" title="SpringBoot整合RabbitMQ案例"></a>SpringBoot整合RabbitMQ案例</h6></li>
</ul>
<h2 id="线程池-——-治理线程的法宝"><a href="#线程池-——-治理线程的法宝" class="headerlink" title="线程池 —— 治理线程的法宝"></a>线程池 —— 治理线程的法宝</h2><ul>
<li>线程池的<strong>自我介绍</strong></li>
<li><strong>创建</strong>和停止线程池</li>
<li><strong>常见线程池</strong>的特点和用法</li>
<li>任务太多，怎么<strong>拒绝</strong></li>
<li>钩子方法，给线程池加点料</li>
<li>实现<strong>原理、源码分析</strong></li>
<li>使用线程池的注意点</li>
</ul>
<h5 id="线程池的自我介绍"><a href="#线程池的自我介绍" class="headerlink" title="线程池的自我介绍"></a>线程池的自我介绍</h5><ul>
<li>线程池的重要性 [可以复用我们的线程]</li>
<li>什么是”池” – 软件中的”池”，可以理解为计划经济</li>
<li>如果不适用线程池，每个任务都新开一个线程处理<ul>
<li>一个线程</li>
<li>for循环创建线程</li>
<li>当任务数量上升到1000<br><code>这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题</code>[多了会报错 内存不足异常]</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/ForLoop.java
package threadpool;
/**
 * 描述：     TODO
 */
public class ForLoop &#123;

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            Thread thread = new Thread(new Task());
            thread.start();
        &#125;
    &#125;

    static class Task implements Runnable &#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;执行了任务&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h5><ul>
<li>问题一：反复创建线程开销大</li>
<li>问题二：过多的线程会占用太多内存</li>
<li>解决以上两个问题的思路<ul>
<li>用少量的线程——避免内存占用过多</li>
<li>让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗</li>
</ul>
</li>
</ul>
<h5 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h5><ul>
<li>加快响应速度</li>
<li>合理利用CPU和内存</li>
<li>统一管理</li>
</ul>
<h5 id="线程池使用应用的场合"><a href="#线程池使用应用的场合" class="headerlink" title="线程池使用应用的场合"></a>线程池使用应用的场合</h5><ul>
<li>服务器(Tomcat)接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少现成的创建和销毁次数，提高服务器的工作效率</li>
<li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li>
</ul>
<h3 id="线程增减的时机"><a href="#线程增减的时机" class="headerlink" title="线程增减的时机"></a>线程增减的时机</h3><h5 id="创建和停止线程池"><a href="#创建和停止线程池" class="headerlink" title="创建和停止线程池"></a>创建和停止线程池</h5><ul>
<li>线程池<strong>构造方法的参数</strong></li>
<li>线程池应该<strong>手动创建</strong>还是自动创建</li>
<li>线程池里的<strong>线程数量</strong>设定为多少比较合适</li>
<li><strong>停止</strong>线程池的方法</li>
</ul>
<h5 id="线程池构造方法的参数"><a href="#线程池构造方法的参数" class="headerlink" title="线程池构造方法的参数"></a>线程池构造方法的参数</h5><table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>int</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>保持存活时间</td>
</tr>
<tr>
<td>workQueue</td>
<td>BlockingQueue</td>
<td>任务存储队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>当线程池需要新的线程的时候，会使用threadFactory来生成新的线程</td>
</tr>
<tr>
<td>Handler</td>
<td>RejectedExecutionHandler</td>
<td>由于线程池无法接收你所提交的任务的拒绝策略</td>
</tr>
</tbody></table>
<h5 id="参数中的corePoolSize和maxPoolSize"><a href="#参数中的corePoolSize和maxPoolSize" class="headerlink" title="参数中的corePoolSize和maxPoolSize"></a>参数中的corePoolSize和maxPoolSize</h5><ul>
<li><p><strong>corePoolSize</strong>指的是核心线程数<br>线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新的线程去执行任务</p>
</li>
<li><p>最大量<strong>maxPoolSize</strong><br>在核心线程数的基础上，格外增加的线程数的上限</p>
</li>
</ul>
<h5 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h5><ol>
<li>如果线程数小于corePoolSize，创建一个新线程来运行新任务</li>
<li>如果线程数等于(或大于) corePoolSize但少于maximumPoolSize，则将任务放入<strong>队列</strong></li>
<li>如果队列已满，并且线程数小于maxPoolSize，则创建一个<strong>新线程</strong></li>
<li>如果队列已满，并且线程数大于或等于maxPoolSize，则<strong>拒绝</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4cb2755066dc76e6602ff1110cfc24124f38b42f/data/%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png"></p>
<ul>
<li>是否需要增加线程的判断顺序是：<ul>
<li>corePoolSize</li>
<li>workQueue</li>
<li>maxPoolSize</li>
</ul>
</li>
</ul>
<h6 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h6><ul>
<li>线程池：核心池大小为5，最大池大小为10，队列为100</li>
<li>因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程maxPoolSize，最多到10个线程，如果再来任务，就拒绝</li>
</ul>
<h5 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h5><ul>
<li>通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池</li>
<li>线程池<strong>希望保持较小的线程数</strong>，并且只有在负载变得很大时才增加它</li>
<li>通过设置maximumPoolSize为很高的值，可以允许线程池容纳任意数量的并发任务</li>
<li>只有在队列填满时才创建多于corePoolSize的线程，如果使用的是无界队列，那么线程数就不会超过corePoolSize</li>
</ul>
<h3 id="线程存活时间和工作队列"><a href="#线程存活时间和工作队列" class="headerlink" title="线程存活时间和工作队列"></a>线程存活时间和工作队列</h3><h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><ul>
<li>如果线程池当前的线程多余corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，它们就会被终止</li>
</ul>
<h5 id="ThreadFactory-用来创建线程"><a href="#ThreadFactory-用来创建线程" class="headerlink" title="ThreadFactory 用来创建线程"></a>ThreadFactory 用来创建线程</h5><ul>
<li>默认使用Executors.defaultThreadFactory()</li>
<li>创建出来的线程都在同一个线程组</li>
<li>如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等</li>
</ul>
<h5 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h5><ul>
<li>有三种最常见的队列类型<ul>
<li>直接交接：SynchronousQueue</li>
<li>无界队列：LinkedBlockingQueue</li>
<li>有界队列：ArrayBlockingQueue</li>
</ul>
</li>
</ul>
<h3 id="自动创建线程池的风险"><a href="#自动创建线程池的风险" class="headerlink" title="自动创建线程池的风险"></a>自动创建线程池的风险</h3><h5 id="线程池应该手动创建还是自动创建"><a href="#线程池应该手动创建还是自动创建" class="headerlink" title="线程池应该手动创建还是自动创建"></a>线程池应该手动创建还是自动创建</h5><ul>
<li>手动创建更好，因为这样可以更加明确线程池的运行规则，避免资源耗尽的风险<br>自动创建线程池(即直接调用JDK封装好的构造方法) 可能会带来哪些问题？</li>
<li><strong>newFixedThreadPool</strong><ul>
<li>容易造成大量内存占用，可能会导致OOM</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/FixedThreadPoolThread.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class FixedThreadPoolThread &#123;
    public static void main(String[] args) &#123; //核心线程数量
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
class Task implements Runnable&#123;

    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
        System.out.println(Thread.currentThread().getName());
    &#125;
&#125;
=======================================================================
pool-1-thread-3
pool-1-thread-4
pool-1-thread-1
pool-1-thread-2
    
pool-1-thread-3
pool-1-thread-1
pool-1-thread-4
pool-1-thread-2
因为核心线程数量只规定了4个 这有这四个线程跑程序
</code></pre>
<pre><code class="java">threadpool/FixedThreadPoolOOM.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示nexFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM &#123;
    private static ExecutorService executorService = Executors.newFixedThreadPool(1);

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; Integer.MAX_VALUE; i++)&#123;
            executorService.execute(new SubThread());
        &#125;
    &#125;
&#125;
class SubThread implements Runnable&#123;

    @Override
    public void run() &#123;
        try&#123;//一直睡觉 不让它结束
            Thread.sleep(1000000000);
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
=======================================================================
报错：java.lang.OutOfMemoryError:GC overhead limilt exceeded
</code></pre>
<ul>
<li><strong>newSingleThreadExecutor</strong> [单独的线程]<ul>
<li>当请求堆积的时候，可能会占用大量的内存</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/SingleThreadExecutor.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SingleThreadExecutor &#123;
    public static void main(String[] args) &#123;
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
=======================================================================
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
</code></pre>
<ul>
<li><strong>CachedThreadPool</strong> [可缓存线程池]<ul>
<li>特点：具有自动回收多余线程的功能</li>
<li>弊端在于第二个参数maximumPoolSize被设置为了Integer.MAX_VALUE, 这可能会创建数量非常多的线程，甚至导致OOM</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/CachedThreadPool.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CachedThreadPool &#123;
    public static void main(String[] args) &#123;
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>newScheduledThreadPool</strong> [跟时间相关的]</li>
</ul>
<pre><code class="java">threadpool/ScheduledThreadPool.java
package threadpool;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledThreadPool &#123;
    public static void main(String[] args) &#123;
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
        threadPool.schedule(new Task(), 5, TimeUnit.SECONDS);
        threadPool.scheduleAtFixedRate(new Task(), 1, 3, TimeUnit.SECONDS);//每隔3s运行
    &#125;
&#125;
</code></pre>
<ul>
<li>正确的创建线程池的方法<ul>
<li><strong>根据不同的业务场景</strong>，设置线程池参数</li>
<li>比如：内存有多大，给线程取什么名字等等</li>
</ul>
</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="线程池里的线程数量设定为多少比较合适？"><a href="#线程池里的线程数量设定为多少比较合适？" class="headerlink" title="线程池里的线程数量设定为多少比较合适？"></a>线程池里的线程数量设定为多少比较合适？</h3><ul>
<li><strong>CPU密集型</strong>(加密、计算hash等)：最佳线程数为CPU核心数的1-2倍左右</li>
<li><strong>耗时IO型</strong>(读写数据库、文件、网络读写等)：最佳线程数一般会大于CPU核心数很多倍<br>参考Brain Goetz推荐的计算方法：<br><span style = "color:red"><strong>线程数 &#x3D; CPU核心数 × (1 + 平均等待时间 &#x2F; 平均工作时间)</strong></span></li>
</ul>
<h3 id="对比各种线程池的特点"><a href="#对比各种线程池的特点" class="headerlink" title="对比各种线程池的特点"></a>对比各种线程池的特点</h3><h5 id="常见的线程池的特点"><a href="#常见的线程池的特点" class="headerlink" title="常见的线程池的特点"></a>常见的线程池的特点</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/ee67f47de97062e593b16348ff148cd52f7b7d6e/data/%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg"></p>
<h5 id="以上4种线程池的构造方法的参数"><a href="#以上4种线程池的构造方法的参数" class="headerlink" title="以上4种线程池的构造方法的参数"></a>以上4种线程池的构造方法的参数</h5><table>
<thead>
<tr>
<th>Parameter</th>
<th>FixedThreadPool</th>
<th>CachedThreadPool</th>
<th>ScheduledThreadPool</th>
<th>SingleThreaded</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>constructor-arg</td>
<td>0</td>
<td>constructor-arg</td>
<td>1</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>same as corePoolSize</td>
<td>Integer.MAX_VALUE</td>
<td>Integer.MAX_VALUE</td>
<td>1</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>0 seconds</td>
<td>60 seconds</td>
<td>0 seconds</td>
<td>0 seconds</td>
</tr>
</tbody></table>
<h3 id="阻塞队列分析"><a href="#阻塞队列分析" class="headerlink" title="阻塞队列分析"></a>阻塞队列分析</h3><ul>
<li>FixedThreadPool和SingleThreadExecutor的Queue是<strong>LinedBlockingQueue</strong>？</li>
<li>CachedThreadPool使用的是Queue是<strong>SynchronousQueue</strong>？</li>
<li>ScheduledThreadPool使用延迟队列DelayedWorkQueue</li>
</ul>
<h5 id="workStealingPool是JDK1-8加入的"><a href="#workStealingPool是JDK1-8加入的" class="headerlink" title="workStealingPool是JDK1.8加入的"></a>workStealingPool是JDK1.8加入的</h5><ul>
<li>这个线程池和之前的都有很大不同</li>
<li>子任务</li>
<li>窃取 [并行执行]</li>
</ul>
<h3 id="如何正确关闭线程池"><a href="#如何正确关闭线程池" class="headerlink" title="如何正确关闭线程池"></a>如何正确关闭线程池</h3><h5 id="停止线程池的正确方法"><a href="#停止线程池的正确方法" class="headerlink" title="停止线程池的正确方法"></a>停止线程池的正确方法</h5><ul>
<li><strong>shutdown</strong> [再给就拒绝 新的任务不会增加了]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        executorService.execute(new ShutDownTask());
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;

=================================================================================
pool-1-thread-4
pool-1-thread-9
pool-1-thread-10
Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task threadpool.ShutDownTask@61bbe9ba rejected from java.util.concurrent.ThreadPoolExecutor@610455d6[Shutting down, pool size = 10, active threads = 10, queued tasks = 970, completed tasks = 20]
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)
    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)
    at threadpool.Shutdown.main(Shutdown.java:18)
pool-1-thread-8
pool-1-thread-1
pool-1-thread-3
</code></pre>
<ul>
<li><strong>isShutdown</strong> [判断是否进入停止状态]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        System.out.println(executorService.isShutdown());//false
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        System.out.println(executorService.isShutdown());//true 已经结束了
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>isTerminated</strong> [线程停止返回 整个程序执行完毕]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        System.out.println(executorService.isShutdown());//false
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        System.out.println(executorService.isShutdown());//true 已经结束了
        System.out.println(executorService.isTerminated());
        Thread.sleep(10000);
        System.out.println(executorService.isTerminated());
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
==========================================================================
pool-1-thread-5
pool-1-thread-10
false
true
false
pool-1-thread-2
pool-1-thread-6
pool-1-thread-6
pool-1-thread-2
true
</code></pre>
<ul>
<li><strong>awaitTermination</strong> [测试一段时间内线程会不会完全停止的方法 <u>等待的时间进程被打乱了</u> 等待的时间到了]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500); //七秒钟之内是否完全运行完毕了
        executorService.shutdown();
        boolean b = executorService.awaitTermination(7L, TimeUnit.SECONDS);
        System.out.println(b);
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>shutdownNow</strong> [立刻关闭线程池]</li>
</ul>
<pre><code class="java">///正在执行的和不要关闭 正在等待的内容直接返回 如何优雅编写？
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500); //七秒钟之内是否完全运行完毕了
        executorService.shutdownNow();//暴力关闭线程
        //这是正在队列中的数据 取了个List集合 都到runnableList里面了 要给它一个交代
        List&lt;Runnable&gt; runnableList = executorService.shutdownNow();
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;被中断了&quot;);
        &#125;
    &#125;
&#125;

=================================================================
pool-1-thread-6
pool-1-thread-4
pool-1-thread-10
pool-1-thread-8
pool-1-thread-3被中断了
pool-1-thread-1被中断了
pool-1-thread-8被中断了
pool-1-thread-2被中断了
</code></pre>
<h3 id="暂停和恢复线程池"><a href="#暂停和恢复线程池" class="headerlink" title="暂停和恢复线程池"></a>暂停和恢复线程池</h3><ul>
<li><strong>拒绝时机</strong><ul>
<li>当Executor关闭时，提交<strong>新任务</strong>会<strong>被拒绝</strong></li>
<li>以及当Executor对最大线程和工作队列容量使用有限边界并且<strong>已经饱和</strong>时</li>
</ul>
</li>
</ul>
<h5 id="4种拒绝策略"><a href="#4种拒绝策略" class="headerlink" title="4种拒绝策略"></a>4种拒绝策略</h5><ul>
<li><strong>AbortPolicy</strong> [直接抛出异常]</li>
<li><strong>DiscardPolicy</strong> [默默的丢弃]</li>
<li><strong>DiscardOldestPolicy</strong> [丢弃最老的]</li>
<li><strong>CallerRunsPolicy</strong> [誰提交任务誰去跑(避免了业务损失 提交任务速度下降 给了线程池缓冲时间)]</li>
</ul>
<h5 id="钩子方法，给线程池加点料"><a href="#钩子方法，给线程池加点料" class="headerlink" title="钩子方法，给线程池加点料"></a>钩子方法，给线程池加点料</h5><ul>
<li>每个任务执行前后</li>
<li>日志、统计</li>
<li>代码演示</li>
</ul>
<pre><code class="java">threadpool/PauseableThreadPool.java
package threadpool;

import java.util.concurrent.*;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 演示每个任务执行前后放钩子函数
 */
public class PauseableThreadPool extends ThreadPoolExecutor &#123;
    private final ReentrantLock lock = new ReentrantLock();
    private Condition unpaused = lock.newCondition();
    private boolean isPaused;
    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    &#125;

    @Override //在执行任务之前都会调用这个函数
    protected void beforeExecute(Thread t, Runnable r) &#123;
        super.beforeExecute(t, r);
        lock.lock();
        //如果检测到就暂停休息
        try &#123;
            while (isPaused) &#123;
                unpaused.await();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private void pause()&#123;
        lock.lock();
        try&#123;
            isPaused = true;
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;
    public void resume()&#123;
        lock.lock();
        try&#123;
            isPaused = false;
            unpaused.signalAll(); //唤醒全部
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        PauseableThreadPool pauseableThreadPool = new PauseableThreadPool(10, 20, 10l,
                TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());
        Runnable runnable = new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;我被执行&quot;);
                try &#123;
                    Thread.sleep(10);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;;
        for (int i = 0; i &lt; 10000; i++) &#123;
            pauseableThreadPool.execute(runnable);
        &#125;
            Thread.sleep(1500);
            pauseableThreadPool.pause();
            System.out.println(&quot;线程池被暂停了&quot;);
            Thread.sleep(1500);
            pauseableThreadPool.resume();
            System.out.println(&quot;线程池被恢复了&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="线程池实现复用的原因"><a href="#线程池实现复用的原因" class="headerlink" title="线程池实现复用的原因"></a>线程池实现复用的原因</h3><ul>
<li>线程池组成部分<ul>
<li>线程池管理器</li>
<li>工作线程</li>
<li>任务队列</li>
<li>任务接口(Task)</li>
</ul>
</li>
</ul>
<h5 id="Executor家族"><a href="#Executor家族" class="headerlink" title="Executor家族"></a>Executor家族</h5><ul>
<li><p>线程池、ThreadPoolExecutor、ExecutorService、Executor、Executors等这么多和线程池相关的类，都是什么关系？</p>
<p>Executor ← ExecutorService ← AbstractExecutorService ← ThreadPoolExecutor</p>
</li>
</ul>
<h5 id="线程池实现任务复用的原理"><a href="#线程池实现任务复用的原理" class="headerlink" title="线程池实现任务复用的原理"></a>线程池实现任务复用的原理</h5><ul>
<li>相同线程执行不同任务</li>
</ul>
<h3 id="线程池状态和使用注意点"><a href="#线程池状态和使用注意点" class="headerlink" title="线程池状态和使用注意点"></a>线程池状态和使用注意点</h3><h5 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h5><table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>接收新任务并处理排队任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>不接受新任务，但处理排队任务</td>
</tr>
<tr>
<td>STOP</td>
<td>不接受新任务，也不处理排队任务，并中断正在进行的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>所有任务都已终止，workerCount为零时，线程会转换到TIDYING状态，并将运行terminate()钩子方法</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>terminate()运行完成</td>
</tr>
</tbody></table>
<h5 id="使用线程池的注意点"><a href="#使用线程池的注意点" class="headerlink" title="使用线程池的注意点"></a>使用线程池的注意点</h5><ul>
<li>避免任务<strong>堆积</strong></li>
<li>避免线程数<strong>过度增加</strong></li>
<li>排查<strong>线程泄露</strong></li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h6 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h6><ul>
<li>让某个需要用到的对象在<strong>线程间隔离</strong></li>
<li>在任何方法中都可以<strong>轻松获取</strong>到该对象 .get</li>
</ul>
<p>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get和set方法访问) 时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是ptivate static类型的，用于关联线程和线程上下文，它的作用是：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂性。</p>
<ul>
<li>定义：提供<strong>线程局部</strong>变量；一个线程局部变量在多个线程中，分别由独立的值(副本)</li>
<li>特点：简单(开箱即用)、快速(无格外开销)、安全(线程安全)</li>
<li>场景：多线程场景(<strong>资源持有、线程一致性、并发计算、线程安全</strong>等场景)</li>
<li>实现原理：Java中使用<strong>哈希表</strong>实现</li>
<li>应用范围：几乎<strong>所有</strong>提供多线程特征的语言</li>
<li>设计者追求开箱即用的体验</li>
</ul>
<h3 id="ThreadLocal-API"><a href="#ThreadLocal-API" class="headerlink" title="ThreadLocal API"></a>ThreadLocal API</h3><ul>
<li>构造函数 <strong>ThreadLocal<T>()</strong></li>
<li>初始化 <strong>initialValue()</strong><ul>
<li>该方法会返回当前线程对应的”初始值”，这是一个<strong>延迟加载</strong>的方法，只有在<strong>调用get</strong>的时候，才会触发</li>
<li>当线程<strong>第一次使用get</strong>方法访问变量时，将调用此方法</li>
<li>每个线程最多调用<strong>一次</strong>此方法，但如果已经调用了remove()后，在调用get()，则可以再次调用此方法</li>
<li>如果不重写本方法，这个方法会返回null。一般使用匿名内部类的方法来**重写initialValue()**方法</li>
</ul>
</li>
<li>访问器 T <strong>get</strong>()：得到这个线程对应的value，如果是首次调用get()则会调用initialize来得到这个值 &#x2F;&#x2F; void <strong>set</strong>(T t)：为这个线程设置一个新值</li>
<li>回收 void <strong>remove</strong>(): 删除这个线程</li>
</ul>
<h6 id="根据共享对象的生成时机不同，选择initialValue或set来保存对象"><a href="#根据共享对象的生成时机不同，选择initialValue或set来保存对象" class="headerlink" title="根据共享对象的生成时机不同，选择initialValue或set来保存对象"></a>根据共享对象的生成时机不同，选择initialValue或set来保存对象</h6><h6 id="场景一：initialValue"><a href="#场景一：initialValue" class="headerlink" title="场景一：initialValue"></a>场景一：initialValue</h6><ul>
<li>在ThreadLocal<strong>第一次get</strong>的时候把对象給初始化出来，对象的初始化时机可以<strong>由我们控制</strong></li>
</ul>
<h6 id="场景二：set"><a href="#场景二：set" class="headerlink" title="场景二：set"></a>场景二：set</h6><ul>
<li>如果需要保存到ThreadLocal里的对象的生成时机<strong>不由我们随机控制</strong>，例如拦截器生成的用户信息</li>
<li>用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用</li>
</ul>
<h6 id="使用ThreadLocal带来的好处"><a href="#使用ThreadLocal带来的好处" class="headerlink" title="使用ThreadLocal带来的好处"></a>使用ThreadLocal带来的好处</h6><ul>
<li>达到<strong>线程安全</strong></li>
<li><strong>不需要加锁</strong>，提高执行<strong>效率</strong></li>
<li>更高效地<strong>利用内存、节省开销</strong></li>
<li><strong>避免传参</strong>的繁琐</li>
</ul>
<pre><code class="java">threadpool/ThreadLocalAPI.java
package threadpool;

public class ThreadLocalAPI &#123;
    public static ThreadLocal&lt;Long&gt; x = new ThreadLocal()&#123;
        @Override
        protected Long initialValue()&#123;
            System.out.println(&quot;Inital Value run...&quot;);
            return Thread.currentThread().getId();
        &#125;
    &#125;;

    public static void main(String[] args) &#123;
        new Thread() &#123;
            @Override
            public void run() &#123;
                System.out.println(x.get());
            &#125;
        &#125;.start(); //调用一次initialValue 每个线程单独拥有一个
        x.set(101l);
        x.remove();//清空线程 结果为1 因为 Thread.currentThread().getId();
        System.out.println(x.get());//发现x.remove被移除了 结果去重新触发initialValue
        System.out.println(x.get());
    &#125;
&#125;
========================================================================
Inital Value run...
Inital Value run...
20
1
1

若注释掉x.remove则会出现结果：
Inital Value run...
101
101
20
</code></pre>
<h3 id="ThreadLocal的4种核心场景"><a href="#ThreadLocal的4种核心场景" class="headerlink" title="ThreadLocal的4种核心场景"></a>ThreadLocal的4种核心场景</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e19e3d304bdfe6eeda2ae3a7f83a22ad4b9f274c/data/ThreadLocal%E7%9A%844%E7%A7%8D%E6%A0%B8%E5%BF%83%E5%9C%BA%E6%99%AF.png"></p>
<ul>
<li><strong>持有资源</strong>——持有线程资源供线程的各个部分使用，全局获取，减少<strong>编程难度</strong></li>
<li><strong>线程一致</strong>——帮助需要保持线程一致的资源(如数据库事务) 维护一致性，降低<strong>编程难度</strong></li>
<li><strong>线程安全</strong>——帮助只考虑了单线程的程序库，无缝向多线程场景迁移</li>
</ul>
<h3 id="ThreadLocal并发场景分析01"><a href="#ThreadLocal并发场景分析01" class="headerlink" title="ThreadLocal并发场景分析01"></a>ThreadLocal并发场景分析01</h3><h5 id="例1-200QPS压测统计接口"><a href="#例1-200QPS压测统计接口" class="headerlink" title="例1 200QPS压测统计接口"></a>例1 200QPS压测统计接口</h5><ul>
<li>观察200QPS下Spring框架的执行情况</li>
<li>目标：理解并发、竞争条件、临界区等概念</li>
<li>代表场景：交易场景</li>
</ul>
<h5 id="并发、竞争条件和临界区"><a href="#并发、竞争条件和临界区" class="headerlink" title="并发、竞争条件和临界区"></a>并发、竞争条件和临界区</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/7abcc6448891d1b18f32a37dcaf90210ca396b58/data/ThreadLocal%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF.jpg" alt="ThreadLocal并发场景"></p>
<ul>
<li>并发：多个程序<strong>同时执行</strong></li>
<li>竞争条件：多个进程(线程)同时访问<strong>同一个内存资源</strong>，最终的执行结果依赖于多个进程执行时的<strong>精确时序</strong></li>
<li>临界区：访问共享内存的程序片段</li>
</ul>
<pre><code class="java">StatController.java
package com.imooc.springbootlearn;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller //并发可能导致同时 数据错误 需要加★后面的代码
public class StatController &#123;
    //★★ 避免用锁 导致当数据多的话线程缓慢
    static ThreadLocal&lt;Integer&gt; c = new ThreadLocal&lt;Integer&gt;() &#123;
        @Override
        protected Integer initialValue() &#123;
            return 0;
        &#125;
    &#125;;
    //★ 请求并发也要排队synchronized(但是不要轻易使用锁) 应该怎么办 见★★
    synchronized void _add() throws InterruptedException &#123;
        Thread.sleep(100);
        c.set(c.get() + 1);
    &#125;

    @RequestMapping(&quot;/stat&quot;)
    public Integer stat() &#123;
        return c.get();
    &#125;

    @RequestMapping(&quot;/add&quot;)
    public Integer add() throws InterruptedException &#123;
//        Thread.sleep(100l);
//        c++;
        _add();
        return 1;
    &#125;

&#125;
</code></pre>
<pre><code class="java">SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages=&quot;com.imooc&quot;)
public class SpringBootlearnApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;
&#125;
</code></pre>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>基于线程池模型synchronize(排队操作很危险)</li>
<li>用ThreadLocal收集数据很快速且安全</li>
<li>思考：如何在多个ThreadLocal中收集数据？</li>
</ul>
<h3 id="ThreadLocal场景分析——减少同步"><a href="#ThreadLocal场景分析——减少同步" class="headerlink" title="ThreadLocal场景分析——减少同步"></a>ThreadLocal场景分析——减少同步</h3><h5 id="ThreadLocal-lt-T-gt-同步"><a href="#ThreadLocal-lt-T-gt-同步" class="headerlink" title="ThreadLocal&lt; T &gt;同步"></a>ThreadLocal&lt; T &gt;同步</h5><pre><code class="java">StatController.java    高效解决高并发
package com.imooc.springbootlearn;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.HashSet;

@Controller //并发可能导致同时 数据错误 需要加★后面的代码
public class StatController &#123;

    static HashSet&lt;Val&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();
    synchronized static void addSet(Val&lt;Integer&gt; v)&#123;
        set.add(v);
    &#125;

    //★★ 避免用锁 导致当数据多的话线程缓慢
    static ThreadLocal&lt;Val&lt;Integer&gt;&gt; c = new ThreadLocal&lt;Val&lt;Integer&gt;&gt;() &#123;
        @Override
        protected Val&lt;Integer&gt; initialValue() &#123;
            Val&lt;Integer&gt; v = new Val&lt;&gt;();
            v.set(0);
            //set.add(v);//容易产生同步问题 小锁一下
            return v;
        &#125;
    &#125;;

    //★ 请求并发也要排队synchronized(但是不要轻易使用锁) 应该怎么办 见★★
/*synchronized*/void _add() throws InterruptedException &#123;
        Thread.sleep(100); //高并发
        Val&lt;Integer&gt; v = c.get();
        v.set(v.get() + 1);
    &#125;

    @RequestMapping(&quot;/stat&quot;)
    public Integer stat() &#123;
        return set.stream().map(x -&gt; x.get()).reduce((a, x) -&gt; a + x).get();
    &#125;

    @RequestMapping(&quot;/add&quot;)
    public Integer add() throws InterruptedException &#123;
//        Thread.sleep(100l);
//        c++;
        _add();
        return 1;
    &#125;
&#125;
</code></pre>
<pre><code class="java">Val.java
package com.imooc.springbootlearn;

public class Val&lt;T&gt;&#123;
    T v;
    public void set(T _v)&#123;
        v = _v;
    &#125;
    public T get()&#123;
        return v;
    &#125;
&#125;
</code></pre>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul>
<li>完全避免同步(<strong>难</strong>)</li>
<li>缩小同步范围(<strong>简单</strong>) + ThreadLocal解决问题</li>
<li>思考：还可以用在哪些场景？</li>
</ul>
<h6 id="源码分析1-Quartz-SimpleSemaphore"><a href="#源码分析1-Quartz-SimpleSemaphore" class="headerlink" title="源码分析1-Quartz SimpleSemaphore"></a>源码分析1-Quartz SimpleSemaphore</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/d20d4cb3a98413a2fb910922671f8a98e6d114a5/data/Quartz%E4%BB%8B%E7%BB%8D.png"></p>
<ul>
<li>Quartz的SimpleSemaphore提供资源隔离(上锁)</li>
<li>SimpleSemaphore中的lockOwners(ThreadLocal)为重度锁操作前置过滤</li>
<li>思考：学易，用难！</li>
</ul>
<h6 id="源码分析2-Mybatis框架保持连接池线程一致"><a href="#源码分析2-Mybatis框架保持连接池线程一致" class="headerlink" title="源码分析2-Mybatis框架保持连接池线程一致"></a>源码分析2-Mybatis框架保持连接池线程一致</h6><h5 id="什么是本地事务"><a href="#什么是本地事务" class="headerlink" title="什么是本地事务"></a>什么是本地事务</h5><ul>
<li>A(Atomic)原子性，操作不可分割</li>
<li>C(Consistency)一致性，任何时刻数据都能保持一致</li>
<li>I(Isolation)隔离性，多事务并发执行的时许不影响结果</li>
<li>D(Durability)持久性，对数据结构的存储是永久的</li>
</ul>
<p>Begin → [本地事务：(更新订单状态 →&lt;订单状态更新成功&gt;→发放资源) → <strong>资源发放成功(提交)</strong> → Commit →&lt;持久化&gt;→DB。**若资源发放失败(回滚)**→Rollback]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9693ffeda32d871b1665958a7febca56da0011bd/data/Mybatis%E6%A1%86%E6%9E%B6%E4%BF%9D%E6%8C%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%BA%BF%E7%A8%8B%E4%B8%80%E8%87%B4.jpg"></p>
<h6 id="源码分析03-Spring框架对分布式事务的支持"><a href="#源码分析03-Spring框架对分布式事务的支持" class="headerlink" title="源码分析03 Spring框架对分布式事务的支持"></a>源码分析03 Spring框架对分布式事务的支持</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/b2cc782319836bb4d81765c38fe5b8de5098bb21/data/Spring%E6%A1%86%E6%9E%B6%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81.jpg"></p>
<h3 id="技术选型——实现自己的ThreadLocal"><a href="#技术选型——实现自己的ThreadLocal" class="headerlink" title="技术选型——实现自己的ThreadLocal"></a>技术选型——实现自己的ThreadLocal</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ec226021e343c1f8dbc268e9809361c629e6cb4d/data/threadLocalMap.jpg"></p>
<pre><code class="java">MyThreadLocal.java
package com.imooc.springbootlearn;

import java.util.HashMap;
import java.util.Objects;

class MyThreadLocal&lt;T&gt; &#123;
    static HashMap&lt;Thread, HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt;&gt; threadLocalMap = new HashMap&lt;&gt;();//这里会产生临界区

    synchronized static HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt; getMap() &#123; //这是锁临界区
        var thread = Thread.currentThread();
        if (!threadLocalMap.containsKey(thread)) &#123;
            threadLocalMap.put(thread, new HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt;());
        &#125;
        return threadLocalMap.get(thread);
    &#125;

    T value;

    protected T initialValue() &#123;
        return null;
    &#125;

    public T get() &#123;
        var map = getMap();
        if (!map.containsKey(this)) &#123;
            map.put(this, initialValue());
        &#125;
        return (T) map.get(this);
    &#125;

    public void set(T v)&#123;
        var map = getMap();
        map.put(this, v);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Test.java
package com.imooc.springbootlearn;

public class Test &#123;
    static MyThreadLocal&lt;Long&gt; v = new MyThreadLocal&lt;Long&gt;()&#123;
        @Override
        protected Long initialValue() &#123;
         return Thread.currentThread().getId();
        &#125;
    &#125;;

    public static void main(String[] args) &#123;
        for (Integer i = 0; i &lt; 100; i++) &#123;
            new Thread(()-&gt;&#123;
                System.out.println(v.get());
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>HashMap中直接存储了MyThreadLocal的引用，导致内存无法回收</li>
<li>思考：可以用整数ID替代对MyThreadLocal的引用</li>
</ul>
<pre><code class="java">MyThreadLocal.java
package com.imooc.springbootlearn;

import java.util.HashMap;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;

class MyThreadLocal&lt;T&gt; &#123;
    static AtomicInteger atomic = new AtomicInteger(); //保证数据唯一性
    Integer threadLocalHash = atomic.addAndGet(0x61c88647); //这个值保证hash的更平均性
    static HashMap&lt;Thread, HashMap&lt;Integer, Objects&gt;&gt; threadLocalMap = new HashMap&lt;&gt;();//这里会产生临界区

    synchronized static HashMap&lt;Integer, Objects&gt; getMap() &#123; //这是锁临界区
        var thread = Thread.currentThread();
        if (!threadLocalMap.containsKey(thread)) &#123;
            threadLocalMap.put(thread, new HashMap&lt;Integer, Objects&gt;());
        &#125;
        return threadLocalMap.get(thread);
    &#125;

    T value;

    protected T initialValue() &#123;
        return null;
    &#125;

    public T get() &#123;
        var map = getMap();
        if (!map.containsKey(this.threadLocalHash)) &#123;
            map.put(this.threadLocalHash, initialValue());
        &#125;
        return (T) map.get(this.threadLocalHash);
    &#125;

    public void set(T v)&#123;
        var map = getMap();
        map.put(this.threadLocalHash, v);
    &#125;
&#125;
</code></pre>
<ul>
<li>HashMap无限增加？初始空间分配是否合理？</li>
</ul>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h5 id="源码解读——哈希表实现ThreadLocal"><a href="#源码解读——哈希表实现ThreadLocal" class="headerlink" title="源码解读——哈希表实现ThreadLocal"></a>源码解读——哈希表实现ThreadLocal</h5><h6 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h6><p><strong>哈希表</strong>(散列 HashTable) 根据键(Key) 访问&#x2F;设置内存中存储的位置的值</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c2851c7bd5792200e8f9af16f6f08a33520c6f2d/data/%E9%80%89%E5%AD%A6HashTable.png"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>架构是严密且精确的东西(切记夸夸其谈)</li>
<li>并发是一个很危险的场景，提高能力才会获得安全感</li>
<li>保持怀疑，持续学习</li>
<li>会用 → 场景查找 → 轻量实现 → 源码对照 → 场景沉淀</li>
<li>程序架构：低耦合(独立)、高内聚(组合做到开箱即用)</li>
<li>无论达到什么高度，要永远认为自己是个<strong>菜鸡</strong></li>
</ul>
<h2 id="分布式章节"><a href="#分布式章节" class="headerlink" title="分布式章节"></a>分布式章节</h2><ul>
<li><h5 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h5></li>
<li><h5 id="分布式的作用"><a href="#分布式的作用" class="headerlink" title="分布式的作用"></a>分布式的作用</h5></li>
<li><h5 id="分布式和单体结构的对比"><a href="#分布式和单体结构的对比" class="headerlink" title="分布式和单体结构的对比"></a>分布式和单体结构的对比</h5></li>
<li><p><strong>CAP</strong>定理</p>
</li>
<li><p><span style = "color:red"><strong>集群、分布式、微服务</strong></span>的区别</p>
</li>
</ul>
<h3 id="什么是分布式-1"><a href="#什么是分布式-1" class="headerlink" title="什么是分布式"></a>什么是分布式</h3><ul>
<li><p>利用物理架构形成多个自治的处理元素，<strong>不共享主内存</strong>，但是通过<strong>发送信息</strong>合作。</p>
</li>
<li><h6 id="饭店初始的例子"><a href="#饭店初始的例子" class="headerlink" title="饭店初始的例子"></a>饭店初始的例子</h6><ul>
<li><strong>一个</strong>厨师 [单例]</li>
<li><strong>多个</strong>厨师 </li>
<li>术业有<strong>专攻</strong>：配菜师、洗菜工</li>
</ul>
</li>
<li><p>实际项目的演进过程</p>
<ul>
<li>一个项目，<strong>大而全</strong></li>
<li><strong>多台机器</strong>，部署相同的应用</li>
<li><strong>分布式</strong>：权限系统、员工系统、请假系统</li>
</ul>
</li>
</ul>
<h3 id="分布式的作用-1"><a href="#分布式的作用-1" class="headerlink" title="分布式的作用"></a>分布式的作用</h3><h5 id="为什么需要分布式"><a href="#为什么需要分布式" class="headerlink" title="为什么需要分布式"></a>为什么需要分布式</h5><ul>
<li>实际工作中的痛点<ul>
<li>工程<strong>臃肿</strong> [相互耦合 相互冲突]</li>
<li>测试、上线<strong>繁琐</strong></li>
<li>开发<strong>效率低</strong></li>
</ul>
</li>
</ul>
<h5 id="单体应用的问题"><a href="#单体应用的问题" class="headerlink" title="单体应用的问题"></a>单体应用的问题</h5><ul>
<li>应用代码<strong>耦合</strong>严重，功能扩展难</li>
<li>新需求开发交互周期长，测试工作量大</li>
<li>新加入的开发同事需要很长时间才能熟悉系统</li>
<li>升级维护也很困难(改动任何一点地方都要升级整个系统)</li>
<li>系统性能提升艰难，可用性低，不稳定</li>
</ul>
<h5 id="分布式的好处"><a href="#分布式的好处" class="headerlink" title="分布式的好处"></a>分布式的好处</h5><ul>
<li>增大系统容量</li>
<li>加强系统可用[某个模块出bug 但不影响其他]</li>
<li>因为模块化，所以系统模块重用度更高</li>
<li>因为软件服务模块被拆分，开发和发布速度可以并行而变得更快</li>
<li>系统<strong>扩展性</strong>更高</li>
<li>团队<strong>协作流程</strong>也会得到改善</li>
<li><strong>技术升级</strong></li>
</ul>
<h3 id="单体和分布式的对比"><a href="#单体和分布式的对比" class="headerlink" title="单体和分布式的对比"></a>单体和分布式的对比</h3><h5 id="分布式和单体结构的对比-1"><a href="#分布式和单体结构的对比-1" class="headerlink" title="分布式和单体结构的对比"></a>分布式和单体结构的对比</h5><table>
<thead>
<tr>
<th></th>
<th>传统单体构架</th>
<th>分布式构架</th>
</tr>
</thead>
<tbody><tr>
<td><strong>新人的学习成本</strong></td>
<td>业务逻辑成本高</td>
<td>架构逻辑成本高</td>
</tr>
<tr>
<td><strong>部署、运维</strong></td>
<td>容易</td>
<td>发布频繁，顺序复杂、运维难</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>一损俱损，殃及鱼池</td>
<td>故障影响范围小</td>
</tr>
<tr>
<td><strong>架构设计</strong></td>
<td>难度低</td>
<td>难度指数级上升</td>
</tr>
<tr>
<td><strong>系统性能</strong></td>
<td>响应快、吞吐量小</td>
<td>响应慢、吞吐量大</td>
</tr>
<tr>
<td><strong>测试成本</strong></td>
<td>低</td>
<td>很高</td>
</tr>
<tr>
<td><strong>技术多样性</strong></td>
<td>技术单一且封闭</td>
<td>技术多样且开放</td>
</tr>
<tr>
<td><strong>系统扩展性</strong></td>
<td>扩展性差</td>
<td>扩展性很好</td>
</tr>
<tr>
<td><strong>系统管理成本</strong></td>
<td>成本低</td>
<td>成本高</td>
</tr>
</tbody></table>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><h5 id="CAP的重要性"><a href="#CAP的重要性" class="headerlink" title="CAP的重要性"></a>CAP的重要性</h5><p>分布式不可能同时满足三个条件</p>
<h5 id="CAP理论是什么？"><a href="#CAP理论是什么？" class="headerlink" title="CAP理论是什么？"></a>CAP理论是什么？</h5><ul>
<li><span style = "color:red"><strong>C</strong>(Consistency, 一致性)</span>：读操作是否总能读到前一个写操作的结果</li>
<li><span style = "color:red"><strong>A</strong>(Availability, 可用性)</span>：非故障节点应该在合理的时间内作出合理的响应(不是错误或超时的响应),但是可能<strong>不是最新的数据</strong>。</li>
<li><span style = "color:red"><strong>P</strong>(Partition tolerance, 分区容错)</span>：当出现网络分区现象后，系统能够继续运行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/793eb4ab3003af82869b186bcc016fcb8c2c2f5b/data/CAP%E5%AE%9A%E7%90%86.jpg"></p>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
</ul>
<h3 id="集群、分布式、微服务的区别"><a href="#集群、分布式、微服务的区别" class="headerlink" title="集群、分布式、微服务的区别"></a>集群、分布式、微服务的区别</h3><h5 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h5><ul>
<li>分布式：一个业务分拆<strong>多个子业务</strong>，部署在不同的服务器上 [服务器之间要通信]</li>
<li>集群：<strong>同一个</strong>业务，部署在多个服务器上 [五台机器可以不通信]</li>
</ul>
<h5 id="集群和微服务的区别"><a href="#集群和微服务的区别" class="headerlink" title="集群和微服务的区别"></a>集群和微服务的区别</h5><ul>
<li>集群：分散<strong>压力</strong></li>
<li>微服务：分散<strong>压力</strong></li>
</ul>
<h5 id="微服务和分布式的区别"><a href="#微服务和分布式的区别" class="headerlink" title="微服务和分布式的区别"></a>微服务和分布式的区别</h5><ul>
<li><p>微服务是<strong>架构设计</strong>方式 [逻辑架构]</p>
</li>
<li><p>分布式是<strong>系统部署</strong>方式 [物理架构]</p>
</li>
<li><p>微服务：是一种架构方式 [大的服务拆成小的服务 每个服务独立开发测试]</p>
</li>
<li><p>分布式：主要强调部署的方式</p>
</li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul>
<li>基本概念、用途、核心思想</li>
<li>Docker的组成、架构、重要概念</li>
<li>Docker的安装</li>
<li><strong>第一个Docker容器</strong></li>
<li>运用Nginx镜像，并访问到Docker容器内部 [从外部进行访问]</li>
<li>制作自己的Docker容器，<strong>dockerfile</strong>实战</li>
</ul>
<h3 id="Docker的基本概念、用途、核心思想"><a href="#Docker的基本概念、用途、核心思想" class="headerlink" title="Docker的基本概念、用途、核心思想"></a>Docker的基本概念、用途、核心思想</h3><ul>
<li>Docker应用广泛<br>京东618：15万个Docker实例，所有业务全部容器化</li>
<li>Docker是什么？<br>[以前的图标是大鲸鱼拖着集装箱]<ul>
<li>Docker是一个用来装程序及其环境的<strong>容器</strong>[类似于<u>安装包.exe</u>]，属于Linux容器的一种封装，提供简单易用的容器使用接口。它是目前<strong>最流行</strong>的Linux容器解决方案</li>
<li>比喻：客车可以装人，衣柜可以放衣服 [Windows下写的小游戏也可以放在Docker中]</li>
</ul>
</li>
</ul>
<h3 id="为什么需要Docker"><a href="#为什么需要Docker" class="headerlink" title="为什么需要Docker"></a>为什么需要Docker</h3><ul>
<li><strong>环境配置</strong>的难题</li>
<li>虚拟机[资源占用很多 模拟一套完整系统但步骤多(有些步骤无法跳过) 启动慢]</li>
<li>Docker的基础——<strong>Linux容器</strong> [体积小 速度快 轻量级虚拟机]</li>
</ul>
<h3 id="Docker的用途"><a href="#Docker的用途" class="headerlink" title="Docker的用途"></a>Docker的用途</h3><ul>
<li>提供<strong>统一</strong>的环境</li>
<li>提供<strong>快速拓展</strong>、弹性伸缩的云服务 [解决双十一淘宝+天猫 数据量剧增问题]</li>
<li>防止其他用户的进程把服务器资源<strong>占用过多</strong> [程序相互之间可以隔离]</li>
<li>部署简单 运维简单 节省服务器资源</li>
</ul>
<h3 id="Docker的特点"><a href="#Docker的特点" class="headerlink" title="Docker的特点"></a>Docker的特点</h3><h5 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h5><ul>
<li><p><strong>运输方式</strong>(把程序和环境从一个机器运送到另一个机器)</p>
</li>
<li><p><strong>存储方式</strong>(程序和环境的存储)</p>
</li>
<li><p><strong>API接口</strong>(不需要Tomcat等应用的命令了，都标准化了)</p>
</li>
<li><p><strong>灵活</strong>：即使是最复杂的应用也可以集装箱化</p>
</li>
<li><p><strong>轻量级</strong>：容器利用并共享主机内核</p>
</li>
<li><p><strong>便携式</strong>：可以在本地构建，部署到云，并在任何地方运行</p>
</li>
</ul>
<h5 id="Docker带来的好处"><a href="#Docker带来的好处" class="headerlink" title="Docker带来的好处"></a>Docker带来的好处</h5><ul>
<li>开发团队的好处 完全可以控制所有的环境[同一个镜像] 降低了风险</li>
</ul>
<h3 id="image镜像"><a href="#image镜像" class="headerlink" title="image镜像"></a>image镜像</h3><ul>
<li>存储：联合文件系统，UnionFS</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/28665426b3b7f9351280ab4c58b1ea388391f211/data/image%E9%95%9C%E5%83%8F.jpg"></p>
<h3 id="容器和仓库"><a href="#容器和仓库" class="headerlink" title="容器和仓库"></a>容器和仓库</h3><ul>
<li><strong>镜像类似于Java中的类，而容器就是实例化</strong></li>
<li>容器的这一层是可以修改的，而镜像是不可以修改的</li>
<li>同一个镜像可以生成多个容器独立运行，而她们之间没有任何的干扰</li>
</ul>
<h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><ul>
<li><strong>hub.docker.com</strong></li>
<li><a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></li>
<li>共有、私有</li>
</ul>
<h5 id="client和deamon"><a href="#client和deamon" class="headerlink" title="client和deamon"></a>client和deamon</h5><ul>
<li><strong>client</strong>[<strong>客户端</strong>]：提供給用户一个终端，用户输入Docker提供的命令来管理本地或远程的服务器</li>
<li><strong>deamon</strong>：<strong>服务端</strong>守护进程，接收Client发送的命令并执行相应的操作</li>
</ul>
<h3 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h3><ul>
<li><h6 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h6><a target="_blank" rel="noopener" href="https://www.docker.com/products/docker-desktop/">Docker Desktop: The #1 Containerization Tool for Developers | Docker</a></li>
</ul>
<h5 id="更换系统镜像"><a href="#更换系统镜像" class="headerlink" title="更换系统镜像"></a>更换系统镜像</h5><p><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/region/cn-hangzhou">云服务器管理控制台 (aliyun.com)</a> → 实例 → 更多 → 更换操作系统 → CentOS 7.6 64位</p>
<pre><code class="java">C:\Users\Pluminary&gt;ssh root@47.98.225.105
    
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:THXnakQ0Se5ee+d7oHO0NYKBTW7mhEKc426m9+rQgnk.
Please contact your system administrator.
Add correct host key in C:\\Users\\Pluminary/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in C:\\Users\\Pluminary/.ssh/known_hosts:7
Host key for 47.98.225.105 has changed and you have requested strict checking.
Host key verification failed.
    
//使用命令或手动删除 C:\\Users\\Pluminary/.ssh/known_hosts 防火墙拦截了
vim C:\\Users\\Pluminary/.ssh/known_hosts

C:\Users\Pluminary&gt;ssh root@47.98.225.105
root@47.98.225.105&#39;s password:Panchunyao123!

[root@iZbp1dssknxftmjczbtpndZ ~]# cat /etc/redhat-release
CentOS Linux release 7.6.1810 (Core)
//yum地址换成国内yum源
   //wget-O 这是大写的字母O 含义是放到指定目录下 替换本地文件为国内文件
[root@iZbp1dssknxftmjczbtpndZ ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
[root@iZbp1dssknxftmjczbtpndZ ~]# yum clean all
[root@iZbp1dssknxftmjczbtpndZ ~]# yum makecache //读取新的源

//较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。
[root@iZbp1dssknxftmjczbtpndZ ~]# yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
//如果yum报告未安装这些软件包，也没问题。
    //更新yum 先查看需要更新哪些
[root@iZbp1dssknxftmjczbtpndZ ~]# yum check-update
[root@iZbp1dssknxftmjczbtpndZ ~]# yum update
// 安装所需的软件包
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install -y yum-utils \
                  device-mapper-persistent-data \
                  lvm2
// 使用以下命令来设置稳定的存储库 sudo是用超级管理员
[root@iZbp1dssknxftmjczbtpndZ ~]# sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

// 查看docker版本
[root@iZbp1dssknxftmjczbtpndZ ~]# yum list docker-ce --showduplicates | sort -r
// 安装指定的版本
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io
// Docker 是服务器----客户端架构
// 命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动
[root@iZbp1dssknxftmjczbtpndZ ~]# systemctl start docker
// 安装完成后，运行下面的命令，验证是否安装成功。
[root@iZbp1dssknxftmjczbtpndZ ~]# docker version 或者 docker info
</code></pre>
<h3 id="第一个Docker容器"><a href="#第一个Docker容器" class="headerlink" title="第一个Docker容器"></a>第一个Docker容器</h3><ul>
<li><span style = "color:red"><strong>下载镜像</strong></span></li>
<li><strong>docker pull [OPTIONS] NAME[:TAG]</strong></li>
<li><strong>docker images [OPTIONS] [REPOSITORY[:TAG]]</strong> 查看本机有没有任何镜像</li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
c1ec31eb5944: Pull complete
Digest: sha256:53641cd209a4fecfc68e21a99871ce8c6920b2e7502df0a20671c6fccc73a7c6
Status: Downloaded newer image for hello-world:latest
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              d2c94e258dcb        11 months ago       13.3kB
</code></pre>
<ul>
<li><span style = "color:red"><strong>运行镜像</strong></span></li>
<li><strong>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</strong></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hello-world
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal. 

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre>
<h3 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h3><h5 id="运行Nginx镜像，并访问到Docker容器内部"><a href="#运行Nginx镜像，并访问到Docker容器内部" class="headerlink" title="运行Nginx镜像，并访问到Docker容器内部"></a>运行Nginx镜像，并访问到Docker容器内部</h5><ul>
<li><strong>前台、后台</strong></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker images //查看一下程序镜像是否还在
[root@iZbp1dssknxftmjczbtpndZ ~]# docker pull hub.c.163.com/library/nginx:1.13.0
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello-world                   latest              d2c94e258dcb        11 months ago       13.3kB
hub.c.163.com/library/nginx   1.13.0              46102226f2fd        6 years ago         109MB
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hub.c.163.com/library/nginx:1.13.0
//上面的没反应是正常情况，再开一个cmd窗口


//第二个窗口：另一个cmd窗口 
C:\Users\Pluminary&gt;ssh root@47.98.225.105
root@47.98.225.105&#39;s password:
Last login: Sun Apr  7 16:30:40 2024 from 182.102.75.173

Welcome to Alibaba Cloud Elastic Compute Service !
//展示当前容器列表
[root@iZbp1dssknxftmjczbtpndZ ~]# docker ps
CONTAINER ID        IMAGE                                COMMAND                  CREATED              STATUS              PORTS               NAMES
298f7e19f6a8        hub.c.163.com/library/nginx:1.13.0   &quot;nginx -g &#39;daemon of…&quot;   About a minute ago   Up About a minute   80/tcp              kind_taussig
//这时回到第一个窗口 ctrl+c 关掉运行 这时去第二个窗口docker ps的时候已经没有了
// ↓↓↓↓↓↓ 要把Nginx在后台运行才可以解决上述问题 ↓↓↓↓↓↓
[root@iZbp1dssknxftmjczbtpndZ ~]# docekr run -d hub.c.163.com/library/nginx:1.13.0
f124fc9171824e508639768b800efba5c780385dc1d135ab0ff70d80d3d75510 //返回容器ID
//此时再去第二个窗口 docker ps就会看到 CONTAINER ID 有f124fc917182
//第一个窗口 查看容器内部的风景 -i让容器输入有效 t是給我们分配一个终端 bash是启动终端
[root@iZbp1dssknxftmjczbtpndZ ~]# docker exec -it f124 bash //让docker明白我们让哪个启动
root@f124fc917182:/#  //已经进入到容器内部
root@f124fc917182:/# pwd
/
root@f124fc917182:/# touch 1 //创建了一个1
root@f124fc917182:/# ls
1  bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@f124fc917182:/# which nginx
/usr/sbin/nginx
</code></pre>
<h3 id="Docker三种网络模式-网络会隔离-需要配置进行端口映射"><a href="#Docker三种网络模式-网络会隔离-需要配置进行端口映射" class="headerlink" title="Docker三种网络模式 [网络会隔离 需要配置进行端口映射]"></a>Docker三种网络模式 [网络会隔离 需要配置进行端口映射]</h3><ul>
<li><strong>Bridge</strong> 网卡网络独立的端口</li>
<li><strong>Host</strong> 同步宿主机的端口</li>
<li>None</li>
<li>端口映射技术</li>
</ul>
<h5 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h5><ul>
<li>访问Docker内的Nginx</li>
</ul>
<pre><code class="java">cmd窗口2
[root@iZbp1dssknxftmjczbtpndZ ~]# docker stop f12
f12
[root@iZbp1dssknxftmjczbtpndZ ~]# docker ps //目前没有容器在运行了
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
    //-p 本机的8080端口去映射内部的80端口 前面的是本机 后面的是容器内部的
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run -d -p 8080:80 hub.c.163.com/library/nginx:1.13.0
3906129ced72b668581a58dc36595b08734b82e247e2927eb2a8da6fbe7508ae
//拔出端口的信息
[root@iZbp1dssknxftmjczbtpndZ ~]# netstat -na|grep 8080
tcp6       0      0 :::8080                 :::*                    LISTEN

在网页上输入 http://47.98.225.105:8080/

Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.
For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.
Thank you for using nginx.

这个不是在宿主机启动的nginx 而是在容器中启动的【通过宿主机中转 并通过Bridge实现独立】
★★ 通过一台服务器上去布置多台Docker 而每台docker里面是独立的 并且可以通过一个端口 来实现和外界的映射关系 ★★
//这个与7行代码的区别 这里是大P 将这个容器的所有端口都进行映射
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run -d -P hub.c.163.com/library/nginx:1.13.0
</code></pre>
<h3 id="制作自己的Docker容器，dockerfile实战"><a href="#制作自己的Docker容器，dockerfile实战" class="headerlink" title="制作自己的Docker容器，dockerfile实战"></a>制作自己的Docker容器，dockerfile实战</h3><p>[把自己的软件程序打包好传給别人]</p>
<ul>
<li>dockerfile作用</li>
<li>使用dockerfile的好处[一目了然 哪个环境跑在什么环境下 非常方便知道如何配置]</li>
<li>写一个自己的dockerfile</li>
</ul>
<blockquote>
<p>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p>
</blockquote>
<pre><code class="sql">FROM alpine:latest #继承父类 alpine及其小的环境
MAINTAINER imooc   #描述这个镜像由誰维护的
CMD echo &#39;hello my dockerfile&#39;  #进入任何想要的dockerfile命令
</code></pre>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# touch Dockerfile
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
Dockerfile
[root@iZbp1dssknxftmjczbtpndZ ~]# vim Dockerfile
//按小写i进入编辑模式  按ESC退出编辑模式 :wq会保存
//取名字 .dockerfile现在的路径
[root@iZbp1dssknxftmjczbtpndZ ~]# docker build -t hello_docker .
    //先发送到服务器
Sending build context to Docker daemon  285.7kB
    //从父类中拉取下来
Step 1/3 : FROM alpine:latest
latest: Pulling from library/alpine
4abcf2066143: Pull complete
Digest: sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6b
Status: Downloaded newer image for alpine:latest
 ---&gt; 05455a08881e
    //写定它的维护者
Step 2/3 : MAINTAINER imooc
 ---&gt; Running in 38a73abca50e
Removing intermediate container 38a73abca50e
---&gt; f44831f49afe
    //把这个语句写进去
Step 3/3 : CMD echo &#39;hello my dockerfile&#39;
 ---&gt; Running in 1ff431539208
Removing intermediate container 1ff431539208
 ---&gt; f45b88d0cabc
Successfully built f45b88d0cabc
Successfully tagged hello_docker:latest

//运行自己的镜像
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello_docker                  latest              f45b88d0cabc        3 minutes ago       7.38MB
alpine                        latest              05455a08881e        2 months ago        7.38MB
hello-world                   latest              d2c94e258dcb        11 months ago       13.3kB
hub.c.163.com/library/nginx   1.13.0              46102226f2fd        6 years ago         109MB
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hello_docker
hello my dockerfile
</code></pre>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><ul>
<li><h6 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h6></li>
<li><h6 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h6></li>
<li><h6 id="常用命令讲解和演示"><a href="#常用命令讲解和演示" class="headerlink" title="常用命令讲解和演示"></a>常用命令讲解和演示</h6></li>
<li><h6 id="配置文件讲解"><a href="#配置文件讲解" class="headerlink" title="配置文件讲解"></a>配置文件讲解</h6></li>
<li><h6 id="场景实战：搭建一个静态文件的Nginx服务"><a href="#场景实战：搭建一个静态文件的Nginx服务" class="headerlink" title="场景实战：搭建一个静态文件的Nginx服务"></a>场景实战：搭建一个静态文件的Nginx服务</h6></li>
</ul>
<h3 id="Nginx介绍-1"><a href="#Nginx介绍-1" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h3><ul>
<li>Nginx是什么、适用场景</li>
<li>Nginx应用广泛</li>
<li>Nginx优点</li>
</ul>
<h4 id="Nginx是什么、适用场景"><a href="#Nginx是什么、适用场景" class="headerlink" title="Nginx是什么、适用场景"></a>Nginx是什么、适用场景</h4><ul>
<li>HTTP的<strong>反向代理</strong>服务器</li>
<li><strong>动态静态</strong>资源分离</li>
</ul>
<h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a><span style = "color:red">正向代理</span></h5><p>普通的请求转发，客户端把信息传递到代理服务器，代理服务器找到信息转发给我们<br>提供安全功能 代理服务器有防火墙，可以隐藏自身的信息 </p>
<h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><span style = "color:red">反向代理</span></h5><p>提供安全和防火墙 在多个服务器后端提供负载均衡 为服务器提供缓存 把来自用户的压力平均分配[负载均衡]</p>
<h5 id="动态静态资源分离-加速访问-整体速度提高"><a href="#动态静态资源分离-加速访问-整体速度提高" class="headerlink" title="动态静态资源分离 [加速访问 整体速度提高]"></a><span style = "color:red">动态静态资源分离</span> [加速访问 整体速度提高]</h5><ul>
<li>不分离会<strong>变慢</strong></li>
<li>静态资源<strong>无需经过Tomcat</strong>，Tomcat只负责处理动态请求</li>
<li>后缀为gif的时候，Nginx会<strong>直接</strong>获取到当前请求的文件并返回</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/93ef10f6db6a389181a9f20268c6c4b8b82c46d7/data/%E6%AD%A3%E5%90%91_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_.jpg"></p>
<h3 id="Nginx应用广泛"><a href="#Nginx应用广泛" class="headerlink" title="Nginx应用广泛"></a>Nginx应用广泛</h3><h5 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h5><ul>
<li>高并发、高性能</li>
<li>可扩展性好</li>
<li>高可靠性 [服务器运行可以达到数年之久]</li>
<li>热部署</li>
<li>开源、可商用</li>
</ul>
<h3 id="Nginx的安装-1"><a href="#Nginx的安装-1" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h3><h5 id="Nginx在CentOs安装"><a href="#Nginx在CentOs安装" class="headerlink" title="Nginx在CentOs安装"></a>Nginx在CentOs安装</h5><pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# yum install yum-utils
[root@iZbp1dssknxftmjczbtpndZ ~]# vim /etc/yum.repos.d/nginx.repo  //输入源信息 告诉它从哪下载
//输入：3-18行 配置源
[root@iZbp1dssknxftmjczbtpndZ ~]# [nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/
gpgcheck=1
enabled=0
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
    //然后查看源 列出可以使用的ngix地址
[root@iZbp1dssknxftmjczbtpndZ ~]# yum list | grep nginx
    //运行安装命令
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install nginx 1:1.16.1-1.el7.ngx
    //查看版本，若出现版本号，则安装成功
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx -v
nginx version: nginx/1.24.0
用whereis nginx可以查看到目录：
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz
</code></pre>
<h3 id="常用命令讲解和演示-1"><a href="#常用命令讲解和演示-1" class="headerlink" title="常用命令讲解和演示"></a>常用命令讲解和演示</h3><pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# /usr/sbin/ngix 启动
[root@iZbp1dssknxftmjczbtpndZ ~]# systemctl stop docker //把之前的docker关停
[root@iZbp1dssknxftmjczbtpndZ ~]# ps -aux | grep nginx //提取相关进程 80是默认端口
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx -h //提取帮助
    
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /etc/nginx
[root@iZbp1dssknxftmjczbtpndZ nginx]# ls //里面有nginx.conf配置文件 conf.d中也有一个defalut.conf
conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params
[root@iZbp1dssknxftmjczbtpndZ nginx]# cd conf.d/
    
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c   //读取指定配置文件
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -s stop //停止nginx
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c /etc/nginx/nginx.conf //以这个文件启动nginx

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -t //发布前的测试
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -s stop
[root@iZbp1dssknxftmjczbtpndZ conf.d]# /usr/sbin/nginx //开启nginx
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -t //查看使用的哪个配置文件
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -v //打印版本信息
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -V //打印详细参数
    
[root@iZbp1dssknxftmjczbtpndZ conf.d]# whereis uginx//找nginx的路径
nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz
[root@iZbp1dssknxftmjczbtpndZ conf.d]# ps aux | grep nginx //打印进程信息

    //-s信号 1.stop立即停止 2.quit优雅停止 3.reload重启[优雅停止quit] 4.reopen更换日志文件
</code></pre>
<h3 id="配置文件讲解-1"><a href="#配置文件讲解-1" class="headerlink" title="配置文件讲解"></a>配置文件讲解</h3><ul>
<li><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li>“; “ 结尾</li>
<li>“{}” 组织多条指令 </li>
<li>“include” 引入</li>
<li>‘’#’’ 注释</li>
</ul>
</li>
<li><h5 id="实操演示"><a href="#实操演示" class="headerlink" title="实操演示"></a>实操演示</h5></li>
<li><h5 id="默认配置文件分析"><a href="#默认配置文件分析" class="headerlink" title="默认配置文件分析"></a>默认配置文件分析</h5><ul>
<li>nginx.conf</li>
<li>default.conf</li>
</ul>
</li>
</ul>
<pre><code class="mysql">[root@iZbp1dssknxftmjczbtpndZ conf.d]# cat /etc/nginx/nginx.conf //打开文件配置
nginx.conf配置文件讲解
首先我们进入到cd etc/nginx.然后通过ls查看nginx目录的相关内容。在nginx目录下，我们需要关注nginx.conf文件，这个文件是我们的主配置文件，cat打开：
cat nginx.conf 【效果显示在下方分割线后】

[root@iZbp1dssknxftmjczbtpndZ conf.d]# cd /usr/share/nginx/html
[root@iZbp1dssknxftmjczbtpndZ html]# vim stst.html //新建文件
[root@iZbp1dssknxftmjczbtpndZ html]# ls
50x.html     index.html
[root@iZbp1dssknxftmjczbtpndZ html# vim test.html //新建一个html文件保存下来
//i编辑       hello nginx           esc + :wq
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c /etc/nginx/nginx.conf //启动！
//如果不显示一定是服务器规则组的问题  自定义 TCP    目的:1/65535   源:0.0.0.0/0
网址输入：http://47.98.225.105/test.html 
============================================================================
# 运行用户，默认是nginx
user  nginx;
# nginx进程数,一般设置为和cpu核数一样
worker_processes  1;

# 全局错误日志路径
error_log  /var/log/nginx/error.log warn;
# 进程pid路径
pid        /var/run/nginx.pid;
 
events &#123;
# 最大连接数
    worker_connections  1024;
&#125;

# 设置http服务器
http &#123;
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
# 设置日志的格式
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
# 访问日志的路径
    access_log  /var/log/nginx/access.log  main;

# 开启高效传输模式
    sendfile        on;
    #tcp_nopush     on;
# 长连接超时时间，单位是秒
    keepalive_timeout  65;
#传输时是否压缩，压缩的话需要解压，但是传的大小就小了
    #gzip  on;
#加载其他的配置文件，一带多
    include /etc/nginx/conf.d/*.conf;
&#125;
============================================================================
</code></pre>
<h3 id="搭建静态资源服务器"><a href="#搭建静态资源服务器" class="headerlink" title="搭建静态资源服务器"></a>搭建静态资源服务器</h3><h5 id="搭建一个静态文件的Nginx服务"><a href="#搭建一个静态文件的Nginx服务" class="headerlink" title="搭建一个静态文件的Nginx服务"></a>搭建一个静态文件的Nginx服务</h5><ul>
<li>实操演示</li>
<li>配置和网页文件作为教辅提供 [静态网页]</li>
</ul>
<pre><code class="java">//scp传输文件 -r每一个文件夹都传递归 /usr/share/nginx/web/ 上传到这个文件夹
cmd本机框
C:\Users\Pluminary&gt; scp -r /Users/Pluminary/Desktop/静态资源/静态网页/ root@47.98.225.105:/usr/share/nginx/web/

cmd服务器框
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/share/nginx/web/
[root@iZbp1dssknxftmjczbtpndZ web]# pwd //查看现在位置
/usr/share/nginx/web
[root@iZbp1dssknxftmjczbtpndZ web]# ls
css  fonts  images  index.html  js
//修改文件 可以让nginx访问到文件 访问web下面的内容
[root@iZbp1dssknxftmjczbtpndZ web]# vim /etc/nginx/conf.d/default.conf  
//修改location：.../web
===============================================================
location / &#123;
        root   /usr/share/nginx/web;
        index  index.html index.htm;
    &#125;

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html &#123;
        root   /usr/share/nginx/web;
    &#125;
===============================================================
[root@iZbp1dssknxftmjczbtpndZ web]# nginx -t //测试一下是否有问题
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@iZbp1dssknxftmjczbtpndZ web]# nginx -s reload //重启服务
//浏览器访问：http://47.98.225.105/index.html
[root@iZbp1dssknxftmjczbtpndZ web]# cat /etc/nginx/nginx.conf
//进去看到 access_log  /var/log/nginx/access.log  main; 打开它
[root@iZbp1dssknxftmjczbtpndZ web]# cat /var/log/nginx/access.log //打开日志文件
</code></pre>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><ul>
<li><h5 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h5></li>
<li><h5 id="RabbitMQ的安装和启动-Erlang语言"><a href="#RabbitMQ的安装和启动-Erlang语言" class="headerlink" title="RabbitMQ的安装和启动 [Erlang语言]"></a>RabbitMQ的安装和启动 [Erlang语言]</h5></li>
<li><h5 id="RabbitMQ管理后台"><a href="#RabbitMQ管理后台" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h5></li>
<li><h5 id="实战案例演示"><a href="#实战案例演示" class="headerlink" title="实战案例演示"></a>实战案例演示</h5></li>
<li><h5 id="交换机工作模式-fanout、direct、topic、headers"><a href="#交换机工作模式-fanout、direct、topic、headers" class="headerlink" title="交换机工作模式 [fanout、direct、topic、headers]"></a>交换机工作模式 [fanout、direct、topic、headers]</h5></li>
<li><h5 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h5></li>
</ul>
<h3 id="初识RabbitMQ-1"><a href="#初识RabbitMQ-1" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h3><ul>
<li><p>核心思想：<strong>接收并转发消息</strong>。类似于<strong>邮局</strong></p>
</li>
<li><p><strong>producer</strong>：<u>信息生产者</u></p>
</li>
<li><p><strong>queue</strong>：<u>队列</u></p>
</li>
<li><p><strong>consumer</strong>：<u>会从queue中获取消息</u></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ca2883b4e8981a89118a71e0e1590f837b4300de/data/RabbitMQ.jpg"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>什么是消息队列</li>
<li><strong>MQ</strong>(Message Queue)</li>
</ul>
<h5 id="消息队列的性质"><a href="#消息队列的性质" class="headerlink" title="消息队列的性质"></a>消息队列的性质</h5><ul>
<li>业务无关 [不需要考虑上层业务模型]</li>
<li>FIFO [先进先出]</li>
<li>容灾 [对于消息队列可以持久化 断电后也可以保存数据后重新发送]</li>
<li>性能</li>
</ul>
<h5 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h5><ul>
<li>系统<strong>解耦</strong></li>
<li><strong>异步</strong>调用 [我告诉你要做 我可以不等你做完 我再返回 <u>相互不影响</u>]<br>[点外卖 用户发送外卖请求給中间件，随后MQ帮助分发后续流程(扣钱、召唤骑手 计算天气、时间等)]</li>
<li>流量<strong>削峰</strong> [MQ把请求先存在队列中 以合适的速度发送 化解压力]</li>
</ul>
<h3 id="RabbitMQ的特点和核心概念"><a href="#RabbitMQ的特点和核心概念" class="headerlink" title="RabbitMQ的特点和核心概念"></a>RabbitMQ的特点和核心概念</h3><ul>
<li>开源、跨语言</li>
<li>Erlang语言编写 [交换机、通信方面] [数据复制与转发性能好]</li>
<li>应用广泛</li>
<li>社区活跃、API丰富</li>
</ul>
<h5 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h5><ul>
<li>Advanced Message Queuing Protocol 高级消息队列协议</li>
</ul>
<h5 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h5><ul>
<li><strong>Server</strong>：服务</li>
<li><strong>connection</strong>：与Server建立连接</li>
<li><strong>channel</strong>：信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道</li>
<li><strong>message</strong>：消息，由properties和body组成</li>
<li><strong>virtual host</strong>：虚拟主机，顶层隔离。同一个虚拟主机下，不能由重复的交换机和queue</li>
<li><strong>Exchange</strong>：交换机，接收生产者的信息的，然后根据指定的路由器把消息转发到所绑定的队列上</li>
<li><strong>binding</strong>：绑定交换机和队列</li>
<li><strong>routing key</strong>：路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个路由</li>
<li><strong>queue</strong>：队列，消费者只需要监听队列来消费消息，不需要关注消息来自于哪个Exchange</li>
<li>Exchange和Message Queue存在着绑定的关系，一个Exchange可以绑定多个消息队列</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8fc65400c147b4cda128b49a11d646330a5860fc/data/RabiitMQ%E6%B6%88%E6%81%AF%E6%B5%81%E8%BD%AC%E6%96%B9%E5%BC%8F.jpg"></p>
<h3 id="RabbitMQ的安装和启动"><a href="#RabbitMQ的安装和启动" class="headerlink" title="RabbitMQ的安装和启动"></a>RabbitMQ的安装和启动</h3><ul>
<li>安装<strong>Erlang</strong></li>
<li><strong>安装</strong>RabbitMQ</li>
<li><strong>启动</strong>RabbitMQ</li>
</ul>
<h5 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h5><ul>
<li>安装erlang-rpm包，该包经过RabbitMQ官方处理</li>
<li>使用Erlang Solutions源进行安装</li>
<li>使用EPEL(“Extra Packages for Enterprise Linux”)进行安装</li>
</ul>
<pre><code class="java">我们先准备两个安装包：//★★★★别看下面胡咧咧 直接教辅中有erlang和rabbitmq与教材相同★★★★
RabbitMQ： https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.13
Erlang：https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm

注意： 如果说你选的是最新的版本那么你就要选取对应支持的 erlang 的版本才行，具体看下面的连接
https://www.rabbitmq.com/which-erlang.html

这些都准备好之后我们使用 Xptf 软件把这个安装包传输到 linux 端对应文件下（自己建一个文件夹）即可。

安装
第一步：
我们第一步先要对 linux 端进行一个 erlang 的环境配置，所以我们要先解压 erlang 包。
    # rpm -Uvh erlang-solutions-2.0-1.noarch.rpm
    # yum install -y erlang
安装完成后，查看一下版本号，能查到说明就是安装好了
    # erl -v

第二步：
在安装一下
    # yum install -y socat

第三步：
接下来我们就需要进行 RabbitMQ 的安装了

    # rpm -Uvh rabbitmq-server-3.8.33-1.el8.noarch.rpm 
    # yum install rabbitmq-server -y

安装完之后我们来启动测试一下：

    # systemctl start rabbitmq-server
    # systemctl status rebbitmq-server

最后一步：
安装跑起来之后我们设置一下开机自启动

    # systemctl enable rabbitmq-server
    # systemctl stop rabbitmq-server   # 关闭开机自起
=========================================================
可以在这些目录中查找RabbitMQ的配置文件、启动脚本等。另外，RabbitMQ的启动脚本通常会被安装到/usr/sbin或/usr/bin目录下。你可以尝试使用以下命令来查找RabbitMQ的启动脚本位置：

find /usr/sbin /usr/bin -name &#39;rabbitmq*&#39;
=========================================================
</code></pre>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/sbin
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl start rabbitmq-server
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl status rabbitmq-server
● rabbitmq-server.service - RabbitMQ broker
   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)
   Active: active (running) since Mon 2024-04-08 23:24:39 CST; 38min ago
 Main PID: 3570 (beam.smp)
===================================================================================
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl enable rabbitmq-server
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl stop rabbitmq-server   # 关闭开机自起
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_57828911/article/details/131777471?ops_request_misc=%7B%22request_id%22:%22171259388816800186514596%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171259388816800186514596&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-131777471-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=linux%E5%8D%B8%E8%BD%BDrabbitmq&spm=1018.2226.3001.4187">Linux环境如何彻底卸载感干净RabbitMQ_linux卸载rabbitmq-CSDN博客</a></p>
<pre><code class="java">停止RabbitMQ
$rabbitmqctl stop

设置开机启动
$ systemctl enable rabbitmq-server 

启动RabbitMQ
$ systemctl start rabbitmq-server

看看端口有没有起来，查看状态

$ rabbitmqctl status 

要检查RabbitMQ服务器的状态，请运行：

systemctl status rabbitmq-server

开启web管理界面
rabbitmq-plugins enable rabbitmq_management
</code></pre>
<h3 id="RabbitMQ管理后台-1"><a href="#RabbitMQ管理后台-1" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h3><h5 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h5><ul>
<li>启动RabbitMQ：<code>systemctl start rabbitmq-server</code></li>
<li>查看状态：<code>rabbitmqctl status</code></li>
<li>启动管理台</li>
<li>配置admin用户</li>
</ul>
<pre><code class="mysql">[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmq-plugins enable rabbitmq_management
Enabling plugins on node rabbit@iZbp1dssknxftmjczbtpndZ:
rabbitmq_management
The following plugins have been configured:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@iZbp1dssknxftmjczbtpndZ...
Plugin configuration unchanged. ##添加账户
[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmqctl add_user admin password
Adding user &quot;admin&quot; ...            ##设置管理员
[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmqctl set_user_tags admin administrator
Setting tags for user &quot;admin&quot; to [administrator] ...
浏览器进入RabbitMQ管理后台 输入 http://47.98.225.105:15672/
</code></pre>
<h5 id="RabbitMQ管理后台-2"><a href="#RabbitMQ管理后台-2" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h5><ul>
<li>浏览页面</li>
<li>添加用户</li>
<li>创建虚拟主机(Virtual Hosts) &#x3D;&gt; 都有各自的队列、交换机</li>
</ul>
<h3 id="第一个生产者"><a href="#第一个生产者" class="headerlink" title="第一个生产者"></a>第一个生产者</h3><h5 id="实战案例演示-1"><a href="#实战案例演示-1" class="headerlink" title="实战案例演示"></a>实战案例演示</h5><ul>
<li>新建项目</li>
<li>Hello World<br>P(生产者)→hello→C(消费者)</li>
<li>创建一个rabbitmq(Maven)新项目</li>
<li>rabbitmq支持多语言</li>
</ul>
<pre><code class="java">登录上RabbitMQ后台 上面Admin 右面Virtual Hosts 
点表里的 /  下面增加一个admin

pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;rabbitmq&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;20&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;20&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
            &lt;version&gt;5.8.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;
            &lt;version&gt;1.7.29&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">helloworld/send.java
package helloworld;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Hello World的发送类，连接到RabbitMQ服务端，然后发送一条消息后退出
 */
public class send &#123;
    //队列名字
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(QUEUE_NAME,false,false,false,null);
        //发布消息
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + message);
        //关闭连接
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">helloworld/Recv.java
package helloworld;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;
import java.io.IOException;

/**
 * 接收消息，并打印，持续运行
 */
public class Recv &#123;
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws Exception &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        //接收消息并消费 2:是否确认收到(快递签收 自动消息确认) 3：消息收到后进行处理
        channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) &#123;
            //收到信息后会执行的函数
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body)
                    throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot; + message);
            &#125;
        &#125;);
    &#125;
&#125;
=======================================================
//由于是持续接收消息的 若将send.java中改为Hello World2 将会持续打印到控制台
开始接收消息
收到消息：Hello World!
收到消息：Hello World2!
</code></pre>
<h3 id="根据消息内容做处理"><a href="#根据消息内容做处理" class="headerlink" title="根据消息内容做处理"></a>根据消息内容做处理</h3><h5 id="多个消费者分担压力"><a href="#多个消费者分担压力" class="headerlink" title="多个消费者分担压力"></a>多个消费者分担压力</h5><p><strong>RabbitMQ后台</strong><a target="_blank" rel="noopener" href="http://47.98.225.105:15672/">http://47.98.225.105:15672/</a></p>
<h6 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h6><pre><code class="java">workqueues/NewTask.java
package workqueues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 生产者：生产批量消息
 */
public class NewTask &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME,true,false,false,null);
        for (int i = 0; i &lt; 10; i++) &#123;
            String message = i + &quot;...&quot;;
            channel.basicPublish(&quot;&quot;,TAKS_QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;发送了消息：&quot; + message);
        &#125;
        //关闭连接
        channel.close();
        connection.close();
    &#125;
&#125;
=============================================================================================
发送了消息：0...
发送了消息：1...
发送了消息：2...
发送了消息：3...
发送了消息：4...
发送了消息：5...
发送了消息：6...
发送了消息：7...
发送了消息：8...
发送了消息：9...
</code></pre>
<pre><code class="java">workqueues/Worker.java
package workqueues;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 消费者，接收前面的批量消息
 */
public class Worker &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME, true, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        channel.basicConsume(TAKS_QUEUE_NAME, true, new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到了消息：&quot; + message);
                try&#123;
                    doWork(message);
                &#125;finally &#123;
                    System.out.println(&quot;完成消息处理&quot;);
                &#125;
            &#125;
        &#125;);
    &#125;

    private static void doWork(String task) &#123;
        //有点延迟1秒
        char[] chars = task.toCharArray();
        for (char ch : chars) &#123;
            if (ch == &#39;.&#39;) &#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
==========================================================================================
收到了消息：0...
完成消息处理
收到了消息：1...
完成消息处理
收到了消息：2...
完成消息处理
收到了消息：3...
完成消息处理
收到了消息：4...
完成消息处理
收到了消息：5...
完成消息处理
收到了消息：6...
完成消息处理
收到了消息：7...
完成消息处理
收到了消息：8...
完成消息处理
收到了消息：9...
完成消息处理
</code></pre>
<h5 id="并行-多个消费者平均压力！！！"><a href="#并行-多个消费者平均压力！！！" class="headerlink" title="并行 多个消费者平均压力！！！"></a>并行 多个消费者平均压力！！！</h5><h6 id="公平派遣-因为奇数偶数压力不同-消息确认-【以工作量的程度去分任务】"><a href="#公平派遣-因为奇数偶数压力不同-消息确认-【以工作量的程度去分任务】" class="headerlink" title="公平派遣[因为奇数偶数压力不同] + 消息确认 【以工作量的程度去分任务】"></a>公平派遣[因为奇数偶数压力不同] + 消息确认 【<u>以工作量的程度去分任务</u>】</h6><pre><code class="java">//在Worker消费方打开并行消费 Run/Debug Configurations → Modify options蓝字 → Allow multiple instances             此时两个woker开始配合平均压力 一起工作
workqueues/Worker.java
package workqueues;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 消费者，接收前面的批量消息
 */
public class Worker &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME, true, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        channel.basicQos(1); //最希望处理的数量 处理完之前不会接收下一个任务
        channel.basicConsume(TAKS_QUEUE_NAME, false, new DefaultConsumer(channel) &#123; //关掉自动接收 要手动确认false
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到了消息：&quot; + message);
                try&#123;
                    doWork(message);
                &#125;finally &#123;
                    System.out.println(&quot;完成消息处理&quot;);
                    channel.basicAck(envelope.getDeliveryTag(), false); //false 不同时一起确认 手动确认消息
                &#125;
            &#125;
        &#125;);
    &#125;

    private static void doWork(String task) &#123;
        //有点延迟1秒
        char[] chars = task.toCharArray();
        for (char ch : chars) &#123;
            if (ch == &#39;.&#39;) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
=======================================================================================
开始接收消息
收到了消息：1
消息处理完成
收到了消息：2...
消息处理完成
......
</code></pre>
<h3 id="交换机工作模式"><a href="#交换机工作模式" class="headerlink" title="交换机工作模式"></a>交换机工作模式</h3><ul>
<li><strong>fanout</strong>：广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的</li>
<li><strong>direct</strong>：根据RoutingKey匹配消息路由到指定队列</li>
<li><strong>topic</strong>：生产者指定RoutingKey消息根据消费端指定的队列通过模糊匹配的方式进行相应转发</li>
<li><strong>headers</strong>：根据发送消息内容中的headers属性来匹配</li>
</ul>
<h5 id="fanout模式"><a href="#fanout模式" class="headerlink" title="fanout模式"></a>fanout模式</h5><h6 id="广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的-所有消息无差别发送"><a href="#广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的-所有消息无差别发送" class="headerlink" title="广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的 [所有消息无差别发送]"></a>广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的 [所有消息无差别发送]</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/3aa53b6e78e1fd67145c5d2acf905c22eee0b44a/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-fanout.png"></p>
<pre><code class="java">fanout/EmitLog.java【生产者】
package fanout;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 发送日志信息
 */
public class EmitLog &#123;
    //创建交换机
    private static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        String message = &quot;info: Hello World！&quot;;
        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + message);
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">fanout/ReceiveLogs.java【消费者】
package fanout;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 描述：接收日志消息 有多个接收同样的消息
 */
public class ReceiveLogs &#123;
    private static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        //非持久会自动删除的队列 在同一个类中多次启动 每一次队列名字都不一样
        String queueName = channel.queueDeclare().getQueue();
        //交换机和队列的绑定
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);
        System.out.println(&quot;开始接收消息&quot;);
        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
</code></pre>
<h5 id="direct模式"><a href="#direct模式" class="headerlink" title="direct模式"></a>direct模式</h5><h6 id="根据RoutingKey匹配消息路由到指定队列-消费者接收消息不一致"><a href="#根据RoutingKey匹配消息路由到指定队列-消费者接收消息不一致" class="headerlink" title="根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]"></a>根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/df64342f867398846ad29a0cb944a8490cd247b0/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-direct.jpg"></p>
<pre><code class="java">direct/ReceiveLogsDirect1.java
package direct;

import com.rabbitmq.client.*;

import java.io.IOException;

/**
 * 接收3个等级的日志
 */
public class ReceiveLogsDirect1 &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        //生成一个随机的临时的queue
        String queueName = channel.queueDeclare().getQueue();

        //一个交换机同时绑定三个queue
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;error&quot;);

        System.out.println(&quot; 开始接收消息&quot;);

        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
=============================================================================
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
</code></pre>
<pre><code class="java">direct/ReceiveLogsDirect2.java
package direct;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;
import java.io.IOException;

/**
 * 接收1个等级的日志
 */
public class ReceiveLogsDirect2 &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        //生成一个随机的临时的queue
        String queueName = channel.queueDeclare().getQueue();

        //一个交换机同时绑定两个queue，比刚第一个Receiver少接收了一个error等级
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
=============================================================================
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
</code></pre>
<pre><code class="java">direct/EmitLogDirect.java
package direct;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class EmitLogDirect &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机 DIRECT
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        String message = &quot;Hello World！&quot;;
        //发送第一个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;info&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为info,消息内容：&quot; + message);

        //发送第二个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;warning&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为warning,消息内容：&quot; + message);

        //发送第三个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;error&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为error,消息内容：&quot; + message);
        channel.close();
        connection.close();
    &#125;
&#125;
=============================================================================
发送了消息：等级为info,消息内容：Hello World！
发送了消息：等级为warning,消息内容：Hello World！
发送了消息：等级为error,消息内容：Hello World！
</code></pre>
<h5 id="topic模式"><a href="#topic模式" class="headerlink" title="topic模式"></a><span style = "color:red"><strong>topic模式</strong></span></h5><h6 id="比如消息严重性怎么样、只想记录error模块的用户信息"><a href="#比如消息严重性怎么样、只想记录error模块的用户信息" class="headerlink" title="比如消息严重性怎么样、只想记录error模块的用户信息"></a>比如消息严重性怎么样、只想记录error模块的用户信息</h6><ul>
<li>***** 可以替代一个单词</li>
<li><strong>#</strong> 可以替代零个或多个单词</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76b7e6d6ebbac01f8f73850149fefbf50ca51712/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-topic%E7%94%9F%E4%BA%A7%E8%80%85.jpg"></p>
<pre><code class="java">【发送者/生产者】
topic/EmitLogTopic.java
package topic;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

/**
 * topic模式交换机，发送消息
 */
public class EmitLogTopic &#123;

    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) &#123;
        Connection connection = null;
        Channel channel = null;
        try &#123;
            ConnectionFactory factory = new ConnectionFactory();
            factory.setHost(&quot;47.98.225.105&quot;);
            factory.setUsername(&quot;admin&quot;);
            factory.setPassword(&quot;password&quot;);

            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);

            String message = &quot;Animal WorldroutingKey&quot;;

            String[] routingKeys = new String[9];
            routingKeys[0] = &quot;quick.orange.rabbit&quot;;
            routingKeys[1] = &quot;lazy.orange.elephant&quot;;
            routingKeys[2] = &quot;quick.orange.fox&quot;;
            routingKeys[3] = &quot;lazy.brown.fox&quot;;
            routingKeys[4] = &quot;lazy.pink.rabbit&quot;;
            routingKeys[5] = &quot;quick.brown.fox&quot;;
            routingKeys[6] = &quot;orange&quot;;
            routingKeys[7] = &quot;quick.orange.male.rabbit&quot;;
            routingKeys[8] = &quot;lazy.orange.male.rabbit&quot;;
            for (int i = 0; i &lt; routingKeys.length; i++) &#123;
                channel.basicPublish(EXCHANGE_NAME, routingKeys[i], null,
                        message.getBytes(&quot;UTF-8&quot;));
                System.out.println(&quot;发送了：&quot; + message + &quot;:&quot; + routingKeys[i]);
            &#125;


        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (connection != null) &#123;
                try &#123;
                    connection.close();
                &#125; catch (Exception ignore) &#123;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
==================================================================================
发送了：Animal WorldroutingKey:quick.orange.rabbit
发送了：Animal WorldroutingKey:lazy.orange.elephant
发送了：Animal WorldroutingKey:quick.orange.fox
发送了：Animal WorldroutingKey:lazy.brown.fox
发送了：Animal WorldroutingKey:lazy.pink.rabbit
发送了：Animal WorldroutingKey:quick.brown.fox
发送了：Animal WorldroutingKey:orange
发送了：Animal WorldroutingKey:quick.orange.male.rabbit
发送了：Animal WorldroutingKey:lazy.orange.male.rabbit
</code></pre>
<pre><code class="java">【接收者/消费者Ⅰ(对&quot;*.orange.*&quot; 数据感兴趣)】
package topic;

import com.rabbitmq.client.*;

import java.io.IOException;
/**
 * 特定路由键
 */
public class ReceiveLogsTopic1 &#123;
    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        String queueName = channel.queueDeclare().getQueue();

        //指定bindingKey 最重要的一步！
        String bindingKey = &quot;*.orange.*&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer = new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                    AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(
                        &quot; 接收消息： &quot; + message + &quot;:&quot; + envelope.getRoutingKey());
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
==================================================================================
开始接收消息
 接收消息： Animal WorldroutingKey:quick.orange.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.elephant
 接收消息： Animal WorldroutingKey:quick.orange.fox
</code></pre>
<pre><code class="java">【接收者/消费者Ⅱ(对&quot;*.*.rabbit&quot; 和 &quot;lazy.#&quot; 数据感兴趣)】
package topic;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;

import java.io.IOException;
/**
 * 特定路由键
 */
public class ReceiveLogsTopic2 &#123;

    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        String queueName = channel.queueDeclare().getQueue();

        //指定bindingKey
        String bindingKey1 = &quot;*.*.rabbit&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey1);
        String bindingKey2 = &quot;lazy.#&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey2);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer = new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                    AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(
                        &quot; 接收消息： &quot; + message + &quot;:&quot; + envelope.getRoutingKey());
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
==================================================================================
开始接收消息
 接收消息： Animal WorldroutingKey:quick.orange.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.elephant
 接收消息： Animal WorldroutingKey:lazy.brown.fox
 接收消息： Animal WorldroutingKey:lazy.pink.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.male.rabbit
</code></pre>
<ul>
<li><h6 id="headers：根据发送消息内容中的headers属性来匹配"><a href="#headers：根据发送消息内容中的headers属性来匹配" class="headerlink" title="headers：根据发送消息内容中的headers属性来匹配"></a>headers：根据发送消息内容中的headers属性来匹配</h6></li>
</ul>
<h3 id="Spring-Boot整合RabbitMQ"><a href="#Spring-Boot整合RabbitMQ" class="headerlink" title="Spring Boot整合RabbitMQ"></a>Spring Boot整合RabbitMQ</h3><ul>
<li><h6 id="实操代码演示"><a href="#实操代码演示" class="headerlink" title="实操代码演示"></a>实操代码演示</h6></li>
</ul>
<blockquote>
<p>创建两个Springboot项目<br>spring-boot-rabbitmq-consumer 和 spring-boot-rabbitmq-consumer<br>在application.properties中设置 如果是本机用户名和密码都是guest<br>spring.rabbitmq.username&#x3D;guest</p>
</blockquote>
<h6 id="项目：spring-boot-rabbitmq-producer-消息发送者-x2F-生产者"><a href="#项目：spring-boot-rabbitmq-producer-消息发送者-x2F-生产者" class="headerlink" title="项目：spring-boot-rabbitmq-producer [消息发送者&#x2F;生产者]"></a>项目：spring-boot-rabbitmq-producer [消息发送者&#x2F;生产者]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-rabbitmq-consumer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-rabbitmq-consumer&lt;/name&gt;
    &lt;description&gt;spring-boot-rabbitmq-consumer&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties
spring.application.name=spring-boot-rabbitmq-producer
server.port=8080
spring.rabbitmq.addresses=127.0.0.1:5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000
</code></pre>
<pre><code class="java">com/imooc/springbootrabbitmqproducer/MsgSender.java
package com.imooc.springbootrabbitmqproducer;

import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * 发送消息
 */
//@Component让springboot发现
@Component
public class MsgSender &#123;
    @Autowired
    private AmqpTemplate rabbitmqTemplate;
    public void send1()&#123;
        String message = &quot;This is message 1, routing key is dog.red&quot;;
        System.out.println(&quot;发送了：&quot; + message);
        //指定交换机的名字  routing key is dog.red  消息内容
        this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;,&quot;dog.red&quot;,message);
    &#125;
    public void send2()&#123;
        String message = &quot;This is message 2, routing key is dog.black&quot;;
        System.out.println(&quot;发送了：&quot; + message);
        //指定交换机的名字  routing key is dog.red  消息内容
        this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;,&quot;dog.black&quot;,message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootrabbitmqproducer/TopicRabbitConfig.java
package com.imooc.springbootrabbitmqproducer;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


/**
 * rabbitmq配置类
 */
@Configuration
public class TopicRabbitConfig &#123;
    @Bean
    public Queue queue1()&#123;
        return new Queue(&quot;queue1&quot;);
    &#125;
    @Bean
    public Queue queue2()&#123;
        return new Queue(&quot;queue2&quot;);
    &#125;
    //用一个Bean定义交换机
    @Bean
    TopicExchange exchange()&#123;
        return new TopicExchange(&quot;bootExchange&quot;);
    &#125;

    //有了Q1 Q2后去指定一个topic交换机
    //绑定到交换机上
    @Bean
    Binding bingdingExchangeMessage1(Queue queue1, TopicExchange exchange)&#123;
        //to绑定到哪个交换机 with指定routingKey
        return BindingBuilder.bind(queue1()).to(exchange).with(&quot;dog.red&quot;);
    &#125;
    @Bean
    Binding bingdingExchangeMessage2(Queue queue2, TopicExchange exchange)&#123;
        //to绑定到哪个交换机 with指定routingKey
        return BindingBuilder.bind(queue2()).to(exchange).with(&quot;dog.#&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">用test的测试类
com/imooc/springbootrabbitmqproducer/SpringBootRabbitmqProducerApplicationTests.java
package com.imooc.springbootrabbitmqproducer;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SpringBootRabbitmqProducerApplicationTests &#123;

    @Autowired
    MsgSender msgSender;

    @Test
    public void send1()&#123;
        msgSender.send1();
    &#125;
    @Test
    public void send2()&#123;
        msgSender.send2();
    &#125;
&#125;
</code></pre>
<h6 id="项目：spring-boot-rabbitmq-consumer-消息接收者-x2F-消费者"><a href="#项目：spring-boot-rabbitmq-consumer-消息接收者-x2F-消费者" class="headerlink" title="项目：spring-boot-rabbitmq-consumer [消息接收者&#x2F;消费者]"></a>项目：spring-boot-rabbitmq-consumer [消息接收者&#x2F;消费者]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-rabbitmq-consumer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-rabbitmq-consumer&lt;/name&gt;
    &lt;description&gt;spring-boot-rabbitmq-consumer&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties
spring.application.name=spring-boot-rabbitmq-consumer
server.port=8081
spring.rabbitmq.addresses=127.0.0.1:15672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000
</code></pre>
<pre><code class="java">Receiver1.java
package com.imooc.springbootrabbitmqconsumer;

import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 消费者1
 */
@Component
@RabbitListener(queues = &quot;queue1&quot;)
public class Receiver1 &#123;
    @RabbitHandler //收到这个消息后怎么处理
    public void process(String message)&#123;
        System.out.println(&quot;Receiver1：&quot; + message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Receiver2.java
package com.imooc.springbootrabbitmqconsumer;

import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 消费者2
 */
@Component
@RabbitListener(queues = &quot;queue2&quot;)
public class Receiver2 &#123;
    @RabbitHandler //收到这个消息后怎么处理
    public void process(String message)&#123;
        System.out.println(&quot;Receiver2：&quot; + message);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>先启动消费者 然后再启动生产者test中的测试<br>就可以发现<br>send1() → 发送了：This is message 1, routing key is dog.red<br>send2() → 发送了：This is message 2, routing key is dog.black</p>
</blockquote>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/04/04/后端/多线程与分布式/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/02/28/后端/SpringBoot入门及电商项目[SpringBoot_MyBatis.generator_Swagger2_Redis_Postman_RESTful_AOP_UUID_QRCode_Linux_Aliyun]/">
        <h2>
            SpringBoot入门及电商项目[SpringBoot_MyBatis.generator_Swagger2_Redis_Postman_RESTful_AOP_UUID_QRCode_Linux_Aliyun]
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/2/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring-Boot电商项目入门与实战"><a href="#Spring-Boot电商项目入门与实战" class="headerlink" title="Spring Boot电商项目入门与实战"></a>Spring Boot电商项目入门与实战</h1><ul>
<li>重量级的电商项目，前后端彻底分离</li>
<li>体验企业级开发流程：需求分析、设计、编码、测试、上线</li>
<li>用户管理、商品分析、商品管理、购物车、订单等核心功能</li>
<li>数据库的设计与实现</li>
<li>应用<strong>RESTful</strong>进行接口设计，并使用<strong>Postman</strong>进行接口测试</li>
<li>应用<strong>MyBatis generator</strong>代码自动生成插件，提升开发效率</li>
<li>使用阿里云完成项目的线上部署</li>
<li>使用<strong>Swagger2</strong>构建强大的API文档</li>
<li>使用<strong>Redis</strong>对商品分类信息进行缓存</li>
<li>使用<strong>JSR-303</strong>实现请求参数校验</li>
</ul>
<h2 id="Spring-Boot入门"><a href="#Spring-Boot入门" class="headerlink" title="Spring Boot入门"></a>Spring Boot入门</h2><h5 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h5><ul>
<li>Java 1.8.0</li>
<li>MySQL 8.0.12</li>
<li>Maven 3.3.9</li>
<li>Spring Boot 2.2.1(严格一致)</li>
</ul>
<h3 id="Spring-Boot诞生历史"><a href="#Spring-Boot诞生历史" class="headerlink" title="Spring Boot诞生历史"></a>Spring Boot诞生历史</h3><ul>
<li>Spring的缺点：配置过于繁琐</li>
<li>Spring Boot开发团队：Pivotal</li>
</ul>
<h3 id="Spring-Boot简介"><a href="#Spring-Boot简介" class="headerlink" title="Spring Boot简介"></a>Spring Boot简介</h3><ul>
<li>简化初始搭建以及开发过程</li>
<li>不再需要定义样板化的配置</li>
<li>快速应用开发领域</li>
</ul>
<h3 id="Spring、Spring-MVC、Spring-Boot"><a href="#Spring、Spring-MVC、Spring-Boot" class="headerlink" title="Spring、Spring MVC、Spring Boot"></a>Spring、Spring MVC、Spring Boot</h3><ul>
<li><strong>Spring</strong>最初利用IOC和AOP解耦</li>
<li>按照这种模式搞了MVC框架</li>
<li>写很多样板代码很麻烦，就有了<strong>Spring Boot</strong></li>
<li><strong>Spring Cloud</strong>是在Spring Boot基础上</li>
</ul>
<h3 id="Spring-Boot核心特点"><a href="#Spring-Boot核心特点" class="headerlink" title="Spring Boot核心特点"></a>Spring Boot核心特点</h3><ul>
<li>开箱即用</li>
<li>约定优于配置</li>
</ul>
<h3 id="Spring-Boot版本介绍"><a href="#Spring-Boot版本介绍" class="headerlink" title="Spring Boot版本介绍"></a>Spring Boot版本介绍</h3><ul>
<li>CURRENT             2.2.1 CURRENT GA [最新版本]</li>
<li>GA                         2.2.2 SNAPSHOT [GA&#x3D;General Availability 面向大众稳定版本 版本永恒不变]</li>
<li>SNAPSHOT          2.1.11 SNAPSHOT [快照 版本随时被修改]</li>
<li>如何选择版本？   <strong>2.1.10 GA</strong></li>
</ul>
<h3 id="新建Spring-Boot项目演示"><a href="#新建Spring-Boot项目演示" class="headerlink" title="新建Spring Boot项目演示"></a>新建Spring Boot项目演示</h3><ul>
<li>Spring官网 <strong><a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a></strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c9c72f61bc8fdb6d207a1221c3e2fb6ed9dcad81/data/%E6%96%B0%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%BC%94%E7%A4%BA.jpg"></p>
<ul>
<li>IDEA集成的Spring Initializr</li>
</ul>
<h3 id="第一个接口开发"><a href="#第一个接口开发" class="headerlink" title="第一个接口开发"></a>第一个接口开发</h3><pre><code class="java">com/imooc/springbootlearn/SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringBootlearnApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;

&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/ParaController.java
package com.imooc.springbootlearn;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 演示各种传参形式
 */
@RestController
public class ParaController &#123;
    @GetMapping(&#123;&quot;/firstrequest&quot;&#125;)
    public String firstRequest()&#123;
        return &quot;第一个Spring Boot接口&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;SpringBootlearn&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;SpringBootlearn&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id="多种配置URL的方式"><a href="#多种配置URL的方式" class="headerlink" title="多种配置URL的方式"></a>多种配置URL的方式</h3><pre><code class="java">com/imooc/springbootlearn/ParaController.java
package com.imooc.springbootlearn;

import org.springframework.web.bind.annotation.*;

/**
 * 演示各种传参形式
 */
@RestController
@RequestMapping(&quot;/prefix&quot;)//统一增加公共前缀
public class ParaController &#123;
    @GetMapping(&#123;&quot;/firstrequest&quot;&#125;)
    public String firstRequest() &#123;
        return &quot;第一个Spring Boot接口&quot;;
    &#125;

    //@RequestParam 从请求中找到这个参数进行绑定
    @GetMapping(&#123;&quot;/requestpara&quot;&#125;)
    public String requestpara(@RequestParam Integer num) &#123;
        return &quot;para from request: &quot; + num;
    &#125;

    //@PathVariable 从URL中寻找对应的参数进行绑定
    @GetMapping(&#123;&quot;/para/&#123;num&#125;&quot;&#125;)
    public String pathpara(@PathVariable Integer num) &#123;
        return &quot;para from path: &quot; + num;
    &#125;

    //多URL的用法
    @GetMapping(&#123;&quot;/multiurl1&quot;, &quot;/multiurl2&quot;&#125;)
    public String multiurl(@RequestParam Integer num) &#123;
        return &quot;para from path: &quot; + num;
    &#125;

    //增加程序健壮性 不一定必须传值
    @GetMapping(&#123;&quot;/required&quot;&#125;)
    public String required(@RequestParam(required =
            false, defaultValue = &quot;0&quot;) Integer num) &#123;
        return &quot;para form request: &quot; + num;
    &#125;
&#125;
</code></pre>
<h3 id="Web项目的三层结构"><a href="#Web项目的三层结构" class="headerlink" title="Web项目的三层结构"></a>Web项目的三层结构</h3><ul>
<li><strong>Controller职责</strong>：对外暴露接口</li>
<li><strong>Service职责</strong>：复杂业务场景下对业务逻辑做一层抽象和封装，保持Controller的简洁和独立，抽象出来的Service可以被Controller重复调用。具体业务代码写在service层，Controller只做简单的逻辑判断</li>
<li><strong>DAO层职责</strong>：和数据相关的、增删改查数据库代码</li>
</ul>
<h3 id="配置文件简介"><a href="#配置文件简介" class="headerlink" title="配置文件简介"></a>配置文件简介</h3><ul>
<li><p><strong>properties</strong>：容器端口名、数据库信息、日志级别…</p>
<ul>
<li>environments.dev.url&#x3D;<a target="_blank" rel="noopener" href="http://imooc.com/">http://imooc.com</a></li>
<li>environments.dev.name&#x3D;Developer</li>
</ul>
</li>
<li><p><strong>yml</strong>：分层级，冒号后需要空格</p>
<ul>
<li>enviroments:<ul>
<li>dev:<ul>
<li>url: <a target="_blank" rel="noopener" href="http://imooc.com/">http://imooc.com</a></li>
<li>name: Developer</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以自动转换的网址：<a target="_blank" rel="noopener" href="https://www.toyaml.com/">在线yaml转properties-在线properties转yaml-ToYaml.com</a></p>
<pre><code class="java">Properties:
server.port=8081
server.servlet.context-path=/first
============================================================
YAML:
server:
  port: 8081
  servlet:
    context-path: /first
</code></pre>
<h3 id="进行自定义配置"><a href="#进行自定义配置" class="headerlink" title="进行自定义配置"></a>进行自定义配置</h3><p><strong>注解类</strong>配置载入数据[利用@Value注解]</p>
<pre><code class="java">com/imooc/springbootlearn/PropertiesController.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 演示读取配置的Controller
 */
@RestController
public class PropertiesController &#123;
    //用@Value将properties的设置值进行绑定
    @Value(&quot;$&#123;school.grade&#125;&quot;)
    Integer grade;
    @Value(&quot;$&#123;school.classnum&#125;&quot;)
    Integer classnum;
    @GetMapping(&quot;/gradeclass&quot;)
    public String gradeClass()&#123;
        return &quot;年级： &quot; + grade + &quot; 班级：&quot; + classnum;
    &#125;
&#125;
</code></pre>
<pre><code class="java">resoources/application.properties
#server.port=8081
##对于整个项目建立统一的前缀 http://127.0.0.1:8081/first/prefix/required
#server.servlet.context-path=/first
#school.方便分类
school.grade=3
school.classnum=6
</code></pre>
<p><strong>配置类</strong>文件配置载入数据</p>
<pre><code class="java">com/imooc/springbootlearn/SchoolConfig.java
package com.imooc.springbootlearn;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * School配置类
 */
@Component
@ConfigurationProperties(prefix = &quot;school&quot;)
public class SchoolConfig &#123;
    //自动去配置信息里寻找且绑定
    Integer grade;
    Integer classnum;

    public Integer getGrade() &#123;
        return grade;
    &#125;

    public void setGrade(Integer grade) &#123;
        this.grade = grade;
    &#125;

    public Integer getClassnum() &#123;
        return classnum;
    &#125;

    public void setClassnum(Integer classnum) &#123;
        this.classnum = classnum;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/ConfigController.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 读取配置类
 */
@RestController
public class ConfigController &#123;
    @Autowired
    SchoolConfig schoolConfig;
    @GetMapping(&#123;&quot;/gradefromconfig&quot;&#125;)
    public String gradeclass()&#123;
        return &quot;年级： &quot; + schoolConfig.grade + &quot; 班级：&quot; + schoolConfig.classnum;

    &#125;
&#125;
</code></pre>
<h3 id="Service和Dao的编写"><a href="#Service和Dao的编写" class="headerlink" title="Service和Dao的编写"></a>Service和Dao的编写</h3><ul>
<li><h5 id="学生信息查询案例"><a href="#学生信息查询案例" class="headerlink" title="学生信息查询案例"></a>学生信息查询案例</h5></li>
</ul>
<pre><code class="java">com/imooc/springbootlearn/Student.java
package com.imooc.springbootlearn;

/**
 * 学生实体类
 */
public class Student &#123;
    Integer id;
    String name;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/StudentController.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 学生Controller
 */
@RestController
public class StudentController &#123;
    @Autowired
    StudentService studentService;
    //服务层 去中转

    @GetMapping(&quot;/student&quot;)
    public String student(@RequestParam Integer num)&#123;
        Student student = studentService.findStudent(num);
        return student.toString();
    &#125;
&#125;
/*
联系
@Autowired和@Resource注解都是作为bean对象注入的时候使用的
两者都可以声明在字段和setter方法上
注意：如果声明在字段上，那么就不需要再写setter方法。但是本质上，该对象还是作为set方法的实参，通过执行set方法注入，只是省略了setter方法罢了

区别
@Autowired注解是Spring提供的，而@Resource注解是J2EE本身提供的
@Autowird注解默认通过byType方式注入，而@Resource注解默认通过byName方式注入
@Autowired注解注入的对象需要在IOC容器中存在，否则需要加上属性required=false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错
*/
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/StudentService.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 学生Service  之后调用mapper操作数据库[interface]
 */
@Service
public class StudentService &#123;
    @Autowired
    StudentMapper studentMapper;

    public Student findStudent(Integer id)&#123;
        return studentMapper.findById(id);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/StudentMapper.java 【接口】
package com.imooc.springbootlearn;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

/**
 * 学生Mapper
 */
@Mapper
@Repository
public interface StudentMapper &#123;
    @Select(&quot;select * from students where id = #&#123;id&#125;&quot;)
    Student findById(Integer id);
&#125;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;springbootlearn&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;SpringBootlearn&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages=&quot;com.imooc&quot;)
public class SpringBootlearnApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;

&#125;
</code></pre>
<pre><code class="java">application.properties
#server.port=8081
#server.servlet.context-path=/first
school.grade=10
school.classnum=6

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<hr>
<hr>
<h1 id="SpringBoot电商项目"><a href="#SpringBoot电商项目" class="headerlink" title="SpringBoot电商项目"></a>SpringBoot电商项目</h1><p><a target="_blank" rel="noopener" href="http://127.0.0.1:8083/#/index">慕慕生鲜前台</a><br><a target="_blank" rel="noopener" href="http://127.0.0.1:8083//admin/index.html#/login">慕慕生鲜后台</a></p>
<h3 id="课程整体介绍"><a href="#课程整体介绍" class="headerlink" title="课程整体介绍"></a>课程整体介绍</h3><ul>
<li>为什么要做电商项目</li>
<li>项目亮点以及功能模块介绍</li>
<li>项目演示</li>
<li>项目开发所需要工具准备</li>
<li>数据库设计与项目初始化</li>
<li>功能模块开发</li>
<li>阿里云部署</li>
<li>项目总结</li>
</ul>
<h3 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h3><ul>
<li>最新的业界的互联网企业的优质技术</li>
<li>代码规范简介，充分优化</li>
<li>流程完整、电商功能丰富</li>
<li>前后端彻底分离，符合未来趋势，学了就能用</li>
</ul>
<h3 id="功能模块介绍"><a href="#功能模块介绍" class="headerlink" title="功能模块介绍"></a>功能模块介绍</h3><ul>
<li><h4 id="项目功能："><a href="#项目功能：" class="headerlink" title="项目功能："></a>项目功能：</h4><ul>
<li><h5 id="前台-用户、商品分类、商品信息、购物车、订单"><a href="#前台-用户、商品分类、商品信息、购物车、订单" class="headerlink" title="前台  {用户、商品分类、商品信息、购物车、订单}"></a><span style = "color:red">前台  {用户、商品分类、商品信息、购物车、订单}</span></h5><ul>
<li><strong>用户模块</strong>{注册、登录、更新签名、身份认证、登出}</li>
<li><strong>商品分类模块</strong>{多级目录、递归查询、缓存}</li>
<li><strong>商品模块</strong>{商品搜索、商品排序、商品列表、目录展示、商品详情}</li>
<li><strong>购物车模块</strong>{加入商品、列表显示、数量更改、删除商品、勾选反选、全选全不选}</li>
<li><strong>订单模块</strong>{下单、订单流程、订单详情、取消订单、支付二维码、扫码支付、个人订单、确认收货}</li>
</ul>
</li>
<li><h5 id="后台-用户、商品分类、商品信息、订单"><a href="#后台-用户、商品分类、商品信息、订单" class="headerlink" title="后台  {用户、商品分类、商品信息、订单}"></a><span style = "color:red">后台  {用户、商品分类、商品信息、订单}</span></h5><ul>
<li><strong>管理员模块</strong>{登录登出、身份认证、安全限制}</li>
<li><strong>商品分类模块</strong>{分类列表、增加分类、修改分类、删除分类}</li>
<li><strong>商品模块</strong>{商品列表、新增商品、图片上传、更新删除、批量上下架}</li>
<li><strong>订单模块</strong>{订单列表、地址信息、发货、订单完结}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h3><ul>
<li>前后端分离</li>
<li>接口文档</li>
<li>全栈、CTO</li>
<li>核心是接口的设计</li>
</ul>
<h3 id="项目开发所需工具准备"><a href="#项目开发所需工具准备" class="headerlink" title="项目开发所需工具准备"></a>项目开发所需工具准备</h3><ul>
<li><strong>IDEA</strong>常用优质插件介绍<ul>
<li>Maven Helper</li>
<li>Free MyBatis plugin [跳转&#x2F;识别mapper语法错误]</li>
</ul>
</li>
<li><strong>Postman</strong>安装和常用功能演示</li>
<li><strong>MySQL可视化工具</strong></li>
</ul>
<h3 id="数据库设计与项目初始化"><a href="#数据库设计与项目初始化" class="headerlink" title="数据库设计与项目初始化"></a>数据库设计与项目初始化</h3><ul>
<li>表设计</li>
<li>技术选型、思路</li>
<li>新建项目，整合Mybatis，跑通接口</li>
<li>引用log4j2日志组件</li>
<li>使用AOP统一处理Web请求日志 [请求的参数  返回的商品、字段]</li>
</ul>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul>
<li>Spring Boot 2.2.1RELEASE</li>
<li>MyBatis 3.4.6(优点)</li>
<li>Maven 3.6.1</li>
</ul>
<h3 id="技术选型需要考虑的点"><a href="#技术选型需要考虑的点" class="headerlink" title="技术选型需要考虑的点"></a>技术选型需要考虑的点</h3><ul>
<li>选择你最熟悉的技术 [最好不要超过30%的新技术]</li>
<li>选择拥有强大社区支撑的开源技术</li>
<li>确保技术前进步伐</li>
<li>学会从业务端开始思考</li>
<li>重视经验</li>
</ul>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><ul>
<li>新建项目</li>
<li>mybatis-generator的安装配置</li>
<li>自动生成DAO层文件</li>
<li>跑通接口</li>
</ul>
<p>【下方链接的主要问题就是 由于项目中的jdk和你实际安装的jdk不匹配】<br>{修改Project Structure → Project的版本}<br>{修改启动Edit的版本}<br>{修改setting→Build,Execution,Deployment→Compiler→Java Compiler中的<strong>Project version</strong>以及项目的<strong>Target version</strong>}</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44664231/article/details/131544077">【Java异常】完美解决this version of the Java Runtime only recognizes class file versions up to xx.0异常_java runtime (class file version 61.0), this versi-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51970165/article/details/128242289">fileversion 55.0 this version of the Java Runtime only recognizes class file versions up to 52.0：已解决_class file version 55.0-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_54878983/article/details/134912368">彻底解决：IDEA java: 警告: 源发行版 17 需要目标发行版 17-CSDN博客</a></p>
<pre><code class="xml">generatorConfig.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
  &lt;!-- 配置文件，放在resource目录下即可 --&gt;
  &lt;!--数据库驱动个人配置--&gt;
  &lt;classPathEntry
    location=&quot;/Users/Pluminary/.m2/repository/mysql/mysql-connector-java/8.0.18/mysql-connector-java-8.0.18.jar&quot;/&gt;
  &lt;context id=&quot;MysqlTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
    &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt;
    &lt;!--可以使用``包括字段名，避免字段名与sql保留字冲突报错--&gt;
    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;
    &lt;commentGenerator&gt;
      &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;
      &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;
    &lt;/commentGenerator&gt;
    &lt;!--数据库链接地址账号密码--&gt;
    &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
      connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&quot;
      userId=&quot;root&quot;
      password=&quot;root&quot;&gt;
      &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;
    &lt;/jdbcConnection&gt;
    &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;
    &lt;javaTypeResolver&gt;
      &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
    &lt;/javaTypeResolver&gt;
    &lt;!--生成Model类存放位置--&gt;
    &lt;javaModelGenerator targetPackage=&quot;com.imooc.mall.model.pojo&quot;
      targetProject=&quot;src/main/java&quot;&gt;
      &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
      &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;
      &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
      &lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;
      &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;
    &lt;/javaModelGenerator&gt;
    &lt;!--生成mapper映射文件存放位置--&gt;
    &lt;sqlMapGenerator targetPackage=&quot;mappers&quot; targetProject=&quot;src/main/resources&quot;&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/sqlMapGenerator&gt;
    &lt;!--生成Dao类存放位置--&gt;
    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.imooc.mall.model.dao&quot;
      targetProject=&quot;src/main/java&quot;&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/javaClientGenerator&gt;
    &lt;!--生成对应表及类名--&gt;
    &lt;table schema=&quot;root&quot; tableName=&quot;imooc_mall_cart&quot; domainObjectName=&quot;Cart&quot;
      enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_category&quot; domainObjectName=&quot;Category&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_order&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_order_item&quot; domainObjectName=&quot;OrderItem&quot;
      enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_product&quot; domainObjectName=&quot;Product&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;

  &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="xml">application.properties
spring.datasource.name=imooc_mall_datasource
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;mall&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;small&lt;/name&gt;
    &lt;description&gt;small&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;!--  1.依赖mysql-connector-java  mybatis-spring-boot-starter 加入generatorConfig.xml 写下面的Plugins--&gt;
&lt;!-- 2. 加入imooc_mall_local.sql后 点Maven -&gt; Plugins -&gt; mybatis-generator -&gt; 点击第一个 --&gt;
&lt;!--  通过插件生成 此时就出来了com/imooc/mall/model/dao里面所有的 和 com/imooc/mall/model/pojo里面所有的 和 mappers--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.7&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;verbose&gt;true&lt;/verbose&gt;
                    &lt;overwrite&gt;true&lt;/overwrite&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">package com.imooc.mall.controller;

import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 用户控制器
 */
@Controller
public class UserController &#123;
    //4.返回对象的基本信息 return里面会写和service相关的  5建立Service层
    @Autowired
    UserService userService;
    @GetMapping(&quot;/test&quot;)
    @ResponseBody //返回Json格式内容
    public User personalPage()&#123;
//  6.补全return 7告诉mapper在哪里怎么去找 去application.properties编写 mybatis.mapper-locations:......
//  去主类里编写@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;) 以防找不到mapper 8.去配置端口8083
//   9.加入log4j2.xml
        return userService.getUser();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/UserService.java
package com.imooc.mall.service;

import com.imooc.mall.model.pojo.User;

//5.这是抽象的接口 还要让它实现 再创建一个impl 实现接口类 UserServiceImpl.java
public interface UserService &#123;
    User getUser();
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.model.dao.UserMapper;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * UserService实现类
 */
@Service
//5.重写里面的方法  @Autowired引入一个mapper去查询数据库返回真正的信息 6返回UserController补全return
public class UserServiceImpl implements UserService &#123;
    @Autowired
    UserMapper userMapper;

    @Override
    public User getUser()&#123;
        //通过主键来查询一个对象
        return userMapper.selectByPrimaryKey(1);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.mall;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;)
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="log4j2日志"><a href="#log4j2日志" class="headerlink" title="log4j2日志"></a>log4j2日志</h3><ul>
<li>日志级别(优先级降低)：error, warn, info, debug, trace</li>
<li>排除Logback依赖</li>
</ul>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">log4j2.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;fatal&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;baseDir&quot; value=&quot;$&#123;sys:user.home&#125;/Desktop/idea_Space/logs&quot;/&gt;
  &lt;/Properties&gt;

  &lt;Appenders&gt;
    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
      &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt;
      &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot;
        onMismatch=&quot;DENY&quot;/&gt;
      &lt;PatternLayout
        pattern=&quot;[%d&#123;MM:dd HH:mm:ss.SSS&#125;] [%level] [%logger&#123;36&#125;] - %msg%n&quot;/&gt;
    &lt;/Console&gt;

    &lt;!--debug级别日志文件输出--&gt;
    &lt;RollingFile name=&quot;debug_appender&quot; fileName=&quot;$&#123;baseDir&#125;/debug.log&quot;
      filePattern=&quot;$&#123;baseDir&#125;/debug_%i.log.%d&#123;yyyy-MM-dd&#125;&quot;&gt;
      &lt;!-- 过滤器 --&gt;
      &lt;Filters&gt;
        &lt;!-- 限制日志级别在debug及以上在info以下 --&gt;
        &lt;ThresholdFilter level=&quot;debug&quot;/&gt;
        &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
      &lt;/Filters&gt;
      &lt;!-- 日志格式 --&gt;
      &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;
      &lt;!-- 策略 --&gt;
      &lt;Policies&gt;
        &lt;!-- 每隔一天转存 --&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
        &lt;!-- 文件大小 --&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;

    &lt;!-- info级别日志文件输出 --&gt;
    &lt;RollingFile name=&quot;info_appender&quot; fileName=&quot;$&#123;baseDir&#125;/info.log&quot;
      filePattern=&quot;$&#123;baseDir&#125;/info_%i.log.%d&#123;yyyy-MM-dd&#125;&quot;&gt;
      &lt;!-- 过滤器 --&gt;
      &lt;Filters&gt;
        &lt;!-- 限制日志级别在info及以上在error以下 --&gt;
        &lt;ThresholdFilter level=&quot;info&quot;/&gt;
        &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
      &lt;/Filters&gt;
      &lt;!-- 日志格式 --&gt;
      &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;
      &lt;!-- 策略 --&gt;
      &lt;Policies&gt;
        &lt;!-- 每隔一天转存 --&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
        &lt;!-- 文件大小 --&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;

    &lt;!-- error级别日志文件输出 --&gt;
    &lt;RollingFile name=&quot;error_appender&quot; fileName=&quot;$&#123;baseDir&#125;/error.log&quot;
      filePattern=&quot;$&#123;baseDir&#125;/error_%i.log.%d&#123;yyyy-MM-dd&#125;&quot;&gt;
      &lt;!-- 过滤器 --&gt;
      &lt;Filters&gt;
        &lt;!-- 限制日志级别在error及以上 --&gt;
        &lt;ThresholdFilter level=&quot;error&quot;/&gt;
      &lt;/Filters&gt;
      &lt;!-- 日志格式 --&gt;
      &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;
      &lt;Policies&gt;
        &lt;!-- 每隔一天转存 --&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
        &lt;!-- 文件大小 --&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;debug&quot;&gt;
      &lt;AppenderRef ref=&quot;Console&quot;/&gt;
      &lt;AppenderRef ref=&quot;debug_appender&quot;/&gt;
      &lt;AppenderRef ref=&quot;info_appender&quot;/&gt;
      &lt;AppenderRef ref=&quot;error_appender&quot;/&gt;
    &lt;/Root&gt;

  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h3 id="AOP统一处理Web请求日志"><a href="#AOP统一处理Web请求日志" class="headerlink" title="AOP统一处理Web请求日志"></a>AOP统一处理Web请求日志</h3><ul>
<li>为什么需要AOP统一处理Web请求日志 [对系统健壮性的保证 创建filter]</li>
</ul>
<pre><code class="java">com/imooc/mall/filter/WebLogAspect.java
package com.imooc.mall.filter;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.util.Arrays;

/**
 * 打印请求和响应信息
 */
@Aspect
@Component
public class WebLogAspect &#123;
    //生成loger类
    private final Logger log = LoggerFactory.getLogger(WebLogAspect.class);
//10.增加一个拦截点AOP
    @Pointcut(&quot;execution(public * com.imooc.mall.controller..*.*(..))&quot;)
    public void webLog()&#123;

    &#125;
//  10.提供请求参数
    @Before(&quot;webLog()&quot;)
    public void doBefore(JoinPoint joinPoint)&#123;
        //收到请求,记录请求内容  请求到来所作的事情
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        log.info(&quot;URL: &quot; + request.getRequestURI().toString());
        log.info(&quot;HTTP_METHOD: &quot; + request.getMethod());
        log.info(&quot;IP: &quot; + request.getRemoteAddr());
        log.info(&quot;CLASS_METHOD: &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());
        log.info(&quot;ARGS: &quot; + Arrays.toString(joinPoint.getArgs()));
    &#125;
//  11.返回的时候也要拦截  返回参数res 拦截点webLog
    @AfterReturning(returning = &quot;res&quot;,pointcut = &quot;webLog()&quot;)
    public void doAfterReturning(Object res)throws Exception&#123;
        //处理完请求,返回内容
        log.info(&quot;RESPONSE: &quot; + new ObjectMapper().writeValueAsString(res));
    &#125;
&#125;
</code></pre>
<h3 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h3><ul>
<li>整体介绍：知识点、功能点<br> [<u>登录、注册、重名校验、密码加密存储、Session的使用、越权校验、统一响应对象、异常枚举、Java异常体系、Postman实操、统一异常处理、更新个人信息</u>]</li>
<li>接口设计</li>
<li>编码设计</li>
</ul>
<h3 id="API统一返回对象"><a href="#API统一返回对象" class="headerlink" title="API统一返回对象"></a>API统一返回对象</h3><pre><code class="java">package com.imooc.mall.common;

import com.imooc.mall.exception.ImoocMallExceptionEnum;

/**
 * 通用返回对象 T有可能是返回的购物车对象
 * 12.编写响应API      13创建枚举异常com/imooc/mall/exception/ImoocMallExceptionEnum.java
 */
public class ApiRestResponse&lt;T&gt; &#123;
    private Integer status;
    private String msg;
    private T data;
    private static final int OK_CODE = 10000;
    private static final String OK_MSG = &quot;SUCCESS&quot;;

    public ApiRestResponse(Integer status, String msg, T data) &#123;
        this.status = status;
        this.msg = msg;
        this.data = data;
    &#125;

    public ApiRestResponse(Integer status, String msg) &#123;
        this.status = status;
        this.msg = msg;
    &#125;

    public ApiRestResponse() &#123;
        //默认请求信息
        this(OK_CODE, OK_MSG);
    &#125;
    public static&lt;T&gt; ApiRestResponse&lt;T&gt; success()&#123;
//   建立带着10000 和 SUCCESS的方法
        return new ApiRestResponse&lt;&gt;();
    &#125;

    public static &lt;T&gt; ApiRestResponse&lt;T&gt; error(Integer code, String msg) &#123;
        return new ApiRestResponse&lt;&gt;(code, msg);
    &#125;
//  14.用枚举来搞错误 为了方便调试编写完后生成一个toString方法 15修改UserController的register()
    public static &lt;T&gt; ApiRestResponse&lt;T&gt; error(ImoocMallExceptionEnum ex) &#123;
        return new ApiRestResponse&lt;&gt;(ex.getCode(), ex.getMsg());
    &#125;
//   把错误[异常]创建成一个枚举类

    public static&lt;T&gt; ApiRestResponse&lt;T&gt; success(T result)&#123;
//    两个成功success的方法
        ApiRestResponse&lt;T&gt; response = new ApiRestResponse&lt;&gt;();
        response.setData(result);
        return response;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;ApiRestResponse&#123;&quot; +
                &quot;status=&quot; + status +
                &quot;, msg=&#39;&quot; + msg + &#39;\&#39;&#39; +
                &quot;, data=&quot; + data +
                &#39;&#125;&#39;;
    &#125;

    public Integer getStatus() &#123;
        return status;
    &#125;

    public void setStatus(Integer status) &#123;
        this.status = status;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;

    public T getData() &#123;
        return data;
    &#125;

    public void setData(T data) &#123;
        this.data = data;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
package com.imooc.mall.exception;

/**
 * 异常枚举
 */
//13.编写异常枚举 注意类是enum噢  14返回ApiRestResponse
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;);


    //异常码
    Integer code;
    //异常信息
    String msg;

    ImoocMallExceptionEnum(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<h3 id="注册接口开发"><a href="#注册接口开发" class="headerlink" title="注册接口开发"></a>注册接口开发</h3><pre><code class="java">com/imooc/mall/controller/UserController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 用户控制器
 */
@Controller
public class UserController &#123;
    //4.返回对象的基本信息 return里面会写和service相关的  5建立Service层
    @Autowired
    UserService userService;
    @GetMapping(&quot;/test&quot;)
    @ResponseBody //返回Json格式内容
    public User personalPage()&#123;
//  6.补全return 7告诉mapper在哪里怎么去找 去application.properties编写 mybatis.mapper-locations:......
//  去主类里编写@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;) 以防找不到mapper 8.去配置端口8083
//   9.加入log4j2.xml  增加aop的pom
        return userService.getUser();
    &#125;
// 12.创造一个统一返回对象 com/imooc/mall/common/ApiRestResponse.java
    // 15.参数加在请求中所以加上@RequestParam 编写校验  16去UserService增加register接口
    @PostMapping(&quot;/register&quot;)
    @ResponseBody
    public ApiRestResponse register(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password) throws ImoocMallException &#123;
//    字符串为空 || 符合参数
        if (StringUtils.isEmpty(userName))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;if (StringUtils.isEmpty(password))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;
//   防止用户密码长度设置简单 密码长度不能少于8
        if (password.length()&lt;8)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.PASSWORD_TOO_SHORT);
        &#125;
 //18.补全操作  19进行统一处理异常[对前端安全考虑] GlobalExceptionHandler.java
        userService.register(userName, password);
        return ApiRestResponse.success();
    &#125;
&#125;

=========================================
http://127.0.0.1:8083/register

Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Wed Mar 06 00:06:06 CST 2024
There was an unexpected error (type=Method Not Allowed, status=405).
Request method &#39;GET&#39; not supported
    
因为注册的时候采用的是@PostMapping(&quot;/register&quot;)
单纯查询用get 往数据库写东西post
@RequestMapping(&quot;/register&quot;)是GET和POST都支持的 但是不推荐
根据不同的业务逻辑选择类型

打开postman 新建一个去查询post
POST: 127.0.0.1:8083/register?userName=mumu&amp;password=12345678

&#123;
    &quot;status&quot;: 10000,
    &quot;msg&quot;: &quot;SUCCESS&quot;,
    &quot;data&quot;: null
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/UserService.java
package com.imooc.mall.service;

import com.imooc.mall.model.pojo.User;

//5.这是抽象的接口 还要让它实现 再创建一个impl 实现接口类 UserServiceImpl.java
public interface UserService &#123;
    User getUser();
// 16.写完接口去实现接口UserServiceImpl.java
    void register(String userName, String password);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.UserMapper;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * UserService实现类
 */
@Service
//5.重写里面的方法  @Autowired引入一个mapper去查询数据库返回真正的信息 6返回UserController补全return
public class UserServiceImpl implements UserService &#123;
    @Autowired
    UserMapper userMapper;

    @Override
    public User getUser()&#123;
        //通过主键来查询一个对象
        return userMapper.selectByPrimaryKey(1);
    &#125;
    @Override
    public void register(String userName, String password) throws ImoocMallException &#123;
//    16.查询用户名是否存在, 不允许重名 用userMapper去查数据
//    但未编写功能 去手动编写UserMapper.java
        User result = userMapper.selectByName(userName);
        if (result != null)&#123;
//    17. 用户已存在 在Service层不能直接return但是controller可以直接返回
            // 创建一个异常类 com/imooc/mall/exception/ImoocMallException.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
    // 通过检测 允许写入数据库
        User user = new User();
        user.setUsername(userName);
        user.setPassword(password);
        //先判断是不是空 不是空才修改  实现完以后回到controller层进行调用
        int count = userMapper.insertSelective(user);
        if (count==0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.INSERT_FAILED);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/UserMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.User;
import org.springframework.stereotype.Repository;

@Repository
public interface UserMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(User record);

    int insertSelective(User record);

    User selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(User record);

    int updateByPrimaryKey(User record);

    // 16. 新增功能 去对应的UserMapper.xml进行描述 117行  BaseResultMap就是一开始自动生成的User对象
    // &lt;include refid=&quot;Base_Column_List&quot;/&gt; 选取完整的User对象
    User selectByName(String userName);
&#125;
</code></pre>
<pre><code class="xml">mappers/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.mall.model.dao.UserMapper&quot;&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;
    &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt;
    &lt;result column=&quot;personalized_signature&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;personalizedSignature&quot; /&gt;
    &lt;result column=&quot;role&quot; jdbcType=&quot;INTEGER&quot; property=&quot;role&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
    &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;sql id=&quot;Base_Column_List&quot;&gt;
    id, username, `password`, personalized_signature, `role`, create_time, update_time
  &lt;/sql&gt;
  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select 
    &lt;include refid=&quot;Base_Column_List&quot; /&gt;
    from imooc_mall_user
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/select&gt;
  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from imooc_mall_user
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/delete&gt;
  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    insert into imooc_mall_user (id, username, `password`, 
      personalized_signature, `role`, create_time, 
      update_time)
    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, 
      #&#123;personalizedSignature,jdbcType=VARCHAR&#125;, #&#123;role,jdbcType=INTEGER&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;, 
      #&#123;updateTime,jdbcType=TIMESTAMP&#125;)
  &lt;/insert&gt;
  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    insert into imooc_mall_user
    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
      &lt;if test=&quot;id != null&quot;&gt;
        id,
      &lt;/if&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        username,
      &lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;
        `password`,
      &lt;/if&gt;
      &lt;if test=&quot;personalizedSignature != null&quot;&gt;
        personalized_signature,
      &lt;/if&gt;
      &lt;if test=&quot;role != null&quot;&gt;
        `role`,
      &lt;/if&gt;
      &lt;if test=&quot;createTime != null&quot;&gt;
        create_time,
      &lt;/if&gt;
      &lt;if test=&quot;updateTime != null&quot;&gt;
        update_time,
      &lt;/if&gt;
    &lt;/trim&gt;
    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
      &lt;if test=&quot;id != null&quot;&gt;
        #&#123;id,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        #&#123;username,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;
        #&#123;password,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;personalizedSignature != null&quot;&gt;
        #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;role != null&quot;&gt;
        #&#123;role,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;createTime != null&quot;&gt;
        #&#123;createTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;updateTime != null&quot;&gt;
        #&#123;updateTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
    &lt;/trim&gt;
  &lt;/insert&gt;
  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    update imooc_mall_user
    &lt;set&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        username = #&#123;username,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;
        `password` = #&#123;password,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;personalizedSignature != null&quot;&gt;
        personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;role != null&quot;&gt;
        `role` = #&#123;role,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;createTime != null&quot;&gt;
        create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;updateTime != null&quot;&gt;
        update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
    &lt;/set&gt;
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/update&gt;
  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    update imooc_mall_user
    set username = #&#123;username,jdbcType=VARCHAR&#125;,
      `password` = #&#123;password,jdbcType=VARCHAR&#125;,
      personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,
      `role` = #&#123;role,jdbcType=INTEGER&#125;,
      create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,
      update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/update&gt;
  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select
        &lt;include refid=&quot;Base_Column_List&quot;/&gt;
        from imooc_mall_user
        where username = #&#123;userName,jdbcType=VARCHAR&#125;
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallException.java
package com.imooc.mall.exception;

/**
 * 17. 统一异常(感觉像递归之前编写的枚举异常)
 */
public class ImoocMallException extends Exception&#123;
    private final Integer code;
    private final String message;

    public ImoocMallException(Integer code, String message) &#123;
        this.code = code;
        this.message = message;
    &#125;

    public ImoocMallException(ImoocMallExceptionEnum exceptionEnum) &#123;
        this(exceptionEnum.getCode(), exceptionEnum.getMsg());
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    @Override
    public String getMessage() &#123;
        return message;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
package com.imooc.mall.exception;

/**
 * 异常枚举
 */
//13.编写异常枚举 注意类是enum噢  14返回ApiRestResponse
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;);


    //异常码
    Integer code;
    //异常信息
    String msg;

    ImoocMallExceptionEnum(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<h3 id="GlobalExceptionHandler编写"><a href="#GlobalExceptionHandler编写" class="headerlink" title="GlobalExceptionHandler编写"></a>GlobalExceptionHandler编写</h3><ul>
<li>对前端安全考虑，敏感信息不会暴露给用户</li>
<li>抛出异常，直接转化为Json的APIResponse</li>
<li>抛出重名异常</li>
<li>拦截异常并且转变成APIRespond统一类型输出</li>
</ul>
<pre><code class="java">com/imooc/mall/exception/GlobalExceptionHandler.java
package com.imooc.mall.exception;

import com.imooc.mall.common.ApiRestResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 19.处理统一异常的handler 业务异常 处理不同逻辑异常  
   20对密码进行MD5加密UserServiceImpl 先创建MD5Utils
 */
@ControllerAdvice
public class GlobalExceptionHandler &#123;
    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    //   统一处理Exception.class异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Object handleException(Exception e) &#123;
        log.error(&quot;Default Exception: &quot;, e);
        return ApiRestResponse.error(ImoocMallExceptionEnum.SYSTEM_ERROR);
    &#125;
    @ExceptionHandler(ImoocMallException.class)
    @ResponseBody
    public Object handleImoocMallException(ImoocMallException e) &#123;
        log.error(&quot;ImoocMallException: &quot;, e); //传进来的是什么就传出去
        return ApiRestResponse.error(e.getCode(), e.getMessage());
    &#125;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e682b6dfead4194de33f37c0a5d1f116f2d9ad96/data/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png"></p>
<h3 id="对密码进行MD5保护"><a href="#对密码进行MD5保护" class="headerlink" title="对密码进行MD5保护"></a>对密码进行MD5保护</h3><pre><code class="java">com/imooc/mall/util/MD5Utils.java
package com.imooc.mall.util;

import com.imooc.mall.common.Constant;
import org.apache.tomcat.util.codec.binary.Base64;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

//20.不具备解密的协议 哈希算法  因为有破解MD5的网站所以需要加盐 21com/imooc/mall/common/Constant.java
public class MD5Utils &#123;
    public static String getMD5Str(String strValue) throws NoSuchAlgorithmException &#123;
        MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
        return Base64.encodeBase64String(md5.digest((strValue+ Constant.SALT).getBytes()));
    &#125;
//  用这个方法测试生成MD5的值
    public static void main(String[] args) throws NoSuchAlgorithmException &#123;
        String md5Str = getMD5Str(&quot;12345&quot;);
        System.out.println(md5Str);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.UserMapper;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import com.imooc.mall.util.MD5Utils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.security.NoSuchAlgorithmException;

/**
 * UserService实现类
 */
@Service
//5.重写里面的方法  @Autowired引入一个mapper去查询数据库返回真正的信息 6返回UserController补全return
public class UserServiceImpl implements UserService &#123;
    @Autowired
    UserMapper userMapper;

    @Override
    public User getUser()&#123;
        //通过主键来查询一个对象
        return userMapper.selectByPrimaryKey(1);
    &#125;
    @Override
    public void register(String userName, String password) throws ImoocMallException, NoSuchAlgorithmException &#123;
//    16.查询用户名是否存在, 不允许重名 用userMapper去查数据
//    但未编写功能 去手动编写UserMapper.java
        User result = userMapper.selectByName(userName);
        if (result != null)&#123;
//    17. 用户已存在 在Service层不能直接return但是controller可以直接返回
            // 创建一个异常类 com/imooc/mall/exception/ImoocMallException.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
    // 通过检测 允许写入数据库
        User user = new User();
        user.setUsername(userName);
//        user.setPassword(password);
        //21.重写密码
        user.setPassword(MD5Utils.getMD5Str(password));
        //先判断是不是空 不是空才修改  18实现完以后回到controller层进行调用
        int count = userMapper.insertSelective(user);
        if (count==0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.INSERT_FAILED);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="登录功能分析"><a href="#登录功能分析" class="headerlink" title="登录功能分析"></a>登录功能分析</h3><ul>
<li>登录状态需要保持 </li>
<li>session的实现方案：登陆后，会保存用户信息到session</li>
<li>之后的访问，会先从session中获取用户信息，然后再执行业务逻辑</li>
</ul>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
</code></pre>
<pre><code class="java">com/imooc/mall/controller/UserController.java
//22登录login接口的开发 23返回UserServiceImpl写login
    @PostMapping(&quot;/login&quot;)
    @ResponseBody
    public ApiRestResponse login(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws ImoocMallException, NoSuchAlgorithmException &#123;
        if (StringUtils.isEmpty(userName))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;if (StringUtils.isEmpty(password))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;//26.编写完毕login接口
        User user = userService.login(userName, password);
        //保存用户信息时，不保存密码
        user.setPassword(null);
        //把对象放入session中
        session.setAttribute(Constant.IMOOC_MALL_USER,user);
        return ApiRestResponse.success(user);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
    //23.写方法判断md5与其匹配
    @Override
    public User login(String userName, String password) throws ImoocMallException &#123;
        String md5Password = null;
        try &#123;
            md5Password = MD5Utils.getMD5Str(password);
        &#125; catch (NoSuchAlgorithmException e) &#123;
            e.printStackTrace();
        &#125;
//   23写方法判断md5与其匹配 UserMapper中写 login
        //25.匹配 且去接口增加
        User user = userMapper.selectLogin(userName, password);
        if (user == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_PASSWORD);
        &#125;//能找到就返回用户 直接从上面写@Override再自动修复就可以自动生成login的接口
        //26.返回UserController写完login接口
        return user;
    &#125;
</code></pre>
<h3 id="用户模块剩余接口开发-更新个性签名"><a href="#用户模块剩余接口开发-更新个性签名" class="headerlink" title="用户模块剩余接口开发 [更新个性签名]"></a>用户模块剩余接口开发 [更新个性签名]</h3><pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/UserController.java
//22登录login接口的开发 23返回UserServiceImpl写login
    @PostMapping(&quot;/login&quot;)
    @ResponseBody
    public ApiRestResponse login(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws ImoocMallException, NoSuchAlgorithmException &#123;
        if (StringUtils.isEmpty(userName)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;
        if (StringUtils.isEmpty(password)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;//26.编写完毕login接口  27更新个性签名接口
        User user = userService.login(userName, password);
        //保存用户信息时，不保存密码
        user.setPassword(null);
        //把对象放入session中 KEY
        session.setAttribute(Constant.IMOOC_MALL_USER, user);
        return ApiRestResponse.success(user);
    &#125;

    //  27.个性签名接口 28编写UserServiceImpl的updateUserInfo方法
    @PostMapping(&quot;/user/update&quot;)
    @ResponseBody
    public ApiRestResponse updateUserInfo(HttpSession session, @RequestParam String signature) throws ImoocMallException &#123;
        User currentUser = (User)session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;
        User user = new User();
        user.setId(currentUser.getId());
        user.setPersonalizedSignature(signature);
        //29.搞全代码
        userService.updateInformation(user);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
//23.写方法判断md5与其匹配
    @Override
    public User login(String userName, String password) throws ImoocMallException &#123;
        String md5Password = null;
        try &#123;
            md5Password = MD5Utils.getMD5Str(password);
        &#125; catch (NoSuchAlgorithmException e) &#123;
            e.printStackTrace();
        &#125;
//   23写方法判断md5与其匹配 UserMapper中写 login
        //25.匹配 且去接口增加
        User user = userMapper.selectLogin(userName, md5Password);
        if (user == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_PASSWORD);
        &#125;//能找到就返回用户 直接从上面写@Override再自动修复就可以自动生成login的接口
        //26.返回UserController写完login接口
        return user;
    &#125;
// 28写updateUserInfo方法 不需要返回任何信息 只需要提醒更行成功即可
    @Override
    public void updateInformation(User user) throws ImoocMallException &#123;
//    更新个性签名
        int updateCount = userMapper.updateByPrimaryKeySelective(user);
        if(updateCount&gt;1)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;
        //快速使用@Override 快速补全接口代码 29返回UserController补全代码
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/UserService.java
package com.imooc.mall.service;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.model.pojo.User;

import java.security.NoSuchAlgorithmException;

//5.这是抽象的接口 还要让它实现 再创建一个impl 实现接口类 UserServiceImpl.java
public interface UserService &#123;
    User getUser();
// 16.写完接口去实现接口UserServiceImpl.java
    void register(String userName, String password) throws ImoocMallException, NoSuchAlgorithmException;

    //23.写方法判断md5与其匹配
    User login(String userName, String password) throws ImoocMallException;

    // 28写updateUserInfo方法 不需要返回任何信息 只需要提醒更行成功即可
    void updateInformation(User user) throws ImoocMallException;
&#125;
</code></pre>
<h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><pre><code class="java">com/imooc/mall/controller/UserController.java
//30.退出登录接口
    @PostMapping(&quot;/user/logout&quot;)
    @ResponseBody
    public ApiRestResponse logout(HttpSession session)&#123;
        session.removeAttribute(Constant.IMOOC_MALL_USER);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<h3 id="管理员接口"><a href="#管理员接口" class="headerlink" title="管理员接口"></a>管理员接口</h3><pre><code class="java">com/imooc/mall/controller/UserController.java
    //  31.管理员登录接口 思路可以借鉴
    @PostMapping(&quot;/adminLogin&quot;)
    @ResponseBody
    public ApiRestResponse adminLogin(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws ImoocMallException, NoSuchAlgorithmException &#123;
        if (StringUtils.isEmpty(userName)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;
        if (StringUtils.isEmpty(password)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;//31.拿到用户名和密码的时候 对其进行校验是否为管理员
        //数据库中 role=1是普通用户   role=2是管理员用户
        // 32去serviceImpl写一个方法
        User user = userService.login(userName, password);
        //33.判断是否为管理员
//        userService.checkAdminRole(user).if
        if (userService.checkAdminRole(user)) &#123;
            //是管理员
            //保存用户信息时，不保存密码
            user.setPassword(null);
            //把对象放入session中 KEY
            session.setAttribute(Constant.IMOOC_MALL_USER, user);
            return ApiRestResponse.success(user);
        &#125;else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;
    //  34.创建分类接口 CategoryController
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
//  32.拿到用户  role=1是普通用户   role=2是管理员用户
    //33.回到Controller
    @Override
    public boolean checkAdminRole(User user)&#123;
        return user.getRole().equals(2);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    NEED_ADMIN(10009,&quot;无管理员权限&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
&#125;
</code></pre>
<h3 id="总结用户模块"><a href="#总结用户模块" class="headerlink" title="总结用户模块"></a>总结用户模块</h3><ul>
<li><strong>重难点</strong>：统一响应对象、登录状态保持、统一异常处理</li>
<li><strong>常见错误</strong>：响应对象不规范、异常不统一处理</li>
</ul>
<h3 id="商品分类管理模块开发"><a href="#商品分类管理模块开发" class="headerlink" title="商品分类管理模块开发"></a>商品分类管理模块开发</h3><ul>
<li>模块介绍</li>
<li>编码</li>
<li>自测</li>
<li>总结</li>
</ul>
<h5 id="什么是商品分类"><a href="#什么是商品分类" class="headerlink" title="什么是商品分类"></a>什么是商品分类</h5><ul>
<li>条例清楚，层次分明</li>
<li>方便用户进行筛选和辨别</li>
<li>可以通过分类的设置快速的进入对应的商品列表页面进行商品选择</li>
</ul>
<h5 id="分类层级"><a href="#分类层级" class="headerlink" title="分类层级"></a>分类层级</h5><ul>
<li>在商品分类上需要继续做归类操作</li>
<li>分类设置成三级</li>
<li>层级太深的弊端：<ul>
<li>一是对用户不太友好，不利于寻找</li>
<li>二是对后台管理人员不友好，不方便管理</li>
</ul>
</li>
</ul>
<h3 id="分类模块的主要功能"><a href="#分类模块的主要功能" class="headerlink" title="分类模块的主要功能"></a>分类模块的主要功能</h3><ul>
<li>分类数据的设置</li>
<li>分类的父一级目录、递归</li>
</ul>
<h5 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h5><ul>
<li>接口设计</li>
<li>表设计</li>
</ul>
<h3 id="开发添加分类接口part1"><a href="#开发添加分类接口part1" class="headerlink" title="开发添加分类接口part1"></a>开发添加分类接口part1</h3><pre><code class="java">com/imooc/mall/controller/CategoryController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.model.AddCategoryReq;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.CategoryService;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpSession;

//  34.创建分类接口 CategoryController
@Controller
public class CategoryController &#123;
    @Autowired
    UserService userService;
    @Autowired
    CategoryService categoryService;
    @PostMapping(&quot;admin/category/add&quot;)
    @ResponseBody
    public ApiRestResponse addCategory(HttpSession session, @RequestBody AddCategoryReq addCategoryReq) &#123;
        //登录且必须为管理员才可以 参数中需要添加很多元素 可以使用封装来搞
        //com/imooc/mall/model/model/AddCategoryReq.java
        if (addCategoryReq.getName() == null || addCategoryReq.getType() == null || addCategoryReq.getParentId() == null || addCategoryReq.getOrderNum() == null) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.PARA_NOT_NULL);
        &#125;
        //对身份进行校验 用session获取当前的用户
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole)&#123; //35.创建一个CategoryService 分类目录Service
        //37.补全代码 是管理员  在上面添加@RequestBody 去postman Body-&gt;(raw/JSON)里测试接口
            categoryService.add(addCategoryReq);
            return ApiRestResponse.success();
        &#125;else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;
//38.简化参数校验过程 || || || ||  @Valid  @Size(AddCategoryReq) @NotNull
        //39.增加GlobalExceptionHandler.java中的提示代码 不仅仅只提供20000 系统异常 handleMethodArg。。。
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/model/AddCategoryReq.java
package com.imooc.mall.model.model;

/**
 * 34.AddCategoryReq 新建一个类 供添加接口进行封装 回去引用
 */
public class AddCategoryReq &#123;
    private String name;
    private Integer type;
    private Integer parentId;
    private Integer orderNum;
&#125;+GETTER SETTER
</code></pre>
<pre><code class="java">com/imooc/mall/service/CategoryService.java
package com.imooc.mall.service;

import com.imooc.mall.model.model.AddCategoryReq;
import com.imooc.mall.model.pojo.Category;

//35.创建一个CategoryService 分类目录Service 36创建一个它的实现类CategoryServiceImpl
public interface CategoryService &#123;
    void add(AddCategoryReq addCategoryReq);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
package com.imooc.mall.service.impl;

import com.fasterxml.jackson.databind.util.BeanUtil;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.CategoryMapper;
import com.imooc.mall.model.model.AddCategoryReq;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.service.CategoryService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 36.目录分类Service实现类
 */
@Service
public class CategoryServiceImpl implements CategoryService &#123;
    @Autowired
//   去Mapper里增加selectbyName 117行
    CategoryMapper categoryMapper;
    public void add(AddCategoryReq addCategoryReq) &#123;
        Category category = new Category();
//        category.setName(addCategoryReq.getName());
        //字段类型一样 字段名一样的话可以自动拷贝进去
        BeanUtils.copyProperties(addCategoryReq,category);
        Category categoryOld = categoryMapper.selectByName(addCategoryReq.getName());
        if (categoryOld != null)&#123; //重名目录 不允许创建 (优化)将ImoocMallException中的extends换一个
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
        int count = categoryMapper.insertSelective(category);
        if (count == 0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;//37.回到CategoryController.java
    &#125;
&#125;
</code></pre>
<pre><code class="xml">mappers/CategoryMapper.xml
  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_category
    where name = #&#123;name,jdbcType=VARCHAR&#125;
  &lt;/select&gt;
</code></pre>
<h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Valid</td>
<td>需要验证</td>
</tr>
<tr>
<td>@NotNull</td>
<td>非空</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>最大值</td>
</tr>
<tr>
<td>@Size(max, min)</td>
<td>字符串长度范围限制</td>
</tr>
</tbody></table>
<pre><code class="java">com/imooc/mall/model/model/AddCategoryReq.java
package com.imooc.mall.model.model;

import javax.validation.constraints.Max;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

/**
 * 34.AddCategoryReq 新建一个类 供添加接口进行封装 回去引用
 */
public class AddCategoryReq &#123;
    @Size(min=2,max=5)
    private String name;
    @NotNull
    @Max(3)
    private Integer type;
    @NotNull(message = &quot;parentId不能为null&quot;)
    private Integer parentId;
    @NotNull
    private Integer orderNum;
    
===================================================
POST:127.0.0.1:8083/admin/category/add
Body→raw→JSON：&#123;&quot;name&quot;:&quot;鸭货伴手零食&quot;,&quot;type&quot;:2,&quot;parentId&quot;:6,&quot;orderNum&quot;:10&#125;

&#123;
    &quot;status&quot;: 20000,
    &quot;msg&quot;: &quot;系统异常&quot;,
    &quot;data&quot;: null
&#125;

org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [1] in public com.imooc.mall.common.ApiRestResponse com.imooc.mall.controller.CategoryController.addCategory(javax.servlet.http.HttpSession,com.imooc.mall.model.model.AddCategoryReq): [Field error in object &#39;addCategoryReq&#39; on field &#39;name&#39;: rejected value [鸭货伴手零食]; codes [Size.addCategoryReq.name,Size.name,Size.java.lang.String,Size]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [addCategoryReq.name,name]; arguments []; default message [name],5,2]; default message [个数必须在2和5之间]] 
</code></pre>
<pre><code class="java">com/imooc/mall/exception/GlobalExceptionHandler.java
package com.imooc.mall.exception;

import com.imooc.mall.common.ApiRestResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.ArrayList;
import java.util.List;

/**
 * 19.处理统一异常的handler 业务异常 处理不同逻辑异常  20对密码进行MD5加密UserServiceImpl 先创建MD5Utils
 */
@ControllerAdvice
public class GlobalExceptionHandler &#123;
    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    //   统一处理Exception.class异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Object handleException(Exception e) &#123;
        log.error(&quot;Default Exception: &quot;, e);
        return ApiRestResponse.error(ImoocMallExceptionEnum.SYSTEM_ERROR);
    &#125;

    @ExceptionHandler(ImoocMallException.class)
    @ResponseBody
    public Object handleImoocMallException(ImoocMallException e) &#123;
        log.error(&quot;ImoocMallException: &quot;, e); //传进来的是什么就传出去
        return ApiRestResponse.error(e.getCode(), e.getMessage());
    &#125;

    //  39.处理方法参数不合规的情况
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public ApiRestResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e) &#123;
        log.error(&quot;handleMethodArgumentNotValidException: &quot;, e);
        return handleBindingResult(e.getBindingResult());
    &#125;
//  40.处理返回异常的ApiRespond 41去pom引入Swagger自动生成API文档
    private ApiRestResponse handleBindingResult(BindingResult result)&#123;
//  把异常处理为对外暴露的提示
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        if (result.hasErrors())&#123;
            List&lt;ObjectError&gt; allErrors = result.getAllErrors();
            for (ObjectError objectError : allErrors) &#123; //itli快速  对着for按alt+回车 改成增强for
                String message = objectError.getDefaultMessage();
                list.add(message);
            &#125;
        &#125;
        if (list.size() == 0)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR);
        &#125; //list.toString()生成所创建的异常描述信息
        return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR.getCode(), list.toString());
    &#125;
&#125;
</code></pre>
<h3 id="Swagger自动生成API文档"><a href="#Swagger自动生成API文档" class="headerlink" title="Swagger自动生成API文档"></a>Swagger自动生成API文档</h3><pre><code class="xml">pom.xml
&lt;!--41.导入Swagger自动生成API文档 并在main函数中加入注解 @EnableSwagger2--&gt;
&lt;!--42.再去创造一个config  配置文件    --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/config/SpringFoxConfig.java
package com.imooc.mall.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

@Configuration
public class SpringFoxConfig &#123;
 //41.访问http://localhost:8083/swagger-ui.html可以看到API文档 
    //42创建ImoocMallWebMvcConfig
    @Bean
    public Docket api() &#123;
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.any())
                .paths(PathSelectors.any())
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕慕生鲜&quot;)
                .description(&quot;&quot;)
                .termsOfServiceUrl(&quot;&quot;)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/MallApplication.java
package com.imooc.mall;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;)
@EnableSwagger2
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
package com.imooc.mall.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 
 * 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
   44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;

    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
==================================================
http://localhost:8083/swagger-ui.html
</code></pre>
<h3 id="更新目录接口"><a href="#更新目录接口" class="headerlink" title="更新目录接口"></a>更新目录接口</h3><pre><code class="java">com/imooc/mall/model/request/UpdateCategoryReq.java
package com.imooc.mall.model.request;

import javax.validation.constraints.Max;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

/**
 * 45.CategoryController.java中创建新增方法
 */
public class UpdateCategoryReq &#123;
    @NotNull(message = &quot;id不能为null&quot;)
    private Integer id;

    @Size(min=2,max=5)
    private String name;
    @Max(3)
    private Integer type;

    private Integer parentId;
    private Integer orderNum;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CategoryController.java
 //    45.创建新增接口   46在CategoryServiceImpl.java中新增更新方法
    @ApiOperation(&quot;后台更新目录&quot;)
    @PostMapping(&quot;admin/category/update&quot;)
    @ResponseBody
    public ApiRestResponse updateCategory( @Valid @RequestBody UpdateCategoryReq updateCategoryReq, HttpSession session) &#123;
        //对身份进行校验 用session获取当前的用户
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole) &#123;
            //补全代码 是管理员  在上面添加@RequestBody 去postman Body-&gt;(raw/JSON)里测试接口
            //46.补全接口代码
            Category category = new Category(); //复制过来
            BeanUtils.copyProperties(updateCategoryReq, category);
            categoryService.update(category);
            return ApiRestResponse.success();
        &#125; else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;//47.为了统一接口校验管理员身份 NEED_LOGIN NEED_ADMIN
        // 创建一个com/imooc/mall/filter/AdminFilter.java
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
 @Override //47.快速生成
    // 46在CategoryServiceImpl.java中新增更新方法
    public void update(Category updateCategory)&#123;
        if (updateCategory.getName() != null)&#123;
            Category categoryOld = categoryMapper.selectByName(updateCategory.getName());
            if (categoryOld != null &amp;&amp; !categoryOld.getId().equals(updateCategory.getId()))&#123; //不能为空且和原来的名字不一样
                throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
            &#125;
        &#125;
        categoryMapper.updateByPrimaryKeySelective(updateCategory); //根据主键更新
// 不和其他名字冲突
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/CategoryService.java
package com.imooc.mall.service;

import com.imooc.mall.model.pojo.Category;
import com.imooc.mall .model.request.AddCategoryReq;

//35.创建一个CategoryService 分类目录Service 36创建一个它的实现类CategoryServiceImpl
public interface CategoryService &#123;
    void add(AddCategoryReq addCategoryReq);

    //47.快速生成
    // 46在CategoryServiceImpl.java中新增更新方法
    void update(Category updateCategory);
&#125;
</code></pre>
<h3 id="统一校验管理员身份"><a href="#统一校验管理员身份" class="headerlink" title="统一校验管理员身份"></a>统一校验管理员身份</h3><pre><code class="java">com/imooc/mall/controller/CategoryController.java
//    45.创建新增接口   46在CategoryServiceImpl.java中新增更新方法
    @ApiOperation(&quot;后台更新目录&quot;)
    @PostMapping(&quot;admin/category/update&quot;)
    @ResponseBody
    public ApiRestResponse updateCategory( @Valid @RequestBody UpdateCategoryReq updateCategoryReq, HttpSession session) &#123;
        //对身份进行校验 用session获取当前的用户
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole) &#123;
            //补全代码 是管理员  在上面添加@RequestBody 去postman Body-&gt;(raw/JSON)里测试接口
            //46.补全接口代码
            Category category = new Category(); //复制过来
            BeanUtils.copyProperties(updateCategoryReq, category);
            categoryService.update(category);
            return ApiRestResponse.success();
        &#125; else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;//47.为了统一接口校验管理员身份 NEED_LOGIN NEED_ADMIN
        // 创建一个com/imooc/mall/filter/AdminFilter.java
    &#125;
    @ApiOperation(&quot;后台更新目录&quot;)
    @PostMapping(&quot;admin/category/update&quot;)
    @ResponseBody //没有在接口里做权限校验
    public ApiRestResponse deleteCategory()&#123;
        return null;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/filter/AdminFilter.java
package com.imooc.mall.filter;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.PrintWriter;

/**
 *
 * 47. 管理员校验过滤器  48.Admin过滤器的配置
 */
public class AdminFilter implements Filter &#123;
    @Autowired
    UserService userService;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        //对身份进行校验 用session获取当前的用户
        HttpServletRequest request = (HttpServletRequest)servletRequest;
        HttpSession session = request.getSession();
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) servletResponse).getWriter();
            out.write(&quot;&#123;\n&quot; //用户未登录
                    + &quot;    \&quot;status\&quot;: 10007,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            out.flush();
            out.close();
            return;
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole) &#123; //放行代码
            filterChain.doFilter(servletRequest,servletResponse);
        &#125; else &#123;
            PrintWriter out = new HttpServletResponseWrapper(
                    (HttpServletResponse) servletResponse).getWriter();
            out.write(&quot;&#123;\n&quot;
                    + &quot;    \&quot;status\&quot;: 10009,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_ADMIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            out.flush();
            out.close();
        &#125;
    &#125;

    @Override
    public void destroy() &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/filter/AdminFilterConfig.java
package com.imooc.mall.filter;

import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Admin过滤器的配置
 */
@Configuration
public class AdminFilterConfig &#123;
    @Bean
    public AdminFilter adminFilter()&#123;
        return new AdminFilter();
    &#125;
    @Bean(name = &quot;adminFilterConf&quot;)
    public FilterRegistrationBean adminFilterConfig()&#123;
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
        filterRegistrationBean.setFilter(adminFilter());
        filterRegistrationBean.addUrlPatterns(&quot;/admin/category/*&quot;);
        filterRegistrationBean.addUrlPatterns(&quot;/admin/product/*&quot;);
        filterRegistrationBean.addUrlPatterns(&quot;/admin/order/*&quot;);
        filterRegistrationBean.setName(&quot;adminFilterConfig&quot;);
        return filterRegistrationBean;
    &#125;
&#125;
com/imooc/mall/filter/AdminFilterConfig.java
</code></pre>
<h3 id="删除目录接口、分页功能开发"><a href="#删除目录接口、分页功能开发" class="headerlink" title="删除目录接口、分页功能开发"></a>删除目录接口、分页功能开发</h3><pre><code class="java">@RequestBody用来接收http post请求的body，前端传入序列化好的json数据，后端可以解析为json对象（Content-Type需要指定为 application/json）。
@RequestParam用来接收请求url?后面的参数，或者Content-Type为multipart/form-data、application/x-www-form-urlencoded时的http body数据。
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CategoryController.java
     @ApiOperation(&quot;后台删除目录&quot;)
    @PostMapping(&quot;admin/category/delete&quot;)
    @ResponseBody //没有在接口里做权限校验
    //49.编写delete接口  再去CategoryServiceImpl.java 写delete方法
    public ApiRestResponse deleteCategory(@RequestParam Integer id) &#123;
        categoryService.delete(id);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//49.写delete方法     @Override快速更新service
    @Override
    public void delete(Integer id)&#123;
        Category categoryOld = categoryMapper.selectByPrimaryKey(id);
        //查不到记录，无法删除，删除失败
        if (categoryOld == null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
        int count = categoryMapper.deleteByPrimaryKey(id);
        if (count == 0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CategoryController.java
 //50.写后台查询商品分类列表的接口
    @ApiOperation(&quot;后台目录列表&quot;)
    @PostMapping(&quot;admin/category/list&quot;)
    @ResponseBody //没有在接口里做权限校验
    public ApiRestResponse listCategoryForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        //51.去CategoryServiceImpl编写该接口的实现类
        PageInfo pageInfo = categoryService.listForAdmin(pageNum, pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/CategoryVO.java
package com.imooc.mall.model.vo;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class CategoryVO &#123;
    private Integer id;
    private String name;
    private Integer type;
    private Integer parentId;
    private Integer orderNum;
    private Date createTime;
    private Date updateTime;
    private List&lt;CategoryVO&gt; childCategory = new ArrayList&lt;&gt;();
&#125;Setter+Getter
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//51.创建vo[转换过后反应给前端的一个类]  pageInfo里面蕴藏着一个List&lt;Category&gt;
    @Override
    public PageInfo listForAdmin(Integer pageNum, Integer pageSize)&#123;
        //把分页的功能包裹在List后 而不是直接返回
        //52.引入分页查询的pom 续写分页代码
        PageHelper.startPage(pageNum,pageSize,&quot;type,order_num&quot;);
        //53.写一个查询的mapper新的sql语句 CategoryMapper.java =&gt; List&lt;Category&gt; selectList();
        //54.返回Categorycontroller补全代码
        List&lt;Category&gt; categoryList = categoryMapper.selectList();
        PageInfo pageInfo = new PageInfo(categoryList);
        return pageInfo;
    &#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;!--  52.引入分页的依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.13&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="用户分类列表接口开发"><a href="#用户分类列表接口开发" class="headerlink" title="用户分类列表接口开发"></a>用户分类列表接口开发</h3><pre><code class="java">com/imooc/mall/controller/CategoryController.java
//54.用户分类列表接口开发 去Impl补写实现类
    @ApiOperation(&quot;前台目录列表&quot;)
    @GetMapping(&quot;category/list&quot;)
    @ResponseBody
    public ApiRestResponse listCategoryForCustomer()&#123;
        List&lt;CategoryVO&gt; categoryVOS = categoryService.listCategoryForCustomer();
        return ApiRestResponse.success(categoryVOS);
    &#125;

============================================
目录列表(給用户看)：127.0.0.1:8083/category/list
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//54.用户分类列表接口开发
    @Override
    public List&lt;CategoryVO&gt; listCategoryForCustomer()&#123;
        ArrayList&lt;CategoryVO&gt; categoryVOList = new ArrayList&lt;&gt;();
        recursivelyFindCategories(categoryVOList, 0);
        //55.去Mapper.java 和 Mapper.xml写方法
        return categoryVOList;
    &#125;

    private void recursivelyFindCategories(List&lt;CategoryVO&gt; categoryVOList, Integer parentId)&#123;
        //递归获取所有子类别并组合 合成一个&quot;目录树&quot;
        List&lt;Category&gt; categoryList = categoryMapper.selectCategoriesByParentId(parentId);
        if (!CollectionUtils.isEmpty(categoryList))&#123;
            //空 或 有无元素   itli
            for (int i = 0; i &lt; categoryList.size(); i++) &#123;
                Category category =  categoryList.get(i);
                CategoryVO categoryVO = new CategoryVO();
                //拷贝链接  比原来的多一个childCategory这个字段未被赋值
                BeanUtils.copyProperties(category, categoryVO);
                categoryVOList.add(categoryVO);
                //拿到childCategory字段并赋值 再从上面return categoryVOList;
                recursivelyFindCategories(categoryVO.getChildCategory(), categoryVO.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/CategoryMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Category;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CategoryMapper &#123;
    int deleteByPrimaryKey(Integer id);
    int insert(Category record);
    int insertSelective(Category record);
    Category selectByPrimaryKey(Integer id);
    int updateByPrimaryKeySelective(Category record);
    int updateByPrimaryKey(Category record);
    Category selectByName(String name);
    List&lt;Category&gt; selectList();
    List&lt;Category&gt; selectCategoriesByParentId(Integer parentId);
&#125;
</code></pre>
<pre><code class="java">mappers/CategoryMapper.xml
&lt;mapper&gt;
 &lt;select id=&quot;selectList&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_category
  &lt;/select&gt;
  &lt;select id=&quot;selectCategoriesByParentId&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;int&quot;&gt;
    select &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_category
    where parent_id = #&#123;parentId&#125;
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="利用Redis缓存加速响应-目录变化频繁-访问量大的-增加效率"><a href="#利用Redis缓存加速响应-目录变化频繁-访问量大的-增加效率" class="headerlink" title="利用Redis缓存加速响应 [目录变化频繁(访问量大的) 增加效率]"></a>利用Redis缓存加速响应 [目录变化频繁(访问量大的) 增加效率]</h3><pre><code class="xml">pom.xml
&lt;!--    55.导入Redis的pom文件    --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">56.增加一个@EnableCaching注解让idea知道你想打开缓存功能
com/imooc/mall/MallApplication.java
package com.imooc.mall;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;)
@EnableSwagger2
@EnableCaching
//56.增加注解 并去想用的前面加注解 @Cacheable(value = &quot;listCategoryForCustomer&quot;)
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>import org.springframework.cache.annotation.Cacheable; [对的]<br><del>import springfox.documentation.annotations.Cacheable;</del> [错的]</p>
</blockquote>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//这里要格外注意 不要导错包 不然运行不了redis 里面的keys会没有键值对
// import org.springframework.cache.annotation.Cacheable; [对的]
// import springfox.documentation.annotations.Cacheable; [错的]
 //54.用户分类列表接口开发
    @Override //56.在下方加想用Redis的注解  
  //57.创建一个对于缓存的配置类com/imooc/mall/config/CachingConfig.java
    @Cacheable(value = &quot;listCategoryForCustomer&quot;)
    public List&lt;CategoryVO&gt; listCategoryForCustomer()&#123;
        ArrayList&lt;CategoryVO&gt; categoryVOList = new ArrayList&lt;&gt;();
        recursivelyFindCategories(categoryVOList, 0);
        //55.去Mapper.java 和 Mapper.xml写方法
        return categoryVOList;
    &#125;

    private void recursivelyFindCategories(List&lt;CategoryVO&gt; categoryVOList, Integer parentId)&#123;
        //递归获取所有子类别并组合 合成一个&quot;目录树&quot;
        List&lt;Category&gt; categoryList = categoryMapper.selectCategoriesByParentId(parentId);
        if (!CollectionUtils.isEmpty(categoryList))&#123;
            //空 或 有无元素   itli
            for (int i = 0; i &lt; categoryList.size(); i++) &#123;
                Category category =  categoryList.get(i);
                CategoryVO categoryVO = new CategoryVO();
                //拷贝链接  比原来的多一个childCategory这个字段未被赋值
                BeanUtils.copyProperties(category, categoryVO);
                categoryVOList.add(categoryVO);
                //拿到childCategory字段并赋值 再从上面return categoryVOList;
                recursivelyFindCategories(categoryVO.getChildCategory(), categoryVO.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/CachingConfig.java
package com.imooc.mall.config;

import org.springframework.context.annotation.Bean;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.RedisConnectionFactory;

import java.time.Duration;

/**
 * 57.缓存的配置类 想要运行成功保存序列化 要去弄个序列化接口com/imooc/mall/model/vo/CategoryVO.java
 */
@Configuration
@EnableCaching
public class CachingConfig &#123;
    @Bean
    public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory) &#123;

        RedisCacheWriter redisCacheWriter = RedisCacheWriter
                .lockingRedisCacheWriter(connectionFactory);
        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
        cacheConfiguration = cacheConfiguration.entryTtl(Duration.ofSeconds(30));

        RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter,
                cacheConfiguration);
        return redisCacheManager;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/CategoryVO.java
public class CategoryVO implements Serializable &#123;
     private Integer id;
    private String name;
    private Integer type;
    private Integer parentId;
    private Integer orderNum;
    private Date createTime;
    private Date updateTime;
    private List&lt;CategoryVO&gt; childCategory = new ArrayList&lt;&gt;();
&#125;Setter+Getter
</code></pre>
<h3 id="Idea调试技巧"><a href="#Idea调试技巧" class="headerlink" title="Idea调试技巧"></a>Idea调试技巧</h3><ul>
<li>断点统一开关</li>
<li>条件断点</li>
<li>单步调试<ul>
<li>step into 会进入方法内部</li>
<li>step out 跳出方法</li>
</ul>
</li>
<li>表达式求值 [Evaluate Expression]</li>
</ul>
<h3 id="总结商品分类模块"><a href="#总结商品分类模块" class="headerlink" title="总结商品分类模块"></a>总结商品分类模块</h3><ul>
<li>重难点：参数校验、Swagger[API文档自动]、统一鉴权[Filter过滤器]、Redis整合[Springboot整合]、调试功能</li>
<li>常见错误：参数手动校验、<span style = "color:red"><strong>项目没用Redis缓存</strong></span>、不善用调试</li>
</ul>
<h1 id="商品模块介绍"><a href="#商品模块介绍" class="headerlink" title="商品模块介绍"></a>商品模块介绍</h1><h6 id="演示、数据表设计、接口设计"><a href="#演示、数据表设计、接口设计" class="headerlink" title="演示、数据表设计、接口设计"></a>演示、数据表设计、接口设计</h6><h3 id="新增商品功能开发"><a href="#新增商品功能开发" class="headerlink" title="新增商品功能开发"></a>新增商品功能开发</h3><pre><code class="java">com\imooc\mall\controller\ProductAdminController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import org.springframework.stereotype.Controller;

/**
 * 58.后台商品管理Controller  pojo的product复制一份到request变成AddProductReq
   59.需要ProductService.java
 */
@Controller
public class ProductAdminController &#123;
    @Autowired
    ProductService productService;
    @PostMapping(&quot;admin/product/add&quot;)
    public ApiRestResponse addProduct(@Valid @RequestBody AddProductReq addProductReq)&#123;
    //61.补全代码  目前图片上传还未开发成功
        productService.add(addProductReq);
        return ApiRestResponse.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/request/AddProductReq.java
package com.imooc.mall.model.request;

import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;

public class AddProductReq &#123;
    @NotNull(message = &quot;商品名称不能为null&quot;)
    private String name;
    @NotNull(message = &quot;商品图片不能为null&quot;)
    private String image;

    private String detail;
    @NotNull(message = &quot;商品分类不能为null&quot;)
    private Integer categoryId;
    @NotNull(message = &quot;商品价格不能为null&quot;)
    @Min(value = 1, message = &quot;价格不能为null&quot;)
    private Integer price;

    @NotNull(message = &quot;商品库存不能为null&quot;)
    @Max(value = 10000, message = &quot;库存不能大于10000&quot;)
    private Integer stock;

    private Integer status;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/mall/service/ProductService.java
package com.imooc.mall.service;

import com.imooc.mall.model.request.AddProductReq;

/**
 * 59.商品Service 再创建一个实现类ProductServiceImpl
 */
public interface ProductService &#123;

    void add(AddProductReq addProductReq);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.ProductMapper;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.AddProductReq;
import com.imooc.mall.service.ProductService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 59.商品服务实现类
 */
@Service
public class ProductServiceImpl implements ProductService &#123;
    @Autowired
    ProductMapper productMapper;//60.ProductMapper SQL通过名字查找product是否存在 151行
    @Override
    public void add(AddProductReq addProductReq)&#123;
        Product product = new Product();
        BeanUtils.copyProperties(addProductReq, product);//赋值
        //61.商品重名情况  返回ProductAdminController补全代码  
        //62.图片上传接口 ProductAdminController
        Product productOld = productMapper.selectByName(addProductReq.getName());
        if (productOld != null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
        int count = productMapper.insertSelective(product);
        if (count == 0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.CREATE_FAILED);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><ul>
<li>文件名UUID</li>
<li>通用唯一识别码(Universally Unique Identifier)</li>
<li>防止重名、防止爬图</li>
<li>生成规则：日期和时间、<strong>MAC地址、HashCode、随机数</strong></li>
</ul>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
//62.图片上传接口
    @PostMapping(&quot;admin/upload/file&quot;)
    public  ApiRestResponse upload(HttpServletRequest httpServletRequest, @RequestParam(&quot;file&quot;) MultipartFile file)&#123;
        String fileName = file.getOriginalFilename();
        String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));//用文件后面的名字
        //生成文件名称UUID
        UUID uuid = UUID.randomUUID();
        String newFileName = uuid.toString() + suffixName;
        //创建文件 放在常量类中 Constant.java
        //63.application.properties配置file.upload.dir
//        new File()
        File fileDirectory = new File(Constant.FILE_UPLOAD_DIR);
        File destFile = new File(Constant.FILE_UPLOAD_DIR + newFileName);
        if (!fileDirectory.exists())&#123;
            if (!fileDirectory.mkdir())&#123;//新建文件夹
                throw new ImoocMallException(ImoocMallExceptionEnum.MKDIR_FAILED);
            &#125;
        &#125;
        try &#123;
            file.transferTo(destFile); //传进来的写到空的方法中去
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
        try &#123;
            return ApiRestResponse.success(getHost(new URI(httpServletRequest.getRequestURL()+&quot;&quot;))+&quot;/images/&quot;+newFileName); //生成的路径IP和端口号
        &#125; catch (URISyntaxException e) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.UPLOAD_FAILED);
        &#125;
    &#125;
    private URI getHost(URI uri)&#123;
        URI effectiveURI;
        try &#123;
            effectiveURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(),null,null,null);
        &#125; catch (URISyntaxException e) &#123;
            effectiveURI = null; //如果新建失败 就返回回去
        &#125;
        return effectiveURI;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    public static String FILE_UPLOAD_DIR;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    NEED_ADMIN(10009,&quot;无管理员权限&quot;),
    NAME_NOT_NULL(10010,&quot;参数不能为空&quot;),
    PARA_NOT_NULL(10011,&quot;参数不能为空&quot;),
    CREATE_FAILED(10012,&quot;新增失败&quot;),
    REQUEST_PARAM_ERROR(10013,&quot;参数错误&quot;),
    DELETE_FAILED(10014,&quot;删除失败&quot;),
    MKDIR_FAILED(10015,&quot;文件夹创建失败&quot;),
    UPLOAD_FAILED(10015,&quot;图片上传失败&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
&#125;
</code></pre>
<h3 id="资源映射开发"><a href="#资源映射开发" class="headerlink" title="资源映射开发"></a>资源映射开发</h3><blockquote>
<p>此时从postman中创建一个上传图片的接口<br>127.0.0.1:8083&#x2F;admin&#x2F;upload&#x2F;file<br>选择Body→form-data<br>此时上传图片会报错 {<br>  “status”: 20000,<br>  “msg”: “系统异常”,<br>  “data”: null<br>}</p>
</blockquote>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
@Component //让spring帮注入value
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
    public static String FILE_UPLOAD_DIR;
    //64.为了解决上传图片系统异常报错 注入失败的原因是上方是static普通变量 set方法把静态变量赋值
    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    public void setFileUploadDir(String fileUploadDir)&#123;
        FILE_UPLOAD_DIR = fileUploadDir;
    &#125;//65.打开ImoocMallWebMvcConfig 加一个映射规则
&#125;
</code></pre>
<h3 id="自定义静态资源映射目录"><a href="#自定义静态资源映射目录" class="headerlink" title="自定义静态资源映射目录"></a>自定义静态资源映射目录</h3><ul>
<li>上传图片后回显</li>
<li>配置SpringBootWebMvcConfig</li>
<li>静态资源到本地目录的映射</li>
<li>演示打开图片</li>
</ul>
<pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
package com.imooc.mall.config;

import com.imooc.mall.common.Constant;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
 * 44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;
    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + Constant.FILE_UPLOAD_DIR);
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="更新-UpdateProductReq-和新增-AddProductReq-商品"><a href="#更新-UpdateProductReq-和新增-AddProductReq-商品" class="headerlink" title="更新(UpdateProductReq)和新增(AddProductReq)商品"></a>更新(UpdateProductReq)和新增(AddProductReq)商品</h3><ul>
<li>合并写法不可取</li>
<li>业务逻辑清晰、独立</li>
</ul>
<pre><code class="java">com/imooc/mall/model/request/UpdateProductReq.java
public class UpdateProductReq &#123;
    @NotNull
    private Integer id; 
    private String name;
    private String image;
    private String detail;
    private Integer categoryId;
    @Min(value = 1, message = &quot;价格不能为null&quot;)
    private Integer price;

    @Max(value = 10000, message = &quot;库存不能大于10000&quot;)
    private Integer stock;

    private Integer status;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
package com.imooc.mall.config;

import com.imooc.mall.common.Constant;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
 * 44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;
    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
        //65.增加一个registry  66.新增接口继续开发 ProductAdminController
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + Constant.FILE_UPLOAD_DIR);
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
 //66. 接口 复制一个request中的AddProductReq 之后回来补全代码
    @ApiOperation(&quot;后台更新商品&quot;)
    @PostMapping(&quot;/admin/product/update&quot;)
    public ApiRestResponse updateProduct(@Valid @RequestBody UpdateProductReq updateProductReq)&#123;
        Product product = new Product();
        BeanUtils.copyProperties(updateProductReq, product);
        //67.进入ProductServiceImpl编写接口实现类
        productService.update(product);
        return ApiRestResponse.success();
    &#125;
    //68. 搞一个删除的接口 同理也在ProductServiceImpl中写实现类 之后回来补全代码
    @ApiOperation(&quot;后台删除商品&quot;)
    @PostMapping(&quot;/admin/product/delete&quot;)
    public ApiRestResponse deleteProduct(@RequestParam Integer id)&#123;
        productService.delete(id);
        return ApiRestResponse.success();
    &#125;com/imooc/mall/controller/ProductAdminController.java
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
//67.写updateProduct实现类 @Override自动导入
    @Override
    public void update(Product updateProduct) &#123;
        Product productOld = productMapper.selectByName(updateProduct.getName());
        //同名且不同id，不能继续修改
        if (productOld != null &amp;&amp; productOld.getId().equals(updateProduct.getId())) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
        int count = productMapper.updateByPrimaryKeySelective(updateProduct);
        if (count == 0) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;
    &#125;

    //68.删除实现类  @Override自动导入
    @Override
    public void delete(Integer id) &#123;
        Product productOld = productMapper.selectByPrimaryKey(id);
        //查不到该记录，无法删除
        if (productOld == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
        int count = productMapper.deleteByPrimaryKey(id);
        if (count == 0) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
    &#125;
</code></pre>
<h3 id="批量上下架"><a href="#批量上下架" class="headerlink" title="批量上下架"></a>批量上下架</h3><ul>
<li>MyBatis遍历List</li>
<li>where语句拼接</li>
</ul>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
//69. 批量上下架接口 同理也在ProductServiceImpl中写实现类 Napper中增加批量上下架的SQL
    // 之后回来补全代码
    @ApiOperation(&quot;后台批量上下架接口&quot;)
    @PostMapping(&quot;/admin/product/batchUpdateSellStatus&quot;)
    public ApiRestResponse batchUpdateSellStatus(@RequestParam Integer[] ids, @RequestParam Integer sellStatus)&#123;
        productService.batchUpdateSellStatus(ids,sellStatus);
        return ApiRestResponse.success();
    &#125;
=====================================================
127.0.0.1:8083//admin/product/batchUpdateSellStatus?ids=2,3&amp;sellStatus=0
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
//69.去ProductAdminController增加batchUpdateSellStatus接口
    @Override
    public void batchUpdateSellStatus(Integer[] ids, Integer sellStatus)&#123;
        productMapper.batchUpdateSellStatus(ids, sellStatus);
    return null;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/ProductMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Product;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Product record);

    int insertSelective(Product record);

    Product selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Product record);

    int updateByPrimaryKey(Product record);

    Product selectByName(String name);
    int batchUpdateSellStatus(@Param(&quot;ids&quot;) Integer[] ids, @Param(&quot;sellStatus&quot;) Integer sellStatus);

&#125;
</code></pre>
<pre><code class="java">mappers/ProductMapper.xml
  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_product
    where name = #&#123;name,jdbcType = VARCHAR&#125;
  &lt;/select&gt;
  &lt;update id=&quot;batchUpdateSellStatus&quot;&gt;
    update imooc_mall_product
    set status=#&#123;sellStatus&#125;
    where id in
    &lt;foreach collection=&quot;ids&quot; close=&quot;)&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt;
      #&#123;id&#125;
    &lt;/foreach&gt;
  &lt;/update&gt;
</code></pre>
<h3 id="后台商品列表、商品详情接口"><a href="#后台商品列表、商品详情接口" class="headerlink" title="后台商品列表、商品详情接口"></a>后台商品列表、商品详情接口</h3><pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
 //70.后台商品列表接口
    @Override
    public PageInfo listForAdmin(Integer pageNum, Integer pageSize)&#123;
        PageHelper.startPage(pageNum, pageSize); //在mapper里写查询sql
        List&lt;Product&gt; products = productMapper.selectListForAdmin();
        PageInfo pageInfo = new PageInfo(products);
        return pageInfo;
    &#125;
    //72.商品详情接口开发 再去ProductController调用
    @Override
    public Product detail(Integer id)&#123;
        Product product = productMapper.selectByPrimaryKey(id);
        return product;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
 //70.后台商品列表接口 同理也在ProductServiceImpl中写实现类 Napper中增加批量上下架的SQL 补全代码
    //71.开发与前台商品ProductController.java
    @ApiOperation(&quot;后台商品列表接口&quot;)
    @PostMapping(&quot;/admin/product/list&quot;)
    public ApiRestResponse list(@RequestParam Integer[] pageNum, @RequestParam Integer pageSize)&#123;
        PageInfo pageInfo = productService.batchUpdateSellStatus(pageNum,pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.service.ProductService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 71.前台商品Controller 72新增detail接口 ProductServiceImpl.java
 */
@RestController
public class ProductController &#123;
    @Autowired
    ProductService productService;

    @ApiOperation(&quot;商品详情&quot;)
    @GetMapping(&quot;product/detail&quot;)
    public ApiRestResponse detail(@RequestParam Integer id)&#123;
        Product product = productService.detail(id);
        return ApiRestResponse.success(product);
    &#125;
&#125;
</code></pre>
<h3 id="前台商品列表接口part1"><a href="#前台商品列表接口part1" class="headerlink" title="前台商品列表接口part1"></a>前台商品列表接口part1</h3><h5 id="商品列表：搜索功能"><a href="#商品列表：搜索功能" class="headerlink" title="商品列表：搜索功能"></a>商品列表：搜索功能</h5><p>入参判空 → 加%通配符 → like关键字</p>
<h5 id="对于查询目录的in处理"><a href="#对于查询目录的in处理" class="headerlink" title="对于查询目录的in处理"></a>对于查询目录的in处理</h5><ul>
<li>目录处理：如果查某个目录下的商品，不仅是需要查出来该目录的，还需要查出来子目录的所有商品</li>
<li>所以这里要拿到某一个目录Id下的所有子目录id的List</li>
</ul>
<h5 id="前台：商品列表"><a href="#前台：商品列表" class="headerlink" title="前台：商品列表"></a>前台：商品列表</h5><ul>
<li>排序功能</li>
<li>MyBatis PageHelper</li>
<li>枚举：order by [自定义]</li>
</ul>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
//72.商品详情接口开发 再去ProductController调用
    @Override
    public Product detail(Integer id)&#123;
        Product product = productMapper.selectByPrimaryKey(id);
        return product;
    &#125;
    //73.完成实现类
    @Override
    public PageInfo list(ProductListReq productListReq)&#123;
        //复杂查询就构建一个querry对象 ProductListQuery.java
        ProductListQuery productListQuery = new ProductListQuery();
        //☆☆搜索处理☆☆  拼接且转换成字符串去数据库查找
        if (!StringUtils.isEmpty(productListReq.getKeyword()))&#123;
            String keyword = new StringBuilder().append(&quot;%&quot;).append(productListReq.getKeyword()).append(&quot;%&quot;).toString();
            productListQuery.setKeyword(keyword);
        &#125;
        //☆☆目录处理☆☆：如果查某个目录下的商品，不仅是需要查出该目录下的，还要把所有子目录的所有商品都查出来，所以要拿到一个目录id的List
        if (productListReq.getCategoryId() != null)&#123;
            //要拿到子目录 引用CategoryService   CategoryVO原本是给前台目录用的 需要重构一下 不是所有目录而是指定目录
            //改动代码 CategoryServiceImpl.java中的listCategoryForCustomer 传入的参数是Integer parentId
            //productListReq获取了所有根节点的list  因为点开List&lt;CategoryVO&gt;里面包括一个  private List&lt;CategoryVO&gt;递归结构
            List&lt;CategoryVO&gt; categoryVOList = categoryService.listCategoryForCustomer(productListReq.getCategoryId());
            ArrayList&lt;Integer&gt; categoryIds = new ArrayList&lt;&gt;(); //拿过来之后存储的list
            categoryIds.add(productListReq.getCategoryId());
            getCategoryIds(categoryVOList,categoryIds);
            productListQuery.setCategoryIds(categoryIds);
        &#125;
        //74.排序能力 错误:前端传什么就 就传到sql中排序  这样是不安全的 要提前处理好
        //☆☆排序处理☆☆：去Constant定义支持的排序模式和手段
        String orderBy = productListReq.getOrderBy();
        if (Constant.ProductListOrderBy.PRICE_ASC_DESC.contains(orderBy)) &#123;
            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize(), orderBy);
        &#125;else &#123;//前端不一定包含数据的话就不排序了
            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize());
        &#125;//75.去写Mapper 最后回到ProductController写调用
        List&lt;Product&gt; productList = productMapper.selectList(productListQuery);
        PageInfo pageInfo = new PageInfo(productList);
        return pageInfo;
    &#125;
    //74.写一个方法拿到所有的id 拿到参数之后往哪里存放
    private void getCategoryIds(List&lt;CategoryVO&gt;categoryVOList, ArrayList&lt;Integer&gt; categoryIds)&#123;
        for (int i = 0; i &lt; categoryVOList.size(); i++) &#123;
            CategoryVO categoryVO =  categoryVOList.get(i);
            if (categoryVO != null)&#123;
                categoryIds.add(categoryVO.getId());
                //递归子节点 子子节点
                getCategoryIds(categoryVO.getChildCategory(), categoryIds); //去上面调用方法 传入对象
            &#125;
            
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/query/ProductListQuery.java
package com.imooc.mall.model.query;

import java.util.List;

/**
 * 查询商品列表的Query
 */
public class ProductListQuery &#123;
    private String keyword;
    private List&lt;Integer&gt; categoryIds;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/ProductMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.query.ProductListQuery;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductMapper &#123;
    List&lt;Product&gt; selectListForAdmin(); //给前台用户用的
    List&lt;Product&gt; selectList(@Param(&quot;ids&quot;)ProductListQuery query); //给后台用户用的 Type是一个类

&#125;
</code></pre>
<pre><code class="java">mappers/ProductMapper.xml
 &lt;select id=&quot;selectList&quot; resultMap=&quot;BaseResultMap&quot;
          parameterType=&quot;com.imooc.mall.model.query.ProductListQuery&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_product
    &lt;where&gt;
      &lt;if test=&quot;query.keyword != null&quot;&gt;
        and name like #&#123;query.keyword&#125;
      &lt;/if&gt;
      &lt;if test=&quot;query.categoryIds != null&quot;&gt;
        and category_id in
        &lt;foreach collection=&quot;query.categoryIds&quot; close=&quot;)&quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt;
          #&#123;item&#125;
        &lt;/foreach&gt;
      &lt;/if&gt;
      and status = 1
    &lt;/where&gt;
    order by update_time desc
  &lt;/select&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/ProductMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.query.ProductListQuery;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Product record);

    int insertSelective(Product record);

    Product selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Product record);

    int updateByPrimaryKey(Product record);

    Product selectByName(String name);
    int batchUpdateSellStatus(@Param(&quot;ids&quot;) Integer[] ids, @Param(&quot;sellStatus&quot;) Integer sellStatus);

    List&lt;Product&gt; selectListForAdmin(); //给前台用户用的

    List&lt;Product&gt; selectList(@Param(&quot;query&quot;)ProductListQuery query); //给后台用户用的 Type是一个类

&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductController.java
package com.imooc.mall.controller;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.ProductListReq;
import com.imooc.mall.service.ProductService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 71.前台商品Controller 72新增detail接口 ProductServiceImpl.java
 */
@RestController
public class ProductController &#123;
    @Autowired
    ProductService productService;

    @ApiOperation(&quot;商品详情&quot;)
    @GetMapping(&quot;product/detail&quot;)
    public ApiRestResponse detail(@RequestParam Integer id)&#123;
        Product product = productService.detail(id);
        return ApiRestResponse.success(product);
    &#125;
    //73.开发前台商品列表 开一个ProductListReq.java 去ProductServiceImpl
    @ApiOperation(&quot;商品详情&quot;)
    @GetMapping(&quot;product/list&quot;)
    public ApiRestResponse list(ProductListReq productListReq)&#123;
        PageInfo list = productService.list(productListReq);
        return ApiRestResponse.success(list);
    &#125;
&#125;
</code></pre>
<h3 id="总结商品模块"><a href="#总结商品模块" class="headerlink" title="总结商品模块"></a>总结商品模块</h3><ul>
<li>重难点：<strong>商品的搜索</strong>[<u>like</u>]、<strong>排序</strong>[<u>枚举+自定义</u>]、<strong>目录查询</strong>[<u>所有目录id都查到  再用查询列表方式</u>]</li>
<li>常见错误：更新和新增放在同一个接口、排序字段不用枚举</li>
</ul>
<h3 id="购物车模块介绍"><a href="#购物车模块介绍" class="headerlink" title="购物车模块介绍"></a>购物车模块介绍</h3><h5 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h5><ul>
<li>添加商品到购物车 → 商品是否在售、是否有库存 <ul>
<li>→[否] 提示用户</li>
<li>→[是] 该商品之前就在购物车里<ul>
<li>→[否] 添加新商品</li>
<li>→[是] 原有基础上添加数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">com/imooc/mall/controller/CartController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * 76.购物车Controller  77.用一个通用UserFilter逻辑
 */
@Controller
@RequestMapping(&quot;/cart&quot;)
public class CartController &#123;//因为放在url中 要加数据绑定 通过HttpSession获取用户信息太麻烦 用一个通用filter逻辑
    @PostMapping(&quot;/add&quot;)
    public ApiRestResponse add(@RequestParam Integer productId, @RequestParam Integer count)&#123;
        return null;
    &#125;
&#125;
========================================================
127.0.0.1:8083/cart/add?productId=22&amp;count=1
</code></pre>
<pre><code class="java">com/imooc/mall/filter/UserFilter.java
package com.imooc.mall.filter;

import com.imooc.mall.common.Constant;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.PrintWriter;

/**
 *
 * 77.用户过滤器 希望把用户信息currentUser保存下来
 */
public class UserFilter implements Filter &#123;
    public static User currentUser;
    @Autowired
    UserService userService;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        //对身份进行校验 用session获取当前的用户
        HttpServletRequest request = (HttpServletRequest)servletRequest;
        HttpSession session = request.getSession();
        currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) servletResponse).getWriter();
            out.write(&quot;&#123;\n&quot; //用户未登录
                    + &quot;    \&quot;status\&quot;: 10007,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            out.flush();
            out.close();
            return;
        &#125;
        //78.续写过滤器链条 写好后对用户链条进行config配置 UserFilterConfig.java
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;

    @Override
    public void destroy() &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/UserFilterConfig.java
package com.imooc.mall.config;

import com.imooc.mall.filter.UserFilter;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 78.对调用接口时对哪个类进行拦截 过滤器的配置 79创建cartService
 */
@Configuration
public class UserFilterConfig &#123;
    @Bean
    public UserFilter userFilter()&#123;
        return new UserFilter();
    &#125;
    @Bean(name = &quot;userFilterConf&quot;)
    public FilterRegistrationBean adminFilterConfig()&#123;
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
        filterRegistrationBean.setFilter(userFilter());
        //下面的是校验与拦截
        filterRegistrationBean.addUrlPatterns(&quot;/cart/*&quot;); //CartController.java
        filterRegistrationBean.addUrlPatterns(&quot;/order/*&quot;);
        filterRegistrationBean.setName(&quot;userFilterConf&quot;);
        return filterRegistrationBean;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CartServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.CategoryMapper;
import com.imooc.mall.model.dao.ProductMapper;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.vo.CartVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 80.购物车Service实现类 其中List&lt;&gt;中间是需要包括 商品id 图片 名字 商品选中 数量信息
 * 81.创建一个VO增加那些属性放在&lt;&gt;中 是返回给前端组合后的对象
 */
@Service
public class CartServiceImpl &#123;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CategoryMapper categoryMapper;

    public List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count) &#123;
        validProduct(productId, count);

    &#125;

    private void validProduct(Integer productId, Integer count) &#123;
        Product product = productMapper.selectByPrimaryKey(productId);
        //判断商品是否存在，商品是否上架
        if (product == null || product.getStatus().equals(Constant.SaleStatus.NOT_SALE)) &#123;
            //82. 1是上架 1不明确要形成代码让顾客知道 Constant.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_SALE);
        &#125;
        //判断商品库存 如果要买的比库存多 就买不了
        if (count &gt; product.getStock()) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
    //83.创建商品上下架的状态 创建CartMapper[Cart selectCartByUserIdAndProductId] 写sql 
    //84再去CartServiceImpl
    public interface SaleStatus&#123;
        int NOT_SALE = 0; //商品下架状态
        int SALE = 1; //商品上架状态
    &#125;
</code></pre>
<pre><code class="java">@Service
public class CartServiceImpl implements CartService &#123;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CategoryMapper categoryMapper;
    @Autowired
    CartMapper cartMapper;
@Override
    public List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count) &#123;
        validProduct(productId, count);
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        //84.补全代码
        if (cart==null)&#123;
            //这个商品之前不在购物车里，需要新增一个记录
            cart = new Cart();
            cart.setProductId(productId);
            cart.setUserId(userId);
            cart.setQuantity(count);
            cart.setSelected(Constant.Cart.CHECKED);
            cartMapper.insertSelective(cart);
        &#125;else &#123;
            //这个商品已经在购物车里了，数量相加
            count = cart.getQuantity() + count;
            Cart cartNew = new Cart();
            cartNew.setQuantity(count);
            cartNew.setId(cart.getId());
            cartNew.setProductId(cart.getProductId());
            cartNew.setUserId(cart.getUserId());
            //无论是否想买都选中
            cartNew.setSelected(Constant.Cart.CHECKED);
            cartMapper.updateByPrimaryKeySelective(cartNew);
        &#125;
        //85.去CartController补全代码逻辑 返回购物车列表哦~ 86.CartMapper.java
        return null;
    &#125;

    private void validProduct(Integer productId, Integer count) &#123;
        Product product = productMapper.selectByPrimaryKey(productId);
        //判断商品是否存在，商品是否上架
        if (product == null || product.getStatus().equals(Constant.SaleStatus.NOT_SALE)) &#123;
            //82. 1是上架 1不明确要形成代码让顾客知道 Constant.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_SALE);
        &#125;
        //判断商品库存 如果要买的比库存多 就买不了
        if (count &gt; product.getStock()) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/CartMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Cart;
import com.imooc.mall.model.vo.CartVO;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Repository
public interface CartMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Cart record);

    int insertSelective(Cart record);

    Cart selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Cart record);

    int updateByPrimaryKey(Cart record);

    //86.选中列表的方法 传入的参数是userId
    List&lt;CartVO&gt; selectList(@Param(&quot;userId&quot;) Integer userId);
    Cart selectCartByUserIdAndProductId(@Param(&quot;userId&quot;) Integer userId, @Param(&quot;productId&quot;)Integer productId);
&#125;
</code></pre>
<pre><code class="xml">mappers/CartMapper.xml
 &lt;select id=&quot;selectList&quot; resultType=&quot;com.imooc.mall.model.vo.CartVO&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    select
    c.id as id,
    p.id as productId,
    c.user_id as userId,
    c.quantity as quantity,
    c.selected as selected,
    p.price as price,
    p.name as productName,
    p.image as productImage
    from imooc_mall_cart c
    left join imooc_mall_product p on p.id = c.product_id
    where c.user_id = #&#123;userId&#125;
    and p.status = 1
  &lt;/select&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CartController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.filter.UserFilter;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.service.CartService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * 76.购物车Controller  77.用一个通用User_filter逻辑
 */
@RestController //404的错误① 返回的json格式 要用RestController
@RequestMapping(&quot;/cart&quot;)
public class CartController &#123;//因为放在url中 要加数据绑定 通过HttpSession获取用户信息太麻烦 用一个通用filter逻辑
    @Autowired
    CartService cartService;
    @PostMapping(&quot;/list&quot;)
    @ApiOperation(&quot;购物车列表&quot;)
    public ApiRestResponse list()&#123;
        //86.去写service的list接口 CartMapper中写选中列表的方法
        //内部获取用户Id,防止横向越权
        List&lt;CartVO&gt; cartList = cartService.list(UserFilter.currentUser.getId());
        return ApiRestResponse.success();
    &#125;

    @PostMapping(&quot;/add&quot;)
    @ApiOperation(&quot;添加商品到购物车&quot;)
    public ApiRestResponse add(@RequestParam Integer productId, @RequestParam Integer count)&#123;
        //85.补全完逻辑代码 87在下面补全代码 List&lt;CartVO&gt; cartVOList =
        List&lt;CartVO&gt; cartVOList = cartService.add(UserFilter.currentUser.getId(), productId, count);
        return ApiRestResponse.success(cartVOList);
    &#125;
&#125;
</code></pre>
<h3 id="更新、删除购物车接口"><a href="#更新、删除购物车接口" class="headerlink" title="更新、删除购物车接口"></a>更新、删除购物车接口</h3><pre><code class="java">com/imooc/mall/controller/CartController.java
@PostMapping(&quot;/update&quot;)
    @ApiOperation(&quot;更新购物车&quot;)
    public ApiRestResponse update(@RequestParam Integer productId, @RequestParam Integer count)&#123;
        //86.去service层中写更新方法 CartServiceImpl.java
        List&lt;CartVO&gt; cartVOList = cartService.update(UserFilter.currentUser.getId(), productId, count);
        return ApiRestResponse.success(cartVOList);
    &#125;

    @PostMapping(&quot;/delete&quot;)
    @ApiOperation(&quot;删除保护购物车&quot;)
    public ApiRestResponse delete(@RequestParam Integer productId)&#123;
        //87.删除保护购物车方法
        //不能传入userId, cartId, 否则可以删除别人的购物车
        List&lt;CartVO&gt; cartVOList = cartService.delete(UserFilter.currentUser.getId(), productId);
        return ApiRestResponse.success(cartVOList);
    &#125;
=====================================================================
127.0.0.1:8083/cart/delete?productId=22
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CartServiceImpl.java
 @Override
    public List&lt;CartVO&gt; update(Integer userId, Integer productId, Integer count)&#123;
        //86.去service层中写更新方法
        validProduct(productId, count);
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        if (cart==null)&#123;
            //这个商品之前不在购物车里，无法更新
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;else &#123;
            //这个商品已经在购物车里了，则更新数量
            Cart cartNew = new Cart();
            cartNew.setQuantity(count);
            cartNew.setId(cart.getId());
            cartNew.setProductId(cart.getProductId());
            cartNew.setUserId(cart.getUserId());
            //无论是否想买都选中
            cartNew.setSelected(Constant.Cart.CHECKED);
            cartMapper.updateByPrimaryKeySelective(cartNew);
        &#125;
        return this.list(userId);
    &#125;

    @Override
    public List&lt;CartVO&gt; delete(Integer userId, Integer productId)&#123;
        //86.去service层中写更新方法
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        if (cart==null)&#123;
            //这个商品之前不在购物车里，无法更新
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;else &#123;
            //这个商品已经在购物车里了，则可以删除
            cartMapper.deleteByPrimaryKey(cart.getId());
        &#125;
        return this.list(userId);
    &#125;
======================================================================
127.0.0.1:8083/cart/update?productId=22&amp;count=1
</code></pre>
<pre><code class="java">com/imooc/mall/service/CartService.java
package com.imooc.mall.service;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.model.request.AddCategoryReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.model.vo.CategoryVO;

import java.util.List;

/**
 * 79.购物车service 增加CartServiceImpl
 */
public interface CartService &#123;

    //87.补全list实现类
    List&lt;CartVO&gt; list(Integer userId);

    List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; update(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; delete(Integer userId, Integer productId);
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/624114484">浅谈@RequestParam、@RequestBody、@PathVariable - 知乎 (zhihu.com)</a></p>
<h3 id="选中购物车相关接口"><a href="#选中购物车相关接口" class="headerlink" title="选中购物车相关接口"></a>选中购物车相关接口</h3><pre><code class="java">com/imooc/mall/controller/CartController.java
 @PostMapping(&quot;/select&quot;)
    @ApiOperation(&quot;选择/不选择购物车的某商品&quot;)
    public ApiRestResponse select(@RequestParam Integer productId, @RequestParam Integer selected)&#123;
        //88.选/不选购物车某商品
        //不能传入userId, cartId, 否则可以删除别人的购物车
        List&lt;CartVO&gt; cartVOList = cartService.selectOrNot(UserFilter.currentUser.getId(), productId,selected);
        return ApiRestResponse.success(cartVOList);
    &#125;

    @PostMapping(&quot;/selectAll&quot;)
    @ApiOperation(&quot;全选择/全不选择购物车的某商品&quot;)
    public ApiRestResponse selectAll(@RequestParam Integer selected)&#123;
        //89.全选/全不选购物车某商品
        //不能传入userId, cartId, 否则可以删除别人的购物车
////90.订单模块接口编写 91创建OrderController.java  OrderService.java  OrderServiceImpl.java
        List&lt;CartVO&gt; cartVOList = cartService.selectAllOrNot(UserFilter.currentUser.getId(), selected);
        return ApiRestResponse.success(cartVOList);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CartServiceImpl.java
    @Override
    public List&lt;CartVO&gt; selectOrNot(Integer userId, Integer productId, Integer selected)&#123;
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        if (cart==null)&#123;
            //88.这个商品之前不在购物车里，无法选择/不选中
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;else &#123;
            //这个商品已经在购物车里了，则可以选中/不选中
            cartMapper.selectOrNot(userId, productId, selected);
        &#125;//返回购物车列表
        return this.list(userId);
    &#125;

    @Override
    public List&lt;CartVO&gt; selectAllOrNot(Integer userId, Integer selected)&#123;
        //89.这里填null是对mapper中的sql进行等于null判断的语句 改变选中状态
        cartMapper.selectOrNot(userId, null, selected);
        return this.list(userId);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/CartService.java
package com.imooc.mall.service;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.model.request.AddCategoryReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.model.vo.CategoryVO;

import java.util.List;

/**
 * 79.购物车service 增加CartServiceImpl
 */
public interface CartService &#123;

    //87.补全list实现类
    List&lt;CartVO&gt; list(Integer userId);

    List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; update(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; delete(Integer userId, Integer productId);

    List&lt;CartVO&gt; selectOrNot(Integer userId, Integer productId, Integer selected);

    List&lt;CartVO&gt; selectAllOrNot(Integer userId, Integer selected);
&#125;
</code></pre>
<h3 id="总结购物车模块"><a href="#总结购物车模块" class="headerlink" title="总结购物车模块"></a>总结购物车模块</h3><ul>
<li><h5 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h5><ul>
<li>MyBatis返回非标准对象、后期计算单样商品的总价 [数据库无法直接查到]</li>
<li>添加商品到购物车时，根据是否已经存在该商品，有不同逻辑</li>
</ul>
</li>
<li><p>常见错误：不做越权判断 [不允许前端传入Id]</p>
</li>
</ul>
<h3 id="创建订单接口-主流程框架搭建"><a href="#创建订单接口-主流程框架搭建" class="headerlink" title="创建订单接口 - 主流程框架搭建"></a>创建订单接口 - 主流程框架搭建</h3><ul>
<li>登录 → 浏览商品 → 加入购物车 → 下单 <ul>
<li>​                                                            → 取消订单</li>
<li>​                                                            → 扫码支付 → 发货 → 收获 → 订单完结</li>
</ul>
</li>
</ul>
<h3 id="生成订单-——-用户下单"><a href="#生成订单-——-用户下单" class="headerlink" title="生成订单 —— 用户下单"></a>生成订单 —— 用户下单</h3><ul>
<li>入参</li>
<li>从购物车中查找已经勾选的商品</li>
<li>判断商品是否正在售卖中</li>
<li>判断库存，保证不超卖，扣库存</li>
<li>数据库事务(实操演示效果)</li>
<li>删除购物车中对应的商品</li>
<li>生成订单</li>
<li>订单号生成规则</li>
<li>循环保存每个商品到order_item表</li>
<li>进入Coding阶段</li>
</ul>
<pre><code class="java">com/imooc/mall/controller/OrderController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

/**
 * 91.订单Controller 新建一个根据pojo的Order → CreateOrderReq 新建一个OrderService
 */
@RestController
public class OrderController &#123;
    @Autowired
    OrderService orderService;

    @PostMapping(&quot;order/create&quot;)
    public ApiRestResponse create(@RequestBody CreateOrderReq createOrderReq)&#123;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.filter.UserFilter;
import com.imooc.mall.model.dao.CartMapper;
import com.imooc.mall.model.dao.CategoryMapper;
import com.imooc.mall.model.dao.ProductMapper;
import com.imooc.mall.model.pojo.Cart;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.service.CartService;
import com.imooc.mall.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * 91.★★ 订单Service实现类 ★★
 */
@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    CartService cartService;

    public String create(CreateOrderReq createOrderReq) &#123;
        //拿到用户ID
        Integer userId = UserFilter.currentUser.getId();
        //从购物车查找已经勾选的商品 CartVO里面包含着任何信息
        List&lt;CartVO&gt; cartVOList = cartService.list(userId);
        //勾选的单独拿出来
        ArrayList&lt;CartVO&gt; cartVOListTemp = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO = cartVOList.get(i);
            if (cartVO.getSelected().equals(Constant.Cart.CHECKED)) &#123;
                cartVOListTemp.add(cartVO);
            &#125;
        &#125;
        cartVOList = cartVOListTemp;
        //如果购物车已勾选的为空,报错
        if (CollectionUtils.isEmpty(cartVOList))&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.CART_EMPTY);
        &#125;
    &#125;
    //判断商品是否存在、上下架状态、库存
    //把购物车对象转换为订单item对象
    //扣库存
    //把购物车中的已勾选商品删除
    //生成订单
    //生成订单号,有独立的规则
    //循环保存每个商品的order_item表
    //把结果返回
&#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
package com.imooc.mall.exception;

/**
 * 异常枚举
 */
//13.编写异常枚举 注意类是enum噢  14返回ApiRestResponse
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    NEED_ADMIN(10009,&quot;无管理员权限&quot;),
    NAME_NOT_NULL(10010,&quot;参数不能为空&quot;),
    CREATE_FAILED(10011,&quot;新增失败&quot;),
    REQUEST_PARAM_ERROR(10012,&quot;参数错误&quot;),
    DELETE_FAILED(10013,&quot;删除失败&quot;),
    MKDIR_FAILED(10014,&quot;文件夹创建失败&quot;),
    UPLOAD_FAILED(10015,&quot;图片上传失败&quot;),
    NOT_SALE(10016,&quot;商品状态不可售&quot;),
    NOT_ENOUGH(10017,&quot;商品库存不足&quot;),
    CART_EMPTY(10018, &quot;购物车已勾选的商品为空&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);


    //异常码
    Integer code;
    //异常信息
    String msg;

    ImoocMallExceptionEnum(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<h3 id="创建订单-——-对象转换与扣库存"><a href="#创建订单-——-对象转换与扣库存" class="headerlink" title="创建订单 —— 对象转换与扣库存"></a>创建订单 —— 对象转换与扣库存</h3><pre><code class="java">com/imooc/mall/controller/OrderController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

/**
 * 91.订单Controller 新建一个根据pojo的Order → CreateOrderReq 新建一个OrderService
 */
@RestController
public class OrderController &#123;
    @Autowired
    OrderService orderService;

    @PostMapping(&quot;order/create&quot;)
    @ApiOperation(&quot;创建订单&quot;)
    public ApiRestResponse create(@RequestBody CreateOrderReq createOrderReq)&#123;
        //95.调用orderService
        String orderNo = orderService.create(createOrderReq);
        return ApiRestResponse.success(orderNo);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.filter.UserFilter;
import com.imooc.mall.model.dao.*;
import com.imooc.mall.model.pojo.Order;
import com.imooc.mall.model.pojo.OrderItem;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.service.CartService;
import com.imooc.mall.service.OrderService;
import com.imooc.mall.util.OrderCodeFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * 91.★★ 订单Service实现类 ★★
 */
@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    CartService cartService;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CartMapper cartMapper;
    @Autowired
    OrderMapper orderMapper;
    @Autowired
    OrderItemMapper orderItemMapper;
    @Override
    public String create(CreateOrderReq createOrderReq) &#123;
        //拿到用户ID
        Integer userId = UserFilter.currentUser.getId();
        //从购物车查找已经勾选的商品 CartVO里面包含着任何信息
        List&lt;CartVO&gt; cartVOList = cartService.list(userId);
        //勾选的单独拿出来
        ArrayList&lt;CartVO&gt; cartVOListTemp = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO = cartVOList.get(i);
            if (cartVO.getSelected().equals(Constant.Cart.CHECKED)) &#123;
                cartVOListTemp.add(cartVO);
            &#125;
        &#125;
        cartVOList = cartVOListTemp;
        //如果购物车已勾选的为空,报错
        if (CollectionUtils.isEmpty(cartVOList))&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.CART_EMPTY);
        &#125;
        //判断商品是否存在、上下架状态、库存
        validSaleStatusAndStock(cartVOList);
        //把购物车对象转换为订单item对象
        List&lt;OrderItem&gt; orderItemList = cartVOListToOrderItemList(cartVOList);
        //扣库存
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem =  orderItemList.get(i);
            Product product = productMapper.selectByPrimaryKey(orderItem.getProductId());
            int stock = product.getStock() - orderItem.getQuantity();
            if (stock &lt; 0)&#123;
                throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
            &#125;
            product.setStock(stock);
            productMapper.updateByPrimaryKeySelective(product);
        &#125;
        //把购物车中的已勾选商品删除
        cleanCart(cartVOList);
        //生成订单
        Order order = new Order();
        //93.创建一个Util/OrderCodeFactory
        //生成订单号,有独立的规则
        String orderNo = OrderCodeFactory.getOrderCode(Long.valueOf(userId));
        order.setOrderNo(orderNo);
        order.setUserId(userId);
        order.setTotalPrice(totalPrice(orderItemList));
        order.setReceiverName(createOrderReq.getReceiverName());
        order.setReceiverMobile(createOrderReq.getReceiverMobile());
        order.setReceiverAddress(createOrderReq.getReceiverAddress());
        order.setOrderStatus(Constant.OrderStatusEnum.NOT_PAID.getCode()); //94.去Constant定义订单状态
        //循环保存每个商品的order_item表
        order.setPostage(0);
        order.setPaymentType(1);
        //插入到Order表
        orderMapper.insertSelective(order);
        //循环保存每个商品到order_item表
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem =  orderItemList.get(i);
            orderItem.setOrderNo(order.getOrderNo());
            orderItemMapper.insertSelective(orderItem);
        &#125;
        //把结果返回
        return orderNo;
        //95.回到Controller调用
    &#125;
//92.生成相似代码并改造
    private void validSaleStatusAndStock(List&lt;CartVO&gt; cartVOList) &#123;
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO =  cartVOList.get(i);
            Product product = productMapper.selectByPrimaryKey(cartVO.getProductId());
            //判断商品是否存在，商品是否上架
            if (product == null || product.getStatus().equals(Constant.SaleStatus.NOT_SALE)) &#123;
                //82. 1是上架 1不明确要形成代码让顾客知道 Constant.java
                throw new ImoocMallException(ImoocMallExceptionEnum.NOT_SALE);
            &#125;
            //判断商品库存 如果要买的比库存多 就买不了
            if (cartVO.getQuantity() &gt; product.getStock()) &#123;
                throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
            &#125;
        &#125;
    &#125;
    private List&lt;OrderItem&gt; cartVOListToOrderItemList(List&lt;CartVO&gt; cartVOList) &#123;
        List&lt;OrderItem&gt; orderItemList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO =  cartVOList.get(i);
            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(cartVO.getProductId());
            //记录商品快照信息
            orderItem.setProductName(cartVO.getProductName());
            orderItem.setProductImg(cartVO.getProductImage());
            orderItem.setUnitPrice(cartVO.getPrice());
            orderItem.setQuantity(cartVO.getQuantity());
            orderItem.setTotalPrice(cartVO.getTotalPrice());
            orderItemList.add(orderItem);
        &#125;
        return orderItemList;
    &#125;
    private void cleanCart(List&lt;CartVO&gt; cartVOList)&#123;
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO =  cartVOList.get(i);
            cartMapper.deleteByPrimaryKey(cartVO.getId());

        &#125;
    &#125;
    private Integer totalPrice(List&lt;OrderItem&gt; orderItemList)&#123;
        Integer totalPrice = 0;
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem =  orderItemList.get(i);
            totalPrice += orderItem.getTotalPrice();
        &#125;
        return totalPrice;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/util/OrderCodeFactory.java
package com.imooc.mall.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Random;

/**
 * 描述：     生成订单No工具类
 */
public class OrderCodeFactory &#123;

    /**
     * 订单类别头
     */
    private static final String ORDER_CODE = &quot;1&quot;;
    /**
     * 随机编码
     */
    private static final int[] r = new int[]&#123;7, 9, 6, 2, 8, 1, 3, 0, 5, 4&#125;;
    /**
     * 用户id和随机数总长度
     */
    private static final int maxLength = 5;

    /**
     * 更具id进行加密+加随机数组成固定长度编码
     */
    private static String toCode(Long id) &#123;
        String idStr = id.toString();
        StringBuilder idSb = new StringBuilder();
        for (int i = idStr.length() - 1; i &gt;= 0; i--) &#123;
            idSb.append(r[idStr.charAt(i) - &#39;0&#39;]);
        &#125;
        return idSb.append(getRandom(maxLength - idStr.length())).toString();
    &#125;

    /**
     * 生成时间戳
     */
    private static String getDateTime() &#123;
        DateFormat sdf = new SimpleDateFormat(&quot;HHmmss&quot;);
        return sdf.format(new Date());
    &#125;

    /**
     * 生成固定长度随机码
     *
     * @param n 长度
     */
    private static long getRandom(long n) &#123;
        long min = 1, max = 9;
        for (int i = 1; i &lt; n; i++) &#123;
            min *= 10;
            max *= 10;
        &#125;
        long rangeLong = (((long) (new Random().nextDouble() * (max - min)))) + min;
        return rangeLong;
    &#125;

    /**
     * 生成不带类别标头的编码
     */
    private static synchronized String getCode(Long userId) &#123;
        userId = userId == null ? 10000 : userId;
        return getDateTime() + toCode(userId);
    &#125;

    /**
     * 生成订单单号编码
     */
    public static String getOrderCode(Long userId) &#123;
        return ORDER_CODE + getCode(userId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

import com.google.common.collect.Sets;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Set;


/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
@Component //让spring帮注入value
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
    public static String FILE_UPLOAD_DIR;
    //64.为了解决上传图片系统异常报错 注入失败的原因是上方是static普通变量 set方法把静态变量赋值
    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    public void setFileUploadDir(String fileUploadDir)&#123;
        FILE_UPLOAD_DIR = fileUploadDir;
    &#125;//65.打开ImoocMallWebMvcConfig 加一个映射规则

    //74.排序处理 去Constant定义支持的排序模式和手段
    public interface ProductListOrderBy&#123;
        Set&lt;String&gt; PRICE_ASC_DESC = Sets.newHashSet(&quot;price desc&quot;,&quot;price asc&quot;);
    &#125;
    //83.创建商品上下架的状态 创建CartMapper[Cart selectCartByUserIdAndProductId] 写sql 84再去CartServiceImpl
    public interface SaleStatus&#123;
        int NOT_SALE = 0; //商品下架状态
        int SALE = 1; //商品上架状态
    &#125;
    public interface Cart&#123;
        int UN_CHECKED = 0; //购物车未选中状态
        int CHECKED = 1; //购物车选中状态
    &#125;
    public enum OrderStatusEnum&#123;
        CANCELED(0, &quot;用户已取消&quot;),
        NOT_PAID(10, &quot;未付款&quot;),
        PAID(20, &quot;已付款&quot;),
        DELIVERED(30, &quot;已发货&quot;),
        ;

        private String value;
        private int code;
        //94.去Constant定义订单状态
        OrderStatusEnum(int code,String value)&#123;
            this.value = value;
            this.code = code;
        &#125;
        public static OrderStatusEnum codeOf(int code)&#123;
            for (OrderStatusEnum orderStatusEnum : values())&#123;
                if (orderStatusEnum.getCode() == code)&#123;
                    return orderStatusEnum;
                &#125;
            &#125;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ENUM);
        &#125;

        public String getValue() &#123;
            return value;
        &#125;

        public void setValue(String value) &#123;
            this.value = value;
        &#125;

        public int getCode() &#123;
            return code;
        &#125;

        public void setCode(int code) &#123;
            this.code = code;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="添加数据库事务"><a href="#添加数据库事务" class="headerlink" title="添加数据库事务"></a>添加数据库事务</h3><pre><code class="java">//95.写数据库事务代码 @Transactional (要么全对全要 要么全不要)
    @Transactional(rollbackFor = Exception.class)
    @Override
    public String create(CreateOrderReq createOrderReq) &#123;
     ......
    &#125;
</code></pre>
<h3 id="订单详情"><a href="#订单详情" class="headerlink" title="订单详情"></a>订单详情</h3><pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
/* 95.继续实现Service实现类 拷贝一个Order成OrderVo 新增两个属性
        private String orderStatusName;
        private List&lt;OrderItemVo&gt; orderItemVoList;
        因为没有&lt;OrderItemVo&gt;要根据需求去创建
        拷贝OrderItem成OrderItemVO 更改属性
        之后回来补写代码
     */
    public OrderVO detail(String orderNo)&#123;

    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/OrderItemVO.java
public class OrderItemVO &#123;
    private Integer id;

    private String orderNo;

    private Integer productId;

    private String productName;

    private String productImg;

    private Integer unitPrice;

    private Integer quantity;

    private Integer totalPrice;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/OrderVO.java
public class OrderVO &#123;
    private Integer id;

    private String orderNo;

    private Integer userId;

    private Integer totalPrice;

    private String receiverName;

    private String receiverMobile;

    private String receiverAddress;

    private Integer orderStatus;

    private Integer postage;

    private Integer paymentType;

    private Date deliveryTime;

    private Date payTime;

    private Date endTime;

    private Date createTime;

    private Date updateTime;
</code></pre>
<h5 id="订单状态"><a href="#订单状态" class="headerlink" title="订单状态"></a>订单状态</h5><ul>
<li>0 用户已取消</li>
<li>10 未付款(下单后的初始状态)</li>
<li>20 已付款</li>
<li>30 已发货</li>
<li>40 交易完成</li>
</ul>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 /* 95.继续实现Service实现类 拷贝一个Order成OrderVo 新增两个属性
        private String orderStatusName;
        private List&lt;OrderItemVo&gt; orderItemVoList;
        因为没有&lt;OrderItemVo&gt;要根据需求去创建
        拷贝OrderItem成OrderItemVO 更改属性
        之后回来补写代码
     */
   @Override
    public OrderVO detail(String orderNo)&#123;
        //96.去创建mapper的方法后回来补写代码 97写订单controller
        Order order = orderMapper.selectByOrderNo(orderNo);
        //订单不存在,则报错
        if (order == null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //订单存在,需要判断所属
        Integer userId = UserFilter.currentUser.getId();
        if (!order.getUserId().equals(userId)) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_YOUR_ORDER);
        &#125;
        OrderVO orderVO = getOrderVo(order);
        return orderVO;
    &#125;

    private OrderVO getOrderVo(Order order) &#123;
        OrderVO orderVO = new OrderVO();
        BeanUtils.copyProperties(order,orderVO);
        //获取订单对应的orderItemVOList
        List&lt;OrderItem&gt; orderItemList = orderItemMapper.selectByOrderNo(order.getOrderNo());
        //OrderItem和OrderItem相比少了几个字段
        List&lt;OrderItemVO&gt; orderItemVOList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem = orderItemList.get(i);
            OrderItemVO orderItemVO = new OrderItemVO();
            BeanUtils.copyProperties(orderItem, orderItemVO);
            orderItemVOList.add(orderItemVO);
        &#125;
        orderVO.setOrderItemVOList(orderItemVOList);
        //com/imooc/mall/common/Constant.java的列举枚举
        orderVO.setOrderStatusName(Constant.OrderStatusEnum.codeOf(orderVO.getOrderStatus()).getValue());
        return orderVO;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/OrderMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Order;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Order record);

    int insertSelective(Order record);

    Order selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Order record);

    int updateByPrimaryKey(Order record);

    Order selectByOrderNo(String orderNo);
&#125;

=====================================================
 &lt;select id=&quot;selectByOrderNo&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.String&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_order
    where order_no = #&#123;orderNo&#125;
  &lt;/select&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/OrderController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.model.vo.OrderVO;
import com.imooc.mall.service.OrderService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * 91.订单Controller 新建一个根据pojo的Order → CreateOrderReq 新建一个OrderService
 */
@RestController
public class OrderController &#123;
    @Autowired
    OrderService orderService;

    @PostMapping(&quot;order/create&quot;)
    @ApiOperation(&quot;创建订单&quot;)
    public ApiRestResponse create(@RequestBody CreateOrderReq createOrderReq)&#123;
        //95.调用orderService
        String orderNo = orderService.create(createOrderReq);
        return ApiRestResponse.success(orderNo);
    &#125;

    @GetMapping(&quot;order/detail&quot;)
    @ApiOperation(&quot;前台订单详情&quot;)
    public ApiRestResponse detail(@RequestParam String orderNo)&#123;
        //95.调用orderService  Service层具体实现
        OrderVO orderVO = orderService.detail(orderNo);
        return ApiRestResponse.success(orderVO);
    &#125;
&#125;
==========================================
生成订单详情 GET:127.0.0.1:8083/order/detail?orderNo=100233359639
</code></pre>
<h3 id="订单列表"><a href="#订单列表" class="headerlink" title="订单列表"></a>订单列表</h3><pre><code class="java">com/imooc/mall/controller/OrderController.java
//97.写一个订单列表controller
    @GetMapping(&quot;order/list&quot;)
    @ApiOperation(&quot;前台订单列表&quot;)
    public ApiRestResponse list(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        //95.调用list   Service  Service层具体实现
        PageInfo pageInfo = orderService.listForCustomer(pageNum, pageSize);
        return  ApiRestResponse.success(pageInfo);
    &#125;
===============================================
订单列表：GET:127.0.0.1:8083/order/list?pageNum=1&amp;pageSize=10
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
  //97.前台订单实现类 搞个OrderMapper中的selectForCustomer
    @Override
    public PageInfo listForCustomer(Integer pageNum, Integer pageSize)&#123;
        Integer userId = UserFilter.currentUser.getId();
        PageHelper.startPage(pageNum, pageSize);
        List&lt;Order&gt; orderList = orderMapper.selectForCustomer(userId);
        List&lt;OrderVO&gt; orderVOList = orderListToOrderVOList(orderList);
        //新建一个pageinfo返回 方便前端查看
        PageInfo pageInfo = new PageInfo&lt;&gt;(orderList);
        pageInfo.setList(orderVOList);
        return pageInfo;
    &#125;

    private List&lt;OrderVO&gt; orderListToOrderVOList(List&lt;Order&gt; orderList) &#123;
        List&lt;OrderVO&gt; orderVOList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; orderList.size(); i++) &#123;
            Order order =  orderList.get(i);
            OrderVO orderVO = getOrderVo(order);
            orderVOList.add(orderVO);
        &#125;
        return  orderVOList;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/OrderMapper.java
 List&lt;Order&gt; selectForCustomer(Integer userId);
===============================================
mappers/OrderMapper.xml
  &lt;select id=&quot;selectForCustomer&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;integer&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_order
    where user_id = #&#123;userId&#125;
    order by create_time desc
  &lt;/select&gt;
</code></pre>
<h3 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h3><pre><code class="java">com/imooc/mall/controller/OrderController.java
//98.写一个订单取消controller
    @PostMapping(&quot;order/cancel&quot;)
    @ApiOperation(&quot;前台取消订单&quot;)
    public ApiRestResponse cancel(@RequestParam String orderNo)&#123;
        orderService.cancel(orderNo);
        return  ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
//98.写一个订单取消实现类
    @Override
    public void cancel(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //验证用户身份
        //订单存在,需要判断所属
        Integer userId = UserFilter.currentUser.getId();
        if (!order.getUserId().equals(userId)) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_YOUR_ORDER);
        &#125;
        //没有付款才可以取消
        if (order.getOrderStatus().equals(Constant.OrderStatusEnum.NOT_PAID.getCode())) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.CANCELED.getCode());
            order.setEndTime(new Date());
            //更新状态
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
</code></pre>
<h3 id="二维码接口开发"><a href="#二维码接口开发" class="headerlink" title="二维码接口开发"></a>二维码接口开发</h3><p><a target="_blank" rel="noopener" href="https://tool.oschina.net/qr?type=2">在线生成 QR Code (oschina.net)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42456466/article/details/91869955">Springboot 上传图片到项目路径下不能访问，需要重启_springboot能上传图片到win11中但无法访问图片-CSDN博客</a></p>
<pre><code class="java">com/imooc/mall/controller/OrderController.java
//99.生成支付二维码
    @GetMapping(&quot;order/qrcode&quot;)
    @ApiOperation(&quot;前台取消订单&quot;)
    public ApiRestResponse qrcode(@RequestParam String orderNo)&#123;
        orderService.cancel(orderNo);
        return  ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 //99.生成支付二维码 pom.xml生成新的二维码依赖 util新建一个QRCodeGenerator类
       @Override
    public String qrcode(String orderNo) &#123;
        //得到请求相关的信息
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();//不能直接拿到内网的信息 要经过多层转发才可以
        //去application.properties配置一下可以访问的ip  去上面String ip
        String address = ip + &quot;:&quot; + request.getLocalPort();//拼接一下 这下生成的是整个地址
        String payUrl = &quot;http://&quot; + address + &quot;/pay?orderNo=&quot; + orderNo;
        System.out.println(address);
        System.out.println(payUrl);
        try &#123;
            QRCodeGenerator.generateQRCodeImage(payUrl, 350, 350, Constant.FILE_UPLOAD_DIR + orderNo + &quot;.png&quot;);
        &#125; catch (WriterException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
        //这个图片可以通过这个url访问到
        String pngAddress = &quot;http://&quot; + address + &quot;/images/&quot; + orderNo + &quot;.png&quot;;
        return pngAddress;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/util/QRCodeGenerator.java
package com.imooc.mall.util;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;

import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;

/**
 * 99.生成二维码工具
 */
public class QRCodeGenerator &#123;
    public static void generateQRCodeImage(String text, int width, int height, String filePath) throws WriterException, IOException &#123;
        QRCodeWriter qrCodeWriter = new QRCodeWriter();
        BitMatrix bitMatrix = qrCodeWriter.encode(text, BarcodeFormat.QR_CODE, width, height);
        Path path = FileSystems.getDefault().getPath(filePath);
        MatrixToImageWriter.writeToPath(bitMatrix,&quot;PNG&quot;,path);
    &#125;

    public static void main(String[] args) &#123;
        try &#123;
            generateQRCodeImage(&quot;PANCHUNYAO&quot;, 350,350,&quot;/Users/Pluminary/Desktop/idea_Space/mall_file_upload/QRTest.png&quot;);
        &#125; catch (WriterException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">application.properties
file.upload.dir=/Users/Pluminary/Desktop/idea_Space/mall_file_upload/
file.upload.ip=127.0.0.1
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
/**
 * 91.★★ 订单Service实现类 ★★
 */
@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    CartService cartService;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CartMapper cartMapper;
    @Autowired
    OrderMapper orderMapper;
    @Autowired
    OrderItemMapper orderItemMapper;
    @Value(&quot;$&#123;file.upload.ip&#125;&quot;)
    String ip;
............
&#125;
</code></pre>
<h3 id="后台订单列表接口"><a href="#后台订单列表接口" class="headerlink" title="后台订单列表接口"></a>后台订单列表接口</h3><pre><code class="java">com/imooc/mall/controller/OrderAdminController.java
package com.imooc.mall.controller;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.service.OrderService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 100.订单后台管理Controller
 */
@RestController
public class OrderAdminController &#123;
    @Autowired
    OrderService orderService;

    @GetMapping(&quot;admin/order/list&quot;)
    @ApiOperation(&quot;管理员订单列表&quot;)
    public ApiRestResponse listForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        PageInfo pageInfo = orderService.listForAdmin(pageNum, pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 //100.实现类
    @Override
    public PageInfo listForAdmin(Integer pageNum, Integer pageSize) &#123;//想看到所有订单
        PageHelper.startPage(pageNum, pageSize);
        List&lt;Order&gt; orderList = orderMapper.selectAllForAdmin();
        List&lt;OrderVO&gt; orderVOList = orderListToOrderVOList(orderList);
        //新建一个pageinfo返回 方便前端查看
        PageInfo pageInfo = new PageInfo&lt;&gt;(orderList);
        pageInfo.setList(orderVOList);
        return pageInfo;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/OrderMapper.java
List&lt;Order&gt; selectAllForAdmin();
===========================================
mappers/OrderMapper.xml 
&lt;select id=&quot;selectAllForAdmin&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;integer&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_order
    order by create_time desc
  &lt;/select&gt;
</code></pre>
<h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><h6 id="根据订单号生成支付二维码-→-扫码支付-→-访问支付URL-完成支付"><a href="#根据订单号生成支付二维码-→-扫码支付-→-访问支付URL-完成支付" class="headerlink" title="根据订单号生成支付二维码 → 扫码支付 → 访问支付URL, 完成支付"></a>根据订单号生成支付二维码 → 扫码支付 → 访问支付URL, 完成支付</h6><pre><code class="java">com/imooc/mall/controller/OrderController.java
 //101.支付接口
    @GetMapping(&quot;pay&quot;)
    @ApiOperation(&quot;支付接口&quot;)
    public ApiRestResponse pay(@RequestParam String orderNo)&#123;
        orderService.pay(orderNo);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
//101.支付
    @Override
    public void pay(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //支付前的判断 未付款才可以付款
        if (order.getOrderStatus() == Constant.OrderStatusEnum.NOT_PAID.getCode()) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.PAID.getCode());
            order.setPayTime(new Date());
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
</code></pre>
<h3 id="完结订单"><a href="#完结订单" class="headerlink" title="完结订单"></a>完结订单</h3><pre><code class="java">com/imooc/mall/controller/OrderAdminController.java
package com.imooc.mall.controller;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.service.OrderService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 100.订单后台管理Controller
 */
@RestController
public class OrderAdminController &#123;
    @Autowired
    OrderService orderService;

    @GetMapping(&quot;admin/order/list&quot;)
    @ApiOperation(&quot;管理员订单列表&quot;)
    public ApiRestResponse listForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        PageInfo pageInfo = orderService.listForAdmin(pageNum, pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;

    /**
     * 102.发货。订单状态流程：0用户已取消，10未付款，20已付款，30已发货，40交易完成
     */
    @GetMapping(&quot;admin/order/delivered&quot;)
    @ApiOperation(&quot;管理员发货&quot;)
    public ApiRestResponse delivered(@RequestParam String orderNo)&#123;
        orderService.deliver(orderNo);
        return ApiRestResponse.success();
    &#125;

    /**
     * 103.完结订单。订单状态流程：0用户已取消，10未付款，20已付款，30已发货，40交易完成
     * 管理员和用户都可以调用
     */
    @GetMapping(&quot;order/finish&quot;)
    @ApiOperation(&quot;完结订单&quot;)
    public ApiRestResponse finish(@RequestParam String orderNo)&#123;
        orderService.finish(orderNo);
        return ApiRestResponse.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 //102.管理订单实现类开发 发货
    @Override
    public void deliver(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //支付前的判断 判断已付款的
        if (order.getOrderStatus() == Constant.OrderStatusEnum.PAID.getCode()) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.DELIVERED.getCode());
            order.setDeliveryTime(new Date());
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
    //103.完结订单
    @Override
    public void finish(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //有可能管理员调用 有可能用户调用 如果是普通用户, 要去校验一下订单所属
        if (!userService.checkAdminRole(UserFilter.currentUser) &amp;&amp; !order.getUserId().equals(UserFilter.currentUser.getId())) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_YOUR_ORDER);
        &#125;
        //支付前的判断 判断已付款的 //发货后可以完结订单
        if (order.getOrderStatus() == Constant.OrderStatusEnum.DELIVERED.getCode()) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.FINISHED.getCode());
            order.setEndTime(new Date());
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
</code></pre>
<h3 id="全流程测试"><a href="#全流程测试" class="headerlink" title="全流程测试"></a>全流程测试</h3><ul>
<li>Postman实操</li>
<li>登录 → 浏览商品 → 加入购物车 → 下单 <ul>
<li>​                                                            → 取消订单</li>
<li>​                                                            → 扫码支付 → 发货 → 收获 → 订单完结</li>
</ul>
</li>
</ul>
<h5 id="总结订单模块"><a href="#总结订单模块" class="headerlink" title="总结订单模块"></a>总结订单模块</h5><ul>
<li><p>重难点</p>
<ul>
<li>VO的封装、裁剪</li>
<li>一个订单内包括多个商品</li>
<li>订单状态流转</li>
<li>二维码生成</li>
</ul>
</li>
<li><p>常见错误：把POJO返回到前端</p>
</li>
</ul>
<h1 id="上线前准备工作"><a href="#上线前准备工作" class="headerlink" title="上线前准备工作"></a>上线前准备工作</h1><h3 id="阿里云部署"><a href="#阿里云部署" class="headerlink" title="阿里云部署"></a>阿里云部署</h3><p>把每个 com&#x2F;imooc&#x2F;mall&#x2F;model&#x2F;request&#x2F;… 类都加上**toString()**方法 方便调试<br><strong>后台、前台、获取类的行为</strong> 的目录列表都是 <strong>Get</strong>Mapping</p>
<h3 id="前端准备工作"><a href="#前端准备工作" class="headerlink" title="前端准备工作"></a>前端准备工作</h3><h6 id="把static里的前端文件导入项目中"><a href="#把static里的前端文件导入项目中" class="headerlink" title="把static里的前端文件导入项目中"></a>把static里的前端文件导入项目中</h6><pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
//104.ImoocMallWebMvcConfig.java 根据路由配置相关文件 以admin开头的文件会被路由到下面的Locations
package com.imooc.mall.config;

import com.imooc.mall.common.Constant;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
 * 44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;
    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
        //104.根据路由配置相关文件 以admin开头的文件会被路由到下面的Locations
        registry.addResourceHandler(&quot;/admin/**&quot;).addResourceLocations(&quot;classpath:/static/admin&quot;);
        //65.增加一个registry  66.新增接口继续开发 ProductAdminController
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + Constant.FILE_UPLOAD_DIR);
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="部署云服务器"><a href="#部署云服务器" class="headerlink" title="部署云服务器"></a>部署云服务器</h3><ul>
<li>阿里云简介</li>
<li>选择云服务器并购买</li>
<li>环境配置</li>
<li>Spring Boot部署[包括maven打包 sql文件也要上传]</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/region/cn-hangzhou">云服务器管理控制台 (aliyun.com)</a></p>
<blockquote>
<p>免费试用三个月<br>账号: root<br>密码: panchunyao123!</p>
</blockquote>
<pre><code class="java">复制服务器的公网ip：47.98.225.105
cmd本地电脑 → ssh root@47.98.225.105
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_57581439/article/details/124928451">在阿里云购买Linux服务器，配置宝塔环境，全图文，最最详细图解，保姆级教学_阿里云服务器怎么直接买宝塔-CSDN博客</a></p>
<blockquote>
<h2 id="【宝塔安装jdk1-8-yum安装-】"><a href="#【宝塔安装jdk1-8-yum安装-】" class="headerlink" title="【宝塔安装jdk1.8(yum安装)】"></a><strong>【宝塔安装jdk1.8(yum安装)】</strong></h2><p>1、检索检索1.8的列表</p>
<pre><code class="none">yum list java-1.8*
</code></pre>
<p>2、安装1.8.0的所有文件</p>
<pre><code class="none">yum install java-1.8.0-openjdk* -y
</code></pre>
<p>3、使用命令检查是否安装成功</p>
<pre><code class="none">java -version
</code></pre>
</blockquote>
<p>登录宝塔 → 绑定宝塔 → 下载软件<br>宝塔服务器[<a target="_blank" rel="noopener" href="http://47.98.225.105:22003/]">http://47.98.225.105:22003/]</a></p>
<pre><code class="sql">☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ 宝塔BaoTa ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
========================面板账户登录信息=========================
 外网面板地址: http://47.98.225.105:22003/1259ebfa
 内网面板地址: http://172.24.91.49:22003/1259ebfa
 username: grltvl7d
 password: 46303f93


======================== mysql-5.7 ===========================
root密码成功修改为: Panchunyao123![mysql-8.0]

[root@iZbp1dssknxftmjczbtpndZ ~]# mysql -uroot -pPanchunyao123!
mysql&gt; create database imooc_mall;
mysql&gt; use imooc_mall;
Database changed
导入sql文件:imooc_mall_online.sql
从本机将其上传到服务器在cmd中运行:
scp /Users/Pluminary/Desktop/imooc_mall_online.sql root@47.98.225.105:22003:/root
输入服务器密码:panchunyao123!

回到服务器端输入：
mysql&gt; use imooc_mall
Database changed
mysql&gt; source /root/imooc_mall_online.sql
mysql&gt; show tables;
+-----------------------+
| Tables_in_imooc_mall  |
+-----------------------+
| imooc_mall_cart       |
| imooc_mall_category   |
| imooc_mall_order      |
| imooc_mall_order_item |
| imooc_mall_product    |
| imooc_mall_user       |
+-----------------------+
#为数据库赋予权限！！！
mysql&gt; grant all privileges on imooc_mall.* to &#39;root&#39;@&#39;127.0.0.1&#39; identified by &#39;Panchunyao123!&#39;;
--------------------------------------------------------------
MySql8.0
CREATE USER &#39;root&#39;@&#39;47.98.225.105&#39; IDENTIFIED BY &#39;Panchunyao123!&#39;;
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;47.98.225.105&#39; WITH GRANT OPTION;
--------------------------------------------------------------
mysql&gt; quit
Bye
[root@iZbp1dssknxftmjczbtpndZ ~]# mysql -uroot -pPanchunyao123! -h127.0.0.1
去云服务器 安全组 访问规则 入方向 手动添加一个 目的:8081/8081 源:0.0.0.0/0
==============================================================
</code></pre>
<p>整理文件上传到服务器 先**Build → Rebuild Project **<br>打包 <strong>Maven → Lifecycle → clean[之前的内容删除 不容易出错] → package[打包操作]</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_62488212/article/details/132412209">spring打包报错：Java Runtime (class file version 55.0), class file versions up to 52.0_there was an error in the forked process org&#x2F;testn-CSDN博客</a></p>
<pre><code class="sql">[INFO] Building jar: C:\Users\Pluminary\Desktop\idea_Space\mall\target\mall-0.0.1-SNAPSHOT.jar
在本机cmd中运行把导好的包发送給服务器
C:\Users\Pluminary&gt;scp C:\Users\Pluminary\Desktop\idea_Space\mall\target\mall-0.0.1-SNAPSHOT.jar root@c:/root
#rm -rf images/ 删除images文件夹
新建一个文件夹
[root@iZbp1dssknxftmjczbtpndZ ~]# pwd
[root@iZbp1dssknxftmjczbtpndZ ~]# mkdir image

图片上传到服务器中[图片尽量在没有根目录空格的文件夹下 比如Spring Boot 中间有空格]
C:\Users\Pluminary&gt;scp C:/Users/Pluminary/Desktop/images/. root@47.98.225.105:/root/images/

在Xshell7中阿里云服务器
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
images  imooc_mall_online.sql  install.sh  mall-0.0.1-SNAPSHOT.jar

每一次部署之前要把当前的java停止掉
[root@iZbp1dssknxftmjczbtpndZ images]# lsof -i:8081
[root@iZbp1dssknxftmjczbtpndZ images]# kill -9 12345 //按照PID杀死端口号
-bash: kill: (12345) - No such process

部署到云服务器 [/root/null 2&gt;&amp;1 &amp;]将日志输出到哪里 这里是丢弃的意思
[root@iZbp1dssknxftmjczbtpndZ ~]# nohup java -jar -Dserver.port=8081 -Dspring.profiles.active=prod /root/mall-0.0.1-SNAPSHOT.jar &gt; /root/null 2&gt;&amp;1 &amp;
[1] 18656
如果没有别名就一个本来的application.properties
[root@iZbp1dssknxftmjczbtpndZ ~]# nohup java -jar -Dserver.port=8081 /root/mall-0.0.1-SNAPSHOT.jar &gt; /root/null 2&gt;&amp;1 &amp;


 #代表当前程序的进程号
[root@iZbp1dssknxftmjczbtpndZ ~]# lsof -i:8081   //查询端口号
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
java    18656 root   19u  IPv6 195648      0t0  TCP *:tproxy (LISTEN)

============================================================================

若打不开请检查网页报错 寻找传入的application.prod.properties的 
spring.datasource.url地址和spring.datasource.username &amp;&amp; password数据库用户和密码

查看服务器的端口: mysql&gt; show global variables like &#39;port&#39;;

阿里云控制台:
https://ecs.console.aliyun.com/server/i-bp1dssknxftmjczbtpnd/detail?regionId=cn-hangzhou

如何查看linux服务器安装了tomcat：
rpm -qa|grep tomcat

宝塔安装目录: $cd /www/server/.....
[root@iZbp1dssknxftmjczbtpndZ data]# cd /www/server/tomcat/bin
#找到文件后启动tomcat
[root@iZbp1dssknxftmjczbtpndZ bin]# ./startup.sh
#看进程，如果返回一大串东西，说明tomcat启动成功。
[root@iZbp1dssknxftmjczbtpndZ ~]# ps -ef|grep tomcat

运行SpringBoot: 
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
Desktop  images  imooc_mall_online.sql  install.sh  logs  mall-0.0.1-SNAPSHOT.jar  null
[root@iZbp1dssknxftmjczbtpndZ ~]# java -jar mall-0.0.1-SNAPSHOT.jar 

===============================================
当把SpringBoot项目的jar包部署到linux服务器中，启动SpringBoot项目，却无法正常访问，这是怎么回事呢？
主要的原因是端口号被Linux的firewall防火墙拦截掉了
解决办法：
1、查询已开启的端口列表：firewall-cmd --list-ports 
不出意外的话，是啥也没有，这也表示，所有端口都未放行，当然springboot项目的80端口也被拦截掉了
2、firewall-cmd --zone=public --add-port=1-12345/tcp --permanent
将端口1~12345全都开启
3、重启防火墙
service firewalld restart
4、重新运行springboot项目
5、成功访问
===============================================
</code></pre>
<blockquote>
<p>server.port&#x3D;8083<br>spring.datasource.name&#x3D;imooc_mall_datasource<br>spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;47.98.225.105&#x2F;imooc_mall?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;autoReconnect&#x3D;true&amp;useSSL&#x3D;true&amp;allowPublicKeyRetrieval&#x3D;true&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai<br>spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver<br>spring.datasource.username&#x3D;root<br>spring.datasource.password&#x3D;Panchunyao123!<br>mybatis.mapper-locations&#x3D;classpath:mappers&#x2F;*.xml<br>spring.redis.host&#x3D;localhost<br>spring.redis.port&#x3D;6379<br>spring.redis.password&#x3D;<br>file.upload.dir&#x3D;&#x2F;root&#x2F;images&#x2F;<br>file.upload.ip&#x3D;47.98.225.105<br>icode&#x3D;ABCDE</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46070108/article/details/116495116">SpringBoot上传图片，图片不能及时显示问题_springboot项目上传照片到uoload 不会实时更新-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42456466/article/details/91869955">Springboot 上传图片到项目路径下不能访问，需要重启_springboot能上传图片到win11中但无法访问图片-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/124680688">关于springboot项目图片上传到本地，必须重启之后才能访问的解决方案_springboot上传图片需要重启-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/rqz__/article/details/130304492">关于IDEA2022开启热部署没有compiler.automake.allow.when.app.running的解决方案-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37954460/article/details/125842857">Linux部署SpringBoot项目无法访问问题_linux springboot项目启动外面不能访问-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/terry711/article/details/106226298/">linux服务器部署SpringBoot项目并查看项目运行日志_linux 怎么实时查看springboot 日志-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://class.imooc.com/course/qadetail/269346">线上发布报数据库没有连接成功，麻烦帮忙看…-慕课网 (imooc.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63693805/article/details/132626318">linux安装mysql 8 数据库（保姆级）_linux安装mysql8-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52885524/article/details/127076560">慕慕生鲜详细步骤全部打通(从无到上线)-CSDN博客</a></p>
<p>mysql8.0密码&#x3D;&gt; root &amp; Panchunyao123!</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/02/28/后端/SpringBoot入门及电商项目[SpringBoot_MyBatis.generator_Swagger2_Redis_Postman_RESTful_AOP_UUID_QRCode_Linux_Aliyun]/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/01/18/后端/SSM开发社交网站[Freemarker+Spring+SpringMVC+Mybatis(Plus)构成SSM+Bootstrap+Art-Template+Kaptcha+SpringTask+wangEditor]/">
        <h2>
            SSM开发社交网站[Freemarker+Spring+SpringMVC+Mybatis(Plus)构成SSM+Bootstrap+Art-Template+Kaptcha+SpringTask+wangEditor]
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/18
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="慕课书评网学习内容"><a href="#慕课书评网学习内容" class="headerlink" title="慕课书评网学习内容"></a><span style ="color:red">慕课书评网学习内容</span></h1><p><span style ="color:blue"><strong>SSM</strong> &#x3D;&gt; <span style ="color:red"><strong>S</strong></span>pring &#x2F; <span style ="color:red"><strong>S</strong></span>pring MVC &#x2F; <span style ="color:red"><strong>M</strong></span>yBatis</span></p>
<ul>
<li>讲解Spring&#x2F;Spring MVC&#x2F;MyBatis(SSM)整合配置过程</li>
<li>讲解<span style ="color:red"><strong>MyBatis-Plus</strong></span>敏捷开发插件的用法</li>
<li>开发Java Web应用”慕课书评网”</li>
</ul>
<h3 id="主要知识点"><a href="#主要知识点" class="headerlink" title="主要知识点"></a>主要知识点</h3><ul>
<li>SSM整合配置</li>
<li>MyBatis-Plus配置与应用</li>
<li>Kaptcha验证码组件使用</li>
<li>富文本编辑器wangEditor</li>
<li>Spring Task任务调度</li>
<li>基于阿里云实现短信验证</li>
<li>基于腾讯云的滑块验证码实现前置的人机登录检查</li>
</ul>
<h4 id="工程结构与开发规约-复习知识点"><a href="#工程结构与开发规约-复习知识点" class="headerlink" title="工程结构与开发规约 [复习知识点]"></a>工程结构与开发规约 [<span style = "color:red">复习知识点</span>]</h4><h5 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h5><pre><code class="java">mgallery - eclipse工程项目
 /src - java源代码目录
 /WebContent - Web资源目录
 /css - css文件目录
 /js - js文件目录
 /image - 图片资源目录
 /upload - 上传文件目录
 /WEB-INF   //jsp数据来自controller 不允许在web中直接访问 要从控制器跳转
   /jsp - jsp页面目录
   /lib - jar文件目录
   /classes - 编译后的class目录
   /web.xml web描述符文件
</code></pre>
<h5 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h5><pre><code class="java">com.imooc.mgallery //逆命名法
    /controller - 存放Servlet控制器类 //承上启下接收参数 调用逻辑 返回处理结果
    /service - 存放处理逻辑类model[伪数据库] //完成业务逻辑 service与dao进行传递调用
    /dao - Data Access Object 数据访问对象类 数据读写的java类 数据来自xml文件
    /entity - 存放实体类 JavaBean java中的简单对象
    /utils - 通用工具类 底层通用的工具类或方法
</code></pre>
<h3 id="什么是整合"><a href="#什么是整合" class="headerlink" title="什么是整合"></a>什么是整合</h3><ul>
<li>通过Spring IoC容器管理第三方框架对象, 让多框架形成整体</li>
<li><span style ="color:blue"><strong>SSM</strong> &#x3D;&gt; <span style ="color:red"><strong>S</strong></span>pring &#x2F; <span style ="color:red"><strong>S</strong></span>pring MVC &#x2F; <span style ="color:red"><strong>M</strong></span>yBatis</span>是业内最主流的框架搭配<ul>
<li>Spring MVC提供了控制器 基于Spring的Web交互的能力</li>
<li>Spring是对应用程序的对象进行创建和管理</li>
<li>MyBatis是完成了与底层数据库实现增删改查的操作</li>
</ul>
</li>
<li>SSM配置与使用是所有Java工程师必须掌握的技能</li>
</ul>
<h3 id="SSM整合三阶段"><a href="#SSM整合三阶段" class="headerlink" title="SSM整合三阶段"></a>SSM整合三阶段</h3><ul>
<li><span style ="color:red"><strong>Spring与Spring MVC环境配置</strong></span></li>
<li><span style ="color:red"><strong>Spring与MyBatis的整合配置</strong></span></li>
<li><span style ="color:red"><strong>整合其他组件: 声明式事务&#x2F;日志&#x2F;任务调度&#x2F;…</strong></span></li>
</ul>
<h3 id="Spring与Spring-MVC环境配置"><a href="#Spring与Spring-MVC环境配置" class="headerlink" title=" Spring与Spring MVC环境配置"></a><span style ="color:purple"> <strong>Spring与Spring MVC环境配置</strong></span></h3><ul>
<li>依赖Spring-WebMVC</li>
<li>配置DispatcherServlet</li>
<li>启用Spring MVC注解模式</li>
<li>配置请求与相应字符集</li>
<li>配置FreeMarker模板引擎</li>
<li>配置JSON序列化组件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/958385c851d8c4239be83aec9c90132408b1f53b/data/reader%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.png"></p>
<p>编写pom.xml  引入导入的依赖jar包<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fittec/article/details/118942425?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-118942425-blog-120412354.235%5Ev40%5Epc_relevant_anti_vip&spm=1001.2101.3001.4242.2&utm_relevant_index=4">IntelliJ IDEA 2021 自动下载pom文件中的依赖_pom中的自定义插件下载-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67401055/article/details/123938800?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123938800-blog-108093107.235%5Ev40%5Epc_relevant_anti_vip&spm=1001.2101.3001.4242.1&utm_relevant_index=3">idea编译Java项目的部分java文件并且生成class文件_idea将java文件编译成class-CSDN博客</a></p>
<blockquote>
<p>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★<br>设置resource和source<br>方法：点击文件右键-&gt;<strong>make direction as</strong></p>
<p>需要运行和引用的java文件设置为source文件，将配置文件(xml)等设置为resource文件<br>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-reader&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
&lt;!--1.Maven依赖Spring-webmvc 第二步web.xml--&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--    Freemarker --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.30&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--   Jackson依赖包  --&gt;
        &lt;dependency&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">WEB-INF/web.xml    init-param变量 这个是放在servlet里面的，只有此servlet可以访问
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
&lt;!--    2.配置DispatcherServlet 第三步applicationContext.xml--&gt;
 &lt;!--    DispatcherServlet是Spring MVC是最核心的对象
         DispatcherServlet用于拦截http请求        --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;!--自动加载applicationContext--&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
&lt;!--        启动时初始化 servlet--&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt; &lt;!--与上面保持一致--&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;!-- 4.解决中文乱码问题  只会对Post请求生效 Get只需要修改tomcat的server.xml(8.0以上是自动的) 72行增加URIEncoding=&quot;UTF-8&quot; 第五步application--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt; &lt;!--初始化参数--&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;
       xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/task
            http://www.springframework.org/schema/task/spring-task.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
&lt;!-- 3.Spring框架启用SpringMVC注解模式 第四步web.xml--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
&lt;!-- 真正开启SpringMVC注解 --&gt;
&lt;!-- https://blog.csdn.net/u011066470/article/details/112438252 --&gt;
&lt;!-- &lt;mvc:annotation-driven&gt; Spring MVC用来提供Controller请求转发，json自动转换等功能。，默认会帮我们注册默认处理请求，参数和返回值的类 --&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
&lt;!-- 解决相应里的中文输出 --&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                        &lt;!-- 6.JSON(Jackson)序列化输出配置   --&gt;
                        &lt;value&gt;application/json;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
&lt;!-- 诸如css/图片/js静态资源排除在外 使得SpringMVC对url处理效率加大   --&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;!-- 5.配置Freemarker模板引擎 脚本存放地址 Bean定义可以具有零个或多个属性。属性元素对应于bean类公开的JavaBean setter方法。 Spring支持原语，对相同或相关工厂中的其他bean的引用，列表，映射和属性。 --&gt;
    &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;
&lt;!--        对于本身的参数配置  --&gt;
        &lt;property name=&quot;freemarkerSettings&quot;&gt;
            &lt;props&gt;
&lt;!--        默认的编码类型 UTF-8 freemarker读取指定ftl文件时采用此字符集--&gt;
                &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;!--    使用何种模板引擎 创建的后缀名 --&gt;
    &lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="html">WEB-INF/ftl/test.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
测试页面！！
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/imooc/controller/TestController.java
package com.imooc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import java.util.HashMap;
import java.util.Map;

@Controller
public class TestController &#123;
    @GetMapping(&quot;/test/t1&quot;)
    public ModelAndView test1()&#123;
        return new ModelAndView(&quot;/test&quot;);
    &#125;
    @GetMapping(&quot;test/t2&quot;)
    @ResponseBody
    public Map test2()&#123;
        Map result = new HashMap();
        result.put(&quot;test&quot;,&quot;测试文本&quot;);
        return result;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a2272062968/article/details/120404192">IDEA Web项目out&#x2F;classes目录没有编译的class类文件 - IDEA环境下创建Maven WebApp_out中没有class文件夹-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/31486d18fb2b0875fc03efc01fd1d1b5939a6c84/data/idea%E4%B8%ADout%E7%9A%84WEB-INF%E7%83%AD%E9%83%A8%E7%BD%B2%E7%A9%B6%E6%9E%81%E6%96%B9%E6%B3%95.jpg"></p>
<h3 id="Spring与MyBatis整合配置"><a href="#Spring与MyBatis整合配置" class="headerlink" title=" Spring与MyBatis整合配置"></a><span style ="color:purple"> <strong>Spring与MyBatis整合配置</strong></span></h3><p>MyBatisUtils封装初始化代码 如果自己new了对象就不会享受spring的福利待遇</p>
<ul>
<li>依赖mybatis-spring及驱动</li>
<li>配置数据源与连接池</li>
<li>配置SqlSessionFactory</li>
<li>配置Mapper扫描器</li>
<li>创建mybatis-config.xml</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;!-- 5.配置Freemarker模板引擎 脚本存放地址 第六步见pom.xml mybatis依赖 --&gt;
    &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;
&lt;!--        对于本身的参数配置  --&gt;
        &lt;property name=&quot;freemarkerSettings&quot;&gt;
            &lt;props&gt;
&lt;!--        默认的编码类型 UTF-8 freemarker读取指定ftl文件时采用此字符集--&gt;
                &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;!--    使用何种模板引擎 创建的后缀名   --&gt;
    &lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    7. MyBatis与Spring的整合配置   --&gt;
      &lt;!--②.配置数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/imooc_reader?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;initialSize&quot; value=&quot;5&quot;/&gt;
        &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt;
    &lt;/bean&gt;
&lt;!--8. SqlSessionFactoryBean用于根据配置信息创建SqlSessionFactory,不再需要我们自己编码创建--&gt;
    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;!--    存储sql语句的mapper.xml文件 存储在哪个目录中 去创建mapper接口--&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;/&gt;
&lt;!-- 10.  MyBatis配置文件地址 去创建一个xml  --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
&lt;!--  9. 配置Mapper扫描器 下一步9TestMapper --&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
&lt;!--  这样初始化mybatis时 会对所有mapper接口进行扫描 --&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.imooc.reader.mapper&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;!--  6. Mybatis整合步骤：①引入依赖 第七步看applicationContext.xml--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.4&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--        MyBatis与Spring整合组件 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.14&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/TestMapper.java
package com.imooc.reader.mapper;
//接口作用Mybatis通过接口自动生成实现类
public interface TestMapper &#123;
// 系统中接口很多不是所有的都对应mapper 9.application.xml
    public void insert();
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
&lt;!--        驼峰命名转换 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="整合其他组件"><a href="#整合其他组件" class="headerlink" title="整合其他组件"></a><span style ="color:purple"><strong>整合其他组件</strong></span></h3><ul>
<li>配置logback日志输出</li>
<li>声明式事务配置</li>
<li>整合JUnit单元测试</li>
</ul>
<pre><code class="xml">pom.xml
&lt;!--   11. 单元测试依赖 mappers加入test.xml mapper扫描接口后生成对应实现类 12test.xml--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
&lt;!--  15导入依赖 scope打包时不会放进去 tomcat自带 但是测试时不用tomcat所以要加--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
&lt;!--   16加入日志依赖 logback日志组件 17创建logback.xml--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="xml">mappers/test.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.TestMapper&quot;&gt;
&lt;!--   12. 与接口对应的完整类路径  ↓用于对应数据新增 对应TestMapper.java接口  13TestService --&gt;
    &lt;insert id=&quot;insert&quot;&gt;
        insert into test(content) values(&#39;测试内容&#39;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/TestService.java
package com.imooc.reader.service;

import com.imooc.reader.mapper.TestMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

@Service
public class TestService &#123;
// 13.运行时注入生成的对象 自动生成Test 选中上面的类 Code generate 14TestServiceTest.java
    @Resource
    private TestMapper testMapper;
//      @Transactional 要么全部完成 要么什么也不做
    @Transactional
    public void batchImport()&#123;
        for (int i = 0; i &lt; 5; i++) &#123;
//            if (i==3) &#123;
//                throw new RuntimeException(&quot;预期外异常&quot;);
//            &#125;
            testMapper.insert();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/TestServiceTest.java
package com.imooc.reader.service;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

import static org.junit.Assert.*;

//14. 运行时自动初始IoC容器 + 说明配置文件在什么地方完成初始化 15依赖javaservlet pom.xml
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class TestServiceTest &#123;
    @Resource
    private TestService testService;

    @Test
    public void batchImport() &#123;
        testService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">logback.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;
&lt;!--           17.       小时分钟秒   日志级别  线程名   说明何类何方法  对应日志消息+换行--&gt;
&lt;!--            18转至声明式事务 applicationContext上面的文件头加些配置信息 再去下面写--&gt;
            &lt;pattern&gt;%d&#123;HH:mm:ss&#125; %-5level [%thread] %logger&#123;30&#125; - %msg%n&lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
&lt;!--    输出级别   --&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--    18.声明式事务配置 控制事务的打开 提交 回滚 ↓--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    与之对应的注解模式！ 再去TestService.java添加  @Transactional --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<pre><code class="java">@RunWith作用
@RunWith 就是一个运行器
@RunWith(JUnit4.class) 就是指用JUnit4来运行
@RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境
@RunWith(Suite.class) 的话就是一套测试集合，
@ContextConfiguration Spring整合JUnit4测试时，使用注解引入多个配置文件
单个文件
@ContextConfiguration(Locations=“classpath：applicationContext.xml”)
@ContextConfiguration(classes = SimpleConfiguration.class)

多个文件时，可用&#123;&#125;
@ContextConfiguration(locations = &#123; “classpath:spring1.xml”, “classpath:spring2.xml” &#125;)
</code></pre>
<h3 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h3><p><a target="_blank" rel="noopener" href="https://baomidou.com/">MyBatis-Plus (baomidou.com)</a></p>
<ul>
<li>MyBatis-Plus(简称MP)是一个MyBatis的增强工具</li>
<li>自动实现Mapper CRUD操作, 极致提高数据库开发效率</li>
<li>MP在MyBatis的基础上只做增强不做改变</li>
</ul>
<h3 id="MyBatis-Plus整合三部曲"><a href="#MyBatis-Plus整合三部曲" class="headerlink" title="MyBatis-Plus整合三部曲"></a>MyBatis-Plus整合三部曲</h3><ul>
<li>pom引入mybatis-plus依赖</li>
<li>Spring XML更改配置SqlSessionFactory实现类</li>
<li>mybatis-config.xml增加MP分页插件</li>
</ul>
<h3 id="MyBatis-Plus开发三部曲"><a href="#MyBatis-Plus开发三部曲" class="headerlink" title="MyBatis-Plus开发三部曲"></a>MyBatis-Plus开发三部曲</h3><ul>
<li><p>创建实体类, <code>@TableName/ @Tableld/ @TableField</code>实现映射</p>
</li>
<li><p>创建Mapper接口继承BaseMapper, 创建Mapper XML</p>
</li>
<li><p>开发时注入Mapper对象, 通过内置API实现CRUD操作</p>
</li>
</ul>
<h3 id="MyBatis-Plus核心注解"><a href="#MyBatis-Plus核心注解" class="headerlink" title="MyBatis-Plus核心注解"></a>MyBatis-Plus核心注解</h3><ul>
<li><code>@TableName</code> - 将实体类与表名映射</li>
<li><code>@Tableld</code> - 说明对应属性是表的主键</li>
<li><code>@TableField</code> - 设置属性与列名的对应关系</li>
</ul>
<h3 id="BaseMapper接口核心API"><a href="#BaseMapper接口核心API" class="headerlink" title="BaseMapper接口核心API"></a>BaseMapper接口核心API</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>insert</strong>(entity)</td>
<td>数据新增,自动生成insert sql, 根据@Tableld决定注解生成方式</td>
</tr>
<tr>
<td><strong>updateById</strong>(entity)</td>
<td>根据主键更新对应对象, 自动生成update sql</td>
</tr>
<tr>
<td><strong>deleteById</strong>(id)</td>
<td>根据主键删除数据, 自动更新delete sql</td>
</tr>
<tr>
<td><strong>selectById</strong>(id)</td>
<td>按主键查询对应的实体对象</td>
</tr>
<tr>
<td>selectList(queryWrapper)</td>
<td>根据查询生成器(QueryWrapper)的条件自动生成sql查询返回List集合</td>
</tr>
<tr>
<td>selectPage(page,queryWrapper)</td>
<td>分页查询方法, 自动生成分页limit子句, 返回IPage分页对象</td>
</tr>
</tbody></table>
<pre><code class="xml">pom.xml
&lt;!--   19 整合Mybatis-plus依赖  修改application中65行   --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;
            &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml  【替换之前的sessionFactory】
&lt;!--  19. 原生Mybatis与Spring整合  自动实现接口的增删改查  20增加plus底层的分页查询插件 mybatis-config.xml--&gt;
&lt;!--    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;--&gt;
    &lt;bean id=&quot;sessionFactory&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;!--    存储sql语句的mapper.xml文件 存储在哪个目录中 去创建mapper接口--&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;/&gt;
&lt;!-- 10.  MyBatis配置文件地址 去创建一个xml  第十一步pom加单元测试依赖--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
&lt;!--  9. 配置Mapper扫描器  --&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
&lt;!--  这样初始化mybatis时 会对所有mapper接口进行扫描 --&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.imooc.reader.mapper&quot;/&gt;
&lt;/bean&gt;
&lt;!--    18.声明式事务配置 控制事务的打开 提交 回滚 ↓--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    与之对应的注解模式！ 再去TestService.java添加  @Transactional --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
&lt;!--        驼峰命名转换 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;plugins&gt;
&lt;!--  20.配置Mybatis-Plus分页查询     21创entity/Test.java--&gt;
        &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt;&lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/entity/Test.java
// 21 Mybatis-plus运用   22mapper中TestMapper
@TableName(&quot;test&quot;) //说明实体对应哪一张表
public class Test &#123;
    @TableId(type = IdType.AUTO) //数据自增
    @TableField(&quot;id&quot;) //说明属性对应哪个字段
    private Integer id;
    //如果字段名与属性名相同或者符合驼峰命名转换规则 则TableField可以省略
    @TableField(&quot;content&quot;)
    private String content;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/TestMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Test;
//22.为了和BaseMapper里的insert()区别开 这个改名成insertSample
//接口作用Mybatis通过接口自动生成实现类 23.MyBatisPlusTest.java
public interface TestMapper extends BaseMapper&lt;Test&gt; &#123;
// 系统中接口很多不是所有的都对应mapper 9.application.xml
    public void insertSample();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/MyBatisPlusTest.java
package com.imooc.reader;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Test;
import org.junit.runner.RunWith;
import com.imooc.reader.mapper.TestMapper;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.List;

//23.利用插件调用增删改查  24以Bootstrap开发前端index.ftl
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class MyBatisPlusTest &#123;
    @Resource
    private TestMapper testMapper;

    //增
    @org.junit.Test //直接进行调用 与注解重名 故此加包名
    public void testInsert() &#123;
        Test test = new Test();
        test.setContent(&quot;MyBatis Plus测试&quot;);
        //在接口中 com/imooc/reader/mapper/TestMapper.java
        testMapper.insert(test);
    &#125;

    //改
    @org.junit.Test
    public void testUpdate() &#123;
        Test test = testMapper.selectById(30);//按id号查询
        test.setContent(&quot;MyBatis Plus测试1&quot;);
        testMapper.updateById(test);
    &#125;

    //删
    @org.junit.Test
    public void testDelete() &#123;
        testMapper.deleteById(30);
    &#125;

    //查
    @org.junit.Test
    public void testSelect() &#123;
        //传入特殊包装对象
        QueryWrapper&lt;Test&gt; queryWrapper = new QueryWrapper&lt;Test&gt;();
//        queryWrapper.eq(&quot;id&quot;, 31); //eq是等值比较 若写多行语句则sql语言用and连接
        queryWrapper.gt(&quot;id&quot;, 5);//选择范围 查询大于5的数据
        List&lt;Test&gt; list = testMapper.selectList(queryWrapper);//返回获取7号数据的集合
        System.out.println(list.get(0));
    &#125;
&#125;
</code></pre>
<img src="https://raw.githubusercontent.com/P-luminary/images/06dcc63a2b2136dc8423f58abfc719549d2fe9ab/data/for%E7%9A%84%E4%BC%98%E5%8C%96%E6%B5%81.jpg" style="zoom: 80%;" />

<h3 id="基于SSM开发慕课书评网"><a href="#基于SSM开发慕课书评网" class="headerlink" title="基于SSM开发慕课书评网"></a>基于SSM开发慕课书评网</h3><p>导入训练素材的<code>imooc-reader.sql</code></p>
<h5 id="Bootstrap入门介绍-优秀的前端UI框架"><a href="#Bootstrap入门介绍-优秀的前端UI框架" class="headerlink" title="Bootstrap入门介绍 [优秀的前端UI框架]"></a>Bootstrap入门介绍 [优秀的前端UI框架]</h5><ul>
<li>Bootstrap是全球最受欢迎的前端组件库, 由推特(TWitter)开源</li>
<li>Bootstrap用于开发<strong>响应式布局</strong>、移动设备优先的WEB项目</li>
<li>Bootstrap提供完整的HTML、CSS和JS开发工具集</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bootcss.com/">Bootstrap中文网 (bootcss.com)</a></p>
<h3 id="显示图书类别-全部-前端-后端-测试-产品"><a href="#显示图书类别-全部-前端-后端-测试-产品" class="headerlink" title="显示图书类别 [全部 | 前端 | 后端 | 测试 | 产品]"></a>显示图书类别 [<strong>全部</strong> | 前端 | 后端 | 测试 | 产品]</h3><pre><code class="html">index.ftl [只写入顺序关键信息 在这里插入素材中的index.html并更名]
&lt;#--在这块进行动态数据编写 24.创建entity/Category分类实体--&gt;
        &lt;div class=&quot;col-8 mt-2&quot;&gt;
            &lt;span data-category=&quot;-1&quot; style=&quot;cursor: pointer&quot; class=&quot;highlight  font-weight-bold category&quot;&gt;全部&lt;/span&gt;
            |
&lt;#--     31.对页面进行动态的数据导入       --&gt;
            &lt;#list categoryList as category&gt;
                &lt;a style=&quot;cursor: pointer&quot; data-category=&quot;$&#123;category.categoryId&#125;&quot; class=&quot;text-black-50 font-weight-bold category&quot;&gt;$&#123;category.categoryName&#125;&lt;/a&gt;
&lt;#--                取消最后一个的竖线--&gt;
                &lt;#if category_has_next&gt;|&lt;/#if&gt;
            &lt;/#list&gt;
        &lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/entity/Category.java
// 24.图书分类实体 25mapper创建一个CategoryMapper
public class Category &#123;
    @TableId(type = IdType.AUTO)
    private Long categoryId;
// 已自动配置好了驼峰命名法 可以忽略
// @TableField(&quot;category_name&quot;)
    private String categoryName;
&#125;Getter + Setter + 重写toString
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/CategoryMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Category;
//25.BaseMapper自动提供了增删改查的功能 泛型指向Category
// 图书分类Mapper接口 26在mappers中创建一个category.xml
public interface CategoryMapper extends BaseMapper&lt;Category&gt; &#123;

&#125;
</code></pre>
<pre><code class="xml">mappers/category.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.CategoryMapper&quot;&gt;
&lt;!-- 26.如何使用呢？ 27创建一个service/CategoryService接口--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/CategoryService.java
package com.imooc.reader.service;
//27.有了service的接口 28就要有实现实现类存放包CategoryServiceImpl

import com.imooc.reader.entity.Category;
import java.util.List;

public interface CategoryService &#123;
    public List&lt;Category&gt; selectAll();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/CategoryServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Category;
import com.imooc.reader.mapper.CategoryMapper;
import com.imooc.reader.service.CategoryService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.List;

//28.向接口编程的规则,注入写好的CategoryMapper接口 设置Transactional事务传播
//默认所有方法是不使用事务的 查询较多的方法不使用事务 写入方法较多下写入事务
//29生成测试类 code-generate-Test  com/imooc/reader/service/impl/CategoryServiceImplTest.java
@Service(&quot;categoryService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class CategoryServiceImpl implements CategoryService &#123;
    @Resource
    private CategoryMapper categoryMapper;
    /**
     * 查询所有图书分类
     * @return 图书分类List
     */
    @Override
    public List&lt;Category&gt; selectAll() &#123;
        //查询列表 返回多个数据 插入条件构造器[查询所有]
        List&lt;Category&gt; list = categoryMapper.selectList(new QueryWrapper&lt;Category&gt;());
        return list;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/CategoryServiceImplTest.java[Test]
package com.imooc.reader.service.impl;

import com.imooc.reader.entity.Category;
import com.imooc.reader.mapper.CategoryMapper;
import com.imooc.reader.service.CategoryService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

import java.util.List;

import static org.junit.Assert.*;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class CategoryServiceImplTest &#123;
    @Resource
    //29.保证属性和刚才的 @Service(&quot;categoryService&quot;)一致 重写Category的tostring方法重新运行selectAll
    //30进入controller开发环节 新建url与方法绑定的BookController.java
    private CategoryService categoryService;
    @Test
    public void selectAll() &#123;
        List&lt;Category&gt; list = categoryService.selectAll();
        System.out.println(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
package com.imooc.reader.controller;

import com.imooc.reader.entity.Category;
import com.imooc.reader.service.CategoryService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.annotation.Resource;
import java.util.List;

//30.显示之前写好的index.ftl
@Controller
public class BookController &#123;
    //传入模板数据 分类信息
    @Resource
    private CategoryService categoryService;
    //showIndex与url绑定  31继续向前推进因为index.ftl所有数据都是静态写死的
    //31要对每一个分类进行读取 List标签&lt;#list&gt;读取 转至index.ftl 64行
    /**
     * 显示首页
     * @return
     */
    @GetMapping(&quot;/&quot;)
    public ModelAndView showIndex()&#123;
        ModelAndView mav = new ModelAndView(&quot;index&quot;);
        List&lt;Category&gt; categoryList = categoryService.selectAll();//拿到列表
        //结果放入其中 属性名,值
        mav.addObject(&quot;categoryList&quot;,categoryList);
        return mav;
    &#125;
&#125;

----------------------------------------------------------
index.ftl
&lt;#-- 31.对页面进行动态的数据导入 32创建全新实体类Book --&gt;
            &lt;#list categoryList as category&gt;
                &lt;a style=&quot;cursor: pointer&quot; data-category=&quot;$&#123;category.categoryId&#125;&quot; class=&quot;text-black-50 font-weight-bold category&quot;&gt;$&#123;category.categoryName&#125;&lt;/a&gt;
&lt;#--   取消最后一个的竖线 --&gt;
                &lt;#if category_has_next&gt;|&lt;/#if&gt;
            &lt;/#list&gt;
        &lt;/div&gt;
</code></pre>
<h3 id="实现图书分页查询"><a href="#实现图书分页查询" class="headerlink" title="实现图书分页查询"></a>实现图书分页查询</h3><pre><code class="java">com/imooc/reader/entity/Book.java
// 32.创建完Book实体类  33去创建全新的BookMapper接口[mapper中]
@TableName(&quot;book&quot;)
public class Book &#123;
    @TableId(type = IdType.AUTO)
    private Long bookId;
    private String bookName;
    private String subTitle;
    private String author;
    private String cover;
    private String description;
    private Long categoryId;
    private Float evaluationScore;
    private Integer evaluationQuantity;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/BookMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Book;
//33.创建完Book接口  34与之对应的创建book.xml文件
public interface BookMapper extends BaseMapper&lt;Book&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">mappers/book.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.BookMapper&quot;&gt;
&lt;!--33.完成底层与数据交互代码 34完成分页处理 是在Service中完成的创建BookService完成分页对象查询--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
package com.imooc.reader.service;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
//图书服务
public interface BookService &#123;
    //34.泛型&lt;Book&gt; 说明查询出来的每一行数据都是一个Book对象
    // 瞄准BookService快速生成实现类Alt+Enter =&gt; Implement interface
    //35编写com.imooc.reader.service.impl.BookServiceImpl
    public IPage&lt;Book&gt; paging(Integer page, Integer rows);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.imooc.reader.entity.Book;
import com.imooc.reader.mapper.BookMapper;
import com.imooc.reader.service.BookService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

//35. 实现分类代码编写  36生成测试用例 Code generate Test =&gt; BookServiceImplTest
@Service(&quot;bookService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class BookServiceImpl implements BookService &#123;
    @Resource
    private BookMapper bookMapper;
    /**
     * 分页查询图书
     * @param page 页号
     * @param rows 每页记录数
     * @return 分页对象
     */
    public IPage&lt;Book&gt; paging(Integer page, Integer rows) &#123;
        Page&lt;Book&gt; p = new Page&lt;Book&gt;(page,rows);
        QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;Book&gt;();
        IPage&lt;Book&gt; pageObject = bookMapper.selectPage(p, queryWrapper);//传入两个参数: page对象哪一页数据  每页记录数[条件构造器]
        return pageObject;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImplTest.java[Test]
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
import com.imooc.reader.service.BookService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

import java.util.List;

import static org.junit.Assert.*;
//36.测试分页的代码编写  37去BookController新加一个方法
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class BookServiceImplTest &#123;
    @Resource
    private BookService bookService;
    @Test
    public void paging() &#123;
        //查询每页十条
        IPage&lt;Book&gt; pageObject = bookService.paging(1,10);
        //获取当前页数据
        List&lt;Book&gt; records = pageObject.getRecords();
        for (Book b:records)&#123;
            System.out.println(b.getBookId() + &quot;:&quot; + b.getBookName());
        &#125;
        System.out.println(&quot;总页数：&quot; + pageObject.getPages());
        System.out.println(&quot;总记录数：&quot; + pageObject.getTotal());
    &#125;
&#125;
</code></pre>
<h3 id="Ajax动态加载图书信息"><a href="#Ajax动态加载图书信息" class="headerlink" title="Ajax动态加载图书信息"></a>Ajax动态加载图书信息</h3><pre><code class="java">com/imooc/reader/controller/BookController.java
//37.编写一个page方法 上面加个@Resource 绑定一个Ajax @GetMapping
    //http://localhost/books 非常长的JSON序列化结果  38index.ftl 83行
    /**  
     * 分页查询图书列表
     * @param p 页号
     * @return 分页对象
     */
package com.imooc.controller;

import com.imooc.reader.entity.Book;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.service.BookService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.annotation.Resource;

@Controller
public class BookController &#123;
    @Resource
    private BookService bookService;
    
    @GetMapping(&quot;/books&quot;)
    @ResponseBody //具体数据来自客户端传入
    public IPage&lt;Book&gt; selectBook(Long categoryId, String order, Integer p) &#123;
        if (p == null) &#123;
            p = 1;
        &#125;
        IPage&lt;Book&gt; pageObject = bookService.paging(categoryId, order, p, 10);
        return pageObject;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gybshen/article/details/79990533">img标签src引用网络图片，响应403的解决方法_img src引用其他网站图片-CSDN博客</a></p>
<pre><code class="java">index.ftl
  &lt;#--    38.编写Json序列化格式并追加到当前网页 上方以导入Art-Template模板引擎 39将&lt;div id=&quot;bookList&quot;&gt;下面的代码裁切放到上面 http://localhost/ --&gt;
    &lt;script&gt;
        $(function () &#123;
            $.ajax(&#123;
                url: &quot;/books&quot;,
                data : &#123;p:1&#125;,
                type : &quot;get&quot;,
                dataType : &quot;json&quot;,
                success: function(json)&#123;
                    console.info(json);
                    var list = json.records;//获取当前分页数据
                    for (var i = 0; i &lt; list.length; i++) &#123;
                        var book = json.records[i];
                        //动态将数据组合成html
                        var html = &quot;&lt;li&gt;&quot; + book.bookName + &quot;&lt;/li&gt;&quot;;
                        //jquery的id选择器选中div对象 追加
                        $(&quot;#bookList&quot;).append(html);
                    &#125;
                &#125;
            &#125;)
        &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="Art-Template-腾讯JS模板引擎"><a href="#Art-Template-腾讯JS模板引擎" class="headerlink" title="Art - Template 腾讯JS模板引擎"></a>Art - Template 腾讯JS模板引擎</h3><p><a target="_blank" rel="noopener" href="https://aui.github.io/art-template/zh-cn/index.html">art-template (aui.github.io)</a></p>
<p>整段HTML模板化 静态文本不变化 动态的数据用响应表达式进行提取</p>
<p>两组大括号进行数据提取</p>
<pre><code class="java">index.ftl
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/bootstrap/bootstrap.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/raty/lib/jquery.raty.css&quot;&gt;
    &lt;script src=&quot;./resources/jquery.3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./resources/bootstrap/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./resources/art-template.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./resources/raty/lib/jquery.raty.js&quot;&gt;&lt;/script&gt;
-------------------------------------------------------------------------------------
&lt;#--39.type=&quot;text/html&quot;说明当前script块中包含的内容是一段一段的html浏览器不会作为javascript进行解析--&gt;
&lt;#-- ★ ★ ★ id是模板名字 两组大括号进行提取数据 ★ ★ ★ 使用模板引擎简化产生html过程--&gt;
&lt;#--    40去修改下方script代码导入的形式--&gt;
    &lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt;
        &lt;a href=&quot;/book/&#123;&#123;bookId&#125;&#125;&quot; style=&quot;color: inherit&quot;&gt;
            &lt;div class=&quot;row mt-2 book&quot;&gt;
                &lt;div class=&quot;col-4 mb-2 pr-2&quot;&gt;
                    &lt;img class=&quot;img-fluid&quot; src=&quot;&#123;&#123;cover&#125;&#125;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-8  mb-2 pl-0&quot;&gt;
                    &lt;h5 class=&quot;text-truncate&quot;&gt;&#123;&#123;bookName&#125;&#125;&lt;/h5&gt;

                    &lt;div class=&quot;mb-2 bg-light small  p-2 w-100 text-truncate&quot;&gt;&#123;&#123;author&#125;&#125;&lt;/div&gt;


                    &lt;div class=&quot;mb-2 w-100&quot;&gt;&#123;&#123;subTitle&#125;&#125;&lt;/div&gt;

                    &lt;p&gt;
                        &lt;span class=&quot;stars&quot; data-score=&quot;&#123;&#123;evaluationScore&#125;&#125;&quot; title=&quot;gorgeous&quot;&gt;&lt;/span&gt;
&lt;#--                        &lt;img alt=&quot;1&quot; 加入了星型组件免去这些操作 --&gt;
&lt;#--                             src=&quot;./resources/raty/lib/images/star-on.png&quot;--&gt;
&lt;#--                             title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img alt=&quot;2&quot;--&gt;
&lt;#--                                                         src=&quot;./resources/raty/lib/images/star-on.png&quot;--&gt;
&lt;#--                                                         title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img--&gt;
&lt;#--                                alt=&quot;3&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img--&gt;
&lt;#--                                alt=&quot;4&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img--&gt;
&lt;#--                                alt=&quot;5&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&lt;input--&gt;
&lt;#--                                name=&quot;score&quot; type=&quot;hidden&quot; value=&quot;&#123;&#123;evaluationScore&#125;&#125;&quot; readonly=&quot;&quot;&gt;&lt;/span&gt;--&gt;
                        &lt;span class=&quot;mt-2 ml-2&quot;&gt;&#123;&#123;evaluationScore&#125;&#125;&lt;/span&gt;
                        &lt;span class=&quot;mt-2 ml-2&quot;&gt;&#123;&#123;evaluationQuantity&#125;&#125;人已评&lt;/span&gt;
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/a&gt;
    &lt;/script&gt;

&lt;#--    38.编写Json序列化格式并追加到当前网页 上方以导入Art-Template[js]模板引擎 39将&lt;div id=&quot;bookList&quot;&gt;下面的代码裁切放到上面--&gt;
        &lt;script&gt;
&lt;#-- 41.引入星星图片 和 评价方法 上面的script运用简便写法 42下面 $(&quot;.stars&quot;)将星星的span标签选中 raty转换成可视的星星组件--&gt;
            $.fn.raty.defaults.path = &quot;./resources/raty/lib/images&quot;
            $(function () &#123;
                $.ajax(&#123;
                    url: &quot;/books&quot;,
                    data : &#123;p:1&#125;,
                    type : &quot;get&quot;,
                    dataType : &quot;json&quot;,
                    success: function(json)&#123;
                        console.info(json);
                        var list = json.records;//获取当前分页数据
                        for (var i = 0; i &lt; list.length; i++) &#123;
                            var book = json.records[i];
                            // 动态将数据组合成html
                            // var html = &quot;&lt;li&gt;&quot; + book.bookName + &quot;&lt;/li&gt;&quot;;
                            // 40.替换导入数据形式 (传入模板id,传入数据) 将数据结合tpl模板,生成html
                            // 41当评分降低的时候顺带着星星的亮度降低 raty星型评分组件 上面已准备好raty css js引入
                            // 41在上面几行引入星型评分的script方法
                            var html = template(&quot;tpl&quot;, book);
                            console.info(html);
                            //jquery的id选择器选中div对象 追加
                            $(&quot;#bookList&quot;).append(html);
                        &#125;
                        //42.显示星型评价组件 只读并不能修改
                        $(&quot;.stars&quot;).raty(&#123;readonly:true&#125;);
                    &#125;
                &#125;)
            &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="实现图书列表分页查询"><a href="#实现图书列表分页查询" class="headerlink" title="实现图书列表分页查询"></a>实现图书列表分页查询</h3><pre><code class="java">index.ftl
// 43.用于绑定加载更多按钮单击事件 44下面的设置页面的逻辑及处理
        $(function () &#123;
            $(&quot;#btnMore&quot;).click(function ()&#123;
                loadMore();
            &#125;)
        &#125;)
</code></pre>
<pre><code class="java">&lt;script&gt;
&lt;#-- 41.引入星星图片 和 评价方法 上面的script运用简便写法 42下面 $(&quot;.stars&quot;)将星星的span标签选中 raty转换成可视的星星组件(被注释)--&gt;
        $.fn.raty.defaults.path = &quot;./resources/raty/lib/images&quot;
        // 45.对两次Ajax的代码进行重构与梳理(定义一个loadMore()方法将下面的裁切进来底下写进递归)
        // isReset参数设置true,代表从第一页开始查询,否则按nextPage查询后续页
        // 对下面那个data: &#123;p: 1&#125;, 进行重构 ↓↓↓↓ isReset 下面代码已经被注释但未完全删除
        // loadMore()加载更多数据
        function loadMore(isReset)&#123;
            if (isReset == true)&#123;
                $(&quot;#nextPage&quot;).val(1);
            &#125;
            var nextPage = $(&quot;#nextPage&quot;).val();
            $.ajax(&#123;
                url: &quot;/books&quot;,
                //nextPage为2可以加载第二页
                data: &#123;p: nextPage&#125;,
                type: &quot;get&quot;,
                dataType: &quot;json&quot;,
                success: function (json) &#123;
                    console.info(json);
                    var list = json.records;//获取当前分页数据
                    for (var i = 0; i &lt; list.length; i++) &#123;
                        var book = json.records[i];
                        var html = template(&quot;tpl&quot;, book);
                        console.info(html);
                        //jquery的id选择器选中div对象 追加
                        $(&quot;#bookList&quot;).append(html);
                    &#125;
                    $(&quot;.stars&quot;).raty(&#123;readonly: true&#125;);
                    // 44.如果当前页小于总页数 下面利用val设置隐藏域的值
                    // 可能将按照字符串处理 结果是31而不是4 要强制转换
                    // 若有后续数据的话 最后几行的divNoMore需要隐藏起来
                    // 45对两次的Ajax代码进行重构与梳理 上面找到第一个script
                    if (json.current &lt; json.pages)&#123;
                        $(&quot;#nextPage&quot;).val(parseInt(json.current + 1));
                        $(&quot;#btnMore&quot;).show();
                        $(&quot;#divNoMore&quot;).hide();
                    &#125;else &#123;
                        $(&quot;#btnMore&quot;).hide();
                        $(&quot;#divNoMore&quot;).show();
                    &#125;
                &#125;
            &#125;)
        &#125;
     
        $(function () &#123;
            loadMore(true);
        &#125;)

        // 43.用于绑定加载更多按钮单击事件 44上面的设置页面的逻辑及处理
        $(function () &#123;
            $(&quot;#btnMore&quot;).click(function ()&#123;
                loadMore();
            &#125;)
        &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="实现图书多条件动态查询"><a href="#实现图书多条件动态查询" class="headerlink" title="实现图书多条件动态查询"></a>实现图书多条件动态查询</h3><pre><code class="java">index.ftl
// 43.用于绑定加载更多按钮单击事件 44上面的设置页面的逻辑及处理
        $(function()&#123;
            $(&quot;#btnMore&quot;).click(function()&#123;
                loadMore();
            &#125;)
            //46 增加点击的显示控件
            $(&quot;.category&quot;).click(function () &#123;
                $(&quot;.category&quot;).removeClass(&quot;highlight&quot;); //移除高亮
                $(&quot;.category&quot;).addClass(&quot;text-black-50&quot;);//增添灰色
                $(this).addClass(&quot;highlight&quot;);//增加高亮
                //49添加数量与热度 ↓点击的超链接 在下面也要添加order
                var categoryId = $(this).data(&quot;category&quot;); //214行定义了data-category
                $(&quot;#categoryId&quot;).val(categoryId);
                loadMore(true); //每次点完要重新查询
            &#125;)//在排序处显示控件 47点击 全部|前端|后端 产生数据联动BookService上

            $(&quot;.order&quot;).click(function()&#123;
                $(&quot;.order&quot;).removeClass(&quot;highlight&quot;); //移除高亮
                $(&quot;.order&quot;).addClass(&quot;text-black-50&quot;);//增添灰色
                $(this).addClass(&quot;highlight&quot;);//增加高亮
                //~49.提取设置到隐藏域中 发送请求到Ajax服务器上最上面 50var categoryId
                var order = $(this).data(&quot;order&quot;);
                $(&quot;#order&quot;).val(order); //点击不同隐藏域时为其赋值
                loadMore(true);
            &#125;)
        &#125;)
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
package com.imooc.reader.service;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
//图书服务
public interface BookService &#123;
    //34.泛型&lt;Book&gt; 说明查询出来的每一行数据都是一个Book对象
    // 瞄准BookService快速生成实现类Alt+Enter =&gt; Implement interface
    //35编写com.imooc.reader.service.impl.BookServiceImpl

    /**
     * 分页查询图书
     * @param categoryId 分类编号
     * @param order 排序方式
     * @param page 页号
     * @param rows 每页记录数
     * @return 分页对象
     */
//    47增加两个变量且在BookServiceImpl中也对应增加上
    public IPage&lt;Book&gt; paging(Long categoryId, String order, Integer page, Integer rows);
&#125;
</code></pre>
<pre><code class="java">package com.imooc.reader.service.impl.BookServiceImpl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.imooc.reader.entity.Book;
import com.imooc.reader.mapper.BookMapper;
import com.imooc.reader.service.BookService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

//35. 实现分类代码编写  36生成测试用例 Code generate Test =&gt; BookServiceImplTest
@Service(&quot;bookService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class BookServiceImpl implements BookService &#123;
    @Resource
    private BookMapper bookMapper;

    /**
     * 分页查询图书
     *
     * @param categoryId 分类编号
     * @param order      排序方式
     * @param page       页号
     * @param rows       每页记录数
     * @return 分页对象
     */
    public IPage&lt;Book&gt; paging(Long categoryId, String order, Integer page, Integer rows) &#123;
        Page&lt;Book&gt; p = new Page&lt;Book&gt;(page, rows);
        QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;Book&gt;();
        //47.编写匹配条件 48去BookController更改调用参数
        if (categoryId != null &amp;&amp; categoryId != -1) &#123;//代表传入了有效分类编号
            queryWrapper.eq(&quot;category_id&quot;, categoryId);//查询的where子句
        &#125;
        if (order != null) &#123;
            if (order.equals(&quot;quantity&quot;)) &#123; //前台必须传入↓ 评价人数排序
                queryWrapper.orderByDesc(&quot;evaluation_quantity&quot;);//降序排序
            &#125; else if (order.equals(&quot;score&quot;)) &#123;
                queryWrapper.orderByDesc(&quot;evaluation_score&quot;);//评分降序
            &#125;
        &#125;
        IPage&lt;Book&gt; pageObject = bookMapper.selectPage(p, queryWrapper);//传入两个参数: page对象哪一页数据  每页记录数[条件构造器]
        return pageObject;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
package com.imooc.reader.controller;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
import com.imooc.reader.entity.Category;
import com.imooc.reader.service.BookService;
import com.imooc.reader.service.CategoryService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import javax.annotation.Resource;
import java.util.List;

//30.显示之前写好的index.ftl
@Controller
public class BookController &#123;
    //传入模板数据 分类信息
    @Resource
    private CategoryService categoryService;
    @Resource
    private BookService bookService;
    //showIndex与url绑定  31继续向前推进因为index.ftl所有数据都是静态写死的
    //31要对每一个分类进行读取 List标签&lt;#list&gt;读取 转至index.ftl 64行

    /**
     * 显示首页
     *
     * @return
     */
    @GetMapping(&quot;/&quot;)
    public ModelAndView showIndex() &#123;
        ModelAndView mav = new ModelAndView(&quot;index&quot;);
        List&lt;Category&gt; categoryList = categoryService.selectAll();//拿到列表
        //结果放入其中 属性名,值
        mav.addObject(&quot;categoryList&quot;, categoryList);
        return mav;
    &#125;
//37.编写一个page方法 上面加个@Resource 绑定一个Ajax @GetMapping
    //http://localhost/books 非常长的JSON序列化结果  38index.ftl 40行

    /**
     * 分页查询图书列表
     *
     * @param p 页号
     * @return 分页对象
     */
    //48.更改调用参数 更改BookServiceImplTest.java调用参数 49回到index.ftl 增加function第二个
    @GetMapping(&quot;/books&quot;)
    @ResponseBody //具体数据来自客户端传入
    public IPage&lt;Book&gt; selectBook(Long categoryId, String order, Integer p) &#123;
        if (p == null) &#123;
            p = 1;
        &#125;
        IPage&lt;Book&gt; pageObject = bookService.paging(categoryId, order, p, 10);
        return pageObject;
    &#125;
&#125;
</code></pre>
<pre><code class="java">index.ftl
&lt;script&gt;
        &lt;#-- 41.引入星星图片 和 评价方法 上面的script运用简便写法 42下面 $(&quot;.stars&quot;)将星星的span标签选中 raty转换成可视的星星组件(被注释)--&gt;
        $.fn.raty.defaults.path = &quot;./resources/raty/lib/images&quot;
        // 45.对两次Ajax的代码进行重构与梳理(定义一个loadMore()方法将下面的裁切进来底下写进递归)
        // isReset参数设置true,代表从第一页开始查询,否则按nextPage查询后续页
        // 对下面那个data: &#123;p: 1&#125;, 进行重构 ↓↓↓↓ isReset 下面代码已经被注释但未完全删除
        // loadMore()加载更多数据 46下方整理点击时的高亮显示 [全部]
        function loadMore(isReset)&#123;
            if(isReset == true)&#123;
                $(&quot;#bookList&quot;).html(&quot;&quot;);
                $(&quot;#nextPage&quot;).val(1);
            &#125;
            // 50.让Ajax获取数据在下方data填写 下方$(&quot;.category和.order&quot;)都要重新调用递归
            // 细节清空再显示 上方$(&quot;#bookList&quot;).html(&quot;&quot;);
            var nextPage = $(&quot;#nextPage&quot;).val();
            var categoryId= $(&quot;#categoryId&quot;).val();
            var order = $(&quot;#order&quot;).val();
            //接下来就是发送数据时 组织成参数发送服务器
            $.ajax(&#123;
                url : &quot;/books&quot; ,
                //nextPage为2可以加载第二页  ↓字符串：变量
                data : &#123;p:nextPage,&quot;categoryId&quot;:categoryId , &quot;order&quot;:order&#125;,
                type : &quot;get&quot; ,
                dataType : &quot;json&quot; ,
                success : function(json)&#123;
                    console.info(json);
                    var list = json.records;
                    for(var i = 0 ; i &lt; list.length ; i++)&#123;
                        var book = json.records[i];
                        // var html = &quot;&lt;li&gt;&quot; + book.bookName + &quot;&lt;/li&gt;&quot;;
                        //将数据结合tpl模板,生成html
                        var html = template(&quot;tpl&quot; , book);
                        console.info(html);
                        //jquery的id选择器选中div对象 追加
                        $(&quot;#bookList&quot;).append(html);
                    &#125;
                    $(&quot;.stars&quot;).raty(&#123;readOnly:true&#125;);
                    // 44.如果当前页小于总页数 下面利用val设置隐藏域的值
                    // 可能将按照字符串处理 结果是31而不是4 要强制转换
                    // 若有后续数据的话 最后几行的divNoMore需要隐藏起来
                    // 45对两次的Ajax代码进行重构与梳理 上面找到第一个script
                    if(json.current &lt; json.pages)&#123;
                        $(&quot;#nextPage&quot;).val(parseInt(json.current) + 1);
                        $(&quot;#btnMore&quot;).show();
                        $(&quot;#divNoMore&quot;).hide();
                    &#125;else&#123;
                        $(&quot;#btnMore&quot;).hide();
                        $(&quot;#divNoMore&quot;).show();
                    &#125;
                &#125;
            &#125;)
        &#125;
</code></pre>
<h3 id="图书详情页-读取图书信息"><a href="#图书详情页-读取图书信息" class="headerlink" title="图书详情页-读取图书信息"></a>图书详情页-读取图书信息</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gybshen/article/details/79990533">img标签src引用网络图片，响应403的解决方法_img src引用其他网站图片-CSDN博客</a></p>
<pre><code class="java">com/imooc/reader/service/BookService.java
public IPage&lt;Book&gt; paging(Long categoryId, String order, Integer page, Integer rows);
    /**
     * 根据图书编号查询图书对象
     * @param bookId 图书编号
     * @return 图书对象
     */
    //51.增加一个查询书籍的接口 再去BookServiceImpl中实现
    public Book selectById(Long bookId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
 //51实现后再向上推进 BookController
    @Override
    public Book selectById(Long bookId) &#123;
        Book book = bookMapper.selectById(bookId);
        return book;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
//51.进行页面的绑定 获取读书编号 52把所有ftl相对路径改成绝对路径 ./前面的.删掉
    //加上了./就是  localhost/book/......   删掉就是 localhost/......
    //52更改detail.ftl将静态页面改成动态页面
    @GetMapping(&quot;/book/&#123;id&#125;&quot;) //↓ 路径变量 和 上面的保持一致
    public ModelAndView showDetail(@PathVariable(&quot;id&quot;) Long id)&#123;
        Book book = bookService.selectById(id);
        ModelAndView mav = new ModelAndView(&quot;/detail&quot;);
        mav.addObject(&quot;book&quot;, book);
        return mav;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
&lt;#-- 52.更改detail.ftl将静态页面改成动态页面 &lt;title&gt; 还有下面图书细节 --&gt;
&lt;#--  53.来源于数据底层的description描述字段   54显示动态评论列表 数据库有evaluation表 创建一个entity/Evaluation--&gt;

    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt; &lt;#--防止网页图片加载不出来--&gt;
    &lt;title&gt;$&#123;book.bookName&#125;&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/bootstrap/bootstrap.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/raty/lib/jquery.raty.css&quot;&gt;
    &lt;script src=&quot;/resources/jquery.3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/resources/bootstrap/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/resources/art-template.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/resources/raty/lib/jquery.raty.js&quot;&gt;&lt;/script&gt;

-------------------------------------------------------------------
&lt;div class=&quot;row p-2 description&quot;&gt;
        &lt;#-- 53.来源于数据底层的description描述字段     --&gt;
        $&#123;book.description&#125;
    &lt;/div&gt;
</code></pre>
<h3 id="图书详情页-显示评论列表"><a href="#图书详情页-显示评论列表" class="headerlink" title="图书详情页-显示评论列表"></a>图书详情页-显示评论列表</h3><pre><code class="java">com/imooc/reader/entity/Member.java
//59.创建Member实体后完成MemberMapper接口
@TableName(&quot;member&quot;)
public class Member &#123;
    @TableId(type = IdType.AUTO)
    private Long memberId;
    private String username;
    private String password;
    private Integer salt;
    private String nickname;
    private Date createTime;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/reader/entity/Evaluation.java
package com.imooc.reader.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.util.Date;
//54.创造了评论相关的底层entity 55定义一个EvaluationMapper.java接口
//再定义一个 evaluation.xml  再service上创建一个新的接口EvaluationService.java
@TableName(&quot;evaluation&quot;)
public class Evaluation &#123;
//  id是主键
    @TableId(type= IdType.AUTO)
    private Long evaluationId;
    private Long bookId;
    private String content;
    private Integer score;
    private Long memberId;
    private Date createTime;
    private Integer enjoy;
    private String state;
    private String disableReason;
    private Date disableTime;
    @TableField(exist = false) //58.说明book属性没有对应字段,不会参与到sql自动生成
    private Book book; //Book的关联字段 加注解不存在 不会参与sql语句自动生成中 59创建会员entity对象Member实体
    @TableField(exist = false)
    private Member member; //59.获取集合后查询每个评论的信息 EvaluationServiceImpl中
&#125;Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/EvaluationMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Evaluation;
//55
public interface EvaluationMapper extends BaseMapper&lt;Evaluation&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">mappers/evaluation.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.EvaluationMapper&quot;&gt;
&lt;!--55--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/EvaluationService.java
package com.imooc.reader.service;

import com.imooc.reader.entity.Evaluation;

import java.util.List;
//55.再创建一个它的实现类 Alt+回车 com/imooc/reader/service/impl/EvaluationServiceImpl.java
public interface EvaluationService&#123;
    /**
     * 按图书编号查询有效短评
     * @param bookId 图书编号
     * @return 评论列表
     */
    public List&lt;Evaluation&gt; selectByBookId(Long bookId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/EvaluationServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Book;
import com.imooc.reader.entity.Evaluation;
import com.imooc.reader.entity.Member;
import com.imooc.reader.mapper.BookMapper;
import com.imooc.reader.mapper.EvaluationMapper;
import com.imooc.reader.mapper.MemberMapper;
import com.imooc.reader.service.EvaluationService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.List;
//55.按图书编号查询有效短评   56BookController得到对应的图书编号以后 基于service查询对应短评信息
@Service(&quot;evluationService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class EvaluationServiceImpl implements EvaluationService &#123;
    @Resource
    private EvaluationMapper evaluationMapper;
    //59
    @Resource
    private MemberMapper memberMapper;
    @Resource
    private BookMapper bookMapper;
    /**
     * 按图书编号查询有效短评
     * @param bookId 图书编号
     * @return
     */
    @Override
    public List&lt;Evaluation&gt; selectByBookId(Long bookId) &#123;
        Book book = bookMapper.selectById(bookId); //59根据参数查询book对象
        QueryWrapper&lt;Evaluation&gt; queryWrapper = new QueryWrapper&lt;Evaluation&gt;();
        queryWrapper.eq(&quot;book_id&quot;, bookId);
        queryWrapper.eq(&quot;state&quot;,&quot;enable&quot;);
        queryWrapper.orderByDesc(&quot;create_time&quot;);
        List&lt;Evaluation&gt; evaluationList = evaluationMapper.selectList(queryWrapper);
        //59.查询每个评论的信息
        for(Evaluation eva:evaluationList)&#123;
            Member member = memberMapper.selectById(eva.getMemberId());//59获得会员对象要使用接口咯
            eva.setMember(member);
            eva.setBook(book);//59循环的时候为每一个Evaluation设置一个book对象 60回到detail.ftl
        &#125;
        return evaluationList;
    &#125;
&#125;
</code></pre>
<pre><code class="java">detail.ftl
 &lt;div class=&quot;alert alert-primary w-100 mt-2&quot; role=&quot;alert&quot;&gt;短评
        &lt;button type=&quot;button&quot; id=&quot;btnEvaluation&quot; class=&quot;btn btn-success btn-sm text-white float-right&quot;
                style=&quot;margin-top: -3px;&quot;&gt;
            写短评
        &lt;/button&gt;
    &lt;/div&gt;
    &lt;div class=&quot;reply pl-2 pr-2&quot;&gt;
&lt;#--  57.对短评进行动态页面的整合与梳理 进行循环遍历  58注意下面的慕粉-126对应着数据库的会员表 再重来一遍 Evaluation--&gt;
        &lt;#list evaluationList as evaluation&gt;
            &lt;div&gt;
                &lt;div&gt;
                    &lt;span class=&quot;pt-1 small text-black-50 mr-2&quot;&gt;$&#123;evaluation.createTime?string(&#39;MM-dd&#39;)&#125;&lt;/span&gt;
&lt;#--   60.修改 慕粉-126 变为动态的--&gt;
                    &lt;span class=&quot;mr-2 small pt-1&quot;&gt;$&#123;evaluation.member.nickname&#125;&lt;/span&gt;
                    &lt;span class=&quot;stars mr-2&quot; data-score=&quot;$&#123;evaluation.score&#125;&quot;&gt;&lt;/span&gt;

                    &lt;button type=&quot;button&quot; data-evaluation-id=&quot;$&#123;evaluation.evaluationId&#125;&quot;
                            class=&quot;btn btn-success btn-sm text-white float-right&quot; style=&quot;margin-top: -3px;&quot;&gt;
                        &lt;img style=&quot;width: 24px;margin-top: -5px;&quot; class=&quot;mr-1&quot;
                             src=&quot;https://img3.doubanio.com/f/talion/7a0756b3b6e67b59ea88653bc0cfa14f61ff219d/pics/card/ic_like_gray.svg&quot;/&gt;
                        &lt;span&gt;$&#123;evaluation.enjoy&#125;&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;

                &lt;div class=&quot;row mt-2 small mb-3&quot;&gt;
                    $&#123;evaluation.content&#125;
                &lt;/div&gt;
                &lt;hr/&gt;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;
</code></pre>
<h3 id="会员注册与登录"><a href="#会员注册与登录" class="headerlink" title="会员注册与登录"></a>会员注册与登录</h3><h5 id="Kaptcha验证码的配置与使用"><a href="#Kaptcha验证码的配置与使用" class="headerlink" title="Kaptcha验证码的配置与使用"></a>Kaptcha验证码的配置与使用</h5><ul>
<li>Kaptcha 是谷歌开源的可高度配置的使用验证码生成工具</li>
<li>通过 Kaptcha 可阻拦大多数机器人脚本操作</li>
<li>Kaptcha 典型应用于注册、登录、重要信息提交等用户交互</li>
</ul>
<h5 id="Kaptcha-使用步骤"><a href="#Kaptcha-使用步骤" class="headerlink" title="Kaptcha 使用步骤"></a>Kaptcha 使用步骤</h5><ul>
<li>Kaptcha 配置验证码生成参数</li>
<li>开发 KaptchaController 生成验证码图片</li>
<li>将前台输入验证码与session保存的验证码进行比对</li>
</ul>
<pre><code class="xml">pom.xml
&lt;!--   61.增加Kaptcha验证码组件依赖 applicationContext增加一个bean  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;
            &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;
            &lt;version&gt;2.3.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--  61.配置Kaptcha 的bean  62创造KaptchaController.java--&gt;
    &lt;bean id=&quot;KaptchaProducer&quot; class=&quot;com.google.code.kaptcha.impl.DefaultKaptcha&quot;&gt;
        &lt;property name=&quot;config&quot;&gt;
            &lt;bean class=&quot;com.google.code.kaptcha.util.Config&quot;&gt;
                &lt;constructor-arg&gt;
                    &lt;props&gt;
                        &lt;!-- 验证码图片不生成边框 --&gt;
                        &lt;prop key=&quot;kaptcha.border&quot;&gt;no&lt;/prop&gt;
                        &lt;!-- 验证码图片宽度为120像素  --&gt;
                        &lt;prop key=&quot;kaptcha.image.width&quot;&gt;120&lt;/prop&gt;
                        &lt;!-- 验证码图片字体颜色为蓝色  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.color&quot;&gt;blue&lt;/prop&gt;
                        &lt;!-- 每个字符最大占用40像素  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.size&quot;&gt;40&lt;/prop&gt;
                        &lt;!-- 验证码包含4个字符  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.char.length&quot;&gt;4&lt;/prop&gt;
                    &lt;/props&gt;
                &lt;/constructor-arg&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/KaptchaController.java
package com.imooc.reader.controller;

import com.google.code.kaptcha.Producer;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import javax.annotation.Resource;
import javax.imageio.ImageIO;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.image.BufferedImage;
import java.io.IOException;
//62.完成图片的随机生成与控制台的输出相同 63将原型里的 注册页 复制到项目工程register.ftl
@Controller
public class KaptchaController &#123;
    @Resource
    private Producer kaptchaProducer;
//    Ioc动态注入 因为验证码组件设计的时候没有考虑过SpringMVC的集成 要使用原生的请求与响应
    @GetMapping(&quot;/verify_code&quot;)
    public void createVerifyCode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        //响应立即过期
        response.setDateHeader(&quot;Expires&quot;,0);
        //不存储 不缓存任何图片数据
        response.setHeader(&quot;Cache-Control&quot;,&quot;no-store,no-cache,must-revalidate&quot;);
        response.setHeader(&quot;Cache-Control&quot;,&quot;post-check=0,pre-check=0&quot;);
        response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);
        response.setContentType(&quot;image/png&quot;);
        //生成验证码字符文本
        String verifyCode = kaptchaProducer.createText();
        request.getSession().setAttribute(&quot;kaptchaVerifyCode&quot;,verifyCode);
        System.out.println( request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;));
        BufferedImage image = kaptchaProducer.createImage(verifyCode);//创建验证码图片 二进制图片
        //二进制用getOutputStream() 字符用getWritter()
        ServletOutputStream out = response.getOutputStream();
        ImageIO.write(image,&quot;png&quot;,out);//输出图片流
        out.flush(); //立即输出
        out.close(); //关闭输出流

    &#125;
&#125;
</code></pre>
<h3 id="Kaptcha验证码的使用与对比-运用到前端"><a href="#Kaptcha验证码的使用与对比-运用到前端" class="headerlink" title="Kaptcha验证码的使用与对比 [运用到前端]"></a>Kaptcha验证码的使用与对比 [运用到前端]</h3><pre><code class="java">register.ftl
&lt;div class=&quot;col-4 p-0 pl-2 pt-0&quot;&gt;
   &lt;!-- 63.验证码图片 src要显示从服务器后台动态生成的验证码 KaptchaController生成的url粘贴在这里 64弄一个MemberController--&gt;
   &lt;img id=&quot;imgVerifyCode&quot; src=&quot;/verify_code&quot;
   style=&quot;width: 120px;height:50px;cursor: pointer&quot;&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
package com.imooc.reader.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

//64.嵌入验证码 65编写单机验证码刷新register.ftl中的function reloadVerifyCode()
@Controller
public class MemberController &#123;
    @GetMapping(&quot;/register.html&quot;)
    public ModelAndView showRegister() &#123;
        return new ModelAndView(&quot;/register&quot;);
    &#125;
    //67. 验证码匹配比对 request拿到对象  68编写会员服务MemberService.java
    @PostMapping(&quot;/registe&quot;)
    @ResponseBody
    public Map registe(String vc, String username, String password, String nickname, HttpServletRequest request)&#123;
        //接收kaptchaController.java中的request.getSession().setAttribute响应
        //正确验证码
        String verityCode  = (String)request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;);
        //验证码比对  后面的是大小写对比
        Map result = new HashMap();
        if (vc == null || verityCode == null || !vc.equalsIgnoreCase(verityCode))&#123;
            result.put(&quot;code&quot;,&quot;VC01&quot;);
            result.put(&quot;msg&quot;,&quot;验证码错误&quot;);
        &#125;else &#123;
            result.put(&quot;code&quot;,&quot;0&quot;);
            result.put(&quot;msg&quot;,&quot;success&quot;);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<pre><code class="java">register.ftl
&lt;script&gt;
    //控制错误信息的显示与隐藏
    function showTips(isShow, css, text) &#123;
        if (isShow) &#123;
            $(&quot;#tips&quot;).removeClass(&quot;d-none&quot;)
            $(&quot;#tips&quot;).hide();
            $(&quot;#tips&quot;).addClass(css);
            $(&quot;#tips&quot;).text(text);
            $(&quot;#tips&quot;).fadeIn(200);
        &#125; else &#123;
            $(&quot;#tips&quot;).text(&quot;&quot;);
            $(&quot;#tips&quot;).fadeOut(200);
            $(&quot;#tips&quot;).removeClass();
            $(&quot;#tips&quot;).addClass(&quot;alert&quot;)
        &#125;
    &#125;
    //65.重新发送请求,刷新验证码 66验证码与后台绑定[比对校验]
    function reloadVerifyCode()&#123;
        //请在这里实现刷新验证码 ts timestamp是时间戳 增加时间戳取消缓存
        $(&quot;#imgVerifyCode&quot;).attr(&quot;src&quot;,&quot;/verify_code?ts=&quot; + new Date().getTime())
    &#125;
    
    //点击验证码图片刷新验证码
    $(&quot;#imgVerifyCode&quot;).click(function () &#123;
        reloadVerifyCode();
    &#125;);
    
    // 66.点击提交按钮,向/registe发起ajax请求
    //提交请求包含四个参数
    //vc:前台输入验证码  username:用户名 password:密码 nickname:昵称
    $(&quot;#btnSubmit&quot;).click(function () &#123;
        //表单校验
        var username = $.trim($(&quot;#username&quot;).val());
        var regex = /^.&#123;6,10&#125;$/;
        if (!regex.test(username)) &#123;
            showTips(true, &quot;alert-danger&quot;, &quot;用户名请输入正确格式（6-10位）&quot;);
            return;
        &#125; else &#123;
            showTips(false);
        &#125;

        var password = $.trim($(&quot;#password&quot;).val());

        if (!regex.test(password)) &#123;
            showTips(true, &quot;alert-danger&quot;, &quot;密码请输入正确格式（6-10位）&quot;);
            return;
        &#125; else &#123;
            showTips(false);
        &#125;

        $btnReg = $(this);

        $btnReg.text(&quot;正在处理...&quot;);
        $btnReg.attr(&quot;disabled&quot;, &quot;disabled&quot;);
        
        //66.发送ajax请求 67编写MemberController.java实现url
        $.ajax(&#123;
            url: &quot;/registe&quot;,
            type: &quot;post&quot;,
            dataType: &quot;json&quot;,
            data: $(&quot;#frmLogin&quot;).serialize(),
            success: function (data) &#123;
                //结果处理,根据服务器返回code判断服务器处理状态
                //服务器要求返回JSON格式:
                //&#123;&quot;code&quot;:&quot;0&quot;,&quot;msg&quot;:&quot;处理消息&quot;&#125;
                console.info(&quot;服务器响应:&quot; , data);
                if (data.code == &quot;0&quot;) &#123;
                    //显示注册成功对话框
                    $(&quot;#exampleModalCenter&quot;).modal(&#123;&#125;);
                    $(&quot;#exampleModalCenter&quot;).modal(&quot;show&quot;);
                &#125; else &#123;
                    //服务器校验异常,提示错误信息
                    showTips(true, &quot;alert-danger&quot;, data.msg);
                    reloadVerifyCode();
                    $btnReg.text(&quot;注    册&quot;);
                    $btnReg.removeAttr(&quot;disabled&quot;);
                &#125;
            &#125;
        &#125;);
        return false;
    &#125;);
&lt;/script&gt;
============================
67在上面MemberController.java
</code></pre>
<h3 id="实现会员注册功能"><a href="#实现会员注册功能" class="headerlink" title="实现会员注册功能"></a>实现会员注册功能</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mask_boys/article/details/118273990">500 (Internal Server Error)_谷歌浏览器 internal server error-CSDN博客</a></p>
<pre><code class="java">com/imooc/reader/service/MemberService.java
package com.imooc.reader.service;

import com.imooc.reader.entity.Member;
//68.创建一个实现类MemberServiceImpl.java[Alt + Enter]
public interface MemberService &#123;
    /**
     * 会员注册,创建新会员
     * @param username
     * @param password
     * @param nickname
     * @return
     */
    public Member createMember(String username, String password, String nickname);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/exception.java
package com.imooc.reader.service.exception;

/**
 * 68.业务逻辑异常 回到MemberServiceImpl编写用户名异常 69返回MemberServiceImpl
 */
public class BussinessException extends RuntimeException&#123;
    private String code;
    private String msg;

    //构造方法
    public BussinessException(String code, String msg) &#123;
        super(msg); //继承自运行时异常
        this.code = code;
        this.msg = msg;
    &#125;

    public String getCode() &#123;
        return code;
    &#125;

    public void setCode(String code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/utils/MD5Utils.java
package com.imooc.reader.utils;

import org.apache.commons.codec.digest.DigestUtils;
//70.生成MD5方法 返回MemberServiceImpl编写随机数
public class MD5Utils &#123;
    public static String md5Digest(String source, Integer salt)&#123;
        char[] ca = source.toCharArray();//获取字符数组
        for (int i = 0; i &lt; ca.length; i++) &#123;
            ca[i] = (char) (ca[i] + salt);
        &#125;
        String target = new String(ca);
        String md5 = DigestUtils.md5Hex(target);
        return md5;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Member;
import com.imooc.reader.mapper.MemberMapper;
import com.imooc.reader.service.exception.BussinessException;
import com.imooc.reader.service.MemberService;
import com.imooc.reader.utils.MD5Utils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
import java.util.List;
import java.util.Random;

//68.完成与会员的交互[写操作居多] 完成运行异常service/BussinessException.java
@Service(&quot;memberService&quot;)
@Transactional
public class MemberServiceImpl implements MemberService &#123;
    @Resource
    private MemberMapper memberMapper;

    /**
     * 会员注册,创建新会员
     *
     * @param username 用户名
     * @param password 密码
     * @param nickname 昵称
     * @return 新会员对象
     */
    public Member createMember(String username, String password, String nickname) &#123;
        QueryWrapper&lt;Member&gt; queryWrapper = new QueryWrapper&lt;Member&gt;();
        queryWrapper.eq(&quot;username&quot;, username);
        List&lt;Member&gt; memberList = memberMapper.selectList(queryWrapper);
        //判断用户名是否已存在 68定义一个异常BussinessException.java
        //69.续写异常  70增加加密组件pom.xml
        if (memberList.size() &gt; 0) &#123;
            throw new BussinessException(&quot;M01&quot;, &quot;用户名已存在&quot;);
        &#125;
        Member member = new Member();
        member.setUsername(username);
        member.setNickname(nickname);
        //70. 随机数md5  71生成测试用例MemberServiceImplTest
        int salt = new Random().nextInt(1000)+1000; //盐值
        String md5 = MD5Utils.md5Digest(password, salt);
        member.setPassword(md5);
        member.setSalt(salt);
        member.setCreateTime(new Date()); //创建时间
        memberMapper.insert(member);
        return member;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImplTest.java
package com.imooc.reader.service.impl;

import com.imooc.reader.service.MemberService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

//71.生成测试用例 72MemberController后续的工作
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class MemberServiceImplTest &#123;
    @Resource
    private MemberService memberService;
    @Test
    public void createMember() &#123;
        memberService.createMember(&quot;s123457&quot;, &quot;123456&quot;, &quot;测试&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
package com.imooc.reader.controller;

import com.imooc.reader.service.exception.BussinessException;
import com.imooc.reader.service.MemberService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

//64.嵌入验证码 65编写单机验证码刷新register.ftl中的function reloadVerifyCode()
@Controller
public class MemberController &#123;
    //72后续工作 进行注入
    @Resource
    private MemberService memberService;

    @GetMapping(&quot;/register.html&quot;)
    public ModelAndView showRegister() &#123;
        return new ModelAndView(&quot;/register&quot;);
    &#125;

    //67. 验证码匹配比对 request拿到对象  68编写会员服务MemberService.java
    @PostMapping(&quot;/registe&quot;)
    @ResponseBody
    public Map registe(String vc, String username, String password, String nickname, HttpServletRequest request) &#123;
        //接收kaptchaController.java中的request.getSession().setAttribute响应
        //正确验证码
        String verityCode = (String) request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;);
        //验证码比对  后面的是大小写对比
        Map result = new HashMap();
        if (vc == null || verityCode == null || !vc.equalsIgnoreCase(verityCode)) &#123;
            result.put(&quot;code&quot;, &quot;VC01&quot;);
            result.put(&quot;msg&quot;, &quot;验证码错误&quot;);
        &#125; else &#123;
            //72.调用过程  73将登录页复制进去 74MemberServiceImpl
            try &#123;
                memberService.createMember(username, password, nickname);
                result.put(&quot;code&quot;, &quot;0&quot;);
                result.put(&quot;msg&quot;, &quot;success&quot;);
            &#125; catch (BussinessException ex) &#123;
                ex.printStackTrace();
                result.put(&quot;code&quot;, ex.getCode());
                result.put(&quot;msg&quot;, ex.getMsg());
            &#125;
        &#125;
        return result;
    &#125;
&#125;
http://localhost/register.html
</code></pre>
<h3 id="实现会员登录功能"><a href="#实现会员登录功能" class="headerlink" title="实现会员登录功能"></a>实现会员登录功能</h3><pre><code class="java"> com/imooc/reader/service/impl/MemberServiceImpl.java
 /**
     * 登陆检查
     * @param username 用户名
     * @param password 密码
     * @return 登录对象
     */
    //74.登录方法的接口实现 校验密码 75再续方法 MemberController.java
    public Member checkLogin(String username, String password) &#123;
        QueryWrapper&lt;Member&gt; queryWrapper = new QueryWrapper&lt;Member&gt;();
        queryWrapper.eq(&quot;username&quot;, username);
        Member member = memberMapper.selectOne(queryWrapper);
        if (member == null)&#123;
            throw new BussinessException(&quot;M02&quot;, &quot;用户不存在&quot;);
        &#125;//校验密码
        String md5 = MD5Utils.md5Digest(password, member.getSalt());
        if (!md5.equals(member.getPassword()))&#123;
            throw new BussinessException(&quot;M03&quot;, &quot;输入密码有误&quot;);
        &#125;
        return member;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
// 75.HttpSession session 登录校验后会将这个会员信息存放到session中
    // 76登录校验成功以后会返回一个member对象 存放在session中
    @PostMapping(&quot;/check_login&quot;) //前台url
    @ResponseBody
    public Map checkLogin(String username, String password, String vc, HttpSession session)&#123;
        //正确验证码                     ↓为了得到session对象
        String verityCode = (String)session.getAttribute(&quot;kaptchaVerifyCode&quot;);
        //验证码比对  后面的是大小写对比
        Map result = new HashMap();
        if (vc == null || verityCode == null || !vc.equalsIgnoreCase(verityCode)) &#123;
            result.put(&quot;code&quot;, &quot;VC01&quot;);
            result.put(&quot;msg&quot;, &quot;验证码错误&quot;);
        &#125;else &#123;
            try &#123;//处理成功
                Member member = memberService.checkLogin(username, password);
                //76.member存放在session中  77去index.ftl下方登录块改造
                session.setAttribute(&quot;loginMember&quot;,member);
                result.put(&quot;code&quot;, &quot;0&quot;);
                result.put(&quot;msg&quot;, &quot;success&quot;);
            &#125; catch (BussinessException ex) &#123; //处理失败
                ex.printStackTrace();
                result.put(&quot;code&quot;, ex.getCode());
                result.put(&quot;msg&quot;, ex.getMsg());
            &#125;
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">index.ftl 
&lt;#--   77.将获取到的member的session数据替换成登录右上角的动态数据--&gt;
  &lt;#--  两个问号代表前面的属性是存在的情况下输出其中的html --&gt;
&lt;#-- 78新增entity/MemberReadState.java会员阅读状态 --&gt;
        &lt;#if loginMember??&gt;
            &lt;h6 class=&quot;mt-1&quot;&gt;
                &lt;img style=&quot;width: 2rem;margin-top: -5px&quot; class=&quot;mr-1&quot; src=&quot;./images/user_icon.png&quot;&gt;$&#123;loginMember.nickname&#125;
            &lt;/h6&gt;
            &lt;#else&gt; &lt;#--上面是已登录 下面是未登录--&gt;
                &lt;a href=&quot;/login.html&quot; class=&quot;btn btn-light btn-sm&quot;&gt;
                    &lt;img style=&quot;width: 2rem;margin-top: -5px&quot; class=&quot;mr-1&quot; src=&quot;./images/user_icon.png&quot;&gt;登录
                &lt;/a&gt;
        &lt;/#if&gt;
</code></pre>
<h3 id="获取会员阅读状态"><a href="#获取会员阅读状态" class="headerlink" title="获取会员阅读状态"></a>获取会员阅读状态</h3><h5 id="实现会员交互功能"><a href="#实现会员交互功能" class="headerlink" title="实现会员交互功能"></a>实现会员交互功能</h5><ul>
<li>想看&#x2F;看过的阅读状态变更</li>
<li>为图书写短评</li>
<li>为喜欢的短评点赞</li>
</ul>
<pre><code class="java">com/imooc/reader/entity/MemberReadState.java
package com.imooc.reader.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;

import java.util.Date;

/**
 * 会员阅读状态实体
 */
//78.搞实体 再去创MemberReadStateMapper.java接口
public class MemberReadState &#123;
    @TableId(type = IdType.AUTO)
    private Long rsId;
    private Long bookId;
    private Long memberId;
    private Integer readState;
    private Date createTime;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/MemberReadStateMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.MemberReadState;

//78接口创完 再去搞个Member_Read_State.xml
public interface MemberReadStateMapper extends BaseMapper&lt;MemberReadState&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">mappers/member_read_state.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.MemberReadStateMapper&quot;&gt;
&lt;!--  78. 去MemberService 阅读状态--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/MemberService.java 
//78.获取阅读状态 再去实现这个方法

    /**
     * 获取阅读状态
     *
     * @param memberId 会员编号
     * @param bookId   图书编号
     * @return 阅读状态对象
     */
    public MemberReadState selectMemberReadState(Long memberId, Long bookId);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
 //78.新增方法实现那个方法 再去上方进行方法注入 79根据会员编号进行查询BookController

    /**
     * 获取阅读状态
     * @param memberId 会员编号
     * @param bookId 图书编号
     * @return 阅读状态对象
     */
    public MemberReadState selectMemberReadState(Long memberId, Long bookId)&#123;
        QueryWrapper&lt;MemberReadState&gt; queryWrapper = new QueryWrapper();
        queryWrapper.eq(&quot;book_id&quot;, bookId);
        queryWrapper.eq(&quot;member_id&quot;, memberId);
        MemberReadState memberReadState = memberReadStateMapper.selectOne(queryWrapper);
        return memberReadState;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
//51.进行页面的绑定 获取读书编号 52把所有ftl相对路径改成绝对路径 ./前面的.删掉
    //加上了./就是  localhost/book/......   删掉就是 localhost/......
    //52更改detail.ftl将静态页面改成动态页面
    @GetMapping(&quot;/book/&#123;id&#125;&quot;) //↓ 路径变量 和 上面的保持一致
    //79.新增一个参数 获取当前用户登录信息
    public ModelAndView showDetail(@PathVariable(&quot;id&quot;) Long id, HttpSession session) &#123;
        Book book = bookService.selectById(id);
        //56.写完并放入 mav.addObject 57得到了对象就要去detail.ftl渲染循环遍历[写短评下方的div]
        List&lt;Evaluation&gt; evaluationList = evaluationService.selectByBookId(id);
        //79.将之前设置的用户信息拿出来 两种情况 ①会员没登录就null ②会员登录了member对象存在了 注入memberService
        Member member = (Member)session.getAttribute(&quot;loginMember&quot;);
        ModelAndView mav = new ModelAndView(&quot;/detail&quot;);
        if (member != null) &#123; //获取会员阅读状态    会员编号 图书编号  80 detail.ftl想看[1]与看过[2] 页面上方找script块
            MemberReadState memberReadState = memberService.selectMemberReadState(member.getMemberId(), id);
            mav.addObject(&quot;memberReadState&quot;, memberReadState);

        &#125;
        mav.addObject(&quot;book&quot;, book);
        mav.addObject(&quot;evaluationList&quot;, evaluationList);
        return mav;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
 &lt;script&gt;
        $.fn.raty.defaults.path = &#39;/resources/raty/lib/images&#39;;
        $(function () &#123;
            $(&quot;.stars&quot;).raty(&#123;readOnly: true&#125;);
        &#125;)
       // 80 想看与看过 freemark脚本 如果它存在(想看/看过) 81产生对应的状态数据 MemberService
        $(function () &#123;
            &lt;#if memberReadState ??&gt;
            // 重选阅读状态回填
            $(&quot;*[data-read-state=&#39;$&#123;memberReadState.readState&#125;&#39;]&quot;).addClass(&quot;highlight&quot;);
            &lt;/#if&gt;
            &lt;#if !loginMember ??&gt;
                $(&quot;*[data-read-state]&quot;).click(function () &#123;
                    // 利用jquery选择div的对话框函数 显示需要登录
                    $(&quot;#exampleModalCenter&quot;).modal(&quot;show&quot;);
                &#125;)
            &lt;/#if&gt;
        &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="更新会员阅读状态"><a href="#更新会员阅读状态" class="headerlink" title="更新会员阅读状态"></a>更新会员阅读状态</h3><pre><code class="java">com/imooc/reader/service/MemberService.java
 /**
     * 更新阅读状态
     * @param memberId 会员编号
     * @param bookId 图书编号
     * @param readState 阅读状态
     * @return 阅读对象状态
     */         //81定义方法 MemberServiceImpl实现状态
    public MemberReadState updateMemberReadState(Long memberId, Long bookId, Integer readState);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
/**
 * 更新阅读状态
 * @param memberId 会员编号
 * @param bookId 图书编号
 * @param readState 阅读状态
 * @return 阅读对象状态
 */
//81.编写阅读状态代码 编写完打开MemberController
public MemberReadState updateMemberReadState(Long memberId, Long bookId, Integer readState)&#123;
    QueryWrapper&lt;MemberReadState&gt; queryWrapper = new QueryWrapper&lt;MemberReadState&gt;();
    queryWrapper.eq(&quot;book_id&quot;, bookId);
    queryWrapper.eq(&quot;member_id&quot;, memberId);
    MemberReadState memberReadState = memberReadStateMapper.selectOne(queryWrapper);
    //空的代表没有点过按钮 数据是空的
        //无则新增,有则更新
        if(memberReadState == null)&#123;
            memberReadState = new MemberReadState();
            memberReadState.setMemberId(memberId);
            memberReadState.setBookId(bookId);
            memberReadState.setReadState(readState);
            memberReadState.setCreateTime(new Date());
            memberReadStateMapper.insert(memberReadState);
        &#125;else&#123;
            memberReadState.setReadState(readState);
            memberReadStateMapper.updateById(memberReadState);
        &#125;

        return memberReadState;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
//81. 完成更新状态的事务  82去完成detail.ftl后面的loginMember存在的代码
    @PostMapping(&quot;/update_read_state&quot;)
    @ResponseBody
    public Map updateReadState(Long memberId, Long bookId, Integer readState)&#123;
        Map result = new HashMap();
        try &#123;
            memberService.updateMemberReadState(memberId, bookId, readState);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
//82 完成登录状态
            &lt;#if loginMember ??&gt;
            /**
             * 更新会员阅读状态
             */
            $(&quot;*[data-read-state]&quot;).click(function () &#123;
                //会员阅读状态
                var readState = $(this).data(&quot;read-state&quot;);
                //发送请求
                $.post(&quot;/update_read_state&quot;, &#123;
                    memberId: $&#123;loginMember.memberId&#125;,
                    bookId: $&#123;book.bookId&#125;,
                    readState: readState
                &#125;, function (json) &#123;
                    if (json.code == &quot;0&quot;) &#123; //服务器处理成功
                        $(&quot;*[data-read-state]&quot;).removeClass(&quot;highlight&quot;);//高亮的清除
                        $(&quot;*[data-read-state=&#39;&quot; + readState + &quot;&#39;]&quot;).addClass(&quot;highlight&quot;);//状态值放入其中
                    &#125;
                &#125;, &quot;json&quot;)
            &#125;);
            &lt;/#if&gt;
</code></pre>
<h3 id="实现写短评功能"><a href="#实现写短评功能" class="headerlink" title="实现写短评功能"></a>实现写短评功能</h3><pre><code class="java">detail.ftl
 //83.短评功能  下面短评联动现象
            $(&quot;#btnEvaluation&quot;).click(function () &#123;
                // 选中id＝score的标签 转换为星型组件
                $(&quot;#score&quot;).raty(&#123;&#125;);
                $(&quot;#dlgEvaluation&quot;).modal(&quot;show&quot;);//显示短评对话框
            &#125;)
---------------------------------------------------------------
&lt;!-- Modal --&gt;
&lt;div class=&quot;modal-content&quot;&gt;
            &lt;div class=&quot;modal-body&quot;&gt;
&lt;#-- 83. 短评联动   84 MemberService.java 短评实现代码 --&gt;
                &lt;h6&gt;为$&#123;book.bookName&#125;写短评&lt;/h6&gt;
                &lt;form id=&quot;frmEvaluation&quot;&gt;
                    &lt;div class=&quot;input-group  mt-2 &quot;&gt;
                        &lt;span id=&quot;score&quot;&gt;&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;input-group  mt-2 &quot;&gt;
                        &lt;input type=&quot;text&quot; id=&quot;content&quot; name=&quot;content&quot; class=&quot;form-control p-4&quot;
                               placeholder=&quot;这里输入短评&quot;&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;
            &lt;div class=&quot;modal-footer&quot;&gt;
                &lt;button type=&quot;button&quot; id=&quot;btnSubmit&quot; class=&quot;btn btn-primary&quot;&gt;提交&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/MemberService.java
//84.短评代码!  MemberServiceImpl 组一个全新的对象
    public Evaluation evaluate(Long memberId, Long bookId, Integer score, String content);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
/**
     * 发布新的短评
     * @param memberId 会员编号
     * @param bookId 图书编号
     * @param score 评分
     * @param content 短评内容
     * @return
     */ // 84 完成评论信息的更新 85在MemberController编写与web交互功能
    public Evaluation evaluate(Long memberId, Long bookId, Integer score, String content) &#123;
        Evaluation evaluation = new Evaluation();
        evaluation.setMemberId(memberId);
        evaluation.setBookId(bookId);
        evaluation.setScore(score);
        evaluation.setContent(content);
        evaluation.setCreateTime(new Date());
        evaluation.setState(&quot;enable&quot;);
        evaluation.setEnjoy(0); //注入evaluationMapper 完成数据新增
        evaluationMapper.insert(evaluation);
        return evaluation;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
//85.与web交互功能 前台请求传入数据 86回到detail.ftl写
    @PostMapping(&quot;/evaluate&quot;)
    @ResponseBody
    public Map evaluate(Long memberId, Long bookId, Integer score, String content)&#123;
        Map result = new HashMap();
        try &#123;
//    Evaluation eva = memberService.evaluate(memberId, bookId, score, content);
            memberService.evaluate(memberId, bookId, score, content);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
//          result.put(&quot;evaluation&quot;, eva);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
//86.评论对话框提交数据  87完成点赞核心实现 MemberService
            $(&quot;#btnSubmit&quot;).click(function () &#123;
                var score = $(&quot;#score&quot;).raty(&quot;score&quot;);//获取评分
                var content = $(&quot;#content&quot;).val();
                if (score == 0 || $.trim(content) == &quot;&quot;)&#123; //没有进行选择 或 删除前后空格
                    return; //禁止提交方法中断
                &#125;
                $.post(&quot;/evaluate&quot;,&#123;
                    score : score,
                    bookId: $&#123;book.bookId&#125;,
                    memberId: $&#123;loginMember.memberId&#125;,
                    content: content
                &#125;,function (json) &#123;
                    if (json.code == &quot;0&quot;) &#123;//处理成功
                        window.location.reload();//列表进行刷新
                    &#125;
                &#125;,&quot;json&quot;)
            &#125;)
</code></pre>
<h3 id="完成会员短评点赞核心实现"><a href="#完成会员短评点赞核心实现" class="headerlink" title="完成会员短评点赞核心实现"></a>完成会员短评点赞核心实现</h3><pre><code class="java">com/imooc/reader/service/MemberService.java
 /**
     * 短评点赞
     * @param evaluationId 短评编号
     * @return 短评对象
     */
//    87完成点赞核心实现 MemberServiceImpl
    public Evaluation enjoy(Long evaluationId);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
// 87.短评点赞 自增+1 Membercontroller
    public Evaluation enjoy(Long evaluationId) &#123;
        Evaluation evaluation = evaluationMapper.selectById(evaluationId);
        evaluation.setEnjoy(evaluation.getEnjoy()+1);
        evaluationMapper.updateById(evaluation);
        return evaluation;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
 //87.实现controller 88让客户端页面发送ajax请求
    @PostMapping(&quot;/enjoy&quot;)
    @ResponseBody
    public Map evaluate(Long evaluationId) &#123;
        Map result = new HashMap();
        try &#123;
//    Evaluation eva = memberService.evaluate(memberId, bookId, score, content);
            Evaluation eva = memberService.enjoy(evaluationId);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
            result.put(&quot;evaluation&quot;, eva); //包含最新点赞数
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
// 88.评论点赞
            $(&quot;*[data-evaluation-id]&quot;).click(function()&#123;
                var evaluationId = $(this).data(&quot;evaluation-id&quot;);
                $.post(&quot;/enjoy&quot;,&#123;evaluationId:evaluationId&#125;,function(json)&#123;
                    if(json.code == &quot;0&quot;)&#123;
                        $(&quot;*[data-evaluation-id=&#39;&quot; + evaluationId + &quot;&#39;] span&quot;).text(json.evaluation.enjoy);
                    &#125;
                &#125;,&quot;json&quot;)
            &#125;)
</code></pre>
<h3 id="Spring-Task定时任务-eg-闹钟命令"><a href="#Spring-Task定时任务-eg-闹钟命令" class="headerlink" title="Spring Task定时任务 [eg:  闹钟命令]"></a>Spring Task定时任务 [eg:  闹钟命令]</h3><ul>
<li>Spting Task 是 Spring 3.0后推出的定时任务模块</li>
<li>Spring Task的职责是按周期后台自动执行任务</li>
<li>Spring Task可利用Cron表达式实现灵活的定时处理</li>
</ul>
<h5 id="Cron表达式实例"><a href="#Cron表达式实例" class="headerlink" title="Cron表达式实例"></a>Cron表达式实例</h5><table>
<thead>
<tr>
<th align="center">秒</th>
<th align="center">分</th>
<th align="center">小时</th>
<th align="center">日</th>
<th align="center">月</th>
<th align="center">星期</th>
<th align="center">年</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">0,30</td>
<td align="center">0-5</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">?</td>
<td align="center">2000</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">9-18</td>
<td align="center">?</td>
<td align="center">*</td>
<td align="center">WED</td>
<td align="center"></td>
</tr>
</tbody></table>
<h5 id="利用Spring-Task自动计算图书评分-所有图书评价信息重算"><a href="#利用Spring-Task自动计算图书评分-所有图书评价信息重算" class="headerlink" title="利用Spring-Task自动计算图书评分 [所有图书评价信息重算]"></a>利用Spring-Task自动计算图书评分 [所有图书评价信息重算]</h5><pre><code class="java">mappers/book.xml
&lt;!--    89.增加平均评分增加信息  增加接口BookMapper --&gt;
    &lt;update id=&quot;updateEvaluation&quot;&gt;
        update book b SET evaluation_score = (
            select ifnull(avg(score),0) from evaluation where book_id = b.book_id and state=&#39;enable&#39;
        ),evaluation_quantity = (
            select ifnull(count(*),0) from evaluation where book_id = b.book_id and state=&#39;enable&#39;
        )
    &lt;/update&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/BookMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Book;
//33.创建完Book接口  34与之对应的创建book.xml文件
//89. 更新图书评分  BookService去定义
public interface BookMapper extends BaseMapper&lt;Book&gt; &#123;
    /**
     * 更新图书评分/评价数量
     */
    public void updateEvaluation();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
 /**
     * 更新图书评分/评价数量
     */
    //89. 定义完去impl定义实现类
    public void updateEvaluation();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
/**
     * 更新图书评分/评价数量  Controller直接面向Service Service面向Mapper
     */
    //89. 更新操作需要声明式事务 开启  90applicationContext.xml开启task
    @Transactional
    public void updateEvaluation() &#123;
        bookMapper.updateEvaluation();
    &#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;!--  61.配置Kaptcha 的bean  62创造KaptchaController.java--&gt;
    &lt;bean id=&quot;KaptchaProducer&quot; class=&quot;com.google.code.kaptcha.impl.DefaultKaptcha&quot;&gt;
        &lt;property name=&quot;config&quot;&gt;
            &lt;bean class=&quot;com.google.code.kaptcha.util.Config&quot;&gt;
                &lt;constructor-arg&gt;
                    &lt;props&gt;
                        &lt;!-- 验证码图片不生成边框 --&gt;
                        &lt;prop key=&quot;kaptcha.border&quot;&gt;no&lt;/prop&gt;
                        &lt;!-- 验证码图片宽度为120像素  --&gt;
                        &lt;prop key=&quot;kaptcha.image.width&quot;&gt;120&lt;/prop&gt;
                        &lt;!-- 验证码图片字体颜色为蓝色  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.color&quot;&gt;blue&lt;/prop&gt;
                        &lt;!-- 每个字符最大占用40像素  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.size&quot;&gt;40&lt;/prop&gt;
                        &lt;!-- 验证码包含4个字符  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.char.length&quot;&gt;4&lt;/prop&gt;
                    &lt;/props&gt;
                &lt;/constructor-arg&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 90.开启Spring Task定时任务的注解模式 创建一个reader/task/ComputeTask.java--&gt;
    &lt;task:annotation-driven/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/task/ComputeTask.java
package com.imooc.reader.task;

import com.imooc.reader.service.BookService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

//90.组件注解 不确定是哪个类 但是会被扫描实例化和管理
@Component
public class ComputeTask &#123;
    @Resource
    private BookService bookService;
//  每分钟0秒时候 执行一次Cron表达式
    @Scheduled(cron = &quot;0 * * * * ?&quot;)
    public void updateEvaluation()&#123;
        bookService.updateEvaluation();
        System.out.println(&quot;已更新所有图书评分&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="后台管理功能-图书管理"><a href="#后台管理功能-图书管理" class="headerlink" title="后台管理功能-图书管理"></a>后台管理功能-图书管理</h3><h5 id="富文本编辑器wangEditor使用入门"><a href="#富文本编辑器wangEditor使用入门" class="headerlink" title="富文本编辑器wangEditor使用入门"></a>富文本编辑器<code>wangEditor</code>使用入门</h5><ul>
<li>基于Javascript与css开发的Web富文本编辑器</li>
</ul>
<pre><code class="java">test.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!-- 91.引入wangEditor  创建WEB-INF/ftl/management/book.ftl--&gt;
    &lt;script src=&quot;/resources/wangEditor.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
    &lt;button id=&quot;btnRead&quot;&gt;读取内容&lt;/button&gt;
    &lt;button id=&quot;btnWrite&quot;&gt;写入内容&lt;/button&gt;
&lt;/div&gt;
&lt;div id=&quot;divEditor&quot; style=&quot;width: 800px;height:600px&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var E = window.wangEditor;
    var editor = new E(&quot;#divEditor&quot;);//完成富文本编辑器初始化
    editor.create();//创建富文本编辑器,显示在页面上
    document.getElementById(&quot;btnRead&quot;).onclick = function()&#123;
        var content = editor.txt.html();//获取编辑器现有的html内容
        alert(content);
    &#125;
    document.getElementById(&quot;btnWrite&quot;).onclick = function()&#123;
        var content = &quot;&lt;li style=&#39;color:red&#39;&gt;我是&lt;b&gt;新内容&lt;/b&gt;&lt;/li&gt;&quot;;
        editor.txt.html(content);
    &#125;
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="实现图书管理功能"><a href="#实现图书管理功能" class="headerlink" title="实现图书管理功能"></a>实现图书管理功能</h3><h6 id="在训练素材中导入图书管理页"><a href="#在训练素材中导入图书管理页" class="headerlink" title="在训练素材中导入图书管理页"></a>在训练素材中导入图书管理页</h6><pre><code class="java">book.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;#-- 91.创建后台图书管理控制器com/imooc/reader/controller/management/MBookController.java   --&gt;
    &lt;title&gt;图书管理功能&lt;/title&gt;
    &lt;style&gt;
        #dlgBook&#123;
            padding: 10px
        &#125;
    &lt;/style&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;

    &lt;script src=&quot;/resources/wangEditor.min.js&quot;&gt;&lt;/script&gt;


    &lt;script type=&quot;text/html&quot; id=&quot;toolbar&quot;&gt;
        &lt;div class=&quot;layui-btn-container&quot;&gt;
            &lt;button class=&quot;layui-btn layui-btn-sm&quot; id=&quot;btnAdd&quot; onclick=&quot;showCreate()&quot;&gt;添加&lt;/button&gt;
        &lt;/div&gt;
    &lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;


&lt;div class=&quot;layui-container&quot;&gt;
    &lt;blockquote class=&quot;layui-elem-quote&quot;&gt;图书列表&lt;/blockquote&gt;
    &lt;!-- 数据表格 --&gt;
    &lt;table id=&quot;grdBook&quot; lay-filter=&quot;grdBook&quot;&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;!--表单内容--&gt;
&lt;div id=&quot;dialog&quot; style=&quot;padding: 10px;display: none&quot;&gt;
    &lt;form class=&quot;layui-form&quot; &gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 图书类别 --&gt;
            &lt;select id=&quot;categoryId&quot; name=&quot;categoryId&quot; lay-verify=&quot;required&quot; lay-filter=
            &quot;categoryId&quot;&gt;
                &lt;option value=&quot;&quot;&gt;&lt;/option&gt;
                &lt;option value=&quot;1&quot;&gt;前端&lt;/option&gt;
                &lt;option value=&quot;2&quot;&gt;后端&lt;/option&gt;
                &lt;option value=&quot;3&quot;&gt;测试&lt;/option&gt;
                &lt;option value=&quot;4&quot;&gt;产品&lt;/option&gt;
            &lt;/select&gt;

        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 书名 --&gt;
            &lt;input type=&quot;text&quot; id=&quot;bookName&quot; name=&quot;bookName&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入书名&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;


        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 子标题 --&gt;
            &lt;input type=&quot;text&quot; id=&quot;subTitle&quot; name=&quot;subTitle&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入子标题&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;

        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 作者 --&gt;
            &lt;input type=&quot;text&quot; id=&quot;author&quot; name=&quot;author&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入作者信息&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;

        &lt;div style=&quot;margin-top: 30px;font-size: 130%&quot;&gt;图书介绍(默认第一图将作为图书封面)&lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot; &gt;
            &lt;!-- wangEditor编辑器 --&gt;
            &lt;div id=&quot;editor&quot; style=&quot;width: 100%&quot;&gt;

            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 图书编号 --&gt;
        &lt;input id=&quot;bookId&quot; type=&quot;hidden&quot;&gt;
        &lt;!-- 当前表单操作类型,create代表新增 update代表修改 --&gt;
        &lt;input id=&quot;optype&quot;  type=&quot;hidden&quot;&gt;
        &lt;div class=&quot;layui-form-item&quot; style=&quot;text-align: center&quot;&gt;
            &lt;!-- 提交按钮 --&gt;
            &lt;button class=&quot;layui-btn&quot; lay-submit=&quot;&quot; lay-filter=&quot;btnSubmit&quot;&gt;立即提交&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;

    var table = layui.table; //table数据表格对象
    var $ = layui.$; //jQuery
    var editor = null; //wangEditor富文本编辑器对象
    //初始化图书列表
    table.render(&#123;
        elem: &#39;#grdBook&#39;  //指定div
        , id : &quot;bookList&quot; //数据表格id
        , toolbar: &quot;#toolbar&quot; //指定工具栏,包含新增添加
        , url: &quot;/management/book/list&quot; //数据接口
        , page: true //开启分页
        , cols: [[ //表头
            &#123;field: &#39;bookName&#39;, title: &#39;书名&#39;, width: &#39;300&#39;&#125;
            , &#123;field: &#39;subTitle&#39;, title: &#39;子标题&#39;, width: &#39;200&#39;&#125;
            , &#123;field: &#39;author&#39;, title: &#39;作者&#39;, width: &#39;200&#39;&#125;
            , &#123;type: &#39;space&#39;, title: &#39;操作&#39;, width: &#39;200&#39; , templet : function(d)&#123;
                    //为每一行表格数据生成&quot;修改&quot;与&quot;删除&quot;按钮,并附加data-id属性代表图书编号
                    return &quot;&lt;button class=&#39;layui-btn layui-btn-sm btn-update&#39;  data-id=&#39;&quot; + d.bookId + &quot;&#39; data-type=&#39;update&#39; onclick=&#39;showUpdate(this)&#39;&gt;修改&lt;/button&gt;&quot; +
                        &quot;&lt;button class=&#39;layui-btn layui-btn-sm btn-delete&#39;  data-id=&#39;&quot; + d.bookId + &quot;&#39;   onclick=&#39;showDelete(this)&#39;&gt;删除&lt;/button&gt;&quot;;
                &#125;
            &#125;
        ]]
    &#125;);
    //显示更新图书对话框
    //obj对应点击的&quot;修改&quot;按钮对象
    function showUpdate(obj)&#123;
        //弹出&quot;编辑图书&quot;对话框
        layui.layer.open(&#123;
            id: &quot;dlgBook&quot;, //指定div
            title: &quot;编辑图书&quot;, //标题
            type: 1, 
            content: $(&#39;#dialog&#39;).html(), //设置对话框内容,复制自dialog DIV
            area: [&#39;820px&#39;, &#39;730px&#39;], //设置对话框宽度高度
            resize: false //是否允许调整尺寸
        &#125;)

        var bookId = $(obj).data(&quot;id&quot;); //获取&quot;修改&quot;按钮附带的图书编号
        $(&quot;#dlgBook #bookId&quot;).val(bookId); //为表单隐藏域赋值,提交表单时用到

        editor = new wangEditor(&#39;#dlgBook #editor&#39;); //初始化富文本编辑器
        editor.customConfig.uploadImgServer = &#39;/management/book/upload&#39; //设置图片上传路径
        editor.customConfig.uploadFileName = &#39;img&#39;; //图片上传时的参数名
        editor.create(); //创建wangEditor
        $(&quot;#dlgBook #optype&quot;).val(&quot;update&quot;); //设置当前表单提交时提交至&quot;update&quot;更新地址

        //发送ajax请求,获取对应图书信息
        $.get(&quot;/management/book/id/&quot; + bookId , &#123;&#125; , function(json)&#123;
            //文本框回填已有数据
            $(&quot;#dlgBook #bookName&quot;).val(json.data.bookName);//书名
            $(&quot;#dlgBook #subTitle&quot;).val(json.data.subTitle); //子标题
            $(&quot;#dlgBook #author&quot;).val(json.data.author);//作者
            $(&quot;#dlgBook #categoryId&quot;).val(json.data.categoryId); //分类选项
            editor.txt.html(json.data.description); //设置图文内容
            layui.form.render();//重新渲染LayUI表单
        &#125; , &quot;json&quot;)



    &#125;
    //显示新增图书对话框
    function showCreate()&#123;
        //弹出&quot;新增图书&quot;对话框
        layui.layer.open(&#123;
            id: &quot;dlgBook&quot;,
            title: &quot;新增图书&quot;,
            type: 1,
            content: $(&#39;#dialog&#39;).html(),
            area: [&#39;820px&#39;, &#39;730px&#39;],
            resize: false
        &#125;)
        //初始化wangEditor
        editor = new wangEditor(&#39;#dlgBook #editor&#39;);
        editor.customConfig.uploadImgServer = &#39;/management/book/upload&#39;;//设置图片上传地址
        editor.customConfig.uploadFileName = &#39;img&#39;;//设置图片上传参数
        editor.create();//创建wangEditor

        layui.form.render(); //LayUI表单重新
        $(&quot;#dlgBook #optype&quot;).val(&quot;create&quot;);//设置当前表单提交时提交至&quot;create&quot;新增地址

    &#125;;

    //对话框表单提交
    layui.form.on(&#39;submit(btnSubmit)&#39;, function(data)&#123;
        //获取表单数据
        var formData = data.field;
        
        //判断是否包含至少一副图片,默认第一图作为封面显示
        var description = editor.txt.html();
        if(description.indexOf(&quot;img&quot;) == -1)&#123;
            layui.layer.msg(&#39;请放置一副图片作为封面&#39;);
            return false;
        &#125;
        //获取当前表单要提交的地址
        //如果是新增数据则提交至create
        //如果是更新数据则提交至update
        var optype = $(&quot;#dlgBook #optype&quot;).val();
        
        if(optype == &quot;update&quot;)&#123;
            //更新数据时,提交时需要附加图书编号
            formData.bookId=$(&quot;#dlgBook #bookId&quot;).val();
        &#125;
        //附加图书详细描述的图文html
        formData.description = description;
        //向服务器发送请求
        $.post(&quot;/management/book/&quot; + optype , formData , function(json)&#123;
            if(json.code==&quot;0&quot;)&#123;
                //处理成功,关闭对话框,刷新列表,提示操作成功
                layui.layer.closeAll();
                table.reload(&#39;bookList&#39;);
                layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
            &#125;else&#123;
                //处理失败,提示错误信息
                layui.layer.msg(json.msg);
            &#125;
        &#125; ,&quot;json&quot;)
        return false;
    &#125;);
    //删除图书
    function showDelete(obj)&#123;
        //获取当前点击的删除按钮中包含的图书编号
        var bookId = $(obj).data(&quot;id&quot;);
        //利用layui的询问对话框进行确认
        layui.layer.confirm(&#39;确定要执行删除操作吗?&#39;, &#123;icon: 3, title:&#39;提示&#39;&#125;, function(index)&#123;
                    
                //确认按钮后发送ajax请求,包含图书编号
                $.get(&quot;/management/book/delete/&quot; + bookId, &#123;&#125;, function (json) &#123;
                    if(json.code==&quot;0&quot;)&#123;
                        //删除成功刷新表格
                        table.reload(&#39;bookList&#39;);
                        //提示操作成功
                        layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
                        //关闭对话框
                        layui.layer.close(index);
                    &#125;else&#123;
                        //处理失败,提示错误信息
                        layui.layer.msg(json.msg);
                    &#125;
                &#125;, &quot;json&quot;);
            
        &#125;);

    &#125;

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
package com.imooc.reader.controller.management;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

//http://localhost/management/book/index.html
//91.后台管理系统 编写富文本编辑器的图片上传功能book.ftl已全实现
//editor.customConfig.uploadImgServer = &#39;/management/book/upload&#39;;//设置图片上传地址
//92提供文件上传地址的接口 pom.xml增加文件上传依赖 apache
@Controller
@RequestMapping(&quot;/management/book&quot;)
public class MBookController &#123;
    @GetMapping(&quot;/index.html&quot;)
    public ModelAndView showBook()&#123;
        return new ModelAndView(&quot;/management/book&quot;);
    &#125;

    /**
     * wangEditor文件上传
     * @param file 上传文件
     * @param request 原生请求对象
     * @return
     * @throws IOException
     */
    //93. 接收提交的文件 上传的文件保存到upload目录中 代码编写
    @PostMapping(&quot;/upload&quot;)
    @ResponseBody
    public Map upload(@RequestParam(&quot;img&quot;) MultipartFile file, HttpServletRequest request) throws IOException &#123;
        //得到上传目录
        String uploadPath = request.getServletContext().getResource(&quot;/&quot;).getPath() + &quot;/upload/&quot;;//在out里 运行时执行获取路径
        //文件名
        String fileName = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;).format(new Date());
        //原始文件扩展名
        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;));//最后一次获得点
        //保存文件到upload目录
        file.transferTo(new File(uploadPath + fileName + suffix));
        Map result = new HashMap();
        result.put(&quot;errno&quot;, 0);
        result.put(&quot;data&quot;, new String[]&#123;&quot;/upload/&quot; + fileName + suffix&#125;);
        return result;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;!-- 92.增加文件上传依赖 SpringMVC文件上传底层依赖 93去applicationContext.xml激活--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
            &lt;version&gt;1.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--  93.激活文件上传功能 回到MBookController--&gt;
    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
 /**
     * wangEditor文件上传
     * @param file 上传文件
     * @param request 原生请求对象
     * @return
     * @throws IOException
     */
    //93. 接收提交的文件 上传的文件保存到upload目录中 代码编写 94book.ftl对话框表单提交
    @PostMapping(&quot;/upload&quot;)
    @ResponseBody
    public Map upload(@RequestParam(&quot;img&quot;) MultipartFile file, HttpServletRequest request) throws IOException &#123;
        //得到上传目录
        String uploadPath = request.getServletContext().getResource(&quot;/&quot;).getPath() + &quot;/upload/&quot;;//在out里 运行时执行获取路径
        //文件名
        String fileName = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;).format(new Date());
        //原始文件扩展名
        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;));//最后一次获得点
        //保存文件到upload目录
        file.transferTo(new File(uploadPath + fileName + suffix));
        Map result = new HashMap();
        result.put(&quot;errno&quot;, 0);
        result.put(&quot;data&quot;, new String[]&#123;&quot;/upload/&quot; + fileName + suffix&#125;);
        return result;
    &#125;
</code></pre>
<h3 id="实现图书新增功能"><a href="#实现图书新增功能" class="headerlink" title="实现图书新增功能"></a>实现图书新增功能</h3><pre><code class="java">book.ftl
// 94.对话框表单提交 95增加全新方法声明BookService
    layui.form.on(&#39;submit(btnSubmit)&#39;, function(data)&#123;
        //获取表单数据
        var formData = data.field;
        
        //判断是否包含至少一副图片,默认第一图作为封面显示
        var description = editor.txt.html();
        if(description.indexOf(&quot;img&quot;) == -1)&#123;
            layui.layer.msg(&#39;请放置一副图片作为封面&#39;);
            return false;
        &#125;
        //获取当前表单要提交的地址
        //如果是新增数据则提交至create
        //如果是更新数据则提交至update
        var optype = $(&quot;#dlgBook #optype&quot;).val();
        
        if(optype == &quot;update&quot;)&#123;
            //更新数据时,提交时需要附加图书编号
            formData.bookId=$(&quot;#dlgBook #bookId&quot;).val();
        &#125;
        //附加图书详细描述的图文html
        formData.description = description;
        //向服务器发送请求
        $.post(&quot;/management/book/&quot; + optype , formData , function(json)&#123;
            if(json.code==&quot;0&quot;)&#123;
                //处理成功,关闭对话框,刷新列表,提示操作成功
                layui.layer.closeAll();
                table.reload(&#39;bookList&#39;);
                layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
            &#125;else&#123;
                //处理失败,提示错误信息
                layui.layer.msg(json.msg);
            &#125;
        &#125; ,&quot;json&quot;)
        return false;
    &#125;);
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
 //95.创建新的图书 BookServiceImpl
    public Book createBook(Book book);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
 //95.数据增加 MBookController
    @Transactional
    public Book createBook(Book book) &#123;
        bookMapper.insert(book);
        return book;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
//95.获取书籍数据
    @PostMapping(&quot;/create&quot;)
    @ResponseBody
    public Map createBook(Book book)&#123;
        Map result = new HashMap();
        try &#123;
            book.setEvaluationQuantity(0);
            book.setEvaluationScore(0f);
            Document doc = Jsoup.parse(book.getDescription()); //一个个片段被解析
            Element img = doc.select(&quot;img&quot;).first();//选中所有标签提取第一个 获取图书详情第一图的元素对象
            String cover = img.attr(&quot;src&quot;);//获取当前元素指定值
            book.setCover(cover); //95.来自于description描述的第一幅图
            //用html解析器jsoup.jorg从前台的描述里截取图片位置 96加入依赖
            bookService.createBook(book); //此处可以打点debug
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<h3 id="实现图书分页查询-显示图书列表"><a href="#实现图书分页查询-显示图书列表" class="headerlink" title="实现图书分页查询[显示图书列表]"></a>实现图书分页查询[显示图书列表]</h3><pre><code class="java">com/imooc/reader/controller/management/MBookController.java
 //96.设计列表显示加载 97回到book.ftl
    @GetMapping(&quot;/list&quot;)
    @ResponseBody
    public Map list(Integer page, Integer limit)&#123;
        if (page == null)&#123;
            page = 1;
        &#125;
        if (limit == null)&#123;
            limit = 10;
        &#125;
        IPage&lt;Book&gt; pageObject = bookService.paging(null, null, page, limit);//返回paging的分页对象
        Map result = new HashMap();
        result.put(&quot;code&quot;, &quot;0&quot;);
        result.put(&quot;msg&quot;, &quot;success&quot;);
        //layUI返回值必须要求写的
        result.put(&quot;data&quot;, pageObject.getRecords()); //当前页面数据
        result.put(&quot;count&quot;, pageObject.getTotal()); //未分页时记录总数
        return result;
    &#125;
</code></pre>
<h3 id="实现图书修改更新功能-原有数据调整-回填数据"><a href="#实现图书修改更新功能-原有数据调整-回填数据" class="headerlink" title="实现图书修改更新功能 [原有数据调整 回填数据]"></a>实现图书修改更新功能 [原有数据调整 回填数据]</h3><pre><code class="java">book.ftl
// 94.对话框表单提交 95增加全新方法声明BookService
    layui.form.on(&#39;submit(btnSubmit)&#39;, function(data)&#123;
        //获取表单数据
        var formData = data.field;
        
        //判断是否包含至少一副图片,默认第一图作为封面显示
        var description = editor.txt.html();
        if(description.indexOf(&quot;img&quot;) == -1)&#123;
            layui.layer.msg(&#39;请放置一副图片作为封面&#39;);
            return false;
        &#125;
        //获取当前表单要提交的地址
        //如果是新增数据则提交至create
        //如果是更新数据则提交至update
        var optype = $(&quot;#dlgBook #optype&quot;).val();
     // 97.从隐藏域拿数据   98 MBookController
        if(optype == &quot;update&quot;)&#123;
            //更新数据时,提交时需要附加图书编号
            formData.bookId=$(&quot;#dlgBook #bookId&quot;).val();
        &#125;
        //附加图书详细描述的图文html
        formData.description = description;
        //向服务器发送请求
        $.post(&quot;/management/book/&quot; + optype , formData , function(json)&#123;
            if(json.code==&quot;0&quot;)&#123;
                //处理成功,关闭对话框,刷新列表,提示操作成功
                layui.layer.closeAll();
                table.reload(&#39;bookList&#39;);
                layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
            &#125;else&#123;
                //处理失败,提示错误信息
                layui.layer.msg(json.msg);
            &#125;
        &#125; ,&quot;json&quot;)
        return false;
    &#125;);
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
//98 前台ajax发送的格式保持一致 /managemet/book/id/ + bookId
    @GetMapping(&quot;/id/&#123;id&#125;&quot;)
    @ResponseBody
    public Map selectById(@PathVariable(&quot;id&quot;) Long bookId) &#123;
        Book book = bookService.selectById(bookId);
        Map result = new HashMap();
        result.put(&quot;code&quot;, &quot;0&quot;);
        result.put(&quot;msg&quot;, &quot;success&quot;);
        result.put(&quot;data&quot;, book); //服务器返回json.data book.ftl132行
        return result;
        //99 点击修改后的确认提交 增添更新操作 BookService.java
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
/**
     * 更新图书
     * @param book 新图书数据
     * @return 更新后的数据
     */
    //99.创建新的更新 BookServiceImpl
    public Book updateBook(Book book);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
/**
     * 更新图书
     * @param book 新图书数据
     * @return 更新后的数据
     */
    //99.更新数据 100 MBookController
    @Transactional
    public Book updateBook(Book book) &#123;
        bookMapper.updateById(book);
        return null;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
    /**
     * 更新图书数据
     * @param book
     * @return
     */
    //100. 更新代码 不要轻易对Book book数据直接更新 根据传入的book编号把数据库记录查出来
//101 删除方法BookService
    @PostMapping(&quot;/update&quot;)
    @ResponseBody
    public Map updateBook(Book book)&#123;
        Map result = new HashMap();
        try &#123;
            Book rawBook = bookService.selectById(book.getBookId());
            //通过前台数据获取
            rawBook.setBookName(book.getBookName());
            rawBook.setSubTitle(book.getSubTitle());
            rawBook.setAuthor(book.getAuthor());
            rawBook.setCategoryId(book.getCategoryId());
            rawBook.setDescription(book.getDescription());
            Document doc = Jsoup.parse(book.getDescription());
            String cover = doc.select(&quot;img&quot;).first().attr(&quot;src&quot;);
            rawBook.setCover(cover);
            bookService.updateBook(rawBook);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode()); ///成功时
            result.put(&quot;msg&quot;, ex.getMsg());//失败时
        &#125;
        return result;
    &#125;
</code></pre>
<h3 id="实现图书删除功能"><a href="#实现图书删除功能" class="headerlink" title="实现图书删除功能"></a>实现图书删除功能</h3><p><a target="_blank" rel="noopener" href="http://localhost/management/book/index.html">http://localhost/management/book/index.html</a><br><a target="_blank" rel="noopener" href="http://localhost/">http://localhost/</a></p>
<pre><code class="java">com/imooc/reader/service/BookService.java
 //101.删除方法 BookServiceImpl
    public void deleteBook(Long book);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
//101.删除相关数据 上面增加memberReadStateMapper evaluationMapper
    //一次性三个表删除 有声明式事务不会删一半 102 MBookController.java
    /**
     * 删除图书及其数据
     * @param bookId 图书编号
     */
    @Transactional
    public void deleteBook(Long bookId) &#123;
        bookMapper.deleteById(bookId);//单独删除id效率太低 写个构造器
        QueryWrapper&lt;MemberReadState&gt; mrsQueryWrapper = new QueryWrapper&lt;MemberReadState&gt;();
        mrsQueryWrapper.eq(&quot;book_id&quot;, bookId);
        memberReadStateMapper.delete(mrsQueryWrapper);
        QueryWrapper&lt;Evaluation&gt; evaluationQueryWrapper = new QueryWrapper&lt;Evaluation&gt;();
        evaluationQueryWrapper.eq(&quot;book_id&quot;, bookId);
        evaluationMapper.delete(evaluationQueryWrapper);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
//102. 封装 以及 code输出  103加入后台首页=&gt;index.ftl 后增加ManagementController
    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)
    @ResponseBody
    public Map deleteBook(@PathVariable(&quot;id&quot;) Long bookId) &#123;
        Map result = new HashMap();
        try &#123;
            bookService.deleteBook(bookId);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode()); ///成功时
            result.put(&quot;msg&quot;, ex.getMsg());//失败时
        &#125;
        return result;
    &#125;
</code></pre>
<h5 id="增加后台框架"><a href="#增加后台框架" class="headerlink" title="增加后台框架"></a>增加后台框架</h5><p><a target="_blank" rel="noopener" href="http://localhost/management/index.html">慕课书评网数据管理系统</a></p>
<pre><code class="java">com/imooc/reader/controller/management/ManagementController.java
package com.imooc.reader.controller.management;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
//103.后台管理系统控制器 104 修改index.ftl的静态地址
/**
 * 后台管理系统控制器
 */
@Controller
@RequestMapping(&quot;/management&quot;) //功能启动后台所需
public class ManagementController &#123;
    @GetMapping(&quot;/index.html&quot;)
    public ModelAndView showIndex()&#123;
        return new ModelAndView(&quot;/management/index&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">index.ftl

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;慕课书评网数据管理系统&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课书评网数据管理系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    admin
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;/management/logout&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;


                    &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                        &lt;a href=&quot;javascript:void(0)&quot;&gt;数据管理&lt;/a&gt;
                        &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;xxx&quot;&gt;
&lt;#--       104.静态地址改为动态地址--&gt;
                            &lt;dd&gt;&lt;a href=&quot;/management/book/index.html&quot; target=&quot;ifmMain&quot;&gt;图书管理&lt;/a&gt;&lt;/dd&gt;
                            &lt;dd&gt;&lt;a href=&quot;短评管理.html&quot; target=&quot;ifmMain&quot;&gt;短评管理
                                &lt;/a&gt;&lt;/dd&gt;
                        &lt;/dl&gt;
                    &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot; src=&quot;/management/book/index.html&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;);
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/01/18/后端/SSM开发社交网站[Freemarker+Spring+SpringMVC+Mybatis(Plus)构成SSM+Bootstrap+Art-Template+Kaptcha+SpringTask+wangEditor]/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/01/16/软考/软件设计师刷题考点/">
        <h2>
            软件设计师刷题考点
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="计算机工作原理"><a href="#计算机工作原理" class="headerlink" title="计算机工作原理"></a>计算机工作原理</h2><p>@@ 如果”2x”的补码是”90H”, 那么x的真值是 <u><strong>-56</strong></u><br>90H 拆开根据8 4 2 1由十六进制转换为二进制：10010000；补码最高位为符号位, 1代表负号, 所以说明此数为<strong>负数</strong>，可以根据口诀直接得源码(注意符号位不变)：1111 0000 即 -112；故2X&#x3D;-112  X&#x3D;-56</p>
<p>@@ 计算机中CPU对其访问速度最快的是<u><strong>通用寄存器</strong></u><br>计算机系统中的CPU内部对通用寄存器的存取操作是速度最快的 其次是Cache 再次是内存 最慢的是作为外存的硬盘</p>
<p>@@ 属于CPU中算术逻辑单元的部位是**<u>加法器</u>**<br>控制单元部件：<strong>指</strong>令寄存器、<strong>程</strong>序计数器、地<strong>址</strong>寄存器、<strong>数</strong>据寄存器[紫橙子树]                                                                                                                                                                                                                                                                                                                                                                                                                                         加法器是算数逻辑运算单元的部件</p>
<p>@@ 在CPU中，常用来为ALU执行算数逻辑运算提供数据并暂存运算结果的寄存器是<strong>累加寄存器</strong>[是专门存放算术或逻辑运算的一个操作数和运算结果的寄存器(加 减 读出 移位)]</p>
<p>@@ 所谓定点数，就是表示数据时小数点的位置固定不变。<br>小数点的位置通常由两种约定方式：<br>①定点整数(纯整数, 小数点在最低有效数值位之后)<br>②定点小数(纯小数, 小数点在最高有效数值位之前)<br>当机器字长为n时, 定点数的补码和移码可表示$2^n$个数, 而其源码和反码只能表示$2^n-1$个数(0占用了两个编码), 所以定点数所能表示的数值范围比较小, 运算中很容易因结果超出范围而溢出<br>数的浮点表示的一般形式为：N&#x3D;F×$2^E$, 其中E称为阶码，F为尾数。<br>尾数部分F的位数越多↑，数的精度越高↑；指数部分E的位数越多↑，能表示的范围越大↑<br><strong>阶码</strong>通常为带符号的纯整数<br><strong>尾数</strong>为带符号的纯小数<br>在尾数用补码表示时，规格化浮点数应满足尾数最高数位与符号位不同<br>当<strong>1&#x2F;2 ≤ |F|＜ 1</strong>时，应有0.1xx…x形式；<br>当**-1 ≤ M ＜ -1&#x2F;2<strong>时，应有1.0xx…x形式<br>当</strong>M&#x3D;-1&#x2F;2**时，对于源码来说是规格化数，而对于补码来说不是规格化数</p>
<p>@@ <strong>寄存器</strong>既可以用来存放<u>数据</u>和<u>地址</u>，也可以存放<u>控制信息</u>或<u>CPU工作时的状态</u><br>在CPU中增加寄存器的数量，可以使CPU把执行程序时所需的数据尽可能地放在寄存器中，从而减少访问内存的次数，提高其运行速度</p>
<p>@@ 程序计数器(PC)用于存放<strong>下一条指令所在单元的地址</strong>的地方</p>
<p>@@ 计算机系统中采用补码来表示和运算数据，原因是采用补码可以<strong>简化计算机运算部件的设计</strong><br>使用补码表示数据时，可以将符号位和其他位统一处理，减法也可按加法来处理，从而简化运算部件的设计</p>
<p>@@ 为了使一个系统能检查和纠正一个差错，间码最小距离必须至少是3<br><strong>海明码</strong>是一种可以纠正一位差错的编码，是<u>利用奇偶性来检错和纠错的一种校验方法</u>；海明码的基本意思是給传输的数据增加r个校验位，从而增加两个合法消息的不同位的个数。海明码利用奇偶性进行<u>检错</u>和<u>纠错</u>；其码距最小为<u>2n+1</u> [海明校验码只有在代码中只存在一个错误的前提下，才能实现纠错 ]<br>**循环冗余校验码(CRC)**编码方法是在k位信息码后再拼接r位的校验码，形成长度位n位的编码，其特点是检错能力极强且开销小，用于<u>编码器</u>及<u>检测电路实现</u><br><strong>奇偶校验</strong>是由若干位有效信息，再加上1  一个二进制位(校验位)组成校验码；奇偶校验只能查错不能纠错，<u>只有奇数个数发生错误，才能发现错误</u>；若有奇数个数据位出错，则可以检测出该错误但无法纠正错误</p>
<p>@@ 冗余技术：<br>1.结构冗余，按其工作方法可以分位<strong>静态</strong>、<strong>动态</strong>和<strong>混合</strong>冗余<br>2.信息冗余，指的是为了<strong>检测</strong>或<strong>纠正</strong>信息在运算或传输中的错误另外附加的一部分信息<br>3.时间冗余，指的是以重复执行指令或程序来消除顺时错误带来的影响<br>4.冗余附件技术，指的是为实现上述冗余技术所需的资源和技术</p>
<p>@@ CPU依据<strong>指令周期的不同阶段</strong>来区分在内存中以二进制编码形式存放的指令和数据<br>指令周期是执行一条指令所需时间，一般由若干个机器周期组成，是从取指令、分析指令到执行完所需的全部时间</p>
<p>@@ 浮点数相加，对阶时，小数向大数看齐；对阶是通过较小数的尾数右移实现的。将小阶向大阶对齐，同时将尾数右移n位</p>
<p>@@ 在CPU的寄存器中，<strong>指令寄存器</strong>对用户是完全透明的</p>
<p>@@ 程序计数器是用于存放下一条指令所在单元的地址的地方</p>
<p>@@ 属于CPU中算数逻辑单元的部件是<strong>加法器</strong></p>
<p>@@ 高速缓存地址是为了高速缓存的读取和写入而使用的地址，在CPU和高速缓存之间进行数据传输时使用的；当CPU需要读取数据时，DMA控制器和中断CPU发出的数据地址是<strong>主存的物理地址</strong>[<u>中断向量</u>提供的是<strong>中断服务程序的入口地址</strong>]；硬盘的扇区地址是用于访问硬盘上指定扇区的地址，并不直接与CPU进行数据交互；虚拟地址，是指在操作系统中使用的地址，它需要通过地址映射和页表等机制转换为物理地址才能被CPU使用</p>
<p>@@ <strong>相联存储器</strong>是指<u>按内容访问</u>的存储器<br>按<strong>构成存储器</strong>的材料：磁存储器、半导体存储器、光存储器<br>按存储器的<strong>工作方式</strong>：读写存储器、只读存储器<br>按<strong>访问</strong>方式：按地址访问的存储器、按内容访问的存储器<br>按**[寻]地址**访问的存储器：随机存储器、顺序存储器、直接存储器</p>
<p>@@ ±0编码相同的是<strong>补码和移码</strong></p>
<p>@@ 计算机感染特洛伊木马后的典型现象是<strong>有未知程序试图建立网络连接</strong></p>
<p>@@ 再微型计算机中，管理键盘最适合采用的1&#x2F;0控制方式是<strong>中断方式</strong></p>
<p>@@ 在移臂调度算法中，<strong>先来先服务</strong>和<strong>最短寻找时间优先</strong>(<u>根据当前磁臂到要请求访问磁道的距离，誰短满足誰的请求</u>)算法可能会随时改变移动臂的运动方向</p>
<p>@@ 计算机中，系统总线用于<strong>CPU、主存及外设部件</strong>连接</p>
<p>@@ 双核是指<strong>在一个CPU中集成两个运算核心以提高运算能力</strong></p>
<p>@@ 已知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>对B进行反编译，不能还原出源程序A</strong></p>
<p>@@ 在程序执行过程中，Cache与主存的地址映射是由<strong>硬件自动</strong>完成的</p>
<p>@@ 计算机系统的主存主要是由<strong>DRAM</strong>构成的。<br>随机访问存储器(<strong>RAM</strong>)有两类：静态的(SRAM) 和 动态的(DRAM)</p>
<p>@@ 存储系统采用Cache技术的主要目的是提高存储器的访问速度，因此是由<strong>硬件自动完成</strong>Cache与主存之间的操作</p>
<p>@@ 主存与Cache的地址映射方式中，<strong>全相联</strong>方式可以实现主存任意一块装入Cache中任意位置，只有装满才需要替换<br><strong>全相联地址映射：</strong>主存的任意一块可以映射到Cache中的<strong>任意</strong>一块<br><strong>直接相联映射：</strong>主存中一块只能映射到到Cache的一个<strong>特定</strong>的块中<br><strong>组相联的映射：</strong>各区中的某一块只能存入缓存的同组号的空间内，但组内各块地址之间则可以任意存放。即从<strong>主存</strong>的组到Cache的组之间采用直接映像方式，在两个对应的<strong>组内部</strong>采用全相联映像方式</p>
<p>@@ 常用的虚拟存储器由<strong>主存-赋存</strong>两级存储器构成<br>虚拟存储技术使辅助存储器和主存储器密切配合。虚拟存储器的地址称为虚地址或逻辑地址  </p>
<p>@@ 虚拟存储体系由<strong>主存-赋存</strong>两级存储器构成<br>一般计算机系统中主要由两种存储体系：<br><u><strong>Cache存储体系</strong></u>由<strong>Cache</strong>和<strong>主存储器</strong>构成，主要目的是提高存储器速度，对系统程序员以上均透明<br><u><strong>虚拟存储体系</strong></u>由主存储器和在线磁盘存储器等辅存构成，主要目的是扩大存储器容量，对应用程序员透明</p>
<p>@@ Cache的地址映像方式中，发生块冲突次数最小的是<strong>全相联映像</strong><br>Cache的地址映射方法主要有三种：全相联地址映射、直接相联地址映射、组相联地址映射<br>**全相联地址映射 **[意味着主存的任意一块可以映射到Cache中的任意一块，特点：块冲突概率低，Cache空间利用率高，但相联目录表容量大导致成本高、查表速度慢]<br><strong>直接映像方式</strong> [指主存的每一块只能映像到Cache的一个特定的块中，整个Cache地址与主存地址的低位部分完全相同，其特点是硬件简单，不需要相联存储器，访问速度快，Cache块冲突概率高，Cache控件利用率低]<br><strong>组相联映射</strong> [是上面两种方法的这种处理]</p>
<p>@@ 计算机采用分级存储体系的主要目的是为了解决<strong>存储容量、成本和速度之间的矛盾</strong>问题<br>高速缓存一般用SRAM[速度快,成本高]<br>内存一般用DRAM[集成度高,动态刷新]<br>外存一般用磁存储器[速度慢,容量大,价格便宜]</p>
<p>@@ Cache的设计思想是在合理成本下提高命中率</p>
<p>@@ <strong>并行总线</strong>适合<strong>近距离高速数据传输</strong>、<strong>串行总线</strong>适合<strong>长距离数据传输</strong><br>在单总线结构中，CPU与主存之间、CPU与I&#x2F;O设备之间、I&#x2F;O设备与主存之间、各种设备之间都通过系统总线交换信息。单总线结构的优点是控制简单方便，扩充方便</p>
<p>@@ 总线：数(数据总线) 控(控制总线) 地(地址总线) ISA EISA PCI MCA<br>SCSI是一种用于计算机和智能设备之间系统级接口的独立处理器标准</p>
<p>@@ 总线复用方式可以<strong>减少总线中信号线的数量</strong><br>总线式一组能为多个部件分时共享的信息传送线，用来连接多个部件并为之提供信息交换通路，通过<strong>总线复用方式</strong><u>可以减少总线中信号线的数量，以较少的信号线传输更多的消息</u></p>
<p>@@ 在计算机系统中采用总线结构，便于实现系统的积木化结构，同时可以<strong>减少总线中信号线的数量</strong> </p>
<p>@@ <strong><u>直接主存存取</u></strong>(<strong>DMA</strong>)[Direct Memory Access]控制方式是在<strong>主存与外设</strong>之间直接建立数据通路进行数据的交换处理</p>
<p>@@ 在I&#x2F;O设备与主机间进行数据传输时，CPU只需在开始和结束时作少量处理，而无需干预数据传送过程的是<strong>直接存储器存取 [DMA]<strong>方式。[直接内存存取(Direct Memory Access)方式的基本思想是通过</strong>硬件控制</strong>实现<u><strong>主存</strong></u>与**<u>I&#x2F;O设备</u>**间的直接数据传送，数据的传递过程由DMA控制器进行控制，不需要CPU的干预。在DMA方式下由CPU启动传送过程，即向设备发出”传送一块数据”的命令，在传送过程结束时，DMAC通过中断方式通知CPU进行一些后续处理工作]</p>
<p>@@ 在微机系统中，BIOS(基本输入输出系统)保存在<strong>主板上的ROM</strong>中 [BIOS是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从<strong>CMOS</strong>中读写系统设置的具体信息]</p>
<p>@@ 计算机运行过程中，遇到突发事件，要求CPU暂时停止正在运行的程序，转去为突发事件服务，服务完毕，再自动返回原程序继续执行，这个过程成为<strong>中断</strong>，其处理过程中保存现场的目的是<strong>返回去继续执行原程序</strong></p>
<p>@@ CPU是再<strong>一个总线周期</strong>结束时响应DMA请求的 [DMA请求的检测点设置在每个机器周期也即总线周期结束时执行，这样使得总线利用率最高]</p>
<p>@@ 计算机中CPU的中断响应时间指的是<strong>从发出中断请求到开始进入中断处理程序</strong>的时间</p>
<p>@@ 中断向量可提供<strong>中断服务程序的入口地址</strong>[为了提高响应中断的速度，通常把所有<u>中断服务<strong>程序的入口地址</strong></u>[称中断向量]汇聚为<strong>中断向量表</strong>]</p>
<p>@@ 为了便于实现多级中断嵌套，使用<strong>堆栈</strong>来保护断点和现场最有效 【<u>实现中断嵌套<strong>后进先出</strong>的栈来保护断点和现场最有效(当系统中有多个中断请求时，中断系统按优先级进行排队。若在处理低级中断过程中又有高级中断申请中断，则高级中断可以打断低级中断处理，转去处理高级中断，等处理完高级中断后再返回去处理原来的低级中断，称为<strong>中断嵌套</strong>)</u>】</p>
<p>@@ <strong>由I&#x2F;O设备提出的中断请求是可屏蔽中断，电源掉电是不可屏蔽中断</strong><br>可将中断分为两大类：<br><strong>不可屏蔽中断</strong>(非屏蔽中断) 和 <strong>可屏蔽中断</strong><br><strong>不可屏蔽中断源</strong>[断电]一旦提出请求，CPU必须无条件响应，而对<strong>可屏蔽中断源</strong>[打印机中断(处于等待请求响应)]的请求，CPU可以响应，也可以不响应。</p>
<p>@@ 计算机在一个指令周期过程中，为从内存读取指令操作码，首先要将**程序计数器(PC)**的内容送到地址总线上<br>CPU首先从程序计数器获得需要执行的指令地址，从内存(或高速缓存)读取到的指令则暂存在指令寄存器(IR)，然后进行分析和执行</p>
<p><strong>程序计数器</strong>是PC用于存放下一条指令所在单元的地址的地方<br><strong>指令寄存器</strong>是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一套指令<br><strong>地址寄存器</strong>用来保存当前CPU所访问的内存单元的地址<br><strong>指令译码器</strong>从内存中取出一条指令经数据总线送往指令寄存器中</p>
<p>@@ 对于只有单条指令的情况下，流水线方式与顺序执行时没有区别的。流水线的原理是在某一时刻可以让多个部件同时处理多条指令，避免各部件等待空闲，由此提高了各部件的利用率，也提高了系统的吞吐率</p>
<p>@@ 流水线的吞吐率是指单位时间流水线处理机输出的结果的数目，因此流水线的吞吐率为一个流水级时间的倒数，即最长流水级时间的倒数</p>
<p>@@ CPU执行算术运算或者逻辑运算时，常将源操作数和结果暂存在<strong>累加器(AC)<strong>中<br>CPU中常设置多个寄存器，其中，<u><strong>程序计数器</strong>的作用是保存<em>待读取</em> 指令在内存中的地址</u>，</strong>累加器(AC)<strong>是算数逻辑运算单位中用来<u><strong>暂存</strong>源操作数</u>和<u>计算结果的寄存器</u>，</strong>指令寄存器</strong>暂存从内存读取的指令，<strong>地址寄存器</strong>暂存要访问的内存单元的地址。</p>
<p>@@ <strong>VLIW</strong>(Very Long Instruction Word, 超长指令字) 一种非常长的指令组合，它把许多条指令连在一起，增加了运算的速度</p>
<p>@@ 在机器指令的地址字段中，直接指出操作数本身的寻址方式称为<strong>立即寻址</strong>[是一种特殊的寻址方式 指令中在操作码字段后面的部分不是通常意义的操作数，而是操作数本身，也就是说数据就包含在指令中，只要取出指令，也就是去除了可以立即使用的操作数]</p>
<p>@@ 若CPU要执行的指令为：MOV R1，#45(即将数值45传递到寄存器R1中)，则该指令中采用的寻址方式是<strong>寄存器寻址和立即寻址</strong> [45是立即数，R1是寄存器]<br><strong>立即寻址：</strong>操作数就包含在指令中<br><strong>直接寻址：</strong>操作数存放在内存单元中，指令中直接給处操作数所在内存单元的地址<br><strong>寄存器寻址：</strong>操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名<br><strong>寄存器间接寻址：</strong>操作数存放在内存单元中，操作数所在存储单元的地址在某个寄存器中<br><strong>间接寻址：</strong>指令中给出操作数地址的地址<br><strong>相对寻址：</strong>指令地址码给出的是一个偏移量可正可负，操作数地址等于本条指令的地址加上该偏移量<br><strong>变址寻址：</strong>操作数地址等于变址寄存器的内容加偏移量</p>
<p>@@ CISC(Complex Instruction Set Computer)是<strong>复杂指令系统计算机</strong>的简称 其基本思想是：<u>进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬件化，导致机器的指令系统越来越庞大而复杂。CISC计算机一般所含的指令数目至少300条以上</u><br>RISC(Reduced  Instruction Set Computer <strong>精简指令集计算机</strong>) 其基本思想是：<u>通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用<strong>硬布线</strong>控制逻辑优化编译程序。</u> 通常会比CISC配置更多的寄存器、RISC编译器的子程序库通常要比CISC编译器的子程序库大很多、RISC比CISC更加适合VLSI工艺的规整性要求。</p>
<p>@@ Flynn分类法基于信息流特征将计算机分成4类，其中<strong>MISD</strong>只有理论意义而无实例<br>Flynn主要根据指令流和数据流来分类：<br>① 单指令流单数据流机器(SISD)<br>② 单指令流多数据流机器(SIMD)<br>③ 多指令流单数据流机器(MISD)[<strong>M</strong>ulti <strong>I</strong>nstruction <strong>S</strong>ingle <strong>D</strong>ata] [采用多个指令流来处理单个数据流 在实际情况中，采用多指令流处理多数据流才是最有效的方法，因此MISD<strong>只是作为理论模型出现，没有投入实际应用</strong>]<br>④ 多指令流多数据流机器(MIMD)</p>
<p>@@ 取指令时间4Δt，分析时间为2Δt，执行时间为3Δt，按顺序方式从头到尾执行完600条指令所需时间为<strong>5400</strong>Δt，使用流水线从头到尾执行完600条指令所需的时间为<strong>2405</strong>Δt [未说流水线就普通乘法计算 流水线则按公式计算]<br>① 指令顺序执行时，每条指令需要(4Δt+2Δt+3Δt)&#x3D;9Δt     9Δt×600&#x3D;5400Δt<br>② (4Δt+2Δt+3Δt) + (600-1) × 4 &#x3D; 2405Δt</p>
<p>@@ 指令系统中采用不同寻址方式的目的是<strong>扩大寻址控件并提高编程灵活性</strong></p>
<p>@@ 计算机指令一般包括操作码和地址码两部分，为分析执行一条指令，其<strong>操作码和地址吗都应存入指令寄存器(IR)</strong> [程序被加载到内存后开始运行，当CPU执行一条指令时，<u><strong>先把它从内存器取到缓冲寄存器DR中，再送入IR暂存</strong></u>，指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所有功能。]</p>
<p>@@ CPU产生每条指令的操作信号并将操作信号送往相应的部件进行控制、CPU中的控制器决定计算机运行过程的自动化、指令译码器是CPU控制器中的部件<br>CPU是计算机的控制中心，主要由运算器、控制器、寄存器组、和内部总线等部件组成。<br><strong>控制器</strong>由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成</p>
<p>@@ 可靠度串并联：串联系统可靠度为R1×R2，并联系统可靠度为R1&#x2F;R2&#x3D;1-(1-R)</p>
<p>@@ 计算机系统的<strong>可靠性</strong>可以用**MTBF &#x2F; (1+MTBF)**来度量，其中MTBF为平衡失效间隔时间 [又称平均无敌故障时间] 是衡量一个产品(尤其是电器产品)的可靠性指标，单位为”小时”</p>
<p>@@ 软件产品的可靠性并不取决于<strong>软件产品的开发方式</strong> 而取决于<strong>潜在的错误数量和位置，软件产品的使用方式</strong>；软件可靠性指的是一个系统对于给定的时间间隔内，在给定条件下**<u>无失效运作的概率</u>**。</p>
<p>@@ <u>软件<strong>可靠性</strong></u>是指一个系统在给定时间间隔内和给定条件下<strong>无失败运行的概率</strong>，一个软件系统能够按照规格说明正确运行的概率。<u>软件<strong>可维护性</strong></u>是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源<strong>完成维护活动的概率</strong></p>
<p>@@ <strong>应用级网关</strong>防火墙是内部网和外部网的隔离点，它可对应用层的通信数据流进行监控和过滤。应用级网关可以工作在OSI七层模型上的任意一层，能够检查进出的数据包，通过网关复制传递数据，防止在受信任服务器和客户机与不受信任的主机之间直接建立联系。</p>
<p>@@ 用户A和B要进行安全通信，通信过程需确认双方身份和消息不可否认，A和B通信时使用<strong>数字证书</strong>来对用户的身份进行认证；使用<strong>数字签名</strong>确保消息不可否认</p>
<p>@@ <strong>震网</strong>病毒是一种破坏工业基础设施的恶意代码，利用系统漏洞攻击工业控制系统，是一种危害性极大的<strong>蠕虫病毒</strong>。<strong>蠕虫(Worm)<strong>是一个程序或程序序列。它利用网络进行复制和传播，传染途径是通过网络、移动存储设备和电子邮件。最初的蠕虫病毒定义是在DOS环境下，病毒发作时会在频幕上出现一条类似虫子的东西，胡乱吞吃屏幕上的字母并将其改正。常见的蠕虫病毒有：</strong>快乐时光、红色代码、爱虫病毒、熊猫烧香、Nimda病毒、爱丽兹病毒</strong>。<strong>CIH</strong>：系统病毒      <strong>X卧底</strong>：以木马形式传播目标为智能手机的病毒<br><strong>引导区病毒</strong>：破坏的是引导盘、文件目录<br><strong>宏病毒</strong>[<strong>Macro</strong>]：破坏的是OFFICE文件相关(病毒宏将自身复制至Word的通用Normal模板中)<br><strong>木马</strong>：一般强调控制操控 [<strong>冰河</strong>是木马软件，主要用于远程监控。冰河木马后经其他人多次改写形成多种变种，并被用于入侵其他用户的计算机木马程序]</p>
<p>@@ Sniffer(<strong>嗅探器</strong>)是一种基于被动侦听原理的网络分析方式。使用这种技术方式可以监视网络的状态、数据流动情况以及网上传输的信息。它不是木马程序</p>
<p>@@ 属于DoS攻击的是<strong>SYN Flooding攻击</strong> [<u>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。</u>]<br>① <strong>特洛伊木马</strong>[Trojan]是附着在应用程序中或者单独存在的一些恶意程序，它可以利用网络远程控制网络的另一端的安装有服务端服务的主机，实现对被植入了木马程序的计算机的控制，或者窃取被植入了木马程序的计算机上的机密资料。<br>② <strong>拒绝服务攻击</strong>通过网络的内外部用户来发动攻击。内部用户可以通过长时间占用系统的内存、CPU处理时间使其他用户不能及时得到这些资源，而引起拒绝服务器攻击；外部黑客也可以通过占用网络连接使其他用户得不到网络服务   <strong>SYN Flooding攻击</strong>以多个随机的源主机地址向目的路由器发送SYN包，在收到目的路由器的SYN ACK后并不回应，于是目的路由器就为这些源主机建立大量的连接队列，由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致服务器崩溃。服务器要等待超时才能断开已分配的资源，所以SYN Flooding攻击是一种DOS攻击<br>③ <strong>端口欺骗攻击</strong>是采用端口扫描到系统漏洞从而实施攻击<br>④ <strong>IP欺骗攻击</strong>是产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份</p>
<p>@@ DES是<strong>共享密钥加密</strong>算法；常见的对称加密算法有：DES、三重DES、RC-5、IDEA、AES<br><u>共享密钥加密</u>指<u><strong>对称加密</strong></u>；<br><u>非共享密钥</u>加密指<u><strong>公开密钥加密</strong></u></p>
<p>@@ 计算机病毒的特征：<strong>隐蔽性、传染性、潜伏性、触发性、破坏性</strong></p>
<p>@@ MD5是<strong>摘要</strong>算法，对任意长度的输入计算得到的结果长度是<strong>128未散列值</strong></p>
<p>@@ 攻击者通过发送一个目的主机已经接受过的报文来达到攻击目的，这种攻击方式属于<strong>重放</strong>攻击<br>**重放攻击(Replay Attacks)**又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行</p>
<p>@@ kerberos系统中可通过在报文中加入<strong>时间戳</strong>来防止重放攻击。发送的数据包带时间戳的，服务器可以根据时间戳来判断是否为重放包，以此防止重放攻击</p>
<p>@@  防火墙最基本的功能就是控制在计算机网络中，不同信任程度区域间传送的数据流。防火墙对流经它的网络通信进行扫描，这样能够过滤掉一些攻击，以免其在目标计算机上被执行。防火墙还可也关闭不适用的端口，屏蔽内部细节。所有的访问都经过防火墙，防火墙就能记录下这些访问并做出日志记录，同时也能提供网络使用情况的统计数据</p>
<p>@@ 防火墙的性能及特点：<br>① <strong>工作层次：</strong>决定防火墙效率及安全的主要因素，<u><strong>工作层次越低，则工作效率越高，其安全性就越低</strong></u><br>② <strong>防火墙机制：</strong>采用代理机制，则防火墙具有内部信息隐藏的特点，相对而言，安全性越高，效率越低。如果采用<strong>过滤机制</strong>，则效率高，安全性却降低</p>
<p>@@ 包过滤防火墙和代理服务防火墙的叙述中正确的是<strong>包过滤技术对应用和用户是透明的</strong>。包过滤技术是一种基于网络层、传输层的安全技术，优点是简单实用，实现成本较低同时，<strong>包过滤操作对于应用层来说是透明的</strong>，使用此类防火墙时外部网络与内部网络之间不存在直接连接，即使防火墙发生了问题，外部网络也无法被保护的网络连接。</p>
<p>@@ 包过滤防火墙对数据包的过滤依据包括<strong>源IP地址、源端口号、目标IP地址、目标端口号</strong> 而不是<del>MAC地址</del></p>
<p>@@ 防火墙通常分为<strong>内网、外网、DMZ</strong>三个区域<br>按照<u>受保护程序</u>[安全级别]从高到低正确排列顺序依次为<strong>内网、DMZ、外网</strong>；<br>① 内网可以访问外网、内网可以访问DMZ<br>② 外网可以访问DMZ、外网不能访问内网<br>③ DMZ不能访问外网、DMZ不能访问内网</p>
<p>@@ 入侵检测技术包括<strong>专家系统、模型检测、简单匹配</strong> [<u>入侵检测</u>和<u>流量控制</u>属于网络安全措施]</p>
<p>@@ 这四种加密算法均能对明文进行加密。<br><strong>RSA</strong>是一种非对称加密算法，由于加密和解密的密钥不同，因此便于密钥管理和发放，同时用户或机构之间进行身份认证方面有较好的应用 [基于大数定律，通常用于对消息摘要进行签名(<strong>数字签名算法</strong>) 而IDEA和RC4适用于对数据传输加密]<br><strong>SHA-1</strong>是一种安全散列算法，常用于对接接收到的明文输入产生固定长度的输出，来确保明文在传输过程中不会被篡改<br><strong>MD5</strong>是一种使用最为广泛的报文摘要算法(<strong>摘要算法</strong>)<br><strong>RC5</strong>是一种用于对明文进行加密的算法，在加密速度和强度上均较为合适，适用于大量明文进行加密并传输</p>
<p>@@ 假定用户A、B分别为I1和I2两个CA处取得了各自的证书，下面<strong>I1、I2互换公钥</strong>是A、B互信的必要条件</p>
<p>@@ <strong>MIME</strong>是一个互联网标准，<u>扩展了电子邮件标准</u>，使其能够支持，与安全无关。<br><strong>SSL</strong>和<strong>HTTPS</strong>涉及到<u>邮件传输过程的安全</u><br><strong>PGP</strong>是一套用于信息加密、验证的应用程序，可用于<u>加密电子邮件内容</u></p>
<p>@@ 数字签名用于通信的A、B双方，使得A向B发送签名的消息P，提供以下服务：<br>① B可以验证消息P确实是来源于A<br>② A不能否认发送过消息P<br>③ B不能便在或修改消息P<br>数字签名首先需要生成消息摘要，使用非对称加密算法以及私钥对摘要进行加密。接收方使用发送方的公钥对消息摘要进行验证。</p>
<p>@@ 用户B收到用户A带数字签名的消息M，为了验证M的真实性，<span style = "color : red">首先需要从CA获取用户A的数字证书，并利用<strong>CA的公钥</strong>验证该证书的<strong>真伪</strong></span>，然后利用<strong>A的公钥</strong>验证M的真实性 [<u>验证证书的真伪需要用CA的公钥验证CA的签名，验证M的真实性需要用用户A的公钥验证用户A的签名</u>]</p>
<p>@@ <span style = "color : red">从认证中心CA获取用户B的数字证书，该证书用<strong>CA的私钥</strong>作<strong>数字签名</strong></span>：<u>从用户B的数字证书中可以获得B的公钥</u> 【<strong>CA公钥→合法性、CA签名→真伪、CA私钥→数字签名</strong>】</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/030ab484289fb8237b38a9a6a073451c201af8c5/data/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></p>
<p>@@ 公钥体系中，<strong>私钥用于<u>解密和签名</u>，公钥用于<u>加密和认证</u></strong></p>
<p>@@ 某网站向CA申请了数字证书，用户通过<strong>CA的签名</strong>来验证网站的<strong>真伪</strong>，通过使用<strong>CA的公钥</strong>来确定该网站的<strong>合法性</strong></p>
<p>@@ <strong>设置防雷击</strong>属于物理线路安全措施、<strong>入侵检测, 流量控制</strong>属于网络安全措施、<strong>漏洞发现于补丁管理</strong>属于系统安全措施</p>
<p>@@ <strong>网络攻击</strong>有<strong>主动攻击</strong>和<strong>被动攻击</strong>两类，主动攻击是指通过一系列方法主动向被攻击对象试试破坏的一种攻击方式，<strong>主动攻击</strong>有：<u>重放攻击、IP地址欺骗、拒绝服务</u>。<strong>流量分析攻击</strong>[被动攻击]是通过持续检测现有网络中的流量变化或者变化趋势，而得到相应信息的一种被动攻击方式</p>
<p>@@ 端口443明确用于<strong>HTTPS服务</strong>，因此是HTTPS（加密）流量的标准端口。 它也称为HTTPS端口443，因此所有受保护的事务都是使用端口443进行的。 您可能会惊讶地发现，几乎95％的安全站点都使用端口443进行安全传输。80端口是<strong>HTTP超文本传输协议</strong>。</p>
<table>
<thead>
<tr>
<th align="center">Proto</th>
<th align="center">Local Address</th>
<th align="center">Foreign Address</th>
<th align="center">State</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2011</td>
<td align="center">202.100.112.12:443</td>
<td align="center">ESTABLISHED</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2052</td>
<td align="center">128.105.129.30:80</td>
<td align="center">ESTABLISHED</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2038</td>
<td align="center">100.29.200.110:110</td>
<td align="center">TIME_WAIT</td>
</tr>
</tbody></table>
<p>① 其中已经与主机202.100.112.12的443端口建立连接，由于443端口主要用于HTTPS服务，是提供加密和通过安全端口传输的另一种HTTP协议，是建立了<strong>安全连接</strong>。<br>② 其中已经与主机128.105.129.30的80端口建立了普通连接。<br>③ 其中与主机100.29.200.110的110端口正在等待建立连接</p>
<p>@@ <strong>SSH</strong>(Secure Shell)是<strong>终端设备</strong>与<strong>远程站点</strong>之间建立安全连接的协议，是专为远程登录会话和其他网络服务提供安全性的协议，利用SSH协议可以有效防止远程管理过程中的信息泄露问题，SSH最初是UNIX上的程序</p>
<p>@@ <strong>机房安全</strong>属于物理安全、<strong>入侵检测</strong>属于网络安全、<strong>漏洞补丁管理</strong>属于系统安全、<strong>数据库安全</strong>属于应用安全</p>
<p>@@ 网络系统中，通常把<strong>Web服务器</strong>置于DMZ区 [DMZ是为了<u>解决安装防火墙后外部网络不能访问内部网络服务器的问题</u>，而设立的一个非安全系统与安全系统之间的缓冲区。这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，在这个小网络区域内可以防止一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛]</p>
<p>@@ 拒绝服务攻击即攻击者想办法让目标机器停止提供服务，这是黑客常用的攻击手段之一，其实对网络带宽进行的消耗性攻击只是拒绝服务攻击的一小部分，只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于<strong>拒绝服务攻击</strong>。攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是<u><strong>迫使服务器的缓冲区满</strong></u>，不接收新的请求。二是<u><strong>使用IP欺骗</strong></u>，迫使服务器把合法用户的连接复位，影响合法用户的连接</p>
<p>@@ PKI体制中，保证数字证书不被篡改的方法是<strong>用CA的私钥对数字证书签名</strong>[防伪造,不可抵赖]</p>
<p>@@ <strong>ECC、DSA、RSA</strong>属于公开密钥加密算法     <strong>DES</strong>属于<strong>私钥加密体制</strong></p>
<p>@@ 利用<strong>报文摘要算法</strong>生成报文主要的目的是<strong>防止发送的报文被篡改</strong> [报文摘要是用来保证数据完整性的，传输的数据一旦被修改，摘要就不同了，只要对比两次摘要就可以确定数据是否被修改过]</p>
<p>@@ <strong>TLS</strong>是安全传输层协议的简称，用于在两个通信应用程序之间提供保密性和数据完整性<br><strong>SSL</strong>是安全套接层协议的简称，是一种为网络通信提供安全和数据完整性的协议，它与TLS非常相似，它们都是在<u>传输层</u>对网络连接进行加密<br><strong>PGP</strong>是基于RSA公钥加密体系的邮件加密软件，用它可以对邮件保密以防止非授权者阅读<br><strong>HTTPS</strong>即安全版的<strong>HTTP</strong>(超文本传输协议)，它是在HTTP下加入SSL层，HTTPS的安全基础就是SSL<br><strong>IPSec</strong>是<u>网络层</u>的安全协议，它通过使用加密的安全服务来确保在网络上进行保密而安全的通讯</p>
<p>@@ 在Windows系统中，默认权限最低的用户组是<strong>everyone</strong><br>用户组默认权限由高到低的顺序是<strong>administrators &gt; power users &gt; users &gt; everyone</strong></p>
<p>@@ IIS6.0支持的身份验证安全机制有[<u>.NET Passport身份验证、集成Windows身份验证、摘要式身份验证、基本身份验证</u>]安全级别最高的验证方法是<strong>集成Windows身份验证</strong></p>
<p>@@ 利用<strong>漏洞扫描系统</strong>可以获取某FTP服务器中是否存在可写目录的信息 [通过与目标主机TCP&#x2F;IP端口建立连接并请求某些服务(TELNET、FTP)，记录目标主机的应答，搜索目标主机相关信息，从而发现目标主机某些内在的安全弱点]</p>
<p>@@ FTP服务器的控制端口为<strong>21</strong>，上传文件时的端口为<strong>20</strong></p>
<p>@@ 防范网络监听最有效的方法是<strong>数据加密</strong></p>
<p>@@ “三网合一”的三网是指<strong>电信网、广播电视网、互联网</strong></p>
<h2 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h2><p>@@ <strong>LISP</strong>是一种通用高级计算机程序语言、<strong>C</strong>是命令式过程式语言、<strong>Java</strong>面向对象语言、<strong>C#<strong>结构化程序设计语言、</strong>Java,Python,JavaScript</strong>都是解释型程序设计语言[其中python[弱类型语言]和javascript是<u>脚本语言</u>(主要采用<strong>解释方式实现</strong>)]<br>强&#x2F;弱类型指的是语言类型系统的类型检查的严格程度。弱类型相对于强类型来说类型检查<strong>更不严格</strong>, 比如<u>允许变量类型的隐式转换，允许强制类型转换</u>等</p>
<p>@@ <strong><u>语法制导翻译</u><strong>是一种</strong>静态语义分析</strong>方法。程序设计语言的语义分为<strong>静态语义</strong>和<strong>动态语义</strong>，其中静态语义分析方法是语法制导翻译，其基本思想是将语言结构的语义以属性的形式赋予代表此结构的文法符号，而属性的计算以语义规则的形式赋予文法的产生式。</p>
<p>@@ 常用的函数参数传递方式有<strong>传值</strong>与<strong>传引用</strong>两种；<strong>在传引用方式下，修改形参实质上改变了实参的值</strong>。[<u>在<strong>传值</strong>调用方式下，是将实参的值传递给形参，该传递是单方向的，结束调用后不会再将形参的值传递給实参</u>。<u>在<strong>引用</strong>调用方式下，实质上是将实参的地址传递給形参，借助指针的间接访问数据方式下(或者将形参看作是实参的别名)，在被调用函数中对形参的修改实质上是对实参的修改。</u>]</p>
<p>@@ 在<strong>值调用</strong>方式下是将参数的值传給形参。在<strong>引用调用</strong>方式下是将实参的地址传递给形参                 </p>
<p>@@ 在<strong>传值调用</strong>方式下，实参可以是变量，也可以是常数和表达式<br>在<strong>引用调用</strong>方式下，可以是实现形参和实参间双向传递数据的效果          </p>
<p>@@ 传地址方式下，<u>将<strong>实参</strong>的地址传給<strong>形参</strong></u>，因此，实参必须有地址                                                                       </p>
<p>@@ 函数中print(x)执行后输出的值为<strong>40</strong></p>
<pre><code class="C">main()&#123;                      f(int x, int &amp;a)&#123;
  int x = 5;                    x = x * x - 1;
  f(x+1,x);                        a = x + a;
  print(x);                        return;
&#125;                               &#125;
</code></pre>
<p>@@ 函数中return(a-x)执行后输出的值为<strong>33</strong><br><img src="https://raw.githubusercontent.com/P-luminary/images/92ef1aa18e2abcd24f114fb254939f65a6933028/data/%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92%E5%9C%B0%E5%9D%80.png" style="zoom:50%;" /></p>
<p>@@ 编译器对高级语言源程序的处理过程：<br><u>源程序 → 词法分析 → 语法分析 → 语义分析 → 中间代码生成 → 代码优化 → 目标代码生成 → 目标代码</u>；<br>其中<strong>中间代码生成和代码优化</strong>并不是每个编译器都必需的，与编译器相比，解释器<strong>参与运行控制，程序执行的速度慢</strong></p>
<p><strong>词法分析</strong>：根据语言的词法规则，对源程序进行逐个字符地描述，从中识别出一个个单词符号，针对词汇的检查<br><strong>语法分析</strong>：在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位；<br><strong>语义分析</strong>：分析各语法结构的含义，检查源程序是否包含语义错误，主要针对句子含义的检查；</p>
<p>@@ <strong>语法分析阶段</strong>的输入是<strong>记号流</strong>，若程序中的符号不匹配，则会在<strong>语法分析阶段</strong>检查出错误<br><strong>记号流</strong>：词法分析的输出是记号流，也就是语法分析的输入。<br><strong>源程序</strong>：词法分析的任务是把源程序的字符串转换成单词符号序列<br><strong>分析树</strong>：如果没有语法错误，语法分析后就能正常的构造出语法树</p>
<p>@@ <strong>语法错误</strong>是指语言结构上的使用错误，是指编译时所发现的程序错误，如<strong>单词拼写错误、标点符号错误、表达式中缺少操作数、符号不匹配</strong>等有关语言结构上的错误 [<u>语法分析阶段可以发现程序中所有的语法错误、但是不能在语义分析阶段发现程序中的所有语义错误(循环越界)</u>]</p>
<p>@@ 若程序在运行时陷入死循环，则情况属于<strong>动态的语义错误</strong>；在编译过程中，进行类型分析和检查是<strong>语义分析</strong>阶段的一个主要工作。**<u>死循环，零除数，其他逻辑错误</u><strong>是属于</strong>动态语义错误<strong>。语义检查时不检查动态语义，因此</strong><u>编译正确的程序不包含语法错误</u>**</p>
<p>@@ 高级程序设计语言不依赖具体的<strong>机器硬件</strong>；程序中局部变量的值在运行时<u>可以改变</u>，局部函数只能在函数内部使用，其作用域是从定义位置起至函数体或复合语句体结束位置。</p>
<p>@@ 在编写C&#x2F;C++时，若表达式中引用的变量从定义到使用始终没有赋值，则该变量中的值表现为一个<strong>随机数</strong>，这样对表达式的求值结果就是不确定的了。故[可以通过编译并运行，但运行结果不一定是期望的结果]</p>
<p>@@ 关于高级程序设计语言翻译的叙述中正确的是<strong>目标代码生成阶段的工作与目标机器的体系结构密切相关</strong></p>
<p>@@ 变量与常量：<strong>变量具有类型属性，常量则没有</strong> [<u>常量在程序运行过程中不能修改</u>]</p>
<p>@@ 可视化程序设计是以”<strong>所见即所得</strong>“的编程思想为原创，力图实现编程工作的可视化，即随时可以看到结果，程序与结果的调整同步。可视化程序设计仅通过直观的操作方式即可完成界面的设计工作[其基于面向对象的思想，引入了控件的概念和事件驱动；程序开发遵循步骤：即<u>先进行界面的绘制工作，再基于事件编写程序代码，以响应鼠标、键盘的各种动作</u>]。可视化程序设计最大的有点是设计人员可以不用编写或只需要编写很少程序代码，就能完成应用程序的设计，极大提高设计人员的工作效率</p>
<p>@@ PHP不是标记语言，PHP，全称 Hypertext Preprocessor ，中文翻译“超文本预处理器”。是在 服务器 端执行的 脚本语言 ，尤其适用于 Web 开发并可嵌入 HTML 中。 </p>
<p>@@ 创建指向邮箱地址的连接**<code>&lt;a href = &quot;mailto:test@test.com&quot;&gt; test@test.com &lt;/a&gt;</code>** 使用**<code>&lt;mailto&gt;</code>**标签定义一个指向电子邮件地址的超级链接</p>
<p>@@ <strong>指针变量</strong>可以是全局变量也可以是局部变量 </p>
<p>@@ 若一个程序语言可以提供链表的定义和运算，则其运算时的<strong>数据空间必须采用堆存储分配策略</strong></p>
<p>@@ <strong>动态语言</strong>是指程序在运行时可以改变其结构，例如新的函数可以被引进、已有的函数可以被删除等，在结构上的变化。动态语言的类型检查是在运行时进行的。优点是方便阅读，不需要写非常多的与类型相关的代码；缺点是不方便调试，命名不规范时会读不懂、不利于理解。事实上脚本语言都是动态语言，而动态语言都是解释型语言，不管它们是否是面向对象的语言 ；C语言属于<strong>静态语言</strong>，其所有成分可在编译时确定</p>
<p>@@ HTML<code>&lt;body&gt;</code>元素中，<strong>vlink</strong>属性用于定义超链接被鼠标点击后所显示的颜色<br><strong>alink</strong>：用于设置正在被击中的链接的颜色<br><strong>vlink</strong>：用于设置已使用的链接的颜色<br><strong>bgcolor</strong>：用于设置文档整体背景颜色<br><strong>background</strong>：用于设置背景图片的URL</p>
<p>@@ XML文档语法规范中：<strong>标记之间不可以交叉嵌套</strong></p>
<p>@@ <strong>动态</strong>绑定是指在运行时把过程调用和响应调用所需要执行的代码加以结合。<strong>运行时结合</strong>是<strong>动态绑定</strong>、<strong>编译时结合</strong>是<strong>静态绑定</strong></p>
<p>@@ 汇编程序的功能是将用<strong>汇编语言</strong>写的源程序翻译成机器指令程序。汇编程序的基本工作包括将一条可执行汇编语句转换成对应的机器指令；处理源程序中出现的伪指令。由于汇编指令中形成操作数指令的部分可能出现后面才会定义的符号，所以汇编程序一般需要两次扫描源程序才能完成翻译过程</p>
<p>@@ 对高级语言源程序进行编译或解释处理的过程中，需要不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入<strong>符号表</strong> [这些信息一般以表格形式存储于系统中]</p>
<p>@@ 将高级语言源程序翻译称目标程序的是<strong>编译程序</strong></p>
<p>@@ 将高级语言源程序翻译为可在计算机上执行的形式有多种不同的方式，其中<strong>编译方式生成逻辑上与源程序等价的目标程序，解释方式不生成</strong>[为源程序中变量所分配的存储单元的地址属于<strong>逻辑地址</strong>]<br>编译语言是一种以编译器来实现的编程语言，它不像直译语言一样，由解释器将代码一句一句运行，而是以编译器，先将代码编译为机器码，再加以运行。将某一种程序设计语言写的程序翻译成等价的另一种语言的程序的程序，称为编译程序</p>
<p>@@ 将高级语言源程序通过编译或解释方式进行翻译时，可以先生成与源程序等价的某种中间代码。<strong>后缀式和三地址码是常用的中间代码</strong>。[不同高级程序语言可以产生同一种中间代码]<br><strong>中间代码</strong>的作用是<u>可使程序的结构再逻辑上更为简单明确</u>(<strong>有利于进行与机器无关的优化处理，优化一般建立在对程序的控制流和数据流分析的基础之上, 与机器无关</strong>)，特别是可以使目标代码的优化比较容易实现。中间代码由很多形式，常见的由**<u>逆波兰记号(后缀式)、四元式、三元式(三地址码)、语法树</u><strong>，它们的共同特点是与具体的机器无关，不依赖于具体的计算机。</strong>中间代码**是源程序的一种内部表示，称中间语言。<u>中间代码不依赖于具体的机器、使用中间代码可提高编译程序的可移植性、中间代码可以用树或图表示</u></p>
<p>@@ 编译程序不参加与用户程序的运行控制，而解释程序则参与。编译程序(编译器)则是将源程序翻译成目标语言程序，然后再计算机上运行目的程序。再解释方式下。翻译源程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。</p>
<p>@@ 编译和解释是实现高级程序设计语言翻译的两种基本形式，<u><strong>在编译方式下，必须进行词法、语法和语义分析，然后再产生源程序的目标代码</strong></u></p>
<p>@@ 对高级语言源程序进行编译的过程可分为多个阶段，分配寄存器的工作再<strong>目标代码生成</strong>阶段进行。[<strong>目标代码生成</strong>是编译器工作的最后一个阶段，这一阶段的任务是把中间代码变换成特定机器上的绝对指令代码、了重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密切相关，因此在目标代码生成阶段分配寄存器。]</p>
<p>@@ 汇编程序输入的是用汇编语法书写的源程序，输出的是用机器语言表示的目标程序[<u>汇编语言源程序中的指令语句将被翻译成机器代码</u>、<u>汇编程序以汇编语言源程序为输入，以机器语言表示的目标程序为输出</u>、<u>汇编语言的指令语句必须具有操作码字段，可以没有操作数字段</u>]</p>
<p>@@ 编译过程中，对高级语言程序语句的翻译主要考虑声明语句和可执行语句。对声明语句，主要是将所需要的信息正确地填入合理组织的<strong>符号表</strong>中；对可执行语句，则是<strong>翻译成中间代码或目标代码</strong></p>
<p>@@ <strong>编译</strong>和<strong>解释</strong>是语言处理的两种基本方式：<br><strong>编译过程</strong>包括(词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成等阶段)，以及**<u>符号表管理</u><strong>和</strong><u>出错处理模块</u>**<br><strong>解释过程</strong>在词法、语法和语义分析方面与编译程序的工作原理基本相同，但是在运行用户程序时，它直接执行<strong>源程序或源程序的内部形式</strong><br>这两种语言处理程序的根本区别：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程；而在解释方式下，解释程序和源程序(某种等价表示)要参与到程序的运行过程中，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序，而编译器则需要将源程序翻译成独立的目标程序</p>
<p>@@ <strong>移进—归约</strong>分析法是编译程序(解释程序)对高级语言源程序进行语法分析的一种方法，属于<strong>自下而上</strong>的语法分析方法<br><strong>递归下降分析法、预测分析法</strong> → 是<u><strong>自上而下</strong></u>分析法<br><strong>移进-归约分析法</strong> → 是**<u>自下而上</u>**分析法</p>
<p>@@ 已知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>对B进行反编译，不能还原出源程序A</strong><br>编译是将高级语言源程序翻译成机器语言程序，<u>反编译是编译的逆过程</u>，<u><strong>反编译</strong>通常不能把可执行文件还原成高级语言源程序，只能转换成功能上等价的汇编程序</u></p>
<p>@@ 对于表达式<code>a or ((c&lt;d) and b)</code>，当<strong>a为true</strong>时可进行<strong>短路计算</strong>，最后计算的是or，对 <strong>或运算</strong> ，只要有一个真则结果为真，此题当a为true时，可进行短路计算，直接得到后面的结果</p>
<p>@@ 文法分为4种类型，程序设计语言的大多数语法现象可用<strong>乔姆斯基</strong>的<strong>上下文无关文法</strong>描述</p>
<p>@@ 在仅由字符a、b构成的所有字符串种，其中<u>以b结尾的<strong>字符串集合</strong></u>可用正则表达式为<br>$(b|ab)^<em>b$表示的<strong>字符串集合</strong>为<code>&#123;b,bb,abb,bbb,abab,bbbb,abbb,babb,...&#125;</code><u>除了以b结尾, 还要求每个a后面至少有1个b</u> 不符合题意只要有b结尾的！！<br>$(a|b)^</em>b$ 表示的<strong>字符串集合</strong><code>&#123;b,ab,bb,aab,abb,bab,bbb,aaab,aabb,abab,abbb,baab,babb,bbab,...&#125;</code></p>
<p>@@ 表达式采用逆波兰式表示时，利用<strong>栈</strong>进行求值<br>后缀式(逆波兰式)表达方式把运算符写在运算对象后面，**把a+b写成ab+**，所以也称为后缀式。借助栈可以方便地对后缀式进行求职。</p>
<p>@@ 与算术表达式**(a+(b-c))*d**对应的树是  求值运算处理顺序是：先进行b-c，然后与a相加，最后再与d相乘[中序遍历二叉树即可得出]</p>
<p>@@ 算数表达式**(a-b)<em>(c+d)<strong>的后缀式是</strong>ab-cd+**</em>  后缀式(逆波兰式)</p>
<p>@@ 算术表达式<em>*a+(b-C)*d**的后缀式是</em><em>abc-d</em>+** 利用逆波兰式，但是要把得到的步骤式子当成整体<br>原式&#x3D;<code>a+bC-*d</code> &#x3D;<code>a+bC-d*</code>&#x3D;<code>abC-d*+</code>  其中的着重点在于把bC-变成一个整体<strong>bC- * d</strong>再用逆波兰式 <strong>bC-d</strong>*<br>算术表达式**(a-b)<em>c+d<strong>的后缀式是</strong>ab-c</em>d+**</p>
<p>@@ 逻辑表达式<code>&quot;a^bvc^(bvx&gt;0)&quot;</code> 的后缀式是**<code>ab^cbx0&gt;v^v</code>**<br>此题有大坑   <code>^是&quot;与&quot;门的意思、v是异&quot;或&quot;门的意思</code>；<br><u>逻辑与运算</u>的优先级高于<u>逻辑或运算</u><br>“<strong>逻辑与运算</strong>“ 表达式 “<code>x^y</code>“的短路求值逻辑是：若x为假，则可知”<code>x^y</code>“的值为假，无需再对y求值。因此只有在x为真时继续对y求值<br>“<strong>逻辑或运算</strong>“ 表达式 “<code>xvy</code>“的短路求值逻辑是：若x为真，则可知”<code>xvy</code>“的值为真，无需再对y求值。因此只有在x为假时继续对y求值<br>对于逻辑表达式<code>&quot;a^bvc^(bvx&gt;0)&quot;</code>，从运算符的优先级方面考虑需先对”<code>a^b</code>“求值。然后对”<code>c^(b^x&gt;0)</code>“求值，最后进行对<code>&quot;v&quot;</code>运算，因此后缀式是**<code>ab^cbx0&gt;v^v</code>**</p>
<p>@@ 递归下降分析方法是一种<strong>自上而下的语法分析</strong><br>程序式设计语言的绝大多数语法规则可以采用<strong>上下文无关文法</strong>进行描述。语法分析方法有多种，根据产生语法树的方向，可分为<u><span style = "color:red"><strong>自底向上</strong></span>[算符优先分析法、LR分析法]</u>     <u><strong><span style = "color:red">自顶向下</span></strong>[递归下降分析法、预测分析法]</u>两类。</p>
<p>@@ 对于大多数通用程序设计语言，用<strong>上下文无关文法</strong>描述其语法即可<br>文法分成四种类型：0型、1型、2型、3型。<br><strong>0型文法</strong>也称为短语文法，其能力相当于图灵机，任何0型语言都是递归可枚举的；反之，递归可枚举集也必定是一个0型语言<br><strong>1型文法</strong>也称为上下文有关文法，这种文法意味着对非终结符的替换必须考虑上下文<br><strong>2型文法</strong>也称为上下文无关文法，非终结符的替换无需考虑上下文【通用程序设计语言绝大多数使用上下文无关文法(此文法拥有足够强的表达能力来表示大多数程序设计语言的语法)】<br><strong>3型文法</strong>等价于正规式，因此也被称为正规文法或线性文法。</p>
<p>@@ 在c&#x2F;c++程序种，整型变量a的值为0且应用在表达式”c&#x3D;b&#x2F;a”种，则最可能发生的情形是<strong>运行时产生异常</strong><br>c&#x3D;b&#x2F;a符合c&#x2F;c++语言的语法逻辑，编译时不会报错，运行时，代入a的值，发生错误</p>
<p>@@ 对高级语言源程序进行编译过程中，有限自动机(NFA或DFA)是进行<strong>词法分析</strong>的适当工具<br>词法分析的任务是把构成源程序的字符串转换成单词符号序列。有限自动机是一种识别装置的抽象概念，它能准确地识别正规集。有限自动机分为两类：<strong>确定的有限自动机(DFA)<strong>和</strong>不确定的有限自动机(NFA)</strong></p>
<p>@@ L&#x3D;{$a^n$$b^n$|n&gt;&#x3D;1}<strong>不能用正规式表示，也不能通过有限自动机识别</strong>[此字符串的特点是a的个数与b的个数相同，且所有的a都在b之前]，因为该集合不是正规集，不能用正规式表示。而语言**L&#x3D;{$a^m$$b^n$|m≥0, n≥1}**的正规式表达式式<code>a*bb*</code>  因为在此集合中表示，若干个a之后跟若干个b，a可以不出现，b至少出现1次。</p>
<p>@@ 包含8个成员的开发小组的沟通路径最多有<strong>28</strong>条 [任意小组成员之间均可能有沟通路径，则可用完全连通图来对开发小组的沟通路径建模，最多的沟通路径为<strong>完全连通图的边数</strong>，即n个成员的开发小组的沟通路径是<strong>n(n-1)&#x2F;2</strong>，因此8个成员的开发小组沟通路径最多有28条]</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/cbacb3bb4e0bb351d573b25f7a61a12cfdcddc4a/data/%E7%A1%AE%E5%AE%9E_%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A9%E6%9C%BA.png" style="zoom: 67%;" />

<p>@@ 一个文法的语言是从文法能产生的句子的集合。<u><strong>一个文法产生的句子是从文法开始符号发出推导出的所有终结符号串</strong></u></p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>@@ 从减少成本和缩短研发周期考虑，要求<strong>嵌入式操作系统</strong>能运行在不同的<strong>微处理器平台</strong>上，能针对硬件变化进行结构与功能上的配置。该要求体现了嵌入式操作系统的<strong>可定制性</strong><br><strong>嵌入式操作系统的特点：</strong><br>① <strong>微型化：</strong>从性能和成本角度考虑，希望占用的资源和系统代码量少<br>② <strong>可定制：</strong>从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的<strong>微处理器平台</strong>上，能针对硬件变化进行结构与功能上的配置，以满足不同应用的需求<br>③ <strong>实时性：</strong>嵌入式操作性系统主要应用于过程控制、数据采集、传输通信、多媒体信息及关键要害领域需要迅速响应的场合，所以对实时性要求较高<br>④ <strong>可靠性：</strong>系统构建、模块和体系结构必须达到应有的可靠性，对关键要害应用还要提供容错和防故障措施<br>⑤ <strong>可移植性：</strong>为了提高系统的易移植性，通常采用<strong>硬件抽象层</strong>和<strong>板级支撑包</strong>的底层设计技术</p>
<p>@@ 在Linux中，要更改一个文件的权限设置可使用<strong>chmod</strong>命令，修改文件夹名可使用<strong>modify</strong>命令<br>Linux中只有一个根目录，用”&#x2F;“表示</p>
<p>@@ 计算机系统由<strong>硬件</strong>和<strong>软件</strong>两部分组成，通常把未配置软件的计算机称为裸机。操作系统目的是为了填充人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。从用户角度看，当计算机配置了操作系统后，用户不再直接使用计算机系统硬件，而是使用操作系统所提供的命令和服务去操纵计算机，操作系统已称为现代计算机系统中必不可少的最重要的系统软件，因此<strong>操作系统</strong>是<strong>用户</strong>与<strong>计算机之间</strong>的<u>接口</u><br><img src="https://raw.githubusercontent.com/P-luminary/images/9f871f12e0e525d3f04ed912fcaa537b19f5203a/data/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%9C%B0%E4%BD%8D.jpg" style="zoom:50%;" /></p>
<p>@@ 实时操作系统主要用于<strong>实时要求的过程控制</strong>等领域，实时系统对于来自外部的事件必须在<strong>被操控对象规定的事件内做出及时响应并对其进行处理</strong>。<br><strong>实时操作系统</strong>与<strong>分时操作系统</strong>的第一点区别就是：<br>① 交互性强弱不同，<u>分时系统</u>交互型强，<u>实时系统</u>交互型弱，但可靠性要求高<br>② 响应事件的敏感性强，对随机发生的外部事件必须在被控制对象规定的时间做出及时响应并对其进行处理<br>③ 系统的设计目的不同，<u>分时系统</u>是设计称一个多用方的通用系统，交互能力强；而<u>实时系统</u>大多数都是专用系统。</p>
<p>@@ <strong>嵌入式系统初始化</strong>过程分为3个主要环节，按照<u>自底向上</u>，<u>从硬件到软件</u>的次序依次为：<u><strong>片级初始化</strong>、<strong>板级初始化</strong>、<strong>系统级初始化</strong></u>。系统初始化主要任务是<strong>以软件初始化为主，主要进行操作系统的初始化</strong><br><strong>片级初始化：</strong><u>片级初始化完成嵌入式微处理器的初始化</u>，包括设置嵌入式微处理器的核心寄存器和控制寄存器、嵌入式微处理器核心工作模式和嵌入式微处理器的局部总线模式等。片级初始化把嵌入式微处理器从上电时的默认状态逐步设置成系统所要求的工作状态。这是一个纯硬件的初始化过程。<br><strong>板级初始化：</strong><u>板级初始化完成嵌入式微处理器以外的其他硬件设备的初始化</u>。另外，还需设置某些软件的数据结构和参数，为随后的系统级初始化和应用程序的运行建立硬件和软件环境。这是一个同时包含软硬件两部分在内的初始化过程。<br><strong>系统初始化：</strong><u>系统初始化过程以软件初始化为主，主要进行操作系统的初始化</u>。BSP将对嵌入式微处理器的控制权转交给嵌入式操作系统，由操作系统完成余下的初始化操作，包含加载和初始化与硬件无关的设备驱动程序，建立系统内存区，加载并初始化其他系统软件模块，如网络系统、文件系统等。最后，操作系统创建应用程序环境，并将控制权交给应用程序的入口。</p>
<p>@@ 设计操作系统时不需要考虑的问题是<strong>语言编译器的设计实现</strong><br>操作系统有两个重要作用：<br>① 通过资源管理提高计算机系统的效率，<strong>操作系统</strong>是计算机的资源管理者，它含有对系统软&#x2F;硬件资源实施管理的一组程序<br>② 改善人机界面，向用户提供有好的工作环境</p>
<p>@@ <strong>磁盘格式化</strong>是指把一张空白的盘划分称一个个小区域并编号，以供计算机存储和读取数据，格式化是一种纯物理操作，实在磁盘的所有数据区上写0的操作过程，同时对硬盘介质做一致性检测，并且标记出不可读和坏的扇区。由于大部分硬盘在出厂时已经格式化过，所以有在硬盘介质产生错误时才需要进行格式化。<br><strong>磁盘分区</strong>是将磁盘划分成一块块的存储区域。在传统的磁盘管理中，将一个硬盘分为两大类分区：主分区和扩展分区。主分区是能够安装操作系统、能够进行计算机启动的分区，这样的分区可以直接格式化，然后安装系统，直接存放文件。<br>磁盘里的文件都是按存储时间先后来排列的，理论上文件之间都是紧凑排列而没有空隙的。但是，用户常常会对文件进行修改，而且新增加的内容并不是直接加到原文件的位置的，而是放在磁盘存储空间的最末尾，系统会在这两段之间加上联系标识。当有多个文件被修改后，磁盘里就会有很多不连续的文件。一旦文件被删除，所占用的不连 续空间就会空着，并不会被自动填满，而且，新保存的文件也不会放在这些地方，这些 空着的磁盘空间，就被称作”磁盘碎片”。因此，硬盘的每个分区里都会有碎片。碎片太多，其他的不连续文件相应也多，系统在执行文件操作时就会因反复寻找联系标识，工作效率大大降低，直接的反映就是感觉慢。磁盘清理将删除计算机上所有不需要的文件（这些文件由用户或系统进行确认）。<br><strong>磁盘碎片整理</strong>就是通过系统软件或者专业的磁盘碎片整理软件对电脑磁盘在长期使用过程中产生的碎片和凌乱文件重新整理，释放出更多的磁盘空间，可提高电脑的整体性能和运行速度。</p>
<p>@@ 在WinXP操作系统中，用户利用”<strong>磁盘管理</strong>“程序可以对磁盘进行初始化、创建卷，<strong>可以选择使用FAT、FAT32或NTFS文件系统格式化券</strong>，通常将<code>&quot;C:\Windows\myprogram.exe&quot;</code>文件设置成<strong>只读</strong>和<strong>隐藏</strong>属性，以便控制用户对该文件的访问。这一级安全管理称之为<strong>文件级</strong>安全管理。<br>文件级安全管理是通过系统管理员或文件组对文件设置来控制用户对文件的访问。用户对文件的访问，将由用户<strong>访问权、目录访问权、文件属性</strong>三者的权限所确定。</p>
<p>@@ 假设磁盘臂位于15号柱面上，进程的请求序列如下表表示，如果采用<strong>最短移臂调度算法</strong>，那么系统的响应序列应为<strong>⑤①②④③⑥</strong></p>
<table>
<thead>
<tr>
<th>请求序列</th>
<th>柱面号</th>
<th>磁头号</th>
<th>扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>①</td>
<td>12</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>②</td>
<td>19</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>③</td>
<td>23</td>
<td>9</td>
<td>6</td>
</tr>
<tr>
<td>④</td>
<td>19</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>⑤</td>
<td>12</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>⑥</td>
<td>28</td>
<td>3</td>
<td>10</td>
</tr>
</tbody></table>
<p><strong>最短移臂调度算法</strong>，即有限响应距离比较近磁道的申请<br>1.当磁头位于15号柱面 (柱面号即磁道编号)，请求序列分别位于12号柱面(①⑤)、19号柱面(②④)、23号柱面(③)、28号柱面(⑥)<br>2.距离15号柱面最近的应该是12号柱面(①⑤)，优先响应(①⑤)，次序不限；</p>
<p>@@ P(Pass)(通过)消耗一个信号量  V(释放)发送一个信号量<br>V(S1)唤醒P(S1)：<strong>收银员进程操作</strong>只有等待着<strong>购书者</strong>拿出去前台后才能触发</p>
<p>@@ PV操作是操作系统提供的具有特定功能的原语，利用PV操作可以<strong>实现资源的互斥使用</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37063785/article/details/88802580">软考必考题型之PV操作_pv操作中p和v各代表什么-CSDN博客</a></p>
<p>@@ 某计算机系统中互斥资源R的可用数为8，系统中有3个进程P1、P2和P3竞争R，且每个进程都需要i个R，该系统可能会发生死锁的最小i值为：<strong>4</strong><br>本题对于R资源可用数为8，分配到3个进程中，为了让最后的i值最小，所以每个进程尽量平均分配，可以得到3、3、2的分配情况，此时如果假设i的取值为3，则必定不会发生死锁，当i&gt;3时系统会产生死锁，此时取整，即最小i值为4</p>
<p>@@ 常用的进程控制块的组织方式有<strong>链接方式</strong>和<strong>索引方式</strong>：<br>采用<span style ="color:red"><strong><u>链接方式</u></strong></span>是把具有同一状态的PCB，用其中的链接字链接成一个队列。这样可以形成<strong>就绪队列</strong>、若干个<strong>阻塞队列</strong>和<strong>空白队列</strong>等。其中的就绪队列常按进程优先级的高低排列，把优先级高的进程的PCB排在队列前面。此外，也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I&#x2F;O操作完成的队列和等待分配内存的队列等。<br>采用<span style ="color:red"><strong><u>索引方式</u></strong></span>是系统根据所有进程的状态<u><strong>建立若干索引表</strong></u>。例如，<strong>就绪索引表、阻塞索引表</strong>，并把各索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。<br><img src="https://raw.githubusercontent.com/P-luminary/images/dddb1b1a79e0de02dd213d846e7b7c8045a9dc70/data/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97.jpg"  /></p>
<p>@@ 某系统中有3个并发进程竞争资源R，每个进程都需要5个R，那么至少有<u><strong>13</strong>个R</u>，才能保证系统不会发生死锁。[<u>每个进程所需资源数-1，再相加，就是发生死锁的临界资源数</u>]<br><code>3(5-1)+1&lt;=y</code> 所以y＝13个</p>
<pre><code class="java">某系统有n个进程，每个进程需要x个同类资源，系统不会产生死锁的最少资源是多少？
★ 设：最少资源数位y个，满足如下表达式即可：★
n(x-1)+1&lt;=y
每个进程需要x个资源，初始时給每个进程x-1个资源，最后再給一个格外的资源，每当一个进程运行完后马上释放其占有的资源，其它进程可以申请资源继续运行
</code></pre>
<p>@@ 某系统中仅有5个并发进程竞争某类资源，且都需要3个该类资源，那么至少有<strong>11</strong>个该类资源，才能保证系统不会发生死锁。5×(3-1)+1&#x3D;11</p>
<p>@@ 某计算机系统页面大小为4k，进程的页面变换表如下。若进程的逻辑地址为2D16H。该地址经过变换后，其物理地址应为<strong>4D16H</strong></p>
<table>
<thead>
<tr>
<th align="center">页号</th>
<th align="center">物理块号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>4</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>根据题意，页面大小为4k，逻辑地址2D16H所在<strong>页号为2</strong>，页内地址为D16H，查看表后可知<strong>物理块号为4</strong>，该地址i过变换后，其物理地址应为物理块号4拼接上页内地址D16H，即十六进制4D16H</p>
<p>@@ <em>让我们来看一下这道13年上半年的软设选择题：</em><span style = "color:red"> <strong>图(a)中<u>B</u>；</strong></span><br><img src="https://raw.githubusercontent.com/P-luminary/images/be02605405d236b87be94947a28e00f477fd4bdf/data/%E9%98%BB%E5%A1%9E%E8%8A%82%E7%82%B9%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%8A%82%E7%82%B9.jpg"></p>
<p><span style = "color:red"><strong>图(b)中<u>C</u></strong></span><br>A. P1、P2、P3都是非阻塞节点，该图可以化简，是非死锁的<br>B. P1、P2、P3都是阻塞节点，该图不可以化简，是死锁的<br><span style = "color:red">C. P2是阻塞节点，P1、P3是非阻塞节点，该图可以化简，是非死锁的</span><br>D. P1、P2是非阻塞节点，P3是阻塞节点，该图不可以化简，是死锁的</p>
<pre><code class="java">★ 如何看进程资源图呢？
P:进程    R:一类资源     R中的圆圈数：该类资源有几个
★ 字母箭头都是啥意思？
R→P(R指向P)：分配一份R类资源給进程P
P→R(P指向R)：进程P申请一份R类资源
★ 判断一个进程节点是否堵塞？
读图时，先看资源分配R→P，再看资源申请P→R
【注意】
读图时，不要将同时存在R→P、P→R双向箭头的情况理解成：
P先申请一个资源，R再分配一个资源给P！

可能存在的情况：
① R中所有资源分配出去了(R→P)，而此时还有进程P向R申请资源(P→R)
此时申请资源R的进程P：成为阻塞节点
② R中所有资源没有全部都分配出去了(R→P)，而此时还有进程P向R申请资源(P→R)
此时申请资源R的进程P：成为非阻塞节点

★ 判断一个进程资源图是否是死锁的？
如果所有节点都是阻塞的———此进程图不可以化简，是死锁的
如果有节点不是阻塞的————此进程图可以花间，是非死锁的
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
</code></pre>
<h6 id="图a"><a href="#图a" class="headerlink" title="图a"></a>图a</h6><pre><code class="java">R1一共有2个资源，给P1、P2各分配一个，已经无可分配资源
此时P2还向R1申请1个资源，因为没有资源可以申请了，所以P2会阻塞；

同理，R2一共有3个资源，给P1分配1个、P2分配2个，已经无可分配资源
此时P1还向R2申请1个资源，因为没有资源可以申请了，所以P1也会阻塞；

因为P1、P2节点都阻塞了，所以此图无法化简，是死锁的
</code></pre>
<h6 id="图b"><a href="#图b" class="headerlink" title="图b"></a>图b</h6><pre><code class="java">R1一共有2个资源，给P1、P3各分配一个，已经无可分配资源
此时P2还向R1申请1个资源，因为没有资源可以申请了，所以P2会阻塞；

R2一共有3个资源，给P2、P3各分配一个，还剩1个可分配资源
此时P1向R2申请1个资源，因为还有可分配资源，所以P1不会阻塞；
（此时P3也向R2申请1个资源，同理P3也不会阻塞）
【这里要特别注意：P1、P3虽然同时都在申请剩下的1个资源，但是并不意味着这个资源申请已经被响应了，从而造成死锁的现象】
--------------------------------------------------------------------------
R1出去两个资源，R1资源数为0，此时P2申请R1资源，P2阻塞。R2总资源数3，出去2个资源。P1,P3申请R2资源，P1,P3非阻塞。[R2资源有3个，已分配2个，P3申请1个R2资源可以得到满足，故进程P3可以进行完毕释放其占有的资源。这样可以使得P1、P3都变成非阻塞节点，得到所需资源进行完毕，因此，该进程资源图是可以化简的]
</code></pre>
<p>@@ 在支持多线程的操作系统中，假设进程P创建了若干个线程，那么<strong>该进程中某线程的栈指针</strong>是不能被这些线程共享的。<u>在同一进程中的各个线程都可以共享进程所拥有的资源</u>，如访问进程地址空间中的每一个虚地址；访问进程所拥有的已打开文件、定时器、信号量机构等，但是<u>不能共享进程中某线程的栈指针</u> </p>
<p>@@ 假设系统采用PV操作实现进程同步与互斥。若n个进程<strong>共享两台打印机</strong>，那么信号量S的取值范围为 <strong>-(n-2) ~ 2</strong>。信号量初值等于资源数量，即为2，由于同时最多有2个进程访问打印机，其余进程必须处理等待状态，故S的最小值为 <strong>-(n-2)</strong> </p>
<pre><code class="java">·每个进程开始的时候执行P操作(信号量减一操作)，结束的时候执行V操作(信号量加一操作)。P作挂起阻塞，V为激活唤醒。信号量的原则是从左到右，从上到下。
·假设系统采用PV操作实现进程同步与互斥，若n个进程共享两台打印机，那么信号量S的取值范围为-(n-2)~2。两台打印机，所以最多等待状态的进程数就是(n-2)，
★★如果没有进程申请打印机，打印机的信号量就是2★★
信号量的值小于0，表示没有可用的资源，其绝对值表示阻塞队列中等待该资源的进程数。

·同步信号量，值为可用资源的个数。信号量的值小于0，则线程进行等待；信号量的值大于0，表示值为可用资源的个数。初始值为0。
·互斥信号量，只有两个值：0和1。0表示资源被占用，线程等待；1表示资源没有被占用，线程可以进入。初始值为1。
</code></pre>
<p>@@ 假设系统中有n个进程<strong>共享3台扫描仪</strong>，并采用PV操作实现进程同步与互斥。若系统信号量S的当前值为-1，**<u>进程P1、P2又分别执行了一次P(S)操作</u><strong>，那么信号量S的值应为___。<br>[<strong>当有进程运行时</strong>,其他进程访问信号量,信号量就会减1。S&#x3D;-1-2]<br>[当进程执行P(S)操作时，它试图将信号量S的值减去1。因此，如果</strong><u>进程P1和P2都执行了一次P(S)操作</u>**，并且信号量S的初始值为-1，那么它们会尝试将S的值减去1两次，结果是S的值变为-3。这是因为当信号量S的值为-1时，两个进程都尝试将其减去1，每次减去1后，S的值分别变为-2和-3。所以最终S的值为-3]</p>
<p>@@ 假设系统采用PV操作实现进程同步与互斥，若有n个进程共享一台扫描仪，那么当信号量S的值为-3时，表示系统中有<strong>3</strong>个进程等待使用扫描仪<br>[信号量不用减1是因为<strong>本题并没有进程运行</strong>]</p>
<p>@@ 假设某分时系统采用简单时间片轮转法，当系统中的用户数为n、时间片为q时，系统对每个用户的相应时间T&#x3D;(n*q) [<u>在分时系统中是将把CPU的时间分成很短的时间片轮流地分配給各个终端用户</u>]</p>
<p>@@ 如果系统采用信箱通信方式，当进程调用Send原语被设置为”等信箱”状态时，其原因是<strong>指定的信箱中存满了信件</strong>；因为Send原语是发送原语，如果系统采用信箱通信方式，那么当进程调用Send原语被设置成”<strong>等信箱</strong>“状态时，意味着指定的信箱存满了信件，无可用空间</p>
<p>@@ <span style = "color:red"><strong>绝对路径</strong>从根目录\开始</span>，本题book2.doc的绝对路径为 <code>\MyDrivers\user2\</code><br><span style = "color:blue"><strong>相对路径</strong>从当前目录下一级开始</span>，本题book2.doc的相对路径为 <code>user2\</code></p>
<p>@@ 直接索引即索引直接指向物理块，可用表示逻辑块号范围：0-4号<br>一级索引即索引节点指向的物理块用来存放地址项，可用表示256个地址项，即256个物理块<br>二级索引即索引节点指向的物理块，存放的是一级索引的地址块地址。一共有256个地址块用来存放以及索引</p>
<p>@@ 某文件系统采用多级索引结构。若磁盘块的大小为1k字节，每个块号占3字节，那么采用二级索引时的文件最大长度为<strong>116281</strong>k字节 。<br>磁盘块的大小为1KB，每个块号需占3B，因此一个磁盘物理块可存放1024&#x2F;3&#x3D;341个块号(取整)<br>采用一级索引时的文件最大长度为：341×1024&#x2F;1024&#x3D;341KB<br>采用二级索引时的文件最大长度为：341×341×1024&#x2F;1024&#x3D;116281KB</p>
<p>@@ 若系统正在将<strong>系统目录</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。<br>影响文件系统可靠性因素之一是文件系统的一致性问题。<u>很多文件系统是先<strong>读取磁盘块到主存</strong>，在主存进行修改，修改完毕再写回磁盘。</u> <strong>一致性检查</strong>包括 <u>块的一致性检查</u> 和 <u>文件的一致性检查</u></p>
<p>@@ 双击”xxx.jpg”文件名时，系统会自动通过建立的<strong>文件关联</strong>来决定使用什么程序打开该图像文件</p>
<h6 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h6><p>@@ 若系统正在将<strong>目录</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。很多文件系统是先读取磁盘块到主存，在主存进行修改，修改完毕再写回磁盘。</p>
<p>@@ 若某计算机系统的I&#x2F;O接口与主存采用统一编址，则输入输出操作是通过<strong>访存</strong>指令来完成的。<br>常用的I&#x2F;O接口编制方法有两种：<br>一是<strong>内存单元统一编址</strong>[将I&#x2F;O接口中有关的寄存器或存储部件看作存储器单元，与主存中的存储单元统一编址。内存地址和接口地址统一在一个公共的地址空间里，<u>对I&#x2F;O接口的访问就如同对主存单元的访问一样，可以用访问内存单元的指令访问I&#x2F;O接口</u>]<br>二是<strong>单独编址</strong>[通过设置单独的I&#x2F;O地址空间，为接口中的有关寄存器或存储部件分配地址码，需要设置专门的I&#x2F;O指令进行访问。这种编址方式的优点是不占用主存的地址空间，访问主存的指令和访问接口的指令不同。]</p>
<p>@@ I&#x2F;O设备管理软件一般分为4个层次。具体层次从上往下分别是**<u>用户级I&#x2F;O层、设备无关I&#x2F;O层、设备驱动程序、中断处理程序、硬件</u>** [用户五官射中硬件]</p>
<table>
<thead>
<tr>
<th>用户级I&#x2F;O层：发出I&#x2F;O调用</th>
</tr>
</thead>
<tbody><tr>
<td>设备无关I&#x2F;O层：设备名解析、阻塞进程、分配缓冲区</td>
</tr>
<tr>
<td>设备驱动程序：设置寄存器、检查设备状态</td>
</tr>
<tr>
<td>中断处理程序：I&#x2F;O完成后唤醒设备驱动程序</td>
</tr>
<tr>
<td>硬件：完成具体的I&#x2F;O操作</td>
</tr>
</tbody></table>
<p>@@ DMA工作方式下，在<strong>主存与外设</strong>之间建立了直接的数据链路</p>
<p>@@ 计算机运行过程中，cpu需要与外设进行数据交换。采用**<u>中断方式和DMA方式</u><strong>控制技术时，CPU与外设可并行工作。</strong>程序查询<strong>和</strong>中断方式<strong>都需要CPU来执行程序指令进行数据的输入和输出，DMA方式则不同，这是<u>一种不经过CPU而</strong>直接从内存存取数据**的数据交换模式</u>。[DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传达，数据传达完毕再把信息反馈给CPU即可]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0ab1d3a552633777cd974d25748160cc91ad68a5/data/%E7%A3%81%E7%9B%98CT%E9%A2%98.jpg"></p>
<p>@@ 某磁盘有100个磁道，磁头从一个磁道移至另一个磁道需要6ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均距离为10个磁道，每块的旋转延迟时间及传输时间分别为100ms和20ms，则读取一个100块的文件需要<strong>18000</strong>ms。[访问一个数据块的时间应为寻道时间加旋转延迟时间及传输时间之和。根据题意，每块的旋转延迟时间及传输时间共需120ms，磁头从一个磁道移至另一个磁道需要6ms，但逻辑上相邻数据块的平均距离为10个磁道，即读完一个数据块到下一个数据块寻道时间需要60ms。通过上述分析，本题访问一个数据块的时间T&#x3D;120ms+60ms&#x3D;180ms，而读取一个100块的文件共需要18000ms。]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a5957207201dabc57750a4659ee50c53b8017761/data/%E7%A3%81%E7%9B%98%E8%87%82%E8%86%80%E5%93%8D%E5%BA%94%E5%BA%8F%E5%88%97%E9%A2%98.png"></p>
<p>@@ 假设某磁盘的每个磁道划分成9个物理块，每块存放1个逻辑记录。逻辑记录R0,RI,…,R8存放在同一个磁道上，记录的安排顺序如下表所示：如果磁盘的旋转速度为27ms／周，磁头当前处在RO的开始处。若系统顺序处理这些记录，使用单缓冲区，每个记录处理时间为3ms，则处理这9个记录的最长时间为<strong>246ms</strong>：若对信息存储进行优化分布后，处理9个记录的最少时间为<strong>54ms</strong> 。</p>
<table>
<thead>
<tr>
<th align="center">物理块</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑记录</td>
<td align="center">R0</td>
<td align="center">R1</td>
<td align="center">R2</td>
<td align="center">R3</td>
<td align="center">R4</td>
<td align="center">R5</td>
<td align="center">R6</td>
<td align="center">R7</td>
<td align="center">R8</td>
</tr>
</tbody></table>
<p>[因为系统使用的是单缓冲区，且顺序处理9个记录，每个记录处理时间为3ms，加上读写时间，总的时间就超过3ms了。而磁盘旋转一圈的时间为27ms，也就是说，当系统读取第0个记录后，正在处理的过程中，磁盘已经旋过了第1个记录。那么，要读取第1个记录，就需要磁盘再次旋转到第1个记录（即磁盘旋转1圈后，27+3&#x3D;30ms)。同理，要读取第2个记录时，也需要等30ms。这样，要读取后面8个记录，需要8x30&#x3D;240ms，同时加上处理第0个记录的时间（3ms）和处理第8个记录的时间（3ms)，共需246ms。] [对于第二种情况，若对信息进行分布优化的结果如下所示：从上表可以看出，当读出记录RI并处理结束后，磁头刚好转至R2记录的开始处，立即就可以读出并处理，因此处理9个记录的总时间为：<u>9X (3ms （读记录）+3ms （处理记录）)&#x3D;9X6ms&#x3D;54ms</u>]</p>
<p>@@ 在移臂调度算法中，<strong>先来先服务和最短寻找时间优先</strong>算法可能会随时改变移动臂的运动方向</p>
<p>@@ 概要设计文档的内容包括<strong>系统构架、模块划分、系统接口、数据设计</strong>四个方面</p>
<p>@@ 三层C&#x2F;S体系结构由逻辑上互相分离的**<u>表示层、业务层、数据层</u><strong>构成。其中</strong>表示层<strong>向客户提供数据，</strong>业务层<strong>实施业务相关数据规划，</strong>数据层**定义数据访问表中。</p>
<p>@@ 对软件过程的考虑：<u>在整体上按照<strong>瀑布模型</strong>的流程实施项目开发</u>，以方便对项目的管理；但在软件的实际创建中，则将软件系统按照功能分为许多增量构件，并以构件为单位逐个地创建与交付，直到全部增量构件创建完毕，并都被集成到系统之中交付用户使用。</p>
<table>
<thead>
<tr>
<th align="left">模型</th>
<th align="left">详情信息</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>增量</strong>模型</td>
<td align="left">又称渐增模型，也称为有计划的产品改进模型，从一组给定的需求开始，通过构造一系列可执行中间版本来实施开发活动。第一个版本纳入一部分需求，下一个版本纳入更多的需求，直到系统完成。每个中间版本都需要执行必需的过程、活动和任务。增量模型是 [<u>瀑布模型+原型</u>] 进化模型的综合<br />[增量模型具有非常显著的优越性，但增量模型对软件设计有更高的技术要求，特别是对软件体系结构，要求它具有很好的开放性与稳定性，能够顺利地实现构件的集成；<strong>不必等到整个系统开发完成就可以使用</strong>、<strong>可以使用较早的增量构件作为原型</strong>、<strong>优先级最高的服务先交付</strong>, 这样<u>最重要的服务接收最多的测试</u>。<span style = "color:red">其<strong>难点</strong>是<u>如何进行模块的划分</u></span>。]<br />融合了瀑布模型的基本成分和原型实现迭代的特征，该模型随着日程时间的进展而交错的线性序列。<br />增量式开发的<strong>主要优点包括</strong>：<br/>1．由于能够在较短的时间内向用户提交一些有用的工作产品，因此能够解决用户的一些急用功能。<br/>2．由于每次只提交用户部分功能，用户有较充分的时间学习和适应新的产品。<br/>3．对系统的可维护性是一个极大的提高，因为整个系统是由一个个构件集成在一起的，当需求变更时只变更部分部件，而不必影响整个系统。<br/><strong>主要缺点包括</strong>：<br/>1．由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。<br/>2．在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。<br/>3．增量包之间存在相交的情况且未很好处理</td>
</tr>
<tr>
<td align="left"><strong>瀑布</strong>模型</td>
<td align="left">将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段的过程。将软件生存周期各个活动规定为线性顺序链接的若干阶段的模型[<u>计划、分析、设计、编程、测试、维护</u>]。规定了由前至后，相互衔接的固定次序，如同瀑布流水，逐级下落。是一种理想的开发模式，但<span style = "color:red"><u><strong>缺乏</strong>灵活性，无法解决软件需求不明确或不准确的问题；不适用于开发初期对软件需求缺乏准确全面认识的情况</u></span>；<span style = "color:blue"><strong>优点</strong>：可强迫开发人员采用规范的方法；严格规定了各阶段必须提交的文档；要求每个阶段结束后，都要进行严格的审核。</span></td>
</tr>
<tr>
<td align="left"><strong>原型</strong>模式</td>
<td align="left">开发人员<u>快速地构造整个系统</u>或者<u>系统的一部分以理解或澄清问题</u>。增量模型是把软件产品作为一系列的增量构件来设计、编码、集成和测试，每个构件由多个相互作用的模块组成，并且能够完成特定的功能；并非所有的需求在系统开发之前都能准确地说明和定义。<span style = "color:blue">采用了动态定义需求的方法。适用于需求不明确的开发环境</span>；可以有效地捕获系统需求</td>
</tr>
<tr>
<td align="left"><strong>喷泉</strong>模型</td>
<td align="left">喷泉模型是典型的面向对象生命周期模型，在开发过程中<strong>以用户需求为动力</strong>，以对象为驱动，适合于面向对象的开发方法；<span style = "color:blue">喷泉模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性；模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统</span>；”喷泉”一词本身体现了迭代和无间隙特性。<strong>迭代意味着模型中的开发活动常常需要重复多次</strong>，在迭代过程中不断地完善软件系统；无间隙是指在开发活动之间不存在明显的边界。</td>
</tr>
<tr>
<td align="left"><strong>螺旋</strong>模型</td>
<td align="left">将开发活动和风险管理结合起来，以减小风险。将<u>瀑布模型</u>与<u>快速原型模型</u>结合起来，还增加了风险分析；螺旋模型包含了四个方面的活动：制订计划、风险分析、实施工程、客户评估，<span style = "color:blue">螺旋模型适用于<strong>复杂的大型软件</strong></span>；</td>
</tr>
</tbody></table>
<p>@@ 若用户<u>需求<strong>不清晰</strong></u>且经常发生变化，但<u>系统规模不太大且不太复杂</u>，则最适宜采用<strong>原型化</strong>开发方法<br>对于<u>数据处理领域不太复杂的软件，若系统规模不太大且不太复杂，需求变化也不大</u>，则最适宜采用<strong>结构化</strong>开发方法</p>
<p>@@ 软件工程的基本要素包括<strong>方法、工具、过程</strong></p>
<p>@@ 在<strong>概要</strong>设计阶段选择适当的解决方案，将系统分解为若干个子系统，建立整个系统的体系结构。<br>软件设计的任务是基于需求分析的结果建立各种设计模型，给出问题的解决方案。<br><strong>从工程管理的角度，可以将软件设计分为两个阶段：</strong><u>概要设计阶段</u>和<u>详细设计阶段</u>。<br><strong>概要设计阶段</strong>进行软件体系结构的设计、数据设计和接口设计；<br><strong>详细设计阶段</strong>进行数据结构和算法的设计。面向对象设计方法中，概要设计阶段进行体系结构设计、初步的类设计&#x2F;数据设计、结构设计：详细设计阶段进行构件设计。结构化设计和面向对象设计是两种不同的设计方法，结构化设计根据系统的数据流图进行设计，模块体现为函数、过程及子程序：面向对象设计基于面向对象的基本概念进行，模块体现为类、对象和构件等。</p>
<p>@@ “软件产品必须能够在3秒内对用户请求作出响应”属于软件需求中的<strong>非功能需求</strong>。<br>软件需求是软件系统必须完成的事以及必须具备的品质。软件需求包括<strong>功能需求、非功能需求和设计约束</strong>三个方面的内容。功能需求是所开发的软件必须具备什么样的功能：非功能需求是指产品必须具备的属性或品质，如可靠性、性能、响应时间和扩展性等等；设计约束通常对解决方案的一些约束说明。”软件产品必须能够在3秒内对用户请求作出响应”主要表述软件的响应时间，属于非功能需求</p>
<p>@@ 软件复杂性度量是软件度量的一个重要分支。参数有很多主要包括：<br>①<strong>规模</strong>。即指令数或者源程序行数；②<strong>难度</strong>。通常由程序中出现的操作数所决定的量来表示；<br>③<strong>结构</strong>。通常用与程序结构有关的度量来表示；④<strong>智能度</strong>。即算法的难易程度</p>
<p>@@ 基于构件的软件开发，主要强调在构建软件系统时复用已有的软件”构件”，在检索到可以使用的构件后，需要针对新系统的需求对构件进行<strong>合格性检验、适应性修改</strong>，然后集成到新系统中</p>
<p>@@ 程序的三种基本控制结构式<strong>顺序、选择和重复</strong></p>
<p>@@ 软件工程每一个阶段结束前，应该着重对可维护性进行复审。在系统设计阶段的复审期间，应该从<strong>容易修改、模块化和功能独立的目的</strong>出发，评价软件的结构和过程。可维护性式所有软件都具有的基本特点，必须在开发阶段保证软件具有可维护性的特点。</p>
<p>@@ I&#x2F;O软件隐藏了I&#x2F;O操作实现的细节。I&#x2F;O软件向用户提供的式逻辑接口。I&#x2F;O软件将硬件与较高层次的软件隔离开来，而最高层软件向硬件提供一个友好的、清晰的、统一的接口，方便用户使用。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/软考" style=color:#ffa2c4>
                软考
            </a>
        </span>
        
    </div>

    <a href="/2024/01/16/软考/软件设计师刷题考点/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/01/15/后端/SpringMVC[Mapping,中文乱码,Restful及跨域,JSON序列化,非简单请求,拦截器]/">
        <h2>
            SpringMVC[Mapping,中文乱码,Restful及跨域,JSON序列化,非简单请求,拦截器]
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring MVC入门</td>
<td>Spring MVC开发流程与环境配置</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>接收Web数据</td>
<td>Spring MVC参数接收与数据绑定</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>URL Mapping</td>
<td>讲解URL绑定过程</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>中文乱码问题</td>
<td>解决请求与相应中文乱码</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>拦截器</td>
<td>Spring MVC拦截器的使用</td>
<td>★★★</td>
</tr>
</tbody></table>
<h1 id="Restful开发风格-主流"><a href="#Restful开发风格-主流" class="headerlink" title="Restful开发风格 [主流]"></a>Restful开发风格 [主流]</h1><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Restful风格介绍</td>
<td>介绍Restful开发规范</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Restful开发实战</td>
<td>实例讲解Restful在Spring MVC中的实现</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>JSON序列化</td>
<td>通过相应输出数据</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Restful的跨域问题</td>
<td>分析跨域问题的来源与解决办法</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h3 id="Spring-MVC-Model-View-Controller-中介"><a href="#Spring-MVC-Model-View-Controller-中介" class="headerlink" title="Spring MVC[Model+View+Controller(中介)]"></a>Spring MVC[<u>Model+View+Controller(中介)</u>]</h3><p>比servlet方便许多 简化web程序的开发</p>
<ul>
<li>Spring MVC是Spring体系的轻量级Web MVC框架</li>
<li>Spring MVC的核心<strong>Controller</strong>控制器，用于处理请求，产生相应</li>
<li>Spring MVC基于Spring IOC容器运行，所有对象被IoC管理</li>
</ul>
<h6 id="学习向导"><a href="#学习向导" class="headerlink" title="学习向导"></a>学习向导</h6><ul>
<li>Spring MVC入门</li>
<li>Spring MVC数据绑定</li>
<li>Restful 开发风格</li>
<li>Spring MVC拦截器</li>
</ul>
<h3 id="Spring-MVC环境配置"><a href="#Spring-MVC环境配置" class="headerlink" title="Spring MVC环境配置"></a>Spring MVC环境配置</h3><h5 id="IDEA环境下创建Maven-WebApp"><a href="#IDEA环境下创建Maven-WebApp" class="headerlink" title="IDEA环境下创建Maven WebApp"></a>IDEA环境下创建Maven WebApp</h5><p>Project Structure 点加号 添加Web 右侧Path是Web描述符所存储的路径<br><code>C:\Users\Pluminary\Desktop\SpringMVC\src\main\webapp\WEB-INF\web.xml</code><br>Deployment descriptor version &#x3D;&gt; 3.1<br>下面的 Web Resource Directory【用于目录存储页面】<br><code>C:\Users\Pluminary\Desktop\SpringMVC\src\main\webapp</code><br>再次点下方的Create Artifact<br>右上角Type：<br><strong>Web Application: Exploded 目录方式运行</strong><br>Web Application: Archive 打包成war包运行<br>配置Tomcat Server &#x3D;&gt; Deployment 添加当前工程 SpringMVC:Web exploded<br>下面的Application context: 设置为 <strong>&#x2F;</strong>    只访问localhost即可<br>Server选项框里的 On ‘Update’ action: 把Restart server 改成 Update classes and resources【热部署】<br>当页面源代码发生变化时 不需要重启 </p>
<ul>
<li>Maven依赖Spring-WebMVC</li>
<li>web.xml配置DispatcherServlet</li>
<li>配置applicationContext的mvc标记</li>
<li>开发Controller控制器</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;first-springmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.28&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
&lt;!--    DispatchServlet 对所有请求进行拦截  --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
&lt;!--        DispatcherServlet是Spring MVC是最核心的对象
            DispatcherServlet用于拦截http请求
            并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理
--&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;!--        在Web应用启动时自动创建Spring IoC容器,并初始化DispatcherServlet --&gt;
&lt;!--        applicationContext.xml 初始化参数 启动时候加载--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
&lt;!--        &quot;/&quot; 所有请求都要拦截--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
&lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
   及子包中拥有以下注解的对象：
       @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
       @Service     ...Service类上 业务逻辑类
       @Controller 描述SpringMVC的控制器类
       @Component  无法确定的类型种类
   --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
&lt;!--    启用Spring MVC的注解开发模式--&gt;
    &lt;mvc:annotation-driven/&gt;
&lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/TestController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TestController &#123;
//  将当前的方法绑定某个get方式请求的url  //localhost/t
    @GetMapping(&quot;/t&quot;)
//  直接向响应输出字符串数据,不跳转页面
    @ResponseBody
    public String test()&#123;
        return &quot;SUCCESS&quot;;
    &#125;
&#125;
</code></pre>
<p>添加依赖jar包进入项目工程 配置tomcat服务<code>Run/Debug Configurations</code> 中的 <code>Deployment</code> 点一下小铅笔修改 将右侧的Avaliable Elements中的依赖包全部put进入<br><code>404bug 配置都正常无误 寻找一下项目工程里的out/artifacts/WEB-INF/web.xml</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4e2dcf96e18f478fddb9049b2544a008edd8f706/data/SpringMVC%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"></p>
<h3 id="Spring-MVC数据绑定"><a href="#Spring-MVC数据绑定" class="headerlink" title="Spring MVC数据绑定"></a>Spring MVC数据绑定</h3><h5 id="URL-Mapping-URL映射"><a href="#URL-Mapping-URL映射" class="headerlink" title="URL Mapping(URL映射)"></a>URL Mapping(URL映射)</h5><ul>
<li>URL Mapping指将URL与Controller方法绑定</li>
<li>通过将URL与方法绑定，SpringMVC便可通过Tomcat对外暴露服务</li>
</ul>
<h5 id="URL-Mapping注解"><a href="#URL-Mapping注解" class="headerlink" title="URL Mapping注解"></a>URL Mapping注解</h5><ul>
<li>@RequestMapping - 通用绑定  &#x2F;&#x2F;<u>在全局用则是通用请求映射访问前缀 若在方法上则不区分get&#x2F;post请求</u></li>
<li>@GetMapping - 绑定Get请求</li>
<li>@PostMapping - 绑定Post请求</li>
</ul>
<p><code>@GetMapping(&quot;/g&quot;)   ======   @RequestMapping(value=&quot;/g&quot;,method=RequestMethod.GET)</code></p>
<pre><code class="java">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;first-springmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
    &lt;!--    DispatchServlet 对所有请求进行拦截  --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        DispatcherServlet是Spring MVC是最核心的对象
                    DispatcherServlet用于拦截http请求
                    并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理
        --&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--        在Web应用启动时自动创建Spring IoC容器,并初始化DispatcherServlet --&gt;
        &lt;!--        applicationContext.xml 初始化参数 启动时候加载--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        &quot;/&quot; 所有请求都要拦截--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
       及子包中拥有以下注解的对象：
           @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
           @Service     ...Service类上 业务逻辑类
           @Controller 描述SpringMVC的控制器类
           @Component  无法确定的类型种类
       --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--    启用Spring MVC的注解开发模式--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/TestController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TestController &#123;
    @GetMapping(&quot;/t&quot;) //localhost/t
    @ResponseBody //直接向响应输出字符串数据,不跳转页面
    public String test()&#123;
        return &quot;Hello Spring MVC&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping (&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
    @GetMapping(&quot;/g&quot;)
    @ResponseBody
    public String getMapping()&#123;
        return &quot;This is get method&quot;;
    &#125;
//  直接访问会出错 post请求如何访问 用进行html表单提交
    @PostMapping(&quot;/p&quot;)
    @ResponseBody
    public String postMapping()&#123;
        return &quot;This is post method&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Controller方法参数接收请求参数"><a href="#Controller方法参数接收请求参数" class="headerlink" title="Controller方法参数接收请求参数"></a>Controller方法参数接收请求参数</h3><h5 id="接收请求参数的常用做法"><a href="#接收请求参数的常用做法" class="headerlink" title="接收请求参数的常用做法"></a>接收请求参数的常用做法</h5><ul>
<li><h6 id="使用Controller方法参数接收"><a href="#使用Controller方法参数接收" class="headerlink" title="使用Controller方法参数接收"></a>使用Controller方法参数接收</h6></li>
</ul>
<pre><code class="java">&lt;form action=&quot;/m1&quot; method=&quot;post&quot;&gt;
    &lt;input name=&quot;username&quot;/&gt;
    &lt;input name=&quot;password&quot;/&gt;
&lt;/form&gt;
----------------------------------------------------
@PostMapping(&quot;/m1&quot;)
@ResponseBody
public String post(String username, Long password)&#123;
    return username + &quot;:&quot; + password;
&#125;
</code></pre>
<p>特殊的注解<code>@RequestParam(&quot;&quot;)</code> 接收特殊自定义的参数</p>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequestMapping(&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
    @GetMapping(&quot;/g&quot;)
    @ResponseBody
    public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName) &#123;
        System.out.println(&quot;managerName:&quot;+managerName);
        return &quot;This is get method&quot;;
    &#125;

    //    直接访问会出错 post请求如何访问 用进行html表单提交
    @PostMapping(&quot;/p&quot;)
    @ResponseBody
    public String postMapping(String username, String password) &#123;
        System.out.println(username + &quot;:&quot; + password);
        return &quot;This is post method&quot;;
    &#125;
&#125;

=========================
网页中输入 http://localhost/um/g?manager_name=lily
控制台返回 managerName:lily
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><h6 id="使用Java-Bean接收数据"><a href="#使用Java-Bean接收数据" class="headerlink" title="使用Java Bean接收数据"></a>使用Java Bean接收数据</h6></li>
</ul>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​         用<strong>实体对象</strong><code>User</code>进行接收多个对象的创建和注入以及类型转换 [一次性完成]</p>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
@PostMapping(&quot;/p1&quot;)
    @ResponseBody //只要拥有User属性和参数 就可以一起赋值
    public String postMapping1(User user, String username)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;This is post method&quot;;
    &#125;
</code></pre>
<pre><code class="java">User.java
//标准的java bean
public class User &#123;
    private String username;
    private Long password;
&#125; Setter + Getter
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30254749/article/details/123139736">踩坑记录：IDEA web项目out artifacts文件夹只包含WEB-INF_out artifacts无法生成test.html-CSDN博客</a></p>
<h3 id="综合训练：学员调查问卷"><a href="#综合训练：学员调查问卷" class="headerlink" title="综合训练：学员调查问卷"></a>综合训练：学员调查问卷</h3><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ul>
<li>利用数组或者List接收请求中的复合数据</li>
<li>利用@RequestParam为参数设置默认值</li>
<li>使用Map对象接收请求参数及注意事项</li>
</ul>
<h5 id="URI绝对路径与相对路径"><a href="#URI绝对路径与相对路径" class="headerlink" title="URI绝对路径与相对路径"></a>URI绝对路径与相对路径</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/7faa031203ba69b146426bd6c3fa7431902da258/data/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%841.jpg"></p>
<h5 id="相对地址的应用案例"><a href="#相对地址的应用案例" class="headerlink" title="相对地址的应用案例"></a>相对地址的应用案例</h5><ul>
<li><code>&lt;form action=&quot;./apply&quot; method=&quot;post&quot;</code></li>
<li>页面地址：<a target="_blank" rel="noopener" href="http://localhost:8080/[%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84]/form.html">http://localhost:8080/[上下文路径]/form.html</a></li>
<li>提交地址：<a target="_blank" rel="noopener" href="http://localhost:8080/[%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84]/apply">http://localhost:8080/[上下文路径]/apply</a></li>
</ul>
<pre><code class="html">src/main/webapp/form.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;学员调查问卷&lt;/title&gt;
    &lt;style&gt;
        .container &#123;
            position: absolute;
            border: 1px solid #cccccc;
            left: 50%;
            top: 50%;
            width: 400px;
            height: 300px;
            margin-left: -200px;
            margin-top: -150px;
            box-sizing: border-box;
            padding: 10px;
        &#125;
        h2&#123;
            margin: 10px 0px;
            text-align: center;
        &#125;
        h3&#123;
            margin: 10px  0px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;h2&gt;学员调查问卷&lt;/h2&gt;
        &lt;form action=&quot;./apply&quot; method=&quot;post&quot;&gt;
        &lt;h3&gt;您的姓名&lt;/h3&gt;
        &lt;input name=&quot;name&quot; class=&quot;text&quot;  style=&quot;width: 150px&quot;&gt;
        &lt;h3&gt;您正在学习的技术方向&lt;/h3&gt;
        &lt;select name=&quot;course&quot; style=&quot;width: 150px&quot;&gt;
            &lt;option value=&quot;java&quot;&gt;Java&lt;/option&gt;
            &lt;option value=&quot;h5&quot;&gt;HTML5&lt;/option&gt;
            &lt;option value=&quot;python&quot;&gt;Python&lt;/option&gt;
            &lt;option value=&quot;php&quot;&gt;PHP&lt;/option&gt;
        &lt;/select&gt;
        &lt;div&gt;
&lt;!--复选框用数组 或 ArrayList接收--&gt;
            &lt;h3&gt;您的学习目的：&lt;/h3&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他
        &lt;/div&gt;
        &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt;
        &lt;/div&gt;
        &lt;/form&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果要接收复合数据 直接用数组接收是最简单的 但使用起来并不轻松<br>可以使用List来接收 但是前方记得要有<code>@RequestParam</code><br>更加高级的可以封装成一个对象 用List接收复合数据<br>Map只能接收单个数据 接收复合数据的时候会造成数据丢失</p>
<pre><code class="java">com/imooc/springmvc/controller/FormController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.Form;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.List;
import java.util.Map;

@Controller
public class FormController &#123;
//    @PostMapping(&quot;/apply&quot;)  ★★★第一次尝试★★★
    @ResponseBody
//    如果在请求中不包含默认值 =&gt; 取别名  默认值机制：ANON匿名
    public String apply(@RequestParam(value = &quot;n&quot;, defaultValue = &quot;ANON&quot;) String name, String course, Integer[] purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

//    @PostMapping(&quot;/apply&quot;)  ★★★第二次尝试★★★
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(String name, String course, @RequestParam List&lt;Integer&gt; purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

    @PostMapping(&quot;/apply&quot;)  
    //★★★★★ 推荐使用 ★★★★★
    // 实体类+List 极大简化表单工作量  
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(Form form)&#123;
        return &quot;SUCCESS&quot;;
    &#125;
    //不推荐直接使用Map导入数据 因为复合数据[数组数据]会丢失
&#125;
</code></pre>
<pre><code class="java">com/imooc/springmvc/entity/Form.java
public class Form &#123;
    private String name;
    private String course;
    private List&lt;Integer&gt; purpose;
&#125;Setter + Getter
</code></pre>
<h3 id="关联对象赋值"><a href="#关联对象赋值" class="headerlink" title="关联对象赋值"></a>关联对象赋值</h3><h5 id="复杂内容表单"><a href="#复杂内容表单" class="headerlink" title="复杂内容表单"></a>复杂内容表单</h5><pre><code class="html">用户名: &lt;input name=&quot;username&quot;&gt;
密码：&lt;input name=&quot;password&quot;&gt;
--------------------------------
姓名：&lt;input name=&quot;name&quot;&gt;
身份证号：&lt;input name=&quot;idno&quot;&gt;
过期时间：&lt;input name=&quot;expire&quot;&gt;
</code></pre>
<h6 id="面向对象设计-【关联对象赋值】"><a href="#面向对象设计-【关联对象赋值】" class="headerlink" title="面向对象设计 【关联对象赋值】"></a>面向对象设计 【关联对象赋值】</h6><pre><code class="java">public class User&#123;
    private String username;
    private String password;
    private IDcard idcard = new IDCard();
    //Getter + Setter
&#125;
★★ 关联上IDcard ★★
public class IDcard&#123;
    private String name;
    private String idno;
    private Date expire;
    //Getter + Setter
&#125;
</code></pre>
<pre><code class="html">用户名: &lt;input name=&quot;username&quot;&gt;
密码：&lt;input name=&quot;password&quot;&gt;
--------------------------------
姓名：&lt;input name=&quot;idcard.name&quot;&gt;
身份证号：&lt;input name=&quot;idcard.idno&quot;&gt;
过期时间：&lt;input name=&quot;idcard.expire&quot;&gt;
</code></pre>
<pre><code class="html">src/main/webapp/form.html
 &lt;div&gt;
            &lt;h3&gt;您的学习目的：&lt;/h3&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他
        &lt;/div&gt;
            &lt;h3&gt;收货人&lt;/h3&gt;
&lt;!--  private Delivery delivery = new Delivery() --&gt;
            &lt;input name=&quot;delivery.name&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt;
            &lt;h3&gt;联系电话&lt;/h3&gt;
            &lt;input name=&quot;delivery.mobile&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt;
            &lt;h3&gt;收货地址&lt;/h3&gt;
            &lt;input name=&quot;delivery.address&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt;

        &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt;
        &lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/entity/Form.java
public class Form &#123;
    private String name;
    private String course;
    private List&lt;Integer&gt; purpose;
    private Delivery delivery = new Delivery();
&#125; Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/springmvc/entity/Delivery.java
public class Delivery &#123;
    private String name;
    private String address;
    private String mobile;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/FormController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.Form;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.List;
import java.util.Map;

@Controller
public class FormController &#123;
//    @PostMapping(&quot;/apply&quot;)  第一次尝试
    @ResponseBody
//    如果在请求中不包含默认值 =&gt; 取别名  默认值机制：ANON匿名
    public String apply(@RequestParam(value = &quot;n&quot;, defaultValue = &quot;ANON&quot;) String name, String course, Integer[] purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

//    @PostMapping(&quot;/apply&quot;)  第二次尝试
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(String name, String course, @RequestParam List&lt;Integer&gt; purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

//    @PostMapping(&quot;/apply&quot;) 第三次尝试[这个可以 但有更好]
    // 实体类+List 极大简化表单工作量
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(Form form)&#123;
        return &quot;SUCCESS&quot;;
    &#125;

    @PostMapping(&quot;/apply&quot;)
    @ResponseBody
    public String applyDelivery(Form form)&#123;
        System.out.println(form.getDelivery().getName());
        return &quot;SUCCESS&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="日期类型转换"><a href="#日期类型转换" class="headerlink" title="日期类型转换"></a>日期类型转换</h3><p>①注解方法</p>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
@Controller
@RequestMapping(&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
@PostMapping(&quot;/p1&quot;)
    @ResponseBody
    public String postMapping1(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;This is post method&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;createTime&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<hr>
<p>②实体对象接收数据</p>
<pre><code class="java">com/imooc/springmvc/entity/User.java
//标准的java bean
public class User &#123;
    private String username;
    private Long password;
// SpringMVC会自动按照这个类型进行转换
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private Date createTime;
&#125; Getter + Setter
</code></pre>
<hr>
<p>③自定义转换器：全局的默认时间转换器</p>
<pre><code class="java">com/imooc/springmvc/converter/MyDateConverter.java
package com.imooc.springmvc.converter;

import org.springframework.core.convert.converter.Converter;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class MyDateConverter implements Converter&lt;String, Date&gt; &#123;
    public Date convert(String s) &#123; //转换工作
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            Date d = sdf.parse(s);
            return d;
        &#125; catch (ParseException e) &#123;
            return null;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
       及子包中拥有以下注解的对象：
           @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
           @Service     ...Service类上 业务逻辑类
           @Controller 描述SpringMVC的控制器类
           @Component  无法确定的类型种类
       --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--    启用Spring MVC的注解开发模式 让底下的转换类生效--&gt;
    &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;
    &lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--    通知SpringMVC有哪些转换类--&gt;
    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;!--    这是转换类定义的地方--&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;com.imooc.springmvc.converter.MyDateConverter&quot;/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h3><h5 id="Web应用的中文乱码由来"><a href="#Web应用的中文乱码由来" class="headerlink" title="Web应用的中文乱码由来"></a>Web应用的中文乱码由来</h5><ul>
<li>Tomcat默认使用字符集ISO-8859-1，属于西欧字符集</li>
<li>解决乱码的核心思路是将ISO-8859-1转换为UTF-8</li>
<li>Controller中请求与响应都需要设置UTF-8字符集</li>
</ul>
<h5 id="中文乱码的配置"><a href="#中文乱码的配置" class="headerlink" title="中文乱码的配置"></a>中文乱码的配置</h5><ul>
<li>Get请求乱码 - server.xml增加URIEncoding属性</li>
</ul>
<p>去Tomcat-conf文件中寻找server.xml进行增加</p>
<pre><code class="java"> &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot;
               URIEncoding=&quot;UTF-8&quot;
               maxParameterCount=&quot;1000&quot;
               /&gt;

===============================================
http://localhost/um/g?manager_name=丽丽
控制台：managerName:丽丽
</code></pre>
<ul>
<li>Post请求乱码 - web.xml配置CharacterEncodingFilter</li>
</ul>
<pre><code class="java">http://localhost/
输入:
张三  123456 2001-03-02
随后点击提交
控制台：??????:123456
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/web.xml
&lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<pre><code class="java">http://localhost/
输入:
张三  123456 2001-03-02
随后点击提交
控制台：张三:123456
</code></pre>
<ul>
<li>Response相应乱码 - Spring配置StringHttpMessageConverter</li>
</ul>
<h3 id="解决响应中的中文乱码"><a href="#解决响应中的中文乱码" class="headerlink" title="解决响应中的中文乱码"></a>解决响应中的中文乱码</h3><pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.User;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.Date;

@Controller
@RequestMapping(&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
    @GetMapping(&quot;/g&quot;)
    @ResponseBody
    public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName) &#123;
        System.out.println(&quot;managerName:&quot;+managerName);
        return &quot;This is get method&quot;;
    &#125;

    //    直接访问会出错 post请求如何访问 用进行html表单提交
    @PostMapping(&quot;/p&quot;)
    @ResponseBody
    public String postMapping(String username, Long password) &#123;
        System.out.println(username + &quot;:&quot; + password);
        return &quot;This is post method&quot;;
    &#125;

//    @PostMapping(&quot;/p1&quot;)
    @ResponseBody
    public String postMapping1(User user)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;This is post method&quot;;
    &#125;

    @PostMapping(&quot;/p1&quot;)
    @ResponseBody
    public String postMapping1(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;这是Post响应&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">User.java
//标准的java bean
public class User &#123;
    private String username;
    private Long password;
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private Date createTime;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/springmvc/converter/MyDateConverter.java
package com.imooc.springmvc.converter;

import org.springframework.core.convert.converter.Converter;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class MyDateConverter implements Converter&lt;String, Date&gt; &#123;
    public Date convert(String s) &#123; //转换工作
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            Date d = sdf.parse(s);
            return d;
        &#125; catch (ParseException e) &#123;
            return null;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;createTime&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
       及子包中拥有以下注解的对象：
           @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
           @Service    ...Service类上 业务逻辑类
           @Controller 描述SpringMVC的控制器类
           @Component  无法确定的类型种类
       --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--    启用Spring MVC的注解开发模式 让底下的转换类生效--&gt;
    &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;
&lt;!--        设置消息转换器--&gt;

        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
&lt;!--                转换什么呢？--&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
&lt;!--  在servlet中是直接  response.setContentType(&quot;text/html;charset=utf-8&quot;)  --&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;

    &lt;/mvc:annotation-driven&gt;
    &lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--    通知SpringMVC有哪些转换类--&gt;
    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;!--    这是转换类定义的地方--&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;com.imooc.springmvc.converter.MyDateConverter&quot;/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
    &lt;!--    DispatchServlet 对所有请求进行拦截  --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        DispatcherServlet是Spring MVC是最核心的对象
                    DispatcherServlet用于拦截http请求
                    并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理
        --&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--        在Web应用启动时自动创建Spring IoC容器,并初始化DispatcherServlet --&gt;
        &lt;!--        applicationContext.xml 初始化参数 启动时候加载--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        &quot;/&quot; 所有请求都要拦截--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="响应中产生结果-ModelAndView-x3D-gt-MVC高效解耦理念"><a href="#响应中产生结果-ModelAndView-x3D-gt-MVC高效解耦理念" class="headerlink" title="响应中产生结果 [ModelAndView &#x3D;&gt; MVC高效解耦理念]"></a>响应中产生结果 [<span style = "color:red">ModelAndView</span> &#x3D;&gt; MVC高效解耦理念]</h3><ul>
<li><p>@ResponseBody - 产生响应文本</p>
<ul>
<li>@ResponseBody直接产生响应体数据, 过程不涉及任何视图</li>
<li>@ResponseBody可产生标准字符串&#x2F;JSON&#x2F;XML等格式数据</li>
<li>@ResponseBody被StringHttpMessageConverter所影响</li>
</ul>
</li>
<li><p>ModelAndView - 利用模板引擎渲染输出</p>
<ul>
<li>ModelAndView对象是指”模型(数据)与视图(界面)”对象</li>
<li>通过ModelAndView可将包含数据对象与模板引擎进行绑定</li>
<li>SpringMVC中默认的View是JSP, 也可以配置其他模板引擎</li>
</ul>
</li>
</ul>
<blockquote>
<p>提问：为什么不直接访问view.jsp 而是绕了一个圈子还是同样的效果<br>回答：因为jsp页面是写死的如何将页面和数据绑定在一起呢？先通过访问&#x2F;um&#x2F;view这个controller让其方法中产生数据, 之后再将这个数据通过modelandview对象绑定到页面中才可以做到</p>
<p>从请求传来一个用户编号把数据查询出来得到一个user用户对象 然后再view.jsp中把刚刚查询的对象进行显示[动态的]</p>
</blockquote>
<h6 id="高效解耦"><a href="#高效解耦" class="headerlink" title="高效解耦"></a>高效解耦</h6><pre><code class="java">后端：com/imooc/springmvc/controller/URLMappingController.java
// http://localhost/um/view?userId=1 数据动态查询产生
    @GetMapping(&quot;/view&quot;)
    public ModelAndView showView(Integer userId)&#123;
        ModelAndView mav = new ModelAndView(&quot;/view.jsp&quot;);
        User user = new User();
        if (userId == 1)&#123;
            user.setUsername(&quot;lily&quot;);
        &#125;else if (userId == 2)&#123;
            user.setUsername(&quot;smith&quot;);
        &#125;
    //  在当前请求中增加一个对象 数据绑定view.jsp
        mav.addObject(&quot;u&quot;, user);
        return mav;
    &#125;
</code></pre>
<pre><code class="jsp">前端：src/main/webapp/view.jsp
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;I&#39;m view page&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Username:$&#123;u.username&#125;&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="ModelAndView-重定向"><a href="#ModelAndView-重定向" class="headerlink" title="ModelAndView [重定向]"></a><span style = "color:red">ModelAndView</span> [重定向]</h2><h6 id="SpringMVC若跳转页面需要使用此对象进行数据绑定"><a href="#SpringMVC若跳转页面需要使用此对象进行数据绑定" class="headerlink" title="[SpringMVC若跳转页面需要使用此对象进行数据绑定]"></a>[SpringMVC若跳转页面需要使用此对象进行数据绑定]</h6><ul>
<li>mav.addObject()方法设置的属性默认存放在当前请求中</li>
<li>默认ModelAndView使用请求转发(forward)至页面</li>
<li><strong>重定向</strong>使用 new ModelAndView(“<strong>redirect:</strong>&#x2F;index.jsp”) 新请求</li>
</ul>
<p>页面重定向使用时机：内部的controller处理逻辑和跳转页面之间没有直接关系时可以用”redirect:&#x2F;view.jsp”</p>
<pre><code class="java">ModelAndView mav = new ModelAndView(&quot;redirect:/view.jsp&quot;);
直接访问到了jsp  http://localhost/view.jsp

访问：http://localhost/um/view?userId=1
建立一个 没有斜杠的相对路径 src/main/webapp/um/view.jsp
com/imooc/springmvc/controller/URLMappingController.java
 // http://localhost/um/view?userId=1 数据动态查询产生
    @GetMapping(&quot;/view&quot;)
    public ModelAndView showView(Integer userId)&#123;
//        ModelAndView mav = new ModelAndView(&quot;redirect:/view.jsp&quot;);
        ModelAndView mav = new ModelAndView();
        mav.setViewName(&quot;view.jsp&quot;);
//        没有斜杠是代表相对路径 相对于@RequestMapping(&quot;/um&quot;)地址
//        mav.setViewName(&quot;view.jsp&quot;);

        User user = new User();
        if (userId == 1)&#123;
            user.setUsername(&quot;lily&quot;);
        &#125;else if (userId == 2)&#123;
            user.setUsername(&quot;smith&quot;);
        &#125;
//      在当前请求中增加一个对象 数据绑定view.jsp
        mav.addObject(&quot;u&quot;, user);
        return mav;
    &#125;
</code></pre>
<h5 id="String与ModelMap实现ModelAndView类似功能-工作中的小技巧"><a href="#String与ModelMap实现ModelAndView类似功能-工作中的小技巧" class="headerlink" title="String与ModelMap实现ModelAndView类似功能  [工作中的小技巧]"></a>String与ModelMap实现ModelAndView类似功能  [工作中的小技巧]</h5><pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
//   String 与 ModelMap[为模型数据] 返回字符串
//    Controller方法返回String的情况
//    1.方法被@ResponseBody描述, 则SpringMVC直接响应Spring字符串本身
//    2.方法不存在@ResponseBody, 则SpringMVC处理String指代的视图(页面)
// 这里的String是直接代替了@ResponseBody - 产生响应文本
    public String showView1(Integer userId, ModelMap modelMap)&#123;
        String view = &quot;/um/view.jsp&quot;;
        User user = new User();
        if (userId == 1)&#123;
            user.setUsername(&quot;lily&quot;);
        &#125;else if (userId == 2)&#123;
            user.setUsername(&quot;smith&quot;);
        &#125;
        modelMap.addAttribute(&quot;u&quot;, user);
        return view;
    &#125;
</code></pre>
<h3 id="SpringMVC整合Freemarker-项目：first-springmvc"><a href="#SpringMVC整合Freemarker-项目：first-springmvc" class="headerlink" title="SpringMVC整合Freemarker [项目：first-springmvc]"></a>SpringMVC整合Freemarker [项目：first-springmvc]</h3><h5 id="①-pom-xml引入依赖"><a href="#①-pom-xml引入依赖" class="headerlink" title="① pom.xml引入依赖"></a>① pom.xml引入依赖</h5><pre><code class="xml">要随时导入包 tomcat → Edit configuration → Deployment → Artifacts 将右侧包put in
&lt;dependency&gt;
  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
  &lt;version&gt;2.3.28&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
  &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="②-启用Freemarker模板引擎"><a href="#②-启用Freemarker模板引擎" class="headerlink" title="② 启用Freemarker模板引擎"></a>② 启用Freemarker模板引擎</h5><pre><code class="xml">applicationContext.xml
&lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
   &lt;!-- 设置响应输出，并解决中文乱码 --&gt; 
&lt;!-- 渲染完成后向客户端浏览器响应式 响应体中使用的字符集编码 --&gt;
   &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;&gt;&lt;/property&gt;
   &lt;!-- 指定Freemarker模板文件扩展名 --&gt;
   &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="③-本身配置Freemarker参数"><a href="#③-本身配置Freemarker参数" class="headerlink" title="③ 本身配置Freemarker参数"></a>③ 本身配置Freemarker参数</h5><pre><code class="xml">&lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
&lt;!-- 设置模板保存的目录 tomcat无法直接解析freemarker模板引擎 所以新增/WEB-INF/ftl --&gt;
   &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;
   &lt;!-- 其他模板引擎设置 --&gt;
   &lt;property name=&quot;freemarkerSettings&quot;&gt;
     &lt;props&gt;
         &lt;!-- 设置Freemarker脚本与数据渲染时使用的字符集 --&gt;
         &lt;!-- 模板与数据绑定渲染的过程中使用的字符集编码 --&gt;
         &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;
     &lt;/props&gt; 
   &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/ftl/test.ftl
&lt;h1&gt;$&#123;u.username&#125;&lt;/h1&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/FreemarkerController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
// http://localhost/fm/test  显示 andy
@Controller
@RequestMapping(&quot;/fm&quot;)
public class FreemarkerController &#123;
    @GetMapping(&quot;/test&quot;)
    public ModelAndView showTest()&#123;
//        因为之前配置所有配置扩展名是.ftl 所以下面不用写
        ModelAndView mav = new ModelAndView(&quot;/test&quot;);
        User user = new User();
        user.setUsername(&quot;andy&quot;);
        mav.addObject(&quot;u&quot;,user);
        return mav;
    &#125;
&#125;
=====================================================
// http://localhost/fm/test  显示 andy
</code></pre>
<h1 id="RESTful开发风格"><a href="#RESTful开发风格" class="headerlink" title="RESTful开发风格"></a>RESTful开发风格</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzvar/article/details/118164133">RESTful 风格（详细介绍 + 案例实现）_c# restful风格接口-CSDN博客</a></p>
<h3 id="REST与RESTful"><a href="#REST与RESTful" class="headerlink" title="REST与RESTful"></a>REST与RESTful</h3><ul>
<li>REST- 表现层状态转换, 资源在网络中以某种表现形式进行状态转移</li>
<li>RESTful是基于REST理念的一套开发风格, 是具体的开发规则</li>
</ul>
<h3 id="RESTful开发规范"><a href="#RESTful开发规范" class="headerlink" title="RESTful开发规范"></a>RESTful开发规范</h3><p>URL中所有的都是名词 请求都有不同的含义  返回的数据是JSON或者XML格式 </p>
<ul>
<li>使用URL作为用户交互入口</li>
<li>明确的语义规范(GET, POST, PUT, DELETE)</li>
<li>只返回数据(JSON, XML)不包含任何展现</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/13679a67b4eec21f54b5f30a53b45aafaf3fbebc/data/RESTful%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC.jpg" style="zoom: 67%;" />

<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@RestController</td>
<td>由 @Controller + @ResponseBody组成（返回 JSON 数据格式）</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到控制器处理方法的形参中</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>注解用于请求地址的解析，是最常用的一种注解</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>查询请求</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>添加请求</td>
</tr>
<tr>
<td>@PutMapping</td>
<td>更新请求</td>
</tr>
<tr>
<td>@DeleteMapping</td>
<td>删除请求</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）</td>
</tr>
</tbody></table>
<h3 id="RESTful命名要求"><a href="#RESTful命名要求" class="headerlink" title="RESTful命名要求"></a>RESTful命名要求</h3><table>
<thead>
<tr>
<th>URI</th>
<th>说明</th>
<th>修改建议</th>
</tr>
</thead>
<tbody><tr>
<td>GET &#x2F;articles?au&#x3D;lily</td>
<td><span style = "color:green">正确用法</span></td>
<td></td>
</tr>
<tr>
<td>GET &#x2F;a&#x2F;1</td>
<td><span style = "color:red">URI必须具有语义</span></td>
<td>GET &#x2F;student&#x2F;1</td>
</tr>
<tr>
<td>POST &#x2F;createArticle&#x2F;1</td>
<td><span style = "color:red">URI必须使用名词</span></td>
<td>POST &#x2F;article&#x2F;1</td>
</tr>
<tr>
<td>GET &#x2F;articles&#x2F;author&#x2F;1</td>
<td><span style = "color:red">URI扁平化, 不超两级</span></td>
<td>GET &#x2F;articles&#x2F;author?id&#x3D;1</td>
</tr>
<tr>
<td>DELETE&#x2F;articles&#x2F;1</td>
<td><span style = "color:red">URI名词区分单复数</span></td>
<td>GET &#x2F;articles?au&#x3D;lily<br />DELETE &#x2F;article&#x2F;1</td>
</tr>
</tbody></table>
<img src="https://raw.githubusercontent.com/P-luminary/images/1cd2b6c624167b8007e3b67c15b03d631b2d1e92/data/%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F%20URI%20%E5%92%8C%20RESTful%20%E9%A3%8E%E6%A0%BC%E5%AF%B9%E6%AF%94.jpg"  />

<h3 id="开发第一个RESTful应用"><a href="#开发第一个RESTful应用" class="headerlink" title="开发第一个RESTful应用"></a>开发第一个RESTful应用</h3><p><strong>404究极报错</strong><br>项目生成文件out&#x2F;artifacts&#x2F;XXX&#x2F;WEB-INF中没有导入lib包<br>没有将下面的web文件里的web.xml手动复制进去</p>
<pre><code class="xml">pom.xml 
写完pom.xml后记得在tomcat配置中的Deployment中加入依赖包
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;restful&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.restful&quot;/&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                        &lt;value&gt;application/json;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">web/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
package com.imooc.restful.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping(&quot;/restful&quot;)
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    @ResponseBody
    public String doGetRequest()&#123;
//  双引号中如果包括双引号 要用转义字符 \&quot;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;
&#125;

=======================================================
http://localhost/restful/request
&#123;&quot;message&quot;:&quot;返回查询结果&quot;&#125;
</code></pre>
<h3 id="实现RESTful实验室"><a href="#实现RESTful实验室" class="headerlink" title="实现RESTful实验室"></a>实现RESTful实验室</h3><pre><code class="java">com/imooc/restful/controller/RestfulController.java
package com.imooc.restful.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequestMapping(&quot;/restful&quot;)
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    @ResponseBody
    public String doGetRequest()&#123;
//  双引号中如果包括双引号 要用转义字符 \&quot;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;
    @PostMapping(&quot;/request&quot;)
    @ResponseBody
    public String doPostRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;&#125;&quot;;
    &#125;
    @PutMapping (&quot;/request&quot;)
    @ResponseBody
    public String doPutRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;
    @DeleteMapping(&quot;/request&quot;)
    @ResponseBody
    public String doDeleteRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据删除成功\&quot;&#125;&quot;;
    &#125;
&#125;
===========================
http://localhost/client.html
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.restful&quot;/&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                        &lt;!--只要响应产生就会使用utf-8字符集--&gt;
                        &lt;value&gt;application/json;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;restful&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="html">web/client.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        $(function () &#123;
            $(&quot;#btnGet&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;get&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
        $(function () &#123;
            $(&quot;#btnPost&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;post&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
        $(function () &#123;
            $(&quot;#btnPut&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;put&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
        $(function () &#123;
            $(&quot;#btnDelete&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;delete&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;发送Get请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPost&quot; value=&quot;发送Post请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPut&quot; value=&quot;发送Put请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnDelete&quot; value=&quot;发送Delete请求&quot;&gt;
    &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="RestController注解与路径变量"><a href="#RestController注解与路径变量" class="headerlink" title="RestController注解与路径变量"></a>RestController注解与路径变量</h3><p>在post请求中通过client.html利用Ajax动态注入了一个rid到RestfulController.java<br>代替了所有的@ResponseBody 默认向请求台进行输出</p>
<pre><code class="java">@Controller： 用于标识一个类是Spring MVC中的控制器，类似于标准的@Controller 注解。它告诉Spring框架该类是一个控制器，可以处理HTTP请求。

@ResponseBody： 用于将方法的返回值直接作为HTTP响应的主体（Body）内容。这意味着不会进行视图解析，而是直接将返回的对象（通常是JSON或XML）写入HTTP响应

因此，@RestController 的作用是将一个控制器类标记为RESTful风格的控制器，其中的每个方法都被视为返回数据，而不是视图。这样就不需要在每个方法上都添加 @ResponseBody 注解，因为该注解已经包含在 @RestController 中。
</code></pre>
<pre><code class="java">client.html
 $(function()&#123;
            $(&quot;#btnPost&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/request/100&quot;,
                    type : &quot;post&quot; ,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                   $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
    
package com.imooc.restful.controller;
import org.springframework.web.bind.annotation.*;
@RestController
@RequestMapping(&quot;/restful&quot;)
//@CrossOrigin(origins = &#123;&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;&#125;)
//@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600)
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doGetRequest() &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;

    // POST /article/1
    // POST /restful/request/100
    @PostMapping(&quot;/request/&#123;rid&#125;&quot;)
    //@ResponseBody
    public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId) &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;,\&quot;id\&quot;:&quot; + requestId + &quot;&#125;&quot;;
    &#125;

    @PutMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doPutRequest() &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;

    @DeleteMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doDeleteRequest() &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据删除成功\&quot;&#125;&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="简单请求与非简单请求"><a href="#简单请求与非简单请求" class="headerlink" title="简单请求与非简单请求"></a>简单请求与非简单请求</h3><ul>
<li>简单请求是指标准结构的HTTP请求, 对应GET&#x2F;POST请求</li>
<li>非简单请求是复杂要求的HTTP请求, 指PUT&#x2F;DELETE、扩展标准请求</li>
<li>两者最大区别是非简单请求发送前需要发送<strong>预检请求</strong> [看看能不能进行处理 可以才实际处理 预先处理不符合的数据挡在外面]</li>
</ul>
<pre><code class="xml">web.xml
&lt;!--    对put和delete请求进行支持--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.FormContentFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<pre><code class="java">web/client.html
$(function()&#123;
            $(&quot;#btnPost&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/request/100&quot;,
                    type : &quot;post&quot; ,
                    data : &quot;name=lily&amp;age=23&quot;,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id);
                    &#125;
                &#125;)
            &#125;);
        &#125;)

        $(function()&#123;
            $(&quot;#btnPut&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/request&quot;,
                    type : &quot;put&quot; ,
                    data : &quot;name=lily&amp;age=23&quot;,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
 // POST /article/1
    // POST /restful/request/100
    @PostMapping(&quot;/request/&#123;rid&#125;&quot;)
    //@ResponseBody
    public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;,\&quot;id\&quot;:&quot; + requestId + &quot;&#125;&quot;;
    &#125;

    @PutMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doPutRequest(Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;
====================
lily:23
</code></pre>
<p>创建一个Person用来插入数据 并打印在控制台</p>
<pre><code class="java">com/imooc/restful/entity/Person.java
public class Person &#123;
    private String name;
    private Integer age;
&#125;Getter + Setter
</code></pre>
<h3 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h3><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
一定要使用2.9以后的版本 之前的版本有严重的安全风险
</code></pre>
<pre><code class="java">http://localhost/restful/person?id=1
@GetMapping(&quot;/person&quot;)
//不返回String 返回JSON序列化的对象
    public Person findByPersonId(Integer id)&#123;
        Person p = new Person();
        if (id==1)&#123;
            p.setName(&quot;lily&quot;);
            p.setAge(23);
        &#125; else if (id==2) &#123;
            p.setName(&quot;smith&quot;);
            p.setAge(22);
        &#125;
        return p;
    &#125;
============================================
&#123;
    &quot;name&quot;: &quot;lily&quot;,
    &quot;age&quot;: 23
&#125;



http://localhost/restful/persons
@GetMapping(&quot;/persons&quot;)
    public List&lt;Person&gt; findPersons()&#123;
        List list = new ArrayList();
        Person p1 = new Person();
        p1.setName(&quot;lily&quot;);
        p1.setAge(23);
        list.add(p1);

        Person p2 = new Person();
        p2.setName(&quot;smith&quot;);
        p2.setAge(22);
        list.add(p2);
        
        return list;
    &#125;
=============================================
[
    &#123;
        &quot;name&quot;: &quot;lily&quot;,
        &quot;age&quot;: 23
    &#125;,
    &#123;
        &quot;name&quot;: &quot;smith&quot;,
        &quot;age&quot;: 22
    &#125;
]
</code></pre>
<p>服务器返回json数组</p>
<pre><code class="html">client.html
$(function()&#123;
            $(&quot;#btnPersons&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/persons&quot;,
                    type : &quot;get&quot; ,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        console.info(json);
                        for (var i=0; i&lt;json.length; i++)&#123;
                            var p = json[i];
                            $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;&lt;/h2&gt;&quot;)
                        &#125;
                    &#125;
                &#125;)
            &#125;);
        &#125;)

    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;发送Get请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPost&quot; value=&quot;发送Post请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPut&quot; value=&quot;发送Put请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnDelete&quot; value=&quot;发送Delete请求&quot;&gt;
    &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt;
    &lt;hr/&gt;
    &lt;!-- 点击btnPersons按钮时发送Ajax请求[上面有操作代码] 将所有人员信息追加到div中--&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPersons&quot; value=&quot;查询所有人员&quot;&gt;
    &lt;div id=&quot;divPersons&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
@GetMapping(&quot;/persons&quot;)
    public List&lt;Person&gt; findPersons()&#123;
        List list = new ArrayList();
        Person p1 = new Person();
        p1.setName(&quot;lily&quot;);
        p1.setAge(23);
        list.add(p1);

        Person p2 = new Person();
        p2.setName(&quot;smith&quot;);
        p2.setAge(22);
        list.add(p2);

        return list;
    &#125;

===============================================
http://localhost/client.html
点击查询所有人员
=&gt; 
lily-23
smith-22
</code></pre>
<p>增加时间！</p>
<pre><code class="java">Person.java
public class Person &#123;
    private String name;
    private Integer age;
// 记得用日期的格式化输出
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)
    private Date birthday;
&#125;Getter + Setter
</code></pre>
<pre><code class="html">client.html
$(function()&#123;
            $(&quot;#btnPersons&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/persons&quot;,
                    type : &quot;get&quot; ,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        console.info(json);
                        for (var i=0; i&lt;json.length; i++)&#123;
                            var p = json[i];
                            $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;-&quot; + p.birthday+ &quot;&lt;/h2&gt;&quot;)
                        &#125;
                    &#125;
                &#125;)
            &#125;);
        &#125;)

===================================
lily-23-2024-01-17 09:09:28
smith-22-2024-01-17 09:09:28
</code></pre>
<h3 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h3><ul>
<li>同源策略阻止从一个域加载的脚本去获取另一个域上的资源</li>
<li>只要<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>有任何一个不同，都被当做是不同的域</li>
<li>浏览器Console看到<strong>Access-Control-Allow-Origin</strong>就代表了跨域了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/161c64c96177be1c274357912c48055b196806cd/data/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%A4%BA%E4%BE%8B.jpg"></p>
<h3 id="HTML中允许跨域的标签"><a href="#HTML中允许跨域的标签" class="headerlink" title="HTML中允许跨域的标签"></a>HTML中允许跨域的标签</h3><ul>
<li>&lt; img &gt; - 显示远程图片</li>
<li>&lt; script &gt; - 加载远程JS</li>
<li>&lt; link &gt; - 加载远程CSS</li>
</ul>
<h3 id="CORS跨域资源访问"><a href="#CORS跨域资源访问" class="headerlink" title="CORS跨域资源访问"></a>CORS跨域资源访问</h3><ul>
<li>CORS是一种机制, 使用额外的HTTP头通知浏览器可以访问其他域</li>
<li>URL响应头包含 <strong>Access-Control-</strong>* 指明请求允许跨域</li>
</ul>
<h3 id="Spring-MVC解决跨域访问"><a href="#Spring-MVC解决跨域访问" class="headerlink" title="Spring MVC解决跨域访问"></a>Spring MVC解决跨域访问</h3><ul>
<li><strong>@CrossOrigin - Controller</strong>跨域注解</li>
<li>&lt; mvc:cors &gt; - Spring MVC全局跨域配置</li>
</ul>
<pre><code class="java">RestfulController.java [代码第四行]
@RestController
@RequestMapping(&quot;/restful&quot;)
//@CrossOrigin(origins = &#123;&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;&#125;)
//@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600) 所有端口都会访问发送请求
//maxAge = 3600 一小时时间后发送预检请求  之内的就发送实际请求 【非简单请求】
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doGetRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;

    // POST /article/1
    // POST /restful/request/100
    @PostMapping(&quot;/request/&#123;rid&#125;&quot;)
    //@ResponseBody
    public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;,\&quot;id\&quot;:&quot; + requestId + &quot;&#125;&quot;;
    &#125;

    @PutMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doPutRequest(Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;

    @DeleteMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doDeleteRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据删除成功\&quot;&#125;&quot;;
    &#125;

    @GetMapping(&quot;/person&quot;)
    public Person findByPersonId(Integer id)&#123;
        Person p = new Person();
        if (id==1)&#123;
            p.setName(&quot;lily&quot;);
            p.setAge(23);
        &#125; else if (id==2) &#123;
            p.setName(&quot;smith&quot;);
            p.setAge(22);
        &#125;
        return p;
    &#125;

    @GetMapping(&quot;/persons&quot;)
    public List&lt;Person&gt; findPersons()&#123;
        List list = new ArrayList();
        Person p1 = new Person();
        p1.setName(&quot;lily&quot;);
        p1.setAge(23);
        p1.setBirthday(new Date());
        list.add(p1);

        Person p2 = new Person();
        p2.setName(&quot;smith&quot;);
        p2.setAge(22);
        p2.setBirthday(new Date());
        list.add(p2);
        return list;
    &#125;
&#125;
</code></pre>
<h3 id="CORS全局配置"><a href="#CORS全局配置" class="headerlink" title="CORS全局配置"></a>CORS全局配置</h3><pre><code class="xml">&lt;mvc:cors&gt;
    &lt;mvc:mapping path=&quot;/restful/**&quot;
        allowed-origins=&quot;http://localhost:8080,http://www.imooc.com&quot;
        max-age=&quot;3600&quot;/&gt;
&lt;/mvc:cors&gt;
</code></pre>
<h3 id="SpringMVC拦截器-高级组件"><a href="#SpringMVC拦截器-高级组件" class="headerlink" title="SpringMVC拦截器 [高级组件]"></a>SpringMVC拦截器 [高级组件]</h3><h5 id="拦截器-Interceptor"><a href="#拦截器-Interceptor" class="headerlink" title="拦截器-Interceptor"></a>拦截器-Interceptor</h5><ul>
<li>拦截器(Interceptor)用于对URL请求进行前置&#x2F;后置过滤</li>
<li>Interceptor与Filter用途相似, 但实现方式不同</li>
<li>Interceptor底层基于Spring AOP面向切面编程实现[类似于<strong>环绕通知</strong>]</li>
</ul>
<h5 id="拦截器开发流程"><a href="#拦截器开发流程" class="headerlink" title="拦截器开发流程"></a>拦截器开发流程</h5><ul>
<li>Maven依赖servlet-api</li>
<li>实现HandlerInterceptor接口</li>
<li>applicationContext配置过滤地址</li>
</ul>
<h5 id="HandlerInterceptor接口"><a href="#HandlerInterceptor接口" class="headerlink" title="HandlerInterceptor接口"></a>HandlerInterceptor接口</h5><ul>
<li><strong>preHandle</strong> - 前置执行处理</li>
<li><strong>postHandle</strong> - 目标资源已被Spring MVC框架处理 没产生响应文本</li>
<li><strong>afterCompletion</strong> - 相应文本已经产生</li>
</ul>
<pre><code class="xml">pom.xml
     &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
&lt;!-- 只有在开发编译才会引用 打包最终使用的时候会排除在外 因为 servlet-api与tomcat-api冲突  --&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/interceptor/MyInterceptor.java
package com.imooc.restful.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyInterceptor implements HandlerInterceptor &#123;
//    Code -&gt; Implement Methods

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;准备执行&quot;);
        return true;
    &#125;

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;目标处理成功&quot;);
    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;响应内容已产生&quot;);
    &#125;
//  随后去applicationContext.xml配置
&#125;

=============================================================
/准备执行
/目标处理成功
/响应内容已产生
/准备执行
/目标处理成功
/响应内容已产生
/准备执行
/目标处理成功
/响应内容已产生
    
http://localhost/restful/persons
/restful/persons准备执行
/restful/persons目标处理成功
/restful/persons响应内容已产生
    
http://localhost/client.html
/client.html准备执行
/client.html目标处理成功
/client.html响应内容已产生
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
&lt;!--  哪些[所有]地址进行拦截 下面加个bean是哪个类进行处理[送到这个类中处理]--&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt;
            &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<h3 id="拦截器使用细则"><a href="#拦截器使用细则" class="headerlink" title="拦截器使用细则"></a>拦截器使用细则</h3><pre><code class="xml">applicationContext.xml
&lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
&lt;!--            哪些[所有]地址进行拦截 下面加个bean是哪个类进行处理[送到这个java中处理]--&gt;
       &lt;!-- &lt;mvc:mapping path=&quot;/**&quot;/&gt; --&gt;
            &lt;mvc:mapping path=&quot;/restful/**&quot;/&gt;
            &lt;mvc:mapping path=&quot;/webapi/**&quot;/&gt;
&lt;!--            以下是不需要拦截 排除在外的--&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt;
&lt;!--   创建一个resources  规范静态文件目录 一次性都排除在外--&gt;
            &lt;mvc:exclude-mapping path=&quot;/rescources/**&quot;/&gt;

            &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e1dbff67f8b3f8c785e7ca12d62741c295469782/data/%E5%A4%9AInterceptor%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg"></p>
<pre><code class="java">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;准备执行&quot;);
        return true;
    &#125;
通过preHandle的返回值可以做很多事情
对某一个url进行前置检查 对请求放行 如果不符合要求 直接在拦截器中返回相应
return true; 请求依次向后发送
return false; 请求被阻挡
</code></pre>
<h3 id="开发”用户流量”拦截器"><a href="#开发”用户流量”拦截器" class="headerlink" title="开发”用户流量”拦截器"></a>开发”用户流量”拦截器</h3><pre><code class="xml">pom.xml [引入新的依赖后一定要去Tomcat导入新的依赖包]
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">logback.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;[%thread] %d %level %logger&#123;10&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;accessHistoryLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;d:/logs/history.%d.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;[%thread] %d %level %logger&#123;10&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
    &lt;/root&gt;
    &lt;logger name=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot;
            level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;accessHistoryLog&quot;/&gt;
    &lt;/logger&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/interceptor/AccessHistoryInterceptor.java
package com.imooc.restful.interceptor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class AccessHistoryInterceptor implements HandlerInterceptor &#123;
    private Logger logger = LoggerFactory.getLogger(AccessHistoryInterceptor.class);
//    前置处理

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        StringBuilder log = new StringBuilder();
        log.append(request.getRemoteAddr());
        log.append(&quot;|&quot;);
        log.append(request.getRequestURL());
        log.append(&quot;|&quot;);
        log.append(request.getHeader(&quot;user-agent&quot;));
        logger.info(log.toString());
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/restful/interceptor/MyInterceptor.java
package com.imooc.restful.interceptor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyInterceptor implements HandlerInterceptor &#123;
//    Code -&gt; Implement Methods

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(request.getRequestURL() + &quot;-准备执行&quot;);
//        response.getWriter().print(&quot;[]&quot;);
        return true;
    &#125;

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(request.getRequestURL() + &quot;-目标处理成功&quot;);
    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(request.getRequestURL() + &quot;-响应内容已产生&quot;);
    &#125;
&#125;

==============================================================
http://localhost/client.html
[http-nio-80-exec-1] 2024-01-18 10:43:54,739 DEBUG o.s.w.s.DispatcherServlet - GET &quot;/login.html&quot;, parameters=&#123;&#125;
[http-nio-80-exec-1] 2024-01-18 10:43:54,750 DEBUG o.s.w.s.h.SimpleUrlHandlerMapping - Mapped to org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler@5c0e8bb9
[http-nio-80-exec-1] 2024-01-18 10:43:54,758 DEBUG o.s.w.s.DispatcherServlet - Completed 404 NOT_FOUND
[http-nio-80-exec-2] 2024-01-18 10:44:00,495 DEBUG o.s.w.s.DispatcherServlet - GET &quot;/restful/request&quot;, parameters=&#123;&#125;
[http-nio-80-exec-2] 2024-01-18 10:44:00,502 DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to public java.lang.String com.imooc.restful.controller.RestfulController.doGetRequest()
http://localhost/restful/request-准备执行
[http-nio-80-exec-2] 2024-01-18 10:44:00,539 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Using &#39;application/json;charset=utf-8&#39;, given [application/json, text/javascript, */*;q=0.01] and supported [text/html;charset=utf-8, application/json;charset=utf-8, text/plain, */*, application/json, application/*+json]
[http-nio-80-exec-2] 2024-01-18 10:44:00,539 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Writing [&quot;&#123;&quot;message&quot;:&quot;返回查询结果&quot;&#125;&quot;]
http://localhost/restful/request-目标处理成功
http://localhost/restful/request-响应内容已产生
[http-nio-80-exec-2] 2024-01-18 10:44:00,580 DEBUG o.s.w.s.DispatcherServlet - Completed 200 OK
[http-nio-80-exec-5] 2024-01-18 10:44:08,194 DEBUG o.s.w.s.DispatcherServlet - GET &quot;/restful/persons&quot;, parameters=&#123;&#125;
[http-nio-80-exec-5] 2024-01-18 10:44:08,195 DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to public java.util.List&lt;com.imooc.restful.entity.Person&gt; com.imooc.restful.controller.RestfulController.findPersons()
http://localhost/restful/persons-准备执行
RestfulController.findPersons() - return list
[http-nio-80-exec-5] 2024-01-18 10:44:08,211 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Using &#39;application/json&#39;, given [application/json, text/javascript, */*;q=0.01] and supported [application/json, application/*+json]
[http-nio-80-exec-5] 2024-01-18 10:44:08,211 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Writing [[com.imooc.restful.entity.Person@619c4d80, com.imooc.restful.entity.Person@71459fb]]
http://localhost/restful/persons-目标处理成功
http://localhost/restful/persons-响应内容已产生
===================================================================
D:\logs\history.2024-01-18
[http-nio-80-exec-1] 2024-01-18 10:43:54,755 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/login.html|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-2] 2024-01-18 10:44:00,502 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-5] 2024-01-18 10:44:08,195 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/persons|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-3] 2024-01-18 10:44:10,137 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request/100|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-4] 2024-01-18 10:44:10,935 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-6] 2024-01-18 10:44:11,481 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt;
            &lt;bean class=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<h3 id="Spring-MVC处理流程"><a href="#Spring-MVC处理流程" class="headerlink" title="Spring MVC处理流程"></a>Spring MVC处理流程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/42e2897ef9dc2075cb7c71f43c2a2e54e11ffea7/data/SpringMVC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/01/15/后端/SpringMVC[Mapping,中文乱码,Restful及跨域,JSON序列化,非简单请求,拦截器]/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/12/09/后端/Spring(切点表达式,通知,AOP,CGLib代理,Spring JdbcTemplate,事务)/">
        <h2>
            Spring
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/12/9
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><img src="https://raw.githubusercontent.com/P-luminary/images/8fdafeebf37a6ccf8de24be3ce4d857524f07204/data/Spring%E6%A8%A1%E5%9D%97.png" style="zoom: 200%;" />

<h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring框架介绍</td>
<td>Spring IoC、DI和AOP等核心概念</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Spring IoC容器</td>
<td>Spring实例化与管理对象</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>集合对象注入</td>
<td>注入List、Set、Map集合对象</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>底层原理</td>
<td>Spring Bean的生命周期</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>注解与Java Config</td>
<td>Spring注解分类和常用注解应用</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h6 id="不修改源代码的程序扩展"><a href="#不修改源代码的程序扩展" class="headerlink" title="不修改源代码的程序扩展"></a>不修改源代码的程序扩展</h6><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>理解AOP及名词</td>
<td>Spring AOP开发与配置流程</td>
<td>★★★★★★(面试)</td>
</tr>
<tr>
<td>五种通知类型</td>
<td>Spring五种通知类型与应用场景</td>
<td>★★★</td>
</tr>
<tr>
<td>切点表达式</td>
<td>PointCut切点表达式的语法规则及应用</td>
<td>★★</td>
</tr>
<tr>
<td>代理模式</td>
<td>JDK动态代理和CGLib代理的执行过程</td>
<td>★★★★★★(面试)</td>
</tr>
</tbody></table>
<h3 id="Spring-JDBC与声明式事务"><a href="#Spring-JDBC与声明式事务" class="headerlink" title="Spring JDBC与声明式事务"></a>Spring JDBC与声明式事务</h3><p>JDBC的扩展</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring JDBC</td>
<td>Spring JDBC的环境配置</td>
<td>★★★★</td>
</tr>
<tr>
<td>RestTemplate</td>
<td>基于RestTemplate实现SQL处理</td>
<td>★★★</td>
</tr>
<tr>
<td>配置声明式事务</td>
<td>声明式事务的配置过程</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>事务传播行为介绍</td>
<td>讲解常用事务传播行为的用途</td>
<td>★★★</td>
</tr>
<tr>
<td>声明式事务注解形式</td>
<td>基于注解使用声明式事务</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h1 id="★★★★★★-Spring-★★★★★★"><a href="#★★★★★★-Spring-★★★★★★" class="headerlink" title="★★★★★★  Spring  ★★★★★★"></a><span style = "color:red">★★★★★★  Spring  ★★★★★★</span></h1><p>IoC容器负责<strong>实例化</strong>，<strong>配置</strong>和<strong>组装</strong>对象。 IoC容器从XML文件获取信息并相应地工作。</p>
<p>IoC容器执行的主要任务是:</p>
<ul>
<li>实例化应用程序类</li>
<li>配置对象</li>
<li>组装对象之间的依赖关系</li>
</ul>
<p>有两种类型的IoC容器</p>
<ul>
<li><code>BeanFactory</code></li>
<li><code>ApplicationContext</code></li>
</ul>
<h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><h6 id="对象的控制权交给第三方进行管理-中间人"><a href="#对象的控制权交给第三方进行管理-中间人" class="headerlink" title="对象的控制权交给第三方进行管理(中间人)"></a>对象的控制权交给第三方进行管理(中间人)</h6><ul>
<li>IoC控制反转，全称Inverse of Control，是一种设计理念</li>
<li>由代理人来创建与管理对象，消费者通过代理人来获取对象</li>
<li>IoC的目的是降低对象之间直接耦合[更好适合对象之间的变化]</li>
<li>加入<strong>IoC容器</strong>将对象统一管理，让对象关联变为弱耦合</li>
</ul>
<p><strong>顾客</strong> ←(快递) <strong>果商冷冻仓库</strong> (批发)→ <strong>苹果</strong></p>
<h3 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h3><ul>
<li>IoC是设计理念，是现代程序设计遵循的标准，是宏观目标</li>
<li>DI(Dependency Injection)是具体技术实现，是微观实现</li>
<li>DI在Java中利用<strong>反射</strong>技术实现对象注入(Injection) [不同语言运用不同技术]</li>
</ul>
<h3 id="Spring含义"><a href="#Spring含义" class="headerlink" title="Spring含义"></a>Spring含义</h3><ul>
<li>Spring可以从广义和狭义两个角度看待</li>
<li>广义的Spring是指Spring生态系统</li>
<li>狭义的Spring是指Spring框架(Spring Framework)</li>
</ul>
<h5 id="广义的Spring生态体系"><a href="#广义的Spring生态体系" class="headerlink" title="广义的Spring生态体系"></a>广义的Spring生态体系</h5><ul>
<li>分布式微服务 SpringCloud</li>
<li>Reactive相应服务</li>
<li>Web apps 是 SpringMVC 中的</li>
<li>Serverless 无服务器内容</li>
<li>Event Driven 和 Batch</li>
<li>Spring Framework     Spring Boot     Spring Cloud     Spring Cloud Data Flow…</li>
</ul>
<h5 id="狭义的Spring框架"><a href="#狭义的Spring框架" class="headerlink" title="狭义的Spring框架"></a>狭义的Spring框架</h5><ul>
<li>Spring框架是企业开发复杂性的<strong>一站式</strong>解决方案</li>
<li>Spring框架的核心是<strong>IoC容器</strong>与<strong>AOP面向切面编程</strong></li>
<li>Spring IoC负责创建与管理系统对象，并在此基础上扩展功能(不修改源代码)</li>
</ul>
<h5 id="传统开发方式"><a href="#传统开发方式" class="headerlink" title="传统开发方式"></a>传统开发方式</h5><ul>
<li>对象直接引用导致对象硬性关联，程序难以扩展维护 new B new A</li>
</ul>
<h5 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h5><ul>
<li><p>IoC容器是Spring生态的地基，用于统一创建于管理对象依赖</p>
<p><strong>使用者</strong>直接<strong>提取</strong>Spring IoC容器中的已经将<strong>依赖</strong>ObjectB<strong>注入</strong>到ObjectA 直接提取A</p>
</li>
</ul>
<h5 id="Spring-IoC容器职责-宏观理念"><a href="#Spring-IoC容器职责-宏观理念" class="headerlink" title="Spring IoC容器职责 [宏观理念]"></a>Spring IoC容器职责 [宏观理念]</h5><ul>
<li>对象的控制权交由<strong>第三方</strong>统一管理 <u>(IoC控制反转)</u></li>
<li>利用Java<strong>反射</strong>技术实现<strong>运行时</strong>对象创建与关联 <u>(DI依赖注入)</u> [<strong>技术实现</strong>]</li>
<li>基于配置提高应用程序的可维护性与扩展性</li>
</ul>
<h3 id="Spring-IoC初体验"><a href="#Spring-IoC初体验" class="headerlink" title="Spring IoC初体验"></a>Spring IoC初体验</h3><h6 id="三个小孩吃三种不同的苹果"><a href="#三个小孩吃三种不同的苹果" class="headerlink" title="三个小孩吃三种不同的苹果"></a>三个小孩吃三种不同的苹果</h6><h5 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h5><p><strong>Apple.java</strong></p>
<pre><code class="java">public class Apple &#123;
    private String title;
    private String color;
    private String origin;
    Construct(空+满) Getter+Setter
&#125;
</code></pre>
<p><strong>Child.java</strong></p>
<pre><code class="java">public class Child &#123;
    private String name;
    private Apple apple;
    Construct(空+满) Getter+Setter
    public void eat()&#123;
        System.out.println(name + &quot;吃到了&quot; + apple.getOrigin() + &quot;种植的&quot; + apple.getTitle());
    &#125;
&#125;
</code></pre>
<p><strong>Application.java</strong></p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;

public class Application &#123;
    public static void main(String[] args) &#123;
        Apple apple1 = new Apple(&quot;红富士&quot;, &quot;红色&quot;, &quot;欧洲&quot;);
        Apple apple2 = new Apple(&quot;青苹果&quot;, &quot;绿色&quot;, &quot;中亚&quot;);
        Apple apple3 = new Apple(&quot;红富士&quot;, &quot;红色&quot;, &quot;欧洲&quot;);
        Child lily = new Child(&quot;莉莉&quot;,apple1);
        Child andy = new Child(&quot;安迪&quot;,apple2);
        Child luna = new Child(&quot;露娜&quot;,apple3);
        lily.eat();
        andy.eat();
        luna.eat();
    &#125;
&#125;
</code></pre>
<h5 id="Spring-IoC方式代码-不修改源代码-不用new-引入容器让对象统一管理"><a href="#Spring-IoC方式代码-不修改源代码-不用new-引入容器让对象统一管理" class="headerlink" title="Spring IoC方式代码[不修改源代码 不用new 引入容器让对象统一管理]"></a><span style = "color:red">Spring IoC方式代码</span>[不修改源代码 不用new 引入容器让对象统一管理]</h5><p><strong>pom.xml</strong></p>
<pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<p><strong>applicationContext.xml</strong> [静态信息可以放其中]  **<code>属性</code>**元素的 <u><strong>ref</strong> 属性用于定义另一个bean的引用。</u></p>
<pre><code class="java">SpringIoC核心配置文件 右键resources创建 所有对象的创建以及关联的设置都是在applicationContext.xml这里进行
Spring.io -&gt; Project -&gt; Spring Framework -&gt; LEARN -&gt; Reference Doc. -&gt;  Core

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt; 
并且加入配置Spring[出现在提示页面]

------------------------  更新一次  ------------------------
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;!--    在IoC容器启动时，自动由Spring实例化Apple对象，取名sweetApple放入到容器中  --&gt;
     &lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
            &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;sourApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;绿色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;softApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;沙果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中国&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;黄色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;rdApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;蛇果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;美国&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;lily&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;andy&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;安迪&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sourApple&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;luna&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;露娜&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;rdApple&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>SpringApplication.java</strong></p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        System.out.println(sweetApple.getTitle());
        //从IoC容器中提取beanId=lily的对象
        Child lily = context.getBean(&quot;lily&quot;, Child.class);
        lily.eat();
        Child andy = context.getBean(&quot;andy&quot;, Child.class);
        andy.eat();
        Child luna = context.getBean(&quot;luna&quot;, Child.class);
        luna.eat();
    &#125;
&#125;
————————————————————————————————————————————————————————————————————————————————————
红富士
莉莉吃到了欧洲种植的红富士
安迪吃到了中亚种植的青苹果
露娜吃到了美国种植的蛇果
</code></pre>
<p>利用IoC容器有利于对象与对象之间的<strong>解耦</strong>   springIoC大大提高了程序的维护与延展</p>
<h3 id="XML管理对象-Bean"><a href="#XML管理对象-Bean" class="headerlink" title="XML管理对象(Bean)"></a>XML管理对象(Bean)</h3><ul>
<li>基于XML配置Bean</li>
</ul>
<pre><code class="java">上述的吃苹果例题就是基于xml配置Bean
</code></pre>
<ul>
<li>基于注解配置Bean</li>
<li>基于Java代码配置Bean(java .config)</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
            &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
所有都要用bean标签 SpringIoC实例化以后在容器的唯一编号: id=&quot;sweetAppele&quot; SpringIoC就知道创建IoC容器时实例化一个Apple对象同时bean id=&quot;...&quot;
</code></pre>
<h5 id="XML方式创建IoC容器"><a href="#XML方式创建IoC容器" class="headerlink" title="XML方式创建IoC容器"></a>XML方式创建IoC容器</h5><pre><code class="xml">//创建IoC容器并根据配置文件创建对象
ApplicationContext context = new 
ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
</code></pre>
<h3 id="实例化Bean的三种方式"><a href="#实例化Bean的三种方式" class="headerlink" title="实例化Bean的三种方式"></a>实例化Bean的三种方式</h3><ul>
<li><span style = "color:red">基于构造方法对象实例化</span> (90%以上)</li>
</ul>
<h6 id="利用构造方法参数名实例化-推荐"><a href="#利用构造方法参数名实例化-推荐" class="headerlink" title="利用构造方法参数名实例化 [推荐]"></a>利用构造方法<span style = "color:red">参数名</span>实例化 [推荐]</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- 没有constructor-arg则代表调用默认构造方法实例化 --&gt;
  &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士&quot;/&gt;
  &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;           
  &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;     
&lt;/bean&gt;
</code></pre>
<p>Apple.java</p>
<pre><code class="java">public class Apple &#123;
    private String title;
    private String color;
    private String origin;

    public Apple() &#123;
        System.out.println(&quot;Apple对象已创建,&quot; + this);
    &#125;

    public Apple(String title, String color, String origin) &#123;
        System.out.println(&quot;通过带参构造方法创建对象&quot; + this);
        this.title = title;
        this.color = color;
        this.origin = origin;
    &#125;
    ......
</code></pre>
<p>SpringApplication.java</p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
___________________________________________________________________________
Apple对象已创建,com.imooc.spring.ioc.entity.Apple@39fb3ab6
通过带参构造方法创建对象com.imooc.spring.ioc.entity.Apple@1a968a59
</code></pre>
<h6 id="利用构造方法参数位置实例化"><a href="#利用构造方法参数位置实例化" class="headerlink" title="利用构造方法参数位置实例化"></a>利用构造方法<span style = "color:red">参数位置</span>实例化</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
  &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt;
  &lt;constructor-arg index=&quot;1&quot; value=&quot;欧洲&quot;/&gt;
  &lt;constructor-arg index=&quot;2&quot; value=&quot;红色&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li><h3 id="基于静态工厂实例化-在IoC容器之外通过程序组织对象"><a href="#基于静态工厂实例化-在IoC容器之外通过程序组织对象" class="headerlink" title="基于静态工厂实例化 (在IoC容器之外通过程序组织对象)"></a>基于静态工厂实例化 (在IoC容器之外通过程序组织对象)</h3></li>
</ul>
<pre><code class="java">AppleStaticFactory.java
package com.imooc.spring.ioc.factory;

import com.imooc.spring.ioc.entity.Apple;

public class AppleStaticFactory &#123;
    public static Apple createSweetApple()&#123; //静态工厂 用于创建对象的方法是静态的
        Apple apple = new Apple();
        apple.setTitle(&quot;红富士&quot;);
        apple.setOrigin(&quot;欧洲&quot;);
        apple.setColor(&quot;红色&quot;);
        return apple;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--利用静态工厂获取对象--&gt;
    &lt;bean id=&quot;apple4&quot; class=&quot;com.imooc.spring.ioc.factory.AppleStaticFactory&quot;
          factory-method=&quot;createSweetApple&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<hr>
<pre><code class="java">&lt;bean id=&quot;a&quot; class=&quot;com.nhooo.A&quot; factory-method=&quot;getA&quot;&gt;&lt;/bean&gt;
</code></pre>
<pre><code class="java">A.java
package com.nhooo;
public class A &#123;
private static final A obj=new A();
private A()&#123;System.out.println(&quot;private constructor&quot;);&#125;
public static A getA()&#123;
    System.out.println(&quot;factory method &quot;);
    return obj;
&#125;
public void msg()&#123;
    System.out.println(&quot;hello user&quot;);
&#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
&lt;bean id=&quot;a&quot; class=&quot;com.nhooo.A&quot; factory-method=&quot;getA&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">Test.java
package org.sssit;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test &#123;
public static void main(String[] args) &#123;
    ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    A a=(A)context.getBean(&quot;a&quot;);
    a.msg();
&#125;
&#125;
=============================================================
private constructor
factory method
hello user
</code></pre>
<ul>
<li><h3 id="基于工厂实例方法实例化"><a href="#基于工厂实例方法实例化" class="headerlink" title="基于工厂实例方法实例化"></a>基于工厂实例方法实例化</h3></li>
</ul>
<pre><code class="java">AppleFactoryInstance.java
package com.imooc.spring.ioc.factory;

import com.imooc.spring.ioc.entity.Apple;

/**
 * 工厂实例方法创建对象是指IoC容器对工厂类进行实例化并调用对应的实例方法创建对象的过程
 */
public class AppleFactoryInstance &#123;
    public Apple createSweetApple()&#123; //静态工厂 用于创建对象的方法是静态的
        Apple apple = new Apple();
        apple.setTitle(&quot;红富士&quot;);
        apple.setOrigin(&quot;欧洲&quot;);
        apple.setColor(&quot;红色&quot;);
        return apple;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--利用工厂实例方法获取对象--&gt;
    &lt;bean id=&quot;factoryInstance&quot; class=&quot;com.imooc.spring.ioc.factory.AppleFactoryInstance&quot;/&gt;
    &lt;bean id=&quot;apple5&quot; factory-bean=&quot;factoryInstance&quot; factory-method=&quot;createSweetApple&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="从IoC容器获取bean"><a href="#从IoC容器获取bean" class="headerlink" title="从IoC容器获取bean"></a>从IoC容器获取bean</h3><pre><code class="java">Apple sweetApple = context.getBean(&quot;sweetApple&quot;,Apple.class); 【推荐】
                    或者
Apple sweetApple = (Apple)context.getBean(&quot;sweetApple&quot;);
-------------------------------------------------------------
System.out.println(sweetApple.getTitle());
</code></pre>
<pre><code class="java">public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Apple apple4 = context.getBean(&quot;apple4&quot;, Apple.class); 【推荐】
        System.out.println(apple4.getTitle());
        
        Apple apple3 = (Apple)context.getBean(&quot;apple3&quot;);
        System.out.println(apple3.getTitle());
    &#125;
&#125;
</code></pre>
<h5 id="id与name属性相同点"><a href="#id与name属性相同点" class="headerlink" title="id与name属性相同点"></a>id与name属性相同点</h5><ul>
<li>bean id 与 name 都是设置对象在IoC容器中唯一标识</li>
</ul>
<pre><code class="java">&lt;bean id=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;bean name=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
</code></pre>
<ul>
<li>两者在同一个配置文件中都不允许出现重复</li>
<li>两者允许在多个配置文件中出现重复，新对象覆盖旧对象</li>
<li><span style = "color:red"><strong>id要求更为严格，一次只能定义一个对象标识</strong></span> 【推荐】</li>
<li><span style = "color:red"><strong>name更为宽松，一次允许定义多个对象标识</strong></span> </li>
<li>tips: id与name的命名要求有意义，按驼峰命名书写</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;bean id=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt;
        &lt;constructor-arg index=&quot;1&quot; value=&quot;欧洲&quot;/&gt;
        &lt;constructor-arg index=&quot;2&quot; value=&quot;红色&quot;/&gt;
        &lt;constructor-arg index=&quot;3&quot; value=&quot;19.8&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">applicationContext-1.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
 &lt;bean id=&quot;apple2&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
        &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士2号&quot;/&gt;
        &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
        &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;);
        Apple apple2 = context.getBean(&quot;apple2&quot;,Apple.class);
        System.out.println(apple2.getTitle());
        Apple apple3 = context.getBean(&quot;apple3&quot;,Apple.class);
        System.out.println(apple3.getTitle());
    &#125;
&#125;
______________________________________________________________________
红富士2号
红富士
</code></pre>
<blockquote>
<p>&lt; bean name &#x3D; “apple2, apple7”  class&#x3D;”com.imooc.spring.ioc.entity.Apple” &gt;<br>如果使用name(不使用id)可以在后面增加标识名<br>在没有id与name的bean默认使用类名全称作为bean标识<br>&lt; bean class&#x3D;”com.imooc.spring.ioc.entity.Apple” &gt; </p>
</blockquote>
<h3 id="路径匹配表达式"><a href="#路径匹配表达式" class="headerlink" title="路径匹配表达式"></a>路径匹配表达式</h3><h5 id="加载单个配置文件"><a href="#加载单个配置文件" class="headerlink" title="加载单个配置文件"></a>加载单个配置文件</h5><pre><code class="java">//创建IoC容器并根据配置文件创建对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
</code></pre>
<h5 id="加载多配置文件"><a href="#加载多配置文件" class="headerlink" title="加载多配置文件"></a>加载多配置文件</h5><pre><code class="java">String[] configLocations = new String[]&#123;&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;&#125;;
ApplicationContext context = new ClassPathXmlApplicationContext(configLocations);
</code></pre>
<h5 id="路径表达式-config-xml-x3D-ApplicationContext-xml"><a href="#路径表达式-config-xml-x3D-ApplicationContext-xml" class="headerlink" title="路径表达式 (config.xml &#x3D; ApplicationContext.xml)"></a>路径表达式 (config.xml &#x3D; ApplicationContext.xml)</h5><table>
<thead>
<tr>
<th>表达式实例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:config.xml</td>
<td>扫描classpath根路径(不包含jar)的config.xml</td>
</tr>
<tr>
<td>classpath:com&#x2F;imooc&#x2F;config.xml</td>
<td>扫描classpath下(不包含jar)com.imooc包中的config.xml</td>
</tr>
<tr>
<td>classpath*:com&#x2F;imooc&#x2F;config.xml</td>
<td>扫描classpath下(<strong>包含jar</strong>)com.imooc包中的config.xml</td>
</tr>
<tr>
<td>classpath:config-*.xml</td>
<td>扫描classpath根路径下所有以config-开头的XML文件</td>
</tr>
<tr>
<td>classpath:com&#x2F;**&#x2F;config.xml</td>
<td>扫描com包下(包含任何子包)的config.xml</td>
</tr>
<tr>
<td>file:c:&#x2F;config.xml</td>
<td>扫描c盘根路径config.xml</td>
</tr>
</tbody></table>
<h3 id="对象依赖注入"><a href="#对象依赖注入" class="headerlink" title="对象依赖注入"></a>对象依赖注入</h3><ul>
<li>依赖注入是指运行时将容器内对象利用<strong>反射</strong>赋給其他对象的操作</li>
<li><span style = "color:red"><strong>基于setter方法注入对象</strong></span></li>
</ul>
<h6 id="利用setter实现静态数值注入"><a href="#利用setter实现静态数值注入" class="headerlink" title="利用setter实现静态数值注入"></a>利用setter实现静态数值注入</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- IoC容器自动利用反射机制运行时调用setXXX方法为属性赋值 --&gt;
    &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt;
    &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt;
    &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
    &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h6 id="利用setter实现对象注入-【核心操作-ref-x3D-””】"><a href="#利用setter实现对象注入-【核心操作-ref-x3D-””】" class="headerlink" title="利用setter实现对象注入 【核心操作 ref&#x3D;””】"></a>利用setter实现对象注入 【<u>核心操作 ref&#x3D;””</u>】</h6><p>**<code>属性</code>**元素的 <u><strong>ref</strong> 属性用于定义另一个bean的引用。</u></p>
<pre><code class="java">&lt;bean id=&quot;lily&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
    &lt;!-- 利用ref注入依赖对象 --&gt;
    &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="java">Child.java   #创建好的apple对象赋予給参数进入setApple
public void setApple(Apple apple) &#123;
     System.out.println(&quot;注入的Apple对象：&quot; + apple);
     this.apple = apple;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        System.out.println(sweetApple.getTitle());
    &#125;
&#125;
</code></pre>
<h3 id="体验依赖注入的优势-高效解耦"><a href="#体验依赖注入的优势-高效解耦" class="headerlink" title="体验依赖注入的优势 (高效解耦)"></a>体验依赖注入的优势 (高效解耦)</h3><pre><code class="xml">applicatioinContext-dao.xml    #用于数据库的增删改查
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookDao&quot; class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoImpl&quot;&gt;
//如果更改了数据库类型 只需要重新创建一个java实现接口BookDao的insert 之后只需更改class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoOracleImpl&quot;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">applicatioinContext-service.xml 
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookService&quot; class=&quot;com.imooc.spring.ioc.bookshop.service.BookService&quot;&gt;
&lt;!--        id=bookDao     --&gt;
       &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">BookDao.java
package com.imooc.spring.ioc.bookshop.dao;

public interface BookDao &#123;
    public void insert();
&#125;
</code></pre>
<pre><code class="java">BookDaoImpl.java
package com.imooc.spring.ioc.bookshop.dao;

public class BookDaoImpl implements BookDao&#123;
    @Override
    public void insert() &#123;
        System.out.println(&quot;向mysql book表插入数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">BookService.java
package com.imooc.spring.ioc.bookshop.service;

import com.imooc.spring.ioc.bookshop.dao.BookDao;

public class BookService &#123;
    private BookDao bookDao; //接口将在ioc启动的时候动态注入
    public void purchase()&#123;
        System.out.println(&quot;正在执行图书采购业务方法&quot;);
        bookDao.insert();
    &#125;
    public BookDao getBookDao()&#123;
        return bookDao;
    &#125;
    public void setBookDao(BookDao bookDao)&#123;
        this.bookDao = bookDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">BookShopApplication.java
package com.imooc.spring.ioc.bookshop;

import com.imooc.spring.ioc.bookshop.service.BookService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class BookShopApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-*.xml&quot;);
        BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class);
        bookService.purchase();
    &#125;
&#125;
</code></pre>
<h3 id="利用构造方法实现对象依赖注入"><a href="#利用构造方法实现对象依赖注入" class="headerlink" title="利用构造方法实现对象依赖注入"></a>利用构造方法实现对象依赖注入</h3><h5 id="对象依赖注入-1"><a href="#对象依赖注入-1" class="headerlink" title="对象依赖注入"></a>对象依赖注入</h5><ul>
<li>依赖注入是指运行时将容器内对象利用<strong>反射</strong>赋給其他对象的操作</li>
<li><span style="color:red"><strong>基于setter方法注入对象</strong></span></li>
<li>基于构造方法注入对象</li>
</ul>
<pre><code class="java">【com.imooc.spring.ioc.entity】
Child.java + Apple.java 

Apple.java中可以加一个
public void apple()&#123;
        System.out.println(origin+&quot;国家&quot; +color+&quot;的&quot;+title+&quot;食物&quot;);
    &#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.Apple.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;/&gt;
        &lt;property name=&quot;color&quot; value=&quot;绿色&quot;/&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;lily&quot; class=&quot;com.imooc.Apple.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">package com.imooc.Apple;

import com.imooc.Apple.entity.Apple;
import com.imooc.Apple.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-*.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        Child lily = context.getBean(&quot;lily&quot;, Child.class);
        // 添加打印语句，检查属性是否正确注入
        System.out.println(&quot;lily&#39;s name: &quot; + lily.getName());
        System.out.println(&quot;lily&#39;s apple origin: &quot; + lily.getApple().getOrigin());
        System.out.println(&quot;lily&#39;s apple title: &quot; + lily.getApple().getTitle());
        System.out.println(&quot;====================================&quot;);
//        System.out.println(sweetApple.getTitle()+sweetApple.getColor()+sweetApple.getOrigin());
        lily.eat();
        sweetApple.apple();
    &#125;
&#125;
</code></pre>
<h3 id="注入集合对象-1"><a href="#注入集合对象-1" class="headerlink" title="注入集合对象_1"></a>注入集合对象_1</h3><h5 id="注入List-允许重复数据"><a href="#注入List-允许重复数据" class="headerlink" title="注入List [允许重复数据]"></a>注入List [允许重复数据]</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someList&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;具体值&lt;/value&gt;
        &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt;
    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Set-不允许重复数据-自动去除重复"><a href="#注入Set-不允许重复数据-自动去除重复" class="headerlink" title="注入Set  [不允许重复数据 自动去除重复]"></a>注入Set  [不允许重复数据 自动去除重复]</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someSet&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;具体值&lt;/value&gt;
      &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt;
    &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Map"><a href="#注入Map" class="headerlink" title="注入Map"></a>注入Map</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someMap&quot;&gt;
    &lt;Map&gt;
        &lt;entry key=&quot;k1&quot; value=&quot;v1&quot;&gt;&lt;/entry&gt; #静态数值
      &lt;entry key=&quot;k2&quot; value-ref=&quot;beanId&quot;&gt;&lt;/entry&gt; #对象引用
    &lt;/Map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Properties"><a href="#注入Properties" class="headerlink" title="注入Properties"></a>注入Properties</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someProperties&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt;
      &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt;
    &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="公司资产配置清单-小案例"><a href="#公司资产配置清单-小案例" class="headerlink" title="公司资产配置清单[小案例]"></a>公司资产配置清单[小案例]</h3><p><strong>constructor-arg：通过 构造函数注入 。</strong></p>
<p><strong>property：通过 setter对应的方法注入</strong> 。</p>
<pre><code class="java">Company.java
package com.imooc.spring.ioc.entity;

import java.util.List;
import java.util.Map;
import java.util.Properties;

public class Company &#123;
    private List&lt;String&gt; rooms;
    private Map&lt;String,Computer&gt; computers; //每一条数据保存的都是Computer型
    private Properties info;//键值对的写

    @Override
    public String toString() &#123;
        return &quot;Company&#123;&quot; +
                &quot;rooms=&quot; + rooms +
                &quot;, computers=&quot; + computers +
                &quot;, info=&quot; + info +
                &#39;&#125;&#39;;
    &#125;
    + Getter Setter
&#125;
</code></pre>
<pre><code class="java">Computer.java
public class Computer &#123;
    private String brand;
    private String type;
    private String sn;
    private Float price;
    constructor(空+满)+Getter Setter
&#125;
</code></pre>
<p>如何在ioc容器创建后自动的实例化Company对象并且填充信息呢?<br>所有的工作都在<code>applicationContext.xml</code>中进行的</p>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;list&gt; //【允许重复】
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Company;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Company company = context.getBean(&quot;company&quot;, Company.class);
        System.out.println(company);
    &#125;
&#125;
------------------------------------------------------------
Company&#123;rooms=[2001-总裁办, 2003-总经理办公室, 2010-研发部会议室], computers=null, info=null&#125;

Process finished with exit code 0
------------------------------------------------------------
下方xml更新后的显示数据：
Company&#123;rooms=[2001-总裁办, 2003-总经理办公室, 2010-研发部会议室], computers=&#123;dev-88172=Computer&#123;brand=&#39;联想&#39;, type=&#39;台式机&#39;, sn=&#39;8389283012&#39;, price=3085.0&#125;, dev-88173=Computer&#123;brand=&#39;联想&#39;, type=&#39;台式机&#39;, sn=&#39;8389283012&#39;, price=3085.0&#125;&#125;, info=&#123;phone=010-12345678, address=北京市朝阳区XX路XX大厦, website=https://p-luminary.github.io&#125;&#125;
https://p-luminary.github.io

Process finished with exit code 0
</code></pre>
<p>list的底层是ArrayList<br>Set的底层是LinkedHashSet [双向有序列表]<br>Map的底层是LinkedHashMap [双向列表 提取也是存放顺序]</p>
<pre><code class="xml">applicationContext.xml [更新一次]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;c1&quot; class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name=&quot;computers&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;dev-88172&quot; value-ref=&quot;c1&quot;/&gt; &lt;!-- 对象引用c1在上方 --&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;

或者【简便方法】↓
</code></pre>
<pre><code class="xml">applicationContext.xml 更新二次【新增简便方法】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;c1&quot; class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;【方法一】
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        
        &lt;property name=&quot;computers&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;dev-88172&quot; value-ref=&quot;c1&quot;/&gt; &lt;!-- 对象引用c1在上方 --&gt;
                &lt;entry key=&quot;dev-88173&quot;&gt;【方法二 (推荐)】
                    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
                        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
                        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
                        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
                        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;phone&quot;&gt;010-12345678&lt;/prop&gt;
                &lt;prop key=&quot;address&quot;&gt;北京市朝阳区XX路XX大厦&lt;/prop&gt;
                &lt;prop key=&quot;website&quot;&gt;https://p-luminary.github.io&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/43856e9419b6b12dba03ffb97458b89e4dd7ec1e/data/constructor%E4%B8%8Eproperty%E5%8C%BA%E5%88%AB.jpg"></p>
<h3 id="查看容器内对象-【-getBeanDefinitionNames-】"><a href="#查看容器内对象-【-getBeanDefinitionNames-】" class="headerlink" title="查看容器内对象 【.getBeanDefinitionNames()】"></a>查看容器内对象 【.getBeanDefinitionNames()】</h3><pre><code class="java">多个同类型的bean会自动增加编号 #1  #2
    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;微星&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3000&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;华硕&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;9023283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;5600&quot;/&gt;
    &lt;/bean&gt;

//获取容器内所有beanId数组       
        String[] beanNames = context.getBeanDefinitionNames();
        for (String beanName:beanNames)&#123;
            System.out.println(beanName); //c1 company ...&lt;bean id=&quot;...&quot;&gt;
             System.out.println(&quot;类型：&quot; + context.getBean(beanName).getClass().getName());
            System.out.println(&quot;内容：&quot; + context.getBean(beanName).toString());
        &#125;
        Computer computer = context.getBean(&quot;com.imooc.spring.ioc.entity.Computer&quot;, Computer.class);
        System.out.println(computer.getBrand());
        Computer computer1 = context.getBean(&quot;com.imooc.spring.ioc.entity.Computer#1&quot;, Computer.class);
        System.out.println(computer1.getBrand());
</code></pre>
<h3 id="bean-scope属性"><a href="#bean-scope属性" class="headerlink" title="bean scope属性"></a>bean scope属性</h3><ul>
<li>bean scope属性用于决定对象何时被创建与作用范围</li>
<li>bean scope配置将影响容器内对象的数量</li>
<li>bean scope默认值singleton(单例), 指全局共享同一个对象实例</li>
</ul>
<h5 id="scope用法"><a href="#scope用法" class="headerlink" title="scope用法"></a>scope用法</h5><pre><code class="java">&lt;bean id=&quot;bookDao&quot;
    class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoOracleImpl&quot;
    scope=&quot;prototype&quot;/&gt;
</code></pre>
<h5 id="bean-scope属性清单"><a href="#bean-scope属性清单" class="headerlink" title="bean scope属性清单"></a>bean scope属性清单</h5><table>
<thead>
<tr>
<th>scope属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span style = "color:red">singleton</span></td>
<td><span style = "color:red">单例(默认值),每一个容器有且只有唯一的实例,实例被全局共享</span></td>
</tr>
<tr>
<td><span style = "color:red">prototype</span></td>
<td><span style = "color:red">多例,每次使用时都是创建一个实例</span></td>
</tr>
<tr>
<td>request</td>
<td>web环境下,每一个独立请求存在唯一实例</td>
</tr>
<tr>
<td>session</td>
<td>web环境下,每一个session存在有唯一实例</td>
</tr>
<tr>
<td>application</td>
<td>web环境下,ServletContext存在唯一实例</td>
</tr>
<tr>
<td>websocket</td>
<td>每一次WebSocket连接中存在唯一实例</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/59d168487d0ef9aa2a23cf8057d454e1d3f26fc9/data/singleton%E4%B8%8Eprototype%E6%AF%94%E8%BE%83%E5%9B%BE.png"></p>
<h5 id="singleton与prototype对比"><a href="#singleton与prototype对比" class="headerlink" title="singleton与prototype对比"></a>singleton与prototype对比</h5><table>
<thead>
<tr>
<th></th>
<th>singleton</th>
<th>prototype</th>
</tr>
</thead>
<tbody><tr>
<td>对象数量</td>
<td>全局唯一</td>
<td>存在多个</td>
</tr>
<tr>
<td>实例化时机</td>
<td>IoC容器启动时</td>
<td>getBean() 或 对象注入时</td>
</tr>
<tr>
<td>线程安全问题</td>
<td>存在</td>
<td>不存在</td>
</tr>
<tr>
<td>执行效率</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
    public UserDao()&#123;
        System.out.println(&quot;UserDao已创建: &quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    public UserDao userDao;

    public UserService() &#123;
        System.out.println(&quot;UserService已创建: &quot; + this);
    &#125;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        System.out.println(&quot;调用setUserDao: &quot; + userDao);
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
   &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java 【单例】

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserDao userDao = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao1 = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao2 = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao3 = context.getBean(&quot;userDao&quot;, UserDao.class);
    &#125;
&#125;

applicationContext.xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; &gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

================================================================
输出：
UserService已创建: com.imooc.spring.ioc.service.UserService@3dd3bcd
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@7c16905e
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@7c16905e
    
Process finished with exit code 0
</code></pre>
<pre><code class="java">SpringApplication.java 【多例】
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        System.out.println(&quot;IoC容器已初始化&quot;);
        UserService userService1 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService2 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService3 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService4 = context.getBean(&quot;userService&quot;, UserService.class);
    &#125;
&#125;

applicationContext.xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

================================================================
输出:
IoC容器已初始化
UserService已创建: com.imooc.spring.ioc.service.UserService@5c7fa833
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@4dfa3a9d
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@4dfa3a9d
UserService已创建: com.imooc.spring.ioc.service.UserService@4b952a2d
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@3159c4b8
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@3159c4b8
UserService已创建: com.imooc.spring.ioc.service.UserService@73846619
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@4bec1f0c
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@4bec1f0c
UserService已创建: com.imooc.spring.ioc.service.UserService@29ca901e
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@5649fd9b
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@5649fd9b

Process finished with exit code 0
</code></pre>
<p><span style = "color : red">一般来说dao类 service类 control类都是单例 因为单例安全根源是运行时发生不断的变化 如果在真正环境中一般不会重新设置那些类，在运行中都是恒定不变的。所以推荐用单例默认<code>singleton</code></span></p>
<h3 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/cbffd1149ca0b5b1b860325d72941880b7ca7fc4/data/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg"></p>
<pre><code class="java">Order.java
package com.imooc.spring.ioc.entity;

public class Order &#123;
    private Float price;
    private Integer quantity;
    private Float total;

    public Order() &#123;
        System.out.println(&quot;创建Order对象&quot; + this);
    &#125;

    public void init()&#123;
        System.out.println(&quot;执行init()方法&quot;);
        total = price * quantity;
    &#125;
    public void pay()&#123;
        System.out.println(&quot;订单金额为：&quot; + total);
    &#125;

    public Float getPrice() &#123;
        return price;
    &#125;

    public void setPrice(Float price) &#123;
        System.out.println(&quot;设置price：&quot; + price);
        this.price = price;
    &#125;

    public Integer getQuantity() &#123;
        return quantity;
    &#125;

    public void setQuantity(Integer quantity) &#123;
        System.out.println(&quot;设置quantity：&quot; + quantity);
        this.quantity = quantity;
    &#125;

    public Float getTotal() &#123;
        return total;
    &#125;

    public void setTotal(Float total) &#123;
        this.total = total;
    &#125;

    public void destroy()&#123;
        System.out.println(&quot;释放与订单对象相关的资源&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;order1&quot; class=&quot;com.imooc.spring.ioc.entity.Order&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;
        &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
        &lt;property name=&quot;quantity&quot; value=&quot;1000&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        System.out.println(&quot;======IoC容器已初始化======&quot;);
        Order order1 = context.getBean(&quot;order1&quot;,Order.class);
        order1.pay();
        ((ClassPathXmlApplicationContext)context).registerShutdownHook(); //销毁容器 自动调用bean中设置的destory方法
    &#125;
&#125;

==========================================
创建Order对象com.imooc.spring.ioc.entity.Order@153f5a29
设置price：19.8
设置quantity：1000
执行init()方法
======IoC容器已初始化======
订单金额为：19800.0
释放与订单对象相关的资源

Process finished with exit code 0
</code></pre>
<h3 id="实现极简IoC容器-利用反射机制完成对象的创建和注入"><a href="#实现极简IoC容器-利用反射机制完成对象的创建和注入" class="headerlink" title="实现极简IoC容器 [利用反射机制完成对象的创建和注入]"></a>实现极简IoC容器 [利用反射机制完成对象的创建和注入]</h3><pre><code class="java">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

&lt;!--        Dom4j是Java的XML解析组件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.dom4j&lt;/groupId&gt;
            &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--        jaxen是Xpath表达式解释器--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jaxen&lt;/groupId&gt;
            &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
            &lt;version&gt;1.1.6&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">Apple.java
public class Apple &#123;
    private String title;
    private String color;
    private String origin;
&#125; + Getter Setter
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans&gt;
    &lt;bean id = &quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.context.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt; //这里的title是在setter中 public void setTitle(String title)&#123;this.title=title;&#125;
        &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt;
        &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">ApplicationContext.java[接口]
package com.imooc.spring.ioc.context;

public interface ApplicationContext &#123;
    public Object getBean(String beanId);
&#125;
</code></pre>
<pre><code class="java">ClassPathXmlApplicationContext.java
package com.imooc.spring.ioc.context;

import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;

import java.io.File;
import java.lang.reflect.Method;
import java.net.URLDecoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClassPathXmlApplicationContext implements ApplicationContext&#123;
    private Map iocContainer = new HashMap();
    public ClassPathXmlApplicationContext()&#123;
        try &#123;
            String filePath = this.getClass().getResource(&quot;/applicationContext.xml&quot;).getPath();
            filePath = new URLDecoder().decode(filePath,&quot;UTF-8&quot;);
            SAXReader reader = new SAXReader();
            Document document = reader.read(new File(filePath));
            List&lt;Node&gt; beans = document.getRootElement().selectNodes(&quot;bean&quot;);//得到节点的集合
            for (Node node:beans)&#123;
                Element ele = (Element) node;
                String id = ele.attributeValue(&quot;id&quot;);
                String className = ele.attributeValue(&quot;class&quot;);
                Class c = Class.forName(className);//加载指定类
                Object obj = c.newInstance();
                List&lt;Node&gt; properties = ele.selectNodes(&quot;property&quot;);
                for (Node p:properties)&#123;
                    Element property = (Element) p;
                    String propName = property.attributeValue(&quot;name&quot;);
                    String propValue= property.attributeValue(&quot;value&quot;);
//基于property完成注入是通过Setter的set方法，set方法命名的格式为setTitle 属性名第一个字母有个大写
                    String setMethodName = &quot;set&quot; + propName.substring(0,1).toUpperCase()+propName.substring(1);
                    System.out.println(&quot;准备执行&quot; + setMethodName + &quot;方法注入数据&quot;);
                    Method setMethod = c.getMethod(setMethodName, String.class);
                    setMethod.invoke(obj, propValue); //执行哪个对象的实例方法
                &#125;
                iocContainer.put(id,obj); //赋予了bean id
            &#125;
            System.out.println(iocContainer);
            System.out.println(&quot;IoC容器初始化完毕&quot;);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    @Override
    public Object getBean(String beanId) &#123;
        return iocContainer.get(beanId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Application.java
package com.imooc.spring.ioc.context;

public class Application &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext();
        Apple apple = (Apple) context.getBean(&quot;sweetApple&quot;);
        System.out.println(apple);
    &#125;
&#125;

=================================================
准备执行setTitle方法注入数据
准备执行setColor方法注入数据
准备执行setOrigin方法注入数据
&#123;sweetApple=com.imooc.spring.ioc.context.Apple@484b61fc&#125;
IoC容器初始化完毕
com.imooc.spring.ioc.context.Apple@484b61fc

Process finished with exit code 0
</code></pre>
<h3 id="四种组件类型注解"><a href="#四种组件类型注解" class="headerlink" title="四种组件类型注解"></a>四种组件类型注解</h3><h5 id="基于注解配置IoC容器"><a href="#基于注解配置IoC容器" class="headerlink" title="基于注解配置IoC容器"></a>基于注解配置IoC容器</h5><h6 id="基于注解的优势"><a href="#基于注解的优势" class="headerlink" title="基于注解的优势"></a>基于注解的优势</h6><ul>
<li>摆脱繁琐的XML形式的bean与依赖注入配置</li>
<li>基于”声明式”的原则,更适合轻量级的现代企业应用</li>
<li>让代码可读性变得更好,研发人员拥有更好的开发体验</li>
</ul>
<h5 id="三类注解"><a href="#三类注解" class="headerlink" title="三类注解"></a><span style = "color:red">三类注解</span></h5><ul>
<li>四种组件类型注解-声明当前类的功能与职责</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化</td>
</tr>
<tr>
<td><strong>@Controller</strong></td>
<td>语义注解,说明当前类是MVC应用中的控制器类</td>
</tr>
<tr>
<td><strong>@Service</strong></td>
<td>语义注解,说明当前类是Service业务服务类</td>
</tr>
<tr>
<td><strong>@Repository</strong></td>
<td>语义注解,说明当前类用于业务持久层,通常描述对应Dao类</td>
</tr>
</tbody></table>
<p>   <strong>开启组件扫描</strong></p>
<pre><code class="xml">XML配置开启组件扫描,才能使用注解
&lt;context:component-scan base-package=&quot;com.imooc&quot;&gt;
   &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;com.imooc.exl.*&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre>
<ul>
<li>自动装配注解-根据属性特征自动注入对象</li>
<li>元数据注解-更细化的辅助IoC容器管理对象的注解</li>
</ul>
<h3 id="基于注解初始化IoC容器"><a href="#基于注解初始化IoC容器" class="headerlink" title="基于注解初始化IoC容器"></a>基于注解初始化IoC容器</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config">Core Technologies (spring.io)</a></p>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
&lt;!--
    在IoC容器初始化时自动扫描四种组件类型注解并完成实例化
    @Repository
    @Service
    @Controller
    @Component
--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt; //设置基准的包名去扫描

&lt;/beans&gt;
</code></pre>
<pre><code class="java">controller/UserController.java
package com.imooc.spring.ioc.controller;

import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
&#125;
</code></pre>
<pre><code class="java">dao/UserDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.stereotype.Repository;

//组件类型解释默认beanId为类名首字母小写
//组件类型解释默认beanId为类名首字母小写
//beanId = userDao
@Repository
public class UserDao &#123;

&#125;
</code></pre>
<pre><code class="java">service/UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.stereotype.Service;

@Service
public class UserService &#123;

&#125;
</code></pre>
<pre><code class="java">utils/StringUtils.java
package com.imooc.spring.ioc.utils;

import org.springframework.stereotype.Component;

@Component
public class StringUtils &#123;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123; //这些bean在容器中是单例，在初始化的时候创建对象
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;
==============================================================
//组件类型解释默认beanId为类名首字母小写
userController:com.imooc.spring.ioc.controller.UserController@4f51b3e0
userDao:com.imooc.spring.ioc.dao.UserDao@4b9e255
userService:com.imooc.spring.ioc.service.UserService@5e57643e
stringUtils:com.imooc.spring.ioc.utils.StringUtils@133e16fd
    
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@51b279c9
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@1ad282e0
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@7f416310
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@1cab0bfb
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@5e955596

Process finished with exit code 0
</code></pre>
<h3 id="自动装配与Autowired注解"><a href="#自动装配与Autowired注解" class="headerlink" title="自动装配与Autowired注解"></a>自动装配与Autowired注解</h3><h5 id="两类自动装配注解-Primary-如果有两个写此注解作为主要"><a href="#两类自动装配注解-Primary-如果有两个写此注解作为主要" class="headerlink" title="两类自动装配注解  [@Primary 如果有两个写此注解作为主要]"></a>两类自动装配注解  [@Primary 如果有两个写此注解作为主要]</h5><table>
<thead>
<tr>
<th>分类</th>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>按类型装配</td>
<td>@Autowired</td>
<td>按容器内对象类型动态注入属性,由Spring机构提供</td>
</tr>
<tr>
<td></td>
<td>@Inject</td>
<td>基于JSR-330标准,其他同@Autowired,但不支持required属性</td>
</tr>
<tr>
<td>按名称装配</td>
<td>@Named</td>
<td>与@Inject配合使用,JSR-330规范,按属性名自动装配属性</td>
</tr>
<tr>
<td></td>
<td><span style = "color:red">@Resource</span></td>
<td><span style = "color:red">基于JSR-250规范,优先按名称，再按类型智能匹配</span></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>这是默认的自动装配模式，意味着默认情况下没有自动装配</td>
</tr>
<tr>
<td>byName</td>
<td>byName模式根据bean的名称注入对象依赖项。在这种情况属性名称和bean名称必须相同，它在内部调用setter方法</td>
</tr>
<tr>
<td>byType</td>
<td>byType模式根据类型注入对象依赖项，因此属性名称和bean名称可以不同，它在内部调用setter方法</td>
</tr>
<tr>
<td>constructor</td>
<td>构造函数模式通过调用类的构造函数来注入依赖项。它会调用具有大量参数的构造函数。</td>
</tr>
<tr>
<td>autodetect</td>
<td>从Spring 3开始不推荐使用</td>
</tr>
</tbody></table>
<h5 id="无法确认注入哪个bean-解决方案【UserDao-与-UserOracleDao】"><a href="#无法确认注入哪个bean-解决方案【UserDao-与-UserOracleDao】" class="headerlink" title="无法确认注入哪个bean 解决方案【UserDao 与 UserOracleDao】"></a>无法确认注入哪个bean 解决方案【UserDao 与 UserOracleDao】</h5><pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;

//组件类型解释默认beanId为类名首字母小写
//beanId = userDao
@Repository
public class UserDao implements IUserDao&#123;
    public UserDao()&#123;
        System.out.println(&quot;正在创建UseDao：&quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserOracleDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;
@Repository
@Primary
public class UserOracleDao implements IUserDao&#123;

    public UserOracleDao()&#123;
        System.out.println(&quot;正在创建UserOracleDao：&quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">IUserDao.java [接口]
package com.imooc.spring.ioc.dao;

public interface IUserDao &#123;
&#125;
</code></pre>
<pre><code class="java">DepartmentService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

@Service
public class DepartmentService &#123;
    /**
     * 1. @Resource设置name属性,则按name在IoC容器中将bean注入
     * 2. @Resource未设置name属性
     *  2.1 以属性名作为bean name在IoC容器中匹配bean，如有匹配则注入
     *  2.2 按属性名未匹配，则按类型进行匹配，同 @Autowired 需要加入 @Primary解决类型冲突
     *  使用建议: 在使用 @Resource对象时推荐设置name或保证属性名与bean名称一致
     */
    /*方法2.2.1
    @Resource(name = &quot;userOracleDao&quot;)
    private IUserDao udao;*/

    //方法2.2.2
    @Resource
    private IUserDao userOracleDao;
    public void joinDepartment()&#123;
        System.out.println(userOracleDao);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService &#123;
    //@Autowired
    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值
    //不再执行set方法
    private IUserDao udao;

    public UserService() &#123;
        System.out.println(&quot;正在构建UserService&quot; + this);
    &#125;

    public IUserDao getUdao() &#123;
        return udao;
    &#125;

    @Autowired
    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入
    public void setUdao(UserDao udao) &#123;
        System.out.println(&quot;setUdao: &quot; + udao);
        this.udao = udao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java 
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import com.imooc.spring.ioc.service.DepartmentService;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        System.out.println(userService.getUdao());
        DepartmentService departmentService = context.getBean(&quot;departmentService&quot;, DepartmentService.class);
        departmentService.joinDepartment();
    &#125;
&#125;
</code></pre>
<h3 id="元数据注解"><a href="#元数据注解" class="headerlink" title="元数据注解"></a>元数据注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Primary</td>
<td>按类型装配时出现多个相同类型对象,拥有此注解对象优先被注入</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>描述方法,相当于XML中init-method配置的注解版本</td>
</tr>
<tr>
<td>@PreDestory</td>
<td>描述方法,相当于XML中destory-method配置的注解版本</td>
</tr>
<tr>
<td>@Scope</td>
<td>设置对象的scope属性  &#x2F;&#x2F;@Scope(“prototype”)设置多例</td>
</tr>
<tr>
<td>@Value</td>
<td>为属性注入静态数据</td>
</tr>
</tbody></table>
<pre><code class="java">applicationContext.xml 【新增第11行】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
&lt;!--    加载指定路径下的properties文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&gt;
&lt;!--
    在IoC容器初始化时自动扫描四种组件类型注解并完成实例化
    @Repository
    @Service
    @Controller
    @Component
--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">config.properties [这里属于动态注入噢~]
  metaData=imooc.com
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;

@Service
@(&quot;prototype&quot;) //设置多例 与XML中bean scope完全相同
public class UserService &#123;
    @Value(&quot;$&#123;metaData&#125;&quot;)
    private String metaData; //对此数据的动态注入

    //@Autowired
    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值
    //不再执行set方法
    public UserService() &#123;
        System.out.println(&quot;正在构建UserService&quot; + this);
    &#125;

    @PostConstruct //XML中bean init-method完全相同
    public void init()&#123;
        System.out.println(&quot;初始化UserService对象,metaData=&quot; + metaData);
    &#125;
    private IUserDao udao;


    public IUserDao getUdao() &#123;
        return udao;
    &#125;

    @Autowired
    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入
    public void setUdao(UserDao udao) &#123;
        System.out.println(&quot;setUdao: &quot; + udao);
        this.udao = udao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import com.imooc.spring.ioc.service.DepartmentService;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        System.out.println(userService.getUdao());
    &#125;
&#125;
</code></pre>
<h3 id="基于Java-Config配置IoC容器"><a href="#基于Java-Config配置IoC容器" class="headerlink" title="基于Java Config配置IoC容器"></a>基于Java Config配置IoC容器</h3><ul>
<li>完全摆脱XML的束缚, 使用独立Java类管理对象与依赖</li>
<li>注解配置相对分散, 利用Java Config可对配置集中管理</li>
<li>可以在编译时进行依赖检查, 不容易出错</li>
</ul>
<h5 id="Java-Config核心注解【敏捷开发-小型项目】-而XML是大型团队项目"><a href="#Java-Config核心注解【敏捷开发-小型项目】-而XML是大型团队项目" class="headerlink" title="Java Config核心注解【敏捷开发 小型项目】 而XML是大型团队项目"></a>Java Config核心注解【敏捷开发 小型项目】 而XML是大型团队项目</h5><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Configuration</strong></td>
<td>描述类, 说明当前类是Java Config配置类, 完全替代XML文件</td>
</tr>
<tr>
<td>@<strong>Bean</strong></td>
<td>描述方法, 方法返回对象将被IoC容器管理, beanId默认为方法名</td>
</tr>
<tr>
<td>@ImportResource</td>
<td>描述类, 加载静态文件, 可使用@Value注解获取</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>描述类, 同XML的 &lt; context:compoment-scan &gt;标签</td>
</tr>
</tbody></table>
<pre><code class="java">UserController.java
package com.imooc.spring.ioc.controller;

import com.imooc.spring.ioc.service.UserService;
import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
    private UserService userService;

    public UserService getUserService() &#123;
        return userService;
    &#125;

    public void setUserService(UserService userService) &#123;
        this.userService = userService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    private UserDao userDao;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">Config.java [作为配置文件]
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.controller.UserController;
import com.imooc.spring.ioc.dao.UserDao;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //当前是个配置类,用于代替applicationContext.xml
public class Config &#123;
    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名
    public UserDao userDao()&#123;
        UserDao userDao = new UserDao();
        return userDao;
    &#125;
    @Bean
    public UserService userService()&#123;
        UserService userService = new UserService();
        return userService;
    &#125;
    @Bean
    public UserController userController()&#123;
        UserController userController = new UserController();
        return userController;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //基于Java Config配置IoC容器的初始化
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123;
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;
=======================================================
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@4f9a3314
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@3b2c72c2
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@491666ad
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@176d53b2
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@971d0d8
config:com.imooc.Config.Config$$EnhancerBySpringCGLIB$$c932e406@51931956
userDao:com.imooc.Config.UserDao@2b4a2ec7
userService:com.imooc.Config.UserService@564718df
userController:com.imooc.Config.UserController@51b7e5df
</code></pre>
<h3 id="JavaConfig-对象依赖注入"><a href="#JavaConfig-对象依赖注入" class="headerlink" title="JavaConfig-对象依赖注入"></a>JavaConfig-对象依赖注入</h3><p>Config的括号增加参数</p>
<pre><code class="java">Config.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.controller.UserController;
import com.imooc.spring.ioc.dao.UserDao;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //当前是个配置类,用于代替applicationContext.xml
@ComponentScan(basePackages = &quot;com.imooc&quot;) //扫描其他的组件类 因为其他人也会写
public class Config &#123;
    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名
    public UserDao userDao()&#123;
        UserDao userDao = new UserDao();
        System.out.println(&quot;已创建&quot;+userDao);
        return userDao;
    &#125;
    @Bean
    //先按name尝试注入,name不存在则按类型注入 冲突则@Primary
    public UserService userService(UserDao userDao)&#123;
        UserService userService = new UserService();
        System.out.println(&quot;已创建&quot;+userService);
        userService.setUserDao(userDao);
        System.out.println(&quot;调用setUserDao:&quot; + userDao);
        return userService;
    &#125;
    @Bean //&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot;&gt;
    public UserController userController(UserService userService)&#123;
        UserController userController = new UserController();
        System.out.println(&quot;已创建&quot; + userController);
        userController.setUserService(userService);
        System.out.println(&quot;调用setUserService:&quot;+userService);
        return userController;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //基于Java Config配置IoC容器的初始化
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        System.out.println(&quot;=============================&quot;);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123;
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;

=================================================================
已创建com.imooc.spring.ioc.dao.UserDao@10b48321
已创建com.imooc.spring.ioc.service.UserService@473b46c3
调用setUserDao:com.imooc.spring.ioc.dao.UserDao@10b48321
已创建com.imooc.spring.ioc.controller.UserController@797badd3
调用setUserService:com.imooc.spring.ioc.service.UserService@473b46c3
=============================
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@44a664f2
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@7f9fcf7f
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@2357d90a
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@6328d34a
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@145eaa29
config:com.imooc.spring.ioc.Config$$EnhancerBySpringCGLIB$$8a99aa4c@15bb6bea
userDao:com.imooc.spring.ioc.dao.UserDao@10b48321
userService:com.imooc.spring.ioc.service.UserService@473b46c3
userController:com.imooc.spring.ioc.controller.UserController@797badd3

Process finished with exit code 0
</code></pre>
<pre><code class="java">如果突然想增加一个注入employeeDao
UserService.java 先增加一个私有的名字 再getter+setter
去Conifg.java 括号里新增
public UserService userService(UserDao userDao, EmployeeDao employeeDao)&#123;
        UserService userService = new UserService();
        System.out.println(&quot;已创建&quot;+userService);
        userService.setUserDao(userDao);
        System.out.println(&quot;调用setUserDao:&quot; + userDao);
        userService.setEmployeeDao(employeeDao);
        return userService;
    &#125;
</code></pre>
<h3 id="Spring-Test测试模块"><a href="#Spring-Test测试模块" class="headerlink" title="Spring Test测试模块"></a>Spring Test测试模块</h3><ul>
<li>Spring Test是Spring中用于测试的模块</li>
<li>Spring Test对JUnit单元测试框架有良好的整合</li>
<li>通过Spring Test可在Junit单元测试时自动初始化IoC容器</li>
</ul>
<h5 id="Spring与JUnit4整合过程"><a href="#Spring与JUnit4整合过程" class="headerlink" title="Spring与JUnit4整合过程"></a>Spring与JUnit4整合过程</h5><ul>
<li>Maven工程依赖spring-test</li>
<li>利用 <strong>@RunWith</strong> 与 <strong>@ContextConfiguration</strong>描述测试用例类</li>
<li>测试用例类从容器获取对象完成测试用例的执行</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
        &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    private UserDao userDao;
    public void createUser()&#123;
        System.out.println(&quot;调用创建用户业务代码&quot;);
        userDao.insert();
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot;&gt;

    &lt;/bean&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringTestor.java
import com.imooc.spring.ioc.service.UserService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

//将Junit4的执行权交给Spring Test,在测试用例执行前自动初始化IoC容器
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class SpringTestor &#123;
    @Resource
    private UserService userService;

    @Test
    public void testUserService()&#123;
        userService.createUser();
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<h3 id="介绍AOP"><a href="#介绍AOP" class="headerlink" title="介绍AOP"></a>介绍AOP</h3><p><strong>Aspect Oriented Programming</strong>(AOP)从某种意义上说是对OOP的补充，因为它还提供了模块化的功能。但是模块化的关键单元是方面而不是类。</p>
<h5 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h5><ul>
<li>介绍Spring AOP与相关概念名词</li>
<li>Spring AOP开发与配置流程</li>
<li>Spring 五种通知类型与应用场景</li>
</ul>
<h5 id="Spring中的可插拔组件技术-类似于插件"><a href="#Spring中的可插拔组件技术-类似于插件" class="headerlink" title="Spring中的可插拔组件技术 [类似于插件]"></a>Spring中的可插拔组件技术 [类似于插件]</h5><p>应用程序执行前检测的作用</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/63abc993304f86f346667a404430e2ad28f989cb/data/Spring%E4%B8%AD%E7%9A%84%E5%8F%AF%E6%8F%92%E6%8B%94%E7%BB%84%E4%BB%B6%E6%8A%80%E6%9C%AF.jpg"></p>
<h5 id="Spring-AOP-在不修改源码的情况下对程序进行扩展"><a href="#Spring-AOP-在不修改源码的情况下对程序进行扩展" class="headerlink" title="Spring AOP [在不修改源码的情况下对程序进行扩展]"></a>Spring AOP [在不修改源码的情况下对程序进行扩展]</h5><p>[IDEA创建项目出现Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45429409/article/details/118068484?ops_request_misc=%7B%22request_id%22:%22170678007016800227455895%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=170678007016800227455895&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118068484-null-null.142%5Ev99%5Epc_search_result_base9&amp;utm_term=Cannot">https://blog.csdn.net/weixin_45429409/article/details/118068484?ops_request_misc=%7B%22request%5Fid%22%3A%22170678007016800227455895%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170678007016800227455895&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118068484-null-null.142^v99^pc_search_result_base9&amp;utm_term=Cannot</a> resolve plugin org.apache.maven.plugins%3Amaven-site-plugin%3A3.3&amp;spm&#x3D;1018.2226.3001.4187)</p>
<ul>
<li>Spring AOP - Aspect Oriented Programming 面向切面编程</li>
<li>AOP的做法是将通用、与业务无关的功能抽象封装为切面类</li>
<li>切面可配置在<strong>目标方法</strong>的执行前、后运行，真正做到即插即用</li>
</ul>
<p>运行前进行拦截在运行前打印时间 再运行代码；没有IoC就没有AOP；写完扩展之后要再applicationContext.xml中新增&lt; aop:config &gt;…来认可切面</p>
<pre><code class="java">aop/dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

/**
 * 员工表Dao
 */
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
---------------------------------------------
aop/dao/UserDao.java
package com.imooc.spring.aop.dao;

/**
 * 用户表Dao
 */
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
---------------------------------------------
aop/service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;

import java.util.Date;

/**
 * 员工服务
 */
public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
---------------------------------------------
aop/service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;

/**
 * 用户服务
 */
public class UserService &#123;
    private UserDao userDao;

    public void createUser()&#123;
        if(1==1)&#123;
            throw new RuntimeException(&quot;用户已存在&quot;);
        &#125;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
---------------------------------------------
aop/aspect/MethodAspect
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.JoinPoint;

import java.text.SimpleDateFormat;
import java.util.Date;

//切面类
public class MethodAspect &#123;
    //切面方法,用于扩展额外功能
    //JoinPoint 连接点,通过连接点可以获取目标类/方法的信息
    public void printExecutionTime(JoinPoint joinPoint)&#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        String now = sdf.format(new Date());
        String className = joinPoint.getTarget().getClass().getName();//获取类→获取目标类的名称
        String methodName = joinPoint.getSignature().getName();//获取目标方法名称
        System.out.println(&quot;----&gt;&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName);
        Object[] args = joinPoint.getArgs();
        System.out.println(&quot;----&gt;参数个数:&quot; + args.length);
        for(Object arg:args)&#123;
            System.out.println(&quot;----&gt;参数:&quot; + arg);
        &#125;
    &#125;

    public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123;
        System.out.println(&quot;&lt;----返回后通知:&quot; + ret);
    &#125;
    public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123;
        System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage());
    &#125;
    public void doAfter(JoinPoint joinPoint)&#123;
        System.out.println(&quot;&lt;----触发后置通知&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser(); //模拟创建新用户过程
        userService.generateRandomPassword(&quot;MD5&quot;, 16);
    &#125;
&#125;
====================================================================
----&gt;2024-02-01 18:09:38 050:com.imooc.AOP.UserService.createUser
----&gt;参数个数:0
执行创建用户业务逻辑
新增用户数据
&lt;----返回后通知:null
&lt;----触发后置通知
----&gt;2024-02-01 18:09:38 058:com.imooc.AOP.UserService.generateRandomPassword
----&gt;参数个数:2
----&gt;参数:MD5
----&gt;参数:16
按MD5方式生成16位随机密码
&lt;----返回后通知:PzZo3Fzqe!r4$
&lt;----触发后置通知
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
        &lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!--关联一下--&gt;
            &lt;!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt;
            &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; throwing=&quot;th&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;aop&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--aspectjweaver是Spring AOP的底层依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="Spring-AOP-与-AspectJ的关系-实现类与方法的匹配"><a href="#Spring-AOP-与-AspectJ的关系-实现类与方法的匹配" class="headerlink" title="Spring AOP 与 AspectJ的关系 [实现类与方法的匹配]"></a>Spring AOP 与 <u>AspectJ</u>的关系 [实现类与方法的匹配]</h3><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15949848/6813110">Spring【SpringAOP（通知类型、切点表达式 、多切面配置 、注解配置AOP、原生Spring实现AOP）】(六)-全面详解（学习总结—从入门到深化）_童小纯呀的技术博客_51CTO博客</a></p>
<ul>
<li>Eclips AspectJ 是一种基于Java平台的面向切面编程的语言</li>
<li>Spring AOP使用AspectJWeaver实现类与方法匹配</li>
<li><strong>Spring AOP利用<u>代理模式</u>实现对象运行时功能扩展</strong></li>
</ul>
<h5 id="几个关键概念"><a href="#几个关键概念" class="headerlink" title="几个关键概念"></a>几个关键概念</h5><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Aspect</td>
<td>切面,具体的可插拔组件功能类,通常一个切面只能实现一个通用功能</td>
</tr>
<tr>
<td>Target Class&#x2F;Method</td>
<td>目标类、目标方法,指真正要执行与业务相关的方法</td>
</tr>
<tr>
<td><strong>PointCut</strong></td>
<td>切入点,<strong>使用execution表达式</strong>说明切面要作用再系统的哪些类上</td>
</tr>
<tr>
<td><strong>JoinPoint</strong></td>
<td>连接点,切面运行过程中是包含了目标类&#x2F;方法元数据的对象</td>
</tr>
<tr>
<td>Advice</td>
<td>通知,说明具体的切面的执行时机,Spring包含了不中不同类型通知</td>
</tr>
</tbody></table>
<blockquote>
<p>JoinPoint 连接点,通过连接点可以获取目标类&#x2F;方法的信息<br>public void printExecutionTime(JoinPoint joinPoint){}</p>
</blockquote>
<p><span style = "color:red"><strong>Spring AspectJ AOP实现提供了许多注释：</strong></span></p>
<p><strong>@Aspect</strong> 将该类声明为方面。<br><strong>@Pointcut</strong> 声明切入点表达式。</p>
<p>用于创建建议的注释如下:</p>
<p><strong>@Before</strong> 声明before建议。在调用实际方法之前将其应用。<br><strong>@After</strong> 声明after建议。在调用实际方法之后并返回结果之前应用。<br><strong>@AfterReturning</strong> 声明返回建议之后。在调用实际方法之后并返回结果之前应用。但是您可以在建议中获得结果值。<br><strong>@Around</strong> 声明环绕建议。它在调用实际方法之前和之后应用。<br><strong>@AfterThrowing</strong> 声明了throws建议。如果实际方法引发异常，则应用此方法。</p>
<h5 id="AOP配置过程"><a href="#AOP配置过程" class="headerlink" title="AOP配置过程"></a>AOP配置过程</h5><ul>
<li>依赖AspectJ</li>
<li>实现切面类&#x2F;方法</li>
<li>配置Aspect Bean</li>
<li>定义PointCut</li>
<li>配置Advice  &#x2F;&#x2F;before通知(Advice)</li>
</ul>
<h3 id="JoinPoint核心方法"><a href="#JoinPoint核心方法" class="headerlink" title="JoinPoint核心方法"></a>JoinPoint核心方法</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object getTarget()</td>
<td>获取IoC容器内目标对象</td>
</tr>
<tr>
<td>Signature getSignature()</td>
<td>获取目标方法</td>
</tr>
<tr>
<td>Object[] getArgs()</td>
<td>获取目标方法<strong>参数</strong></td>
</tr>
</tbody></table>
<pre><code class="java">//很多线上的项目需要跟踪调试却不知道输入的参数是什么 就可以增加切片
public void printExecutionTime(JoinPoint joinPoint)&#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        String now = sdf.format(new Date());
        String className = joinPoint.getTarget().getClass().getName();//获取类→获取目标类的名称
        String methodName = joinPoint.getSignature().getName();//获取目标方法名称
        System.out.println(&quot;----&gt;&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName);
        Object[] args = joinPoint.getArgs(); //传入目标方法的实际参数
        System.out.println(&quot;----&gt;参数个数:&quot; + args.length);
        for(Object arg:args)&#123;
            System.out.println(&quot;----&gt;参数:&quot; + arg);
        &#125;
    &#125;
</code></pre>
<h3 id="PointCut切点表达式-pointcut"><a href="#PointCut切点表达式-pointcut" class="headerlink" title="PointCut切点表达式 [@pointcut]"></a>PointCut切点表达式 [@pointcut]</h3><p>注释用于定义切入点。我们也可以通过名称引用切入点表达式</p>
<pre><code class="java">@Pointcut(&quot;execution(* Operation.*(..))&quot;)
private void doSomething() &#123;&#125;

//它将应用于所有公共方法
@Pointcut(&quot;execution(public * * (..))&quot;)

//它将应用于Operation类的所有公共方法
@Pointcut(&quot;execution(public Operation.*(..))&quot;)

//它将应用于Operation类的所有方法
@Pointcut(&quot;execution(* Operation.*(..))&quot;)

//它将应用于Employee类的所有公共设置方法
@Pointcut(&quot;execution(public Employee.set*(..))&quot;)

//它将应用于所有返回int值的Operation类方法
@Pointcut(&quot;execution(int Operation.*(..))&quot;)
</code></pre>
<blockquote>
<p>​                   public void com.imooc.service.UserService.createUser(形参1,形参2,..)<br>  ​                    ↑         ↑             ↑                 ↑                 ↑                   ↑                  ↑</p>
<p>execution(public   *     com.imooc       ..                 *       .           *       (          ..          ))<br>*通配符                            ..包通配符[包括所有后代查找]                            (..)参数通配符</p>
<p>第一项public可以默认</p>
</blockquote>
<pre><code class="xml">&lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;/aop:config&gt;

---------------------------------------------------------------------------------
切点表达式训练
&lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
</code></pre>
<h3 id="五种通知类型"><a href="#五种通知类型" class="headerlink" title="五种通知类型"></a>五种通知类型</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Before Advice</td>
<td>前置通知,目标方法运行前执行</td>
</tr>
<tr>
<td>After Returning Advice</td>
<td>返回后通知,目标方法返回数值后执行</td>
</tr>
<tr>
<td>After Throwing Advice</td>
<td>异常通知,目标方法抛出异常后执行</td>
</tr>
<tr>
<td>After Advice</td>
<td>后置通知,目标方法运行后执行</td>
</tr>
<tr>
<td><span style = " color : red"><strong>Around Advice</strong></span></td>
<td><span style = "color:red"><strong>最强大通知,自定通知执行时机,可决定目标方法是否运行</strong></span></td>
</tr>
</tbody></table>
<pre><code class="java">@Around(&quot;execution(* com.imooc..*Service.*(..))&quot;) 【通知 切面表达式】
    // @Before()   @After()   @AfterThrowing   @AfterReturning
    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
</code></pre>
<p><span style = " color : red"><strong>用于创建建议的注释如下：</strong></span></p>
<p><strong>@Before</strong> 声明before建议。在调用实际方法之前将其应用。<br><strong>@After</strong> 声明after建议。在调用实际方法之后并返回结果之前应用。<br><strong>@AfterReturning</strong> 声明返回建议之后。在调用实际方法之后并返回结果之前应用。但是您可以在建议中获得结果值。<br><strong>@Around</strong> 声明环绕建议。它在调用实际方法之前和之后应用。<br><strong>@AfterThrowing</strong> 声明了throws建议。如果实际方法引发异常，则应用此方法。</p>
<p><span style = " color : red"><strong>让我们看看用于定义建议的xml元素：</strong></span><br><a target="_blank" rel="noopener" href="https://www.cainiaoplus.com/spring/spring-aop-aspectj-xml-configuration-example.html">Spring AOP AspectJ Xml配置示例 - Spring教程 - 菜鸟教程 (cainiaoplus.com)</a><br>**<code>aop: before </code>**在调用实际的业务逻辑方法之前应用。<br>**<code>aop: after </code>**在调用实际的业务逻辑方法之后应用。<br>**<code>aop: 返回后</code>**在调用实际的业务逻辑方法后应用。可用于拦截通知中的返回值。<br>**<code>aop: around </code>**在调用实际的业务逻辑方法之前和之后都将应用。<br>**<code>aop: 投掷后</code>**如果实际的业务逻辑方法抛出异常，则将其应用。</p>
<h5 id="特殊的“通知”-引介增强"><a href="#特殊的“通知”-引介增强" class="headerlink" title="特殊的“通知” - 引介增强"></a>特殊的“通知” - 引介增强</h5><ul>
<li>引介增强是对类的增强,而非方法</li>
<li>引介增强允许再运行时为目标类增加新属性或方法</li>
<li>引介增强允许再运行时改变类的行为,让类随运行环境动态变更</li>
</ul>
<pre><code class="java">MethodAspect.java
    public void doAfter(JoinPoint joinPoint)&#123;
        System.out.println(&quot;&lt;----触发后置通知&quot;);
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
</code></pre>
<pre><code class="java">MethodAspect.java
     public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123;
        System.out.println(&quot;&lt;----返回后通知:&quot; + ret);
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    
</code></pre>
<pre><code class="java">MethodAspect.java
public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123;
        System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage());
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;

打印顺序根据applicationContext.xml代码排列顺序一致
</code></pre>
<pre><code class="xml">applicationContext.xml [最终]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
        &lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!--关联一下--&gt;
            &lt;!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt;
            &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; throwing=&quot;th&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser(); //模拟创建新用户过程
        userService.generateRandomPassword(&quot;MD5&quot;, 15);
    &#125;
&#125;
===========================================================
----&gt;2024-01-12 13:40:56 885:com.imooc.spring.aop.service.UserService.createUser
----&gt;参数个数:0
&lt;----异常通知:用户已存在
&lt;----触发后置通知
Exception in thread &quot;main&quot; java.lang.RuntimeException: 用户已存在
    
</code></pre>
<hr>
<hr>
<h5 id="Before示例"><a href="#Before示例" class="headerlink" title="@Before示例"></a>@Before示例</h5><p>在实际业务逻辑方法之前应用AspectJ Before Advice。您可以在此处执行任何操作，例如转换，身份验证等。</p>
<p>创建一个包含实际业务逻辑的类</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg method invoked&quot;);&#125;
    public int m()&#123;System.out.println(&quot;m method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>现在，创建包含在建议之前的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation&#123;
    //它将应用于Operation类的所有方法。
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void k()&#123;&#125;//pointcut name
    
    @Before(&quot;k()&quot;)//在before通知上应用切入点
    public void myadvice(JoinPoint jp)//it is advice (before advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;
</code></pre>
<p>现在创建定义bean的applicationContext.xml文件</p>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/aop 
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
    &lt;bean id=&quot;trackMyBean&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
    &lt;bean class=&quot;org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>现在，让我们称为实际方法</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling msg...&quot;);
        e.msg();
        System.out.println(&quot;calling m...&quot;);
        e.m();
        System.out.println(&quot;calling k...&quot;);
        e.k();
    &#125;
&#125;

===========================================================================
calling msg...
additional concern
msg() method invoked
calling m...
additional concern
m() method invoked
calling k...
additional concern
k() method invoked
</code></pre>
<h5 id="apo-before示例"><a href="#apo-before示例" class="headerlink" title="apo:before示例"></a>apo:before示例</h5><p>在实际业务逻辑方法之前应用”先行AspectJ建议”。您可以在此处执行任何操作，例如转换，身份验证等。<br>创建一个包含实际业务逻辑的类</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg method invoked&quot;);&#125;
    public int m()&#123;System.out.println(&quot;m method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>现在，创建包含在建议之前的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
public class TrackOperation&#123;
    public void myadvice(JoinPoint jp)//it is advice
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;
</code></pre>
<p>现在创建定义bean的applicationContext.xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;
&lt;aop:aspectj-autoproxy /&gt;
&lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
&lt;bean id=&quot;trackAspect&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
        
&lt;aop:config&gt;
  &lt;aop:aspect id=&quot;myaspect&quot; ref=&quot;trackAspect&quot; &gt;
     &lt;!-- @Before --&gt;
     &lt;aop:pointcut id=&quot;pointCutBefore&quot;    expression=&quot;execution(* com.nhooo.Operation.*(..))&quot; /&gt;
     &lt;aop:before method=&quot;myadvice&quot; pointcut-ref=&quot;pointCutBefore&quot; /&gt;
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
    
&lt;/beans&gt;
</code></pre>
<p>现在，让我们称为实际方法</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling msg...&quot;);
        e.msg();
        System.out.println(&quot;calling m...&quot;);
        e.m();
        System.out.println(&quot;calling k...&quot;);
        e.k();
    &#125;
&#125;

===================================================================
calling msg...
additional concern
msg() method invoked
calling m...
additional concern
m() method invoked
calling k...
additional concern
k() method invoked
</code></pre>
<p>如您所见，在调用msg()，m()和k()方法之前，还会打印出其他问题。</p>
<hr>
<hr>
<h5 id="After示例"><a href="#After示例" class="headerlink" title="@After示例"></a>@After示例</h5><p>在调用实际的业务逻辑方法之后，应用了after建议之后的AspectJ。它可以用来维护日志，安全性，通知等。<br>在这里，我们假设 <strong>Operation.java</strong> ， <strong>applicationContext.xml</strong> 和 <strong>Test.java</strong> 文件与@Before示例中给出的文件相同。</p>
<pre><code class="java">TrackOperation.Java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation&#123;
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void k()&#123;&#125;//pointcut name
    
    @After(&quot;k()&quot;)//applying pointcut on after advice
    public void myadvice(JoinPoint jp)//it is advice (after advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;

===============================================================
calling msg...
msg() method invoked
additional concern
calling m...
m() method invoked
additional concern
calling k...
k() method invoked
additional concern
</code></pre>
<h5 id="aop-after示例"><a href="#aop-after示例" class="headerlink" title="aop:after示例"></a>aop:after示例</h5><p>在调用实际的业务逻辑方法之后，应用了通知之后的AspectJ。它可用于维护日志，安全性，通知等。<br>在这里，我们假设 **<code>Operation.java </code>**， **<code>TrackOperation.java </code>**和 **<code>Test.java </code>**文件与aop:before 中的示例相同。<br>现在创建定义bean的applicationContext.xml文件。</p>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;
&lt;aop:aspectj-autoproxy /&gt;
&lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
&lt;bean id=&quot;trackAspect&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
        
&lt;aop:config&gt;
  &lt;aop:aspect id=&quot;myaspect&quot; ref=&quot;trackAspect&quot; &gt;
     &lt;!-- @After --&gt;
     &lt;aop:pointcut id=&quot;pointCutAfter&quot;    expression=&quot;execution(* com.nhooo.Operation.*(..))&quot; /&gt;
     &lt;aop:after method=&quot;myadvice&quot; pointcut-ref=&quot;pointCutAfter&quot; /&gt;
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<blockquote>
<pre><code class="java">calling msg...
msg() method invoked
additional concern
calling m...
m() method invoked
additional concern
calling k...
k() method invoked
additional concern
</code></pre>
<p>您可以看到在调用msg()，m()和k()方法之后，还会出现其他问题。</p>
</blockquote>
<hr>
<hr>
<h5 id="AfterReturning示例"><a href="#AfterReturning示例" class="headerlink" title="@AfterReturning示例"></a>@AfterReturning示例</h5><p>通过在<strong>返回建议后</strong>使用，我们可以在建议中获得结果。创建包含以下内容的类业务逻辑。</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public int m()&#123;System.out.println(&quot;m() method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k() method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>创建返回建议后包含的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
@Aspect
public class TrackOperation&#123;
    @AfterReturning(pointcut = &quot;execution(* Operation.*(..))&quot;, returning= &quot;result&quot;)
    
    public void myadvice(JoinPoint jp,Object result)  //it is advice (after returning advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
        System.out.println(&quot;Result in advice: &quot;+result);
        System.out.println(&quot;end of after returning advice...&quot;);
    &#125;
&#125;
</code></pre>
<p>文件: applicationContext.xml    与@Before建议示例中给出的</p>
<p>文件: Test.java   现在创建调用实际方法的Test类。</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling m...&quot;);
        System.out.println(e.m());
        System.out.println(&quot;calling k...&quot;);
        System.out.println(e.k());
    &#125;
&#125;
================================================================
calling m...
m() method invoked
additional concern
Method Signature: int com.nhooo.Operation.m()
Result in advice: 2
end of after returning advice...
2
calling k...
k() method invoked
additional concern
Method Signature: int com.nhooo.Operation.k()
Result in advice: 3
end of after returning advice...
3
</code></pre>
<h3 id="环绕通知-public-Object-check-ProceedingJoinPoint-pjp"><a href="#环绕通知-public-Object-check-ProceedingJoinPoint-pjp" class="headerlink" title="环绕通知 [public Object check(ProceedingJoinPoint pjp)]"></a>环绕通知 [public Object check(ProceedingJoinPoint pjp)]</h3><h5 id="利用AOP进行方法性能筛查-筛查哪个实现时间长-可以进行代码优化"><a href="#利用AOP进行方法性能筛查-筛查哪个实现时间长-可以进行代码优化" class="headerlink" title="利用AOP进行方法性能筛查 [筛查哪个实现时间长 可以进行代码优化]"></a>利用AOP进行方法性能筛查 [筛查哪个实现时间长 可以进行代码优化]</h5><pre><code class="java">dao/UserDao.java
package com.imooc.spring.aop.dao;

/**
 * 用户表Dao
 */
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;

---------------------------------
dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

/**
 * 员工表Dao
 */
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;

/**
 * 员工服务
 */
public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;

---------------------------------
service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;

/**
 * 用户服务
 */
public class UserService &#123;
    private UserDao userDao;

    public void createUser()&#123;
        try &#123;
            Thread.sleep(3000); //沉睡 为了触发环绕通知
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">aspect/MethodChecker.java
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.ProceedingJoinPoint;

import java.text.SimpleDateFormat;
import java.util.Date;

public class MethodChecker &#123;
    ////ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
    public Object check(ProceedingJoinPoint pjp) throws Throwable &#123;
        try &#123;
            long startTime = new Date().getTime();//方法执行前
            Object ret = pjp.proceed();//执行目标方法
            long endTime = new Date().getTime();//
            long duration = endTime - startTime; //方法执行后 执行时长
            if(duration &gt;= 1000)&#123;//认为执行太慢了 打印信息
                String className = pjp.getTarget().getClass().getName();
                String methodName = pjp.getSignature().getName();
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
                String now = sdf.format(new Date());
                System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;);
            &#125;
            return ret;//方法返回
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;Exception message:&quot; + throwable.getMessage());
            throw throwable;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;methodChecker&quot; class=&quot;com.imooc.spring.aop.aspect.MethodChecker&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt; &lt;!--所有类进行拦截--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;aop:aspect ref=&quot;methodChecker&quot;&gt;
            &lt;!--环绕通知--&gt;
            &lt;aop:around method=&quot;check&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;

pom.xml
&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser();
    &#125;
&#125;

==============================================================
执行员工入职业务逻辑
新增用户数据
=======2024-01-12 13:52:41 475:com.imooc.spring.aop.service.UserService.createUser(3010ms)======

Process finished with exit code 0
</code></pre>
<hr>
<hr>
<h3 id="Around示例"><a href="#Around示例" class="headerlink" title="@Around示例"></a>@Around示例</h3><p>围绕通知的AspectJ在调用实际的业务逻辑方法之前和之后都得到应用。在这里，我们是假设  <strong>applicationContext.xml</strong> 文件与@Before示例中给出的文件相同。创建一个包含实际业务逻辑的类。</p>
<pre><code class="java">Operation.java
package com.nhooo;
public class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg() is invoked&quot;);&#125;
    public void display()&#123;System.out.println(&quot;display() is invoked&quot;);&#125;
&#125;
</code></pre>
<p>创建包含围绕建议的方面类。您需要在advice方法中传递  <strong>PreceedingJoinPoint</strong> 引用，以便我们可以通过调用proce来进行请求()方法。文件: TrackOperation.java</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation
&#123;
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void abcPointcut()&#123;&#125;
    
    @Around(&quot;abcPointcut()&quot;)
    public Object myadvice(ProceedingJoinPoint pjp) throws Throwable 
    &#123;
        System.out.println(&quot;Additional Concern Before calling actual method&quot;);
        Object obj=pjp.proceed();
        System.out.println(&quot;Additional Concern After calling actual method&quot;);
        return obj;
    &#125;
&#125;
</code></pre>
<p>现在创建调用实际方法的Test类。</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new classPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation op = (Operation) context.getBean(&quot;opBean&quot;);
        op.msg();
        op.display();
    &#125;
&#125;

================================================================
Additional Concern Before calling actual method
msg() is invoked
Additional Concern After calling actual method
Additional Concern Before calling actual method
display() is invoked
Additional Concern After calling actual method
</code></pre>
<h3 id="基于注解配置Spring-AOP"><a href="#基于注解配置Spring-AOP" class="headerlink" title="基于注解配置Spring AOP"></a>基于注解配置Spring AOP</h3><pre><code class="java">aspect/MethodChecher.java
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

import java.text.SimpleDateFormat;
import java.util.Date;
@Component //标记当前类为组件
@Aspect //说明当前类是切面类
public class MethodChecker &#123;
    //环绕通知,参数为PointCut切点表达式
    @Around(&quot;execution(* com.imooc..*Service.*(..))&quot;)
    // @Before()   @After()   @AfterThrowing   @AfterReturning
    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
    public Object check(ProceedingJoinPoint pjp) throws Throwable &#123;
        try &#123;
            long startTime = new Date().getTime();
            Object ret = pjp.proceed();//执行目标方法
            long endTime = new Date().getTime();
            long duration = endTime - startTime; //执行时长
            if(duration &gt;= 1000)&#123;
                String className = pjp.getTarget().getClass().getName();
                String methodName = pjp.getSignature().getName();
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
                String now = sdf.format(new Date());
                System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;);
            &#125;
            return ret;
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;Exception message:&quot; + throwable.getMessage());
            throw throwable;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dao/UserDao
package com.imooc.spring.aop.dao;

import org.springframework.stereotype.Repository;

/**
 * 用户表Dao
 */
@Repository
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
----------------------------------------------
dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

import org.springframework.stereotype.Repository;

/**
 * 员工表Dao
 */
@Repository
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 用户服务
 */
@Service
public class UserService &#123;
    @Resource
    private UserDao userDao;

    public void createUser()&#123;
        try &#123;
            Thread.sleep(3000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
---------------------------------------------------------
service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 员工服务
 */
@Service
public class EmployeeService &#123;
    @Resource
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser();
    &#125;
&#125;
========================================================================
执行员工入职业务逻辑
新增用户数据
=======2024-01-12 17:06:18 669:com.imooc.spring.aop.service.UserService.createUser(3015ms)======

Process finished with exit code 0
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!--初始化IoC容器--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
  ★  &lt;!--启用Spring AOP注解模式--&gt; ★
    &lt;aop:aspectj-autoproxy/&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="增加了是说明这个类是需要被IoC实例化的"><a href="#增加了是说明这个类是需要被IoC实例化的" class="headerlink" title="增加了是说明这个类是需要被IoC实例化的"></a>增加了是说明这个类是需要被IoC实例化的</h6><ul>
<li>四种组件类型注解-声明当前类的功能与职责 【回忆上面的知识点】</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化</td>
</tr>
<tr>
<td><strong>@Controller</strong></td>
<td>语义注解,说明当前类是MVC应用中的控制器类</td>
</tr>
<tr>
<td><strong>@Service</strong></td>
<td>语义注解,说明当前类是Service业务服务类</td>
</tr>
<tr>
<td><strong>@Repository</strong></td>
<td>语义注解,说明当前类用于业务持久层,通常描述对应Dao类</td>
</tr>
</tbody></table>
<h3 id="Spring-AOP实现原理"><a href="#Spring-AOP实现原理" class="headerlink" title="Spring AOP实现原理"></a>Spring AOP实现原理</h3><h6 id="★★★★★-面试-Spring-AOP-底层的实现原理-★★★★★★"><a href="#★★★★★-面试-Spring-AOP-底层的实现原理-★★★★★★" class="headerlink" title="★★★★★ 面试 Spring AOP 底层的实现原理 ★★★★★★"></a><span style = "color:red">★★★★★ 面试 Spring AOP 底层的实现原理 ★★★★★★</span></h6><ul>
<li><span style = "color:blue">Spring基于<strong>代理模式</strong>实现功能动态扩展，包含两种形式：</span><ul>
<li><strong><span style = "color:blue">目标类拥有接口，通过JDK动态代理实现功能扩展 来实现目标类的代理从而实现扩展</span></strong></li>
<li><strong><span style = "color:blue">目标类没有接口，通过CGLib组件实现功能扩展 通过继承的方式实现扩展</span></strong></li>
</ul>
</li>
</ul>
<h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><ul>
<li>代理模式通过代理对象对原对象的实现功能扩展</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1d5a848e492cf6e991719bfdc5cbbd31ef8a31fb/data/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png"></p>
<p>基于UserService接口实现代理类 同时持有与之对应的具体实现</p>
<h6 id="静态代理-每一个具体的委托类都要手动创造一个代理类"><a href="#静态代理-每一个具体的委托类都要手动创造一个代理类" class="headerlink" title="静态代理 [每一个具体的委托类都要手动创造一个代理类]"></a>静态代理 [每一个具体的委托类都要手动创造一个代理类]</h6><pre><code class="java">aop/service/UserService [接口]
package com.imooc.spring.aop.service;

public interface UserService &#123;
    public void createUser();
&#125;
-------------------------------------
aop/service/UserServiceImpl.java
package com.imooc.spring.aop.service;

public class UserServiceImpl implements UserService&#123;
    public void createUser() &#123;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
    &#125;
&#125;
-------------------------------------
aop/service/UserServiceProxy.java [代理]
package com.imooc.spring.aop.service;

import java.text.SimpleDateFormat;
import java.util.Date;
//静态代理是指必须手动创建代理类的代理模式使用方式
public class UserServiceProxy implements UserService&#123;
    //持有委托类的对象
    private UserService userService;
    public UserServiceProxy(UserService userService)&#123;
        this.userService = userService;
    &#125;

    public void createUser() &#123;
        System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;);
        userService.createUser();
    &#125;
&#125;
-------------------------------------
aop/service/UserServiceProxy1.java [代理1]
package com.imooc.spring.aop.service;

public class UserServiceProxy1 implements UserService&#123;
    private UserService userService ;
    public UserServiceProxy1(UserService userService)&#123;
        this.userService = userService;
    &#125;

    public void createUser() &#123;
        userService.createUser();
        System.out.println(&quot;========后置扩展功能======&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import com.imooc.spring.aop.service.UserServiceImpl;
import com.imooc.spring.aop.service.UserServiceProxy;
import com.imooc.spring.aop.service.UserServiceProxy1;

public class Application &#123;
    public static void main(String[] args) &#123; //类似于二房东
        UserService userService = new UserServiceProxy1(new UserServiceProxy(new UserServiceImpl()));
        userService.createUser();
    &#125;
&#125;
</code></pre>
<h3 id="AOP底层逻辑—JDK动态代理"><a href="#AOP底层逻辑—JDK动态代理" class="headerlink" title="AOP底层逻辑—JDK动态代理"></a>AOP底层逻辑—JDK动态代理</h3><pre><code class="java">aop/service.UserService.java [接口]
package com.imooc.spring.aop.service;

public interface UserService &#123;
    public void createUser();
&#125;


-------------------------------------
aop/service.EmployeeService.java [接口]
package com.imooc.spring.aop.service;

public interface EmployeeService &#123;
    public void createEmployee();
&#125;
</code></pre>
<pre><code class="java">aop/service.EmployeeServiceImpl.java
package com.imooc.spring.aop.service;

public class EmployeeServiceImpl implements EmployeeService &#123;
    public void createEmployee() &#123;
        System.out.println(&quot;执行创建员工业务逻辑&quot;);
    &#125;
&#125;
--------------------------------------
aop/service.UserServiceImpl.java
package com.imooc.spring.aop.service;

public class UserServiceImpl implements UserService&#123;
    public void createUser() &#123;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">ProxyInvocationHandler.java
package com.imooc.spring.aop.service;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * InvocationHandler是JDK提供的反射类,用于在JDK动态代理中对目标方法进行增强
 * InvocationHandler实现类与切面类的环绕通知类似
 */
public class ProxyInvocationHandler implements InvocationHandler &#123;
    private Object target;//目标对象
    private ProxyInvocationHandler(Object target)&#123;
        this.target = target;
    &#125;
    /**
     * 在invoke()方法对目标方法进行增强 反射method方法的时候遇见过invoke
     * @param proxy 代理类对象
     * @param method 目标方法对象
     * @param args 目标方法实参
     * @return 目标方法运行后返回值
     * @throws Throwable 目标方法抛出的异常
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;);
        Object ret = method.invoke(target, args);//调用目标方法,ProceedingJoinPoint.proceed()
        return ret;
    &#125;

    public static void main(String[] args) &#123;
        UserService userService = new UserServiceImpl();
        ProxyInvocationHandler invocationHandler = new ProxyInvocationHandler(userService);
        //动态创建代理类
        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),
                userService.getClass().getInterfaces(),
                invocationHandler);
        userServiceProxy.createUser();

        //动态代理,必须实现接口才可以运行
        EmployeeService employeeService = new EmployeeServiceImpl();
        EmployeeService employeeServiceProxy = (EmployeeService)Proxy.newProxyInstance(employeeService.getClass().getClassLoader(),
                employeeService.getClass().getInterfaces(),
                new ProxyInvocationHandler(employeeService));
        employeeServiceProxy.createEmployee();
    &#125;
&#125;

=======================================================

=====2024-01-12 19:52:34 179=========
执行创建用户业务逻辑
=====2024-01-12 19:52:34 181=========
执行创建员工业务逻辑

Process finished with exit code 0
</code></pre>
<img src="https://raw.githubusercontent.com/P-luminary/images/7942f4deaa97d742e38e14b1326c7064e1a28f50/data/AOP%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E2%80%94JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png"  />





<h3 id="AOP底层逻辑—CGLib实现代理类"><a href="#AOP底层逻辑—CGLib实现代理类" class="headerlink" title="AOP底层逻辑—CGLib实现代理类"></a>AOP底层逻辑—CGLib实现代理类</h3><ul>
<li>CGLib是运行时字节码增强技术</li>
<li>Spring AOP扩展无接口类使用CGLib</li>
<li>AOP会运行时生成目标继承类字节码的方式进行行为扩展</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7aa4a34eb72920c28d071577e2c074f4cf266e1a/data/AOP%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E2%80%94CGLib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB.jpg"></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/107a911bbe025f10f9f6629b01583a222956ca9f/data/CGLib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB%20%E6%95%88%E6%9E%9C%E5%9B%BE.jpg" style="zoom:80%;" />



<h3 id="Spring-JDBC与事务管理"><a href="#Spring-JDBC与事务管理" class="headerlink" title="Spring JDBC与事务管理"></a>Spring JDBC与事务管理</h3><h5 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h5><ul>
<li>Spring JDBC是Spring框架用于处理关系型数据库的模块</li>
<li>Spring JDBC对JDBC API进行封装，极大简化开发工作量</li>
<li>JdbcTemplate是Spring JDBC核心类, 提供数据CRUD方法</li>
</ul>
<h5 id="为什么有了Mybatis还需要Spring-JDBC？"><a href="#为什么有了Mybatis还需要Spring-JDBC？" class="headerlink" title="为什么有了Mybatis还需要Spring JDBC？"></a>为什么有了Mybatis还需要Spring JDBC？</h5><p>因为这两者面向的对象是不一样的<br><strong>mybatis 封装程度</strong>高适合中小企业敏捷开发, 快速完成与数据库交互的工作, 封装程度高 执行效率低【慢】<br>Spring JDBC只是对原始的JDBC的API进行了简单封装 大厂使用【轻量级】可二次封装</p>
<h3 id="Spring-JDBC的使用步骤"><a href="#Spring-JDBC的使用步骤" class="headerlink" title="Spring JDBC的使用步骤"></a>Spring JDBC的使用步骤</h3><ul>
<li><p>Maven工程引入依赖<code>spring-jdbc</code></p>
</li>
<li><p>applicationContext.xml配置<code>DataSource</code>数据源 [<u>用于指向连接哪数据库的哪种服务器 账号密码都是啥</u>]</p>
</li>
<li><p>在Dao注入<code>JdbcTemplate</code>对象, 实现数据CRUD</p>
</li>
</ul>
<h2 id="JdbcTemplate类"><a href="#JdbcTemplate类" class="headerlink" title="JdbcTemplate类"></a>JdbcTemplate类</h2><h6 id="Spring-JdbcTemplate类的方法"><a href="#Spring-JdbcTemplate类的方法" class="headerlink" title="Spring JdbcTemplate类的方法"></a>Spring JdbcTemplate类的方法</h6><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int update(String query)</td>
<td>用于插入，更新和删除记录。</td>
</tr>
<tr>
<td>public int update(String query，Object … args)</td>
<td>用于通过使用给定参数的PreparedStatement插入，更新和删除记录。</td>
</tr>
<tr>
<td>public void execute(String query)</td>
<td>用于执行DDL查询。</td>
</tr>
<tr>
<td>public T execute(String sql, PreparedStatementCallback action)</td>
<td>通过使用PreparedStatement回调执行查询。</td>
</tr>
<tr>
<td>public T query(String sql, ResultSetExtractor rse)</td>
<td>用于使用ResultSetExtractor获取记录。</td>
</tr>
<tr>
<td>public List query(String sql, RowMapper rse)</td>
<td>用于使用RowMapper获取记录。</td>
</tr>
</tbody></table>
<h3 id="JdbcTemplate实现增删改查"><a href="#JdbcTemplate实现增删改查" class="headerlink" title="JdbcTemplate实现增删改查"></a>JdbcTemplate实现增删改查</h3><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml [SpringIoC基础配置文件]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 数据源设置：使用哪种服务器 哪种数据源 账号密码是什么 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API 让IoC容器初始化的时候自动实例化jdbcTemplate 实例化的过程中要将设置好的数据源dataSource注入到jdbcTemplate属性中 此时就完成了实例化--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
&lt;!--    为Dao注入JdbcTemplate对象 --&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/entity/Employee.java
public class Employee &#123;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &quot;, hiredate=&quot; + hiredate +
                &#39;&#125;&#39;;
    &#125;
&#125; +Setter Getter
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

public class EmployeeDao &#123;
/*    依赖与jdbcTemplate 要持有其
* &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
* */
    private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.jdbc;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        EmployeeDao employeeDao = context.getBean(&quot;employeeDao&quot;, EmployeeDao.class);
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);

    &#125;
&#125;

=======================================================
Employee&#123;eno=3308, ename=&#39;张三&#39;, salary=6000.0, dname=&#39;研发部&#39;, hiredate=2011-05-08 00:00:00.0&#125;

Process finished with exit code 0
</code></pre>
<h3 id="JdbcTemplate的数据查询方法"><a href="#JdbcTemplate的数据查询方法" class="headerlink" title="JdbcTemplate的数据查询方法"></a>JdbcTemplate的数据查询方法</h3><pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

public class EmployeeDao &#123;
/*    依赖与jdbcTemplate 要持有其
* &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
* */
    private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        //查询单条数据 转换成对象
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;
    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据                             sql  对应的参数数组  转换的Mapper对象
        //多条记录 每一条记录转换为一个实体对象 放入List集合中进行返回
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;yan&#39;fa&#39;bu&quot;));
    &#125;
&#125;
================================================================
[Employee&#123;eno=3308, ename=&#39;张三&#39;, salary=6000.0, dname=&#39;研发部&#39;, hiredate=2011-05-08 00:00:00.0&#125;, Employee&#123;eno=3420, ename=&#39;李四&#39;, salary=8700.0, dname=&#39;研发部&#39;, hiredate=2006-11-11 00:00:00.0&#125;]


Process finished with exit code 0
</code></pre>
<pre><code class="java">★★ 新增 ★★
在没有对应的实体类情况下也可以得到相应的结果 结果被封装成为了Map对象
EmployeeDao.java
//    按列表返回每一条按Map对象列表返回
    public List findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno, salary as a from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;


JdbcTemplateTestor.java
@Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;
================================================================
[&#123;empno=3308, a=6000.0&#125;, &#123;empno=3420, a=8700.0&#125;]

Process finished with exit code 0
</code></pre>
<pre><code class="java">总结  [★★★★ queryForObject query queryForList ★★★★]
 private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        // ★★查询单条数据 转换成对象 ★★
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        // ★★查询复合数据★★                      sql  对应的参数数组  转换的Mapper对象
        // ★★多条记录 每一条记录转换为一个实体对象★★ 放入List集合中进行返回
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

//    按列表返回每一条按Map对象列表返回
//特殊情况：无法进行实体类的映射则可用直接用queryForList特殊返回Map 来完成对应数据的封装
    public List findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno, salary as a from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

</code></pre>
<h3 id="JdbcTemplate实现增删改查-1"><a href="#JdbcTemplate实现增删改查-1" class="headerlink" title="JdbcTemplate实现增删改查"></a>JdbcTemplate实现增删改查</h3><pre><code class="java">★★ 增 ★★
EmployeeDao.java
public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        jdbcTemplate.update(sql,new Object[]&#123;
                employee.getEno(), employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate()
        &#125;);
    &#125;

JdbcTemplateTestor.java
@Test
    public void testinsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;


★★ 更新 ★★
EmployeeDao.java
public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename=?, salary=?, dname=?, hiredate=? WHERE eno=?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

JdbcTemplateTestor.java
@Test
    public void testUpdate() &#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;
=========================================================
本次更新1条数据

Process finished with exit code 0


★★ 删除 ★★
EmployeeDao.java
public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno=?&quot;;
        int update = jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
        return update;
    &#125;

JdbcTemplateTestor.java
@Test
    public void testDelete() &#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;
=========================================================
本次删除1条数据
</code></pre>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>事务式以一种可靠、一致的方法，访问和操作数据库的程序单元</li>
<li>说人话：要么把事情做完，要么什么都不做，不要做一半</li>
<li>事务依赖于数据库实现，MySQL通过<strong>事务区</strong>作为数据缓冲地带</li>
</ul>
<h3 id="编程式事务-手动控制啥时候提交-啥时候回滚"><a href="#编程式事务-手动控制啥时候提交-啥时候回滚" class="headerlink" title="编程式事务 [手动控制啥时候提交 啥时候回滚]"></a>编程式事务 [手动控制啥时候提交 啥时候回滚]</h3><ul>
<li>编程式事务是指通过代码手动提交回滚事务的事务控制方法</li>
<li>SpringJDBC通过TransactionManager事务管理器实现事务控制</li>
<li>事务管理器提供commit&#x2F;rollback方法进行事务提交与回滚</li>
</ul>
<blockquote>
<p>S1需求：公司来了10名新员工 批量导入员工表中 (要么什么都不做，要么把事情做完) 【类似银行存钱】</p>
</blockquote>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void bathImport()&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;



applicationContext.xml
&lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

    

JdbcTemplateTestor.java
@Resource
    private EmployeeService employeeService;
@Test
    public void testBatchImport()&#123;
        employeeService.bathImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

此方法是一条一条的增加写入sql操作
09:47:33.565 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
09:47:33.565 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)]
09:47:33.567 [main] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Fetching JDBC Connection from DataSource
09:47:33.567 [main] DEBUG org.springframework.jdbc.datasource.DriverManagerDataSource - Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true]
09:47:33.684 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state &#39;22007&#39;, error code &#39;1292&#39;, message [Incorrect date value: &#39;2024-01-14 09:47:33.564&#39; for column &#39;hiredate&#39; at row 1]
09:47:33.690 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
09:47:33.690 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)]
09:47:33.690 [main] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Fetching JDBC Connection from DataSource
09:47:33.690 [main] DEBUG org.springframework.jdbc.datasource.DriverManagerDataSource - Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true]
09:47:33.695 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state &#39;22007&#39;, error code &#39;1292&#39;, message [Incorrect date value: &#39;2024-01-14 09:47:33.69&#39; for column &#39;hiredate&#39; at row 1]
09:47:33.695 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
</code></pre>
<hr>
<hr>
<h3 id="编程式事务-2-放入事务区统一管理"><a href="#编程式事务-2-放入事务区统一管理" class="headerlink" title="编程式事务-2 [放入事务区统一管理]"></a>编程式事务-2 [放入事务区统一管理]</h3><pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private DataSourceTransactionManager transactionManager;
    public void bathImport()&#123;
        //定义了事务默认的标准配置
        TransactionDefinition definition = new DefaultTransactionDefinition();
        //开始一个事务 放在事务区中统一进行管理
        TransactionStatus status = transactionManager.getTransaction(definition);

        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                if (i==3)&#123;
                    throw new RuntimeException(&quot;意料之外的异常&quot;);
                &#125;
                Employee employee = new Employee();
                employee.setEno(8010 + i);
                employee.setEname(&quot;员工&quot; + i);
                employee.setSalary(4000f);
                employee.setDname(&quot;市场部&quot;);
                employee.setHiredate(new Date());
                employeeDao.insert(employee);
            &#125;
            //提交事务
            transactionManager.commit(status);
        &#125; catch (Exception e) &#123;
            //回滚事务
            transactionManager.rollback(status);
            e.printStackTrace();
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public DataSourceTransactionManager getTransactionManager() &#123;
        return transactionManager;
    &#125;

    public void setTransactionManager(DataSourceTransactionManager transactionManager) &#123;
        this.transactionManager = transactionManager;
    &#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 数据源设置：使用哪种服务器 哪种数据源 账号密码是什么 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
        &lt;!--    为Dao注入JdbcTemplate对象 --&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
&lt;!--     将属性进行注入 要添加其getter setter--&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    事务管理器 数据源  [整体提交以及回滚] 需要控制的类中注入bean id=&quot;transactionManager&quot; --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById() &#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname() &#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname() &#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testinsert() &#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void testUpdate() &#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testDelete() &#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.bathImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;
&#125;

========================================================
都是在一个数据库连接里操作的
10:01:16.165 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Initiating transaction rollback
10:01:16.165 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Rolling back JDBC transaction on Connection [com.mysql.cj.jdbc.ConnectionImpl@c88a337]
10:01:16.166 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Releasing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c88a337] after transaction
java.lang.RuntimeException: 意料之外的异常
    at com.imooc.spring.jdbc.service.EmployeeService.bathImport(EmployeeService.java:24)
    at JdbcTemplateTestor.testBatchImport(JdbcTemplateTestor.java:63)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
</code></pre>
<p>★★★ 编程式事务 ★★★<br>优点：容易理解 编程快<br>缺点：容易受到人为因素影响 结果致命</p>
<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><ul>
<li>声明式事务指在<strong>不修改源代码</strong>情况下通过配置形式自动实现事务控制, 声明式事务本质就是AOP环绕通知</li>
<li>当目标方法执行成功时, 自动提交事务</li>
<li>当目标方法抛出运行异常时, 自动事务回滚</li>
</ul>
<h5 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h5><ul>
<li>配置TransactionManager事务管理器</li>
<li>配置事务通知与事务属性</li>
<li>为事务通知绑定PointCut切点</li>
</ul>
<blockquote>
<p>需求：在不修改原始代码的情况下 配置Service里面的声明式事务</p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--    1-3具体含义：当我们目标方法是imooc包下Service 且方法名为batchImport的时候 则认为当前方法需要使用事务--&gt;
&lt;!--    利用transactionManager来完成对事务的提交以及回滚--&gt;

    &lt;!-- 1.事务管理器,用于创建事务/提交/回滚 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--2.事务通知配置,决定哪些方法使用事务,哪些方法不使用事务 advice是通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
 &lt;!-- ★★★★ 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用  propagation是事务传播行为★★★★--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 不支持事务--&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--3. 定义声明式事务的作用范围--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">EmployeeService.java
vpackage com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private BatchService batchService;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            //注意噢 这里是被注释的
//            if(i==3)&#123;
//                throw new RuntimeException(&quot;意料之外的异常&quot;);
//            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">EmployeeDao.java 未改变
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>
<h3 id="事务传播行为【面试】"><a href="#事务传播行为【面试】" class="headerlink" title="事务传播行为【面试】"></a>事务传播行为【面试】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/dfcdce285d42fc77d69cb614b61e298b10a7252a/data/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E4%B8%83%E7%A7%8D%E7%B1%BB%E5%9E%8B.jpg"></p>
<ul>
<li>事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式</li>
<li><code>XML:&lt;tx:method name=&quot;...&quot; propagation=&quot;REQUIRED&quot;/&gt;</code></li>
<li>注解: <code>@Transactional(propagation=Propagation.REQUIRED)</code></li>
</ul>
<blockquote>
<p>加个BatchService 然后在EmployeeService加一个private BatchService batchService;(getter + setter)  再次插入一个public void startImportJob()<br>进行applicationContext.xml的bean注入<br><bean id="batchService" class="com.imooc.spring.jdbc.service.BatchService"><br>    <property name="employeeDao" ref="employeeDao"/><br></bean></p>
<bean id="employeeService" class="com.imooc.spring.jdbc.service.EmployeeService">
    <property name="employeeDao" ref="employeeDao"/>
    <property name="batchService" ref="batchService"/>
</bean>

<p>会被声明式事务范围包裹噢<br>&lt;aop:pointcut id&#x3D;”pointcut” expression&#x3D;”execution(* com.imooc..*Service.*(..))”&#x2F;&gt;</p>
<pre><code class="java">applicationContext.xml
加入 importJob1 importJob2
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 --&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;

            &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
</code></pre>
<p>补充public void startImportJob()</p>
<pre><code class="java">public void startImportJob()&#123;
    //会有关联行为 若2失败则无法导入 1也会回滚
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

//方法： REQUIRES_NEW 不同方法运行在不同事务中 
//事务1开始 事务1挂起事务2开始 事务2提交 事务1恢复 事务1挂起事务3开始 事务3提交事务1恢复 事务1提交
          &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
上面的分这写
</code></pre>
</blockquote>
<pre><code class="java">com/imooc/spring/jdbc/service/BatchService.java
package com.imooc.spring.jdbc.service;
 
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;
public class BatchService &#123;

    private EmployeeDao employeeDao;

    public void importJob1()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;研发部员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;研发部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void importJob2()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(9000 + i);
            employee.setEname(&quot;市场部员工&quot; + i);
            employee.setSalary(4500f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private BatchService batchService;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
//            if(i==3)&#123;
//                throw new RuntimeException(&quot;意料之外的异常&quot;);
//            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void startImportJob()&#123;
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
public class EmployeeDao &#123;
    private JdbcTemplate jdbcTemplate;

    public Employee findById(Integer eno)&#123;
        String sql = &quot;select * from employee where eno = ?&quot;;
        //查询单条数据
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public List&lt;Map&lt;String, Object&gt;&gt; findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno , salary as s from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

    public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        //利用update方法实现数据写入操作
        jdbcTemplate.update(sql,new Object[]&#123;
           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()
        &#125;);
    &#125;

    public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

    public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno = ?&quot;;
        return jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
    &#125;


    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!-- 数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
        &lt;!--为Dao注入JdbcTemplate对象--&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
        &lt;property name=&quot;batchService&quot; ref=&quot;batchService&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;batchService&quot; class=&quot;com.imooc.spring.jdbc.service.BatchService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    1-3具体含义：当我们目标方法是imooc包下Service 且方法名为batchImport的时候 则认为当前方法需要使用事务--&gt;
&lt;!--    利用transactionManager来完成对事务的提交以及回滚--&gt;

    &lt;!-- 1.事务管理器,用于创建事务/提交/回滚 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--2.事务通知配置,决定哪些方法使用事务,哪些方法不使用事务 advice是通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 --&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;

            &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--3. 定义声明式事务的作用范围--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">jdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="注解配置声明式事务"><a href="#注解配置声明式事务" class="headerlink" title="注解配置声明式事务"></a>注解配置声明式事务</h3><pre><code class="java">//声明式事务核心注解
//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED
@Transactional(propagation = Propagation.REQUIRED) //不写也默认
写在类上就是所有 
写在方法就是单独方法运用
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
@Repository
public class EmployeeDao &#123;
    @Resource
    private JdbcTemplate jdbcTemplate;

    public Employee findById(Integer eno)&#123;
        String sql = &quot;select * from employee where eno = ?&quot;;
        //查询单条数据
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public List&lt;Map&lt;String, Object&gt;&gt; findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno , salary as s from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

    public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        //利用update方法实现数据写入操作
        jdbcTemplate.update(sql,new Object[]&#123;
           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()
        &#125;);
    &#125;

    public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

    public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno = ?&quot;;
        return jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
    &#125;


    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/entity/Employee.java
public class Employee &#123;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;
&#125; getter+setter
     @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &quot;, hiredate=&quot; + hiredate +
                &#39;&#125;&#39;;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/BatchService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.sun.xml.internal.ws.developer.Serialization;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
@Service
//不需要使用事务 只读操作
@Transactional(propagation = Propagation.NOT_SUPPORTED,readOnly = true)
public class BatchService &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void importJob1()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;研发部员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;研发部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void importJob2()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(9000 + i);
            employee.setEname(&quot;市场部员工&quot; + i);
            employee.setSalary(4500f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
@Service
//声明式事务核心注解
//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED
@Transactional(propagation = Propagation.REQUIRED) //不写也默认
public class EmployeeService &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private BatchService batchService;

    @Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true)
    public Employee findById(Integer eno)&#123;
        return employeeDao.findById(eno);
    &#125;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            if(i==3)&#123;
                throw new RuntimeException(&quot;意料之外的异常&quot;);
            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void startImportJob()&#123;
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
    &lt;!--数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--JdbcTemplate--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- 启用注解形式声明式事务 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">test/java/JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/12/09/后端/Spring(切点表达式,通知,AOP,CGLib代理,Spring JdbcTemplate,事务)/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/11/19/英语/四级作文-新/">
        <h2>
            四级作文(新)
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/11/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="作文评分原则"><a href="#作文评分原则" class="headerlink" title="作文评分原则"></a>作文评分原则</h3><h6 id="内容：50-结构：10-语言：40"><a href="#内容：50-结构：10-语言：40" class="headerlink" title="内容：50%    结构：10%    语言：40%"></a>内容：50%    结构：10%    语言：40%</h6><ol>
<li>充实文章的内容：七种方法</li>
<li>固定文章的结构：总分总</li>
<li>丰富文章的语言：读范文；讲句型；躲错误；备模板</li>
</ol>
<h1 id="特点一：内容充实"><a href="#特点一：内容充实" class="headerlink" title="特点一：内容充实"></a><span style = "color:orange">特点一：内容充实</span></h1><h6 id="expert-testimony-专家证言法"><a href="#expert-testimony-专家证言法" class="headerlink" title="expert testimony 专家证言法"></a><span style = "color:blue">expert testimony 专家证言法</span></h6><p><strong>declare</strong> 宣称,声称 (替代think)<br><strong>claim</strong> (替代think)<br><del>exclaim 大叫(shout , yell)</del></p>
<p><strong>① It is plain common sense from those authoritative research that…</strong><br><strong>② Based on their findings, the experts claim that…</strong></p>
<h6 id="statistics-统计数据法"><a href="#statistics-统计数据法" class="headerlink" title="statistics 统计数据法"></a><span style = "color:blue">statistics 统计数据法</span></h6><p>reduce<br>dramatically</p>
<p><strong>① According to a recent survey, thousands of people has found 80% of respondents claimed that…</strong></p>
<h6 id="example-举例子-文章字不够举例子来凑-2个"><a href="#example-举例子-文章字不够举例子来凑-2个" class="headerlink" title="example 举例子 (文章字不够举例子来凑) (2个)"></a><span style = "color:red">example 举例子</span> (文章字不够举例子来凑) (2个)</h6><p>deal with &#x3D; cope with &#x3D; dispose of (解决)<br>efficiently(有效地) &#x2F; effective(有效率的)<br><strong>concentrate on</strong> &#x3D; pay attention to &#x3D; <strong>absorb in</strong> &#x3D; dedicate to &#x3D; indulge in &#x3D; focus on</p>
<p><strong>① Taking a look around, we can find the following examples in our daily lives.</strong><br><strong>② A good case in point is that…</strong><br><strong>③ As an illustration, we may take …as an example.</strong><br><strong>④ A typical example of this is that…</strong><br><u>A typical example of this is that</u> in most families, there is only one child who is loved by not only patents, but also grandparents.</p>
<h6 id="personal-experience-个人经历"><a href="#personal-experience-个人经历" class="headerlink" title="personal experience 个人经历"></a><span style = "color:blue">personal experience 个人经历</span></h6><h6 id="Logic-amp-Reasoning-逻辑推理"><a href="#Logic-amp-Reasoning-逻辑推理" class="headerlink" title="Logic &amp; Reasoning 逻辑推理"></a><span style = "color:blue">Logic &amp; Reasoning 逻辑推理</span></h6><p>​    <strong>分析原因段</strong> (一般都是第二段)<br>​    ① 三个原因 + 一个例子<br>​    ② 两个原因 + 两个例子</p>
<p>​    <strong>解决问题段</strong><br>​    deal with &#x3D; cope with &#x3D; dispose of (解决)</p>
<p>​    ① <strong>国家</strong>政府角度谈 (权威)<br>​    ② 全<strong>社会</strong>人民角度谈 (广泛)<br>​    ③ 就我<strong>个人</strong>而言 (个人)</p>
<h6 id="known-facts-常识法"><a href="#known-facts-常识法" class="headerlink" title="known facts 常识法"></a><span style = "color:blue">known facts 常识法</span></h6><p>consider&#x2F;considerate(adj)<br>consideration(共同的名词词性)[考虑&#x2F;]<br>take sth. into consideration</p>
<p><strong>① It is truism that…</strong><br><strong>② It comes to light that…</strong></p>
<h6 id="analogy-类比-目标A-但是去说B最后与A关联"><a href="#analogy-类比-目标A-但是去说B最后与A关联" class="headerlink" title="analogy 类比(目标A 但是去说B最后与A关联)"></a><span style = "color:blue">analogy 类比</span>(目标A 但是去说B最后与A关联)</h6><p>tend(照顾,倾向于)  extend(延伸,口)    pretend(假装)    intend(打算) &#x3D; mean to do</p>
<h3 id="第二部分：四级写作的出题方式"><a href="#第二部分：四级写作的出题方式" class="headerlink" title="第二部分：四级写作的出题方式"></a>第二部分：四级写作的出题方式</h3><h4 id="一-提纲式作文"><a href="#一-提纲式作文" class="headerlink" title="(一) 提纲式作文"></a>(一) 提纲式作文</h4><p>… on the topic Will <strong>E-books replaced traditional books</strong>? You should write at 150 words following the outline given below in Chinese:<br>① 随着信息技术的发展, 电子图书越来越多<br>② 有人认为电子图书会取代传统图书<br>③ 我的看法</p>
<h4 id="二-图表作文-x2F-漫画式作文"><a href="#二-图表作文-x2F-漫画式作文" class="headerlink" title="(二) 图表作文&#x2F;漫画式作文"></a>(二) 图表作文&#x2F;漫画式作文</h4><h4 id="三-应用文"><a href="#三-应用文" class="headerlink" title="(三) 应用文"></a>(三) 应用文</h4><p>… to write <strong>a letter to a company declining a job offer</strong>.<br>① 对公司提供职位标识感激<br>② 有人认为电子图书会取代传统图书<br>③ 我的看法</p>
<h4 id="四-记叙文"><a href="#四-记叙文" class="headerlink" title="(四) 记叙文"></a>(四) 记叙文</h4><p>… to write a composition on the topic “<strong>The most unforgettable person I ever know.</strong>“</p>
<hr>
<h3 id="第三部分：四级的三段论"><a href="#第三部分：四级的三段论" class="headerlink" title="第三部分：四级的三段论"></a>第三部分：四级的三段论</h3><h4 id="一-现象描述型"><a href="#一-现象描述型" class="headerlink" title="(一) 现象描述型"></a>(一) 现象描述型</h4><p>第一段：描述现象，引出话题<br>第二段：阐述正反观点<br>第三段：观点结论</p>
<h4 id="二-问题解决型"><a href="#二-问题解决型" class="headerlink" title="(二) 问题解决型"></a>(二) 问题解决型</h4><p>第一段：问题描述<br>第二段：解决问题的原因<br>第三段：解决问题的措施</p>
<h4 id="三-对比观点型"><a href="#三-对比观点型" class="headerlink" title="(三) 对比观点型"></a>(三) 对比观点型</h4><p>第一段：正方观点 + 理由<br>第二段：反方观点 + 理由<br>第三段：观点结论</p>
<h4 id="四-应用文-每段的第一个句子要成为主题句出现-三个主题句"><a href="#四-应用文-每段的第一个句子要成为主题句出现-三个主题句" class="headerlink" title="(四) 应用文 (每段的第一个句子要成为主题句出现 三个主题句)"></a>(四) 应用文 (每段的第一个句子要成为主题句出现 三个主题句)</h4><p>第一段：写信目的<br>第二段：写信内容<br>第三段：结束语</p>
<h4 id="五-引语类"><a href="#五-引语类" class="headerlink" title="(五) 引语类"></a>(五) 引语类</h4><p>第一段：引语含义<br>第二段：观点阐述<br>第三段：观点结论</p>
<h4 id="六-漫画-x2F-图表作文"><a href="#六-漫画-x2F-图表作文" class="headerlink" title="(六) 漫画&#x2F;图表作文"></a>(六) 漫画&#x2F;图表作文</h4><p>第一段：描述漫画&#x2F;图表内容<br>第二段：分析原因&#x2F;观点阐述 (可单独 可融合)<br>第三段：展望未来&#x2F;解决问题</p>
<h4 id="七-记叙文"><a href="#七-记叙文" class="headerlink" title="(七) 记叙文"></a>(七) 记叙文</h4><p>第一段：描述概况<br>第二段：描述事件经过细节<br>第三段：得出结论</p>
<hr>
<h3 id="第四部分：四级写作评分实例-阅读范文"><a href="#第四部分：四级写作评分实例-阅读范文" class="headerlink" title="第四部分：四级写作评分实例(阅读范文)"></a>第四部分：四级写作评分实例(阅读范文)</h3><p>… on the topic <strong>Should one expect a reward when doing a good deed ?</strong><br>① 有人做好事期望得到回报<br>② 有人认为应该像雷锋那样做好事不图回报<br>③ 我的观点<br><span style = " color : red">每当写完一个句子 就问问自己后面能写原因吗**(原因状语从句)**</span></p>
<p>​                                            Should one expect a reward when doing a good deed<br>​    <span style = " color : blue"><strong>Different people hold different view about</strong></span> whether or not one should expect a reward when doing a good deed. <span style = " color : blue"><strong>Some argue<span style = "color:red">(替代think)</span> that people should be given</strong></span> a certain reward for their good deed, <span style = " color : blue">because they believe<span style = "color:red">(替代think)</span> the saying</span> “No pain, no gains”. <span style = " color : blue"><strong>In addition<span style = "color:red">(替代and)</span>, they maintain<span style = "color:red">(替代think)</span> that in some sense</strong></span> rewards can <span style = " color : blue">stimulate<span style = "color:red">(代替encourage)</span> people’s enthusiasm to do</span> good deeds.</p>
<h5 id="①-argue可以替代think的"><a href="#①-argue可以替代think的" class="headerlink" title="① argue可以替代think的"></a><span style = " color : red">① argue</span>可以替代think的</h5><h6 id="单词：assume，deem，reckon，maintain"><a href="#单词：assume，deem，reckon，maintain" class="headerlink" title="单词：assume，deem，reckon，maintain"></a>单词：assume，deem，reckon，maintain</h6><h6 id="短语："><a href="#短语：" class="headerlink" title="短语："></a>短语：</h6><p>​    (1) hold the opinion&#x2F; belief&#x2F; point that…<br>​    (2) harbor the idea that…<br>​    (3) take the attitude that…<br>​    (4) be firmly&#x2F; fully convinced that…</p>
<h6 id="句子："><a href="#句子：" class="headerlink" title="句子："></a>句子：</h6><p>​    (1) It is widely shared that…<br>​    (2) It is universally acknowledged</p>
<p><span style = " color : red"><strong>argue</strong></span>的扩展<br><strong>I think</strong><br>&#x3D; to my knowledge<br>&#x3D; from my personal perspective<br>&#x3D; from my point of view<br>&#x3D; from my angle</p>
<p>所有的介词或介词短语后面都要加 名词&#x2F;名词短语。只有连词后面才可以加句子</p>
<p><span style = " color : red">**② because of **</span>+ 短语 (because of your help)<br>on account of、due to、thanks to、by virtue of、in light of、<br>be responsible for</p>
<p><span style = " color : red">③ because</span> + 句子 (because you help me)<br>in that、for the reason that、on the ground that、seeing that、<strong>considering that</strong></p>
<p><span style = " color : red"><strong>④ 动词短语</strong></span></p>
<ul>
<li>(1) 前<strong>因</strong>后<strong>果</strong> “导致”    <ul>
<li>contribute to</li>
<li>lead to</li>
<li>result in</li>
</ul>
</li>
</ul>
<p>例句：Eating too much fat can ___ heart disease.</p>
<ul>
<li>(2) 前<strong>果</strong>后<strong>因</strong> “归因于”<ul>
<li>attribute to</li>
<li>result from</li>
<li>credit to (credit hour学时  credit card信用卡)</li>
</ul>
</li>
</ul>
<p>例句：The accident <strong>resulted from</strong> the driver’s carelessness.<br>例句：The driver’s carelessness **resulted in **the accident.</p>
<ul>
<li>(3) 混合<strong>因果</strong> (誰前誰后都可以)<ul>
<li>be bound up with<br>(<u>be bound to do sth</u>    The cars are bound to be disused[可<u>+原因状语从句</u>].)</li>
<li>be associated with<br>(association 协会&#x2F;团队)</li>
</ul>
</li>
</ul>
<p>例句：Cancer <strong>is bound up with</strong> smoking.<br>例句：Smoking <strong>is bound up with</strong> cancer.</p>
<p>​    <span style = " color : blue"><strong>However, others have different viewpoint.</strong></span> They regard LeiFeng as a model, <strong>who</strong>(定语从句)) always helps others without ever expecting any reward. <span style = " color : blue"><strong>They assume that</strong></span> doing a good deed <span style = " color : blue"><strong>should be based on</strong></span> people’s individual consciousness of responsibility, <span style = " color : blue"><strong>and hence<span style = "color:red">(结果从句)</span> little<span style = "color:red">(不…)</span> significance should be attached to</strong></span> monetary reward. <span style = " color : blue"><strong>In addition</strong></span>, one can enjoy the happiness and peace through <strong>what</strong>(宾语从句) he had done, they think, <strong>which</strong>(定语从句) is the best return.</p>
<p>​    <span style = " color : blue"><strong>Personally, I prefer the latter(former) opinion.</strong></span> <span style = " color : blue"><strong>It is imperative for us to</strong></span>(对…来说做…是) conduct good deeds without expecting any reward. <span style = " color : blue"><strong>For one thing, the authorities should make laws and regulations to encourage people to do<span style = "color:red">(法律法规)</span></strong></span> good deeds. <span style = " color : blue"><strong>For another, people’s awareness should be cultivated that</strong></span> conducing good deeds <span style = " color : blue"><strong>is extremely<span style = "color:red">(very)</span> meaningful to our lives. It should be universally acknowledged that</strong></span> we do good deeds for enjoyment, self-fulfillment and spiritual enhancement, not for the rewards.</p>
<h1 id="第二部分：语言丰富"><a href="#第二部分：语言丰富" class="headerlink" title="第二部分：语言丰富"></a><span style = "color:orange">第二部分：语言丰富</span></h1><h4 id="一、长句-短句错落有致-3-4"><a href="#一、长句-短句错落有致-3-4" class="headerlink" title="一、长句|短句错落有致 (3-4)"></a>一、长句|短句错落有致 (3-4)</h4><h4 id="二、主动-被动适当穿插-2-3"><a href="#二、主动-被动适当穿插-2-3" class="headerlink" title="二、主动|被动适当穿插 (2-3)"></a>二、主动|被动适当穿插 (2-3)</h4><h4 id="三、比较结构巧妙使用-1-2"><a href="#三、比较结构巧妙使用-1-2" class="headerlink" title="三、比较结构巧妙使用 (1-2)"></a>三、比较结构巧妙使用 (1-2)</h4><h4 id="四、强调倒装恰当运用-1-1"><a href="#四、强调倒装恰当运用-1-1" class="headerlink" title="四、强调倒装恰当运用 (1-1)"></a>四、强调倒装恰当运用 (1-1)</h4><h4 id="五、句和句间衔接紧密"><a href="#五、句和句间衔接紧密" class="headerlink" title="五、句和句间衔接紧密"></a>五、句和句间衔接紧密</h4><hr>
<h6 id="一、短句"><a href="#一、短句" class="headerlink" title="一、短句"></a>一、短句</h6><ul>
<li>类型1：<strong>主语 + 谓语</strong> (I seen)</li>
<li>类型2：<strong>主语 + 谓语 + 宾语</strong> (主体+动词+对象)</li>
<li>类型3：<strong>主语 + 系动词 + 表语</strong>  (主体+系动词(be_感官)(动词分支)+对象)</li>
<li>类型4：<strong>主语 + 谓语 + 双宾语</strong> (主体+动词+对象+对象)(<strong>都可以改被动就是双宾否则就是宾补</strong>)</li>
<li>类型5：<strong>主语 + 谓语 + 宾语 + 宾补</strong> (主体+动词+对象+对宾语的补充说明)</li>
</ul>
<p><span style = "color:red">只有<strong>名词、形容词、副词</strong>才可以变成句子(名词性从句、形容词性从句[<strong>定语从句</strong>]、副词性从句[<strong>状语从句</strong>])</span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/bd258af508752dfcfab1c2bbb18dd828579f1338/data/%E4%BB%8E%E5%8F%A5%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.png"></p>
<h6 id="长句"><a href="#长句" class="headerlink" title="长句"></a>长句</h6><h4 id="1-定语从句"><a href="#1-定语从句" class="headerlink" title="(1) 定语从句"></a><strong>(1) 定语从句</strong></h4><p>① This is <strong>the present</strong> <u>that</u> <em>he gave me for my birthday</em>. (什么样的present)<br>② <strong>The person</strong> <u>who</u> <em>broke the window</em> must pay for it.<br>③ <strong>Mr.Lee</strong>(<u>whom</u>) <em>you want to see</em> has come.<br>④ <strong>The girl</strong> <u>whose</u> <em>mother is ill is staying</em> at home today.<br>⑤ A dictionary is <strong>a book</strong> <u>which</u> <em>gives the meaning of words.</em></p>
<p>任何一个<strong>主语</strong>后面都可以加一个<strong>定语从句</strong>对<u>主语</u>进行修饰<br>任何一个<strong>宾语</strong>后面都可以加一个<strong>定语从句</strong>对<u>宾语&#x2F;双宾</u>进行修饰<br>每当造完一个短句子都要时刻提醒自己能不能加<strong>定语从句</strong> [<strong>人</strong>用who whom  <strong>物</strong>用which  that都可以用]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/236d7eb4836934e7fff851ca296af067241d7378/data/%E4%BB%8E%E5%8F%A5%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F2.jpg"></p>
<h4 id="2-状语从句-与含义相关-两句话粘一起-本质是连词-连接句子"><a href="#2-状语从句-与含义相关-两句话粘一起-本质是连词-连接句子" class="headerlink" title="(2) 状语从句 (与含义相关 两句话粘一起) (本质是连词[连接句子])"></a>(2) 状语从句 (与含义相关 两句话粘一起) (本质是连词[连接句子])</h4><p><span style = "color : red"><strong>时间</strong>，<strong>地点</strong>是一对儿</span>；<br><span style = "color : red"><strong>原因</strong>，<strong>结果</strong>为一家；</span><br><span style = "color : red"><strong>条件</strong>，<strong>目的</strong>有虚拟；</span>(一般不用)<br><span style = "color : red">我<strong>比较</strong>喜欢<strong>让步</strong>的<strong>方式</strong></span><br>人,物 + 定 (想一想能不能加！)<br>句子 + 原因结果时间</p>
<h5 id="1-时间状语从句-造完句问自己能产生时间吗"><a href="#1-时间状语从句-造完句问自己能产生时间吗" class="headerlink" title="1) 时间状语从句 (造完句问自己能产生时间吗)"></a>1) 时间状语从句 (造完句问自己能产生时间吗)</h5><p><strong>定语从句</strong>是内战 <strong>状语从句</strong>是侵略战争(拉一个句子来)(寻找句子之间的逻辑关系)<br><strong>When</strong> I arrived home, I had a little rest.<br>He sang <strong>as</strong> he danced.<br>You will grow wiser <strong>as</strong> you grow older.</p>
<h5 id="2-条件状语从句：-真实条件句和虚拟条件句"><a href="#2-条件状语从句：-真实条件句和虚拟条件句" class="headerlink" title="2) 条件状语从句：(真实条件句和虚拟条件句)"></a>2) 条件状语从句：(真实条件句和虚拟条件句)</h5><p>You will fail <strong>unless</strong> you study hard.<br>You will not fail <strong>if</strong> you study hard.<br>You may go there, <strong>as long as</strong> you keep quite.<br>I shall give you the book <strong>on condition that</strong> you return it tomorrow.<br>I will go <strong>provided that</strong> you go too.</p>
<h5 id="3-让步状语从句"><a href="#3-让步状语从句" class="headerlink" title="3) 让步状语从句"></a>3) 让步状语从句</h5><p><strong>Though&#x2F;Although</strong> it is raining, they are still running outside.<br>Child <strong>though</strong> he was, he knew what was the right thing to do.<br>Tired <strong>as</strong> he is, he goes on with his work.<br><strong>Despite&#x2F;In spite of</strong> wanting to see him again, she refused to reply to his letter.</p>
<h5 id="4-原因状语从句-强调句-找主谓宾-关联连接-任何一句话都可能变成"><a href="#4-原因状语从句-强调句-找主谓宾-关联连接-任何一句话都可能变成" class="headerlink" title="4) 原因状语从句(+强调句) [找主谓宾 关联连接] (任何一句话都可能变成)"></a>4) 原因状语从句(+强调句) [找主谓宾 关联连接] (任何一句话都可能变成)</h5><p><strong>It is because she is too inexperienced that</strong> she does know how to deal with the situation<br><strong>As&#x2F;Since</strong> you are not very well[主谓宾], you had better have a rest.[主谓宾]<br>&#x3D; It is Since you are not very well that you had better have a rest</p>
<p>It must have rained last night[主谓宾], <strong>for</strong> the ground is wet now.[主系表]<br>&#x3D; It is because&#x2F;for the ground is wet now that It must have rained last night</p>
<h5 id="5-目的状语从句-怎么怎么滴…-为了…-以防…"><a href="#5-目的状语从句-怎么怎么滴…-为了…-以防…" class="headerlink" title="5) 目的状语从句 (怎么怎么滴…  为了…  以防…)"></a>5) 目的状语从句 (怎么怎么滴…  为了…  以防…)</h5><p>You must speak louder <strong>so that&#x2F;in order that</strong> you can be heard by all.<br>He wrote the name down <strong>for fear that</strong> he should forget it.<br>Better take more clothes <strong>in case</strong> the weather be cold.</p>
<h6 id="注意：lest-in-case-for-fear-that所引导的状语从句中，动词可以用虚拟语气，形式为-should-动词原形-条件，目的有虚拟"><a href="#注意：lest-in-case-for-fear-that所引导的状语从句中，动词可以用虚拟语气，形式为-should-动词原形-条件，目的有虚拟" class="headerlink" title="注意：lest, in case, for fear that所引导的状语从句中，动词可以用虚拟语气，形式为 should + 动词原形 (条件，目的有虚拟)"></a>注意：<u>lest, in case, for fear that</u>所引导的状语从句中，动词可以用虚拟语气，形式为 should + 动词原形 (<span style = "color : red"><strong>条件</strong>，<strong>目的</strong>有虚拟)</span></h6><p>People must 关注 the P, lest it should be more and more 严重</p>
<h5 id="6-结果状语从句"><a href="#6-结果状语从句" class="headerlink" title="6) 结果状语从句"></a>6) 结果状语从句</h5><h6 id="引导结果状语从句的连词有：so-that-so…that-such…that"><a href="#引导结果状语从句的连词有：so-that-so…that-such…that" class="headerlink" title="引导结果状语从句的连词有：so that, so…that, such…that"></a>引导结果状语从句的连词有：so that, so…that, such…that</h6><p>He is <strong>so</strong> young <strong>that</strong> he can not go to school.<br>He is <strong>such</strong> a young boy <strong>that</strong> he can not go to school.</p>
<h6 id="补充常用句型"><a href="#补充常用句型" class="headerlink" title="补充常用句型"></a>补充常用句型</h6><p><strong>① so + 形容词&#x2F;副词 + that从句</strong><br>② so + 形容词 + a&#x2F;an + 单数可数名词 + that从句<br>③ such + a&#x2F;an + 形容词 + 单数可数名词 + that从句<br>④ such + 形容词 + 复数可数名词&#x2F;不可数名词 + that从句</p>
<h5 id="7-比较状语从句"><a href="#7-比较状语从句" class="headerlink" title="7) 比较状语从句"></a>7) 比较状语从句</h5><h6 id="引导比较状语从句的连词有：as…as-than-not-so…as-the-more…the-more等"><a href="#引导比较状语从句的连词有：as…as-than-not-so…as-the-more…the-more等" class="headerlink" title="引导比较状语从句的连词有：as…as, than, not so…as, the more…the more等"></a>引导比较状语从句的连词有：as…as, than, not so…as, the more…the more等</h6><p>He speaks English as fluently as his brother(does).<br>I can’t jump so&#x2F;as high as he(does).</p>
<h5 id="8-地点状语从句"><a href="#8-地点状语从句" class="headerlink" title="8) 地点状语从句"></a>8) 地点状语从句</h5><h6 id="引导地点状语从句的连词有：where-wherever以及-where构成的复合词等"><a href="#引导地点状语从句的连词有：where-wherever以及-where构成的复合词等" class="headerlink" title="引导地点状语从句的连词有：where, wherever以及 where构成的复合词等"></a>引导地点状语从句的连词有：where, wherever以及 where构成的复合词等</h6><p>① She found her calculator where she lost it.<br>② Wherever I am, I will miss you.<br>③ I happened to see your dictionary lie where I used it last time.<br>④ I happened to see your dictionary lie in the lab where I used it last time.</p>
<h5 id="9-方式状语从句"><a href="#9-方式状语从句" class="headerlink" title="9) 方式状语从句"></a>9) 方式状语从句</h5><p>① Just do as you are told.<br>② The workers went on working as if nothing had happened.</p>
<h4 id="3-名词性从句"><a href="#3-名词性从句" class="headerlink" title="(3) 名词性从句"></a>(3) 名词性从句</h4><h5 id="1-主语从句"><a href="#1-主语从句" class="headerlink" title="1) 主语从句"></a>1) 主语从句</h5><p>① That <u>she</u> had <u>won</u> <u>the first place</u>(主谓宾) <u>made us</u> very <u>happy</u>(主谓宾宾).<br><u><strong>五之一</strong>完整的主谓宾</u> (原因,结果,目的,条件) <u><strong>五之一</strong>完整的主谓宾</u><br>【五之一＋连词+五之一】<br>主语比较长的时候避免头重脚轻 可以用It做形式主语<br>&#x3D; It made us very happy that she had won the first place.</p>
<p>② Which team will win the match<br>&#x3D; It is still unknown which team will win the match is still unknown.<br><u><strong>五之一</strong>完整的主谓宾</u> 但是这是主语从句 所以主语就变成了一个句子<br><u>people protect the environment(主谓宾做主语)</u> is important要用连词连接一起<br>&#x3D; It is important that people protect the environment.(It可做形式主语但不是必须)</p>
<h6 id="补充：用it作形式主语的that-从句"><a href="#补充：用it作形式主语的that-从句" class="headerlink" title="补充：用it作形式主语的that-从句"></a>补充：用it作形式主语的that-从句</h6><h6 id="1-It-be-形容词-that从句"><a href="#1-It-be-形容词-that从句" class="headerlink" title="1. It + be + 形容词 + that从句"></a>1. It + be + 形容词 + that从句</h6><p>① It is necessary that… 有必要…<br>② It is important that… 重要的是…<br>③ It is obvious that… 很明显</p>
<h6 id="2-It-be-ed分词-that-从句"><a href="#2-It-be-ed分词-that-从句" class="headerlink" title="2. It + be + -ed分词 + that-从句"></a>2. It + be + -ed分词 + that-从句</h6><p>① It is believed that… 人们相信…<br>② It is known to all that… 纵所周知<br>③ It has been decided that… 已决定</p>
<h6 id="3-It-be-名词-that-从句"><a href="#3-It-be-名词-that-从句" class="headerlink" title="3. It + be + 名词 + that-从句"></a>3. It + be + 名词 + that-从句</h6><p>① It is common knowledge that…  …是常识<br>② It is a surprise that… 令人惊奇的是…<br>③ It is a fact that… 事实是</p>
<p>每当写完一个人能不能在人后面加定语从句<br>每当写完一个物能不能在物后面加定语从句<br>每当写完一个句子想一想在后面能不能加原因&#x2F;结果&#x2F;时间状语从句<br>写主语的时候想一想能不能把一个句子当主语</p>
<h5 id="2-宾语从句"><a href="#2-宾语从句" class="headerlink" title="2) 宾语从句"></a>2) 宾语从句</h5><h5 id="3-表语从句"><a href="#3-表语从句" class="headerlink" title="3) 表语从句"></a>3) 表语从句</h5><h5 id="4-同位语从句"><a href="#4-同位语从句" class="headerlink" title="4) 同位语从句"></a>4) 同位语从句</h5><h3 id="语言丰富方式二：主动被动适当穿插"><a href="#语言丰富方式二：主动被动适当穿插" class="headerlink" title="语言丰富方式二：主动被动适当穿插"></a>语言丰富方式二：主动被动适当穿插</h3><h5 id="1-被动语态的构成"><a href="#1-被动语态的构成" class="headerlink" title="1.被动语态的构成"></a>1.被动语态的构成</h5><p>**<span style = "color : red">① 一般现在时</span>**：am&#x2F;is&#x2F;are + done<br>**<span style = "color : red">② 一般过去时</span>**：was&#x2F;were + done<br>**<span style = "color : red">③ 一般将来时</span>**：will&#x2F;shall&#x2F;be going to be + done<br><strong>④ 过去将来时</strong>：would&#x2F;should&#x2F;be going to be + done<br><strong>⑤ 现在进行时</strong>：am&#x2F;is&#x2F;are being + done<br><strong>⑥ 过去进行时</strong>：was&#x2F;were being + done<br><strong>⑦ 过去完成时</strong>：had been + done</p>
<h5 id="2-被动语态的用法-至少3个"><a href="#2-被动语态的用法-至少3个" class="headerlink" title="2.被动语态的用法(至少3个)"></a>2.被动语态的用法(至少3个)</h5><h6 id="1-不知道或没有必要说明动作的执行者是誰-句子没主语"><a href="#1-不知道或没有必要说明动作的执行者是誰-句子没主语" class="headerlink" title="1) 不知道或没有必要说明动作的执行者是誰 (句子没主语)"></a>1) 不知道或没有必要说明动作的执行者是誰 (句子没主语)</h6><p>① Some new computers were stolen last night.<br>② This book was published in 1981.</p>
<h6 id="2-强调动作的承受者"><a href="#2-强调动作的承受者" class="headerlink" title="2) 强调动作的承受者"></a>2) 强调动作的承受者</h6><p>① Eight hours per day for sleep must be guaranteed.</p>
<h6 id="3-主动语态变被动语态的方法"><a href="#3-主动语态变被动语态的方法" class="headerlink" title="3) 主动语态变被动语态的方法"></a>3) 主动语态变被动语态的方法</h6><p><span style = "color : red">① 把主动语态的<strong>宾语</strong>变为被动语态的<strong>主语</strong></span><br><span style = "color : red">② 把谓语变成被动结构 (<strong>be+过去分词</strong>) [被动形式]</span><br><span style = "color : red">③ 把主动语态中的<strong>主语</strong><u>放在</u>介词<u><strong>by</strong>之后</u>作<strong>宾语</strong>, 将主格改为宾格</span></p>
<p>Ⅰ. All the people laughed at him.[一般过去时]<br>      He was laughed at by all the people.</p>
<p>Ⅱ. They make</p>
<h6 id="4-含有情态动词的被动语态：”情态动词-be-done”"><a href="#4-含有情态动词的被动语态：”情态动词-be-done”" class="headerlink" title="4) 含有情态动词的被动语态：”情态动词 + be + done”"></a>4) 含有情态动词的被动语态：”情态动词 + be + done”</h6><p>Ⅰ. We can repair this watch in two days.<br>      This watch can be repaired in two days.<br>Ⅱ. We must finish this work soon.<br>      This work must be done soon.</p>
<h6 id="5-主动语态变被动语态需要注意的几个问题"><a href="#5-主动语态变被动语态需要注意的几个问题" class="headerlink" title="5) 主动语态变被动语态需要注意的几个问题"></a>5) 主动语态变被动语态需要注意的几个问题</h6><p><strong>① 时态保持一致</strong><br>    Ⅰ. I have repaired my computer. [现在完成时]<br>         My computer has been repaired.</p>
<p><strong>② 被动语态不能丢掉动词短语的介词或副词</strong><br>    Ⅰ. His best friend often <strong>looks after</strong> him.<br>          He is often <strong>looked after</strong> by his best friend.</p>
<p><strong>③ 若双宾语(一个人一个物),将其中一个宾语变为被动句的主语,另一个宾语不变</strong><br>     make&#x2F;buy&#x2F;get用<strong>for</strong>； give&#x2F;send&#x2F;lend&#x2F;take用<strong>to</strong><br>    Ⅰ. Vivian gave <strong>me</strong> a book<br>          <strong>I</strong> was given <strong>a book</strong> by Vivian.<br>         <strong>A book</strong> was given to me by Vivian.<br>双宾： make&#x2F;buy&#x2F;get用<strong>for</strong>； give&#x2F;send&#x2F;lend&#x2F;take用<strong>to</strong><br>一定是一个人一个物<br><span style = "color : blue">如果先都说人 无论主动被动<strong>都没有介词</strong></span><br>I’ll give you the child</p>
<p><span style = "color : blue">如果先都说物    无论主动被动<strong>都有介词</strong></span><br>I am writing to your child</p>
<p><strong>④ 若复合宾语，将主动句的宾语变成被动句的主语，宾补不变</strong><br>    Ⅰ. <strong>They</strong> call <strong>him</strong> Louis.<br>          <strong>He</strong> is called Louis.</p>
<p><strong>⑤ “动词+宾语+宾语补足语”</strong>, 将宾语变为被动结构中的主语, 其余不动<br>    Ⅰ. Someone <strong>caught</strong> <strong><u>the boy</u></strong> <strong>smoking a cigarette</strong>.<br>          <strong>The boy</strong> was caught smoking a cigarette.</p>
<p><strong>⑥ It is said that+从句及类似句型</strong> 【据说…   人们…】</p>
<p>​    “It + be + 过去分词 + that从句” <strong>或</strong> “主语 + be + 过去分词 + to do sth”</p>
<pre><code class="java">被动句型(不会改被动就直接套用)
① It is said that... 据说
② It is reported that... 据报道
③ It is believed that... 大家相信
④ It is hoped that... 大家希望
⑤ It is well known that... 众所周知
⑥ It is thought that... 大家认为
⑦ It is suggested that... 据建议
</code></pre>
<h3 id="语言丰富方式三：比较结构巧妙使用"><a href="#语言丰富方式三：比较结构巧妙使用" class="headerlink" title="语言丰富方式三：比较结构巧妙使用"></a>语言丰富方式三：比较结构巧妙使用</h3><h5 id="1-同级比较"><a href="#1-同级比较" class="headerlink" title="1.同级比较"></a>1.同级比较</h5><h6 id="①-as…as-出现形容词副词-the-same-as-the-identical-with-与…一样"><a href="#①-as…as-出现形容词副词-the-same-as-the-identical-with-与…一样" class="headerlink" title="① as…as(出现形容词副词); the same as; the identical with;  与…一样"></a>① as…as(出现形容词副词); the same as; the identical with;  与…一样</h6><p>She has written <u>as many essays as</u> her brother.</p>
<h6 id="②-no-more…-than-或-not…any-more-than-和…一样不-A是不…-B也不…"><a href="#②-no-more…-than-或-not…any-more-than-和…一样不-A是不…-B也不…" class="headerlink" title="② no more… than 或 not…any more than;  和…一样不 (A是不… B也不…)"></a>② no more… than 或 not…any more than;  和…一样不 (A是不… B也不…)</h6><p>the more…the more句型【越来越…       越… 越…】</p>
<p>The heart is <u>no more intelligent than</u> the stomach, for they are both controlled by the brain.</p>
<h5 id="2-表最高程度"><a href="#2-表最高程度" class="headerlink" title="2.表最高程度"></a>2.表最高程度</h5><h6 id="①-no-名词-more…than；-没有什么比…更…-莫过于"><a href="#①-no-名词-more…than；-没有什么比…更…-莫过于" class="headerlink" title="① no + 名词 + more…than；  没有什么比…更…;  莫过于"></a>① no + 名词 + more…than；  没有什么比…更…;  莫过于</h6><p><u><strong>No</strong></u> tool is <u><strong>more <strong>powerful</u> for understanding the natural world <u><strong>than</strong> the scientific method.</u> 【<u>拉长 添加</strong>状语</strong> 定语</u>】</p>
<h6 id="②-more…than-anyone-和人比-x2F-anything-和物比-else；-比其他任何…都…、没有比…更…"><a href="#②-more…than-anyone-和人比-x2F-anything-和物比-else；-比其他任何…都…、没有比…更…" class="headerlink" title="② more…than + anyone(和人比)&#x2F;anything(和物比) else； 比其他任何…都…、没有比…更…"></a>② more…than + anyone(和人比)&#x2F;anything(和物比) else； 比其他任何…都…、没有比…更…</h6><p>He did <u>more</u> work this morning <u>than anyone else.</u></p>
<h5 id="3-表示倍数-【as、of、than】"><a href="#3-表示倍数-【as、of、than】" class="headerlink" title="3. 表示倍数 【as、of、than】"></a>3. 表示倍数 【as、of、than】</h5><p><strong>as</strong>…只能跟adj&#x2F;adv        <strong>of</strong>…只能跟n        <strong>than</strong>…只能跟比较级</p>
<h6 id="①-倍数-as-形容词或副词-as"><a href="#①-倍数-as-形容词或副词-as" class="headerlink" title="① 倍数 + as + 形容词或副词 + as"></a>① 倍数 + as + 形容词或副词 + as</h6><p>An ordinary subway train, approaching the station, can be <u>twice as loud as</u> the loudest jet.</p>
<h6 id="②-倍数-名词-of"><a href="#②-倍数-名词-of" class="headerlink" title="② 倍数 + 名词 + of"></a>② 倍数 + 名词 + of</h6><p>The bridge is <u>three times the length of</u> that one.</p>
<h6 id="③-倍数-比较级-than"><a href="#③-倍数-比较级-than" class="headerlink" title="③ 倍数 + 比较级 + than"></a>③ 倍数 + 比较级 + than</h6><p>This hole is <u>three times deeper than</u> that one.</p>
<h5 id="4-more-than"><a href="#4-more-than" class="headerlink" title="4. more than"></a>4. more than</h5><h6 id="①-more-than-动词或名词：”不仅仅是-不只是”"><a href="#①-more-than-动词或名词：”不仅仅是-不只是”" class="headerlink" title="① more than + 动词或名词：”不仅仅是, 不只是”"></a>① more than + 动词或名词：”不仅仅是, 不只是”</h6><p>They may teach very well, and more than earn their salaries, but most of them make little…</p>
<h6 id="②-more-than-形容词：非常-代替not-only、very、over"><a href="#②-more-than-形容词：非常-代替not-only、very、over" class="headerlink" title="② more than + 形容词：非常 (代替not only、very、over)"></a>② more than + 形容词：非常 (代替not only、very、over)</h6><p>The USA remains <u>more than capable</u> of holding down.</p>
<h3 id="语言丰富方式四：强调倒装恰当使用"><a href="#语言丰富方式四：强调倒装恰当使用" class="headerlink" title="语言丰富方式四：强调倒装恰当使用"></a>语言丰富方式四：强调倒装恰当使用</h3><h4 id="一-强调句：It-is-x2F-was-被强调的部分-that-句子的其他部分"><a href="#一-强调句：It-is-x2F-was-被强调的部分-that-句子的其他部分" class="headerlink" title="(一) 强调句：It is&#x2F;was + 被强调的部分 + that + 句子的其他部分"></a>(一) 强调句：It is&#x2F;was + 被强调的部分 + that + 句子的其他部分</h4><p>(<strong>谓语以外的任何成分</strong>都可以放在被强调部分当中进行强调)</p>
<h6 id="改写句子①"><a href="#改写句子①" class="headerlink" title="改写句子①"></a>改写句子①</h6><p><u>Wester health-care system</u> <strong>are spending</strong> <u>huge sums of money</u> <u>on the surgical treatment of the disease</u>.( 可以改成三个强调句)<br>① It is <strong>Wester health-care system</strong> that are spending huge sums of money on the surgical treatment of the disease.<br>② It is <strong>huge sums of money</strong> that Western health-care system are spending on the surgical treatment of the disease.<br>③ It is **on the surgical treatment of the disease ** that Western health-care system are spending huge sums of money.</p>
<h6 id="改写句子②"><a href="#改写句子②" class="headerlink" title="改写句子②"></a>改写句子②</h6><p><u>Ann Peters’ husband</u> <strong>rushed</strong> <u>her</u> <u>to a nearby hospital</u> <u>last night.</u><br>① It was <strong>Ann Peters’ husband</strong> that(who) rushed her to nearby hospital last night.<br>② It was <strong>her</strong> that(who) Ann Peters’ husband rushed her to nearby hospital last night.<br>③ It was <strong>to a nearby hospital</strong> that Ann Peters’ husband rushed her last night.<br>④ It was <strong>last night</strong> that Ann Peters’ husband rushed her to a nearby hospital.<br><strong>提示1：</strong><br>1.叙述的是现在或者将来：“It is … that … ”<br>2.叙述的是过去：”It was … that …”</p>
<p><strong>提示2：</strong></p>
<h6 id="强调动词的时候-没有强调句子谓语的强调句，但又其通常的强调手段：do-x2F-does-x2F-did-动词原形"><a href="#强调动词的时候-没有强调句子谓语的强调句，但又其通常的强调手段：do-x2F-does-x2F-did-动词原形" class="headerlink" title="强调动词的时候 没有强调句子谓语的强调句，但又其通常的强调手段：do &#x2F; does &#x2F; did + 动词原形"></a>强调动词的时候 没有强调句子谓语的强调句，但又其通常的强调手段：do &#x2F; does &#x2F; did + 动词原形</h6><p>I <strong>do</strong> believe that he is an honest man.<br>They <strong>did</strong> go to see you yesterday, but failed to meet you.</p>
<h4 id="二-倒装：-主谓-→-谓主-3个被动-定语-原因状语-强调句-倒装-only时间状语-so…that"><a href="#二-倒装：-主谓-→-谓主-3个被动-定语-原因状语-强调句-倒装-only时间状语-so…that" class="headerlink" title="(二) 倒装：(主谓 → 谓主) ( 3个被动 定语 原因状语 强调句 倒装[only时间状语  so…that])"></a>(二) 倒装：(主谓 → 谓主) ( 3个被动 定语 原因状语 强调句 倒装[only时间状语  so…that])</h4><p>① 指将谓语的一部分(如助动词或情态)至主语之前<br>② 如果句子的谓语没有助动词或情态动词，需加助动词do, does或did, 将其置于主语之前</p>
<h6 id="全部倒装"><a href="#全部倒装" class="headerlink" title="全部倒装"></a>全部倒装</h6><p>要把<strong>所有的谓语</strong>都拿到主语前面 和其他成分无关</p>
<h6 id="部分倒装"><a href="#部分倒装" class="headerlink" title="部分倒装"></a>部分倒装</h6><p>要把<strong>谓语的一部分</strong>拿到主语前面<br>助动词+动词        情态动词+动词</p>
<h6 id="1-only句首"><a href="#1-only句首" class="headerlink" title="1. only句首"></a>1. only句首</h6><p>① <strong>Only in this way can you learn</strong>(介词短语) English well.<br>② <strong>Only after being asked three times</strong>(非谓语动词) did he come to the meeting.<br>③ <span style = "color:red"><strong>Only when he is seriously ill</strong>(从句)</span> does he ever stay in bed.<br>Only when 大学生… do they 意识到…</p>
<h6 id="2-句首为否定意义的词语"><a href="#2-句首为否定意义的词语" class="headerlink" title="2. 句首为否定意义的词语"></a>2. 句首为否定意义的词语</h6><h6 id="如：no-never-seldom-little-hardly-at-no-time-in-no-way-not-until…等"><a href="#如：no-never-seldom-little-hardly-at-no-time-in-no-way-not-until…等" class="headerlink" title="如：no, never, seldom, little, hardly, at no time, in no way, not until…等"></a>如：no, never, seldom, little, hardly, at no time, in no way, not until…等</h6><p>① Never have I seen such a performance.<br>② Nowhere will you find the answer to this question.<br>③ Not until the child fell asleep did the mother leave the room.</p>
<h6 id="3-so…that-句型中的so位于句首时，需倒装"><a href="#3-so…that-句型中的so位于句首时，需倒装" class="headerlink" title="3. so…that 句型中的so位于句首时，需倒装"></a>3. so…that 句型中的so位于句首时，需倒装</h6><p>   he was so frightened that he did not dare to move an inch.<br>&#x3D;<strong>So</strong> frightened <strong>was he</strong> that he did not dare to move an inch.</p>
<h6 id="4-在虚拟语气中-可将if省略-采取部分倒装"><a href="#4-在虚拟语气中-可将if省略-采取部分倒装" class="headerlink" title="4. 在虚拟语气中, 可将if省略, 采取部分倒装"></a>4. 在虚拟语气中, 可将if省略, 采取部分倒装</h6><p>Were I you, I would try it again</p>
<h5 id="3个被动-定语-原因状语-强调句-倒装-写作必须拥有的"><a href="#3个被动-定语-原因状语-强调句-倒装-写作必须拥有的" class="headerlink" title="3个被动 定语 原因状语 强调句 倒装 写作必须拥有的"></a><span style = "color:red">3个被动 定语 原因状语 强调句 倒装 写作必须拥有的</span></h5><h3 id="八种万能功能段-三八大盖"><a href="#八种万能功能段-三八大盖" class="headerlink" title="八种万能功能段 (三八大盖)"></a>八种万能功能段 (三八大盖)</h3><h6 id="现象-x2F-问题描述功能段"><a href="#现象-x2F-问题描述功能段" class="headerlink" title="现象&#x2F;问题描述功能段"></a><span style = "color:blue">现象&#x2F;问题描述功能段</span></h6><p><strong>①</strong> In recent years, … is becoming increasingly popular&#x2F;prevalent at an amazing rate.<br>近年来, …越来越流行(现象)<br><strong>②</strong> <span style = "color:red">Along with the advance of the society more and more problems are brought to our attention, one of which is that…</span><br>随着社会的不断发展，出现了越来越多的问题引起我们的注意                                                                                                                                                                                  ，其中之一便是…</p>
<h6 id="原因分析功能段-总原因的阐述"><a href="#原因分析功能段-总原因的阐述" class="headerlink" title="原因分析功能段 (总原因的阐述)"></a><span style = "color:blue">原因分析功能段 (总原因的阐述)</span></h6><p>① <span style = "color:red">A number of factors might <u>contribute to</u>&#x2F;<u>account for</u> the phenomenon&#x2F;problem.</span><br>许多因素可能是造成这种现象&#x2F;问题的原因。<br>② The reasons for … mainly lie in the following two aspects.<br>原因…主要表现在以下两个方面。<br>(<strong>分原因阐述&#x3D;&gt;原因数量决定</strong>)<br>① <span style = "color:red">One of the most common factor is that…</span><br>② Another contributing cause is…<br>③ Perhaps the primary reason is that…<br>④ But the fundamental element is that…</p>
<h6 id="观点阐述功能段"><a href="#观点阐述功能段" class="headerlink" title="观点阐述功能段"></a><span style = "color:blue">观点阐述功能段</span></h6><p><strong>观点主题句</strong><br>① <span style = "color:red">People have (take,adopt,assume) different attitudes towards.</span><br>② People have different opinions on this problem.</p>
<p><strong>观点</strong><br>① <span style = "color:red">According to a survey, some people are in favor of the idea of doing… They point out the fact that(+支持…的第一个原因) they also argue that… (+支持…的另一个原因)</span></p>
<h6 id="观点结论功能段"><a href="#观点结论功能段" class="headerlink" title="观点结论功能段"></a><span style = "color:blue">观点结论功能段</span></h6><p>① <span style = "color:red">From what has been discussed above, we may safely draw the conclusion that…</span><br>根据以上讨论，我们可以得出下面的结论</p>
<h6 id="解决问题功能段"><a href="#解决问题功能段" class="headerlink" title="解决问题功能段"></a><span style = "color:blue">解决问题功能段</span></h6><p><strong>措施主题句</strong><br>① ___ has been playing an increasingly important role in our day-to-day life, which has brought us a lot of benefits but has created some serious problems as well.<br>…在日常生活中发挥着越来越重要的作用, 它给我们带来了很多好处</p>
<p><strong>分措施</strong><br>① <strong>First and foremost</strong>, government should establish some regulations to…<br>② <strong>What’s more</strong>, people should get ready to…<br>③ <strong>After all</strong>, it is necessary to advocate the whole society to…</p>
<p><strong>解决问题总结句</strong><br>① In summary, if we continue to ignore the above-mentioned issue, more problems will crop up.<br>总之，如果我们继续忽略上述问题，会有更多问题出现<br>② From my point of view, college students should … when it comes to … What’s more, we should always bear in mind that…<br>我认为, … 大学生应该自己…此外, 我们应牢记…</p>
<h6 id="未来展望功能段"><a href="#未来展望功能段" class="headerlink" title="未来展望功能段"></a><span style = "color:blue">未来展望功能段</span></h6><p>① It can directly promote the rapid progress of … , and eventually brings …<br>它可以直接促进…还可也用来…</p>
<h6 id="漫画-x2F-图表描述功能段"><a href="#漫画-x2F-图表描述功能段" class="headerlink" title="漫画&#x2F;图表描述功能段"></a><span style = "color:blue">漫画&#x2F;图表描述功能段</span></h6><p>① It  can be easily seen from the picture(chart&#x2F;line&#x2F;graph) that… The picture is intended to inform us of the bad effects of college student’s…<br>从图片中很容易可以看到, …这幅画是在告诉我们 … 有着不好的影响<br>② <span style = "color:red">According to the <u>figure&#x2F;number&#x2F;statistics</u> in the <u>chart&#x2F; bar graph&#x2F;line</u>, it can be seen that…</span></p>
<h6 id="引语解释功能段"><a href="#引语解释功能段" class="headerlink" title="引语解释功能段"></a><span style = "color:blue">引语解释功能段</span></h6><p>① <span style = "color:red">There is such a saying … This saying <strong>not only</strong> emphasizes the importance of… <strong>but also</strong> indicates that…</span><br>有这样一句名言：….这句话不仅强调了…的重要性，而且指出…</p>
<h5 id="附加：举例子"><a href="#附加：举例子" class="headerlink" title="附加：举例子"></a>附加：举例子</h5><p>① There may be no better example than the following one.</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#ffa2c4>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2023/11/19/英语/四级作文-新/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/11/15/后端/Linux,Redis,Jedis/">
        <h2>
            Linux,Redis,Jedis
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/11/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Linux基础入门"><a href="#Linux基础入门" class="headerlink" title="Linux基础入门"></a>Linux基础入门</h1><h3 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h3><ul>
<li><h6 id="介绍Linux与CentOS"><a href="#介绍Linux与CentOS" class="headerlink" title="介绍Linux与CentOS"></a>介绍Linux与CentOS</h6></li>
<li><h6 id="讲解Linux基础"><a href="#讲解Linux基础" class="headerlink" title="讲解Linux基础"></a>讲解Linux基础</h6></li>
<li><h6 id="Linux文本工具与命令"><a href="#Linux文本工具与命令" class="headerlink" title="Linux文本工具与命令"></a>Linux文本工具与命令</h6></li>
<li><h6 id="yum应用安装与卸载"><a href="#yum应用安装与卸载" class="headerlink" title="yum应用安装与卸载"></a>yum应用安装与卸载</h6></li>
<li><h6 id="CentOS的权限与系统安全"><a href="#CentOS的权限与系统安全" class="headerlink" title="CentOS的权限与系统安全"></a>CentOS的权限与系统安全</h6></li>
<li><h6 id="部署OA项目至Linux服务器"><a href="#部署OA项目至Linux服务器" class="headerlink" title="部署OA项目至Linux服务器"></a>部署OA项目至Linux服务器</h6></li>
</ul>
<h3 id="主流操作系统"><a href="#主流操作系统" class="headerlink" title="主流操作系统"></a>主流操作系统</h3><p>不同领域的主流操作系统，主要分为以下这么几类： 桌面操作系统、服务器操作系统、移动设备操作系统、嵌入式操作系统。接下来，这几个领域中，代表性的操作系统是那些?</p>
<p>1). 桌面操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td>用户数量最多</td>
</tr>
<tr>
<td>MacOS</td>
<td>操作体验好，办公人士首选</td>
</tr>
<tr>
<td>Linux</td>
<td>用户数量少(桌面操作系统,Linux使用较少)</td>
</tr>
</tbody></table>
<p>2). 服务器操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Unix</td>
<td>安全、稳定、付费</td>
</tr>
<tr>
<td>Linux</td>
<td>安全、稳定、免费、占有率高</td>
</tr>
<tr>
<td>Windows Server</td>
<td>付费、占有率低</td>
</tr>
</tbody></table>
<p>3). 移动设备操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Android</td>
<td>基于 Linux 、开源，主要用于智能手机、平板电脑和智能电视</td>
</tr>
<tr>
<td>IOS</td>
<td>苹果公司开发、不开源，用于苹果公司的产品，例如：iPhone、 iPad</td>
</tr>
</tbody></table>
<p>4). 嵌入式操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>机顶盒、路由器、交换机</td>
</tr>
</tbody></table>
<h3 id="2-2-Linux系统版本"><a href="#2-2-Linux系统版本" class="headerlink" title="2.2 Linux系统版本"></a>2.2 Linux系统版本</h3><p>Linux系统的版本分为两种，分别是： 内核版 和 发行版。</p>
<p><strong>1). 内核版</strong></p>
<ul>
<li><p>由Linus Torvalds及其团队开发、维护</p>
</li>
<li><p>免费、开源</p>
</li>
<li><p>负责控制硬件</p>
</li>
</ul>
<p><strong>2). 发行版</strong></p>
<ul>
<li><p>基于Linux内核版进行扩展</p>
</li>
<li><p>由各个Linux厂商开发、维护</p>
</li>
<li><p>有收费版本和免费版本</p>
</li>
</ul>
<p>我们使用Linux操作系统，实际上选择的是Linux的发行版本。在linux系统中，有各种各样的发行版本，具体如下： </p>
<table>
<thead>
<tr>
<th>发行版本</th>
<th>Logo</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu</td>
<td><img src="assets/image-20210809001838861.png" alt="image-20210809001838861" style="zoom:50%;" /></td>
<td>以桌面应用为主</td>
</tr>
<tr>
<td>RedHat</td>
<td><img src="assets/image-20210809001731378.png" alt="image-20210809001731378" style="zoom:50%;" /></td>
<td>应用最广泛、收费</td>
</tr>
<tr>
<td><strong>CentOS</strong></td>
<td><img src="assets/image-20210809001741238.png" alt="image-20210809001741238" style="zoom:50%;" /></td>
<td>RedHat的社区版、免费</td>
</tr>
<tr>
<td>openSUSE</td>
<td><img src="assets/image-20210809001750999.png" alt="image-20210809001750999" style="zoom:50%;" /></td>
<td>对个人完全免费、图形界面华丽</td>
</tr>
<tr>
<td>Fedora</td>
<td><img src="assets/image-20210809001800676.png" alt="image-20210809001800676" style="zoom:50%;" /></td>
<td>功能完备、快速更新、免费</td>
</tr>
<tr>
<td>红旗Linux</td>
<td><img src="assets/image-20210809001814942.png" alt="image-20210809001814942" style="zoom:50%;" /></td>
<td>北京中科红旗软件技术有限公司开发</td>
</tr>
</tbody></table>
<p>除了上述罗列出来的发行版，还有很多Linux发行版，这里，我们就不再一一列举了。</p>
<h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><ul>
<li>操作系统(<strong>O</strong>perating <strong>S</strong>ystem)是应用程序运行的基础支撑环境</li>
<li>操作系统作用是管理和控制计算机系统的硬件与软件资源</li>
<li>Intel x86架构上常见的操作系统：Windows、Linux、Unix…</li>
</ul>
<h3 id="Linux操作系统-1"><a href="#Linux操作系统-1" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h3><ul>
<li>Linux是开源的基于Inter x86架构的类Unix多用户操作系统</li>
<li>支持多任务、多用户、多CPU</li>
<li>高效而灵活</li>
<li>兼容任意x86架构计算机</li>
<li>强大易用的系统命令</li>
<li>完整的应用软件生态</li>
</ul>
<h3 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h3><ul>
<li>Linux系统内核(kernel)提供了Linux操作系统的核心功能</li>
<li>不同开发商在内核基础上扩展封装，形成了不同发行版本</li>
<li>常见发行版：Red Hat Linux、CentOS、Ubuntu、SUSE…</li>
</ul>
<h3 id="Linux发行版选择建议"><a href="#Linux发行版选择建议" class="headerlink" title="Linux发行版选择建议"></a>Linux发行版选择建议</h3><ul>
<li>桌面系统：Ubuntu</li>
<li>服务器操作系统：**CentOS(免费)**、Red Hat Linux(收费)</li>
<li>特定需求：Debian(稳定性)、Fedoras(新特性)、麒麟Linux(国产)</li>
</ul>
<h3 id="CentOS-社区企业操作系统"><a href="#CentOS-社区企业操作系统" class="headerlink" title="CentOS - 社区企业操作系统"></a>CentOS - 社区企业操作系统</h3><ul>
<li>基于<strong>R</strong>ed <strong>H</strong>at <strong>E</strong>nterprice <strong>L</strong>inux的开源企业级Linux发行版本</li>
<li>各版本CentOS都会获得十年的支持，与RHEL保持同步更新</li>
<li>CentOS采用社区支持，同步修正了RHEL许多BUG</li>
</ul>
<h3 id="CentOS版本选择"><a href="#CentOS版本选择" class="headerlink" title="CentOS版本选择"></a>CentOS版本选择</h3><ul>
<li>CentOS 5&#x2F;6：历史淘汰版本</li>
<li><strong>CentOS 7：主流版本，成熟稳定，大多数服务器的首先版本</strong></li>
<li>CentOS 8：全新版本，全新内核，存在漏洞隐患</li>
</ul>
<h3 id="安装CentOS-7-7"><a href="#安装CentOS-7-7" class="headerlink" title="安装CentOS 7.7"></a>安装CentOS 7.7</h3><p>vmware.com&#x2F;cn.html</p>
<p>VMware-workstation-full-14.1.2-8497320.exe<br>[链接： <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1EbuhZ4D4kh_NcRJqTA-vhQ">https://pan.baidu.com/s/1EbuhZ4D4kh_NcRJqTA-vhQ</a><br>密码：oq37]</p>
<p>mirrors.aliyun.com&#x2F;centos&#x2F;7.7.1908&#x2F;isos&#x2F;x86_64&#x2F; 下载 Everything-1908.iso<br>[<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/centos-vault/centos/7.7.1908/isos/x86_64/">centos-vault-centos-7.7.1908-isos-x86_64安装包下载_开源镜像站-阿里云 (aliyun.com)</a>]</p>
<p>VM典型 镜像Iso 存储地址放在最快的硬盘 将虚拟磁盘存储为单个文件 自定义(内存2GB 处理器2核  虚拟化 Intel VT-x)</p>
<h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>根目录&#x2F; 下各个目录的作用及含义说明:  </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>目录</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>&#x2F;bin</td>
<td>存放二进制可执行文件</td>
</tr>
<tr>
<td>2</td>
<td>&#x2F;boot</td>
<td>存放系统引导时使用的各种文件</td>
</tr>
<tr>
<td>3</td>
<td>&#x2F;dev</td>
<td>存放设备文件</td>
</tr>
<tr>
<td>4</td>
<td><strong>&#x2F;etc</strong></td>
<td>存放系统配置文件</td>
</tr>
<tr>
<td>5</td>
<td><strong>&#x2F;home</strong></td>
<td>存放系统用户的文件</td>
</tr>
<tr>
<td>6</td>
<td>&#x2F;lib</td>
<td>存放程序运行所需的共享库和内核模块</td>
</tr>
<tr>
<td>7</td>
<td>&#x2F;opt</td>
<td>额外安装的可选应用程序包所放置的位置</td>
</tr>
<tr>
<td>8</td>
<td><strong>&#x2F;root</strong></td>
<td>超级用户目录</td>
</tr>
<tr>
<td>9</td>
<td>&#x2F;sbin</td>
<td>存放二进制可执行文件，只有root用户才能访问</td>
</tr>
<tr>
<td>10</td>
<td>&#x2F;tmp</td>
<td>存放临时文件</td>
</tr>
<tr>
<td>11</td>
<td><strong>&#x2F;usr</strong></td>
<td>存放系统应用程序</td>
</tr>
<tr>
<td>12</td>
<td>&#x2F;var</td>
<td>存放运行时需要改变数据的文件，例如日志文件</td>
</tr>
</tbody></table>
<h3 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h3><h6 id="命令-参数选项-文件或路径"><a href="#命令-参数选项-文件或路径" class="headerlink" title="命令 [参数选项] [文件或路径]"></a>命令 [参数选项] [文件或路径]</h6><h5 id="Linux文件操作核心命令"><a href="#Linux文件操作核心命令" class="headerlink" title="Linux文件操作核心命令"></a>Linux文件操作核心命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>pwd</td>
<td>查看当前目录</td>
</tr>
<tr>
<td><strong>ls</strong>、ll(详细列表)</td>
<td>显示目录内容</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录</td>
</tr>
<tr>
<td><strong>cp</strong></td>
<td>复制文件与目录</td>
</tr>
<tr>
<td><strong>mv</strong></td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件或目录</td>
</tr>
<tr>
<td>find</td>
<td>查找目录或文件</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43585157/article/details/106992907">Xshell连接虚拟机详细教程-CSDN博客</a></p>
<pre><code class="java">按下Tab可以自动提示
输入su 密码root 进入root最高权限

cd ..                 返回上级目录
cd ./local             ./代表当前目录
cd local            到当前目录    

mkdir ./imooc
mkdir -p ./imooc/sample/demo       -p是连续创建多级目录

mkdir -p ./imooc1/sample1
mkdir -p -v./imooc1/sample1     -v是显示执行过程
mkdir -p -v./imooc1/sample1/demo1
=
mkdir -pv ./imooc1/sample1
    
cp Xftp-7.0.014lp.exe ./imooc/sample/demo 文件复制到指定目录
cp -r imooc/sample/demo imooc1/sample1/demo1 复制整个文件夹

cd imooc/sample/demo
mv Xftp-7.0.014lp.exe xftp.exe 重命名
ls

mv xftp.exe /imooc1/sample1/demo1 移动到其他目录
mv demo imooc1/sample1/demo1 移动文件夹到其他目录

cd game/share
rm -r music  y y y    依次删除文件夹中的文件
rm -f music 强制直接删除, 不经过询问
rm -rf music 强制迭代删除            【不要轻易使用】
【ex】 rm -rf / imooc/sample/demo 中间不小心加了空格 就把/后面的整个都删除了

find / -name *.exe 按指定的格式去搜索文件
cd ..
[root@imooc home] find / -name *
</code></pre>
<h3 id="vim文本编辑器"><a href="#vim文本编辑器" class="headerlink" title="vim文本编辑器"></a>vim文本编辑器</h3><h6 id="远程在线文本编辑器"><a href="#远程在线文本编辑器" class="headerlink" title="远程在线文本编辑器"></a>远程在线文本编辑器</h6><ul>
<li>vi是linux重要的文字编辑工具，vim是增强版</li>
<li>vim用于在远程环境下用命令形式对文本进行在线编辑</li>
<li>用法格式：<strong>vim [选项] [文件]</strong></li>
</ul>
<h3 id="vim三种模式"><a href="#vim三种模式" class="headerlink" title="vim三种模式"></a>vim三种模式</h3><ul>
<li>普通模式：默认模式，文本只读，不可编辑</li>
<li>编辑模式：编辑文本模式，普通模式按i键进入，ESC键退出</li>
<li>命令模式：执行保存、搜索、退出等操作</li>
</ul>
<h3 id="vim重要快捷键"><a href="#vim重要快捷键" class="headerlink" title="vim重要快捷键"></a>vim重要快捷键</h3><p>按<strong>i</strong>进入编辑模式</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>delete或x</td>
<td>删除单个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>&#x2F;str</td>
<td>全文查找str字符串，n下一个，N前一个</td>
</tr>
<tr>
<td>:% s&#x2F;old&#x2F;new&#x2F;g</td>
<td>替换文件内所有old字符串为new</td>
</tr>
<tr>
<td>u</td>
<td>撤销最近一次操作</td>
</tr>
<tr>
<td>:wq或者**:wq!**</td>
<td><strong>退出并保存</strong>，只读文件要格外加！</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出放弃保存</td>
</tr>
</tbody></table>
<pre><code class="java">vim server.xml         修改文件
按i进入编辑模式
Home跳转行首
End跳转行尾
Esc退出编辑模式

命令只允许在普通模式下运行
/8080                     查找端口(高亮显示)
查找到后按n是查找下一个 按N是查找上一个
u  撤销最近一次操作
:% s/8080/8900/g        进行端口的全局替换
:% s/&quot;80&quot;/8900/g         想要把80改成8900 且不影响其他数值[把引号也加入其中]
</code></pre>
<h3 id="Linux文本工具"><a href="#Linux文本工具" class="headerlink" title="Linux文本工具"></a>Linux文本工具</h3><h5 id="常用文本工具"><a href="#常用文本工具" class="headerlink" title="常用文本工具"></a>常用文本工具</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>echo</td>
<td>屏幕打印与文本输出 后面要加引号”hello”</td>
</tr>
<tr>
<td>cat</td>
<td>合并文件或查看文件内容</td>
</tr>
<tr>
<td>tail</td>
<td>显示文件内容尾部</td>
</tr>
<tr>
<td>grep</td>
<td>文本过滤工具</td>
</tr>
</tbody></table>
<pre><code class="java">echo &quot;hello&quot; &gt; hello.txt 将左侧命令的结果重写到右侧文件
vim hello.txt
:q        退出

echo &quot;hello&quot; &gt;&gt; hello.txt 内容的追加

cat hello.txt 直接打印到控制台
cat -n hello.txt  -n是在每一行前加行号
cat -nE hello.txt  结尾的时候显示结束符$

echo &quot;hello&quot; &gt; hello.txt
cat hello.txt  =&gt; hello
echo &quot;my name is lili&quot; &gt; myname.txt
cat hello.txt myname.txt &gt;&gt; full.txt    合并文件内容为新的文件    
vim full.txt
echo 和 cat 在实际开发中 打印日志 最后用cat拼接日志

cat &gt; test.txt &lt;&lt; EOF   在当前的输入环境中产生输入流 输入的全输入到test.txt 输入流结束字符串是EOF
&gt; Welcome to imooc.com
&gt; I like linux
&gt; bye!
&gt; EOF

tail处理日志很方便 bug日志
tail full.txt =&gt; hello       my name is lili
tail -n 1 full.txt =&gt; my name is lili   &quot;1&quot;代表显示文本最后一行
tail -f full.txt      对文件进行监听 一旦产生变化就输出控制台【适合用在服务器】
ctrl + c 退出

#cat test.txt
=&gt; welcome to imooc.com
=&gt; I like linux
=&gt; bye!
#grep l test.txt
we&quot;l&quot;come to imooc.com
I &quot;l&quot;ike &quot;l&quot;inux

#grep l test.txt &gt; out.txt            符合条件的可以输出到out.txt文件中
#grep -v l test.txt                    -v 挑选出不包含l的test.txt文件
#grep i...c test.txt                &quot;.&quot;代表匹配任意字符

#ll | grep .txt                     通道特殊使用方法：筛选出后缀是.txt的 
前面ll命令输出的结果会作为后面gerp命令的依据   通过|进行分割 

#ll | grep -E &quot;log[0-9]&#123;1,5&#125;.txt&quot;    通道特殊使用方法：扩展正则表达式
-rw-r--r--. 1 root root 3 12月 23 13:10 log1.txt
-rw-r--r--. 1 root root 3 12月 23 13:10 log2.txt
-rw-r--r--. 1 root root 3 12月 23 13:10 log3.txt
</code></pre>
<h3 id="文件打包-文件组织-与压缩-磁盘节省"><a href="#文件打包-文件组织-与压缩-磁盘节省" class="headerlink" title="文件打包[文件组织]与压缩[磁盘节省]"></a>文件打包<del>[文件组织]</del>与压缩<del>[磁盘节省]</del></h3><h5 id="Linux压缩程序-gzip"><a href="#Linux压缩程序-gzip" class="headerlink" title="Linux压缩程序-gzip"></a>Linux压缩程序-gzip</h5><ul>
<li>gzip是Linux系统的文件压缩程序</li>
<li>gzip压缩包文件扩展名 <strong>.gz</strong></li>
<li>大流量的网站默认都在使用 <strong>gzip</strong> 进行数据压缩传输</li>
</ul>
<h5 id="tar打包与压缩"><a href="#tar打包与压缩" class="headerlink" title="tar打包与压缩"></a>tar打包与压缩</h5><ul>
<li>tar是linux系统将多个文件打包和压缩的工具</li>
<li>tar本质的打包软件，扩展名是 **.tar **</li>
<li>tar可结合gzip或其他压缩工具实现打包压缩，扩展名 <strong>.tar.gz</strong></li>
<li><strong>压缩命令：</strong><code>tar zcvf tomcat.tar.gz game/src</code></li>
<li><strong>解压缩命令：</strong><code>tar zxvf tomcat.tar.gz -C game/src</code></li>
</ul>
<h3 id="tar常用可选项"><a href="#tar常用可选项" class="headerlink" title="tar常用可选项"></a>tar常用可选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>通过gzip压缩或解压</td>
</tr>
<tr>
<td>c</td>
<td>创建新的tar.gz文件</td>
</tr>
<tr>
<td>v</td>
<td>显示执行过程</td>
</tr>
<tr>
<td>f</td>
<td>指定压缩文件名称</td>
</tr>
<tr>
<td>x</td>
<td>解压缩tar.gz文件</td>
</tr>
<tr>
<td>-C</td>
<td>指定解压缩目录</td>
</tr>
</tbody></table>
<h3 id="安装与卸载应用程序"><a href="#安装与卸载应用程序" class="headerlink" title="安装与卸载应用程序"></a>安装与卸载应用程序</h3><h5 id="为CentOS安装应用程序"><a href="#为CentOS安装应用程序" class="headerlink" title="为CentOS安装应用程序"></a>为CentOS安装应用程序</h5><ul>
<li><span style = "color:red">在CentOS中安装第三方应用程序包含<strong>两种方式</strong>：</span><ul>
<li>rpm: Red Hat 软件包管理器, 相当于应用程序安装文件的执行者</li>
<li><strong><u>编译安装</u><strong>：用户自己从网站下载程序</strong>源码</strong>进行<strong>编译安装</strong></li>
</ul>
</li>
</ul>
<h3 id="yum与rpm的关系"><a href="#yum与rpm的关系" class="headerlink" title="yum与rpm的关系"></a>yum与rpm的关系</h3><ul>
<li>rpm安装过程中, 需要用户自己解决依赖问题</li>
<li>yum通过引入软件仓库，联网下载rpm包及依赖，并依次自动安装</li>
<li>yum是rpm的前端程序，其目的就是简化rpm的安装过程</li>
</ul>
<h5 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h5><ul>
<li>yum search 应用名                  #在仓库中查询是否存在指定应用</li>
<li>yum instal -y 应用名                #全自动下载安装应用及依赖</li>
<li>yum info 应用名                       #查看应用详细信息</li>
<li>yum list installed 应用名         #查看已安装的应用程序</li>
<li>rpm -ql 应用名                          #查看安装后输出的文件清单</li>
<li>yum remove -y 应用名            #全自动卸载指定应用</li>
</ul>
<h5 id="①-利用yum安装tree"><a href="#①-利用yum安装tree" class="headerlink" title="① 利用yum安装tree"></a>① 利用yum安装tree</h5><pre><code class="java">yum search tree
yum install tree.x86_64 安装tree
yum install -y tree.x86_64 遇到所有的默认y进行安装
tree -d 或 tree                查看文件树型结构
which tree                     查看刚刚tree安装的目录
rpm -ql tree.x86_64         查看刚刚tree安装了哪些文件
yum list installed          查看已经安装的应用
yum list installed *tree*   查看已安装的应用其中有tree的
    
yum remove tree.x86_64  卸载程序
</code></pre>
<h5 id="②-利用编译方式安装应用程序"><a href="#②-利用编译方式安装应用程序" class="headerlink" title="② 利用编译方式安装应用程序"></a>② 利用编译方式安装应用程序</h5><ul>
<li>如yum仓库未提供rpm，往往需要采用编译安装方式</li>
<li>编译安装是指从应用网站下载源码后，对源码进行编译后使用</li>
<li>编译命令：**make #**使用对应编译器对源码编译生成可执行文件</li>
</ul>
<h6 id="yum与编译安装的比较"><a href="#yum与编译安装的比较" class="headerlink" title="yum与编译安装的比较"></a>yum与编译安装的比较</h6><table>
<thead>
<tr>
<th></th>
<th>yum安装</th>
<th>编译安装</th>
</tr>
</thead>
<tbody><tr>
<td>兼容性</td>
<td>差，每种发行版都要准备</td>
<td>好，全平台适用</td>
</tr>
<tr>
<td>复杂度</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>安装速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>来源</td>
<td>应用仓库</td>
<td>官网下载</td>
</tr>
<tr>
<td>应用场景</td>
<td>日常系统软件</td>
<td>开源软件，最新版本</td>
</tr>
</tbody></table>
<h3 id="编译安装Redis-非关系型数据库"><a href="#编译安装Redis-非关系型数据库" class="headerlink" title="编译安装Redis[非关系型数据库]"></a>编译安装Redis<del>[非关系型数据库]</del></h3><pre><code class="java"># make
# yum install -y gcc
# cd ..
# clear
# rm -rf ./redis-4.0.14
# tar zxvf redis-4.0.14.tar,gz
# cd redis-4.0.14/
# clear
# make

[root@imooc redis-4.0.14]# ./src/redis-server redis.conf
</code></pre>
<h3 id="Linux系统管理命令"><a href="#Linux系统管理命令" class="headerlink" title="Linux系统管理命令"></a>Linux系统管理命令</h3><h5 id="使用-ifconfig-查看网卡ip"><a href="#使用-ifconfig-查看网卡ip" class="headerlink" title="使用 ifconfig 查看网卡ip"></a>使用 <code>ifconfig</code> 查看网卡ip</h5><h4 id="netstat-查看网络端口号"><a href="#netstat-查看网络端口号" class="headerlink" title="netstat 查看网络端口号"></a><code>netstat</code> 查看网络端口号</h4><ul>
<li><p><strong>netstat -tulpn</strong> 或者 <strong>netstat -ano</strong></p>
<ul>
<li><p><strong>netstat</strong> 常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>t</td>
<td>显示tcp传输协议的连接状况</td>
</tr>
<tr>
<td>u</td>
<td>显示udp传输协议的连接状况</td>
</tr>
<tr>
<td>l</td>
<td>显示处于监听状态的网络连接</td>
</tr>
<tr>
<td>p</td>
<td>显示应用PID和程序名称</td>
</tr>
<tr>
<td>n</td>
<td>显示ip地址</td>
</tr>
<tr>
<td>a</td>
<td>显示所有连接</td>
</tr>
<tr>
<td>o</td>
<td>显示计时器</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="查看进程-amp-杀掉进程"><a href="#查看进程-amp-杀掉进程" class="headerlink" title="查看进程 &amp; 杀掉进程"></a>查看进程 &amp; 杀掉进程</h4><ul>
<li><strong>ps -ef</strong><br><code># ps -ef | grep vim</code>     ‘|’代表通道</li>
<li>**kill -9 PID ** 专门按照pid杀死指定进程(强制删除)</li>
</ul>
<pre><code class="java">#ps -ef | grep redis
#netstart -tulpn | grep 6379
</code></pre>
<h3 id="应用服务化"><a href="#应用服务化" class="headerlink" title="应用服务化"></a>应用服务化</h3><ul>
<li>应用服务化是指让应用程序以服务方式在系统后台运行</li>
<li>Linux系统对服务化应用进行统一管理</li>
<li>服务管理命令：<strong>systemctl</strong></li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>启动服务</td>
</tr>
<tr>
<td>stop</td>
<td>停止服务</td>
</tr>
<tr>
<td>restart</td>
<td>重启服务</td>
</tr>
<tr>
<td>enable</td>
<td>设置开机启动</td>
</tr>
<tr>
<td>disable</td>
<td>禁止开机启动</td>
</tr>
<tr>
<td>status</td>
<td>查看服务状态</td>
</tr>
<tr>
<td>daemon-reload</td>
<td>重载服务配置文件</td>
</tr>
<tr>
<td>list-unit-files</td>
<td>列出所有服务</td>
</tr>
</tbody></table>
<pre><code class="java">启动redis
./src/redis-server redis.conf  进入到redis安装目录下执行
ctrl + z 
#ps -ef | grep redis

#find / -name *.pid

cd.. cd.. cd.. 
cd usr/lib/systemd/system 
#pwd
=&gt;/usr/lib/systemd/system 
#vim redis.service 按i进入编写模式
=&gt;
&lt;==========================================================================&gt;
[Unit]
Description=Redis
After=syslog.target network.target remote-fs.target nss-lookup.target

[Service]
Type=forking                    #描述服务类型：后台运行
PIDFile=/run/redis_6379.pid     #指向刚刚继承编号的pid
ExecStart=/usr/local/redis-4.0.14/src/redis-server /usr/local/redis-4.0.14/redis.conf                                 #服务启动时使用什么命令 调用redis-server
ExecStop=/bin/kill -s QUIT $MAINPID 
                                #对指定的命令关闭 $后自动带入pidfile  -s quit是按正常流程关闭
PrivateTmp=true
            
[Install]
WantedBy=multi-user.target         #将radis分配到multi-user.target服务组上[随系统自动启动]
&lt;==========================================================================&gt;
[root@imooc system]#systemctl daemon-reload   对所有redis进行重载

[root@imooc system]#ps -ef | grep redis  
[root@imooc system]#kill -s QUIT #杀死所有redis进程测试能否实现自启动
[root@imooc system]#systemctl start redis
[root@imooc system]#systemctl status redis

https://www.cnblogs.com/niway/p/15346572.html

[root@imooc system]#systemctl stop redis  #停止服务
[root@imooc system]#systemctl enable redis #随着系统启动
[root@imooc system]#systemctl list-unit-files #查看系统中每一个服务命令
[root@imooc system]#systemctl list-unit-files | grep enabled #查看自启动的命令

[root@imooc system]#shutdown -r now   #断开连接
</code></pre>
<h3 id="Linux用户与权限"><a href="#Linux用户与权限" class="headerlink" title="Linux用户与权限"></a>Linux用户与权限</h3><h5 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h5><ul>
<li>Linux是多用户多任务系统，包含两个概念：<strong>用户</strong>与<strong>用户组</strong></li>
<li>用户与账户是同一概念，用于登录系统与区分资源权限</li>
<li>用户让系统变的更安全，同时也保护了用户的个人数字资产</li>
</ul>
<h5 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h5><ul>
<li>用户组就是将用户分组，隶属用户自动拥有组权限</li>
<li>一个用户可隶属于多个组，用户可任意切换当前组</li>
<li>用户组的出现让用户权限管理变更轻松</li>
</ul>
<h5 id="用户与用户组的常用命令"><a href="#用户与用户组的常用命令" class="headerlink" title="用户与用户组的常用命令"></a>用户与用户组的常用命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>useradd</td>
<td>创建新用户</td>
</tr>
<tr>
<td>passwd</td>
<td>修改密码</td>
</tr>
<tr>
<td>usermod</td>
<td>修改用户信息&#x2F;分配组 (覆盖原组)</td>
</tr>
<tr>
<td>groupadd</td>
<td>创建新的用户组</td>
</tr>
<tr>
<td><strong>chown</strong></td>
<td>更改文件的属主或属组</td>
</tr>
<tr>
<td><strong>chmod</strong></td>
<td>更改文件的访问权限</td>
</tr>
<tr>
<td>newgrp</td>
<td>切换用户当前组</td>
</tr>
</tbody></table>
<h3 id="项目内部文件权限管理实践"><a href="#项目内部文件权限管理实践" class="headerlink" title="项目内部文件权限管理实践"></a>项目内部文件权限管理实践</h3><pre><code class="java">3员工(2个程序员 1个测试员)
[root@imooc imooc]# adduser d1
[root@imooc imooc]# adduser d2
[root@imooc imooc]# adduser t1
[root@imooc imooc]# passwd d1 =&gt; shuangyu1
[root@imooc imooc]# passwd d2 =&gt; shuangyu2
[root@imooc imooc]# passwd t1 =&gt; shuangyu3
[root@imooc imooc]# groupadd developer
[root@imooc imooc]# groupadd testor
[root@imooc imooc]# usermod -g developer d1
[root@imooc imooc]# usermod -g developer d2
[root@imooc imooc]# usermod -g testor t1
在上方点击打开 并且复制3个Centos7 分别改用户名(d1 d2 t1)和密码(shuangyu1/2/3) 
[root@imooc imooc]# cd
[root@imooc ~]# cd /usr/local/share
[root@imooc share]# mkdir dev-document
[root@imooc share]# ll
drwxr-xr-x.  2 root root  28 11月 15 18:37 applications
drwxr-xr-x.  2 root root   6 12月  3 20:36 dev-document
drwxr-xr-x.  2 root root   6 4月  11 2018 info
drwxr-xr-x. 21 root root 243 11月 15 18:25 man
【前方的drwxr-xr-x 含义见图】

[root@imooc share]# chown d1:developer dev-document  更改对应目录文件的属主(由超级管理员交給研发组) d1可以对developer拥有完整的操作权限 developer以外的用户有读取执行权 其他用户 只有执行权
drwxr-xr-x.  2 root root       28 11月 15 18:37 applications
drwxr-xr-x.  2 d1   developer   6 12月  3 20:36 dev-document
drwxr-xr-x.  2 root root        6 4月  11 2018 info
drwxr-xr-x. 21 root root      243 11月 15 18:25 man

[root@imooc share]# chmod 750 dev-document/ 其他用户不允许任何权限
[root@imooc share]# ll
总用量 0
drwxr-xr-x.  2 root root       28 11月 15 18:37 applications
drwxr-x---.  2 d1   developer   6 12月  3 20:36 dev-document
drwxr-xr-x.  2 root root        6 4月  11 2018 info
drwxr-xr-x. 21 root root      243 11月 15 18:25 man

返回到Centos 7 - t1
[t1@imooc ~]$ cd /usr/local/share/dev-document/
-bash: cd: /usr/local/share/dev-document/: 权限不够
返回到Centos 7 - d2
[d2@imooc ~]$ cd /usr/local/share
[d2@imooc share]$ mv dev-document/ doc
mv: 无法将&quot;dev-document/&quot; 移动至&quot;doc&quot;: 权限不够


上方的chmod 750 的意思是 对应下方的表 第一个7是第一个rwx相加之和4+2+1
====================chmod命令====================
★ chmod 750：组用户可读写，其他用户不允许访问 ★        
★ chmod 777：所有用户拥有完整权限 ★
★ chmod 700：只有属主拥有完整权限 ★
====================++++++++====================
d1弄个文档整个公司的所有人都可以使用
[d1@imooc ~]$ cd /usr/local/share/dev-document/
[d1@imooc dev-document]$ vim code.md
[d1@imooc dev-document]$ ll
-rw-r--r--. 1 d1 developer 13 12月  3 20:59 code.md
第一个是d则是文件夹 -则是文件 属主可以对文件读写。组仅仅可以读取。其他人仅仅可以读取
[d1@imooc dev-document]$ chmod 770 code.md
[d1@imooc dev-document]$ ll
总用量 4
-rwxrwx---. 1 d1 developer 13 12月  3 20:59 code.md
d2即可读写
[d2@imooc dev-document]$ vim code.md

如何让d1同时拥有两个组
[root@imooc share]# usermod -G developer,testor d1
[root@imooc share]# groups d1
d1: developer testor

将当前组切换到新的用户组上
[d1@imooc ~]$ newgrp testor
[d1@imooc ~]$ groups
d1：testor developer
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ee7e298b43a3cdebf4f9be2ae0e3f72592adee2/data/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%BB%A3%E7%A0%81%E8%A1%A8.png"></p>
<h3 id="sudo获取超级管理员权限"><a href="#sudo获取超级管理员权限" class="headerlink" title="sudo获取超级管理员权限"></a>sudo获取超级管理员权限</h3><ul>
<li>sudo可以让普通用户拥有超级管理员的执行权限</li>
<li>普通用户要经过超级管理员授权才能使用</li>
<li>授权命令：visudo</li>
</ul>
<pre><code class="java">在root端输入 visudo 并且输入100gg 快速定位到100行
[root@imooc ~]#visudo
## The COMMANDS section may have other options added to it.
##
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
d1        ALL=(ALL)        ALL     #按i进入编辑模式且增加此行
        ↑：ALL任意电脑可以连接    后ALL可以切换其他用户执行命令   后后ALL允许哪些命令
ESC退出模式后输入
[root@imooc imooc]# visudo -c
/etc/sudoers：解析正确


[d1@imooc ~]$ useradd d3    #目前还没有权限
useradd: Permission denied.
useradd：无法锁定 /etc/passwd，请稍后再试。
[d1@imooc ~]$ sudo useradd d3     #以d1的身份給d3一个超级管理员的权限
我们信任您已经从系统管理员那里了解了日常注意事项。
总结起来无外乎这三点：

    #1) 尊重别人的隐私。
    #2) 输入前要先考虑(后果和风险)。
    #3) 权力越大，责任越大。

[sudo] d1 的密码：=》 shuangyu1
[d1@imooc ~]$ sudo passwd d3 
更改用户 d3 的密码 =》 shuangyu33

回到主Centos 7
[root@imooc ~]#visudo
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
d1      ALL=(ALL)       NOPASSWD:ALL
NOPASSWD:ALL意味着做任何命令之前不用输入密码

[d1@imooc ~]$ sudo useradd d4
[d1@imooc ~]$                     #直接不需要输入密码了
</code></pre>
<h3 id="CentOS7防火墙firewall"><a href="#CentOS7防火墙firewall" class="headerlink" title="CentOS7防火墙firewall"></a>CentOS7防火墙firewall</h3><h5 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h5><ul>
<li>防火墙是借助硬件和软件对内外部网络环境的保护措施</li>
<li>CentOS 7基于firewall实现应用层防火墙，CentOS6基于iptables</li>
<li>firewall-cmd是firewall的核心命令</li>
</ul>
<h5 id="对外开放Tomcat"><a href="#对外开放Tomcat" class="headerlink" title="对外开放Tomcat"></a>对外开放Tomcat</h5><pre><code class="java">把apache-tomcat.tar.gz放入/usr/local中 
[root@imooc local]# tar zxvf apache-tomcat-9.0.34.tar.gz
[root@imooc local]# ll
[root@imooc local]# cd apache-tomcat-9.0.34/
[root@imooc apache-tomcat-9.0.34]# cd bin
[root@imooc bin]# ./startup.sh
[root@imooc bin]# ./startup.sh
Using CATALINA_BASE:   /usr/local/apache-tomcat-9.0.34
Using CATALINA_HOME:   /usr/local/apache-tomcat-9.0.34
Using CATALINA_TMPDIR: /usr/local/apache-tomcat-9.0.34/temp
Using JRE_HOME:        /usr
Using CLASSPATH:       /usr/local/apache-tomcat-9.0.34/bin/bootstrap.jar:/usr/local/apache-tomcat-9.0.34/bin/tomcat-juli.jar
Tomcat started.
[root@imooc bin]# netstat -tulpn|grep 8080  #查看端口是否开启
tcp6    0    0 :::8080        :::*         LISTEN      4302/java  
在虚拟机内部去fox浏览器搜索 localhost:8080  就会看到可爱的绿色小猫咪
    
若想在计算机中访问端口 192.168.170.129:8080 则需要关闭虚拟机的防火墙
[root@imooc bin]# firewall-cmd --state   #查看防火墙状态
running
[root@imooc bin]# firewall-cmd --list-ports #查看防火墙放行的端口(空代表无任何放行端口)
[root@imooc bin]# firewall-cmd --zone=public --permanent --add-port=8080/tcp
#### zone防火墙定义的规则区域、产生永久变更、增加端口8080、tcp形式
[root@imooc bin]# firewall-cmd --reload  #进行配置重载

若不需要开放8080端口则需要
[root@imooc bin]# firewall-cmd --zone=public --permanent --remove-port=8080/tcp
[root@imooc bin]# firewall-cmd --reload  #进行配置重载

[root@imooc bin]# firewall-cmd --zone=public --permanent --add-port=8000-9000/tcp 
###放行区域端口
[root@imooc bin]# firewall-cmd --reload  #进行配置重载
</code></pre>
<h3 id="Bash-Shell"><a href="#Bash-Shell" class="headerlink" title="Bash Shell"></a>Bash Shell</h3><ul>
<li>Shell是一个用c语言编写的脚本解释器，是用户通过代码操作Linux的桥梁</li>
<li>Shell脚本描述要执行的任务，完成系列复杂操作，文件通常以**.sh**后缀</li>
<li>Shell脚本通过Shell解释器执行，按解释器分类分为多种类型</li>
</ul>
<h3 id="Linux-Shell分类"><a href="#Linux-Shell分类" class="headerlink" title="Linux Shell分类"></a>Linux Shell分类</h3><table>
<thead>
<tr>
<th>Shell种类</th>
<th>Shell解释器</th>
</tr>
</thead>
<tbody><tr>
<td>Bourne Shell</td>
<td>&#x2F;usr&#x2F;bin&#x2F;sh 或 &#x2F;bin&#x2F;sh</td>
</tr>
<tr>
<td><strong>Boourne Again Shell</strong></td>
<td><strong>&#x2F;bin&#x2F;bash(默认)</strong></td>
</tr>
<tr>
<td>C Shell</td>
<td>&#x2F;usr&#x2F;bin&#x2F;csh</td>
</tr>
<tr>
<td>K Shell</td>
<td>&#x2F;usr&#x2F;bin&#x2F;ksh</td>
</tr>
<tr>
<td>Shell for Root</td>
<td>&#x2F;sbin&#x2F;sh</td>
</tr>
</tbody></table>
<h5 id="一键发布Tomcat应用程序"><a href="#一键发布Tomcat应用程序" class="headerlink" title="一键发布Tomcat应用程序"></a>一键发布Tomcat应用程序</h5><pre><code class="java">编写shall脚本
[root@imooc local]# vim deploy_tomcat.sh
======================================================================
echo &quot;准备下载Tomcat9&quot;
wget https://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.34/bin/apache-tomcat-9.0.34.tar.gz
echo &quot;正在解压缩Tomcat9&quot;
tar zxf apache-tomcat-9.0.34.tar,gz
echo &quot;防火墙开放8080端口&quot;
firewall-cmd --zone=public --permanent --add-port=8080/tcp
firewall-cmd --reload
echo &quot;启动Tomcat&quot;
cd ./apache-tomcat-9.0.34/bin
./startup.sh
======================================================================
[root@imooc local]# ./deploy_tomcat.sh        开启文件
</code></pre>
<h3 id="综合训练：Linux部署慕课网办公OA"><a href="#综合训练：Linux部署慕课网办公OA" class="headerlink" title="综合训练：Linux部署慕课网办公OA"></a>综合训练：Linux部署慕课网办公OA</h3><h5 id="部署架构：Chrome-Tomcat-Web服务器-MySQL服务器-【中间通过网络通信】"><a href="#部署架构：Chrome-Tomcat-Web服务器-MySQL服务器-【中间通过网络通信】" class="headerlink" title="部署架构：Chrome + Tomcat Web服务器 + MySQL服务器 【中间通过网络通信】"></a>部署架构：Chrome + Tomcat Web服务器 + MySQL服务器 【中间通过网络通信】</h5><pre><code class="java">重新安装CentOS 7-DB【最小值安装】
[root@localhost ~]# yum install -y net-tools
CentOS 7-DB        ifconfig ==》 192.168.170.131    账户：centos-db 密码：panchunyao123
CentOS 7-WEB    ifconfig ==》 192.168.170.133    账户：centos-web 密码：panchunyao123
DB按照MySQL
WEB按照Tomcat
</code></pre>
<h3 id="CentOS安装MySQL-8"><a href="#CentOS安装MySQL-8" class="headerlink" title="CentOS安装MySQL 8"></a>CentOS安装MySQL 8</h3><pre><code class="java">查找有没有mysql安装包
[centos-db@localhost ~]$ yum search mysql-community
去官网找到Linux版的 右键复制链接地址
[root@localhost ~]# wget https://dev.mysql.com/get/mysql80-community-release-el7-11.noarch.rpm
bash: wget: command not found
卧槽 wegt不存在，那就按装wget
[root@localhost ~]# yum install -y wget
[root@localhost mysql]# ll
total 16
-rw-r--r--. 1 root root 14064 Oct 24 07:44 mysql80-community-release-el7-11.noarch.rpm

[root@localhost mysql]# yum localinstall -y mysql80-community-release-el7- 11.noarch.rpm     #自动安装mysql源
[root@localhost mysql]# yum search mysql-comm #此时查找一下就会出现大量mysql组件
[root@localhost mysql]# yum install -y mysql-community-server #安装mysql&#123;在欧美很慢&#125;
ctrl+c 停止安装
[root@localhost mysql]# cd /var/cache/yum/x86_64/7/mysql80-community/packages/
#yum下载的缓存路径 在网上下载好后Linux版的MySQL后 进入

[root@localhost mysql80-community]  /var/cache/yum/x86_64/7/mysql80-community
用命令更改文件夹权限：chmod 777 test01（需要赋予权限的文件夹）
之后将解压缩的MySQL拖进去

注意：如果直接下载 yum localinstall mysql80-community-release-el7- 11.noarch.rpm  的话会有很多依赖不会被自动下载，最保准的就是去网上下载Linux版本的MySQL再利用Xftp拖进去

[root@localhost package]# yum install -y mysql-community-server 【最快最省事 自动下载&amp;安装依赖】
[root@localhost package]# systemctl start mysqld
[root@localhost package]# netstat -tulpn
tcp6    0    0    :::3306        :::*        LISTEM        21850/mysqld
[root@localhost package]# systemctl status mysqld     #查看myql启动状态
[root@localhost package]# systemctl enable mysqld     #设置开机自启动
</code></pre>
<h3 id="初始化MySQL-CentOS-7-DB"><a href="#初始化MySQL-CentOS-7-DB" class="headerlink" title="初始化MySQL[CentOS 7-DB]"></a>初始化MySQL[CentOS 7-DB]</h3><pre><code class="java">查看mysql日志寻找mysql密码
[root@localhost package]# vi /var/log/mysqld.log
root@localhost: Y,#)foTQ,7js
[root@localhost package]# mysql -uroot -p
修改密码！
mysql&gt; alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;Panchunyao123!&#39;
mysql&gt; use mysql
mysql&gt; select host,user from user;
mysql&gt; update user set host=&#39;%&#39; where user=&#39;root&#39;; #任意设备都可使用%连接到mysql服务器
host: %            user: root
mysql&gt; flush privileges; #使修改的权限数据生效
mysql&gt; exit

下一步是放行防火墙3306端口
[root@localhost package]# firewall-cmd --zone=public --permanent --add-port=3306/tcp
[root@localhost package]# firewall-cmd --reload

去电脑端的Navicat Premium 连接新数据库
MySQL-新建连接
连接名：centos-db
主机：192.168.170.131
端口：3306
用户名：root
密码：Panchunyao123！

新建数据库 imooc-oa  utf8mb4 执行sql文件 imooc-oa.sql
</code></pre>
<h3 id="部署配置Web应用服务器"><a href="#部署配置Web应用服务器" class="headerlink" title="部署配置Web应用服务器"></a>部署配置Web应用服务器</h3><pre><code class="java">CentOS 7-DB        ifconfig ==》 192.168.170.131    账户：centos-db 密码：panchunyao123
CentOS 7-WEB    ifconfig ==》 192.168.170.133    账户：centos-web 密码：panchunyao123
</code></pre>
<pre><code class="java">[root@localhost ~]# yum search jdk  #查看仓库中包含哪些jdk
[root@localhost ~]# yum install -y java-1.8.0-openjdk    #安装jdk以及所有依赖
[root@localhost ~]# java -version
[root@localhost ~]# which java      #查看安装到哪个地方
/bin/java
安装tomcat
[root@localhost ~]# cd /usr
用命令更改文件夹权限：chmod 777 local
[root@localhost usr]# cd local
打开Xftp将apache-tomcat-9.0.34.tar.gz 传入到local内
[root@localhost local]# tar zxf apache-tomcat-9.0.34.tar.gz     #对压缩包进行解压
将素材资料里的imooc_oa.war拖入Xftp的local中 之后进行解压
[root@localhost local]# tar zxf imooc_oa.war 
需要将imooc_oa复制到tomcat9的webapps下才可生效
[root@localhost local]# mv imooc_oa ./apache-tomcat-9.0.34/webapps/
[root@localhost local]# cd apache-tomcat-9.0.34/webapps/
[root@localhost webapps]# vim ./imooc_oa/WEB-INF/classes/mybatis-config.xml
#远程对服务器配置连接数据库服务器
-bash: vim: 未找到命令 需要先安装vim
[root@localhost webapps]# yum install -y vim-common
[root@localhost webapps]# yum install -y vim-enhanced  #再安装一个增强的vim包
[root@localhost webapps]# vim ./imooc_oa/WEB-INF/classes/mybatis-config.xml
输入/root 进行全文查找 修改&lt;property 中的value=&quot;jdbc:mysql:...&quot; loacalhost改为自己网络ip：192.168.170.131
再修改一下下面的password：  Panchunyao123！
:wq
[root@localhost webapps]# cd ..
[root@localhost apache-tomcat-9.0.34]# vim ./conf/server.xml
/8080 搜索 &lt;Connector port=&quot;80&quot; 只保留80端口
/Host&gt; 找到最下面 在上面一行加入
&lt;Context path=&quot;/&quot; docaBacs=&quot;imooc_oa&quot;/&gt; #将imooc_oa目录映射到根路径&quot;/&quot;
:wq

之后启动tomcat
[root@localhost apache-tomcat-9.0.34]# ./bin/startup.sh
[root@localhost apache-tomcat-9.0.34]# netstat -tulpn  #查看进程
tcp6        0        0 :::80        :::*        LISTEN        20303/java

用防火墙将80端口对外进行暴露
[root@localhost apache-tomcat-9.0.34]# firewall-cmd --zone=public --permanent --add-port=80/tcp
[root@localhost apache-tomcat-9.0.34]# firewall-cmd --reload  #重载

回到电脑浏览器输入：http://192.168.170.133/login.html

数据库安全【根据3306端口可以查到数据库根源】：对指定IP端口进行放行
[root@localhost ~]# firewall-cmd --zone=public --permanent --remove-port=3306/tcp
[root@localhost ~]# firewall-cmd --reload  #重载
[root@localhost ~]# firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.170.133&quot; port protocol=&quot;tcp&quot; port=&quot;3306&quot; accept &quot;    #-rich-rule防火墙内部规则强大的定义表达式
[root@localhost ~]# firewall-cmd --reload  #重载
[root@localhost apache-tomcat-9.0.34]# ./bin/shutdown.sh
[root@localhost apache-tomcat-9.0.34]# ./bin/startup.sh
</code></pre>
<hr>
<hr>
<h1 id="Redis-内存-非常快-数据库、非关系型数据库"><a href="#Redis-内存-非常快-数据库、非关系型数据库" class="headerlink" title="Redis (内存[非常快]数据库、非关系型数据库)"></a>Redis (内存<del>[非常快]</del>数据库、非关系型数据库)</h1><ul>
<li>Redis是<strong>Key-Value型</strong>NoSQL数据库</li>
<li><strong>Redis</strong>将数据<strong>存储在内存(RAM)中</strong>，同时也能<strong>持久化到磁盘</strong></li>
<li>Redis常用于缓存，利用内存的高效提高程序的处理速度</li>
</ul>
<h5 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h5><ul>
<li>速度快</li>
<li>广泛的语言支持</li>
<li>持久化</li>
<li>多种数据结构</li>
<li>主从复制(多台Redis可以保持数据同步)</li>
<li>分布式与高可用(7×24小时服务 淘宝&#x2F;京东) 全国各地多个主机 降低网络传输时间</li>
</ul>
<h3 id="Redis的安装与启动"><a href="#Redis的安装与启动" class="headerlink" title="Redis的安装与启动"></a>Redis的安装与启动</h3><ul>
<li>在Linux系统中安装redis (<a target="_blank" rel="noopener" href="http://redis.io/download">http://redis.io/download</a>)</li>
</ul>
<pre><code class="java">$ wegt http://download.redis.io/releases/redis-5.0.2.tar.gz
$ tar xzf redis-5.0.2.tar.gz
$ cd redis-5.0.2
$ make
</code></pre>
<pre><code class="java">[root@imooc imooc]# cd /usr/local
[root@imooc local]# ll
[root@imooc local]# mkdir redis
[root@imooc local]# ll
[root@imooc local]# cd redic
[root@imooc redic]# yum install gcc
[root@imooc redic]# wegt http://download.redis.io/releases/redis-5.0.2.tar.gz
[root@imooc redis]# tar xzf redis-5.0.2.tar.gz
[root@imooc redis]# cd redis-5.0.2
[root@imooc redis-5.0.2]# make
Hint: It&#39;s a good idea to run &#39;make test&#39; ;)   安装成功
[root@imooc redis-5.0.2]# ll  #找redis.conf
总用量 240
-rw-rw-r--.  1 root root 85327 11月 22 2018 00-RELEASENOTES
-rw-rw-r--.  1 root root    53 11月 22 2018 BUGS
-rw-rw-r--.  1 root root  1894 11月 22 2018 CONTRIBUTING
-rw-rw-r--.  1 root root  1487 11月 22 2018 COPYING
drwxrwxr-x.  6 root root   192 12月  5 11:47 deps
-rw-rw-r--.  1 root root    11 11月 22 2018 INSTALL
-rw-rw-r--.  1 root root   151 11月 22 2018 Makefile
-rw-rw-r--.  1 root root  4223 11月 22 2018 MANIFESTO
-rw-rw-r--.  1 root root 20555 11月 22 2018 README.md
-rw-rw-r--.  1 root root 62155 11月 22 2018 redis.conf
-rwxrwxr-x.  1 root root   275 11月 22 2018 runtest
-rwxrwxr-x.  1 root root   280 11月 22 2018 runtest-cluster
-rwxrwxr-x.  1 root root   281 11月 22 2018 runtest-sentinel
-rw-rw-r--.  1 root root  9710 11月 22 2018 sentinel.conf
drwxrwxr-x.  3 root root  8192 12月  5 11:49 src
drwxrwxr-x. 10 root root   167 11月 22 2018 tests
drwxrwxr-x.  8 root root  4096 11月 22 2018 utils
[root@imooc redis-5.0.2]# cd src
[root@imooc src]# ll     #找redis- server启动目录

[root@imooc src]#cd ..
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf
</code></pre>
<pre><code class="java">若端口被占用

找到redis-server的进程，然后杀死对应的进程，然后重新启动redis

&gt;&gt;&gt; ps -ef | grep -i redis
root      3585 19590  0 10:36 pts/20   00:00:00 redis-server *:6379
user      3684  3663  0 10:38 pts/21   00:00:00 grep --color=auto -i redis
进程3585是redis的服务，

kill -9 3585
</code></pre>
<ul>
<li>在Windows系统安装Redis</li>
</ul>
<pre><code class="java">https://github.com/microsoftarchive/redis/releases 下载后解压
打开cmd
C:\Users\Pluminary&gt;d:
D:\&gt;cd Redis-x64-3.0.504
D:\Redis-x64-3.0.504&gt;dir
D:\Redis-x64-3.0.504&gt;redis-server redis.windows.conf
                _._
           _.-``__ &#39;&#39;-._
      _.-``    `.  `_.  &#39;&#39;-._           Redis 3.0.504 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ &#39;&#39;-._
 (    &#39;      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|&#39;` _.-&#39;|     Port: 6379
 |    `-._   `._    /     _.-&#39;    |     PID: 22828
  `-._    `-._  `-./  _.-&#39;    _.-&#39;
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
 |    `-._`-._        _.-&#39;_.-&#39;    |           http://redis.io
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
 |    `-._`-._        _.-&#39;_.-&#39;    |
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
      `-._    `-.__.-&#39;    _.-&#39;
          `-._        _.-&#39;
              `-.__.-&#39;
</code></pre>
<h3 id="Redis的常用基本配置"><a href="#Redis的常用基本配置" class="headerlink" title="Redis的常用基本配置"></a>Redis的常用基本配置</h3><table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">daemonize</td>
<td align="center">daemonize yes</td>
<td align="center">是否启用后台运行, 默认no</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">port 6379</td>
<td align="center">设置端口号, 默认6379</td>
</tr>
<tr>
<td align="center">logfile</td>
<td align="center">logfile 日志文件</td>
<td align="center">设置日志文件</td>
</tr>
<tr>
<td align="center">databases</td>
<td align="center">databases 255</td>
<td align="center">设置redis数据库总量</td>
</tr>
<tr>
<td align="center">dir</td>
<td align="center">dir 数据文件目录</td>
<td align="center">设置数据文件存储目录</td>
</tr>
<tr>
<td align="center">requirepass</td>
<td align="center">requirepass 12345</td>
<td align="center">设置使用密码</td>
</tr>
</tbody></table>
<h5 id="守护进程方式启动Redis"><a href="#守护进程方式启动Redis" class="headerlink" title="守护进程方式启动Redis"></a>守护进程方式启动Redis</h5><pre><code class="java">[root@imooc ~]# cd /usr/local/redis/redis-5.0.2/
[root@imooc redis-5.0.2]# vim redis.conf    #打开后台启动
136行 daemonize no 改成 daemonize yes
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf
关闭终端打开全新终端
[root@imooc ~]# netstat -tulpn
tcp        0        0        127.0.0.1:6379 ...     6338/./src/redis-se

如果关闭
kill -9 6338
</code></pre>
<h5 id="redis使用"><a href="#redis使用" class="headerlink" title="redis使用"></a>redis使用</h5><pre><code class="java">[root@imooc redis-5.0.2]# ./src/redis-cli    #执行redis内置指令
127.0.0.1:6379&gt; ping        #启动成功
PONG
127.0.0.1:6379&gt; exit        #退出
[root@imooc redis-5.0.2]# ./src/redis-cli shutdown  #更加安全的关闭redis

报错(添加log文件 将redis命令行的结果打印到log中)
https://blog.csdn.net/qq_46127735/article/details/113933690


为了保护安全将port从6379改为6380
[root@imooc redis-5.0.2]# vim redis.conf
/port 寻找92行
port 6380
[root@imooc redis-5.0.2]# ./src/redis-cli -p 6380
127.0.0.1:6380&gt; select 0        #当前使用第几号数据库
127.0.0.1:6380&gt; select 15
[root@imooc redis-5.0.2]# vim redis.conf
在186行 可以改变数据连接数量
databases 15→255
    
[root@imooc redis-5.0.2]# vim redis.conf
507行注释去掉 此行是输入密码
requirepass panchunyao123
再次登录就 
127.0.0.1:6380&gt; auth panchunyao123

redis中有一个dump.rdb 全量备份 同时备份到磁盘中
</code></pre>
<h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">select</td>
<td align="center">select 0</td>
<td align="center">选择0号数据库</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">set name lily</td>
<td align="center">设置key&#x3D;name, value&#x3D;lily</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">get hello</td>
<td align="center">获得key&#x3D;hello结果</td>
</tr>
<tr>
<td align="center">keys</td>
<td align="center">keys he*</td>
<td align="center">根据Pattern表达查询符合条件的key</td>
</tr>
<tr>
<td align="center">dbsize</td>
<td align="center">dbsize</td>
<td align="center">返回key的总数</td>
</tr>
<tr>
<td align="center">exists</td>
<td align="center">exists a</td>
<td align="center">检查key&#x3D;a是否存在</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">del a</td>
<td align="center">删除key&#x3D;a的数据</td>
</tr>
<tr>
<td align="center">expire</td>
<td align="center">expire hello 20</td>
<td align="center">设置key&#x3D;hello 20秒后过期</td>
</tr>
<tr>
<td align="center">ttl</td>
<td align="center">ttl hello</td>
<td align="center">查看key&#x3D;a的过期剩余时间</td>
</tr>
</tbody></table>
<pre><code class="java">[root@imooc redis-5.0.2]# ./src/redids-cli -p 6380   #重新连接到端口
127.0.0.1:6380&gt; select 10
127.0.0.1:6380[10]&gt; set name lily   #十号数据库中增加key=name value=lily
127.0.0.1:6380[10]&gt; get name  =&gt; &quot;lily&quot;
127.0.0.1:6380[10]&gt; select 9
127.0.0.1:6380[9]&gt; get name =&gt;(nil)
127.0.0.1:6380[9]&gt; set name kitty
127.0.0.1:6380[9]&gt; get name =&gt;&quot;kitty&quot;
127.0.0.1:6380[9]&gt; keys *  #列举表达式能匹配的所有key
127.0.0.1:6380[9]&gt; set sex male
127.0.0.1:6380[9]&gt; keys *
127.0.0.1:6380[9]&gt; keys n* #模糊匹配表达式
127.0.0.1:6380[9]&gt; dbsize  #显示当前数据库的总量 =&gt; 2个 =&gt; &quot;name&quot;  &quot;sex&quot;
127.0.0.1:6380[9]&gt; del sex #删除 =&gt; 1 返回0则不存在
127.0.0.1:6380[9]&gt; expire name 30   #生效开始之后30秒存活时间
127.0.0.1:6380[9]&gt; ttl name #查看存活时间 时间一到自动清除     keys*中无name数据
</code></pre>
<h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a><span style = "color:red">Redis数据类型</span></h3><ul>
<li><h5 id="String-字符串类型-String最大512mb-建议单个kv不超过100kb"><a href="#String-字符串类型-String最大512mb-建议单个kv不超过100kb" class="headerlink" title="String - 字符串类型 (String最大512mb 建议单个kv不超过100kb)"></a>String - 字符串类型 (<u>String最大512mb 建议单个kv不超过100kb</u>)</h5></li>
</ul>
<table>
<thead>
<tr>
<th align="center">键</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">Lily</td>
</tr>
<tr>
<td align="center">counter</td>
<td align="center">3321</td>
</tr>
<tr>
<td align="center">sn</td>
<td align="center">7361-7749</td>
</tr>
</tbody></table>
<h6 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h6><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get</td>
<td align="center">get hello</td>
<td align="center">获取key&#x3D;hello结果</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">set hello world</td>
<td align="center">设置key&#x3D;hello, value&#x3D;hello</td>
</tr>
<tr>
<td align="center">mset mget</td>
<td align="center">mset hello world java best<br />mget hello java</td>
<td align="center">一次性设置或者获取多个值</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">del hello</td>
<td align="center">删除key&#x3D;hello</td>
</tr>
<tr>
<td align="center">incr&#x2F;decr</td>
<td align="center">incr count<br/>decr count</td>
<td align="center">key值自增&#x2F;自减1</td>
</tr>
<tr>
<td align="center">incrby&#x2F;decrby</td>
<td align="center">incrby count 99<br/>decrby count 99</td>
<td align="center">自增自减指定步长</td>
</tr>
</tbody></table>
<pre><code class="java">127.0.0.1:6380[9]&gt; select 10 
127.0.0.1:6380[10]&gt; set name lily
127.0.0.1:6380[10]&gt; set sex 18
127.0.0.1:6380[10]&gt; set birthday 1998-03-11
127.0.0.1:6380[10]&gt; keys *
1) &quot;birthday&quot;  2)&quot;name&quot;  3)&quot;sex&quot;
127.0.0.1:6380[10]&gt; mset name1 kitty sex1 20 birthday1 2001-03-02 #一次性设置多个键值对
127.0.0.1:6380[10]&gt; mget name sex birthday  #一次性提取多个
127.0.0.1:6380[10]&gt; clear  #当前屏幕清空
127.0.0.1:6380[10]&gt; incr age  #将指定的数字自增+1
127.0.0.1:6380[10]&gt; set age 20
127.0.0.1:6380[10]&gt; keys age =&gt; &quot;age&quot;
127.0.0.1:6380[10]&gt; get age =&gt; &quot;20&quot;
127.0.0.1:6380[10]&gt; incr age =&gt; (integer) 22 #不可以自增字符串噢
127.0.0.1:6380[10]&gt; decrby age 3 #对指定的key自减 =&gt; 20-3=17
127.0.0.1:6380[10]&gt; del age #删除某个key
</code></pre>
<ul>
<li><h5 id="Hash-Hash类型"><a href="#Hash-Hash类型" class="headerlink" title="Hash - Hash类型"></a>Hash - Hash类型</h5></li>
</ul>
<h5 id="Hash类型用于存储结构化数据"><a href="#Hash类型用于存储结构化数据" class="headerlink" title="Hash类型用于存储结构化数据"></a>Hash类型用于存储结构化数据</h5><p>↓↓↓ ↓↓↓ key &#x3D; <strong>emp:1</strong> ↓↓↓ ↓↓↓ 在value中又产生一个键值对[下面全是单个的emp:1的key值]</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">smith</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>age</strong></td>
<td align="center">35</td>
</tr>
<tr>
<td align="center"><strong>birthday</strong></td>
<td align="center">2001-02-02</td>
</tr>
<tr>
<td align="center"><strong>height</strong></td>
<td align="center">178</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hget</td>
<td align="center">hget emp:1 age</td>
<td align="center">获取hash中key&#x3D;age的值</td>
</tr>
<tr>
<td align="center">hset</td>
<td align="center">hset emp:1 age 23</td>
<td align="center">设置hash中age&#x3D;23</td>
</tr>
<tr>
<td align="center">hmset<br />hmget<br />hgetall<br /></td>
<td align="center">hmset emp:1 age 30 name kaka<br />hmget emp:1 age name<br />hgetall emp:1<br /></td>
<td align="center">设置hash多个值<br />获取hash多个值<br />获取hash所有值<br /></td>
</tr>
<tr>
<td align="center">hdel</td>
<td align="center">hdel emp:1 age</td>
<td align="center">删除emp:1的age</td>
</tr>
<tr>
<td align="center">hexists</td>
<td align="center">hexists emp:1 name</td>
<td align="center">检查是否存在</td>
</tr>
<tr>
<td align="center">hlen</td>
<td align="center">hlen emp:1</td>
<td align="center">获取指定长度</td>
</tr>
</tbody></table>
<pre><code class="java">127.0.0.1:6380[1]&gt; hset emp:1 name zhangsan       #设置某个hash值
127.0.0.1:6380[1]&gt; hset emp:1 age 35
127.0.0.1:6380[1]&gt; hset emp:1 birthday 2001-02-02
127.0.0.1:6380[1]&gt; hset emp:1 height 178
127.0.0.1:6380[1]&gt; keys * =&gt; &quot;emp:1&quot;
127.0.0.1:6380[1]&gt; hget emp:1 name    #获取指定hash值 =&gt;&quot;zhangsan&quot;
127.0.0.1:6380[1]&gt; hget emp:1 age =&gt; &quot;35&quot;
127.0.0.1:6380[1]&gt; hgetall emp:1 #提取所有的数据 

127.0.0.1:6380[1]&gt; hmset emp:2 name lisa age 23 birthday 1990-05-03 height 165
127.0.0.1:6380[1]&gt; hgetall emp:2
127.0.0.1:6380[1]&gt; del emp:2     #删除整个对象
127.0.0.1:6380[1]&gt; hlen emp:1 =&gt; (integer) 4     #代表在emp:1中有4个属性
127.0.0.1:6380[1]&gt; hgetall emp:1 
127.0.0.1:6380[1]&gt; hexists emp:1 name  #判断属性是否存在 是则返回1
</code></pre>
<ul>
<li><h5 id="List-列表类型"><a href="#List-列表类型" class="headerlink" title="List - 列表类型"></a>List - 列表类型</h5><ul>
<li>List列表就是一系列字符串的”数组”, 按插入顺序排序</li>
<li>List列表最大长度为2的32次方-1, 可以包含40亿个元素</li>
</ul>
<h6 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h6><ul>
<li><strong>rpush listkey c b a</strong> - 右侧插入 <u>先c后b最后a</u></li>
<li><strong>lpush listkey f e d</strong> - 左侧插入 <u>先f后e最后d</u>         <em>d e f c b a</em></li>
<li><strong>rpop listkey</strong> - 右侧弹出          <em>d e f c b</em></li>
<li><strong>lpop listkey</strong> -左侧弹出             <em>e f c b</em></li>
</ul>
</li>
</ul>
<pre><code class="java">127.0.0.1:6380[1]&gt; rpush list c =&gt;(integer) 1
127.0.0.1:6380[1]&gt; lrange list 0 -1  #输出指定列表起始到结束范围内的所有元素 [开始 末尾]
127.0.0.1:6380[1]&gt; rpush list b a =&gt;(integer) 3
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;c&quot; &quot;b&quot; &quot;a&quot;
127.0.0.1:6380[1]&gt; lpush list f      #在左侧插入
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;f&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot;
127.0.0.1:6380[1]&gt; lpush list b a
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;a&quot; &quot;b&quot; &quot;f&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot;
127.0.0.1:6380[1]&gt; rpop list =&gt; &quot;a&quot;
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;a&quot; &quot;b&quot; &quot;f&quot; &quot;c&quot; &quot;b&quot;
127.0.0.1:6380[1]&gt; lpop list =&gt; &quot;b&quot; &quot;f&quot; &quot;c&quot; &quot;b&quot;
</code></pre>
<ul>
<li><h5 id="Set-集合类型-Zset-有序集合类型"><a href="#Set-集合类型-Zset-有序集合类型" class="headerlink" title="Set - 集合类型      Zset - 有序集合类型"></a>Set - 集合类型      Zset - 有序集合类型</h5><ul>
<li>Set集合是字符串的无序集合, 集合成员是唯一的</li>
<li>Zset集合是字符串的有序集合, 集合成员是唯一的</li>
</ul>
</li>
</ul>
<pre><code class="java">Set集合
127.0.0.1:6380[1]&gt; sadd set1 a =&gt; 1
127.0.0.1:6380[1]&gt; keys * =&gt; &quot;set1&quot; &quot;emp:1&quot; &quot;list&quot;
127.0.0.1:6380[1]&gt; sadd set1 b =&gt; &quot;b&quot;
127.0.0.1:6380[1]&gt; sadd set1 c =&gt; &quot;c&quot;
127.0.0.1:6380[1]&gt; sadd set1 d =&gt; &quot;d&quot;
127.0.0.1:6380[1]&gt; sadd set1 e =&gt; &quot;e&quot;
127.0.0.1:6380[1]&gt; sadd set1 f =&gt; &quot;f&quot;
127.0.0.1:6380[1]&gt; smembers set1 =&gt; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;e&quot;  #字母顺序打乱 乱序

127.0.0.1:6380[1]&gt; sadd set2 d     #创建一个set2与set1有重叠
127.0.0.1:6380[1]&gt; sadd set2 e
127.0.0.1:6380[1]&gt; sadd set2 f
127.0.0.1:6380[1]&gt; sadd set2 h
127.0.0.1:6380[1]&gt; sadd set2 g
127.0.0.1:6380[1]&gt; smembers set2 =&gt; &quot;d&quot; &quot;h&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot;
127.0.0.1:6380[1]&gt; sinter set1 set2 =&gt;     &quot;d&quot; &quot;f&quot; &quot;e&quot;     #取其中的交集
127.0.0.1:6380[1]&gt; sunion set1 set2 =&gt;     &quot;d&quot; &quot;g&quot; &quot;b&quot; &quot;c&quot; &quot;h&quot; &quot;f&quot; &quot;e&quot; &quot;a&quot;    #取其中的并集[取并集并去除重复元素]
127.0.0.1:6380[1]&gt; sdiff set1 set2 #寻找叉集(在set1有 在set2中没有[两个部分交集排除在外])
=&gt; &quot;a&quot; &quot;c&quot; &quot;b&quot;
127.0.0.1:6380[1]&gt; sdiff set2 set1 =&gt; &quot;h&quot; &quot;g&quot;
</code></pre>
<pre><code class="java">Zset集合
127.0.0.1:6380[1]&gt; zadd zset1 100 a =&gt;1
127.0.0.1:6380[1]&gt; zadd zset1 101 b =&gt; 1
127.0.0.1:6380[1]&gt; zrange zset1 0 -1 =&gt; &quot;a&quot; &quot;b&quot; #按照顺序排序
127.0.0.1:6380[1]&gt; zadd zset1 99 c =&gt; 1  
127.0.0.1:6380[1]&gt; zrange zset1 0 -1 =&gt; &quot;c&quot; &quot;a&quot; &quot;b&quot; #按照分数升序排列
127.0.0.1:6380[1]&gt; zadd zset1 102 d
127.0.0.1:6380[1]&gt; zadd zset1 103 e
127.0.0.1:6380[1]&gt; zadd zset1 104 f
127.0.0.1:6380[1]&gt; zrange zset1 0 -1 withscores #升序打印分数
127.0.0.1:6380[1]&gt; zrangebyscore zset1 100 103 #符合score从100-103的名字
</code></pre>
<h3 id="Java客户端-Jedis"><a href="#Java客户端-Jedis" class="headerlink" title="Java客户端-Jedis"></a>Java客户端-Jedis</h3><ul>
<li>Jedis是Java语言开发的Redis客户端工具包</li>
<li>Jedis只是对Redis命令的封装, 掌握Redis命令便可轻易上手</li>
</ul>
<h6 id="允许远程访问需要改文件"><a href="#允许远程访问需要改文件" class="headerlink" title="允许远程访问需要改文件"></a>允许远程访问需要改文件</h6><pre><code class="java">[root@imooc ~]# cd /usr/local/redis/redis-5.0.2/
[root@imooc redis-5.0.2]# vim redis.conf
第88行 protected-mode yes 将yes设置为no
第69行 bind 127.0.0.1 改为 bind 0.0.0.0     #四个0代表所有ip主机都可以访问进来【真正开发时要用特定的ip号】
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf
[root@imooc redis-5.0.2]# netstat -tulpn | grep redis
[root@imooc redis-5.0.2]# firewall-cmd --zone=public --add-port=6379/tcp --permanent
[root@imooc redis-5.0.2]# firewall-cmd --reload
[root@imooc redis-5.0.2]# ifconfig =&gt; IP地址: 192.168.170.135

[root@imooc redis-5.0.2]# ./src/redis-cli -p 6379
</code></pre>
<p>报错连接超时：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41830655/article/details/106114663">Java远程连接Redis时出现: java.net.SocketTimeoutException: connect timed out的解决办法-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zinbin/article/details/109336852">Java连接Redis connection timed out 报错的解决方法_caused by: io.netty.channel.abstractchannel$annota-CSDN博客</a></p>
<pre><code class="java">systemctl start firewalld  #开启防火墙
systemctl enable firewalld.service  #开机自启动防火墙

systemctl stop firewalld.service #关闭防火墙
重启 Redis 服务端
ps -ef|grep redis    #查看 Redis 进程 
kill -s 9 进程号      #杀死 Redis 进程
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf 
</code></pre>
<pre><code class="java">package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.List;

public class JedisTestor &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            jedis.auth(&quot;root&quot;);
            jedis.select(2);
            System.out.println(&quot;Redis连接成功&quot;);
            //字符串
            jedis.set(&quot;sn&quot;, &quot;7781-9938&quot;);
            String sn = jedis.get(&quot;sn&quot;);
            System.out.println(sn);
            jedis.mset(new String[]&#123;&quot;title&quot;, &quot;婴幼儿奶粉&quot;, &quot;num&quot;, &quot;20&quot;&#125;);
            List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot;, &quot;title&quot;, &quot;num&quot;&#125;);
            System.out.println(goods);
            Long num = jedis.incr(&quot;num&quot;);
            System.out.println(num);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">pom.xml【两个jar:    jedis-2.9.0.jar        fastjson-1.2.62.jar】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Jedis_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;2.9.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">[root@imooc redis-5.0.2]# ./src/redis-cli
127.0.0.1:6379&gt; auth root
127.0.0.1:6379&gt; select 2
127.0.0.1:6379[2]&gt; keys * =&gt; &quot;sn&quot;
127.0.0.1:6379[2]&gt; get sn =&gt; &quot;7781-9938&quot;
【此处更换新的java代码再次插入 奶粉...】
------------------------------------------------------------------
jedis.mset(new String[]&#123;&quot;title&quot;, &quot;婴幼儿奶粉&quot;, &quot;num&quot;, &quot;20&quot;&#125;);
List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot;, &quot;title&quot;, &quot;num&quot;&#125;);
------------------------------------------------------------------
127.0.0.1:6379[2]&gt; keys * =&gt; &quot;sn&quot; &quot;num&quot; &quot;title&quot;
127.0.0.1:6379[2]&gt; get num =&gt; 21
127.0.0.1:6379[2]&gt; get title =&gt; \xe5\xa9\xb4\xe5\xb9\xbc\xe5...
</code></pre>
<h3 id="Jedis操作Hash类型"><a href="#Jedis操作Hash类型" class="headerlink" title="Jedis操作Hash类型"></a>Jedis操作Hash类型</h3><pre><code class="java">package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JedisTestor &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            jedis.auth(&quot;root&quot;);
            jedis.select(2);
            System.out.println(&quot;Redis连接成功&quot;);
            //字符串
            jedis.set(&quot;sn&quot;, &quot;7781-9938&quot;);
            String sn = jedis.get(&quot;sn&quot;);
            System.out.println(sn);
            jedis.mset(new String[]&#123;&quot;title&quot;, &quot;婴幼儿奶粉&quot;, &quot;num&quot;, &quot;20&quot;&#125;);
            List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot;, &quot;title&quot;, &quot;num&quot;&#125;);
            System.out.println(goods);
            Long num = jedis.incr(&quot;num&quot;);
            System.out.println(num);

            //Hash
            jedis.hset(&quot;student:3312&quot;, &quot;name&quot;, &quot;张晓明&quot;);
            String name = jedis.hget(&quot;student:3312&quot;, &quot;name&quot;);
            System.out.println(name);

            Map&lt;String,String&gt; studentMap = new HashMap();
            studentMap.put(&quot;name&quot;, &quot;李兰&quot;);
            studentMap.put(&quot;age&quot;, &quot;18&quot;); //所有数据类型都是String
            studentMap.put(&quot;id&quot;, &quot;3313&quot;);
            jedis.hmset(&quot;student:3313&quot;, studentMap);
            Map&lt;String,String&gt; smap = jedis.hgetAll(&quot;student:3313&quot;);
            System.out.println(smap);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;
&#125;

---------------------------------------------------------------
Redis连接成功
7781-9938
[7781-9938, 婴幼儿奶粉, 20]
21
张晓明
&#123;name=李兰, age=18, id=3313&#125;
</code></pre>
<pre><code class="java">127.0.0.1:6380[2]&gt; hgetall student:3313
</code></pre>
<h3 id="Jedis操作List类型"><a href="#Jedis操作List类型" class="headerlink" title="Jedis操作List类型"></a>Jedis操作List类型</h3><pre><code class="java">package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JedisTestor &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123; //List
            jedis.del(&quot;letter&quot;); //要先删除不然lpop、rpop的时候会追加数据
            jedis.rpush(&quot;letter&quot;, new String[]&#123;&quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;);
            jedis.lpush(&quot;letter&quot;, new String[]&#123;&quot;c&quot;, &quot;b&quot;, &quot;a&quot;&#125;);
            List&lt;String&gt; letter = jedis.lrange(&quot;letter&quot;, 0, -1);
            jedis.lpop(&quot;letter&quot;);
            jedis.rpop(&quot;letter&quot;);
            letter = jedis.lrange(&quot;letter&quot;, 0, -1);
            System.out.println(letter);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;
&#125;
----————--——----------------------------------------------------
[a, b, c, d, e, f] =&gt; [b, c, d, e]
</code></pre>
<h3 id="利用Jedis缓存数据-放在内存处理-速度快"><a href="#利用Jedis缓存数据-放在内存处理-速度快" class="headerlink" title="利用Jedis缓存数据 [放在内存处理 速度快]"></a>利用Jedis缓存数据 [放在内存处理 速度快]</h3><h6 id="缓存数据：资料不要太大-信息比较稳定更新次数较低"><a href="#缓存数据：资料不要太大-信息比较稳定更新次数较低" class="headerlink" title="缓存数据：资料不要太大 信息比较稳定更新次数较低"></a>缓存数据：资料不要太大 信息比较稳定更新次数较低</h6><pre><code class="java">Goods.java
public class Goods &#123;
    private Integer goodsId;
    private String goodsName;
    private String description;
    private Float price;
    Getter + Setter + Constructor[空+全]
&#125;
</code></pre>
<pre><code class="java">CacheSample.java
package com.imooc.jedis;

import com.alibaba.fastjson.JSON;
import redis.clients.jedis.Jedis;

import java.util.ArrayList;
import java.util.List;

public class CacheSample &#123;
    public CacheSample()&#123; //数据初始化
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            List&lt;Goods&gt; goodsList = new ArrayList();
            goodsList.add(new Goods(8818,&quot;红富士苹果&quot;,&quot;&quot;,3.5f));
            goodsList.add(new Goods(8819,&quot;赣南脐橙&quot;,&quot;&quot;,5f));
            goodsList.add(new Goods(8820,&quot;进口香蕉&quot;,&quot;&quot;,2f));
            //javabean序列化为json字符串保存到java里
            jedis.auth(&quot;root&quot;);
            jedis.select(3);
            for (Goods goods : goodsList)&#123;
                String json = JSON.toJSONString(goods);
                System.out.println(json);
                String key = &quot;goods:&quot; + goods.getGoodsId();
                jedis.set(key, json); //key + value[序列化为json]
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new CacheSample();
    &#125;
&#125;
________________________________________________________________
&#123;&quot;description&quot;:&quot;&quot;,&quot;goodsId&quot;:8818,&quot;goodsName&quot;:&quot;红富士苹果&quot;,&quot;price&quot;:3.5&#125;
&#123;&quot;description&quot;:&quot;&quot;,&quot;goodsId&quot;:8819,&quot;goodsName&quot;:&quot;赣南脐橙&quot;,&quot;price&quot;:5.0&#125;
&#123;&quot;description&quot;:&quot;&quot;,&quot;goodsId&quot;:8820,&quot;goodsName&quot;:&quot;进口香蕉&quot;,&quot;price&quot;:2.0&#125;
________________________________________________________________
127.0.0.1:6379[3]&gt; keys *
127.0.0.1:6379[3]&gt; &quot;goods:8820&quot; &quot;goods:8819&quot; &quot;goods:8818&quot;
127.0.0.1:6379[3]&gt; get goods:8820
</code></pre>
<hr>
<h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h6><pre><code class="java">CacheSample.java
package com.imooc.jedis;

import com.alibaba.fastjson.JSON;
import redis.clients.jedis.Jedis;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class CacheSample &#123;
    public CacheSample()&#123; //数据初始化
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            List&lt;Goods&gt; goodsList = new ArrayList();
            goodsList.add(new Goods(8818,&quot;红富士苹果&quot;,&quot;&quot;,3.5f));
            goodsList.add(new Goods(8819,&quot;赣南脐橙&quot;,&quot;&quot;,5f));
            goodsList.add(new Goods(8820,&quot;进口香蕉&quot;,&quot;&quot;,2f));
            //javabean序列化为json字符串保存到java里
            jedis.auth(&quot;root&quot;);
            jedis.select(3);
            for (Goods goods : goodsList)&#123;
                String json = JSON.toJSONString(goods);
                System.out.println(json);
                String key = &quot;goods:&quot; + goods.getGoodsId();
                jedis.set(key, json); //key + value[序列化为json]
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new CacheSample();
        System.out.println(&quot;请输入要查询的商品编号:&quot;);
        String goodsId = new Scanner(System.in).next();
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;);
        jedis.auth(&quot;root&quot;);
        jedis.select(3);
        String key = &quot;goods:&quot; + goodsId;
        if (jedis.exists(key))&#123;
            String json = jedis.get(key);
            System.out.println(json);
            //由json转回到java对象
            Goods g = JSON.parseObject(json, Goods.class);
            System.out.println(g.getGoodsName());
            System.out.println(g.getPrice());
        &#125;else&#123;
            System.out.println(&quot;您输入的商品编号不存在，请重新输入!&quot;);
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/11/15/后端/Linux,Redis,Jedis/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        

        <span class="current">
            2
        </span>

        
        <span>
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
            
            <a href="/page/4">
                <span class="page-num">
                    4
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/12">
                <span class="page-num">
                    12
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/3/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>