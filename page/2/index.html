
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2024/07/03/前端/Vue/">
        <h2>
            Vue
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/7/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Vue快速入门"><a href="#Vue快速入门" class="headerlink" title="Vue快速入门"></a>Vue快速入门</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>MVVM</strong>响应式编程模型，避免直接操作<strong>DOM</strong>，降低<strong>DOM</strong>操作的复杂性</p>
<p>安装Vscode 安装nodejs<br>检测是否安装成功 <code>cmd →  node -v  →  npm -v</code></p>
<h6 id="npm设置镜像-cmd"><a href="#npm设置镜像-cmd" class="headerlink" title="npm设置镜像[cmd]"></a>npm设置镜像[cmd]</h6><pre><code class="java">C:\Users\Pluminary&gt;npm config set registry https://registry.npmmirror.com
C:\Users\Pluminary&gt;npm config ls
C:\Users\Pluminary&gt;npm config get registry
</code></pre>
<pre><code class="java">在Vscode里的终端输入 
PS C:\Users\Pluminary\Desktop\vue2&gt; npm init -y
PS C:\Users\Pluminary\Desktop\vue2&gt; npm install vue
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/c327127960/article/details/108853046">Vue Chrome调试工具 Vue.js devtools 5.3.3 安装包及教程_vuedevtool.crx百度网盘-CSDN博客</a></p>
<h4 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h4><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 这个就没有被挂载--&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;!--在对话框里输入的时候改变下面的次数--&gt;
        &lt;button v-on:click=&quot;num++&quot;&gt;登录&lt;/button&gt; &lt;!--实现当点击按钮的时候num数值++--&gt;
        &lt;button v-on:click=&quot;loginout()&quot;&gt;登出&lt;/button&gt;
        &lt;h1&gt;&#123;&#123;name&#125;&#125;, 欢迎您,当前登录第&#123;&#123;num&#125;&#125;次,当前登录时间：&#123;&#123;nowDate()&#125;&#125;&lt;/h1&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;

    &lt;script&gt;
        // 1. new vue实例 每个Vue应用都是通过Vue函数创建一个新的Vue实例开始的
        new Vue(&#123;
            el:&quot;#app&quot;, // 挂载的模板
            data()&#123; // 绑定的数据 把data对象中的所有属性 加到相应视图里
                return&#123;
                    name : &quot;图灵学院&quot;,
                    num:1
                &#125;
            &#125;,
            methods: &#123;
                nowDate()&#123;
                    return new Date().toLocaleDateString()
                &#125;,
                loginout()&#123;
                    this.num--; //当调用实例时要加this
                &#125;
            &#125;,
        &#125;);
        // 双向绑定：数据发生改变 视图也要随之改变；在谷歌浏览器的Vue调试中
        // 指令：简化对Dom的频繁操作
        // 方法：声明方法可以实现更复杂的操作，声明methods属性中
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-text、v-html"><a href="#指令-v-text、v-html" class="headerlink" title="指令 v-text、v-html"></a>指令 v-text、v-html</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div v-text=&quot;message&quot;&gt;&lt;/div&gt;&#123;&#123;message&#125;&#125;
        &lt;!-- &#123;&#123;&#125;&#125;在网络延迟情况下会出现暂时显示的情况 --&gt;
        &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    // 1.实例Vue
    var vm = new Vue(&#123;
        el:&#39;#app&#39;,
        data:&#123;
            message: &quot;&lt;a href = &#39;#&#39;&gt;Hello&lt;/a&gt;&quot;
        &#125;,
    &#125;)
// v-text 用于绑定数据，语法v-text=&quot;属性&quot;，会直接将值作为文本显示
// v-html 会将值进行编译再显示
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-bind"><a href="#指令-v-bind" class="headerlink" title="指令 v-bind"></a>指令 v-bind</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .red&#123;
            background-color: red;
        &#125; 
        .yellow&#123;
            background-color: yellow;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;    &lt;!--:style=&quot;font-size: &#123;&#123;bigFont&#125;&#125;; 错误写法--&gt;
        &lt;div v-bind:title=&quot;title&quot; :class=&quot;red&quot; :style=&quot;&#123;fontSize:bigFont&#125;&quot;&gt;
            鼠标悬停查看信息！
        &lt;/div&gt;
        &lt;div :class=&quot;&#123;yellow:isyellow&#125;&quot;&gt;
            &lt;a :href=&quot;href&quot; :style=&quot;&#123;fontSize:bigFont&#125;&quot;&gt;图灵学院&lt;/a&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;img :src=&quot;src&quot;/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;button v-bind:disabled=&quot;disabled&quot;&gt;禁用按钮&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue(&#123;
        el: &quot;#app&quot;,
        data:&#123;
            red:&quot;red&quot;,
            isyellow:true,
            bigFont:&quot;50px&quot;,
            title: &quot;您好，本网站可以学到更多的知识&quot;,
            href: &quot;https://www.pronhub.com/&quot;,
            scr: &#39;../Imooc_Cat.jpg&#39;,
            disabled: true
        &#125;
    &#125;)

    // 绑定元素属性 -- v-bind
    // 语法：v-bind:元素属性=&quot;vue的属性&quot;
    // 简写：v-bind:title 简写成 :title
    /*
       针对样式的特殊用法：
         动态控制class是否添加 :class=&quot;&#123;red:isred&#125;&quot;
           语法 &#123;red:isred&#125; : &#123;需要动态控制的class样式:vue的属性(需要是boolean类型)&#125;

         动态设置style的样式   :style=&quot;&#123;fontSize:bigFont&#125;&quot;
           语法 &#123;fontSize: bigFont&#125; : &#123;css样式的驼峰命名方法:&#125; font-size=fontSize
    */
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-model"><a href="#指令-v-model" class="headerlink" title="指令 v-model"></a>指令 v-model</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;
            &lt;label&gt;年龄：&lt;/label&gt;
            &lt;input v-model=&quot;age&quot;/&gt;
        &lt;/div&gt;
        &lt;div&gt;当前输入的年龄是：&#123;&#123;age&#125;&#125;&lt;/div&gt;
        &lt;button @click=&quot;add&quot;&gt;加一岁&lt;/button&gt; &lt;!--  @click = v-on:click  --&gt;
        &lt;button @click=&quot;alertYear&quot;&gt;弹出年龄&lt;/button&gt;

    &lt;hr&gt;
        &lt;label&gt;课程：&lt;/label&gt;
        &lt;select v-model=&quot;course&quot;&gt;
            &lt;option value=&quot;javascript&quot;&gt;javascript&lt;/option&gt;
            &lt;option value=&quot;java&quot;&gt;java&lt;/option&gt;
            &lt;option value=&quot;c++&quot;&gt;c++&lt;/option&gt;
        &lt;/select&gt;

        &lt;div&gt;
            &lt;input v-model=&quot;course&quot; type=&quot;radio&quot; name=&quot;course&quot; value=&quot;javascript&quot;&gt;javascript
            &lt;input v-model=&quot;course&quot; type=&quot;radio&quot; name=&quot;course&quot; value=&quot;java&quot;&gt;java
            &lt;input v-model=&quot;course&quot; type=&quot;radio&quot; name=&quot;course&quot; value=&quot;c++&quot;&gt;c++
        &lt;/div&gt;

        &lt;div&gt;当前课程是：&#123;&#123;course&#125;&#125;&lt;/div&gt;
    &lt;/div&gt;
    
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el:&quot;#app&quot;,
    data:&#123;
        age:10,
        course:&#39;java&#39;
    &#125;,
    methods: &#123;
        add()&#123;
            this.age++;
        &#125;,
        alertYear()&#123;
            alert(this.age)
        &#125;
    &#125;
&#125;)

//v-model 用于实现双向绑定 一般用在表单元素
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-on"><a href="#指令-v-on" class="headerlink" title="指令 v-on"></a>指令 v-on</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button v-on:click=&quot;hello(&#39;hello&#39;)&quot;&gt;hello&lt;/button&gt;
        &lt;button @click=&quot;hello(&#39;world&#39;)&quot;&gt;world&lt;/button&gt;
        &lt;button @click=&quot;num++&quot;&gt;数据：&lt;/button&gt;&#123;&#123;num&#125;&#125;
&lt;!-- 不让事件传播 禁止默认a标签事件 
 @click.stop 不让事件传播
 @click.self 需要自己点击[不会参与传播]
 @click.prevent 组织默认事件
 @click.once 事件只会触发一次
 --&gt;
        &lt;div @click=&quot;hello(1)&quot; style=&quot;background-color: red; width: 800px; height: 500px;padding: 50px;&quot;&gt;
            1
            &lt;div @click.stop=&quot;hello(2)&quot; style=&quot;background-color: blue; width: 400px; height: 200px;padding: 50px;&quot;&gt;
                2
                &lt;a @click.stop.prevent=&quot;hello(3)&quot; style=&quot;background-color: yellow; width: 200px; height: 100px; display: block;padding: 50px;&quot; href=&quot;www.baidu.com&quot;&gt;3&lt;/a&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;input v-on:keyup.enter=&quot;hello(&#39;enter&#39;)&quot;&gt; &lt;!--键盘按回车触发--&gt;&lt;br&gt;
        &lt;input v-on:keyup.space=&quot;hello(&#39;enter&#39;)&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue(&#123;
        el: &quot;#app&quot;,
        data:&#123;
            num: 0
        &#125;,
        methods: &#123;
            hello(str)&#123;
                alert(str)
            &#125;
        &#125;
    &#125;)

/*
 v-on用于绑定事件
 语法  v-on:事件名
 简写方式 v-on:click =&gt; @click
 只能调用vue中的函数和数据
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-for"><a href="#指令-v-for" class="headerlink" title="指令 v-for"></a>指令 v-for</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        循环数组
        &lt;ul&gt;
            &lt;li v-for=&quot;(item, index) in music&quot;&gt;&#123;&#123;item.name&#125;&#125;---&#123;&#123;index+1&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
        循环对象
        &lt;ul&gt;
            &lt;li v-for=&quot;(item, index) in obj&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el: &#39;#app&#39;,
    data:&#123;
        // 要循环的数组
        music:[
            &#123;name: &#39;青花瓷&#39;&#125;,
            &#123;name: &#39;阳光总在风雨后&#39;&#125;,
            &#123;name: &#39;十年&#39;&#125;
        ],
        // 要循环的对象
        obj:&#123;
            name: &#39;句号&#39;,
            age: 18,
            sex: &#39;男&#39;
        &#125;
    &#125;
&#125;)
/*
v-for循环，可以循环数组和对象
v-for=&quot;(item, index) in intems
语法：v-for=&quot;(每次循环接收的变量, 当前循环的索引) in 需要循环的变量&quot;
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-if-与-v-show"><a href="#指令-v-if-与-v-show" class="headerlink" title="指令 v-if 与 v-show"></a>指令 v-if 与 v-show</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button @click=&quot;vif=!vif&quot;&gt;切换显示隐藏&lt;/button&gt;
        &lt;div v-if=&quot;vif&quot; style=&quot;background-color: red; width: 200px; height: 200px;&quot;&gt;
            v-if
        &lt;/div&gt;
        &lt;hr&gt;
        &lt;button @click=&quot;vshow=!vshow&quot;&gt;切换显示隐藏&lt;/button&gt;
        &lt;div v-show=&quot;vshow&quot; style=&quot;background-color: yellow; width: 200px; height: 200px;&quot;&gt;
            v-show
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el: &quot;#app&quot;,
    data:&#123;
        vif: true,
        vshow: true
    &#125;
&#125;)
/*
    v-if 和 v-show 用于控制元素显示隐藏
    语法 v-if = &quot;指定Boolean值&quot; v-show一样
    
    v-if 控制元素是否生成
    v-show 控制元素是否显示隐藏
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-else-与-v-else-if"><a href="#指令-v-else-与-v-else-if" class="headerlink" title="指令 v-else 与 v-else-if"></a>指令 v-else 与 v-else-if</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div v-if=&quot;number == 1&quot;&gt;
            A
        &lt;/div&gt;
        &lt;div v-else-if=&quot;number == 2&quot;&gt;
            B
        &lt;/div&gt;
        &lt;div v-else&gt;
            C
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el: &#39;#app&#39;,
    data() &#123;
        return &#123;
            number: 1
        &#125;
    &#125;,
&#125;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;计算属性和侦听器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 实现一个购物车功能 
            1. 数据初始化处理
            2. 选择商品数量：当商品数量超过库存做提示
            3. 计算商品总价
        --&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;(item, index) in car&quot;&gt;
                &#123;&#123;item.pname&#125;&#125; --- 商品价格：&#123;&#123;item.price&#125;&#125; --- 库存：&#123;&#123;item.stock&#125;&#125;
                数量：&lt;input type=&quot;number&quot; v-model=&quot;item.num&quot; style=&quot;width: 30px;&quot;/&gt;
            &lt;/li&gt;
            &lt;li&gt;&lt;strong&gt;总价：&lt;/strong&gt;&#123;&#123;calcSum&#125;&#125;&lt;/li&gt;
            &lt;!-- &lt;li v-html=&quot;warn()&quot;&gt;&lt;/li&gt; --&gt;
            &lt;li v-html=&quot;message&quot;&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
 new Vue(&#123;
    el:&quot;#app&quot;,
    data:&#123;
        car:[
            &#123;pname:&#39;IPhone 12&#39;,price:10000,stock:10,num:1&#125;,
            &#123;pname:&#39;Mate40 pro&#39;,price:7000,stock:3,num:1&#125;,
        ],
        message:&quot;&quot;,
    &#125;,
    // methods：当方法中的数据发生改变，方法会自动调用 所以当数量增加时会自动计算总价
    methods: &#123;
        // calcSum()&#123;
        //     let sum=0;
        //     this.car.forEach(item =&gt; &#123;
        //         sum+=item.price*item.num;
        //     &#125;);
        //     return sum;
        // &#125;

        // warn()&#123;
        //     let message=&quot;&quot;;
        //     this.car.forEach(item =&gt; &#123;
        //         if(item.num&gt;item.stock)&#123;
        //             message+=`$&#123;item.pname&#125;的库存超出限制&lt;br/&gt;`
        //         &#125;
        //     &#125;);
        //     return message;
        // &#125;
    &#125;,
    // 计算属性 上面就不加大括号  &lt;li&gt;&lt;strong&gt;总价：&lt;/strong&gt;&#123;&#123;calcSum&#125;&#125;&lt;/li&gt;
    computed:&#123;
        calcSum()&#123;
            let sum=0;
            this.car.forEach(item =&gt; &#123;
                sum+=item.price*item.num;
            &#125;);
            return sum;
        &#125;
    &#125;,
    // 侦听器 专门用于侦听某些数据的变化，当数据发生变化会自动调节方法 不能像方法那样调用
    watch:&#123;
        // 要侦听的数据 
        car:&#123;
            handler(newvalue,oldvalue)&#123;
                this.message=&quot;&quot;;
                this.car.forEach(item =&gt; &#123;
                    if(item.num&gt;item.stock)&#123;
                        this.message+=`$&#123;item.pname&#125;的库存超出限制&lt;br/&gt;`
                    &#125;
                &#125;);
            &#125;,
            deep:true
        &#125;,
        //侦听message 基础类型的侦听 将侦听数据作为函数就可以了
        message(newvalue,oldvalue)&#123;
            console.info(newvalue,oldvalue)
        &#125;
    &#125;
 &#125;);
 /*
    方法和计算属性的区别：
    声明方式不一样，调用不一样方法要用&quot;()&quot;, 计算属性调用不要加&quot;()&quot;
 */
/*
    方法和侦听器的区别：
        方法：方法中任意数据发生改变了就会自动调用方法 
            可以调用，进行返回值

        侦听器：需要指定具体的侦听数据，只有被具体指定的侦听数据发生了改变才会触发
            不能像方法那样去调用，而是靠vue自动触发 如果初始情况就数量就大于库存是不改变的
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;过滤器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    

    &lt;div id=&quot;app&quot;&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;user in userList&quot;&gt;
                姓名：&#123;&#123;user.name&#125;&#125;; 性别：&#123;&#123;user.gender==1?"男":"女"&#125;&#125;
                &#123;&#123;user.gender | filterGender&#125;&#125;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    let vm = new Vue(&#123;
        el: &quot;#app&quot;,
        data:&#123;
            userList:[
                &#123;id:1, name:&#39;xushu&#39;, gender:1&#125;,
                &#123;id:2, name:&#39;zhuge&#39;, gender:0&#125;
            ]
        &#125;,
        //针对数据过滤的
        methods:&#123;
            formateGender(gender)&#123;
                if(gender==1)&#123;
                    return &quot;~男&quot;
                &#125;else&#123;
                    return &quot;~女&quot;
                &#125;
            &#125;
        &#125;,
        filters:&#123;
            filterGender(gender)&#123;
                if(gender==1)&#123;
                    return &quot;!男&quot;
                &#125;else&#123;
                    return &quot;!女&quot;
                &#125;
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Vue-组件化"><a href="#Vue-组件化" class="headerlink" title="Vue-组件化"></a>Vue-组件化</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;组件化&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- &lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; --&gt;
        &lt;!-- &lt;xushu&gt;&lt;/xushu&gt; --&gt;
        &lt;xushu :num=&quot;numxx&quot;&gt;&lt;/xushu&gt; &lt;!--传递属性--&gt;  &lt;!--输出50--&gt;
        &lt;app-xushu&gt;&lt;/app-xushu&gt; &lt;!--输出66--&gt;
    &lt;/div&gt;

    &lt;div id=&quot;app2&quot;&gt;
        &lt;!-- &lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; --&gt;
        &lt;!-- &lt;xushu&gt;&lt;/xushu&gt; --&gt;
        &lt;xushu :num=&quot;numxx&quot;&gt;&lt;/xushu&gt; &lt;!--传递属性--&gt; &lt;!--输出100--&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // 1.全局组件 在所有的Vue实例中使用
        /*
            1.1 命名：不要使用驼峰命名法 可以用中划线命名
            1.2 模板：必须的
            1.3 数据：一定要函数的方式声明
        */
        Vue.component(&quot;xushu&quot;, &#123;
            template: `&lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;`,
            //1.在自己的字方法中声明  
            // data() &#123;
            //     return &#123;
            //         num:10
            //     &#125;
            // &#125;,

            //2.在下方父方法中声明并传递过来
            props: [&quot;num&quot;]
        &#125;);

        // 2.局部组件 //自己定义下面引用
        const appXushu = &#123;
            template: `&lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;`,
            data() &#123;
                return &#123;
                    num: 66
                &#125;
            &#125;
        &#125;;

        new Vue(&#123;
            el: &quot;#app&quot;,
            data: &#123;
                numxx: 50
            &#125;,
            components: &#123;
                &quot;app-xushu&quot;: appXushu
            &#125;
        &#125;);

        new Vue(&#123;
            el: &quot;#app2&quot;,
            data: &#123;
                numxx: 100
            &#125;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="生命周期和钩子函数"><a href="#生命周期和钩子函数" class="headerlink" title="生命周期和钩子函数"></a>生命周期和钩子函数</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;span id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;
        &lt;button @click=&quot;updateName&quot;&gt;更新&lt;/button&gt;
        &lt;button @click=&quot;destroyInstance&quot;&gt;销毁&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue(&#123;
        el: &#39;#app&#39;,
        data:&#123;
            name: &#39;hello !&#39;
        &#125;,
        methods: &#123;
            updateName()&#123;
                console.log(&#39;准备改名字啦！&#39;)
                this.name = &#39;hello 图灵！&#39;
            &#125;,
            destroyInstance()&#123;
                console.log(&#39;销毁实例&#39;)
                vm.$destroy()
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><pre><code class="vue">npm install vue-router@3
npm install vue-router@3 --legacy-peer-deps

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;!-- 1.安装vue-router路由
     2.引入vue-router文件
     3.根据不同url连接到不同的页面，需要使用模板实现，将模板绑定对应的路由地址
--&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;nav&gt;
            &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;
            &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
        &lt;/nav&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-router@3.5.1/dist/vue-router.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
                // 定义组件：原本应该是在外面定义HomeComponent.vue [创建一些组件]
        const HomeComponent = &#123;
            template: `&lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;p&gt;Welcome to the Home page!&lt;/p&gt;&lt;/div&gt;`
        &#125;;
              // 定义组件：原本应该是在外面定义AboutComponent.vue [创建一些组件]
        const AboutComponent = &#123;
            template: `&lt;div&gt;&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;Learn more about us on this page.&lt;/p&gt;&lt;/div&gt;`
        &#125;;

        // 定义路由：原本应该是外面定义router.js文件来定义路由。
        const routes = [
            &#123; path: &#39;/&#39;, component: HomeComponent &#125;,
            &#123; path: &#39;/about&#39;, component: AboutComponent &#125;
        ];

        // 创建路由实例
        const router = new VueRouter(&#123;
            routes
        &#125;);

        // 创建并挂载根实例
        const app = new Vue(&#123;
            router// 挂载路由
        &#125;).$mount(&#39;#app&#39;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Vue with Axios Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h1&gt;Data from API&lt;/h1&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;post in posts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/li&gt;
        &lt;!-- 使用 Vue 的 v-for 指令遍历 posts 数组，并生成列表项，每个列表项显示 post.title。 --&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;!-- 引入 Vue.js --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 引入 Axios --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // 创建 Vue 实例
        let vm = new Vue(&#123;
            el: &quot;#app&quot;, // Vue 实例绑定到 HTML 中的 id=&quot;app&quot; 的元素
            data: &#123;
                posts: [] // 初始化一个空数组用于存储从 API 获取的数据
            &#125;,
            created() &#123;
                // Vue 实例创建时调用的生命周期钩子
                axios.get(&#39;https://jsonplaceholder.typicode.com/posts&#39;) // 使用 Axios 发送 GET 请求
                    .then(response =&gt; &#123; // 请求成功后的处理
                        this.posts = response.data; // 将响应数据赋值给 posts 数组
                    &#125;)
                    .catch(error =&gt; &#123; // 请求失败后的处理
                        console.error(&#39;Error fetching data:&#39;, error); // 输出错误信息到控制台
                    &#125;);
            &#125;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h3><h5 id="CLI文档，开箱即用！"><a href="#CLI文档，开箱即用！" class="headerlink" title="CLI文档，开箱即用！"></a>CLI文档，开箱即用！</h5><pre><code class="vue">cmd全局安装：
npm install -g @vue/cli         或者
npm install -g @vue/cli-init

去想要的文件夹里面：C:\Users\Pluminary\Desktop\vue_cli&gt;vue init webpack tuling
vue init webpack 项目名

? Project name tuling
? Project description A Vue.js project
? Author pcy
? Vue build standalone
? Install vue-router? Yes
? Use ESLint to lint your code? No //严格检验Javascript语法的
? Set up unit tests No
? Setup e2e tests with Nightwatch? No
? Should we run `npm install` for you after the project has been created? (recommended) npm

完成后需要开启：
cd tuling
npm run dev

DONE  Compiled successfully in 1780ms 18:41:21
I  Your application is running here: http://localhost:8080
</code></pre>
<h3 id="运用element-ui创建一个简易的登录界面"><a href="#运用element-ui创建一个简易的登录界面" class="headerlink" title="运用element-ui创建一个简易的登录界面"></a>运用element-ui创建一个简易的登录界面</h3><pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;hello-world&quot;&gt;
    &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;showAlert&quot;&gt;Click Me&lt;/el-button&gt;
  &lt;/div&gt;

  &lt;div class=&quot;app&quot;&gt;
    &lt;h3&gt;&#123;&#123;passage&#125;&#125;&lt;/h3&gt;
    &lt;h4&gt;&#123;&#123;getVal()&#125;&#125;&lt;/h4&gt;
  &lt;/div&gt;

   &lt;!-- 使用Element UI的Table组件展示empList --&gt;
  &lt;el-table :data=&quot;empList&quot; style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column prop=&quot;name&quot; label=&quot;Name&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;salary&quot; label=&quot;Salary&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;
  &lt;/el-table&gt;

   &lt;!-- 登录表单 --&gt;
  &lt;el-form ref=&quot;loginForm&quot; :model=&quot;loginForm&quot; class=&quot;loginForm&quot; label-width=&quot;80px&quot;&gt;
    &lt;h2 class=&quot;loginTitle&quot;&gt;人事后台管理系统&lt;/h2&gt;
    &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;
      &lt;el-input v-model=&quot;loginForm.username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;
      &lt;el-input v-model=&quot;loginForm.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item label=&quot;验证码&quot; prop=&quot;code&quot;&gt;
      &lt;el-input v-model=&quot;loginForm.code&quot; placeholder=&quot;请输入验证码&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item style=&quot;width:100%;&quot;&gt;
      &lt;el-button type=&quot;primary&quot; @click=&quot;handleLogin&quot;&gt;登录&lt;/el-button&gt;
    &lt;/el-form-item&gt;
  &lt;/el-form&gt;
   

&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    name: &#39;app&#39;,
    data()&#123;
      return&#123;
        passage: &#39;Oh?&#39;,
        message: &#39;Hello World!&#39;,
        empList:[
          &#123; name: &#39;Peter&#39;, salary: &#39;20000&#39; &#125;,
          &#123; name: &#39;Mike&#39;, salary: &#39;16000&#39; &#125;,
          &#123; name: &#39;Tom&#39;, salary: &#39;17000&#39; &#125;
        ],
        loginForm:&#123;
          username:&#39;&#39;,
          password:&#39;&#39;,
          code:&#39;&#39;
        &#125;
      &#125;
    &#125;,
    methods: &#123;
      showAlert() &#123;
        this.$message(&#123;
          message: &#39;Hello from Element UI!&#39;,
          type: &#39;success&#39;
        &#125;);
      &#125;,
      getVal:function()&#123;
        return &quot;getVal的方法&quot;;
      &#125;,
      handleLogin() &#123;
      this.$message(&#123;
        message: `登录成功，用户名: $&#123;this.loginForm.username&#125;`,
        type: &#39;success&#39;
      &#125;);
     &#125;
    &#125;
  &#125;

&lt;/script&gt;

&lt;style scoped&gt;
    .hello-world &#123;
      text-align: center;
      margin-top: 20px;
    &#125;

    h1 &#123;
      font-size: 24px;
      margin-bottom: 20px;
    &#125;
    .app &#123;
      margin-top: 30px;
    &#125;
&lt;/style&gt;
</code></pre>
<pre><code class="java">在Vue项目中，Element UI需要正确引入CSS样式和JavaScript文件才能正常工作。如果你没有一个HTML模板文件（例如index.html），而是在Vue组件中直接编写代码，你需要通过一些方式来确保Element UI的样式和脚本被正确加载。

// 1. 创建index.html文件：
这个index.html文件通常放在public文件夹下，是你Vue应用的入口文件。Vue CLI自动生成的项目通常会有这个文件。

// 2. 为什么需要这个HTML文件？
这个index.html文件是Vue CLI或手动设置的Vue项目的入口页面。当你运行npm run serve时，Vue CLI会将所有内容注入到&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;中，这个HTML文件是项目的基本框架。

Element UI的CSS和JS资源：需要在HTML文件的&lt;head&gt;中引入Element UI的样式文件（CSS）和在&lt;body&gt;中引入JS库，这样才能确保Element UI组件在你的Vue组件中正确渲染和运行。
    
// 3. 直接在Vue组件中引入：
如果你不想使用外部HTML文件，Vue项目中可以直接在main.js中引入Element UI的样式和组件：
/*
    // main.js
    import Vue from &#39;vue&#39;;
    import App from &#39;./App.vue&#39;;
    import ElementUI from &#39;element-ui&#39;;
    import &#39;element-ui/lib/theme-chalk/index.css&#39;;

    Vue.config.productionTip = false;

    Vue.use(ElementUI);

    new Vue(&#123;
      render: h =&gt; h(App),
    &#125;).$mount(&#39;#app&#39;);
*/
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/前端" style=color:#879cff>
                前端
            </a>
        </span>
        
    </div>

    <a href="/2024/07/03/前端/Vue/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/05/12/后端/Cloud分布式微服务打造大型自媒体3大业务平台/">
        <h2>
            Cloud分布式微服务打造大型自媒体3大业务平台
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/5/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="自媒体项目"><a href="#自媒体项目" class="headerlink" title="自媒体项目"></a>自媒体项目</h1><h6 id="VM-CentOS7：数据库密码→Panchunyao123"><a href="#VM-CentOS7：数据库密码→Panchunyao123" class="headerlink" title="VM CentOS7：数据库密码→Panchunyao123!"></a>VM CentOS7：数据库密码→Panchunyao123!</h6><h5 id="开发思维与企业一致"><a href="#开发思维与企业一致" class="headerlink" title="开发思维与企业一致"></a>开发思维与企业一致</h5><ul>
<li>三端融合：门户+媒体+运营</li>
<li>4g自媒体辉煌时代</li>
<li>5g科技互联网风口</li>
<li>前后端分离式开发、代码动静分离、保证职</li>
<li>能解耦、功能模块互相协调</li>
</ul>
<h5 id="如何整合分布式中间件到项目中"><a href="#如何整合分布式中间件到项目中" class="headerlink" title="如何整合分布式中间件到项目中"></a>如何整合分布式中间件到项目中</h5><ul>
<li>整个流程会做到细致入微</li>
<li>帮助<span style = "color:red"><strong>迅速提升至少2年</strong></span>以上的项目经验</li>
</ul>
<h5 id="重点功能技术分析"><a href="#重点功能技术分析" class="headerlink" title="重点功能技术分析"></a>重点功能技术分析</h5><ul>
<li><strong>Redis</strong>：分布式会话、session共享、单点登录、防刷、计数</li>
<li><strong>Fastdfs+Nginx&#x2F;OSS&#x2F;GridFS</strong>：搭建分布式文件系统、单文件&#x2F;批量上传、人脸隐私保护拦截</li>
<li><strong>Maven</strong>：项目构建、聚合、分层、架构设计、面向对象</li>
<li><strong>阿里AI</strong>：人脸对比、文本&#x2F;图片自动审核、短信</li>
<li><strong>SpringCloud</strong>：业务分而治之、可伸缩、可扩展、接口服务化</li>
<li><strong>Freemarker</strong>：构建模块页，实现页面静态化</li>
</ul>
<h5 id="前置技能必备"><a href="#前置技能必备" class="headerlink" title="前置技能必备"></a>前置技能必备</h5><ul>
<li>Java基础</li>
<li>熟悉MySQL&#x2F;MariaDB</li>
<li>掌握Linux的基本命令</li>
</ul>
<h5 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h5><ul>
<li>前端构建与运行</li>
<li>后端手把手从0到1</li>
<li>中间件手把手部署</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/42c012bc7c8346dbe4070f43c67bfed16904e4a8/data/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%84%E6%9E%B6%E5%9B%BE.jpg" style="zoom: 80%;" />



<h3 id="前后端分离开发模式"><a href="#前后端分离开发模式" class="headerlink" title="前后端分离开发模式"></a>前后端分离开发模式</h3><h5 id="传统JavaWeb开发-与-前后端页面交互"><a href="#传统JavaWeb开发-与-前后端页面交互" class="headerlink" title="传统JavaWeb开发 与 前后端页面交互"></a>传统JavaWeb开发 与 前后端页面交互</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/1e5f4e27bd9ca7bf4ab7d4afebe373a9f06dc735/data/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F.png"></p>
<h3 id="运行前端项目"><a href="#运行前端项目" class="headerlink" title="运行前端项目"></a>运行前端项目</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bugu_hhh/article/details/130625482?ops_request_misc=%7B%22request_id%22:%22171930111016800178595350%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171930111016800178595350&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-130625482-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=linux%E4%B8%8B%E5%AE%89%E8%A3%85mysql&spm=1018.2226.3001.4187">Linux 安装 MySQL【CentOS】_linux 安装mysql-CSDN博客</a></p>
<pre><code class="java">前端代码在压缩包中 启动D:\apache-tomcat-8.5.93\bin\startup.bat
将里面的imooc-news放到D:\apache-tomcat-8.5.93\webapps中
去浏览器中启动 http://localhost:9090/imooc-news/portal/index.html
</code></pre>
<h5 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h5><blockquote>
<p><a target="_blank" rel="noopener" href="https://oldj.github.io/SwitchHosts/">https://oldj.github.io/SwitchHosts/</a><br>在本地把域名和对应的IP給联系绑定起来 [相当于在云服务买了域名后绑定]</p>
<p> #imooc-news 127.0.0.1<br>[这东西需要关闭代理才可以用]</p>
<p>127.0.0.1 <a target="_blank" rel="noopener" href="http://www.imoocnews.com/">www.imoocnews.com</a><br>127.0.0.1 writer.imoocnews.com<br>127.0.0.1 admin.imoocnews.com</p>
<p>127.0.0.1 article.imoocnews.com<br>127.0.0.1 user.imoocnews.com<br>127.0.0.1 files.imoocnews.com</p>
</blockquote>
<h6 id="D-apache-tomcat-8-5-93-webapps-imooc-news-portal-js-app-js"><a href="#D-apache-tomcat-8-5-93-webapps-imooc-news-portal-js-app-js" class="headerlink" title="D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\js\app.js"></a>D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\js\app.js</h6><pre><code class="java">window.app = &#123;
    /* 
    portalIndexUrl: &quot;http://localhost:8080/imooc-news/portal/index.html&quot;,           // 门户首页地址
    writerIndexUrl: &quot;http://localhost:8080/imooc-news/writer/contentMng.html&quot;,      // 作家中心首页
    writerInfoUrl: &quot;http://localhost:8080/imooc-news/writer/accountInfo.html&quot;,     // 用户信息完善页面
    userServerUrl: &quot;http://192.168.1.5:8003&quot;,   // 用户服务后端接口地址
    */

    portalIndexUrl: &quot;http://www.imoocnews.com:9090/imooc-news/portal/index.html&quot;,           // 门户首页地址
    writerLoginUrl: &quot;http://writer.imoocnews.com:9090/imooc-news/writer/passport.html&quot;,      // 登录页面
    writerIndexUrl: &quot;http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html&quot;,      // 作家中心首页
    writerInfoUrl: &quot;http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html&quot;,     // 用户信息完善页面
    adminCenterUrl: &quot;http://admin.imoocnews.com:9090/imooc-news/admin/contentReview.html&quot;,     // 运营管理平台主页

    userServerUrl: &quot;http://user.imoocnews.com:8003&quot;,        // 用户服务后端接口地址
    fsServerUrl: &quot;http://files.imoocnews.com:8004&quot;,         // 文件服务后端接口地址
    adminServerUrl: &quot;http://admin.imoocnews.com:8005&quot;,      // 运营管理服务后端接口地址
    articleServerUrl: &quot;http://article.imoocnews.com:8001&quot;,      // 文章服务后端接口地址

    /**
     * 如果本地使用localhost测试可以不使用，如果是ip或者域名测试，cookieDomain改为对应的ip或者域名
     * 例：
     *    ip：  192.168.1.111
     *    域名：   .imooc.com
     */
    cookieDomain: &quot;.imoocnews.com&quot;,  
    ......
&#125;
</code></pre>
<h3 id="数据库选型与数据导入"><a href="#数据库选型与数据导入" class="headerlink" title="数据库选型与数据导入"></a>数据库选型与数据导入</h3><ul>
<li>MySql 5.6&#x2F;5.7</li>
<li><strong>MariaDB</strong></li>
<li>Mysql 8.0</li>
</ul>
<pre><code class="java">表名                             注释
admin_user                      运营管理平台的admin级别用户    
app_user                      网站用户
article                          文章资讯表
category                      新闻资讯文章的分类(或称之为领域)
comments                      评论表
fans                          粉丝表，用户与粉丝的关联关系，粉丝本质也是用户
</code></pre>
<h3 id="构建Maven聚合工程"><a href="#构建Maven聚合工程" class="headerlink" title="构建Maven聚合工程"></a>构建Maven聚合工程</h3><blockquote>
<p>创建一个 imooc-news-dev 的Maven项目作为一个顶级工程项目</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5fa77f452f8588a132ccd5a461663d1f8cc8b353/data/%E6%9E%84%E5%BB%BAmaven%E8%81%9A%E5%90%88%E5%B7%A5%E7%A8%8B.png"></p>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
&lt;!--
    1.聚合工程可以分为顶级项目(顶级工程,父工程) 与子工程(子modele模块)
      这两者的关系其实就是父子继承关系, 子工程在maven中可以称为module,
      模块与模块之间是平级的,是可以相互依赖的
    2.子模块可以使用顶级工程中所有的资源(依赖), 子模块之间如果有要使用资源的话
      必须构建依赖(构建关系)
    3.一个顶级工程是可以由多个不同的子工程共同组合而成
--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt; &lt;!--SpringBoot是和后续的SpringCLoud版本联系的--&gt;
    &lt;/parent&gt;

    &lt;properties&gt; &lt;!--属性文件参数 如果mysql是8以上 需要修改mysql的版本号--&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;

        &lt;mysql-connector-java.version&gt;8.0.33&lt;/mysql-connector-java.version&gt;
        &lt;mybatis-spring-boot-starter.version&gt;2.1.0&lt;/mybatis-spring-boot-starter.version&gt;
        &lt;mapper-spring-boot-starter.version&gt;2.1.5&lt;/mapper-spring-boot-starter.version&gt;
        &lt;pagehelper-spring-boot-starter.version&gt;1.2.12&lt;/pagehelper-spring-boot-starter.version&gt;

        &lt;okhttp.version&gt;4.2.2&lt;/okhttp.version&gt;
        &lt;jackson.version&gt;2.10.2&lt;/jackson.version&gt;

        &lt;commons-codec.version&gt;1.11&lt;/commons-codec.version&gt;
        &lt;commons-lang3.version&gt;3.4&lt;/commons-lang3.version&gt;
        &lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;
        &lt;google-guava.version&gt;28.2-jre&lt;/google-guava.version&gt;

        &lt;springfox-swagger2.version&gt;2.4.0&lt;/springfox-swagger2.version&gt;
        &lt;swagger-bootstrap-ui.version&gt;1.6&lt;/swagger-bootstrap-ui.version&gt;
        &lt;fastdfs.version&gt;1.27.2&lt;/fastdfs.version&gt;

        &lt;slf4j.version&gt;1.7.21&lt;/slf4j.version&gt;
        &lt;joda-time.version&gt;2.10.6&lt;/joda-time.version&gt;
    &lt;/properties&gt;

    &lt;!--
        使用dependencyManagement的目的是为了保证父工程的干净，
        也就是说父工程他只负责管理依赖，以及依赖的版本，而不会导入额外的jar依赖。
        如此一来父工程的职责就很单一了，而且也符合了面向对象开发的父子继承关系，
        依赖的导入只有在各自的子工程中才会进行导入。
    --&gt;
&lt;!--  ↓ 管理依赖 不会从外网下载具体jar包 只有在后续子模块配置的时候才会去配置
      为了保证父工程的干净,父工程中只负责管理依赖,以及依赖的版本,而不会导入额外的jar依赖
      如此一来父工程的职责就很单一了,而且也符合了面向对象开发的父子继承关系
      依赖的导入只有在各自的子工程中才会导入
 --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- SpringCloud 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR3&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- 引入 mongodb 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
                &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
                &lt;!--mongodb-driver.version--&gt;
                &lt;version&gt;3.11.1&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mysql 驱动  这样引用方便以后jar包依赖的升级--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mybatis --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mybatis-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- 通用mapper逆向工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mapper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--pagehelper --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
                &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;pagehelper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--服务和服务之间的请求--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
                &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
                &lt;version&gt;$&#123;okhttp.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- jackson --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- apache 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-codec&lt;/groupId&gt;
                &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
                &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- google 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
                &lt;artifactId&gt;guava&lt;/artifactId&gt;
                &lt;version&gt;$&#123;google-guava.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- swagger2 配置 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
                &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;swagger-bootstrap-ui.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- 文件上传fdfs工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
                &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
                &lt;version&gt;$&#123;fastdfs.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- joda-time 时间工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;joda-time&lt;/groupId&gt;
                &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
                &lt;version&gt;$&#123;joda-time.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;!-- Java 编译 --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-common"><a href="#imooc-news-dev-common" class="headerlink" title="imooc-news-dev-common"></a>imooc-news-dev-common</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-common:
    通用工程
    包含了一些工具类,枚举类,封装的一些公共方法以及一些第三方组件等
--&gt;
    &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-model"><a href="#imooc-news-dev-model" class="headerlink" title="imooc-news-dev-model"></a>imooc-news-dev-model</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-model
    模型工程, 所有的子工程以及微服务中所涉及到的模型实体类都在此管理
    可以包含一些 *pojo,*Bean,*Entity,vo,bo,dto等
--&gt;

    &lt;artifactId&gt;imooc-news-dev-model&lt;/artifactId&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
&lt;!--  子工程依赖common --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-service-api"><a href="#imooc-news-dev-service-api" class="headerlink" title="imooc-news-dev-service-api"></a>imooc-news-dev-service-api</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;!--    imooc-news-dev-service-api
            接口工程,集中管理所有的controller中的接口,为了更好的统一管理微服务
    --&gt;
    &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-service-user"><a href="#imooc-news-dev-service-user" class="headerlink" title="imooc-news-dev-service-user"></a>imooc-news-dev-service-user</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-user&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--    引入SpringBoot依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-父"><a href="#imooc-news-dev-父" class="headerlink" title="imooc-news-dev [父]"></a>imooc-news-dev [父]</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;modules&gt;
    &lt;!-- 这里是子模块[自动创建] 如果物理删除了子工程 这个不会自动删除的要手动删除--&gt;
        &lt;module&gt;imooc-news-dev-common&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-model&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-service-api&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-service-user&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-service-user&lt;/module&gt;
    &lt;/modules&gt;
    &lt;!--
        1.聚合工程可以分为顶级项目(顶级工程,父工程) 与子工程(子modele模块)
          这两者的关系其实就是父子继承关系, 子工程在maven中可以称为module,
          模块与模块之间是平级的,是可以相互依赖的
        2.子模块可以使用顶级工程中所有的资源(依赖), 子模块之间如果有要使用资源的话
          必须构建依赖(构建关系)
        3.一个顶级工程是可以由多个不同的子工程共同组合而成
    --&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt; &lt;!--SpringBoot是和后续的SpringCLoud版本联系的--&gt;
    &lt;/parent&gt;

    &lt;properties&gt; &lt;!--属性文件参数 如果mysql是8以上 需要修改mysql的版本号--&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;

        &lt;mysql-connector-java.version&gt;8.0.33&lt;/mysql-connector-java.version&gt;
        &lt;mybatis-spring-boot-starter.version&gt;2.1.0&lt;/mybatis-spring-boot-starter.version&gt;
        &lt;mapper-spring-boot-starter.version&gt;2.1.5&lt;/mapper-spring-boot-starter.version&gt;
        &lt;pagehelper-spring-boot-starter.version&gt;1.2.12&lt;/pagehelper-spring-boot-starter.version&gt;

        &lt;okhttp.version&gt;4.2.2&lt;/okhttp.version&gt;
        &lt;jackson.version&gt;2.10.2&lt;/jackson.version&gt;

        &lt;commons-codec.version&gt;1.11&lt;/commons-codec.version&gt;
        &lt;commons-lang3.version&gt;3.4&lt;/commons-lang3.version&gt;
        &lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;
        &lt;google-guava.version&gt;28.2-jre&lt;/google-guava.version&gt;

        &lt;springfox-swagger2.version&gt;2.4.0&lt;/springfox-swagger2.version&gt;
        &lt;swagger-bootstrap-ui.version&gt;1.6&lt;/swagger-bootstrap-ui.version&gt;
        &lt;fastdfs.version&gt;1.27.2&lt;/fastdfs.version&gt;

        &lt;slf4j.version&gt;1.7.21&lt;/slf4j.version&gt;
        &lt;joda-time.version&gt;2.10.6&lt;/joda-time.version&gt;
    &lt;/properties&gt;

    &lt;!--
        使用dependencyManagement的目的是为了保证父工程的干净，
        也就是说父工程他只负责管理依赖，以及依赖的版本，而不会导入额外的jar依赖。
        如此一来父工程的职责就很单一了，而且也符合了面向对象开发的父子继承关系，
        依赖的导入只有在各自的子工程中才会进行导入。
    --&gt;
&lt;!--  ↓ 管理依赖 不会从外网下载具体jar包 只有在后续子模块配置的时候才会去配置
      为了保证父工程的干净,夫工程中只负责管理依赖,以及依赖的版本,而不会导入额外的jar依赖
      如此一来父工程的职责就很单一了,而且也符合了面向对象开发的父子继承关系
      依赖的导入只有在各自的子工程中才会导入
 --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- SpringCloud 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR3&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- 引入 mongodb 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
                &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
                &lt;!--mongodb-driver.version--&gt;
                &lt;version&gt;3.11.1&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- mysql 驱动  这样引用方便以后jar包依赖的升级--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mybatis --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mybatis-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- 通用mapper逆向工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mapper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--pagehelper --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
                &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;pagehelper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--服务和服务之间的请求--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
                &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
                &lt;version&gt;$&#123;okhttp.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- jackson --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- apache 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-codec&lt;/groupId&gt;
                &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
                &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- google 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
                &lt;artifactId&gt;guava&lt;/artifactId&gt;
                &lt;version&gt;$&#123;google-guava.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- swagger2 配置 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
                &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;swagger-bootstrap-ui.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- 文件上传fdfs工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
                &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
                &lt;version&gt;$&#123;fastdfs.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- joda-time 时间工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;joda-time&lt;/groupId&gt;
                &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
                &lt;version&gt;$&#123;joda-time.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;!-- Java 编译 --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;
    @GetMapping(&quot;/hello&quot;)
    public Object hello()&#123;
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
  port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: service-user
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
</code></pre>
<pre><code class="java">SwitchHosts【一定要先关闭代理 因为它会固定静态ip】
127.0.0.1 user.imoocnews.com

http://user.imoocnews.com:8003/hello
</code></pre>
<h3 id="api接口暴露"><a href="#api接口暴露" class="headerlink" title="api接口暴露"></a>api接口暴露</h3><h6 id="所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内"><a href="#所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内" class="headerlink" title="所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内"></a>所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内</h6><pre><code class="xml">把imooc-news-dev-service-user中的pom.xml中的关于SpringBoot的依赖
全部放入imooc-news-dev-service-api中
并且在imooc-news-dev-service-user中写入引用依赖
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">【服务层依赖api层】
更改把user项目的HelloController 复制到dev-service-api 创建一个接口

...api
com/imooc/api/controller/user/HelloControllerApi.java
package com.imooc.api.controller.user;
import org.springframework.web.bind.annotation.GetMapping;

public interface HelloControllerApi &#123;
    /**
     * api的作用：
     * api就相当于企业的领导,老板,部门经理
     * 其他的服务层都是实现,他们就相当于员工,只做事情
     * 老板(开发人员)来看一下每个人(服务)的进度,做什么事
     * 老板不会去问员工,他只会对接部门经理
     * 这里所有的api接口就是统一在这里管理和调度的,微服务也如此
     */

    /**
     * 运作：
     * 现在的所有接口都在此暴露,实现都是在各自的微服务中
     * 本项目只写项目,不写实现,实现在各自的微服务工程中,因为以业务来划分的微服务有很多
     * Controller也会分散在各个微服务工程中,一旦多了就很难统一管理和查看
     *
     * 其次,微服务之间的调用都是基于接口的
     * 如果不这样做,微服务之间的调用就需要互相依赖了
     * 耦合对也就很高,接口的目的是为了能够提供解耦
     *
     * 此外,本项目的接口其实就是一套规范.实现都是由各自的工程去做的处理
     * 目前我们使用springboot作为接口的实现的
     * 如果未来以后出现新的java web框架,那么我们不需要修改接口
     * 只需要去修改对应的实现就可以了,这其实也是解耦的一个体现
     *
     * Swagger2, 基于接口的自动文档生成
     * 所有的配置文件只需要一份,就能再当前项目中去构建了
     * 管理起来很方便
     * 
     * 综上所述,这样做法可以提高多服务的项目可扩展性
     */
    @GetMapping(&quot;/hello&quot;)
    public Object hello();
&#125;


...user
com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    public Object hello()&#123;
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="配置logback日志与多环境profile"><a href="#配置logback日志与多环境profile" class="headerlink" title="配置logback日志与多环境profile"></a>配置logback日志与多环境profile</h3><h6 id="imooc-news-dev-service-user-1"><a href="#imooc-news-dev-service-user-1" class="headerlink" title="imooc-news-dev-service-user"></a>imooc-news-dev-service-user</h6><blockquote>
<p>先添加一个logback-spring.xml</p>
</blockquote>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-admin&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-dev&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/service-user.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        logger.debug(&quot;debug: hello~&quot;);
        logger.info(&quot;info: hello~&quot;);
        logger.warn(&quot;warn: hello~&quot;);
        logger.error(&quot;error: hello~&quot;);

        return &quot;hello&quot;;
    &#125;
&#125;
//重新启动后去页面刷新一下
......
29:22.373 [main] INFO  com.imooc.user.Application - Started Application in 1.061 seconds (JVM running for 1.543)
29:40.693 [http-nio-8003-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
29:40.694 [http-nio-8003-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet &#39;dispatcherServlet&#39;
29:40.696 [http-nio-8003-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 2 ms
29:40.707 [http-nio-8003-exec-1] INFO  c.i.user.controller.HelloController - info: hello~
29:40.707 [http-nio-8003-exec-1] WARN  c.i.user.controller.HelloController - warn: hello~
29:40.707 [http-nio-8003-exec-1] ERROR c.i.user.controller.HelloController - error: hello~
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-user
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
</code></pre>
<pre><code class="java">application-dev.yml
server:
  port: 8003


application-prod.yml
server:
  port: 8130
</code></pre>
<h3 id="优雅的返回封装结果"><a href="#优雅的返回封装结果" class="headerlink" title="优雅的返回封装结果"></a>优雅的返回封装结果</h3><pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.IMOOCJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        logger.debug(&quot;debug: hello~&quot;);
        logger.info(&quot;info: hello~&quot;);
        logger.warn(&quot;warn: hello~&quot;);
        logger.error(&quot;error: hello~&quot;);

//        return &quot;hello&quot;;
//        return IMOOCJSONResult.ok();
//        return IMOOCJSONResult.ok(&quot;hello!&quot;);
        return IMOOCJSONResult.errorMsg(&quot;您的信息有误&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/IMOOCJSONResult.java
package com.imooc.grace.result;

/**
 * 
 * @Title: IMOOCJSONResult.java
 * @Package com.imooc.utils
 * @Description: 自定义响应数据结构
 *                 本类可提供给 H5/ios/安卓/公众号/小程序 使用
 *                 前端接受此类数据（json object)后，可自行根据业务去实现相关功能
 * 
 *                 200：表示成功
 *                 500：表示错误，错误信息在msg字段中
 *                 501：bean验证错误，不管多少个错误都以map形式返回
 *                 502：拦截器拦截到用户token出错
 *                 555：异常抛出信息
 *                 556: 用户qq校验异常
 *                 557: 校验用户是否在CAS登录，用户门票的校验
 * @Copyright: Copyright (c) 2020
 * @Company: www.imooc.com
 * @author 慕课网 - 风间影月
 * @version V1.0
 * 这样太麻烦了 直接用枚举类
 */
public class IMOOCJSONResult &#123;

    // 响应业务状态
    private Integer status;

    // 响应消息
    private String msg;

    // 响应中的数据
    private Object data;
    
    private String ok;    // 不使用

    public static IMOOCJSONResult build(Integer status, String msg, Object data) &#123;
        return new IMOOCJSONResult(status, msg, data);
    &#125;

    public static IMOOCJSONResult build(Integer status, String msg, Object data, String ok) &#123;
        return new IMOOCJSONResult(status, msg, data, ok);
    &#125;
    
    public static IMOOCJSONResult ok(Object data) &#123;
        return new IMOOCJSONResult(data);
    &#125;

    public static IMOOCJSONResult ok() &#123;
        return new IMOOCJSONResult(null);
    &#125;
    
    public static IMOOCJSONResult errorMsg(String msg) &#123;
        return new IMOOCJSONResult(500, msg, null);
    &#125;

    public static IMOOCJSONResult errorUserTicket(String msg) &#123;
        return new IMOOCJSONResult(557, msg, null);
    &#125;
    
    public static IMOOCJSONResult errorMap(Object data) &#123;
        return new IMOOCJSONResult(501, &quot;error&quot;, data);
    &#125;
    
    public static IMOOCJSONResult errorTokenMsg(String msg) &#123;
        return new IMOOCJSONResult(502, msg, null);
    &#125;
    
    public static IMOOCJSONResult errorException(String msg) &#123;
        return new IMOOCJSONResult(555, msg, null);
    &#125;
    
    public static IMOOCJSONResult errorUserQQ(String msg) &#123;
        return new IMOOCJSONResult(556, msg, null);
    &#125;

    public IMOOCJSONResult() &#123;

    &#125;

    public IMOOCJSONResult(Integer status, String msg, Object data) &#123;
        this.status = status;
        this.msg = msg;
        this.data = data;
    &#125;
    
    public IMOOCJSONResult(Integer status, String msg, Object data, String ok) &#123;
        this.status = status;
        this.msg = msg;
        this.data = data;
        this.ok = ok;
    &#125;

    public IMOOCJSONResult(Object data) &#123;
        this.status = 200;
        this.msg = &quot;OK&quot;;
        this.data = data;
    &#125; Getter+Setter
</code></pre>
<h6 id="这样太麻烦而且观察起来不方便-升级一下变成枚举类-更加优雅！"><a href="#这样太麻烦而且观察起来不方便-升级一下变成枚举类-更加优雅！" class="headerlink" title="这样太麻烦而且观察起来不方便 升级一下变成枚举类 更加优雅！"></a>这样太麻烦而且观察起来不方便 升级一下变成枚举类 更加优雅！</h6><pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.IMOOCJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        logger.debug(&quot;debug: hello~&quot;);
        logger.info(&quot;info: hello~&quot;);
        logger.warn(&quot;warn: hello~&quot;);
        logger.error(&quot;error: hello~&quot;);

//        return &quot;hello&quot;;
//        return IMOOCJSONResult.ok();
//        return IMOOCJSONResult.ok(&quot;hello!&quot;);
//        return IMOOCJSONResult.errorMsg(&quot;您的信息有误&quot;);
        return GraceJSONResult.errorCustom(ResponseStatusEnum.NO_AUTH);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/GraceJSONResult.java
package com.imooc.grace.result;

import java.util.Map;

/**
 * 自定义响应数据类型枚举升级版本
 *
 * @Title: IMOOCJSONResult.java
 * @Package com.imooc.utils
 * @Description: 自定义响应数据结构
 *                 本类可提供给 H5/ios/安卓/公众号/小程序 使用
 *                 前端接受此类数据（json object)后，可自行根据业务去实现相关功能
 *
 * @Copyright: Copyright (c) 2020
 * @Company: www.imooc.com
 * @author 慕课网 - 风间影月
 * @version V2.0
 */
public class GraceJSONResult &#123;

    // 响应业务状态码
    private Integer status;

    // 响应消息
    private String msg;

    // 是否成功
    private Boolean success;

    // 响应数据，可以是Object，也可以是List或Map等
    private Object data;

    /**
     * 成功返回，带有数据的，直接往OK方法丢data数据即可
     * @param data
     * @return
     */
    public static GraceJSONResult ok(Object data) &#123;
        return new GraceJSONResult(data);
    &#125;
    /**
     * 成功返回，不带有数据的，直接调用ok方法，data无须传入（其实就是null）
     * @return
     */
    public static GraceJSONResult ok() &#123;
        return new GraceJSONResult(ResponseStatusEnum.SUCCESS);
    &#125;
    public GraceJSONResult(Object data) &#123;
        this.status = ResponseStatusEnum.SUCCESS.status();
        this.msg = ResponseStatusEnum.SUCCESS.msg();
        this.success = ResponseStatusEnum.SUCCESS.success();
        this.data = data;
    &#125;


    /**
     * 错误返回，直接调用error方法即可，当然也可以在ResponseStatusEnum中自定义错误后再返回也都可以
     * @return
     */
    public static GraceJSONResult error() &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED);
    &#125;

    /**
     * 错误返回，map中包含了多条错误信息，可以用于表单验证，把错误统一的全部返回出去
     * @param map
     * @return
     */
    public static GraceJSONResult errorMap(Map map) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, map);
    &#125;

    /**
     * 错误返回，直接返回错误的消息
     * @param msg
     * @return
     */
    public static GraceJSONResult errorMsg(String msg) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, msg);
    &#125;

    /**
     * 错误返回，token异常，一些通用的可以在这里统一定义
     * @return
     */
    public static GraceJSONResult errorTicket() &#123;
        return new GraceJSONResult(ResponseStatusEnum.TICKET_INVALID);
    &#125;

    /**
     * 自定义错误范围，需要传入一个自定义的枚举，可以到[ResponseStatusEnum.java[中自定义后再传入
     * @param responseStatus
     * @return
     */
    public static GraceJSONResult errorCustom(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;
    public static GraceJSONResult exception(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;

    public GraceJSONResult(ResponseStatusEnum responseStatus) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, Object data) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
        this.data = data;
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, String msg) &#123;
        this.status = responseStatus.status();
        this.msg = msg;
        this.success = responseStatus.success();
    &#125;Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/ResponseStatusEnum.java
package com.imooc.grace.result;

/**
 * 响应结果枚举，用于提供给GraceJSONResult返回给前端的
 * 本枚举类中包含了很多的不同的状态码供使用，可以自定义
 * 便于更优雅的对状态码进行管理，一目了然
 */
public enum ResponseStatusEnum &#123;

    SUCCESS(200, true, &quot;操作成功！&quot;),
    FAILED(500, false, &quot;操作失败！&quot;),

    // 50x
    UN_LOGIN(501,false,&quot;请登录后再继续操作！&quot;),
    TICKET_INVALID(502,false,&quot;会话失效，请重新登录！&quot;),
    NO_AUTH(503,false,&quot;您的权限不足，无法继续操作！&quot;),
    MOBILE_ERROR(504,false,&quot;短信发送失败，请稍后重试！&quot;),
    SMS_NEED_WAIT_ERROR(505,false,&quot;短信发送太快啦~请稍后再试！&quot;),
    SMS_CODE_ERROR(506,false,&quot;验证码过期或不匹配，请稍后再试！&quot;),
    USER_FROZEN(507,false,&quot;用户已被冻结，请联系管理员！&quot;),
    USER_UPDATE_ERROR(508,false,&quot;用户信息更新失败，请联系管理员！&quot;),
    USER_INACTIVE_ERROR(509,false,&quot;请前往[账号设置]修改信息激活后再进行后续操作！&quot;),
    FILE_UPLOAD_NULL_ERROR(510,false,&quot;文件不能为空，请选择一个文件再上传！&quot;),
    FILE_UPLOAD_FAILD(511,false,&quot;文件上传失败！&quot;),
    FILE_FORMATTER_FAILD(512,false,&quot;文件图片格式不支持！&quot;),
    FILE_MAX_SIZE_ERROR(513,false,&quot;仅支持500kb大小以下的图片上传！&quot;),
    FILE_NOT_EXIST_ERROR(514,false,&quot;你所查看的文件不存在！&quot;),
    USER_STATUS_ERROR(515,false,&quot;用户状态参数出错！&quot;),
    USER_NOT_EXIST_ERROR(516,false,&quot;用户不存在！&quot;),

    // 自定义系统级别异常 54x
    SYSTEM_INDEX_OUT_OF_BOUNDS(541, false, &quot;系统错误，数组越界！&quot;),
    SYSTEM_ARITHMETIC_BY_ZERO(542, false, &quot;系统错误，无法除零！&quot;),
    SYSTEM_NULL_POINTER(543, false, &quot;系统错误，空指针！&quot;),
    SYSTEM_NUMBER_FORMAT(544, false, &quot;系统错误，数字转换异常！&quot;),
    SYSTEM_PARSE(545, false, &quot;系统错误，解析异常！&quot;),
    SYSTEM_IO(546, false, &quot;系统错误，IO输入输出异常！&quot;),
    SYSTEM_FILE_NOT_FOUND(547, false, &quot;系统错误，文件未找到！&quot;),
    SYSTEM_CLASS_CAST(548, false, &quot;系统错误，类型强制转换错误！&quot;),
    SYSTEM_PARSER_ERROR(549, false, &quot;系统错误，解析出错！&quot;),
    SYSTEM_DATE_PARSER_ERROR(550, false, &quot;系统错误，日期解析出错！&quot;),

    // admin 管理系统 56x
    ADMIN_USERNAME_NULL_ERROR(561, false, &quot;管理员登录名不能为空！&quot;),
    ADMIN_USERNAME_EXIST_ERROR(562, false, &quot;管理员登录名已存在！&quot;),
    ADMIN_NAME_NULL_ERROR(563, false, &quot;管理员负责人不能为空！&quot;),
    ADMIN_PASSWORD_ERROR(564, false, &quot;密码不能为空后者两次输入不一致！&quot;),
    ADMIN_CREATE_ERROR(565, false, &quot;添加管理员失败！&quot;),
    ADMIN_PASSWORD_NULL_ERROR(566, false, &quot;密码不能为空！&quot;),
    ADMIN_NOT_EXIT_ERROR(567, false, &quot;管理员不存在或密码错误！&quot;),
    ADMIN_FACE_NULL_ERROR(568, false, &quot;人脸信息不能为空！&quot;),
    ADMIN_FACE_LOGIN_ERROR(569, false, &quot;人脸识别失败，请重试！&quot;),
    CATEGORY_EXIST_ERROR(570, false, &quot;文章分类已存在，请换一个分类名！&quot;),

    // 媒体中心 相关错误 58x
    ARTICLE_COVER_NOT_EXIST_ERROR(580, false, &quot;文章封面不存在，请选择一个！&quot;),
    ARTICLE_CATEGORY_NOT_EXIST_ERROR(581, false, &quot;请选择正确的文章领域！&quot;),
    ARTICLE_CREATE_ERROR(582, false, &quot;创建文章失败，请重试或联系管理员！&quot;),
    ARTICLE_QUERY_PARAMS_ERROR(583, false, &quot;文章列表查询参数错误！&quot;),
    ARTICLE_DELETE_ERROR(584, false, &quot;文章删除失败！&quot;),
    ARTICLE_WITHDRAW_ERROR(585, false, &quot;文章撤回失败！&quot;),
    ARTICLE_REVIEW_ERROR(585, false, &quot;文章审核出错！&quot;),
    ARTICLE_ALREADY_READ_ERROR(586, false, &quot;文章重复阅读！&quot;),

    // 人脸识别错误代码
    FACE_VERIFY_TYPE_ERROR(600, false, &quot;人脸比对验证类型不正确！&quot;),
    FACE_VERIFY_LOGIN_ERROR(601, false, &quot;人脸登录失败！&quot;),

    // 系统错误，未预期的错误 555
    SYSTEM_ERROR(555, false, &quot;系统繁忙，请稍后再试！&quot;),
    SYSTEM_OPERATION_ERROR(556, false, &quot;操作失败，请重试或联系管理员&quot;),
    SYSTEM_RESPONSE_NO_INFO(557, false, &quot;&quot;);


    // 响应业务状态
    private Integer status;
    // 调用是否成功
    private Boolean success;
    // 响应消息，可以为成功或者失败的消息
    private String msg;

    ResponseStatusEnum(Integer status, Boolean success, String msg) &#123;
        this.status = status;
        this.success = success;
        this.msg = msg;
    &#125;

    public Integer status() &#123;
        return status;
    &#125;
    public Boolean success() &#123;
        return success;
    &#125;
    public String msg() &#123;
        return msg;
    &#125;
&#125;
</code></pre>
<pre><code class="java">&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: null
&#125;
</code></pre>
<h3 id="配置数据库逆向生成实体类"><a href="#配置数据库逆向生成实体类" class="headerlink" title="配置数据库逆向生成实体类"></a>配置数据库逆向生成实体类</h3><h6 id="引入mybatis-generator-database-新建工程项目"><a href="#引入mybatis-generator-database-新建工程项目" class="headerlink" title="引入mybatis-generator-database[新建工程项目]"></a>引入mybatis-generator-database[新建工程项目]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-generator-database&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;


    &lt;dependencies&gt;

        &lt;!-- 引入log4j日志依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;
            &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 阿里开源数据源 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.41&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mapper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--pagehelper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- mybatis 逆向生成工具  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoheihai666/article/details/125936493">dependencymanagement 无法引入包依赖-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/stKAnic/article/details/121380871?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-121380871-blog-121295199.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-121380871-blog-121295199.235%5Ev43%5Epc_blog_bottom_relevance_base6">关于Maven依赖dependency无法引入的问题_<dependencymanagement> 无法引入包-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46411355/article/details/131312807">Maven配置仓库、阿里云镜像、环境变量（史上最全最详细）_maven配置阿里云镜像-CSDN博客</a></p>
<pre><code class="java">将mybatis-generator-database中的pojo[AppUser+Fans]复制转移到imooc-news-dev-model com/imooc/pojo中
将mybatis-generator-database中的com/imooc/user/mapper[AppUserMapper、FansMapper]复制转移到imooc-news-service-user com/imooc/user/mapper中
所有的服务都是要实现API的
将mybatis-generator-database中的com/imooc/my/mapper[MyMapper]复制转移到imooc-news-dev-service-api com/imooc/my/mapper中
将..database中的resources的mapper[AppUserMapper.xml、FansMapper.xml]转移到...service-user的resources的mapper中
</code></pre>
<pre><code class="yaml">imooc-news-dev-service-user中的resources的application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-user
  datasource: # 数据源的相关配置
    type: com.zaxxer.hikari.HikariDataSource          # 数据源类型：HikariCP
    driver-class-name: com.mysql.jdbc.Driver          # mysql驱动
    url: jdbc:mysql://localhost:3306/imooc-news-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true
    username: root
    password: root
    hikari:
      connection-timeout: 30000       # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 默认:30秒
      minimum-idle: 5                 # 最小连接数
      maximum-pool-size: 20           # 最大连接数
      auto-commit: true               # 自动提交
      idle-timeout: 600000            # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟
      pool-name: DateSourceHikariCP     # 连接池名字
      max-lifetime: 1800000           # 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟 1800000ms
      connection-test-query: SELECT 1
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
############################################################
#
# mybatis 配置
#
############################################################
mybatis:
  type-aliases-package: com.imooc.pojo          # 所有POJO类所在包路径
  mapper-locations: classpath:mapper/*.xml      # mapper映射文件

############################################################
#
# mybatis mapper 配置
#
############################################################
# 通用 Mapper 配置
mapper:
  mappers: com.imooc.my.mapper.MyMapper
  not-empty: false    # 在进行数据库操作的的时候，判断表达式 username != null, 是否追加 username != &#39;&#39;
  identity: MYSQL
# 分页插件配置
pagehelper:
  helperDialect: mysql
  supportMethodsArguments: true
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hkdhkdhkd/article/details/113869035">【解决】SLF4J: Class path contains multiple SLF4J bindings._启动metastore时slf4j: class path contains multiple sl-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huifeidezhuzai/p/16352608.html">整合MongoDB踩坑记录及解决方法 - 会飞的猪仔 - 博客园 (cnblogs.com)</a></p>
<pre><code class="java">com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(&quot;com.imooc&quot;)
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="Swagger2接口文檔工具的使用"><a href="#Swagger2接口文檔工具的使用" class="headerlink" title="Swagger2接口文檔工具的使用"></a>Swagger2接口文檔工具的使用</h3><h6 id="imooc-news-dev-service-api-1"><a href="#imooc-news-dev-service-api-1" class="headerlink" title="imooc-news-dev-service-api"></a>imooc-news-dev-service-api</h6><pre><code class="xml">&lt;!-- swagger2 配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
            &lt;version&gt;$&#123;swagger-bootstrap-ui.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/api/config/Swagger2.java
package com.imooc.api.config;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.RequestHandler;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration //Springboot啓動的時候會被掃描到并且加載
@EnableSwagger2
public class Swagger2 &#123;

    //    http://localhost:8088/swagger-ui.html     原路径
//http://user.imoocnews.com:8003/swagger-ui.htm
    //    http://localhost:8088/doc.html            新路径
//http://user.imoocnews.com:8003/doc.html

    // 配置swagger2核心配置 docket
    @Bean
    public Docket createRestApi() &#123;
        Predicate&lt;RequestHandler&gt; adminPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.admin.controller&quot;);
//        Predicate&lt;RequestHandler&gt; articlePredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.article.controller&quot;);
        Predicate&lt;RequestHandler&gt; userPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.user.controller&quot;);
        Predicate&lt;RequestHandler&gt; filesPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.files.controller&quot;);

        return new Docket(DocumentationType.SWAGGER_2)  // 指定api类型为swagger2
                .apiInfo(apiInfo())                 // 用于定义api文档汇总信息
                .select()
                .apis(Predicates.or(userPredicate, adminPredicate, filesPredicate))
//                .apis(Predicates.or(adminPredicate, articlePredicate, userPredicate, filesPredicate))
                .paths(PathSelectors.any())         // 所有controller
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕课新闻·自媒体接口api&quot;)                       // 文档页标题
                .contact(new Contact(&quot;imooc&quot;,
                        &quot;https://www.imooc.com&quot;,
                        &quot;abc@imooc.com&quot;))                   // 联系人信息
                .description(&quot;专为慕课新闻·自媒体平台提供的api文档&quot;)      // 详细信息
                .version(&quot;1.0.1&quot;)                               // 文档版本号
                .termsOfServiceUrl(&quot;https://www.imooc.com&quot;)     // 网站地址
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/HelloControllerApi.java
package com.imooc.api.controller.user;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;

@Api(value = &quot;controller的標題&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
public interface HelloControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/hello&quot;)
    public Object hello();
&#125;
</code></pre>
<p>[maven-之Lifecycle详解_maven lifecycle-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39505065/article/details/102915403#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86">https://blog.csdn.net/qq_39505065/article/details/102915403#第三部分</a> PS)</p>
<blockquote>
<p>Maven中的Lifecycle的install是什麽 ？<br>将包安装到本地存储库中，作为本地其他项目的依赖项</p>
</blockquote>
<h3 id="梳理短信登錄注冊流程"><a href="#梳理短信登錄注冊流程" class="headerlink" title="梳理短信登錄注冊流程"></a>梳理短信登錄注冊流程</h3><ul>
<li>短信登录注册</li>
<li>短信验证码发送与限制</li>
<li>分布式会话</li>
<li>用户信息完善，OSS&#x2F;FastDFS文件上传</li>
<li>AOP日志监控</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/87e42b65e3e64f84efebcf347d7bd0180b448627/data/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e4dcd13c468e5883cfd3187c6c2800cf2bc4168f/data/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C2.png"></p>
<pre><code class="xml">aliyun.properties
#这里需要去阿里云上购买短信验证 [电脑aliyun_Key.txt有]
aliyun.accessKeyID=
aliyun.accessKeySecret=
</code></pre>
<p><a target="_blank" rel="noopener" href="https://next.api.aliyun.com/api/Dysmsapi/2017-05-25/SendSms?params=%7B%22SignName%22:%22%E5%B0%8F%E6%BD%98%E7%A7%91%E6%8A%80%22,%22TemplateCode%22:%22SMS_467115116%22,%22PhoneNumbers%22:%2215027597319%22,%22TemplateParam%22:%22%7B%22code%22:%221234%22%7D%22%7D">SendSms_短信服务_API调试-阿里云OpenAPI开发者门户 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://next.api.aliyun.com/api-tools/demo/Dysmsapi/db7e1211-14e0-4b7b-9011-037dfb85d42e">短信发送并查询示例_短信服务_示例中心-阿里云OpenAPI开发者门户 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://ram.console.aliyun.com/manage/ak">RAM 访问控制 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://dysms.console.aliyun.com/overview">短信服务 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/i-bp1dssknxftmjczbtpnd/detail?regionId=cn-hangzhou">云服务器管理控制台 (aliyun.com)</a></p>
<pre><code class="xml">【imooc-news-dev-common】
pom.xml
加入springboot依赖包
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-common:
    通用工程
    包含了一些工具类,枚举类,封装的一些公共方法以及一些第三方组件等
--&gt;
    &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--    引入SpringBoot依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--  第三方云厂商相关依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/utils/extend/AliyunResource.java
package com.imooc.utils.extend;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(&quot;classpath:aliyun.properties&quot;)
@ConfigurationProperties(prefix = &quot;aliyun&quot;) //这里是前缀
public class AliyunResource &#123;
    private String accessKeyID;
    private String accessKeySecret;

    public String getAccessKeyID() &#123;
        return accessKeyID;
    &#125;

    public void setAccessKeyID(String accessKeyID) &#123;
        this.accessKeyID = accessKeyID;
    &#125;

    public String getAccessKeySecret() &#123;
        return accessKeySecret;
    &#125;

    public void setAccessKeySecret(String accessKeySecret) &#123;
        this.accessKeySecret = accessKeySecret;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/utils/SMSUtils.java
package com.imooc.utils;

import com.aliyuncs.CommonRequest;
import com.aliyuncs.CommonResponse;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.exceptions.ServerException;
import com.aliyuncs.http.MethodType;
import com.aliyuncs.profile.DefaultProfile;
import com.imooc.utils.extend.AliyunResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component //工具类 可以作为组件
public class SMSUtils &#123;
    @Autowired
    public AliyunResource aliyunResource;
    final static Logger logger = LoggerFactory.getLogger(SMSUtils.class);
    public void sendSMS(String mobile, String code) &#123;
        DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;,
                aliyunResource.getAccessKeyID(),
                aliyunResource.getAccessKeySecret());
        IAcsClient client = new DefaultAcsClient(profile);

        CommonRequest request = new CommonRequest();
        request.setSysMethod(MethodType.POST);
        request.setSysDomain(&quot;dysmsapi.aliyuncs.com&quot;);
        request.setSysVersion(&quot;2017-05-25&quot;);
        request.setSysAction(&quot;SendSms&quot;);
        request.putQueryParameter(&quot;RegionId&quot;, &quot;cn-hangzhou&quot;);
        //给对方发送的手机号
        request.putQueryParameter(&quot;PhoneNumbers&quot;, mobile);
        request.putQueryParameter(&quot;SignName&quot;, &quot;小潘科技&quot;);//控制台可以添加签名
        request.putQueryParameter(&quot;TemplateCode&quot;, &quot;SMS_467115116&quot;);
        request.putQueryParameter(&quot;TemplateParam&quot;, &quot;&#123;\&quot;code\&quot;:\&quot;&quot; + code + &quot;\&quot;&#125;&quot;);//JSON对象字符串
        try &#123;
            CommonResponse response = client.getCommonResponse(request);
            System.out.println(response.getData());
            // 打印阿里云API的响应结果
            logger.info(&quot;Aliyun SMS API response: &quot; + response.getData());
        &#125; catch (ServerException e) &#123;
            e.printStackTrace();
            logger.error(&quot;ServerException: &quot; + e.getMessage());
        &#125; catch (ClientException e) &#123;
            e.printStackTrace();
            logger.error(&quot;ClientException: &quot; + e.getMessage());
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/PassportControllerApi.java[接口]
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode();
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.SMSUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode()&#123;
        // 生成6位随机验证码
        String random = String.valueOf((int)((Math.random() * 9 + 1) * 100000));
        // 打印生成的验证码以便调试
        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
        logger.info(&quot;SMS sent to 15027597000 with code: &quot; + random);

        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/GraceJSONResult.java
package com.imooc.grace.result;

import java.util.Map;

/**
 * 自定义响应数据类型枚举升级版本
 *
 * @Title: IMOOCJSONResult.java
 * @Package com.imooc.utils
 * @Description: 自定义响应数据结构
 *                 本类可提供给 H5/ios/安卓/公众号/小程序 使用
 *                 前端接受此类数据（json object)后，可自行根据业务去实现相关功能
 *
 * @Copyright: Copyright (c) 2020
 * @Company: www.imooc.com
 * @author 慕课网 - 风间影月
 * @version V2.0
 */
public class GraceJSONResult &#123;

    // 响应业务状态码
    private Integer status;

    // 响应消息
    private String msg;

    // 是否成功
    private Boolean success;

    // 响应数据，可以是Object，也可以是List或Map等
    private Object data;

    /**
     * 成功返回，带有数据的，直接往OK方法丢data数据即可
     * @param data
     * @return
     */
    public static GraceJSONResult ok(Object data) &#123;
        return new GraceJSONResult(data);
    &#125;
    /**
     * 成功返回，不带有数据的，直接调用ok方法，data无须传入（其实就是null）
     * @return
     */
    public static GraceJSONResult ok() &#123;
        return new GraceJSONResult(ResponseStatusEnum.SUCCESS);
    &#125;
    public GraceJSONResult(Object data) &#123;
        this.status = ResponseStatusEnum.SUCCESS.status();
        this.msg = ResponseStatusEnum.SUCCESS.msg();
        this.success = ResponseStatusEnum.SUCCESS.success();
        this.data = data;
    &#125;


    /**
     * 错误返回，直接调用error方法即可，当然也可以在ResponseStatusEnum中自定义错误后再返回也都可以
     * @return
     */
    public static GraceJSONResult error() &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED);
    &#125;

    /**
     * 错误返回，map中包含了多条错误信息，可以用于表单验证，把错误统一的全部返回出去
     * @param map
     * @return
     */
    public static GraceJSONResult errorMap(Map map) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, map);
    &#125;

    /**
     * 错误返回，直接返回错误的消息
     * @param msg
     * @return
     */
    public static GraceJSONResult errorMsg(String msg) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, msg);
    &#125;

    /**
     * 错误返回，token异常，一些通用的可以在这里统一定义
     * @return
     */
    public static GraceJSONResult errorTicket() &#123;
        return new GraceJSONResult(ResponseStatusEnum.TICKET_INVALID);
    &#125;

    /**
     * 自定义错误范围，需要传入一个自定义的枚举，可以到[ResponseStatusEnum.java[中自定义后再传入
     * @param responseStatus
     * @return
     */
    public static GraceJSONResult errorCustom(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;
    public static GraceJSONResult exception(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;

    public GraceJSONResult(ResponseStatusEnum responseStatus) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, Object data) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
        this.data = data;
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, String msg) &#123;
        this.status = responseStatus.status();
        this.msg = msg;
        this.success = responseStatus.success();
    &#125;

    public GraceJSONResult() &#123;
    &#125;

    public Integer getStatus() &#123;
        return status;
    &#125;

    public void setStatus(Integer status) &#123;
        this.status = status;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;

    public Object getData() &#123;
        return data;
    &#125;

    public void setData(Object data) &#123;
        this.data = data;
    &#125;

    public Boolean getSuccess() &#123;
        return success;
    &#125;

    public void setSuccess(Boolean success) &#123;
        this.success = success;
    &#125;
&#125;
</code></pre>
<h3 id="安装配置整合Redis"><a href="#安装配置整合Redis" class="headerlink" title="安装配置整合Redis"></a>安装配置整合Redis</h3><pre><code class="mysql">通过Xftp7把redis-5.0.7.tar.gz传入到服务器
[root@iZbp1dssknxftmjczbtpndZ ~]# tar -zxvf redis-5.0.7.tar.gz 
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
apache-zookeeper-3.6.0-bin         rabbitmq-server-3.8.2-1.el7.noarch.rpm
apache-zookeeper-3.6.0-bin.tar.gz  redis-5.0.7
erlang-22.3-1.el7.x86_64.rpm       redis-5.0.7.tar.gz
[root@iZbp1dssknxftmjczbtpndZ ~]# cd redis-5.0.7
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# ll
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# yum install gcc-c++
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# make
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# cd /usr/local/ ★
[root@iZbp1dssknxftmjczbtpndZ local]# ll
[root@iZbp1dssknxftmjczbtpndZ local]# pwd
/usr/local
[root@iZbp1dssknxftmjczbtpndZ local]# cd redis/ ★
[root@iZbp1dssknxftmjczbtpndZ redis]# ll
total 4
drwxr-xr-x 2 root root 4096 May 15 11:19 bin
[root@iZbp1dssknxftmjczbtpndZ redis]# cd bin ★
[root@iZbp1dssknxftmjczbtpndZ bin]# ll
total 32772
-rwxr-xr-x 1 root root 4366880 May 15 11:04 redis-benchmark
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-aof
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-rdb
-rwxr-xr-x 1 root root 4807952 May 15 11:04 redis-cli
-rw-r--r-- 1 root root       0 May 15 11:19 redis.conf
lrwxrwxrwx 1 root root      12 May 15 11:04 redis-sentinel -&gt; redis-server
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-server
[root@iZbp1dssknxftmjczbtpndZ redis]# cd
[root@iZbp1dssknxftmjczbtpndZ ~]# cd redis-5.0.7
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# ls
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# cp redis.conf /usr/local/redis/bin/
cp: overwrite ‘/usr/local/redis/bin/redis.conf’? y
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# cd /usr/local/redis/bin/
[root@iZbp1dssknxftmjczbtpndZ bin]# ll
total 32836
-rwxr-xr-x 1 root root 4366880 May 15 11:04 redis-benchmark
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-aof
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-rdb
-rwxr-xr-x 1 root root 4807952 May 15 11:04 redis-cli
-rw-r--r-- 1 root root   61797 May 15 11:28 redis.conf
lrwxrwxrwx 1 root root      12 May 15 11:04 redis-sentinel -&gt; redis-server
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-server
[root@iZbp1dssknxftmjczbtpndZ bin]# vim redis.conf
在里面 /bind 直接搜索
把bind 127.0.0.1修改成 0.0.0.0在任何地方都可以进行操作修改
在里面 /dae
把daemonize no 改成 daemonize yes[后台启动]
在里面 /require
把requirepass foobared 这里是设置密码 requirepass XXXX
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-server redis.conf ★
32421:C 15 May 2024 11:35:36.687 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
32421:C 15 May 2024 11:35:36.687 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=32421, just started
32421:C 15 May 2024 11:35:36.687 # Configuration loaded
[root@iZbp1dssknxftmjczbtpndZ bin]# ps -ef|grep redis
root     32422     1  0 11:35 ?        00:00:00 ./redis-server 0.0.0.0:6379
root     32456 25226  0 11:35 pts/0    00:00:00 grep --color=auto redis
【此时说明已经成功启动Redis】
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-cli ★
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; keys *
(empty list or set)
127.0.0.1:6379&gt; set name imooc
OK
127.0.0.1:6379&gt; get name
&quot;imooc&quot;
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-cli -p 6379 shutdown

★直接进入redis文件内★
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/local/redis/bin       //进入文件内
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-server redis.conf   //启动
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-cli                 //测试
★★
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hu4545/article/details/126174419">Linux下Redis服务启动与关闭_linux 关闭redis-CSDN博客</a></p>
<h3 id="安装配置整合Redis-2"><a href="#安装配置整合Redis-2" class="headerlink" title="安装配置整合Redis-2"></a>安装配置整合Redis-2</h3><blockquote>
<p>下载并安装好 Redis Desktop Manager<br>新连接设置<br>名字：redis-imooc-news 47.98.225.105<br>地址：47.98.225.105：6379</p>
</blockquote>
<pre><code class="xml">加一下redis的依赖
imooc-news-dev-common
pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-common:
    通用工程
    包含了一些工具类,枚举类,封装的一些公共方法以及一些第三方组件等
--&gt;
    &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--    引入SpringBoot依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 引入 redis 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
            &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- jackson --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- apache 工具类 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-codec&lt;/groupId&gt;
            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- google 工具类 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
            &lt;artifactId&gt;guava&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- joda-time 时间工具 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;joda-time&lt;/groupId&gt;
            &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--  第三方云厂商相关依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/utils/RedisOperator.java
package com.imooc.utils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.connection.StringRedisConnection;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * @Title: Redis 工具类
 * @author 风间影月
 */
@Component
public class RedisOperator &#123;
    
    @Resource
    private StringRedisTemplate redisTemplate;

    // Key（键），简单的key-value操作

    /**
     * 判断key是否存在
     * @param key
     * @return
     */
    public boolean keyIsExist(String key) &#123;
        return redisTemplate.hasKey(key);
    &#125;

    /**
     * 实现命令：TTL key，以秒为单位，返回给定 key的剩余生存时间(TTL, time to live)。
     * 
     * @param key
     * @return
     */
    public long ttl(String key) &#123;
        return redisTemplate.getExpire(key);
    &#125;
    
    /**
     * 实现命令：expire 设置过期时间，单位秒
     * 
     * @param key
     * @return
     */
    public void expire(String key, long timeout) &#123;
        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);
    &#125;
    
    /**
     * 实现命令：increment key，增加key一次
     * 
     * @param key
     * @return
     */
    public long increment(String key, long delta) &#123;
        return redisTemplate.opsForValue().increment(key, delta);
    &#125;

    /**
     * 实现命令：decrement key，减少key一次
     *
     * @param key
     * @return
     */
    public long decrement(String key, long delta) &#123;
        return redisTemplate.opsForValue().decrement(key, delta);
    &#125;

    /**
     * 实现命令：KEYS pattern，查找所有符合给定模式 pattern的 key
     */
    public Set&lt;String&gt; keys(String pattern) &#123;
        return redisTemplate.keys(pattern);
    &#125;

    /**
     * 实现命令：DEL key，删除一个key
     * 
     * @param key
     */
    public void del(String key) &#123;
        redisTemplate.delete(key);
    &#125;

    // String（字符串）

    /**
     * 实现命令：SET key value，设置一个key-value（将字符串值 value关联到 key）
     * 
     * @param key
     * @param value
     */
    public void set(String key, String value) &#123;
        redisTemplate.opsForValue().set(key, value);
    &#125;

    /**
     * 实现命令：SET key value EX seconds，设置key-value和超时时间（秒）
     * 
     * @param key
     * @param value
     * @param timeout
     *            （以秒为单位）
     */
    public void set(String key, String value, long timeout) &#123;
        redisTemplate.opsForValue().set(key, value, timeout, TimeUnit.SECONDS);
    &#125;

    /**
     * 如果key不存在，则设置，如果存在，则报错
     * @param key
     * @param value
     */
    public void setnx60s(String key, String value) &#123;
        redisTemplate.opsForValue().setIfAbsent(key, value, 60, TimeUnit.SECONDS);
    &#125;

    /**
     * 如果key不存在，则设置，如果存在，则报错
     * @param key
     * @param value
     */
    public void setnx(String key, String value) &#123;
        redisTemplate.opsForValue().setIfAbsent(key, value);
    &#125;

    /**
     * 实现命令：GET key，返回 key所关联的字符串值。
     * 
     * @param key
     * @return value
     */
    public String get(String key) &#123;
        return (String)redisTemplate.opsForValue().get(key);
    &#125;

    /**
     * 批量查询，对应mget
     * @param keys
     * @return
     */
    public List&lt;String&gt; mget(List&lt;String&gt; keys) &#123;
        return redisTemplate.opsForValue().multiGet(keys);
    &#125;

    /**
     * 批量查询，管道pipeline
     * @param keys
     * @return
     */
    public List&lt;Object&gt; batchGet(List&lt;String&gt; keys) &#123;

//        nginx -&gt; keepalive
//        redis -&gt; pipeline

        List&lt;Object&gt; result = redisTemplate.executePipelined(new RedisCallback&lt;String&gt;() &#123;
            @Override
            public String doInRedis(RedisConnection connection) throws DataAccessException &#123;
                StringRedisConnection src = (StringRedisConnection)connection;

                for (String k : keys) &#123;
                    src.get(k);
                &#125;
                return null;
            &#125;
        &#125;);

        return result;
    &#125;


    // Hash（哈希表）

    /**
     * 实现命令：HSET key field value，将哈希表 key中的域 field的值设为 value
     * 
     * @param key
     * @param field
     * @param value
     */
    public void hset(String key, String field, Object value) &#123;
        redisTemplate.opsForHash().put(key, field, value);
    &#125;

    /**
     * 实现命令：HGET key field，返回哈希表 key中给定域 field的值
     * 
     * @param key
     * @param field
     * @return
     */
    public String hget(String key, String field) &#123;
        return (String) redisTemplate.opsForHash().get(key, field);
    &#125;

    /**
     * 实现命令：HDEL key field [field ...]，删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。
     * 
     * @param key
     * @param fields
     */
    public void hdel(String key, Object... fields) &#123;
        redisTemplate.opsForHash().delete(key, fields);
    &#125;

    /**
     * 实现命令：HGETALL key，返回哈希表 key中，所有的域和值。
     * 
     * @param key
     * @return
     */
    public Map&lt;Object, Object&gt; hgetall(String key) &#123;
        return redisTemplate.opsForHash().entries(key);
    &#125;

    // List（列表）

    /**
     * 实现命令：LPUSH key value，将一个值 value插入到列表 key的表头
     * 
     * @param key
     * @param value
     * @return 执行 LPUSH命令后，列表的长度。
     */
    public long lpush(String key, String value) &#123;
        return redisTemplate.opsForList().leftPush(key, value);
    &#125;

    /**
     * 实现命令：LPOP key，移除并返回列表 key的头元素。
     * 
     * @param key
     * @return 列表key的头元素。
     */
    public String lpop(String key) &#123;
        return (String)redisTemplate.opsForList().leftPop(key);
    &#125;

    /**
     * 实现命令：RPUSH key value，将一个值 value插入到列表 key的表尾(最右边)。
     * 
     * @param key
     * @param value
     * @return 执行 LPUSH命令后，列表的长度。
     */
    public long rpush(String key, String value) &#123;
        return redisTemplate.opsForList().rightPush(key, value);
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337066868">Spring Boot集成Redis的坑，踩了！ - 知乎 (zhihu.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45590494/article/details/114444371">@Autowired和@Resource注解的区别和联系（十分详细，不看后悔）_为什么@resource和@autowired 注入的对象不一样-CSDN博客</a></p>
<blockquote>
<p>妈的有个超级大bug 整我一下午，<br>@Component public class RedisOperator {<br>@Autowired private StringRedisTemplate redisTemplate;}<br> 报错信息 Could not autowire. No beans of ‘StringRedisTemplate’ type found.</p>
<p>在这里不要本末倒置 回归最原始的报错 那就是pom.xml中的导包依赖问题<br>有的时候直接复制的项目中的成熟依赖 根据时代的不同可能会导致丢失无法下载依赖<br>这时要去百度Maven库手动下载 并且手动添加 然后手动导入Project Structure → Libraries 手动导入自己需要的包[记住包的版本 也要在依赖里面体现 &lt; version &gt;]，而且如果有红色波浪线的包可以删除 再重新导入即可</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/arjelarxfc/article/details/78806384">Spring里遇到的一个问题，autowired时报找不到bean定义_autowired找不到bean-CSDN博客</a></p>
<h3 id="完善发送短信接口"><a href="#完善发送短信接口" class="headerlink" title="完善发送短信接口"></a>完善发送短信接口</h3><pre><code class="java">com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;

import javax.servlet.http.HttpServletRequest;

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request);
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.controller.user.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.RedisOperator;
import com.imooc.utils.SMSUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.imooc.utils.IPUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
// 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
//    @Autowired
//    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        String userIp = IPUtil.getRequestIp(request);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
//        redis.setnx60s(&quot;smscode&quot;+ip);
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot;+userIp,userIp);

        //生成随机验证码并且发送短信
        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替

        //把验证码存入redis,用于后续进行验证
        redis.set(MOBILE_SMSCODE+&quot;:&quot;+mobile, random, 30*60);
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/BaseController.java
package com.imooc.api.controller.user;

import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;

public class BaseController &#123;
   @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;

&#125;
</code></pre>
<pre><code class="java">com/imooc/utils/IPUtil.java
package com.imooc.utils;

import javax.servlet.http.HttpServletRequest;

/**
 * 用户获得用户ip的工具类
 */
public class IPUtil &#123;

    /**
     * 获取请求IP:
     * 用户的真实IP不能使用request.getRemoteAddr()
     * 这是因为可能会使用一些代理软件，这样ip获取就不准确了
     * 此外我们如果使用了多级（LVS/Nginx）反向代理的话，ip需要从X-Forwarded-For中获得第一个非unknown的IP才是用户的有效ip。
     * @param request
     * @return
     */
    public static String getRequestIp(HttpServletRequest request) &#123;
        String ip = request.getHeader(&quot;x-forwarded-for&quot;);
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getRemoteAddr();
        &#125;
        return ip;
    &#125;
&#125;
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/sms/getting-started/use-sms-console-1?spm=a2c4g.11186623.0.0.70707f5cATZOcJ">快速使用 在控制台发送短信_短信服务(SMS)-阿里云帮助中心 (aliyun.com)</a></p>
</blockquote>
<h3 id="联调前端发送短信-解决跨域问题"><a href="#联调前端发送短信-解决跨域问题" class="headerlink" title="联调前端发送短信, 解决跨域问题"></a>联调前端发送短信, 解决跨域问题</h3><pre><code class="java">http://writer.imoocnews.com:9090/imooc-news/writer/passport.html
因为后台写死了手机号 所以在输入手机号可以随便 点击发送验证码后 会在浏览器控制台输出跨域问题 在后端要設置允許跨域請求
-----------------------------------------------------------------------------------
passport.html:1  Access to XMLHttpRequest at &#39;http://user.imoocnews.com:8003/passport/getSMSCode?mobile=123334323&#39; from origin &#39;http://writer.imoocnews.com:9090&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.

GET http://user.imoocnews.com:8003/passport/getSMSCode?mobile=123334323 net::ERR_FAILED 200 (OK)
axios.min.js:2  Uncaught (in promise) Error: Network Error
    at e.exports (axios.min.js:2:9633)
    at l.onerror (axios.min.js:2:8398)
</code></pre>
<pre><code class="java">...service-api  com/imooc/api/config/CorsConfig.java
package com.imooc.api.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration //SpringBoot可以加载该信息
public class CorsConfig &#123;

    public CorsConfig() &#123;
    &#125;

    @Bean
    public CorsFilter corsFilter() &#123;
        // 1. 添加cors配置信息
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOrigin(&quot;*&quot;);
        // 设置是否发送cookie信息
        config.setAllowCredentials(true);
        // 设置允许请求的方式
        config.addAllowedMethod(&quot;*&quot;);
        // 设置允许的header
        config.addAllowedHeader(&quot;*&quot;);
        // 2. 为url添加映射路径
        UrlBasedCorsConfigurationSource corsSource = new UrlBasedCorsConfigurationSource();
        corsSource.registerCorsConfiguration(&quot;/**&quot;, config);
        // 3. 返回重新定义好的corsSource
        return new CorsFilter(corsSource);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.SMSUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        //获取用户ip
        String userIp = IPUtil.getRequestIp(request);
        logger.info(&quot;User ip:&quot;, userIp);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot; + userIp, userIp);

        // 生成6位随机验证码
        String random = (int)((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        // 打印生成的验证码以便调试
//        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
//        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
//        logger.info(&quot;SMS sent to 15027597319 with code: &quot; + random);
        redis.set(MOBILE_SMSCODE + &quot;:&quot; + mobile, random, 30 * 60);
   //记得如果要发送到redis中 则需要先用application-dev.yml导入RedisDesktopManager正确的网络地址127.0.0.1 
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);
&#125;
</code></pre>
<h3 id="拦截并限制60秒用户短信发送"><a href="#拦截并限制60秒用户短信发送" class="headerlink" title="拦截并限制60秒用户短信发送"></a>拦截并限制60秒用户短信发送</h3><pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/password/getSMSCode&quot;); //拦截PassportControllerApi里的信息
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/interceptors/PassportInterceptor.java
package com.imooc.api.interceptors;

import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

    public class PassportInterceptor implements HandlerInterceptor &#123;

        @Autowired
        public RedisOperator redis;

        public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;

        /**
         * 拦截请求，访问controller之前
         * @param request
         * @param response
         * @param handler
         * @return
         * @throws Exception
         */
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

            // 获得用户ip
            String userIp = IPUtil.getRequestIp(request);

            boolean keyIsExist = redis.keyIsExist(MOBILE_SMSCODE + &quot;:&quot; + userIp);

            if (keyIsExist) &#123;
                GraceException.display(ResponseStatusEnum.SMS_NEED_WAIT_ERROR);
//            System.out.println(&quot;短信发送频率太大！&quot;);
                return false;
            &#125;

            /**
             * false：请求被拦截
             * true：请求通过验证，放行
             */
            return true;
        &#125;


        /**
         * 请求访问到controller之后，渲染视图之前
         * @param request
         * @param response
         * @param handler
         * @param modelAndView
         * @throws Exception
         */
        @Override
        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

        &#125;

        /**
         * 请求访问到controller之后，渲染视图之后
         * @param request
         * @param response
         * @param handler
         * @param ex
         * @throws Exception
         */
        @Override
        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

        &#125;
    &#125;
</code></pre>
<pre><code class="java">dev-common com/imooc/exception/GraceException.java
package com.imooc.exception;

import com.imooc.grace.result.ResponseStatusEnum;

/**
 * 优雅的处理异常，统一封装
 */
public class GraceException &#123;

    public static void display(ResponseStatusEnum responseStatusEnum) &#123;
        throw new MyCustomException(responseStatusEnum);
    &#125;

&#125;
</code></pre>
<pre><code class="java">com/imooc/exception/MyCustomException.java
package com.imooc.exception;

import com.imooc.grace.result.ResponseStatusEnum;

/**
 * 自定义异常
 * 目的：统一处理异常信息
 *      便于解耦，service与controller错误的解耦，不会被service返回的类型而限制
 */
public class MyCustomException extends RuntimeException &#123;

    private ResponseStatusEnum responseStatusEnum;

    public MyCustomException(ResponseStatusEnum responseStatusEnum) &#123;
        super(&quot;异常状态码为：&quot; + responseStatusEnum.status()
                + &quot;；具体异常信息为：&quot; + responseStatusEnum.msg());
        this.responseStatusEnum = responseStatusEnum;
    &#125;

    public ResponseStatusEnum getResponseStatusEnum() &#123;
        return responseStatusEnum;
    &#125;

    public void setResponseStatusEnum(ResponseStatusEnum responseStatusEnum) &#123;
        this.responseStatusEnum = responseStatusEnum;
    &#125;
&#125;
</code></pre>
<h3 id="自定义异常-返回错误信息"><a href="#自定义异常-返回错误信息" class="headerlink" title="自定义异常, 返回错误信息"></a>自定义异常, 返回错误信息</h3><h6 id="接上方GraceException、MyCustomException、PassportInterceptor"><a href="#接上方GraceException、MyCustomException、PassportInterceptor" class="headerlink" title="[接上方GraceException、MyCustomException、PassportInterceptor]"></a>[接上方GraceException、MyCustomException、PassportInterceptor]</h6><pre><code class="java">dev-common  com/imooc/grace/result/ResponseStatusEnum.java
package com.imooc.grace.result;

/**
 * 响应结果枚举，用于提供给GraceJSONResult返回给前端的
 * 本枚举类中包含了很多的不同的状态码供使用，可以自定义
 * 便于更优雅的对状态码进行管理，一目了然
 */
public enum ResponseStatusEnum &#123;

    SUCCESS(200, true, &quot;操作成功！&quot;),
    FAILED(500, false, &quot;操作失败！&quot;),

    // 50x
    UN_LOGIN(501,false,&quot;请登录后再继续操作！&quot;),
    TICKET_INVALID(502,false,&quot;会话失效，请重新登录！&quot;),
    NO_AUTH(503,false,&quot;您的权限不足，无法继续操作！&quot;),
    MOBILE_ERROR(504,false,&quot;短信发送失败，请稍后重试！&quot;),
    SMS_NEED_WAIT_ERROR(505,false,&quot;短信发送太快啦~请稍后再试！&quot;),
    SMS_CODE_ERROR(506,false,&quot;验证码过期或不匹配，请稍后再试！&quot;),
    USER_FROZEN(507,false,&quot;用户已被冻结，请联系管理员！&quot;),
    USER_UPDATE_ERROR(508,false,&quot;用户信息更新失败，请联系管理员！&quot;),
    USER_INACTIVE_ERROR(509,false,&quot;请前往[账号设置]修改信息激活后再进行后续操作！&quot;),
    FILE_UPLOAD_NULL_ERROR(510,false,&quot;文件不能为空，请选择一个文件再上传！&quot;),
    FILE_UPLOAD_FAILD(511,false,&quot;文件上传失败！&quot;),
    FILE_FORMATTER_FAILD(512,false,&quot;文件图片格式不支持！&quot;),
    FILE_MAX_SIZE_ERROR(513,false,&quot;仅支持500kb大小以下的图片上传！&quot;),
    FILE_NOT_EXIST_ERROR(514,false,&quot;你所查看的文件不存在！&quot;),
    USER_STATUS_ERROR(515,false,&quot;用户状态参数出错！&quot;),
    USER_NOT_EXIST_ERROR(516,false,&quot;用户不存在！&quot;),

    // 自定义系统级别异常 54x
    SYSTEM_INDEX_OUT_OF_BOUNDS(541, false, &quot;系统错误，数组越界！&quot;),
    SYSTEM_ARITHMETIC_BY_ZERO(542, false, &quot;系统错误，无法除零！&quot;),
    SYSTEM_NULL_POINTER(543, false, &quot;系统错误，空指针！&quot;),
    SYSTEM_NUMBER_FORMAT(544, false, &quot;系统错误，数字转换异常！&quot;),
    SYSTEM_PARSE(545, false, &quot;系统错误，解析异常！&quot;),
    SYSTEM_IO(546, false, &quot;系统错误，IO输入输出异常！&quot;),
    SYSTEM_FILE_NOT_FOUND(547, false, &quot;系统错误，文件未找到！&quot;),
    SYSTEM_CLASS_CAST(548, false, &quot;系统错误，类型强制转换错误！&quot;),
    SYSTEM_PARSER_ERROR(549, false, &quot;系统错误，解析出错！&quot;),
    SYSTEM_DATE_PARSER_ERROR(550, false, &quot;系统错误，日期解析出错！&quot;),

    // admin 管理系统 56x
    ADMIN_USERNAME_NULL_ERROR(561, false, &quot;管理员登录名不能为空！&quot;),
    ADMIN_USERNAME_EXIST_ERROR(562, false, &quot;管理员登录名已存在！&quot;),
    ADMIN_NAME_NULL_ERROR(563, false, &quot;管理员负责人不能为空！&quot;),
    ADMIN_PASSWORD_ERROR(564, false, &quot;密码不能为空后者两次输入不一致！&quot;),
    ADMIN_CREATE_ERROR(565, false, &quot;添加管理员失败！&quot;),
    ADMIN_PASSWORD_NULL_ERROR(566, false, &quot;密码不能为空！&quot;),
    ADMIN_NOT_EXIT_ERROR(567, false, &quot;管理员不存在或密码错误！&quot;),
    ADMIN_FACE_NULL_ERROR(568, false, &quot;人脸信息不能为空！&quot;),
    ADMIN_FACE_LOGIN_ERROR(569, false, &quot;人脸识别失败，请重试！&quot;),
    CATEGORY_EXIST_ERROR(570, false, &quot;文章分类已存在，请换一个分类名！&quot;),

    // 媒体中心 相关错误 58x
    ARTICLE_COVER_NOT_EXIST_ERROR(580, false, &quot;文章封面不存在，请选择一个！&quot;),
    ARTICLE_CATEGORY_NOT_EXIST_ERROR(581, false, &quot;请选择正确的文章领域！&quot;),
    ARTICLE_CREATE_ERROR(582, false, &quot;创建文章失败，请重试或联系管理员！&quot;),
    ARTICLE_QUERY_PARAMS_ERROR(583, false, &quot;文章列表查询参数错误！&quot;),
    ARTICLE_DELETE_ERROR(584, false, &quot;文章删除失败！&quot;),
    ARTICLE_WITHDRAW_ERROR(585, false, &quot;文章撤回失败！&quot;),
    ARTICLE_REVIEW_ERROR(585, false, &quot;文章审核出错！&quot;),
    ARTICLE_ALREADY_READ_ERROR(586, false, &quot;文章重复阅读！&quot;),

    // 人脸识别错误代码
    FACE_VERIFY_TYPE_ERROR(600, false, &quot;人脸比对验证类型不正确！&quot;),
    FACE_VERIFY_LOGIN_ERROR(601, false, &quot;人脸登录失败！&quot;),

    // 系统错误，未预期的错误 555
    SYSTEM_ERROR(555, false, &quot;系统繁忙，请稍后再试！&quot;),
    SYSTEM_OPERATION_ERROR(556, false, &quot;操作失败，请重试或联系管理员&quot;),
    SYSTEM_RESPONSE_NO_INFO(557, false, &quot;&quot;);


    // 响应业务状态
    private Integer status;
    // 调用是否成功
    private Boolean success;
    // 响应消息，可以为成功或者失败的消息
    private String msg;

    ResponseStatusEnum(Integer status, Boolean success, String msg) &#123;
        this.status = status;
        this.success = success;
        this.msg = msg;
    &#125;

    public Integer status() &#123;
        return status;
    &#125;
    public Boolean success() &#123;
        return success;
    &#125;
    public String msg() &#123;
        return msg;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/exception/GraceExceptionHandler.java
package com.imooc.exception;

import com.imooc.grace.result.GraceJSONResult;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 统一异常拦截处理
 * 可以针对异常的类型进行捕获 然后返回json信息到前端
 */
@ControllerAdvice //本质上是实现AOP的管理
public class GraceExceptionHandler &#123;
    @ExceptionHandler(MyCustomException.class)
    //只要是这个类的异常都会进入下面的方法
    @ResponseBody
    public GraceJSONResult returnMyException(MyCustomException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.exception(e.getResponseStatusEnum());
    &#125;
&#125;
</code></pre>
<h3 id="验证BO信息-注册登录接口"><a href="#验证BO信息-注册登录接口" class="headerlink" title="验证BO信息(注册登录接口)"></a>验证BO信息(注册登录接口)</h3><pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/RegistLoginBO.java
package com.imooc.pojo.bo;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;

//加上@data 会自动生成getter+setter
public class RegistLoginBO &#123;
    //不为空 空的话可以返回 不用NOTNULL因为无法校验空字符串 用NotBlank
    @NotBlank(message = &quot;手机号不能为空&quot;) 
    private String mobile;
    @NotBlank(message = &quot;短信验证码不能为空&quot;)
    private String smsCode;

    @Override
    public String toString() &#123;
        return &quot;RegistLoginBO&#123;&quot; +
                &quot;mobile=&#39;&quot; + mobile + &#39;\&#39;&#39; +
                &quot;, smsCode=&#39;&quot; + smsCode + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    public String getMobile() &#123;
        return mobile;
    &#125;

    public void setMobile(String mobile) &#123;
        this.mobile = mobile;
    &#125;

    public String getSmsCode() &#123;
        return smsCode;
    &#125;

    public void setSmsCode(String smsCode) &#123;
        this.smsCode = smsCode;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.utils.IPUtil;
import com.imooc.utils.SMSUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        //获取用户ip
        String userIp = IPUtil.getRequestIp(request);
        logger.info(&quot;User ip:&quot;, userIp);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot; + userIp, userIp);

        // 生成6位随机验证码
        String random = (int)((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        // 打印生成的验证码以便调试
//        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
//        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
//        logger.info(&quot;SMS sent to 15027597319 with code: &quot; + random);
        redis.set(MOBILE_SMSCODE + &quot;:&quot; + mobile, random, 30 * 60);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
package com.imooc.api;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class BaseController &#123;
   @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;

    /**可以公用 就放到BaseController里面
     * 在任何controller中都可以调用和使用
     * 获取BO中的错误信息
     *
     * @param result
     * @return
     */
    public Map&lt;String, String&gt; getErrors(BindingResult result)&#123;
        //对应着RegistLoginBO的信息
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList)&#123;
            //发生验证错误所对应的某个属性
            String field = error.getField();
            //验证的错误信息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;
&#125;
</code></pre>
<pre><code class="java">http://writer.imoocnews.com:8003/doc.html   打开校验
POST：/passport/doLogin

&#123;
    &quot;mobile&quot;:&quot;&quot;,
    &quot;smsCode&quot;:&quot;&quot;
&#125;

&#123;
&quot;status&quot;: 500,
&quot;msg&quot;: &quot;操作失败！&quot;,
&quot;success&quot;: false,
-&quot;data&quot;: &#123;
&quot;smsCode&quot;: &quot;短信验证码不能为空&quot;,
&quot;mobile&quot;: &quot;手机号不能为空&quot;
&#125;
&#125;
--------------------------------------------------------
 //不为空 空的话可以返回 不用NOTNULL因为无法校验空字符串 用NotBlank
    @NotBlank(message = &quot;手机号不能为空&quot;) 
    private String mobile;
    @NotBlank(message = &quot;短信验证码不能为空&quot;)
    private String smsCode;
// 要注意上面的为NotBlank 不然它验证的结果会跳过手机号判断 直接说验证码错误 
// 因为NotNull在处理&quot;mobile&quot;:&quot;&quot;, &quot;smsCode&quot;:&quot;&quot;的时候空字符串也算入不为空
//NotBlank兼顾NotNull
</code></pre>
<h3 id="通过数据库-查询老用户-老用户添加"><a href="#通过数据库-查询老用户-老用户添加" class="headerlink" title="通过数据库 查询老用户_老用户添加"></a>通过数据库 查询老用户_老用户添加</h3><pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.enums.UserStatus;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.IPUtil;
import com.imooc.utils.SMSUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;

    @Autowired
    private UserService userService;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        //获取用户ip
        String userIp = IPUtil.getRequestIp(request);
        logger.info(&quot;User ip:&quot;, userIp);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot; + userIp, userIp);

        // 生成6位随机验证码
        String random = (int)((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        // 打印生成的验证码以便调试
//        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
//        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
//        logger.info(&quot;SMS sent to 15027597319 with code: &quot; + random);
        redis.set(MOBILE_SMSCODE + &quot;:&quot; + mobile, random, 30 * 60);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;

        //2.查询数据库,判断该用户注册
        AppUser user = userService.queryMobileIsExist(mobile);
        if (user != null &amp;&amp; user.getActiveStatus() == UserStatus.FROZEN.type)&#123;
            //如果用户不为空，并且状态为冻结，则直接抛出异常，禁止登录
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_FROZEN);
        &#125;else if (user == null)&#123;
            //如果用户没有注册过，则为null，需要注册信息入库
            user = userService.createUser(mobile);
        &#125;
        return GraceJSONResult.ok(user);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/UserService.java[接口]
package com.imooc.user.service.impl;

import com.imooc.pojo.AppUser;

public interface UserService &#123;
    /**
     * 判断用户是否存在，如果存在返回user信息
     */
    public AppUser queryMobileIsExist(String mobile);

    /**
     * 创建用户，新增用户记录到数据库
     */
    public AppUser createUser(String mobile);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java
package com.imooc.user.service;

import com.imooc.enums.Sex;
import com.imooc.enums.UserStatus;
import com.imooc.pojo.AppUser;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.DesensitizationUtil;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;
import com.imooc.utils.DateUtil;

import java.util.Date;

@Service
public class UserServiceimpl implements UserService &#123;
    @Autowired
    public AppUserMapper appUserMapper; //基本的CRUD都可以

    @Autowired
    public Sid sid;

    private static final String USER_FACE0 = &quot;https://raw.githubusercontent.com/P-luminary/images/10d94134b65e13cc8ec9b8a9aeae4f958921cab7/data/Imooc_Cat.jpg&quot;;
    private static final String USER_FACE1 = &quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;;
    @Override
    public AppUser queryMobileIsExist(String mobile) &#123;
        Example userExample = new Example(AppUser.class);
        Example.Criteria userCriteria = userExample.createCriteria();
        userCriteria.andEqualTo(&quot;mobile&quot;, mobile);
        AppUser user = appUserMapper.selectOneByExample(userExample);
        return null;
    &#125;

    @Transactional //对整个类的方法，事务起作用。无异常时正常提交，有异常时数据回滚
    @Override
    public AppUser createUser(String mobile) &#123;
        /**
         * 互联网项目都要考虑可扩展性
         * 如果未来的业务激增，那么就需要分表分库
         * 那么数据库表主键id必须保证全局(全库)唯一,不得重复
         */
        String userId = sid.nextShort();
        AppUser user = new AppUser();
        user.setId(userId);
        user.setMobile(mobile);
        user.setNickname(&quot;用户：&quot; + DesensitizationUtil.commonDisplay(mobile)); //給手机号加** 是脱敏操作
        user.setFace(USER_FACE1);
        user.setBirthday(DateUtil.stringToDate(&quot;2024-06-29&quot;)); //字符串转换Date类型
        user.setSex(Sex.secret.type);
        user.setActiveStatus(UserStatus.INACTIVE.type);//是否激活
        user.setTotalIncome(0);//收入
        user.setCreatedTime(new Date());
        user.setUpdatedTime(new Date());
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/AppUser.java
package com.imooc.pojo;

import javax.persistence.Column;
import javax.persistence.Id;
import javax.persistence.Table;
import java.util.Date;

@Table(name = &quot;app_user&quot;)
public class AppUser &#123;
    @Id
    private String id;

    /**
     * 手机号
     */
    private String mobile;

    /**
     * 昵称，媒体号
     */
    private String nickname;

    /**
     * 头像
     */
    private String face;

    /**
     * 真实姓名
     */
    private String realname;

    /**
     * 邮箱地址
     */
    private String email;

    /**
     * 性别 1:男  0:女  2:保密
     */
    private Integer sex;

    /**
     * 生日
     */
    private Date birthday;

    /**
     * 省份
     */
    private String province;

    /**
     * 城市
     */
    private String city;

    /**
     * 区县
     */
    private String district;

    /**
     * 用户状态：0：未激活。 1：已激活：基本信息是否完善，真实姓名，邮箱地址，性别，生日，住址等，如果没有完善，则用户不能发表评论，不能点赞，不能关注。2：已冻结。
     */
    @Column(name = &quot;active_status&quot;)
    private Integer activeStatus;

    /**
     * 累计已结算的收入金额，也就是已经打款的金额，每次打款后再此累加
     */
    @Column(name = &quot;total_income&quot;)
    private Integer totalIncome;

    /**
     * 创建时间 创建时间
     */
    @Column(name = &quot;created_time&quot;)
    private Date createdTime;

    /**
     * 更新时间 更新时间
     */
    @Column(name = &quot;updated_time&quot;)
    private Date updatedTime;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-user  com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;com.imooc.utils&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">【来自Chatgpt】
java.sql.SQLException: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;READ&#39; at line 1
    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readErrorPacket(AbstractQueryProtocol.java:1594)
    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readPacket(AbstractQueryProtocol.java:1453)
    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.getResult(AbstractQueryProtocol.java:1415)

这个新的错误信息表明在设置 tx_isolation 时，语法存在问题。我们需要确保设置事务隔离级别的语法是正确的。以下是一些更具体的步骤来解决这个问题：

1. 确认MariaDB版本支持的语法
在MariaDB中，设置事务隔离级别的正确语法可能与MySQL略有不同。确保使用MariaDB支持的正确语法。

2. 确认正确的事务隔离级别语法
根据MariaDB的官方文档，设置事务隔离级别的正确方法是使用以下语法：

sql
复制代码
SET SESSION tx_isolation = &#39;READ-COMMITTED&#39;;
3. 修改连接URL
在连接URL中正确设置事务隔离级别：

yaml
复制代码
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/imooc-news-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;sessionVariables=tx_isolation=&#39;READ-COMMITTED&#39;
4. 确认数据源属性配置
确保数据源属性配置正确：

yaml
复制代码
spring:
  datasource:
    hikari:
      connection-timeout: 30000
      minimum-idle: 5
      maximum-pool-size: 20
      auto-commit: true
      idle-timeout: 600000
      pool-name: DateSourceHikariCP
      max-lifetime: 1800000
      connection-test-query: SELECT 1
      data-source-properties:
        tx_isolation: &#39;READ-COMMITTED&#39;
5. 确认使用MariaDB JDBC驱动
确保使用MariaDB的JDBC驱动：

Maven
xml
复制代码
&lt;dependency&gt;
    &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
    &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
    &lt;version&gt;2.7.2&lt;/version&gt;
&lt;/dependency&gt;
Gradle
groovy
复制代码
implementation &#39;org.mariadb.jdbc:mariadb-java-client:2.7.2&#39;
6. 测试事务隔离设置
在MariaDB中手动测试设置事务隔离级别，确保语法正确：

sql
复制代码
SET SESSION tx_isolation = &#39;READ-COMMITTED&#39;;
如果这条命令可以成功执行，那么它也应该能在你的连接URL中正确设置。

7. 确认Spring配置
确保Spring Boot配置正确，可以通过显式设置数据源属性来避免问题：

yaml
复制代码
spring:
  datasource:
    hikari:
      data-source-properties:
        tx_isolation: &#39;READ-COMMITTED&#39;
总结
通过上述步骤，你应该能够解决 tx_isolation 变量设置的问题，并确保连接到MariaDB数据库时没有语法错误。如果问题依然存在，请提供更多的错误日志和配置文件信息，以便进一步诊断。
</code></pre>
<pre><code class="java">http://writer.imoocnews.com:8003/doc.html 先接收验证码 通过redis获得 再测试登录接口
&#123;
    &quot;mobile&quot;:&quot;15027597319&quot;,
    &quot;smsCode&quot;:&quot;815850&quot;
&#125;

相应内容：
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    -&quot;data&quot;: &#123;
    &quot;id&quot;: &quot;240629F0PD4PZANC&quot;,
    &quot;mobile&quot;: &quot;15027597319&quot;,
    &quot;nickname&quot;: &quot;用户：15******319&quot;,
    &quot;face&quot;: &quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;,
    &quot;realname&quot;: null,
    &quot;email&quot;: null,
    &quot;sex&quot;: 2,
    &quot;birthday&quot;: &quot;2024-06-29 00:00:00&quot;,
    &quot;province&quot;: null,
    &quot;city&quot;: null,
    &quot;district&quot;: null,
    &quot;activeStatus&quot;: 0,
    &quot;totalIncome&quot;: 0,
    &quot;createdTime&quot;: &quot;2024-06-29 19:39:10&quot;,
    &quot;updatedTime&quot;: &quot;2024-06-29 19:39:10&quot;
    &#125;
&#125;

此时去数据库imooc-news-dev的app_user中发现并未有数据新增进入
再UserServiceimpl.java中
appUserMapper.insert(user);

当如果把app_user数据库离的active_status 的0变成2 就会被冻结【UserStatus】
&#123;
&quot;status&quot;: 507,
&quot;msg&quot;: &quot;用户已被冻结，请联系管理员！&quot;,
&quot;success&quot;: false,
&quot;data&quot;: null
&#125;
</code></pre>
<h3 id="设置会话与cookie信息【注册登录】"><a href="#设置会话与cookie信息【注册登录】" class="headerlink" title="设置会话与cookie信息【注册登录】"></a>设置会话与cookie信息【注册登录】</h3><pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
...
 // 3.保存用户分布式会话的相关操作
        int userActiveStatus = user.getActiveStatus();
        if (userActiveStatus != UserStatus.FROZEN.type)&#123;
            String uToken = UUID.randomUUID().toString();
            redis.set(REDIS_USER_TOKEN+&quot;:&quot;+user.getId(),uToken);//BaseController里面 保存token到redis
            //保存用户id和token到cookie中 设计一个request response 回到PassportControllerApi

        &#125;
        return GraceJSONResult.ok(user);
    &#125;
...
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java [增加一个setCookie]
package com.imooc.api;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class BaseController &#123;
   @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;

    /**可以公用 就放到BaseController里面
     * 在任何controller中都可以调用和使用
     * 获取BO中的错误信息
     *
     * @param result
     * @return
     */
    public Map&lt;String, String&gt; getErrors(BindingResult result)&#123;
        //对应着RegistLoginBO的信息
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList)&#123;
            //发生验证错误所对应的某个属性
            String field = error.getField();
            //验证的错误信息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;

/*    public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge)&#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
            Cookie cookie = new Cookie(cookieName,cookieValue);
            cookie.setMaxAge(maxAge);
            cookie.setDomain(&quot;imoocnews.com&quot;);
            cookie.setPath(&quot;/&quot;);//都用cookie
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125; */

   public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge)&#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
//            Cookie cookie = new Cookie(cookieName,cookieValue);
//            cookie.setMaxAge(maxAge);
//            cookie.setDomain(&quot;imoocnews.com&quot;);
//            cookie.setPath(&quot;/&quot;);//都用cookie
            setCookieValue(request, response, cookieName, cookieValue, maxAge);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void setCookieValue(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge)&#123;
            Cookie cookie = new Cookie(cookieName,cookieValue);
            cookie.setMaxAge(maxAge);
            cookie.setDomain(&quot;imoocnews.com&quot;);
            cookie.setPath(&quot;/&quot;);//都用cookie
            response.addCookie(cookie);//把cookie传入
        &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO
            , BindingResult result, HttpServletRequest request, HttpServletResponse response);
    //完成之后 去BaseController里面写一个setCookie()方便都可以用
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
    @Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result, HttpServletRequest request, HttpServletResponse response) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;

        //2.查询数据库,判断该用户注册
        AppUser user = userService.queryMobileIsExist(mobile);
        if (user != null &amp;&amp; user.getActiveStatus() == UserStatus.FROZEN.type)&#123;
            //如果用户不为空，并且状态为冻结，则直接抛出异常，禁止登录
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_FROZEN);
        &#125;else if (user == null)&#123;
            //如果用户没有注册过，则为null，需要注册信息入库
            user = userService.createUser(mobile);
        &#125;

        // 3.保存用户分布式会话的相关操作
        int userActiveStatus = user.getActiveStatus();
        if (userActiveStatus != UserStatus.FROZEN.type)&#123;
            String uToken = UUID.randomUUID().toString();
            redis.set(REDIS_USER_TOKEN+&quot;:&quot;+user.getId(),uToken);//BaseController里面 保存token到redis

            //保存用户id和token到cookie中 设计一个request response 回到PassportControllerApi
            setCookie(request, response,&quot;uToken&quot;,uToken,COOKIE_MONTH);
            setCookie(request, response,&quot;uid&quot;,user.getId(),COOKIE_MONTH);
        &#125;
        // 4.用户登录或注册成功以后，需要删除redis中的短信验证码，验证码只能使用一次，用过则作废
        redis.del(MOBILE_SMSCODE + &quot;:&quot; + mobile);
        // 5.返回用户状态 返回前端看
        return GraceJSONResult.ok(userActiveStatus);
    &#125;
</code></pre>
<h3 id="资源属性与常量绑定-优雅"><a href="#资源属性与常量绑定-优雅" class="headerlink" title="资源属性与常量绑定 [优雅]"></a>资源属性与常量绑定 [优雅]</h3><pre><code class="java">把这种属性放到常量文件里进行绑定  cookie.setDomain(&quot;imoocnews.com&quot;);
service-api  com/imooc/api/BaseController.java
public abstract class BaseController &#123;
    @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;
 ★ @Value(&quot;$&#123;website.domain-name&#125;&quot;) ★★
 ★ public String DOMAIN_NAME; ★★
...
 public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge) &#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
//            Cookie cookie = new Cookie(cookieName,cookieValue);
//            cookie.setMaxAge(maxAge);
//            cookie.setDomain(&quot;imoocnews.com&quot;);
//            cookie.setPath(&quot;/&quot;);//都用cookie
            setCookieValue(request, response, cookieName, cookieValue, maxAge);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void setCookieValue(HttpServletRequest request,
                               HttpServletResponse response,
                               String cookieName,
                               String cookieValue,
                               Integer maxAge) &#123;
        Cookie cookie = new Cookie(cookieName, cookieValue);
        cookie.setMaxAge(maxAge);
//        cookie.setDomain(&quot;imoocnews.com&quot;);
        cookie.setDomain(DOMAIN_NAME);
        cookie.setPath(&quot;/&quot;);//都用cookie
        response.addCookie(cookie);//把cookie传入
    &#125;
...
================================================================================
application-dev.yml
server:
  port: 8003

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379

# setup CN from java, This is resource
website:
  domain-name: imoocnews.com
</code></pre>
<h3 id="查询用户账户信息"><a href="#查询用户账户信息" class="headerlink" title="查询用户账户信息"></a>查询用户账户信息</h3><pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.api.controller.user.UserControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.vo.UserAccountInfoVO;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@RestController
public class UserController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    @Override
    public GraceJSONResult getAccountInfo(String userId) &#123;
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;

        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        UserAccountInfoVO accountInfoVO = new UserAccountInfoVO();
        BeanUtils.copyProperties(user, accountInfoVO); //拷贝信息
        return GraceJSONResult.ok(accountInfoVO);
    &#125;
    private AppUser getUser(String userId)&#123;
        // TODO 本方法后续公用，并且扩展
        AppUser user = userService.getUser(userId);
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/UserService.java
package com.imooc.user.service.impl;

import com.imooc.pojo.AppUser;

public interface UserService &#123;
    /**
     * 判断用户是否存在，如果存在返回user信息
     */
    public AppUser queryMobileIsExist(String mobile);

    /**
     * 创建用户，新增用户记录到数据库
     */
    public AppUser createUser(String mobile);

    /**
     * 根据用户主键id查询用户信息
     * @param userId
     * @return
     */
    public AppUser getUser(String userId);
&#125;
====================================================================
service-user  com/imooc/user/service/UserServiceimpl.java
     @Override
    public AppUser getUser(String userId) &#123;
        return appUserMapper.selectByPrimaryKey(userId);
    &#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/UserAccountInfoVO.java
public class UserAccountInfoVO &#123;
    private String id;
    private String mobile;
    private String nickname;
    private String face;
    private String realname;
    private String email;
    private Integer sex;
    private Date birthday;
    private String province;
    private String city;
    private String district;
&#125;Getter + Setter
</code></pre>
<h3 id="信息校验"><a href="#信息校验" class="headerlink" title="信息校验"></a>信息校验</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.api.controller.user.UserControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.pojo.vo.UserAccountInfoVO;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Map;

@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    @Override
    public GraceJSONResult getAccountInfo(String userId) &#123;
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;

        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        UserAccountInfoVO accountInfoVO = new UserAccountInfoVO();
        BeanUtils.copyProperties(user, accountInfoVO); //拷贝信息
        return GraceJSONResult.ok(accountInfoVO);
    &#125;

    private AppUser getUser(String userId)&#123;
        // TODO 本方法后续公用，并且扩展
        AppUser user = userService.getUser(userId);
        return user;
    &#125;

    @Override
    public GraceJSONResult updateUserInfo(UpdateUserInfoBO updateUserInfoBO, BindingResult result) &#123;
        // 0.校验BO
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        // 1.执行更新操作
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
                                          BindingResult result);
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/UpdateUserInfoBO.java
public class UpdateUserInfoBO &#123;

    @NotBlank(message = &quot;用户ID不能为空&quot;)
    private String id;

    @NotBlank(message = &quot;用户昵称不能为空&quot;)
    @Length(max = 12, message = &quot;用户昵称不能超过12位&quot;)
    private String nickname;

    @NotBlank(message = &quot;用户头像不能为空&quot;)
    private String face;

    @NotBlank(message = &quot;真实姓名不能为空&quot;)
    private String realname;

    @Email
    @NotBlank(message = &quot;邮件不能为空&quot;)
    private String email;

    @NotNull(message = &quot;请选择一个性别&quot;)
    @Min(value = 0, message = &quot;性别选择不正确&quot;)
    @Max(value = 1, message = &quot;性别选择不正确&quot;)
    private Integer sex;

    @NotNull(message = &quot;请选择生日日期&quot;)
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd&quot;) // 解决前端日期字符串传到后端后，转换为Date类型
    private Date birthday;

    @NotBlank(message = &quot;请选择所在城市&quot;)
    private String province;

    @NotBlank(message = &quot;请选择所在城市&quot;)
    private String city;

    @NotBlank(message = &quot;请选择所在城市&quot;)
    private String district;
&#125;
</code></pre>
<h3 id="激活用户信息入库"><a href="#激活用户信息入库" class="headerlink" title="激活用户信息入库"></a>激活用户信息入库</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@Override
    public GraceJSONResult updateUserInfo(UpdateUserInfoBO updateUserInfoBO, BindingResult result) &#123;
        // 0.校验BO
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        // 1.执行更新操作
        userService.updateUserInfo(updateUserInfoBO);
        return GraceJSONResult.ok();
        //调用UserService把独有信息传入
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/UserService.java
package com.imooc.user.service.impl;

import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;

public interface UserService &#123;
    /**
     * 判断用户是否存在，如果存在返回user信息
     */
    public AppUser queryMobileIsExist(String mobile);

    /**
     * 创建用户，新增用户记录到数据库
     */
    public AppUser createUser(String mobile);

    /**
     * 根据用户主键id查询用户信息
     * @param userId
     * @return
     */
    public AppUser getUser(String userId);

    /**
     * 用户修改信息，完善资料，并且激活
     * @param updateUserInfoBO
     */
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java
@Override
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO)&#123;
        String userId = updateUserInfoBO.getId();
        AppUser userInfo = new AppUser();
        BeanUtils.copyProperties(updateUserInfoBO, userInfo);
        userInfo.setUpdatedTime(new Date());
        userInfo.setActiveStatus(UserStatus.ACTIVE.type);
        //appUserMapper.updateByPrimaryKey()//数据中现有的数据覆盖为空的
        int result = appUserMapper.updateByPrimaryKeySelective(userInfo);
        if (result != 1)&#123;
            //更新操作有问题
            GraceException.display(ResponseStatusEnum.USER_UPDATE_ERROR);
        &#125;
    &#125;
</code></pre>
<h3 id="查询并展示用户基本信息"><a href="#查询并展示用户基本信息" class="headerlink" title="查询并展示用户基本信息"></a>查询并展示用户基本信息</h3><pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,BindingResult result);
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/AppUserVO.java
public class AppUserVO &#123;
    private String id;
    private String nickname;
    private String face;
    private Integer activeStatus;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    @Override
    public GraceJSONResult getUserInfo(String userId) &#123;
        //重写接口进行解耦!!
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;
        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        AppUserVO userVO = new AppUserVO();
        BeanUtils.copyProperties(user, userVO); //拷贝信息
        return GraceJSONResult.ok(userVO);
    &#125;
&#125;
</code></pre>
<h3 id="浏览器存储介质"><a href="#浏览器存储介质" class="headerlink" title="浏览器存储介质"></a>浏览器存储介质</h3><ul>
<li><h6 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h6></li>
<li><h6 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a><span style = "color:red">SessionStorage</span></h6></li>
<li><h6 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h6></li>
</ul>
<h3 id="缓存用户信息-用Redis减轻数据库压力"><a href="#缓存用户信息-用Redis减轻数据库压力" class="headerlink" title="缓存用户信息 [用Redis减轻数据库压力]"></a>缓存用户信息 [用Redis减轻数据库压力]</h3><pre><code class="java">service-api  com/imooc/api/BaseController.java
//REDIS_USER_INFO添加进来
public abstract class BaseController &#123;
    @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_USER_INFO = &quot;redis_user_info&quot;;//ctrl+shift+u直接大写
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;
    @Value(&quot;$&#123;website.domain-name&#125;&quot;)
    public String DOMAIN_NAME;

    /**
     * 可以公用 就放到BaseController里面
     * 在任何controller中都可以调用和使用
     * 获取BO中的错误信息
     *
     * @param result
     * @return
     */
    public Map&lt;String, String&gt; getErrors(BindingResult result) &#123;
        //对应着RegistLoginBO的信息
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList) &#123;
            //发生验证错误所对应的某个属性
            String field = error.getField();
            //验证的错误信息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;

    public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge) &#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
//            Cookie cookie = new Cookie(cookieName,cookieValue);
//            cookie.setMaxAge(maxAge);
//            cookie.setDomain(&quot;imoocnews.com&quot;);
//            cookie.setPath(&quot;/&quot;);//都用cookie
            setCookieValue(request, response, cookieName, cookieValue, maxAge);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void setCookieValue(HttpServletRequest request,
                               HttpServletResponse response,
                               String cookieName,
                               String cookieValue,
                               Integer maxAge) &#123;
        Cookie cookie = new Cookie(cookieName, cookieValue);
        cookie.setMaxAge(maxAge);
//        cookie.setDomain(&quot;imoocnews.com&quot;);
        cookie.setDomain(DOMAIN_NAME);
        cookie.setPath(&quot;/&quot;);//都用cookie
        response.addCookie(cookie);//把cookie传入
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
 private AppUser getUser(String userId)&#123;
        //查询判断redis中是否包含用户信息 若有则直接返回就不去查询数据库了
        String userJson = redis.get(REDIS_USER_INFO + &quot;:&quot; + userId);
        AppUser user = null;
        if (StringUtils.isNotBlank(userJson))&#123;
            //字符串转换成json对象  要提取user 所以要一开始赋值null
            user = JsonUtils.jsonToPojo(userJson, AppUser.class);
        &#125; else &#123;
            // TODO 本方法后续公用，并且扩展
            user = userService.getUser(userId);
            // 由于用户信息不怎么会变动,对于一些千万级别网站来说,这类信息不会直接去查询数据库
            // 可以完全依靠Redis,直接把查询后的数据存入到Redis中
            // set里面设置一个key去BaseController里设置  ↓user变成jason转换类
            redis.set(REDIS_USER_INFO + &quot;:&quot; + userId, JsonUtils.objectToJson(user));
        &#125;

        return user;
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java
package com.imooc.user.service;

import com.imooc.enums.Sex;
import com.imooc.enums.UserStatus;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.DesensitizationUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;
import org.n3r.idworker.Sid;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;
import com.imooc.utils.DateUtil;

import java.util.Date;

@Service
public class UserServiceimpl implements UserService &#123;
    @Autowired
    public AppUserMapper appUserMapper; //基本的CRUD都可以

    @Autowired
    public Sid sid;
    public static final String REDIS_USER_INFO = &quot;redis_user_info&quot;;//ctrl+shift+u直接大写


    @Autowired
    public RedisOperator redis;

    private static final String USER_FACE0 = &quot;https://raw.githubusercontent.com/P-luminary/images/10d94134b65e13cc8ec9b8a9aeae4f958921cab7/data/Imooc_Cat.jpg&quot;;
    private static final String USER_FACE1 = &quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;;
    @Override
    public AppUser queryMobileIsExist(String mobile) &#123;
        Example userExample = new Example(AppUser.class);
        Example.Criteria userCriteria = userExample.createCriteria();
        userCriteria.andEqualTo(&quot;mobile&quot;, mobile);
        AppUser user = appUserMapper.selectOneByExample(userExample);
        return user;
    &#125;

    @Transactional //对整个类的方法，事务起作用。无异常时正常提交，有异常时数据回滚
    @Override
    public AppUser createUser(String mobile) &#123;
        /**
         * 互联网项目都要考虑可扩展性
         * 如果未来的业务激增，那么就需要分表分库
         * 那么数据库表主键id必须保证全局(全库)唯一,不得重复
         */
        String userId = sid.nextShort();
        AppUser user = new AppUser();
        user.setId(userId);
        user.setMobile(mobile);
        user.setNickname(&quot;用户：&quot; + DesensitizationUtil.commonDisplay(mobile)); //給手机号加** 是脱敏操作
        user.setFace(USER_FACE1);
        user.setBirthday(DateUtil.stringToDate(&quot;2024-06-29&quot;)); //字符串转换Date类型
        user.setSex(Sex.secret.type);
        user.setActiveStatus(UserStatus.INACTIVE.type);//是否激活
        user.setTotalIncome(0);//收入
        user.setCreatedTime(new Date());
        user.setUpdatedTime(new Date());
        appUserMapper.insert(user);
        return user;
    &#125;

    @Override
    public AppUser getUser(String userId) &#123;
        return appUserMapper.selectByPrimaryKey(userId);
    &#125;

    @Override
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO)&#123;
        String userId = updateUserInfoBO.getId();
        AppUser userInfo = new AppUser();
        BeanUtils.copyProperties(updateUserInfoBO, userInfo);

        userInfo.setUpdatedTime(new Date());
        userInfo.setActiveStatus(UserStatus.ACTIVE.type);
        //appUserMapper.updateByPrimaryKey()//数据中现有的数据覆盖为空的
        int result = appUserMapper.updateByPrimaryKeySelective(userInfo);
        if (result != 1)&#123;
            //更新操作有问题
            GraceException.display(ResponseStatusEnum.USER_UPDATE_ERROR);
        &#125;
        // 再次查询用户的最新信息,放入redis中
        AppUser user = getUser(userId);
        redis.set(REDIS_USER_INFO + &quot;:&quot; + userId, JsonUtils.objectToJson(user));

    &#125;
&#125;
</code></pre>
<pre><code class="java">Redis里面 redis_user_info
&#123;&quot;id&quot;:&quot;240629F21AK1BHX4&quot;,&quot;mobile&quot;:&quot;15027597319&quot;,&quot;nickname&quot;:&quot;15027597319&quot;,&quot;face&quot;:&quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;,&quot;realname&quot;:&quot;小宝宝的小潘潘2&quot;,&quot;email&quot;:&quot;390415030@qq.com&quot;,&quot;sex&quot;:1,&quot;birthday&quot;:1720195200000,&quot;province&quot;:&quot;河北&quot;,&quot;city&quot;:&quot;唐山市&quot;,&quot;district&quot;:&quot;丰润区&quot;,&quot;activeStatus&quot;:1,&quot;totalIncome&quot;:0,&quot;createdTime&quot;:1719661387000,&quot;updatedTime&quot;:1720281759000&#125;
</code></pre>
<h3 id="双写数据不一致的情况-redis故障没有写入新数据"><a href="#双写数据不一致的情况-redis故障没有写入新数据" class="headerlink" title="双写数据不一致的情况 [redis故障没有写入新数据]"></a>双写数据不一致的情况 [redis故障没有写入新数据]</h3><h6 id="如何双写一致-缓存双删"><a href="#如何双写一致-缓存双删" class="headerlink" title="如何双写一致 缓存双删"></a>如何双写一致 缓存双删</h6><blockquote>
<p>用户先把老Redis中的数据删除 然后再把修改值放入数据库 然后数据库再导入redis 就可以保证双写一致<br>但是要保证数据库放入Redis之前 后期用户请求要再其之后 [进行休眠] &#x3D;&gt;缓存双删</p>
</blockquote>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java  @Override
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO)&#123;
        String userId = updateUserInfoBO.getId();
        // 保证双写一致,先删除redis中的数据,后更新数据库
//        redis.del(REDIS_USER_INFO + &quot;:&quot; + userId);

        AppUser userInfo = new AppUser();
        BeanUtils.copyProperties(updateUserInfoBO, userInfo);

        userInfo.setUpdatedTime(new Date());
        userInfo.setActiveStatus(UserStatus.ACTIVE.type);
        //appUserMapper.updateByPrimaryKey()//数据中现有的数据覆盖为空的
        int result = appUserMapper.updateByPrimaryKeySelective(userInfo);
        if (result != 1)&#123;
            //更新操作有问题
            GraceException.display(ResponseStatusEnum.USER_UPDATE_ERROR);
        &#125;
        // 再次查询用户的最新信息,放入redis中
        AppUser user = getUser(userId);
        redis.set(REDIS_USER_INFO + &quot;:&quot; + userId, JsonUtils.objectToJson(user));

        // 缓存双删策略 [不处理可能会缓存击穿]
        try &#123;
            Thread.sleep(100);
            redis.del(REDIS_USER_INFO + &quot;:&quot; + userId);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
</code></pre>
<h3 id="CAP理论-只能满足其中一、二"><a href="#CAP理论-只能满足其中一、二" class="headerlink" title="CAP理论 [只能满足其中一、二]"></a>CAP理论 [只能满足其中一、二]</h3><h5 id="分布式系统都存在CAP情况"><a href="#分布式系统都存在CAP情况" class="headerlink" title="分布式系统都存在CAP情况"></a>分布式系统都存在CAP情况</h5><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><h5 id="CAP的重要性"><a href="#CAP的重要性" class="headerlink" title="CAP的重要性"></a>CAP的重要性</h5><p>分布式不可能同时满足三个条件 【先满足P再去考虑A或C】</p>
<h5 id="CAP理论是什么？"><a href="#CAP理论是什么？" class="headerlink" title="CAP理论是什么？"></a>CAP理论是什么？</h5><ul>
<li><span style = "color:red"><strong>C</strong>(Consistency, 一致性)</span>：读操作是否总能读到前一个写操作的结果 [某节点获得的数据都是一样的] 在本项目中一致性位于Session Storage</li>
<li><span style = "color:red"><strong>A</strong>(Availability, 可用性)</span>：非故障节点应该在合理的时间内作出合理的响应(不是错误或超时的响应),但是可能<strong>不是最新的数据</strong>。 [某个挂掉了 其他还可以用]</li>
<li><span style = "color:red"><strong>P</strong>(Partition tolerance, 分区容错)</span>：当出现网络分区现象后，系统能够继续运行。分区容错性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/793eb4ab3003af82869b186bcc016fcb8c2c2f5b/data/CAP%E5%AE%9A%E7%90%86.jpg"></p>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
<li><strong>CP</strong>：Redis【保证数据一致性 一定要满足C】</li>
<li><strong>AP</strong>：会采用弱一致性 淘宝下单只需要知道下单就好 数量一致性商家可以慢慢调整</li>
<li><strong>CA</strong>：单体存在架构、关系型架构</li>
</ul>
<p>在本项目中如果采用弱一致性：可以不把用户存到session Storage 直接显示</p>
<h3 id="集群、分布式、微服务的区别"><a href="#集群、分布式、微服务的区别" class="headerlink" title="集群、分布式、微服务的区别"></a>集群、分布式、微服务的区别</h3><h5 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h5><ul>
<li>分布式：一个业务分拆<strong>多个子业务</strong>，部署在不同的服务器上 [服务器之间要通信]</li>
<li>集群：<strong>同一个</strong>业务，部署在多个服务器上 [五台机器可以不通信]</li>
</ul>
<h5 id="集群和微服务的区别"><a href="#集群和微服务的区别" class="headerlink" title="集群和微服务的区别"></a>集群和微服务的区别</h5><ul>
<li>集群：分散<strong>压力</strong></li>
<li>微服务：分散<strong>压力</strong></li>
</ul>
<h5 id="微服务和分布式的区别"><a href="#微服务和分布式的区别" class="headerlink" title="微服务和分布式的区别"></a>微服务和分布式的区别</h5><ul>
<li><p>微服务是<strong>架构设计</strong>方式 [逻辑架构]</p>
</li>
<li><p>分布式是<strong>系统部署</strong>方式 [物理架构]</p>
</li>
<li><p>微服务：是一种架构方式 [大的服务拆成小的服务 每个服务独立开发测试]</p>
</li>
<li><p>分布式：主要强调部署的方式</p>
</li>
</ul>
<h3 id="用户会话拦截器-必须用户登陆后才可以用其他界面"><a href="#用户会话拦截器-必须用户登陆后才可以用其他界面" class="headerlink" title="用户会话拦截器 [必须用户登陆后才可以用其他界面]"></a>用户会话拦截器 [必须用户登陆后才可以用其他界面]</h3><pre><code class="java">service-api  com/imooc/api/interceptors/UserTokenInterceptor.java
package com.imooc.api.interceptors;

import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class UserTokenInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    /**
     * 拦截请求，访问controller之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 有些接口同时会給安卓 H5等 所以不去cookie拿
        String userId = request.getHeader(&quot;headerUserId&quot;);
        String userToken = request.getHeader(&quot;headerUserToken&quot;);

        // 判断是否放行
        boolean run = verifyUserIdToken(userId, userToken, REDIS_USER_TOKEN);

        /**
         * false：请求被拦截
         * true：请求通过验证，放行
         */
        return true;
    &#125;


    /**
     * 请求访问到controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    /**
     * 请求访问到controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.api.interceptors;

import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;

public class BaseInterceptor &#123;
    @Autowired
    private RedisOperator redis;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写

    public boolean verifyUserIdToken(String id,
                                     String token,
                                     String redisKeyPrefix)&#123; //redis..前缀
        if (StringUtils.isNotBlank(id) &amp;&amp; StringUtils.isNotBlank(token))&#123;
            String redisToken = redis.get(redisKeyPrefix + &quot;:&quot; + id);
            if (StringUtils.isBlank(id))&#123;
                GraceException.display(ResponseStatusEnum.UN_LOGIN);
                return false;
            &#125; else &#123;
                if (!redisToken.equalsIgnoreCase(token))&#123;//是否和传入token一致
                    GraceException.display(ResponseStatusEnum.TICKET_INVALID);
                    return false;
                &#125;
            &#125;
        &#125;else &#123;
            GraceException.display(ResponseStatusEnum.UN_LOGIN);
            return false;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;);
    &#125;
&#125;
/*
在你的 Spring 应用程序中，InterceptorConfig 类中的 @Bean 注解用于定义 PassportInterceptor 和 UserTokenInterceptor 的 bean。这使这些拦截器对象在 Spring 上下文中可用，以便进行依赖注入。

删除 @Bean 注解后会出现错误 Autowired members must be defined in valid Spring bean (@Component|@Service|...)，这是因为 BaseInterceptor 类中有一个需要由 Spring 注入的依赖 (RedisOperator redis)。要让 Spring 执行依赖注入，包含 @Autowired 注解的类必须是一个由 Spring 管理的 bean，可以通过 @Component、@Service、@Controller 等注解或在配置类中通过 @Bean 来定义。

这里是对 @Bean 的作用以及为什么删除它会导致错误的详细解释：

使用 @Bean 定义 Bean：
在 InterceptorConfig 类中，@Bean 注解定义了 PassportInterceptor 和 UserTokenInterceptor 作为 Spring 的 bean。这使得它们在整个应用程序中可用于依赖注入。

依赖注入的要求：
BaseInterceptor 类中使用了 @Autowired 注解来注入 RedisOperator。要使这个注入有效，BaseInterceptor 必须是一个 Spring 管理的 bean。而 @Bean 注解在配置类中定义了这些拦截器，使得 Spring 可以管理它们，并在需要时进行依赖注入。

如果删除了 @Bean 注解，PassportInterceptor 和 UserTokenInterceptor 将不再是 Spring 管理的 bean，从而导致在它们内部或相关联的类（如 BaseInterceptor）中的依赖无法被注入。这就是为什么删除 @Bean 注解后会出现 Autowired members must be defined in valid Spring bean (@Component|@Service|...) 错误的原因。
*/
</code></pre>
<h3 id="用户状态激活拦截器"><a href="#用户状态激活拦截器" class="headerlink" title="用户状态激活拦截器"></a>用户状态激活拦截器</h3><pre><code class="java">service-api  com/imooc/api/interceptors/UseActiveInterceptor.java
package com.imooc.api.interceptors;

import com.imooc.enums.UserStatus;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.utils.JsonUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 用户激活状态检测拦截器
 * 发文章，修改文章，删除文章，发表评论，查看评论等
 * 这些接口都是要在用户激活后才能进行操作
 * 否则需要提示用户前往[账号设置]去修改信息
 */
    public class UseActiveInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    /**
     * 拦截请求，访问controller之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 有些接口同时会給安卓 H5等 所以不去cookie拿
        String userId = request.getHeader(&quot;headerUserId&quot;);
        String userJson = redis.get(REDIS_USER_INFO + &quot;:&quot; + userId);
        AppUser user = null;
        if (StringUtils.isNotBlank(userJson))&#123;
            user = JsonUtils.jsonToPojo(userJson, AppUser.class);
        &#125; else &#123;
            GraceException.display(ResponseStatusEnum.UN_LOGIN);
        &#125;
        if (user.getActiveStatus() == null || user.getActiveStatus() != UserStatus.ACTIVE.type)&#123;
            GraceException.display(ResponseStatusEnum.USER_INACTIVE_ERROR);
            return false;
            //随后去拦截器里进行@Bean注册 [下下个代码就是]
        &#125;

        /**
         * false：请求被拦截
         * true：请求通过验证，放行
         */
        return true;
    &#125;

    /**
     * 请求访问到controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
    &#125;
    /**
     * 请求访问到controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
//[加一行redis.set(REDIS_USER_INFO+&quot;:&quot;+user.getId(), JsonUtils.objectToJson(user));]
@Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result, HttpServletRequest request, HttpServletResponse response) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;

        //2.查询数据库,判断该用户注册
        AppUser user = userService.queryMobileIsExist(mobile);
        if (user != null &amp;&amp; user.getActiveStatus() == UserStatus.FROZEN.type)&#123;
            //如果用户不为空，并且状态为冻结，则直接抛出异常，禁止登录
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_FROZEN);
        &#125;else if (user == null)&#123;
            //如果用户没有注册过，则为null，需要注册信息入库
            user = userService.createUser(mobile);
        &#125;

        // 3.保存用户分布式会话的相关操作
        int userActiveStatus = user.getActiveStatus();
        if (userActiveStatus != UserStatus.FROZEN.type)&#123;
            String uToken = UUID.randomUUID().toString();
            redis.set(REDIS_USER_TOKEN+&quot;:&quot;+user.getId(),uToken);//BaseController里面 保存token到redis
            redis.set(REDIS_USER_INFO+&quot;:&quot;+user.getId(), JsonUtils.objectToJson(user));

            //保存用户id和token到cookie中 设计一个request response 回到PassportControllerApi
            setCookie(request, response,&quot;utoken&quot;,uToken,COOKIE_MONTH);
            setCookie(request, response,&quot;uid&quot;,user.getId(),COOKIE_MONTH);
        &#125;
        // 4.用户登录或注册成功以后，需要删除redis中的短信验证码，验证码只能使用一次，用过则作废
//        redis.del(MOBILE_SMSCODE + &quot;:&quot; + mobile);
        // 5.返回用户状态 返回前端看
        return GraceJSONResult.ok(userActiveStatus);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UseActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UseActiveInterceptor useActiveInterceptor()&#123;
        return new UseActiveInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;);
//        registry.addInterceptor(userTokenInterceptor())
//                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="AOP警告日志监控与sql打印-切面AOP通知编程"><a href="#AOP警告日志监控与sql打印-切面AOP通知编程" class="headerlink" title="AOP警告日志监控与sql打印 [切面AOP通知编程]"></a>AOP警告日志监控与sql打印 [切面AOP通知编程]</h3><pre><code class="xml">dev-common 引入aop依赖
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/aspect/ServiceLogAspect.java
package com.imooc.api.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class ServiceLogAspect &#123;
    final static Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);
    /**
     * AOP通知：
     * 1.前置通知
     * 2.后置通知
     * 3.环绕通知 ★★
     * 4.异常通知
     * 5.最终通知
     */
    //*是返回所有类型 匹配包的位置 *.* = 任意文件.任意后缀  (..)是任意类和任意方法
    @Around(&quot;execution(* com.imooc.*.service.impl..*.*(..))&quot;)
    public Object recordTimeOfService(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        logger.info(&quot;==== 开始执行 &#123;&#125;.&#123;&#125; ====&quot;,
                joinPoint.getTarget().getClass(),
                joinPoint.getSignature().getName());
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long end = System.currentTimeMillis();
        long takeTime = end - start;
        if (takeTime &gt; 3000)&#123;
            logger.error(&quot;当前执行耗时：&#123;&#125;&quot;,takeTime);
        &#125;else if (takeTime &gt; 2000)&#123;
            logger.warn(&quot;当前执行耗时：&#123;&#125;&quot;,takeTime);
        &#125;else &#123;
            logger.info(&quot;当前执行耗时：&#123;&#125;&quot;,takeTime);
        &#125;
        return result;
    &#125;
&#125;
====================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html
提交信息 看后台Terminal
</code></pre>
<pre><code class="yml">service-user  application-dev.yml #增加一个open mybatis log in dev
  server:
  port: 8003

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
# open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# setup CN from java, This is resource
website:
  domain-name: imoocnews.com

===================================================================
如果在未来发生sql错误可以通过sql输出来找到sql语句从而放入运行检查错误 (21 28行)
JDBC Connection [HikariProxyConnection@2054571226 wrapping org.mariadb.jdbc.MariaDbConnection@4b4b68f8] will not be managed by Spring
==&gt;  Preparing: UPDATE app_user SET nickname = ?,face = ?,realname = ?,email = ?,sex = ?,birthday = ?,province = ?,city = ?,district = ?,active_status = ?,updated_time = ? WHERE id = ? 
==&gt; Parameters: 15027597319(String), https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg(String), 小宝宝的小潘潘(String), 390415030@qq.com(String), 1(Integer), 2024-07-06 00:00:00.0(Timestamp), 河北(String), 唐山市(String), 丰润区(String), 1(Integer), 2024-07-07 22:41:09.862(Timestamp), 240629F21AK1BHX4(String)
&lt;==    Updates: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@9176eb0]
Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@65bd9477] was not registered for synchronization because synchronization is not active
JDBC Connection [HikariProxyConnection@1798162927 wrapping org.mariadb.jdbc.MariaDbConnection@4b4b68f8] will not be managed by Spring
==&gt;  Preparing: SELECT id,mobile,nickname,face,realname,email,sex,birthday,province,city,district,active_status,total_income,created_time,updated_time FROM app_user WHERE id = ? 
==&gt; Parameters: 240629F21AK1BHX4(String)
&lt;==    Columns: id, mobile, nickname, face, realname, email, sex, birthday, province, city, district, active_status, total_income, created_time, updated_time
&lt;==        Row: 240629F21AK1BHX4, 15027597319, 15027597319, https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg, 小宝宝的小潘潘, 390415030@qq.com, 1, 2024-07-06, 河北, 唐山市, 丰润区, 1, 0, 2024-06-29 19:43:07.0, 2024-07-07 22:41:09.0
&lt;==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@65bd9477]
41:10.009 [http-nio-8003-exec-3] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
41:10.010 [http-nio-8003-exec-3] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
41:10.460 [http-nio-8003-exec-3] INFO  c.imooc.api.aspect.ServiceLogAspect - 当前执行耗时：601
</code></pre>
<h3 id="退出登录、注销会话"><a href="#退出登录、注销会话" class="headerlink" title="退出登录、注销会话"></a>退出登录、注销会话</h3><pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
//用户登录信息的redis和cookies清除
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO
            , BindingResult result, HttpServletRequest request, HttpServletResponse response);
    //完成之后 去BaseController里面写一个setCookie()方便都可以用

    @ApiOperation(value = &quot;用户退出登录&quot;,notes = &quot;用户退出登录&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/logout&quot;)
    public GraceJSONResult logout(@RequestParam String userId,
                                  HttpServletRequest request,
                                  HttpServletResponse response);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
@Override
    public GraceJSONResult logout(String userId,
                                  HttpServletRequest request,
                                  HttpServletResponse response)&#123;
        redis.del(REDIS_USER_TOKEN + &quot;:&quot; + userId);
        //USER_INFO可以不用删 可能后面会查询 没有清除cookie只有重新设置时间为0
        setCookie(request, response, &quot;utoken&quot;,&quot;&quot;,COOKIE_DELETE);
        setCookie(request, response, &quot;uid&quot;,&quot;&quot;,COOKIE_DELETE);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<h3 id="FastDFS架构原理与上传下载流程解析"><a href="#FastDFS架构原理与上传下载流程解析" class="headerlink" title="FastDFS架构原理与上传下载流程解析"></a>FastDFS架构原理与上传下载流程解析</h3><h5 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h5><ul>
<li><p>传统服务器存储</p>
</li>
<li><h5 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h5></li>
<li><p>OSS</p>
</li>
<li><p>GridFS</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/584d8cb5b41ffa10cb9b5303c13b5782e1130889/data/FastDFS%E6%9E%B6%E6%9E%84.png"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f4d7477aa2b6843ddfb11af2cbbe2424a25e4b39/data/FastDFS%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="配置FastDFS环境准备工作"><a href="#配置FastDFS环境准备工作" class="headerlink" title="配置FastDFS环境准备工作"></a>配置FastDFS环境准备工作</h3><h6 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h6><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Centos</td>
<td>7.x</td>
</tr>
<tr>
<td>libfastcommon-1.0.42.tar.gz</td>
<td>FastDFS分离出的一些公用函数包</td>
</tr>
<tr>
<td>FastDFS</td>
<td>FastDFS本体</td>
</tr>
<tr>
<td>fastdfs-nginx-module-1.22.tar.gz</td>
<td>FastDFS和nginx的关联模块</td>
</tr>
<tr>
<td>nginx</td>
<td>nginx1.15.4</td>
</tr>
</tbody></table>
<h6 id="它跟我说要准备两个虚拟机-tracker-和-storage-版本都是CentOS-7-x"><a href="#它跟我说要准备两个虚拟机-tracker-和-storage-版本都是CentOS-7-x" class="headerlink" title="它跟我说要准备两个虚拟机[tracker 和 storage 版本都是CentOS 7.x]"></a>它跟我说要准备两个虚拟机[tracker 和 storage 版本都是CentOS 7.x]</h6><pre><code class="java">//创建一个FastDFS文件夹
[imooc@imooc FastDFS]$ ll
总用量 1980
-rw-rw-r--. 1 imooc imooc  800157 7月   9 15:53 fastdfs-6.04.tar.gz
-rw-rw-r--. 1 imooc imooc   19952 7月   9 15:53 fastdfs-nginx-module-1.22.tar.gz
-rw-rw-r--. 1 imooc imooc  164704 7月   9 15:53 libfastcommon-1.0.42.tar.gz
-rw-rw-r--. 1 imooc imooc 1032630 7月   9 15:53 nginx-1.16.1.tar.gz
[imooc@imooc FastDFS]$ tar -zxvf libfastcommon-1.0.42.tar.gz 
[imooc@imooc FastDFS]$ cd libfastcommon-1.0.42/
[imooc@imooc libfastcommon-1.0.42]$ ll
总用量 32
drwxrwxr-x. 2 imooc imooc   114 12月  5 2019 doc
-rw-rw-r--. 1 imooc imooc 10054 12月  5 2019 HISTORY
-rw-rw-r--. 1 imooc imooc   674 12月  5 2019 INSTALL
-rw-rw-r--. 1 imooc imooc  1607 12月  5 2019 libfastcommon.spec
-rwxrwxr-x. 1 imooc imooc  3253 12月  5 2019 make.sh
drwxrwxr-x. 2 imooc imooc   191 12月  5 2019 php-fastcommon
-rw-rw-r--. 1 imooc imooc  2776 12月  5 2019 README
drwxrwxr-x. 3 imooc imooc  4096 12月  5 2019 src
[imooc@imooc libfastcommon-1.0.42]$ ./make.sh
[imooc@imooc libfastcommon-1.0.42]$ sudo ./make.sh install
//安装解压包的本体
[imooc@imooc FastDFS]$ tar -zxvf fastdfs-6.04.tar.gz 
[imooc@imooc FastDFS]$ cd fastdfs-6.04/
[imooc@imooc fastdfs-6.04]$ ./make.sh
[imooc@imooc fastdfs-6.04]$ sudo ./make.sh install
[imooc@imooc fastdfs-6.04]$ cd /usr/bin
[imooc@imooc bin]$ ls fdfs_*
fdfs_appender_test   fdfs_download_file        fdfs_test
fdfs_appender_test1  fdfs_file_info            fdfs_test1
fdfs_append_file     fdfs_monitor              fdfs_trackerd
fdfs_crc32           fdfs_regenerate_filename  fdfs_upload_appender
fdfs_delete_file     fdfs_storaged             fdfs_upload_file
[imooc@imooc bin]$ cd /etc/fdfs/
[imooc@imooc fdfs]$ ll
总用量 28 //这些都是配置文件 如果要修改则需要拷贝一份新鲜的
-rw-r--r--. 1 root root  1834 7月   9 16:02 client.conf.sample
-rw-r--r--. 1 root root 10085 7月   9 16:02 storage.conf.sample
-rw-r--r--. 1 root root   527 7月   9 16:02 storage_ids.conf.sample
-rw-r--r--. 1 root root  8038 7月   9 16:02 tracker.conf.sample

[imooc@imooc FastDFS]$ cd fastdfs-6.04/
[imooc@imooc fastdfs-6.04]$ cd conf/
[imooc@imooc conf]$ ll
总用量 88
-rw-rw-r--. 1 imooc imooc 23981 12月  5 2019 anti-steal.jpg
-rw-rw-r--. 1 imooc imooc  1834 12月  5 2019 client.conf
-rw-rw-r--. 1 imooc imooc   955 12月  5 2019 http.conf
-rw-rw-r--. 1 imooc imooc 31172 12月  5 2019 mime.types
-rw-rw-r--. 1 imooc imooc 10085 12月  5 2019 storage.conf
-rw-rw-r--. 1 imooc imooc   527 12月  5 2019 storage_ids.conf
-rw-rw-r--. 1 imooc imooc  8038 12月  5 2019 tracker.conf
//拷贝到etc下  安装前的准备工作
[imooc@imooc conf]$ sudo cp * /etc/fdfs/
[imooc@imooc conf]$ cd /etc/fdfs
[imooc@imooc fdfs]$ ll
总用量 116
-rw-r--r--. 1 root root 23981 7月   9 16:06 anti-steal.jpg
-rw-r--r--. 1 root root  1834 7月   9 16:06 client.conf
-rw-r--r--. 1 root root  1834 7月   9 16:02 client.conf.sample
-rw-r--r--. 1 root root   955 7月   9 16:06 http.conf
-rw-r--r--. 1 root root 31172 7月   9 16:06 mime.types
-rw-r--r--. 1 root root 10085 7月   9 16:06 storage.conf
-rw-r--r--. 1 root root 10085 7月   9 16:02 storage.conf.sample
-rw-r--r--. 1 root root   527 7月   9 16:06 storage_ids.conf
-rw-r--r--. 1 root root   527 7月   9 16:02 storage_ids.conf.sample
-rw-r--r--. 1 root root  8038 7月   9 16:06 tracker.conf
-rw-r--r--. 1 root root  8038 7月   9 16:02 tracker.conf.sample
</code></pre>
<h3 id="配置tracker服务-一个虚拟机"><a href="#配置tracker服务-一个虚拟机" class="headerlink" title="配置tracker服务 [一个虚拟机]"></a>配置tracker服务 [一个虚拟机]</h3><pre><code class="java">//根据配置文件去区分是哪个服务
[imooc@imooc fdfs]$ cd /etc/fdfs
[imooc@imooc fdfs]$ ll
总用量 116
-rw-r--r--. 1 root root 23981 7月   9 16:06 anti-steal.jpg
-rw-r--r--. 1 root root  1834 7月   9 16:06 client.conf
-rw-r--r--. 1 root root  1834 7月   9 16:02 client.conf.sample
-rw-r--r--. 1 root root   955 7月   9 16:06 http.conf
-rw-r--r--. 1 root root 31172 7月   9 16:06 mime.types
-rw-r--r--. 1 root root 10085 7月   9 16:06 storage.conf
-rw-r--r--. 1 root root 10085 7月   9 16:02 storage.conf.sample
-rw-r--r--. 1 root root   527 7月   9 16:06 storage_ids.conf
-rw-r--r--. 1 root root   527 7月   9 16:02 storage_ids.conf.sample
-rw-r--r--. 1 root root  8038 7月   9 16:06 tracker.conf
-rw-r--r--. 1 root root  8038 7月   9 16:02 tracker.conf.sample
[imooc@imooc fdfs]$ sudo vim tracker.conf  
//里面的port=22122 bind_addr= 计算机节点 这些不动
//修改里面的base_path=/home/yuqing/fastdfs 
    //修改为→ /usr/local/fastdfs/tracker
[imooc@imooc fdfs]$ mkdir /usr/local/fastdfs/tracker -p //-p后面文件夹做递归创建
[imooc@imooc fdfs]$ sudo /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf //当成配置文件加进去 ★★★★★★★★★★★★★★★★★★
[imooc@imooc fdfs]$ ps -ef|grep tracker
root       6254      1  0 18:31 ?        00:00:00 /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf
imooc      6268   3011  0 18:31 pts/0    00:00:00 grep --color=auto tracker
</code></pre>
<h3 id="配置storage服务-另一个虚拟机"><a href="#配置storage服务-另一个虚拟机" class="headerlink" title="配置storage服务 [另一个虚拟机]"></a>配置storage服务 [另一个虚拟机]</h3><pre><code class="java">[storage@imooc fdfs]$ cd /etc/fdfs/
[storage@imooc fdfs]$ sudo vim storage.conf
//[修改后] group_name=imooc 
//[修改后] bath_path=/usr/local/fastdfs/storage
[storage@imooc fdfs]$ sudo mkdir /usr/local/fastdfs/storage -p
[storage@imooc fdfs]$ cd /usr/local/
[storage@imooc local]$ ll
[storage@imooc local]$ cd fastdfs/
[storage@imooc fastdfs]$ ll
[storage@localhost fastdfs]$ ll
总用量 0
drwxr-xr-x. 2 root root 6 7月   9 18:38 storage
[storage@localhost fastdfs]$ cd /etc/fdfs/  //接着修改storage
[storage@imooc fdfs]$ sudo vim storage.conf
//[修改后] store_path0=/usr/local/fastdfs/storage
//配置到tracker的ip地址[修改后] tracker_server=192.168.170.135:22122
/ ‘/8888’  http.server_port=8888 是web的相关端口号
[storage@localhost fdfs]$ sudo /usr/bin/fdfs_storaged /etc/fdfs/storage.conf //★★★★
★一定要先启动tracker 再去启动storage 不然service发不过去★
</code></pre>
<pre><code class="java">//配置客户端做上传动作
[imooc@imooc ~]$ cd /etc/fdfs
[storage@localhost fdfs]$ pwd
/etc/fdfs
[storage@localhost fdfs]$ sudo vim client.conf
//[修改后]base_path=/usr/local/fastdfs/client
[storage@localhost fdfs]$ sudo mkdir /usr/local/fastdfs/client
[storage@localhost fdfs]$ cd /usr/local/fastdfs
[storage@localhost fastdfs]$ ll
总用量 0
drwxr-xr-x. 2 root root  6 7月   9 19:26 client
drwxr-xr-x. 4 root root 30 7月   9 19:04 storage
[storage@localhost fastdfs]$ cd /etc/fdfs/
[storage@localhost fdfs]$ sudo vim client.conf
//[修改后]tracker_server=192.168.170.135:22122
[storage@localhost fdfs]$ cd /usr/bin
[storage@localhost bin]$ ls fdfs*
fdfs_appender_test   fdfs_download_file        fdfs_test
fdfs_appender_test1  fdfs_file_info            fdfs_test1
fdfs_append_file     fdfs_monitor              fdfs_trackerd
fdfs_crc32           fdfs_regenerate_filename  fdfs_upload_appender
fdfs_delete_file     fdfs_storaged             fdfs_upload_file
//fdfs_test在命令行去测试
[storage@localhost bin]$ cd /home/
[storage@localhost home]$ cd /usr/local/fastdfs/storage/
[storage@localhost storage]$ cd data
[storage@localhost data]$ cd 00
[storage@localhost data]$ ll   【里面很多十六进制数据】
[storage@localhost data]$ cd 00 
[storage@localhost data]$ ll   //【里面没有数据 上传图片到这里查看是否成功】
///home/storage 这里有一张测试图片log.png [自行添加]
[storage@localhost 00]$ pwd
/usr/local/fastdfs/storage/data/00/00
[storage@localhost 00]$ cd /etc/fdfs
[storage@localhost ~]$ cd /etc/fdfs/
[storage@localhost fdfs]$ cd /usr/bin/
[storage@localhost bin]$ ls fdfs*
fdfs_appender_test   fdfs_download_file      //fdfs_test
fdfs_appender_test1  fdfs_file_info            fdfs_test1
fdfs_append_file     fdfs_monitor              fdfs_trackerd
fdfs_crc32           fdfs_regenerate_filename  fdfs_upload_appender
fdfs_delete_file     fdfs_storaged             fdfs_upload_file
[storage@localhost bin]$ ./fdfs_test /etc/fdfs/client.conf upload /home/storage/log.png 
/*
This is FastDFS client test program v6.04

Copyright (C) 2008, Happy Fish / YuQing

FastDFS may be copied only under the terms of the GNU General
Public License V3, which may be found in the FastDFS source kit.
Please visit the FastDFS Home Page http://www.fastken.com/ 
for more detail.

[2024-07-09 19:39:25] DEBUG - base_path=/usr/local/fastdfs/client, connect_timeout=10, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0

tracker_query_storage_store_list_without_group: 
    server 1. group_name=, ip_addr=192.168.170.136, port=23000

group_name=imooc【企业简写】, ip_addr=192.168.170.136, port=23000
storage_upload_by_filename
group_name=imooc, remote_filename=M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png 
【remote_filename：重组路径】【因为还没有发布文件服务 所以无法直接查看文件】
source ip address: 192.168.170.136
file timestamp=2024-07-09 19:39:25
file size=12618
file crc32=630904148
example file url: http://192.168.170.136/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
storage_upload_slave_by_filename
group_name=imooc, remote_filename=M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
source ip address: 192.168.170.136
file timestamp=2024-07-09 19:39:25
file size=12618
file crc32=630904148
example file url: http://192.168.170.136/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
 */
[storage@localhost bin]$ cd /usr/local/fastdfs/storage/data/
[storage@localhost data]$ cd 00
[storage@localhost 00]$ cd 00
[storage@localhost 00]$ ll
总用量 40
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png-m
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png-m
</code></pre>
<h3 id="安装Nginx提供Web服务-通过浏览器访问到文件"><a href="#安装Nginx提供Web服务-通过浏览器访问到文件" class="headerlink" title="安装Nginx提供Web服务 [通过浏览器访问到文件]"></a>安装Nginx提供Web服务 [通过浏览器访问到文件]</h3><h6 id="Nginx是反向代理服务器可以做集群-也可以控制多个虚拟主机"><a href="#Nginx是反向代理服务器可以做集群-也可以控制多个虚拟主机" class="headerlink" title="Nginx是反向代理服务器可以做集群 也可以控制多个虚拟主机"></a>Nginx是反向代理服务器可以做集群 也可以控制多个虚拟主机</h6><pre><code class="java">-rw-rw-r--. 1 storage storage 142245547 7月  10 15:32 jdk-7u75-linux-x64.tar.gz
-rw-rw-r--. 1 storage storage   1032630 7月  10 15:33 nginx-1.16.1.tar.gz
//[storage@localhost ~]$ sudo yum install gcc-c++
已加载插件：fastestmirror, langpacks
Determining fastest mirrors
//[storage@localhost ~]$ sudo yum install -y pcre pcre-devel
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
//[storage@localhost ~]$ sudo yum install -y zlib zlib-devel
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
//[storage@localhost ~]$ sudo yum install -y openssl openssl-devel
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
//[storage@localhost ~]$ tar -zxvf nginx-1.16.1.tar.gz
nginx-1.16.1.tar.gz
//[storage@localhost ~]$ cd nginx-1.16.1.tar.gz
[storage@localhost nginx-1.16.1]$ sudo mkdir /var/temp/nginx -p
//创建所需的临时目录：
sudo mkdir -p /var/temp/nginx/client
sudo mkdir -p /var/temp/nginx/proxy
sudo mkdir -p /var/temp/nginx/fastcgi
sudo mkdir -p /var/temp/nginx/uwsgi
sudo mkdir -p /var/temp/nginx/scgi
[storage@localhost nginx-1.16.1]$ ./configure \  //【预配置】
&gt; --prefix=/usr/local/nginx \
&gt; --pid-path=/var/run/nginx/nginx.pid \
&gt; --lock-path=/var/lock/nginx.lock \
&gt; --error-log-path=/var/log/nginx/error.log \
&gt; --http-log-path=/var/log/nginx/access.log \
&gt; --with-http_gzip_static_module \
&gt; --http-client-body-temp-path=/var/temp/nginx/client \
&gt; --http-proxy-temp-path=/var/temp/nginx/proxy \
&gt; --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
&gt; --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
&gt; --http-scgi-temp-path=/var/temp/nginx/scgi
[storage@localhost nginx-1.16.1]$ make  //【编译】
/* linux中的网络不可达
如果镜像出了问题 一定要换一下镜像配置
1. 编辑 CentOS 的 YUM 配置文件：
编辑 /etc/yum.repos.d/CentOS-Base.repo 文件：

复制代码
sudo vi /etc/yum.repos.d/CentOS-Base.repo

2. 使用以下内容更新 CentOS-Base.repo 文件：
复制代码
[base]
name=CentOS-$releasever - Base
baseurl=http://vault.centos.org/7.9.2009/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

[updates]
name=CentOS-$releasever - Updates
baseurl=http://vault.centos.org/7.9.2009/updates/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

[extras]
name=CentOS-$releasever - Extras
baseurl=http://vault.centos.org/7.9.2009/extras/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
*/
[storage@localhost nginx-1.16.1]$ sudo make install
[storage@localhost nginx-1.16.1]$ cd /usr/local
[storage@localhost local]$ ll
总用量 0
drwxr-xr-x. 2 root root  6 4月  11 2018 bin
drwxr-xr-x. 2 root root  6 4月  11 2018 etc
drwxr-xr-x. 4 root root 35 7月   9 19:26 fastdfs
drwxr-xr-x. 2 root root  6 4月  11 2018 games
drwxr-xr-x. 2 root root  6 4月  11 2018 include
drwxr-xr-x. 2 root root  6 4月  11 2018 lib
drwxr-xr-x. 2 root root  6 4月  11 2018 lib64
drwxr-xr-x. 2 root root  6 4月  11 2018 libexec
drwxr-xr-x. 5 root root 42 7月  10 16:55 nginx
drwxr-xr-x. 2 root root  6 4月  11 2018 sbin
drwxr-xr-x. 5 root root 49 7月   9 17:16 share
drwxr-xr-x. 2 root root  6 4月  11 2018 src
[storage@localhost local]$ cd nginx/
[storage@localhost nginx]$ ll
总用量 4
drwxr-xr-x. 2 root root 4096 7月  10 16:55 conf
drwxr-xr-x. 2 root root   40 7月  10 16:55 html
drwxr-xr-x. 2 root root   19 7月  10 16:55 sbin
[storage@localhost nginx]$ cd sbin/
[storage@localhost sbin]$ ll
总用量 3768
-rwxr-xr-x. 1 root root 3857144 7月  10 16:55 nginx
[storage@localhost sbin]$ sudo ./nginx
[storage@localhost sbin]$ ps -ef|grep nginx
root       6642      1  0 16:58 ?        00:00:00 nginx: master process ./nginx
nobody     6643   6642  0 16:58 ?        00:00:00 nginx: worker process
storage    6651   2975  0 16:58 pts/0    00:00:00 grep --color=auto nginx

// 在浏览器输入：http://192.168.170.136/ 【如果没显示应该是虚拟机的防火墙拦截 可以禁止防火墙】
Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.

For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.

Thank you for using nginx.

[storage@localhost nginx]$ cd html
[storage@localhost html]$ ll
总用量 8
-rw-r--r--. 1 root root 494 7月  10 16:55 50x.html
-rw-r--r--. 1 root root 612 7月  10 16:55 index.html

[storage@localhost html]$ sudo ../sbin/nginx -t //【测试刚刚的步骤是否正确】
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
</code></pre>
<h3 id="整合Nginx实现文件服务器"><a href="#整合Nginx实现文件服务器" class="headerlink" title="整合Nginx实现文件服务器"></a>整合Nginx实现文件服务器</h3><pre><code class="java">[storage@localhost FastDFS]$ tar -zxvf fastdfs-nginx-module-1.22.tar.gz 
fastdfs-nginx-module-1.22/
fastdfs-nginx-module-1.22/HISTORY
fastdfs-nginx-module-1.22/INSTALL
fastdfs-nginx-module-1.22/src/
fastdfs-nginx-module-1.22/src/common.c
fastdfs-nginx-module-1.22/src/common.h
fastdfs-nginx-module-1.22/src/config
fastdfs-nginx-module-1.22/src/mod_fastdfs.conf
fastdfs-nginx-module-1.22/src/ngx_http_fastdfs_module.c
[storage@localhost FastDFS]$ cd fastdfs-nginx-module-1.22/
[storage@localhost fastdfs-nginx-module-1.22]$ ll
总用量 8
-rw-rw-r--. 1 storage storage 3036 11月 19 2019 HISTORY
-rw-rw-r--. 1 storage storage 2001 11月 19 2019 INSTALL
drwxrwxr-x. 2 storage storage  109 11月 19 2019 src
[storage@localhost fastdfs-nginx-module-1.22]$ cd src/
[storage@localhost src]$ sudo cp mod_fastdfs.conf /etc/fdfs/
[storage@localhost ~]$ cd /etc/fdfs/
[storage@localhost fdfs]$ sudo vim mod_fastdfs.conf 
//【布置存储路径】
/*
store_path0=/usr/local/fastdfs/storage
tracker_server=192.168.170.135:22122
group_name=imooc
url_have_group_name = true
base_path=/usr/local/fastdfs/tmp
*/
[storage@localhost FastDFS]$ cd fastdfs-nginx-module-1.22/
[storage@localhost fastdfs-nginx-module-1.22]$ cd src/
[storage@localhost src]$ vim config
/local 把带有local的都删掉
[storage@localhost ~]$ cd nginx-1.16.1/
 [storage@localhost nginx-1.16.1]$ 
./configure \
&gt; --prefix=/usr/local/nginx \
&gt; --pid-path=/var/run/nginx/nginx.pid \
&gt; --lock-path=/var/lock/nginx.lock \
&gt; --error-log-path=/var/log/nginx/error.log \
&gt; --http-log-path=/var/log/nginx/access.log \
&gt; --with-http_gzip_static_module \
&gt; --http-client-body-temp-path=/var/temp/nginx/client \
&gt; --http-proxy-temp-path=/var/temp/nginx/proxy \
&gt; --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
&gt; --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
&gt; --http-scgi-temp-path=/var/temp/nginx/scgi \
&gt; --add-module=/home/storage/FastDFS/fastdfs-nginx-module-1.22/src
[storage@localhost nginx-1.16.1]$ sudo make &amp;&amp; sudo make install
[storage@localhost nginx-1.16.1]$ cd /usr/local/nginx/
[storage@localhost nginx]$ cd conf/
[storage@localhost conf]$ sudo vim nginx.conf
/*
server &#123;
        listen       8888;
        server_name  localhost;
        location ~/group[0-9]/ &#123;
        ngx_fastdfs_module;
        &#125;
        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / &#123;
            root   html;
            index  index.html index.htm;
        &#125;

*/
[storage@localhost conf]$ vim /etc/fdfs/tracker.conf
/http.service_port:8080
[storage@localhost conf]$ sudo vim nginx.conf //★★★★★★
/*
server &#123;
        listen       8888;
        server_name  localhost;
        location /imooc/M00 &#123;
            ngx_fastdfs_module;
        &#125;
        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / &#123;
            root   html;
            index  index.html index.htm;
        &#125;
&#125;
*/
[storage@localhost conf]$ sudo ../sbin/nginx -t //测试一下有无问题
ngx_http_fastdfs_set pid=6143
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
[storage@localhost conf]$ sudo ../sbin/nginx -s reload //重新加载
ngx_http_fastdfs_set pid=6436

[storage@localhost conf]$ cd /usr/local/fastdfs/storage/
[storage@localhost storage]$ cd data
[storage@localhost data]$ cd 00/00
总用量 40
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png-m
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png-m
http://192.168.170.136:8888/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png


//查看错误日志 ★★★【sudo tail -n 50 /var/log/nginx/error.log】★★★
/*
2. 重新加载 systemd 并启动 Nginx
重新加载 systemd：
复制代码
sudo systemctl daemon-reload
启动 Nginx：

sh
复制代码
sudo systemctl start nginx
设置开机自启动：

sh
复制代码
sudo systemctl enable nginx
检查 Nginx 服务状态：

sh
复制代码
sudo systemctl status nginx
*/
[storage@localhost conf]$ sudo vim /etc/fdfs/tracker.conf
[storage@localhost conf]$ sudo vim /etc/fdfs/storage.conf

[storage@localhost conf]$ cd /usr/local/nginx/conf/
[storage@localhost conf]$ sudo ../sbin/nginx -s stop
ngx_http_fastdfs_set pid=12586
[storage@localhost conf]$ sudo ../sbin/nginx
ngx_http_fastdfs_set pid=12605
[storage@localhost conf]$ sudo ../sbin/nginx -s reload

/*
FastDFS输出报告位置：
sudo tail -n 50 /usr/local/fastdfs/storage/logs/storaged.log


启动 Tracker 服务器：
sudo systemctl start fdfs_trackerd
检查 Tracker 服务器状态：
sudo systemctl status fdfs_trackerd
确认 Tracker 服务器监听端口：
sudo netstat -tuln | grep :22122
*/
//草！好几个小时的含泪史 一定要先开tracker端！！！
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★

/*
首先，重新启动 FastDFS 的 tracker 和 storage 服务：

bash
复制代码
# 重启 tracker 服务
sudo systemctl restart fdfs_trackerd

# 重启 storage 服务
sudo systemctl restart fdfs_storaged
2. 重启 Nginx 服务
接下来，重新启动 Nginx 服务，确保它能够加载新的配置并生效：

bash
复制代码
sudo systemctl restart nginx
3. 验证服务状态
重新启动服务后，可以通过以下方式验证它们的运行状态：

检查 FastDFS 服务状态：

bash
复制代码
sudo systemctl status fdfs_trackerd
sudo systemctl status fdfs_storaged
检查 Nginx 服务状态：

bash
复制代码
sudo systemctl status nginx
*/

http://192.168.170.136:8888/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
</code></pre>
<h3 id="创建文件服务module-文件上传"><a href="#创建文件服务module-文件上传" class="headerlink" title="创建文件服务module [文件上传]"></a>创建文件服务module [文件上传]</h3><pre><code class="xml">【新建一个module imooc-news-dev-service-files】
pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-files&lt;/artifactId&gt;
&lt;!--
    imooc-news-dev-service-files
    文件服务，文件相关的操作都在此文件中进行
    文件上传   文件下载
    fastdfs  oss  gridfs
--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 文件上传fdfs工具包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
            &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
            &lt;version&gt;1.27.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;



    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yaml">application.yuml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-file
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 512000 #请求文件大小限制为500kb
      max-request-size: 512000
</code></pre>
<pre><code class="yaml">application-dev.yuml
server:
  port: 8004

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/HelloController.java
package com.imooc.files.controller;


import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello()&#123;
        return GraceJSONResult.ok(&quot;Hello World!&quot;);
    &#125;
&#125;




service-files  com/imooc/files/Application.java
package com.imooc.files;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //排除数据源
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
-----------------------------------------------------------------------
http://localhost:8004/hello
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: &quot;Hello World!&quot;
&#125;
</code></pre>
<h3 id="整合fdfs与service实现-文件上传"><a href="#整合fdfs与service实现-文件上传" class="headerlink" title="整合fdfs与service实现 [文件上传]"></a>整合fdfs与service实现 [文件上传]</h3><pre><code class="java">service-api  com/imooc/files/service/impl/UploaderServiceImpl.java
package com.imooc.files.service.impl;

import com.github.tobato.fastdfs.domain.fdfs.StorePath;
import com.github.tobato.fastdfs.service.FastFileStorageClient;
import com.imooc.files.service.UploaderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

@Service
public class UploaderServiceImpl implements UploaderService &#123;
    //注入客户端
    @Autowired
    public FastFileStorageClient fastFileStorageClient;

    @Override
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException &#123;
        StorePath storePath = fastFileStorageClient.uploadFile(file.getInputStream(), file.getSize(), fileExtName, null);
        return storePath.getFullPath();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/files/service/UploaderService.java
package com.imooc.files.service;

import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

public interface UploaderService &#123;
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-file
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 512000 #请求文件大小限制为500kb
      max-request-size: 512000

############################################################
#
# fdfs配置信息
#
############################################################
fdfs:
  connect-timeout: 30
  so-timeout: 30
  tracker-list: 192.168.170.135:22122
</code></pre>
<h3 id="实现fastdfs图片存储-文件上传"><a href="#实现fastdfs图片存储-文件上传" class="headerlink" title="实现fastdfs图片存储 [文件上传]"></a>实现fastdfs图片存储 [文件上传]</h3><pre><code class="java">service-api  com/imooc/api/controller/files/FileUploadControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploadControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // 执行上传
                path = uploaderService.uploadFdfs(file, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);
        return GraceJSONResult.ok(path);
    &#125;
&#125;
//此时去上传图片会报错 报跨域异常错误
//需要在用户service-user里的Application 
//@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
//贴到com/imooc/files/Application.java

此时再次 http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html
提交头像
Console：
06:09.827 [http-nio-8004-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
06:09.827 [http-nio-8004-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet &#39;dispatcherServlet&#39;
06:09.832 [http-nio-8004-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 5 ms
06:09.882 [http-nio-8004-exec-2] INFO  c.imooc.api.aspect.ServiceLogAspect - ==== 开始执行 class com.imooc.files.service.impl.UploaderServiceImpl.uploadFdfs ====
06:09.937 [http-nio-8004-exec-2] INFO  c.imooc.api.aspect.ServiceLogAspect - 当前执行耗时：55
06:09.937 [http-nio-8004-exec-2] INFO  c.i.f.c.FileUploadController - path = imooc/M00/00/00/wKiqiGaPrpKAEt22AAAeb3kUsrg507.png

http://192.168.170.136:8888/imooc/M00/00/00/wKiqiGaPrpKAEt22AAAeb3kUsrg507.png
此时就可以看到Cat的图片了！
</code></pre>
<h3 id="完善用户头像上传"><a href="#完善用户头像上传" class="headerlink" title="完善用户头像上传"></a>完善用户头像上传</h3><pre><code class="java">【在用户返回的时候写死路径+path】
return GraceJSONResult.ok(&quot;http://192.168.170.136:8888/&quot;path);

给它包装一下 FileResource写一下
service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.files.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // 执行上传
                path = uploaderService.uploadFdfs(file, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
            finalPath = fileResource.getHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
        return GraceJSONResult.ok(finalPath);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/FileResource.java
package com.imooc.files;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(&quot;classpath:file-$&#123;spring.profiles.active&#125;.properties &quot;) //这个是在application.yml里面的 自动匹配
@ConfigurationProperties(prefix = &quot;file&quot;)
public class FileResource &#123;
    private String host;

    public String getHost() &#123;
        return host;
    &#125;

    public void setHost(String host) &#123;
        this.host = host;
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">file-dev.properties
# fastdfs storage 节点地址(nginx整合的web服务)
file.host=http://192.168.170.136:8888/


application.yml
############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-file
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 512000 #请求文件大小限制为500kb
      max-request-size: 512000
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
此时拦截器也要加一层
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UseActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UseActiveInterceptor useActiveInterceptor()&#123;
        return new UseActiveInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);
//        registry.addInterceptor(userTokenInterceptor())
//                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="图片大小控制的统一异常处理"><a href="#图片大小控制的统一异常处理" class="headerlink" title="图片大小控制的统一异常处理"></a>图片大小控制的统一异常处理</h3><pre><code class="java">dev-common  com/imooc/exception/GraceExceptionHandler.java
package com.imooc.exception;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MaxUploadSizeExceededException;

/**
 * 统一异常拦截处理
 * 可以针对异常的类型进行捕获 然后返回json信息到前端
 */
@ControllerAdvice
public class GraceExceptionHandler &#123;
    @ExceptionHandler(MyCustomException.class)
    //只要是这个类的异常都会进入下面的方法
    @ResponseBody
    public GraceJSONResult returnMyException(MyCustomException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.exception(e.getResponseStatusEnum());
    &#125;

    @ExceptionHandler(MaxUploadSizeExceededException.class)
    @ResponseBody
    public GraceJSONResult returnMaxUploadSizeExceededException(MaxUploadSizeExceededException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_MAX_SIZE_ERROR);
    &#125;
&#125;
</code></pre>
<h3 id="第三方云存储解决方案-【阿里OSS】"><a href="#第三方云存储解决方案-【阿里OSS】" class="headerlink" title="第三方云存储解决方案 【阿里OSS】"></a>第三方云存储解决方案 【阿里OSS】</h3><h5 id="FastDFS-中小型公司使用"><a href="#FastDFS-中小型公司使用" class="headerlink" title="FastDFS [中小型公司使用]"></a>FastDFS [中小型公司使用]</h5><ul>
<li>水平扩容</li>
<li>运维复杂</li>
<li>开发复杂【增加图片效果 &amp; 人脸识别等】</li>
</ul>
<h5 id="云存储阿里OSS"><a href="#云存储阿里OSS" class="headerlink" title="云存储阿里OSS"></a><span style = "color:red">云存储阿里OSS</span></h5><ul>
<li>SDK使用简单 [Java对接]</li>
<li>提供强大的文件处理功能</li>
<li>零运维成本</li>
<li>图形化管理控制台</li>
<li>CDN加速</li>
<li>降低风险管理成本</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://common-buy.aliyun.com/?commodityCode=ossbag&spm=5176.28061389.commonbuy2container.oss_rc_dp_cn_ZjqTabLinks_2.3949778b3uJsQM&regionId=cn-inland-common&accounttraceid=f8f4fe13a682404d8cab9b0254ae864ddivk">对象存储 OSS 资源包 (aliyun.com)</a>[购买 <strong><u>标准-本地冗余存储</u></strong> ＋ <u><strong>下行流量</strong></u> ]</p>
<h3 id="控制台的基本配置使用-【阿里OSS】"><a href="#控制台的基本配置使用-【阿里OSS】" class="headerlink" title="控制台的基本配置使用 【阿里OSS】"></a>控制台的基本配置使用 【阿里OSS】</h3><p><a target="_blank" rel="noopener" href="https://oss.console.aliyun.com/overview">OSS管理控制台 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://billing-cost.console.aliyun.com/home/myfreetier?spm=5176.29188366.free-tier.4.47553e4dvJ4jbs">费用与成本 (aliyun.com)我的试用</a></p>
<ul>
<li>对象存储OSS → Bucket列表 → 创建Bucket → 存储冗余类型:<u>本地冗余存储</u> → 读写权限:<u>公共读</u></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://oss.console.aliyun.com/bucket/oss-cn-shanghai/iimooc-news-dev/object">OSS管理控制台 (aliyun.com)</a></p>
<ul>
<li>创建成功后进入<u>iimooc-news-dev&#x2F;object</u> → 文件管理 → 文件列表 →<br><a target="_blank" rel="noopener" href="https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/log.png">https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/log.png</a></li>
</ul>
<pre><code class="xml">dev-common  pom.xml
&lt;dependency&gt;
  &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
  &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
  &lt;version&gt;3.10.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>对象存储OSS → SDK文档 → <strong>上传网络流</strong></li>
<li>对象存储OSS → iimooc-news-dev → 概览 → 访问端口: 外网访问 <u>oss-cn-shanghai.aliyuncs.com</u></li>
</ul>
<h3 id="SDK的使用与项目整合"><a href="#SDK的使用与项目整合" class="headerlink" title="SDK的使用与项目整合"></a>SDK的使用与项目整合</h3><pre><code class="java">service-file  com/imooc/files/service/UploaderService.java
package com.imooc.files.service;

import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

public interface UploaderService &#123;
    /**
     * 使用fastdfs 上传文件
     */
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException;

    /**
     * 使用OSS 上传文件
     */
    public String uploadOSS(MultipartFile file,String userId, String fileExtName) throws IOException;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/service/impl/UploaderServiceImpl.java
package com.imooc.files.service.impl;

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.github.tobato.fastdfs.domain.fdfs.StorePath;
import com.github.tobato.fastdfs.service.FastFileStorageClient;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.utils.extend.AliyunResource;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;

@Service
public class UploaderServiceImpl implements UploaderService &#123;
    //注入客户端
    @Autowired
    public FastFileStorageClient fastFileStorageClient;
    @Autowired
    public FileResource fileResource;
    @Autowired
    public AliyunResource aliyunResource;
    @Autowired
    public Sid sid;

    @Override
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException &#123;
        StorePath storePath = fastFileStorageClient.uploadFile(file.getInputStream(), file.getSize(), fileExtName, null);
        return storePath.getFullPath();
    &#125;

    @Override
    public String uploadOSS(MultipartFile file, String userId, String fileExtName) throws IOException &#123;
        // Endpoint以杭州为例，其它Region请按实际情况填写。
        // 外网访问：oss-cn-shanghai.aliyuncs.com
        String endpoint = fileResource.getEndpoint();
        // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。
        String accessKeyId = aliyunResource.getAccessKeyID();
        String accessKeySecret = aliyunResource.getAccessKeySecret();

        // 创建OSSClient实例。
        OSS ossClient = new OSSClientBuilder().build(endpoint,
                accessKeyId,
                accessKeySecret);
        //  images/abc/10010/cat.png  路径不全 所以需要myObjectName拼接
        String fileName = sid.nextShort();
        String myObjectName = fileResource.getObjectName()
                + &quot;/&quot; + userId + &quot;/&quot; + fileName + &quot;.&quot; + fileExtName;

        // 上传网络流。
        InputStream inputStream = file.getInputStream();
        ossClient.putObject(fileResource.getBucketName(),
                myObjectName,
                inputStream);

        // 关闭OSSClient。
        ossClient.shutdown();
        return myObjectName;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/resource/FileResource.java
package com.imooc.files.resource;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(&quot;classpath:file-$&#123;spring.profiles.active&#125;.properties &quot;) //这个是在application.yml里面的 自动匹配
@ConfigurationProperties(prefix = &quot;file&quot;)
public class FileResource &#123;
    private String host;
    private String endpoint;
    private String BucketName;
    private String objectName;
&#125;Getter + Setter
</code></pre>
<pre><code class="mysql">file-dev.properties
# fastdfs storage ????(nginx???web??)
file.host=http://192.168.170.136:8888/

# aliyun OSS
file.endpoint=oss-cn-shanghai.aliyuncs.com

file.BucketName=iimooc-news-dev

# url name
file.objectName=images/abc
</code></pre>
<h3 id="OSS整合实现文件上传"><a href="#OSS整合实现文件上传" class="headerlink" title="OSS整合实现文件上传"></a>OSS整合实现文件上传</h3><pre><code class="java"> // OSS执行上传
//  path = uploaderService.uploadOSS(file, userId, suffix);

service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // fdfs执行上传
//                path = uploaderService.uploadFdfs(file, suffix);
                // OSS执行上传
                path = uploaderService.uploadOSS(file, userId, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
            finalPath = fileResource.getHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
        return GraceJSONResult.ok(finalPath);
    &#125;
&#125;

=================================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html
此时更改头像上传后 头像会在OSS服务器的文件里面显示
</code></pre>
<pre><code class="mysql">file-dev.properties / file-prod.properties
# fastdfs storage ????(nginx???web??)
file.host=http://192.168.170.136:8888/

# aliyun OSS
file.endpoint=oss-cn-shanghai.aliyuncs.com

file.BucketName=iimooc-news-dev

# url name
file.objectName=images/abc

file.ossHost=https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/
</code></pre>
<pre><code class="java">service-files  com/imooc/files/resource/FileResource.java
@Component
@PropertySource(&quot;classpath:file-$&#123;spring.profiles.active&#125;.properties &quot;) //这个是在application.yml里面的 自动匹配
@ConfigurationProperties(prefix = &quot;file&quot;)
public class FileResource &#123;
    private String host;
    private String endpoint;
    private String BucketName;
    private String objectName;
    private String OssHost;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
    //用OSS执行上传 而不是 fdfs执行上传
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // fdfs执行上传
//                path = uploaderService.uploadFdfs(file, suffix);
                // OSS执行上传
                path = uploaderService.uploadOSS(file, userId, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
//            finalPath = fileResource.getHost() + path;
            finalPath = fileResource.getOssHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
        return GraceJSONResult.ok(finalPath);
    &#125;
&#125;
</code></pre>
<h3 id="图片自动审核-【阿里内容安全】"><a href="#图片自动审核-【阿里内容安全】" class="headerlink" title="图片自动审核 【阿里内容安全】"></a>图片自动审核 【阿里内容安全】</h3><h6 id="多媒体内容风险智能识别服务，降低色情、暴力、恐怖-由于太贵了就不买了-1000多呢"><a href="#多媒体内容风险智能识别服务，降低色情、暴力、恐怖-由于太贵了就不买了-1000多呢" class="headerlink" title="多媒体内容风险智能识别服务，降低色情、暴力、恐怖 (由于太贵了就不买了 1000多呢)"></a>多媒体内容风险智能识别服务，降低色情、暴力、恐怖 (<u>由于太贵了就不买了 1000多呢</u>)</h6><pre><code class="xml">dev-common  pom.xml
 &lt;!-- 第三方云厂商相关的依赖 --&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
            &lt;version&gt;3.10.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-green&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.51&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-codec&lt;/groupId&gt;
            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
            &lt;version&gt;1.10&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/extend/AliImageReviewUtils.java
package com.imooc.utils.extend;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.green.model.v20180509.ImageSyncScanRequest;
import com.aliyuncs.http.FormatType;
import com.aliyuncs.http.HttpResponse;
import com.aliyuncs.http.MethodType;
import com.aliyuncs.http.ProtocolType;
import com.aliyuncs.profile.DefaultProfile;
import com.aliyuncs.profile.IClientProfile;
import com.imooc.enums.ArticleReviewLevel;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Date;
import java.util.UUID;

@Component
public class AliImageReviewUtils &#123;

//    文档地址：https://help.aliyun.com/document_detail/70292.html?spm=a2c4g.11186623.2.49.6f9c75fdjaW30p#reference-fzy-ztm-v2b

    @Autowired
    private AliyunResource aliyunResource;

    public boolean reviewImage(String imgUrl) throws Exception &#123;
        IClientProfile profile = DefaultProfile
                .getProfile(&quot;cn-shanghai&quot;, &quot;&quot;, &quot;&quot;);
        DefaultProfile
                .addEndpoint(&quot;cn-shanghai&quot;, &quot;cn-shanghai&quot;, &quot;Green&quot;, &quot;green.cn-shanghai.aliyuncs.com&quot;);
        IAcsClient client = new DefaultAcsClient(profile);

        ImageSyncScanRequest imageSyncScanRequest = new ImageSyncScanRequest();
        // 指定api返回格式
        imageSyncScanRequest.setAcceptFormat(FormatType.JSON);
        // 指定请求方法
        imageSyncScanRequest.setMethod(MethodType.POST);
        imageSyncScanRequest.setEncoding(&quot;utf-8&quot;);
        //支持http和https
        imageSyncScanRequest.setProtocol(ProtocolType.HTTP);


        JSONObject httpBody = new JSONObject();
        /**
         * 设置要检测的场景, 计费是按照该处传递的场景进行
         * 一次请求中可以同时检测多张图片，每张图片可以同时检测多个风险场景，计费按照场景计算
         * 例如：检测2张图片，场景传递porn、terrorism，计费会按照2张图片鉴黄，2张图片暴恐检测计算
         * porn: porn表示色情场景检测
         * logo: 商标
         * 其他详见官方文档
         */
        httpBody.put(&quot;scenes&quot;, Arrays.asList(&quot;terrorism&quot;));

        /**
         * 设置待检测图片， 一张图片一个task
         * 多张图片同时检测时，处理的时间由最后一个处理完的图片决定
         * 通常情况下批量检测的平均rt比单张检测的要长, 一次批量提交的图片数越多，rt被拉长的概率越高
         * 这里以单张图片检测作为示例, 如果是批量图片检测，请自行构建多个task
         */
        JSONObject task = new JSONObject();
        task.put(&quot;dataId&quot;, UUID.randomUUID().toString());

        //设置图片链接
        task.put(&quot;url&quot;, imgUrl);
        task.put(&quot;time&quot;, new Date());
        httpBody.put(&quot;tasks&quot;, Arrays.asList(task));

        imageSyncScanRequest.setHttpContent(org.apache.commons.codec.binary.StringUtils.getBytesUtf8(httpBody.toJSONString()),
                &quot;UTF-8&quot;, FormatType.JSON);

        /**
         * 请设置超时时间, 服务端全链路处理超时时间为10秒，请做相应设置
         * 如果您设置的ReadTimeout小于服务端处理的时间，程序中会获得一个read timeout异常
         */
        imageSyncScanRequest.setConnectTimeout(3000);
        imageSyncScanRequest.setReadTimeout(10000);
        HttpResponse httpResponse = null;
        try &#123;
            httpResponse = client.doAction(imageSyncScanRequest);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        //服务端接收到请求，并完成处理返回的结果
        if (httpResponse != null &amp;&amp; httpResponse.isSuccess()) &#123;
            JSONObject scrResponse = JSON.parseObject(org.apache.commons.codec.binary.StringUtils.newStringUtf8(httpResponse.getHttpContent()));
            System.out.println(JSON.toJSONString(scrResponse, true));
            int requestCode = scrResponse.getIntValue(&quot;code&quot;);
            //每一张图片的检测结果
            JSONArray taskResults = scrResponse.getJSONArray(&quot;data&quot;);
            if (200 == requestCode) &#123;
                for (Object taskResult : taskResults) &#123;
                    //单张图片的处理结果
                    int taskCode = ((JSONObject) taskResult).getIntValue(&quot;code&quot;);
                    //图片要检测的场景的处理结果, 如果是多个场景，则会有每个场景的结果
                    JSONArray sceneResults = ((JSONObject) taskResult).getJSONArray(&quot;results&quot;);
                    if (200 == taskCode) &#123;
                        Object sceneResult = sceneResults.get(0);
//                        for (Object sceneResult : sceneResults) &#123;
                        String scene = ((JSONObject) sceneResult).getString(&quot;scene&quot;);
                        String suggestion = ((JSONObject) sceneResult).getString(&quot;suggestion&quot;);
                        //根据scene和suggetion做相关处理
                        //do something
                        System.out.println(&quot;scene = [&quot; + scene + &quot;]&quot;);
                        System.out.println(&quot;suggestion = [&quot; + suggestion + &quot;]&quot;);

                        return suggestion.equalsIgnoreCase(ArticleReviewLevel.PASS.type) ? true : false;
//                        &#125;
                    &#125; else &#123;
                        //单张图片处理失败, 原因视具体的情况详细分析
                        System.out.println(&quot;task process fail. task response:&quot; + JSON.toJSONString(taskResult));
                        return false;
                    &#125;
                &#125;
            &#125; else &#123;
                /**
                 * 表明请求整体处理失败，原因视具体的情况详细分析
                 */
                System.out.println(&quot;the whole image scan request failed. response:&quot; + JSON.toJSONString(scrResponse));
                return false;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/crisschan/article/details/136866137">解决github Push rejected报错 remote: error: GH013: Repository rule violations found for refs&#x2F;heads&#x2F;maste_github push declined due to repository rule violat-CSDN博客</a></p>
<pre><code class="java">dev-common  com/imooc/enums/ArticleReviewLevel.java
package com.imooc.enums;

/**
 * @Desc: 文章自动审核结果 枚举
 */
public enum ArticleReviewLevel &#123;
    PASS(&quot;pass&quot;, &quot;自动审核通过&quot;),
    BLOCK(&quot;block&quot;, &quot;自动审核不通过&quot;),
    REVIEW(&quot;review&quot;, &quot;建议人工复审&quot;);

    public final String type;
    public final String value;

    ArticleReviewLevel(String type, String value) &#123;
        this.type = type;
        this.value = value;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;

import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.extend.AliImageReviewUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Autowired
    private AliImageReviewUtils aliImageReviewUtils;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // fdfs执行上传     要让外面得以访问 ①需要把内网的环境发布到公网 [内网穿透]  ②路由器端口映射到外网  ③fastdfs安装到公网里
//                path = uploaderService.uploadFdfs(file, suffix);
                // OSS执行上传
                path = uploaderService.uploadOSS(file, userId, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
//            finalPath = fileResource.getHost() + path;
            finalPath = fileResource.getOssHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
           return GraceJSONResult.ok(finalPath);
       // return GraceJSONResult.ok(doAliImageReview(finalPath)); //这里加了图片审核咯
    &#125;

    /**
     * fastdfs 默认存在于内网，无法被阿里云内容管理服务检查到
     * 需要配置到公网才行：
     * 1. 内网穿透，natppp/花生壳/ngrok
     * 2. 路由配置端口映射
     * 3. fdfs 发布到云服务器
     */

   /* 功能实现不了图片识别 因为没有开通内容安全需要企业认证
     public static final String FAILED_IMAGE_URL = &quot;https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/240629F21AK1BHX4/Review_Failed.png&quot;; //这里保存审核失败的照片 提前上传到Oss里直接用
    private String doAliImageReview(String pendingImageUrl)&#123;
        boolean result = false;
        try &#123;
            result = aliImageReviewUtils.reviewImage(pendingImageUrl);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        if (!result)&#123;
            return FAILED_IMAGE_URL;
        &#125;
        return pendingImageUrl;
    &#125;
&#125;
*/
</code></pre>
<h3 id="创建阿里云子账号-【阿里内容安全】"><a href="#创建阿里云子账号-【阿里内容安全】" class="headerlink" title="创建阿里云子账号 【阿里内容安全】"></a>创建阿里云子账号 【阿里内容安全】</h3><p><a target="_blank" rel="noopener" href="https://ram.console.aliyun.com/users">RAM访问控制 → 用户</a><br>[实在不行了 凑合着搞一下吧 功能实现不了图片识别 因为没有开通内容安全需要企业认证]</p>
<blockquote>
<p>登录名称：imooc-news-dev<br>显示名称：用于内容审核<br>√  OpenAPI访问调用<br>AccessKey ID：<br>AccessKeySeret：</p>
<p>点击左侧列表下方 授权 → 新增授权 【授权主体：用于内容审核      权限策略：搜：green   … 管理内容安全的权限】</p>
</blockquote>
<h3 id="构建admin服务"><a href="#构建admin服务" class="headerlink" title="构建admin服务"></a>构建admin服务</h3><ul>
<li>构建admin管理服务</li>
<li>文章分类管理</li>
<li>友情连接管理</li>
<li>用户账号管理</li>
<li>文章内容人工审核 [放在文章上传后的自动审核]</li>
<li>admin管理人员账号分配 [用户人脸]</li>
</ul>
<pre><code class="xml">service-admin  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-admin&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;


&lt;/project&gt;
</code></pre>
<pre><code class="xml">service-admin  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-admin&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-admin&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/service-admin.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">service-admin:8005
package com.imooc.admin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/HelloController.java
package com.imooc.admin.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
----------------------------------------------------------------------------
http://admin.imoocnews.com:8005/hello

application-dev.yml
server:
  port: 8005

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
</code></pre>
<h3 id="表设计与账号预分配-【admin账号】"><a href="#表设计与账号预分配-【admin账号】" class="headerlink" title="表设计与账号预分配 【admin账号】"></a>表设计与账号预分配 【admin账号】</h3><pre><code class="xml">service-admin  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
            &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/PWDTest.java
package com.imooc.admin.controller;

import org.springframework.security.crypto.bcrypt.BCrypt;

public class PWDTest &#123;
    public static void main(String[] args) &#123;
        String pwd = BCrypt.hashpw(&quot;admin&quot;, BCrypt.gensalt());//加盐
        System.out.println(pwd);
    &#125;
&#125;
</code></pre>
<h3 id="持久层查询管理员-【admin账号】"><a href="#持久层查询管理员-【admin账号】" class="headerlink" title="持久层查询管理员 【admin账号】"></a>持久层查询管理员 【admin账号】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/login.html">http://admin.imoocnews.com:9090/imooc-news/admin/login.html</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">Windows下如何查看某个端口被谁占用 | 菜鸟教程 (runoob.com)</a></p>
<pre><code class="java">//更改一下mybatis-generator-database里面的generatorConfig-admin.xml
数据库表为：admin_user
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;!-- 通用mapper所在目录 --&gt;
        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;com.imooc.my.mapper.MyMapper&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/imooc-news-dev&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 对应生成的pojo所在包 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.imooc.pojo&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot;/&gt;

        &lt;!-- 对应生成的mapper所在目录 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper.admin&quot; targetProject=&quot;mybatis-generator-database/src/main/resources&quot;/&gt;

        &lt;!-- 配置mapper对应的java映射 --&gt;
        &lt;javaClientGenerator targetPackage=&quot;com.imooc.admin.mapper&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt;

        &lt;!-- 数据库表 --&gt;
        &lt;table tableName=&quot;admin_user&quot;&gt;&lt;/table&gt;

    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="java">mybatis-generator-database的把AdminUser拷贝到dev-model的com/imooc/pojo下
mybatis-generator-database的把AdminUserMapper拷贝到service-admin的resources mapper/AdminUserMapper.xml
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);
&#125;



service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.service.AdminUserService;
import com.imooc.pojo.AdminUser;
import org.springframework.beans.factory.annotation.Autowired;
import tk.mybatis.mapper.entity.Example;

public class AdminUserServiceImpl implements AdminUserService &#123;
    @Autowired
    public AdminUserMapper adminUserMapper;
    @Override
    public AdminUser queryAdminByUsername(String username) &#123;
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria Criteria = adminExample.createCriteria();
        Criteria.andEqualTo(&quot;username&quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/mapper/AdminUserMapper.java
package com.imooc.admin.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.AdminUser;
import org.springframework.stereotype.Repository;

@Repository
public interface AdminUserMapper extends MyMapper&lt;AdminUser&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">service-admin  mapper/AdminUserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.admin.mapper.AdminUserMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.AdminUser&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;face_id&quot; property=&quot;faceId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;admin_name&quot; property=&quot;adminName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;updated_time&quot; property=&quot;updatedTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="用户名密码登录-【admin账号】"><a href="#用户名密码登录-【admin账号】" class="headerlink" title="用户名密码登录 【admin账号】"></a>用户名密码登录 【admin账号】</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/arjelarxfc/article/details/78806384">Spring里遇到的一个问题，autowired时报找不到bean定义_autowired找不到bean-CSDN博客</a></p>
<h6 id="其次上述问题一定要去找Controller-Service-ServiceImpl-和-启动类里面的有没有正确扫描包-MapperScan-basePackages-x3D-“com-imooc-admin-mapper”"><a href="#其次上述问题一定要去找Controller-Service-ServiceImpl-和-启动类里面的有没有正确扫描包-MapperScan-basePackages-x3D-“com-imooc-admin-mapper”" class="headerlink" title="其次上述问题一定要去找Controller Service ServiceImpl 和 启动类里面的有没有正确扫描包@MapperScan(basePackages &#x3D; “com.imooc.admin.mapper”)"></a>其次上述问题一定要去找Controller Service ServiceImpl 和 启动类里面的有没有正确扫描包@MapperScan(basePackages &#x3D; “com.imooc.admin.mapper”)</h6><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.AdminUserService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.AdminMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AdminMngController.class);

    @Autowired
    private AdminUserService adminUserService;

    @Autowired
    private RedisOperator redis;

    @Override
    public Object adminLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1.查询admin用户的信息
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        // 2.判断admin不为空，如果为空则登录失败
        if (admin == null) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
        // 3.判断密码是否匹配
        boolean isPwdMath = BCrypt.checkpw(adminLoginBO.getPassword(), admin.getPassword());
        if (isPwdMath)&#123;
            doLoginSettings(admin,request,response);
            return GraceJSONResult.ok();
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
    &#125;

    /**
     * 用于admin用户登录过后的基本信息设置
     */
    private void doLoginSettings(AdminUser admin, HttpServletRequest request, HttpServletResponse response)&#123;
        // 保存token放入到redis中
        String token = UUID.randomUUID().toString();
        redis.set(REDIS_ADMIN_TOKEN + &quot;:&quot; + admin.getId(),token);

        // 保存admin登录基本token信息到cookie中
        setCookie(request, response, &quot;atoken&quot;, token, COOKIE_MONTH);
        setCookie(request, response, &quot;aid&quot;, admin.getId(), COOKIE_MONTH);
        setCookie(request, response, &quot;aname&quot;, admin.getAdminName(), COOKIE_MONTH);
    &#125;
&#125;
---------------------------------------------------------------------------------
http://admin.imoocnews.com:9090/imooc-news/admin/login.html
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.service.AdminUserService;
import com.imooc.pojo.AdminUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

@Service
public class AdminUserServiceImpl implements AdminUserService &#123;
    @Autowired
    public AdminUserMapper adminUserMapper;
    @Override
    public AdminUser queryAdminByUsername(String username) &#123;
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria Criteria = adminExample.createCriteria();
        Criteria.andEqualTo(&quot;username&quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/mapper/AdminUserMapper.java
package com.imooc.admin.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.AdminUser;
import org.springframework.stereotype.Repository;

@Repository
public interface AdminUserMapper extends MyMapper&lt;AdminUser&gt; &#123;
&#125;


service-admin  resources/mapper/AdminUserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.admin.mapper.AdminUserMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.AdminUser&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;face_id&quot; property=&quot;faceId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;admin_name&quot; property=&quot;adminName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;updated_time&quot; property=&quot;updatedTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/Application.java
package com.imooc.admin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.admin.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">service-admin  application-dev.yml
server:
  port: 8005

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
## setup CN from java, This is resource
website:
  domain-name: imoocnews.com

## open mybatis log in dev
#mybatis:
#  configuration:
#    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
#
</code></pre>
<h3 id="校验admin账号唯一-【admin账号】"><a href="#校验admin账号唯一-【admin账号】" class="headerlink" title="校验admin账号唯一 【admin账号】"></a>校验admin账号唯一 【admin账号】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html</a></p>
<pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java

  @Override
    public Object adminLogin(String username) &#123;
        checkAdminExist(username);
        return GraceJSONResult.ok();
    &#125;
    private void checkAdminExist(String username)&#123;
        AdminUser admin = adminUserService.queryAdminByUsername(username);
        if (admin != null)&#123;
            GraceException.display(ResponseStatusEnum.ADMIN_USERNAME_EXIST_ERROR);
        &#125;

    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.pojo.bo.AdminLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;,tags = &#123;&quot;管理员admin维护的Controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public Object adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                             HttpServletRequest request,
                             HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;,notes = &quot;查询admin用户名是否存在&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public Object adminLogin(@RequestParam String username); //传回来
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UseActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UseActiveInterceptor useActiveInterceptor()&#123;
        return new UseActiveInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);

        //        registry.addInterceptor(userTokenInterceptor())
//                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="创建admin账号-【admin账号】"><a href="#创建admin账号-【admin账号】" class="headerlink" title="创建admin账号 【admin账号】"></a>创建admin账号 【admin账号】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/userList.html">用户管理 | 运营管理平台 (imoocnews.com)</a><br><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html</a></p>
<pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.AdminUserService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.AdminMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AdminMngController.class);

    @Autowired
    private AdminUserService adminUserService;

    @Autowired
    private RedisOperator redis;

    @Override
    public GraceJSONResult adminLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1.查询admin用户的信息
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        // 2.判断admin不为空，如果为空则登录失败
        if (admin == null) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
        // 3.判断密码是否匹配
        boolean isPwdMath = BCrypt.checkpw(adminLoginBO.getPassword(), admin.getPassword());
        if (isPwdMath)&#123;
            doLoginSettings(admin,request,response);
            return GraceJSONResult.ok();
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
    &#125;


    /**
     * 用于admin用户登录过后的基本信息设置
     */
    private void doLoginSettings(AdminUser admin, HttpServletRequest request, HttpServletResponse response)&#123;
        // 保存token放入到redis中
        String token = UUID.randomUUID().toString();
        redis.set(REDIS_ADMIN_TOKEN + &quot;:&quot; + admin.getId(),token);

        // 保存admin登录基本token信息到cookie中
        setCookie(request, response, &quot;atoken&quot;, token, COOKIE_MONTH);
        setCookie(request, response, &quot;aid&quot;, admin.getId(), COOKIE_MONTH);
        setCookie(request, response, &quot;aname&quot;, admin.getAdminName(), COOKIE_MONTH);
    &#125;


    @Override
    public GraceJSONResult adminLogin(String username) &#123;
        checkAdminExist(username);
        return GraceJSONResult.ok();
    &#125;

    private void checkAdminExist(String username)&#123;
        AdminUser admin = adminUserService.queryAdminByUsername(username);
        if (admin != null)&#123;
            GraceException.display(ResponseStatusEnum.ADMIN_USERNAME_EXIST_ERROR);
        &#125;

    &#125;

    @Override
    public GraceJSONResult addNewAdmin(NewAdminBO newAdminBO,HttpServletRequest request,HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1. base64不为空，则代表人脸入库，否则需要用户输入密码和确认密码
        if (StringUtils.isBlank(newAdminBO.getImg64()))&#123;
            if (StringUtils.isBlank(newAdminBO.getPassword()) || StringUtils.isBlank(newAdminBO.getConfirmPassword()))&#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_NULL_ERROR);
            &#125;
        &#125;
        // 2. 密码不为空，则必须判断两次输入一致
        if (StringUtils.isNotBlank(newAdminBO.getPassword())) &#123;
            if (!newAdminBO.getPassword().equalsIgnoreCase(newAdminBO.getConfirmPassword())) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_ERROR);
            &#125;
        &#125;
        // 3. 校验用户名唯一
        checkAdminExist(newAdminBO.getUsername());

        // 4.调用service存入admin信息
        adminUserService.createAdminUser(newAdminBO);
        return GraceJSONResult.ok();
    &#125;

&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;,tags = &#123;&quot;管理员admin维护的Controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public GraceJSONResult adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;,notes = &quot;查询admin用户名是否存在&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public GraceJSONResult adminLogin(@RequestParam String username); //传回来

    @ApiOperation(value = &quot;创建admin&quot;,notes = &quot;创建admin&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/addNewAdmin&quot;)
    public GraceJSONResult addNewAdmin(@RequestBody NewAdminBO newAdminBO,HttpServletRequest request,HttpServletResponse response); //传回来
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.service.AdminUserService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;

@Service
public class AdminUserServiceImpl implements AdminUserService &#123;
    @Autowired
    public AdminUserMapper adminUserMapper;
    @Autowired
    public Sid sid;
    @Override
    public AdminUser queryAdminByUsername(String username) &#123;
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria Criteria = adminExample.createCriteria();
        Criteria.andEqualTo(&quot;username&quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    &#125;

    @Override
    public void createAdminUser(NewAdminBO newAdminBO) &#123;
        String adminId = sid.nextShort(); //获得主键
        AdminUser adminUser = new AdminUser();
        adminUser.setId(adminId);
        adminUser.setUsername(newAdminBO.getUsername());
        adminUser.setAdminName(newAdminBO.getAdminName());
        // 如果密码不为空 则密码需要加密 存入数据库
        if (StringUtils.isNotBlank(newAdminBO.getPassword()))&#123;
            String pwd = BCrypt.hashpw(newAdminBO.getPassword(), BCrypt.gensalt());
            adminUser.setPassword(pwd);
        &#125;

        // 如果人脸上传以后，则有faceId，需要和admin信息关联存储入库
        if (StringUtils.isNotBlank(newAdminBO.getFaceId()))&#123;
            adminUser.setFaceId(newAdminBO.getFaceId());
        &#125;
        adminUser.setCreatedTime(new Date());
        adminUser.setUpdatedTime(new Date());

        int insert = adminUserMapper.insert(adminUser);
        if (insert != 1)&#123;
            GraceException.display(ResponseStatusEnum.ADMIN_CREATE_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);

    /**
     * 新增管理员
     *
     * @param newAdminBO
     */
    public void createAdminUser(NewAdminBO newAdminBO);
&#125;
</code></pre>
<h3 id="查看admin列表-【admin账号】-分页查询"><a href="#查看admin列表-【admin账号】-分页查询" class="headerlink" title="查看admin列表 【admin账号】(分页查询)"></a>查看admin列表 【admin账号】(分页查询)</h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
 @Override
    public GraceJSONResult getAdminList(Integer page, Integer pageSize) &#123;
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;//由于是固定数值 可以去basecontroller加一下
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        adminUserService.queryAdminList(page, pageSize);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);

    /**
     * 新增管理员
     *
     * @param newAdminBO
     */
    public void createAdminUser(NewAdminBO newAdminBO);


    /**
     * 分页查询admin列表
     * @param page
     * @param pageSize
     */
    public void queryAdminList(Integer page, Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
@Override
    public void queryAdminList(Integer page, Integer pageSize) &#123;
        Example adminExample = new Example(AdminUser.class);
        adminExample.orderBy(&quot;createdTime&quot;).asc();
        PageHelper.startPage(page, pageSize);
        List&lt;AdminUser&gt; adminUserList = adminUserMapper.selectByExample(adminExample);
        System.out.println(adminUserList);
    &#125; //下面一节会有改动
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/Swagger2.java
package com.imooc.api.config;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.RequestHandler;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration //Springboot啓動的時候會被掃描到并且加載
@EnableSwagger2
public class Swagger2 &#123;

    //    http://localhost:8088/swagger-ui.html     原路径
    //    http://localhost:8088/doc.html            新路径

    // 配置swagger2核心配置 docket
    @Bean
    public Docket createRestApi() &#123;
        Predicate&lt;RequestHandler&gt; adminPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.admin.controller&quot;);
//        Predicate&lt;RequestHandler&gt; articlePredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.article.controller&quot;);
        Predicate&lt;RequestHandler&gt; userPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.user.controller&quot;);
        Predicate&lt;RequestHandler&gt; filesPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.files.controller&quot;);

        return new Docket(DocumentationType.SWAGGER_2)  // 指定api类型为swagger2
                .apiInfo(apiInfo())                 // 用于定义api文档汇总信息
                .select()
                .apis(Predicates.or(userPredicate, adminPredicate, filesPredicate))
//                .apis(Predicates.or(adminPredicate, articlePredicate, userPredicate, filesPredicate))
                .paths(PathSelectors.any())         // 所有controller
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕课新闻·自媒体接口api&quot;)                       // 文档页标题
                .contact(new Contact(&quot;imooc&quot;,
                        &quot;https://www.imooc.com&quot;,
                        &quot;abc@imooc.com&quot;))                   // 联系人信息
                .description(&quot;专为慕课新闻·自媒体平台提供的api文档&quot;)      // 详细信息
                .version(&quot;1.0.1&quot;)                               // 文档版本号
                .termsOfServiceUrl(&quot;https://www.imooc.com&quot;)     // 网站地址
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;,tags = &#123;&quot;管理员admin维护的Controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public GraceJSONResult adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;,notes = &quot;查询admin用户名是否存在&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public GraceJSONResult adminLogin(@RequestParam String username); //传回来

    @ApiOperation(value = &quot;创建admin&quot;,notes = &quot;创建admin&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/addNewAdmin&quot;)
    public GraceJSONResult addNewAdmin(@RequestBody NewAdminBO newAdminBO,HttpServletRequest request,HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin列表&quot;,notes = &quot;查询admin列表&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAdminList&quot;)
    public GraceJSONResult getAdminList(@ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;,  required = false) @RequestParam Integer page,
                                        @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页查询每一页显示的条数&quot;, required = false) @RequestParam Integer pageSize);
&#125;

-----------------------------------------------------------------
http://admin.imoocnews.com:8005/doc.html
</code></pre>
<h3 id="封装PagedGridResult分页数据-调试分页接口-【admin账号】"><a href="#封装PagedGridResult分页数据-调试分页接口-【admin账号】" class="headerlink" title="封装PagedGridResult分页数据_调试分页接口 【admin账号】"></a><span style = "color:red">封装<del>PagedGridResult</del></span>分页数据_调试分页接口 【admin账号】</h3><pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
    @Override
    public PagedGridResult queryAdminList(Integer page, Integer pageSize) &#123;
        Example adminExample = new Example(AdminUser.class);
        adminExample.orderBy(&quot;createdTime&quot;).asc();
        PageHelper.startPage(page, pageSize);
        List&lt;AdminUser&gt; adminUserList = adminUserMapper.selectByExample(adminExample);
        return setterPagedGrid(adminUserList, page);
    &#125;

    private PagedGridResult setterPagedGrid( List&lt;?&gt; adminUserList, Integer page)&#123; //类型是? 后期不确定是什么泛型
        PageInfo&lt;?&gt; pageList = new PageInfo&lt;&gt;(adminUserList);
        PagedGridResult gridResult = new PagedGridResult();
        gridResult.setRows(adminUserList);
        gridResult.setPage(page);
        gridResult.setRecords(pageList.getPages());
        gridResult.setTotal(pageList.getTotal());
        return gridResult;

    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.utils.PagedGridResult;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);

    /**
     * 新增管理员
     *
     * @param newAdminBO
     */
    public void createAdminUser(NewAdminBO newAdminBO);


    /**
     * 分页查询admin列表
     * @param page
     * @param pageSize
     */
    public PagedGridResult queryAdminList(Integer page, Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/PagedGridResult.java
package com.imooc.utils;

import java.util.List;

/**
 * 
 * @Title: PagedGridResult.java
 * @Package com.imooc.utils
 * @Description: 用来返回分页Grid的数据格式
 * Copyright: Copyright (c) 2019
 */
public class PagedGridResult &#123;
    
    private int page;            // 当前页数
    private long total;            // 总页数
    private long records;        // 总记录数
    private List&lt;?&gt; rows;        // 每行显示的内容
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
//拦截器新增地址
package com.imooc.api.config;

import com.imooc.api.interceptors.AdminTokenInterceptor;
import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);
        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;);

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/interceptors/AdminTokenInterceptor.java
package com.imooc.api.interceptors;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import static com.imooc.api.BaseController.REDIS_ADMIN_TOKEN;

public class AdminTokenInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    /**
     * 拦截请求，在访问controller调用之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        String adminUserId = request.getHeader(&quot;adminUserId&quot;);
        String adminUserToken = request.getHeader(&quot;adminUserToken&quot;);

        System.out.println(&quot;=====================================================================&quot;);
        System.out.println(&quot;AdminTokenInterceptor - adminUserId = &quot; + adminUserId);
        System.out.println(&quot;AdminTokenInterceptor - adminUserToken = &quot; + adminUserToken);
        System.out.println(&quot;=====================================================================&quot;);

        boolean run = verifyUserIdToken(adminUserId, adminUserToken, REDIS_ADMIN_TOKEN);
        return run;
    &#125;

    /**
     * 请求访问controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    /**
     * 请求访问controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<h3 id="账号注销-【admin账号】-删掉redis和cookie数据"><a href="#账号注销-【admin账号】-删掉redis和cookie数据" class="headerlink" title="账号注销 【admin账号】(删掉redis和cookie数据)"></a>账号注销 【admin账号】(删掉redis和cookie数据)</h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.AdminUserService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.AdminMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.enums.FaceVerifyType;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.utils.FaceVerifyUtils;
import com.imooc.utils.PagedGridResult;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.kafka.KafkaProperties;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(AdminMngController.class);

    @Autowired
    private RedisOperator redis;

    @Autowired
    private AdminUserService adminUserService;

    @Autowired
    private FaceVerifyUtils faceVerifyUtils;

    @Override
    public GraceJSONResult adminLogin(AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1. 查询admin用户的信息
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        // 2. 判断admin不为空，如果为空则登录失败
        if (admin == null) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;

        // 3. 判断密码是否匹配
        boolean isPwdMatch = BCrypt.checkpw(adminLoginBO.getPassword(), admin.getPassword());
        if (isPwdMatch) &#123;
            doLoginSettings(admin, request, response);
            return GraceJSONResult.ok();
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
    &#125;


    /**
     * 用于admin用户登录过后的基本信息设置
     * @param admin
     * @param request
     * @param response
     */
    private void doLoginSettings(AdminUser admin,
                                 HttpServletRequest request,
                                 HttpServletResponse response) &#123;
        // 保存token放入到redis中
        String token = UUID.randomUUID().toString();
        redis.set(REDIS_ADMIN_TOKEN + &quot;:&quot; + admin.getId(), token);

        // 保存admin登录基本token信息到cookie中
        setCookie(request, response, &quot;atoken&quot;, token, COOKIE_MONTH);
        setCookie(request, response, &quot;aid&quot;, admin.getId(), COOKIE_MONTH);
        setCookie(request, response, &quot;aname&quot;, admin.getAdminName(), COOKIE_MONTH);
    &#125;

    @Override
    public GraceJSONResult adminIsExist(String username) &#123;
        checkAdminExist(username);
        return GraceJSONResult.ok();
    &#125;

    private void checkAdminExist(String username) &#123;
        AdminUser admin = adminUserService.queryAdminByUsername(username);

        if (admin != null) &#123;
            GraceException.display(ResponseStatusEnum.ADMIN_USERNAME_EXIST_ERROR);
        &#125;
    &#125;

    @Override
    public GraceJSONResult addNewAdmin(NewAdminBO newAdminBO,
                                       HttpServletRequest request,
                                       HttpServletResponse response) &#123;

        // 0. TODO 验证BO中的用户名和密码不为空

        // 1. base64不为空，则代表人脸入库，否则需要用户输入密码和确认密码
        if (StringUtils.isBlank(newAdminBO.getImg64())) &#123;
            if (StringUtils.isBlank(newAdminBO.getPassword()) ||
                    StringUtils.isBlank(newAdminBO.getConfirmPassword())
            ) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_NULL_ERROR);
            &#125;
        &#125;

        // 2. 密码不为空，则必须判断两次输入一致
        if (StringUtils.isNotBlank(newAdminBO.getPassword())) &#123;
            if (!newAdminBO.getPassword()
                    .equalsIgnoreCase(newAdminBO.getConfirmPassword())) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_ERROR);
            &#125;
        &#125;

        // 3. 校验用户名唯一
        checkAdminExist(newAdminBO.getUsername());

        // 4. 调用service存入admin信息
        adminUserService.createAdminUser(newAdminBO);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult getAdminList(Integer page, Integer pageSize) &#123;

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult result = adminUserService.queryAdminList(page, pageSize);
        return GraceJSONResult.ok(result);
    &#125;

    @Override
    public GraceJSONResult adminLogout(String adminId,
                                       HttpServletRequest request,
                                       HttpServletResponse response) &#123;

        // 从redis中删除admin的会话token
        redis.del(REDIS_ADMIN_TOKEN + &quot;:&quot; + adminId);

        // 从cookie中清理adming登录的相关信息
        deleteCookie(request, response, &quot;atoken&quot;);
        deleteCookie(request, response, &quot;aid&quot;);
        deleteCookie(request, response, &quot;aname&quot;);

        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;, tags = &#123;&quot;管理员admin维护的controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;

    @ApiOperation(value = &quot;hello方法的接口&quot;, notes = &quot;hello方法的接口&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public GraceJSONResult adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;, notes = &quot;查询admin用户名是否存在&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public GraceJSONResult adminIsExist(@RequestParam String username);

    @ApiOperation(value = &quot;创建admin&quot;, notes = &quot;创建admin&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/addNewAdmin&quot;)
    public GraceJSONResult addNewAdmin(@RequestBody NewAdminBO newAdminBO,
                                       HttpServletRequest request,
                                       HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin列表&quot;, notes = &quot;查询admin列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAdminList&quot;)
    public GraceJSONResult getAdminList(
            @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
            @RequestParam Integer page,
            @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页查询每一页显示的条数&quot;, required = false)
            @RequestParam Integer pageSize);

    @ApiOperation(value = &quot;admin退出登录&quot;, notes = &quot;admin退出登录&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogout&quot;)
    public GraceJSONResult adminLogout(@RequestParam String adminId,
                                       HttpServletRequest request,
                                       HttpServletResponse response);
                                        HttpServletResponse response);
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public void setCookieValue(HttpServletRequest request,
                               HttpServletResponse response,
                               String cookieName,
                               String cookieValue,
                               Integer maxAge) &#123;
        Cookie cookie = new Cookie(cookieName, cookieValue);
        cookie.setMaxAge(maxAge);
//        cookie.setDomain(&quot;imoocnews.com&quot;);
        cookie.setDomain(DOMAIN_NAME);
        cookie.setPath(&quot;/&quot;);//都用cookie
        response.addCookie(cookie);//把cookie传入
    &#125;

    public void deleteCookie(HttpServletRequest request,HttpServletResponse response,String cookieName)&#123;
        try &#123;
            String deleteValue = URLEncoder.encode(&quot;&quot;, &quot;utf-8&quot;);
            setCookieValue(request, response, cookieName, deleteValue, COOKIE_DELETE);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>
<h3 id="人脸业务流程图梳理"><a href="#人脸业务流程图梳理" class="headerlink" title="人脸业务流程图梳理"></a>人脸业务流程图梳理</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/fa7fae40efa428b638a2589c3203204ff0479b04/data/%E4%BA%BA%E8%84%B8%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h3 id="Chrome开启视频调试模式"><a href="#Chrome开启视频调试模式" class="headerlink" title="Chrome开启视频调试模式"></a>Chrome开启视频调试模式</h3><blockquote>
<p>在谷歌浏览器中打开【每一次重启电脑都要操作】<br>chrome:&#x2F;&#x2F;flags&#x2F;#unsafely-treat-insecure-origin-as-secure<br>|————————————————————————————————|<br>|  <a href="http://admin.imoocnews.com:9090,http://admin.imoocnews.com">http://admin.imoocnews.com:9090,http://admin.imoocnews.com</a> |<br>|—— ——————————————————————————————|<br><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html</a><br>可以获取人脸</p>
</blockquote>
<h3 id="MongoDB概念-人脸数据存储-可以存储JSON数据"><a href="#MongoDB概念-人脸数据存储-可以存储JSON数据" class="headerlink" title="MongoDB概念 [人脸数据存储]可以存储JSON数据"></a>MongoDB概念 [人脸数据存储]<del>可以存储JSON数据</del></h3><ul>
<li>NoSql 数据库</li>
<li>内存级别查询</li>
<li>不支持事务</li>
<li>非并发读写 请求并发数据量大</li>
<li>GridFS 小文件存储</li>
</ul>
<h4 id="MongoDB术语"><a href="#MongoDB术语" class="headerlink" title="MongoDB术语"></a>MongoDB术语</h4><table>
<thead>
<tr>
<th align="center">数据库</th>
<th align="center">ElasticSearch</th>
<th align="center">MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">database</td>
<td align="center">es库</td>
<td align="center">database</td>
</tr>
<tr>
<td align="center">table表</td>
<td align="center">index索引</td>
<td align="center">collection数据集合</td>
</tr>
<tr>
<td align="center">row行 (记录)</td>
<td align="center">document文档 (json)</td>
<td align="center">document文档 (json)</td>
</tr>
<tr>
<td align="center">column 字段列</td>
<td align="center">field域</td>
<td align="center">field域</td>
</tr>
<tr>
<td align="center">index索引</td>
<td align="center">-</td>
<td align="center">index索引</td>
</tr>
<tr>
<td align="center">join表关联查询</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">pk主键</td>
<td align="center">_id</td>
<td align="center">_id</td>
</tr>
</tbody></table>
<h5 id="MongoDB数据结构"><a href="#MongoDB数据结构" class="headerlink" title="MongoDB数据结构"></a>MongoDB数据结构</h5><pre><code class="vue">UserList:[
    &#123;
        userId: &quot;1001&quot;,
        username: &quot;lee&quot;,
        age: 18
    &#125;,
    &#123;
        userId: &quot;1002&quot;,
        username: &quot;jay&quot;,
        age: 20,
        sex: &quot;boy&quot;
    &#125;
]

----------------------------------------------------------

UserList --&gt;   collection
&#123;&#125;       --&gt;   document
属性        --&gt;   column
</code></pre>
<h3 id="MogoDB安装与配置使用"><a href="#MogoDB安装与配置使用" class="headerlink" title="MogoDB安装与配置使用"></a>MogoDB安装与配置使用</h3><p><a target="_blank" rel="noopener" href="https://www.mongodb.com/try/download/enterprise">https://www.mongodb.com/try/download/enterprise</a></p>
<pre><code class="mysql">将mongodb-linux-x86_64-rhel70-4.2.8传入虚拟机
[imooc@imooc ~]$ tar -zxvf mongodb-linux-x86_64-rhel70-4.2.8.tgz 
[imooc@imooc ~]$ sudo mv mongodb-linux-x86_64-rhel70-4.2.8 /usr/local/mongodb
[imooc@imooc ~]$ cd /usr/local/
[imooc@imooc local]$ ll
drwxrwxr-x. 3 imooc imooc      135 7月  16 19:46 mongodb
[imooc@imooc local]$ cd mongodb/
[imooc@imooc mongodb]$ ll
总用量 312
drwxrwxr-x. 2 imooc imooc    231 7月  16 19:46 bin
-rw-r--r--. 1 imooc imooc  30608 6月  12 2020 LICENSE-Community.txt
-rw-r--r--. 1 imooc imooc  16726 6月  12 2020 MPL-2
-rw-r--r--. 1 imooc imooc   2617 6月  12 2020 README
-rw-r--r--. 1 imooc imooc  75405 6月  12 2020 THIRD-PARTY-NOTICES
-rw-r--r--. 1 imooc imooc 183512 6月  12 2020 THIRD-PARTY-NOTICES.gotools
[imooc@imooc mongodb]$ cd bin/
[imooc@imooc bin]$ pwd
/usr/local/mongodb/bin

[imooc@imooc bin]$ sudo vim /etc/profile
最下面添加：
export JAVA_HOME=/usr/java/jdk1.8.0_222-ea
export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin
#set mogodb config
export PATH=/usr/local/mongodb/bin:$PATH

#修改 /etc/profile 文件后，需要重新加载这个文件才能使新配置生效。你可以执行以下命令：
[imooc@imooc bin]$ source /etc/profile

[imooc@imooc bin]$ mongo --version
MongoDB shell version v4.2.8
git version: 43d25964249164d76d5e04dd6cf38f6111e21f5f
OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013
allocator: tcmalloc
modules: none
build environment:
    distmod: rhel70
    distarch: x86_64
    target_arch: x86_64

[imooc@imooc bin]$ cd /usr/local/mongodb/
[imooc@imooc mongodb]$ pwd
/usr/local/mongodb

#创建数据存储目录
[imooc@imooc mongodb]$ mkdir data/db -p #出来一个data
[imooc@imooc mongodb]$ ll
总用量 312
drwxrwxr-x. 2 imooc imooc    231 7月  16 19:46 bin
drwxrwxr-x. 3 imooc imooc     16 7月  16 20:00 data
[imooc@imooc mongodb]$ cd data
[imooc@imooc data]$ ll
总用量 0
drwxrwxr-x. 2 imooc imooc 6 7月  16 20:00 db
[imooc@imooc data]$ mkdir logs
[imooc@imooc data]$ ll
总用量 0
drwxrwxr-x. 2 imooc imooc 6 7月  16 20:00 db
drwxrwxr-x. 2 imooc imooc 6 7月  16 20:00 logs
[imooc@imooc data]$ cd logs/
[imooc@imooc logs]$ pwd
/usr/local/mongodb/data/logs
[imooc@imooc logs]$ touch mongodb.log
[imooc@imooc logs]$ ll
总用量 0
-rw-rw-r--. 1 imooc imooc 0 7月  16 20:01 mongodb.log
[imooc@imooc logs]$ cd ..
[imooc@imooc logs]$ cd ..

[imooc@imooc mongodb]$ vim mongodb.conf
port=27017
# datasource path
dbpath=/user/local/mongodb/data/db
# log path
logpath=/usr/local/mongodb/data/logs/mongodb.log
# append log
logappend=true
# cut useless log
quiet=true
# back desktop auto run
fork=true
# Maxcontect
maxConns=100
# Not open Verify permissions
noauth=true
# open Verify permissions
# auth=true
# open log =&gt; true
journal=true
# clash
bind_ip=0.0.0.0

[imooc@imooc mongodb]$ sudo yum install net-snmp
 
#错误：软件包：1:net-snmp-agent-libs-5.7.2-49.el7_9.4.x86_64 (updates)
          需要：libmysqlclient.so.18(libmysqlclient_18)(64bit)
#错误：软件包：1:net-snmp-5.7.2-49.el7_9.4.x86_64 (updates)
          需要：libmysqlclient.so.18()(64bit)
#错误：软件包：1:net-snmp-agent-libs-5.7.2-49.el7_9.4.x86_64 (updates)
          需要：libmysqlclient.so.18()(64bit)
# cd /usr/local/mongodb/
[imooc@imooc mongodb]$ mongod -f mongodb.conf
about to fork child process, waiting until server is ready for connections.
forked process: 4989
child process started successfully, parent exiting

[imooc@imooc mongodb]$ ps aux | grep mongod
imooc      4989  1.8  4.2 1550916 78280 ?       Sl   20:39   0:00 mongod -f mongodb.conf
imooc      5105  0.0  0.0 112824   988 pts/0    S+   20:40   0:00 grep --color=auto mongod

[imooc@imooc mongodb]$ ps -ef|grep mongodb
imooc      4989      1  0 20:39 ?        00:00:02 mongod -f mongodb.conf
imooc      5201   2948  0 20:44 pts/0    00:00:00 grep --color=auto mongodb


尝试连接到 MongoDB 实例： 
[imooc@imooc mongodb]$ mongo --port 27017
</code></pre>
<h3 id="可视化管理工具【MongoDB】"><a href="#可视化管理工具【MongoDB】" class="headerlink" title="可视化管理工具【MongoDB】"></a>可视化管理工具【MongoDB】</h3><pre><code class="mysql">在Navicat里新建链接MongoDB
主机：192.168.170.135
右键新建数据库school → 集合 → 右键新建 左上角保存student
[imooc@imooc mongodb]$ vim mongodb.conf
##### 启用用户账号权限
# Not open Verify permissions
# noauth=true
# open Verify permissions
  auth=true
#重启服务
[imooc@imooc mongodb]$ ps -ef|grep mongodb
imooc      4989      1  0 20:39 ?        00:00:05 mongod -f mongodb.conf
imooc      5380   2948  0 20:54 pts/0    00:00:00 grep --color=auto mongodb
[imooc@imooc mongodb]$ kill -2 4989
[imooc@imooc mongodb]$ ps -ef|grep mongodb
imooc      5395   2948  0 20:54 pts/0    00:00:00 grep --color=auto mongodb
[imooc@imooc mongodb]$ mongod -f mongodb.conf
about to fork child process, waiting until server is ready for connections.
forked process: 5419
child process started successfully, parent exiting

[imooc@imooc mongodb]$ mongo
MongoDB shell version v4.2.8
connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb
Implicit session: session &#123; &quot;id&quot; : UUID(&quot;c87ffbd9-69cd-4e29-badd-5b86a314f428&quot;) &#125;
MongoDB server version: 4.2.8
&gt; use admin
switched to db admin
&gt; db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[&quot;root&quot;]&#125;)
Successfully added user: &#123; &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;root&quot; ] &#125;
&gt; db.auth(&quot;root&quot;,&quot;root&quot;)
1
&gt; show users
&#123;
    &quot;_id&quot; : &quot;admin.root&quot;,
    &quot;userId&quot; : UUID(&quot;2ced1f0a-8de4-4fab-9cb8-8e420fe9dcba&quot;),
    &quot;user&quot; : &quot;root&quot;,
    &quot;db&quot; : &quot;admin&quot;,
    &quot;roles&quot; : [
        &#123;
            &quot;role&quot; : &quot;root&quot;,
            &quot;db&quot; : &quot;admin&quot;
        &#125;
    ],
    &quot;mechanisms&quot; : [
        &quot;SCRAM-SHA-1&quot;,
        &quot;SCRAM-SHA-256&quot;
    ]
&#125;
&gt; 
#后面关闭连接 编辑数据库 新增密码登录 root root
</code></pre>
<h3 id="整合SpringBoot-【GridFS】"><a href="#整合SpringBoot-【GridFS】" class="headerlink" title="整合SpringBoot 【GridFS】"></a>整合SpringBoot 【GridFS】</h3><pre><code class="xml">&lt;!-- 引入 mongodb 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
            &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploadControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploadControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的
    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;
&#125;
</code></pre>
<pre><code class="yaml">service-files  application.yml
  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
</code></pre>
<h3 id="实现人脸入库-【GridFS】"><a href="#实现人脸入库-【GridFS】" class="headerlink" title="实现人脸入库 【GridFS】"></a>实现人脸入库 【GridFS】</h3><pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java

...
 @Autowired
    private GridFSBucket gridFSBucket;
...

 @Override
    public GraceJSONResult uploadToGridFS(NewAdminBO newAdminBO) throws Exception &#123;
        // 获得图片的base64字符串
        String file64 = newAdminBO.getImg64();
        // 将base64字符串转换为byte数组
        byte[] bytes = new BASE64Decoder().decodeBuffer(file64.trim());
        // 转换为输入流
        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
        //上传到gridfs中
        ObjectId fileId = gridFSBucket.uploadFromStream(newAdminBO.getUsername() + &quot;.png&quot;, inputStream);
        // 获取文件在gridfs中的主键id
        String fileIdStr = fileId.toString();
        // 下次提交的时候会提交到后端
        return GraceJSONResult.ok(fileIdStr);
    &#125;

http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html
注册并且提交人脸信息
去Navicat → MongoDB → imooc-news → GridFS存储桶 → fs → admin456.png
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
...
    @Override
    public GraceJSONResult uploadToGridFS(NewAdminBO newAdminBO) throws Exception &#123;
        // 获得图片的base64字符串
        String file64 = newAdminBO.getImg64();
        // 将base64字符串转换为byte数组
        byte[] bytes = new BASE64Decoder().decodeBuffer(file64.trim());
        // 转换为输入流
        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
        //上传到gridfs中
        ObjectId fileId = gridFSBucket.uploadFromStream(newAdminBO.getUsername() + &quot;.png&quot;, inputStream);
        // 获取文件在gridfs中的主键id
        String fileIdStr = fileId.toString();
        // 下次提交的时候会提交到后端
        return GraceJSONResult.ok(fileIdStr);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploadControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploadControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的

    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/GridFSConfig.java
package com.imooc.files;

import com.mongodb.MongoClient;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.client.gridfs.GridFSBuckets;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

@Component //可以被容器访问到
public class GridFSConfig &#123;
    @Value(&quot;$&#123;spring.data.mongodb.database&#125;&quot;)
    private String mongodb;

    @Bean
    public GridFSBucket gridFSBucket(MongoClient mongoClient)&#123;
        MongoDatabase mongoDatabase = mongoClient.getDatabase(mongodb);
        GridFSBucket bucket = GridFSBuckets.create(mongoDatabase);//存入mongodatabase
        return bucket;
    &#125;
&#125;
</code></pre>
<h3 id="查看admin人脸信息-【GridFS】"><a href="#查看admin人脸信息-【GridFS】" class="headerlink" title="查看admin人脸信息 【GridFS】"></a>查看admin人脸信息 【GridFS】</h3><pre><code class="java">service-files  com/imooc/files/controller/FileUploaderController.java
 @Override
    public GraceJSONResult uploadToGridFS(NewAdminBO newAdminBO)
            throws Exception &#123;

        // 获得图片的base64字符串
        String file64 = newAdminBO.getImg64();

        // 将base64字符串转换为byte数组
        byte[] bytes = new BASE64Decoder().decodeBuffer(file64.trim());

        // 转换为输入流
        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);

        // 上传到gridfs中
        ObjectId fileId = gridFSBucket.uploadFromStream(newAdminBO.getUsername() + &quot;.png&quot;, inputStream);

        // 获得文件在gridfs中的主键id
        String fileIdStr = fileId.toString();

        return GraceJSONResult.ok(fileIdStr);
    &#125;

    @Override
    public void readInGridFS(String faceId,
                             HttpServletRequest request,
                             HttpServletResponse response) throws Exception &#123;

        // 0. 判断参数
        if (StringUtils.isBlank(faceId) || faceId.equalsIgnoreCase(&quot;null&quot;)) &#123;
            GraceException.display(ResponseStatusEnum.FILE_NOT_EXIST_ERROR);
        &#125;

        // 1. 从gridfs中读取
        File adminFace = readGridFSByFaceId(faceId);

        // 2. 把人脸图片输出到浏览器
        FileUtils.downloadFileByStream(response, adminFace);
    &#125;

    private File readGridFSByFaceId(String faceId) throws Exception &#123;

        GridFSFindIterable gridFSFiles
                = gridFSBucket.find(Filters.eq(&quot;_id&quot;, new ObjectId(faceId)));

        GridFSFile gridFS = gridFSFiles.first();

        if (gridFS == null) &#123;
            GraceException.display(ResponseStatusEnum.FILE_NOT_EXIST_ERROR);
        &#125;

        String fileName = gridFS.getFilename();
        System.out.println(fileName);

        // 获取文件流，保存文件到本地或者服务器的临时目录
        File fileTemp = new File(&quot;/workspace/temp_face&quot;);
        if (!fileTemp.exists()) &#123;
            fileTemp.mkdirs();
        &#125;

        File myFile = new File(&quot;/workspace/temp_face/&quot; + fileName);

        // 创建文件输出流
        OutputStream os = new FileOutputStream(myFile);
        // 下载到服务器或者本地
        gridFSBucket.downloadToStream(new ObjectId(faceId), os);

        return myFile;
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploaderControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploaderControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的

    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;

    @GetMapping(&quot;/readInGridFS&quot;)
    public void readInGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception;
&#125;

//AdminCookieToken也可以获得faceId
</code></pre>
<h3 id="阿里AI人脸识别介绍"><a href="#阿里AI人脸识别介绍" class="headerlink" title="阿里AI人脸识别介绍"></a>阿里AI人脸识别介绍</h3><p><a target="_blank" rel="noopener" href="https://vision.aliyun.com/facebody?spm=5176.21213303.J_qCOwPWspKEuWcmp8qiZNQ.20.f1892f3dvI78tU&scm=20140722.S_card@@%E5%95%86%E5%93%81@@143873.S_card0.ID_card@@%E5%95%86%E5%93%81@@143873-RL_%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-LOC_search~UND~card~UND~item-OR_ser-V_3-RE_cardOld-P0_0">人脸人体-阿里云视觉智能开放平台 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://vision.console.aliyun.com/cn-shanghai/detail/facebody?spm=5176.6660585.viapi_facebody_public_cn-top.i0.7bbf7992dXgogs">视觉智能开放平台-控制台 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://vision.aliyun.com/experience/detail?tagName=facebody&children=CompareFace">能力展示-阿里云视觉智能开放平台 (aliyun.com)</a></p>
<h3 id="获得人脸faceId【人脸登录】"><a href="#获得人脸faceId【人脸登录】" class="headerlink" title="获得人脸faceId【人脸登录】"></a>获得人脸faceId【人脸登录】</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
@ApiOperation(value = &quot;admin管理员的人脸登录&quot;, notes = &quot;admin管理员的人脸登录&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminFaceLogin&quot;)
    public GraceJSONResult adminFaceLogin(@RequestBody AdminLoginBO adminLoginBO,
                                          HttpServletRequest request,
                                          HttpServletResponse response);
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
 @Override
    public GraceJSONResult adminFaceLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. 判断用户名和人脸信息不能为空
        if(StringUtils.isBlank(adminLoginBO.getUsername()))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_USERNAME_NULL_ERROR);
        &#125;
        String tempFace64 = adminLoginBO.getImg64();
        if (StringUtils.isBlank(tempFace64))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 1. 从数据库中查询出faceId
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        String adminFaceId = admin.getFaceId();
        if (StringUtils.isBlank(adminFaceId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 2. 请求文件服务，获得人懒数据的base64数据

        // 3. 调用阿里ai进行人脸对比识别，判断可信度，从而实现人脸登录

        // 4. admin登录后的数据设置，redis与cookie

        return null;
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploaderControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploaderControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的

    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;

    @GetMapping(&quot;/readInGridFS&quot;)
    public void readInGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception;

    /**
     * 从gridfs中读取图片内容 返回base64数据
     * @param faceId
     * @param request
     * @param response
     * @return
     * @throws Exception
     */
    @GetMapping(&quot;/readFace64InGridFS&quot;)
    public GraceJSONResult readFace64InGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploaderController.java
@Override
    public GraceJSONResult readFace64InGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        // 0. 获得gridfs中人脸文件
        File myface = readGridFSByFaceId(faceId);

        // 1. 转换人脸为base64
        String base64Face = FileUtils.fileToBase64(myface);
        return GraceJSONResult.ok(base64Face);
    &#125;
</code></pre>
<h3 id="整合RestTemplate服务通信-【人脸登录】"><a href="#整合RestTemplate服务通信-【人脸登录】" class="headerlink" title="整合RestTemplate服务通信 【人脸登录】"></a>整合RestTemplate服务通信 【人脸登录】</h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;

@Autowired
    private RestTemplate restTemplate;

@Override
    public GraceJSONResult adminFaceLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. 判断用户名和人脸信息不能为空
        if(StringUtils.isBlank(adminLoginBO.getUsername()))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_USERNAME_NULL_ERROR);
        &#125;
        String tempFace64 = adminLoginBO.getImg64();
        if (StringUtils.isBlank(tempFace64))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 1. 从数据库中查询出faceId
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        String adminFaceId = admin.getFaceId();
        if (StringUtils.isBlank(adminFaceId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 2. 请求文件服务，获得人懒数据的base64数据
        String fileServerUrlExecute = &quot;http://files.imoocnews.com:8004/fs/readFace64InGridFS?faceId=&quot; + adminFaceId;
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity = restTemplate.getForEntity(fileServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        String base64DB = (String)bodyResult.getData();
        // 3. 调用阿里ai进行人脸对比识别，判断可信度，从而实现人脸登录

        // 4. admin登录后的数据设置，redis与cookie

        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;

    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    public RestTemplate restTemplate() &#123;

        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<h3 id="实现人脸对比进行登录【人脸对比】没买人脸识别服务-简单写了一下"><a href="#实现人脸对比进行登录【人脸对比】没买人脸识别服务-简单写了一下" class="headerlink" title="实现人脸对比进行登录【人脸对比】没买人脸识别服务,简单写了一下"></a>实现人脸对比进行登录【人脸对比】<del>没买人脸识别服务,简单写了一下</del></h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
@Override
    public GraceJSONResult adminFaceLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. 判断用户名和人脸信息不能为空
        if(StringUtils.isBlank(adminLoginBO.getUsername()))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_USERNAME_NULL_ERROR);
        &#125;
        String tempFace64 = adminLoginBO.getImg64();
        if (StringUtils.isBlank(tempFace64))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 1. 从数据库中查询出faceId
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        String adminFaceId = admin.getFaceId();
        if (StringUtils.isBlank(adminFaceId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 2. 请求文件服务，获得人懒数据的base64数据
        String fileServerUrlExecute = &quot;http://files.imoocnews.com:8004/fs/readFace64InGridFS?faceId=&quot; + adminFaceId;
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity = restTemplate.getForEntity(fileServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        String base64DB = (String)bodyResult.getData();
        // 3. 调用阿里ai进行人脸对比识别，判断可信度，从而实现人脸登录
        boolean result = faceVerifyUtils.faceVerify(FaceVerifyType.BASE64.type,
                tempFace64,
                base64DB,
                60);
        if (!result)&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_LOGIN_ERROR);
        &#125;
        // 4. admin登录后的数据设置，redis与cookie
        doLoginSettings(admin,request,response);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/FaceVerifyUtils.java
package com.imooc.utils;

import com.aliyuncs.utils.Base64Helper;
import com.imooc.enums.FaceVerifyType;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.extend.AliyunResource;
import org.apache.tomcat.util.codec.binary.Base64;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.security.MessageDigest;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.SimpleTimeZone;

@Component
public class FaceVerifyUtils &#123;

    final static Logger logger = LoggerFactory.getLogger(FaceVerifyUtils.class);

    @Autowired
    private AliyunResource aliyunResource;

    //网关地址
    private static final String gateway = &quot;https://dtplus-cn-shanghai.data.aliyuncs.com/face/verify&quot;;

    /*
     * 计算MD5+BASE64
     */
    public static String MD5Base64(String s) &#123;
        if (s == null)
            return null;
        String encodeStr = &quot;&quot;;
        byte[] utfBytes = s.getBytes();
        MessageDigest mdTemp;
        try &#123;
            mdTemp = MessageDigest.getInstance(&quot;MD5&quot;);
            mdTemp.update(utfBytes);
            byte[] md5Bytes = mdTemp.digest();
            Base64Helper b64Encoder = new Base64Helper();
            encodeStr = b64Encoder.encode(md5Bytes);
        &#125; catch (Exception e) &#123;
            throw new Error(&quot;Failed to generate MD5 : &quot; + e.getMessage());
        &#125;
        return encodeStr;
    &#125;

    /*
     * 计算 HMAC-SHA1
     */
    public static String HMACSha1(String data, String key) &#123;
        String result;
        try &#123;
            SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), &quot;HmacSHA1&quot;);
            Mac mac = Mac.getInstance(&quot;HmacSHA1&quot;);
            mac.init(signingKey);
            byte[] rawHmac = mac.doFinal(data.getBytes());
            result = (new Base64Helper()).encode(rawHmac);
        &#125; catch (Exception e) &#123;
            throw new Error(&quot;Failed to generate HMAC : &quot; + e.getMessage());
        &#125;
        return result;
    &#125;

    /*
     * 等同于javaScript中的 new Date().toUTCString();
     */
    public static String toGMTString(Date date) &#123;
        SimpleDateFormat df = new SimpleDateFormat(&quot;E, dd MMM yyyy HH:mm:ss z&quot;, Locale.UK);
        df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
        return df.format(date);
    &#125;

    /**
     * 发送POST请求 进行两张图的人脸对比
     * @param type
     *          0: 通过url识别，参数image_url不为空；1: 通过图片content识别，参数content不为空
     * @param face1
     *          type为0，则传入图片url，为1则传入base64
     * @param face2
     *          type为0，则传入图片url，为1则传入base64
     * @return
     */
    //如果发送的是转换为base64编码后后面加请求参数type为1，如果请求的是图片的url则不用加type参数。
    public String sendPostVerifyFace(int type, String face1, String face2) throws Exception &#123;
        String body = &quot;&quot;;
        if (type == FaceVerifyType.BASE64.type) &#123;
            body = &quot;&#123;\&quot;content_1\&quot;: \&quot;&quot; + face1 + &quot;\&quot;, \&quot;content_2\&quot;:\&quot;&quot; + face2 + &quot;\&quot;, \&quot;type\&quot;:\&quot;&quot; + type + &quot;\&quot;&#125;&quot;;
        &#125; else if (type == FaceVerifyType.IMAGE_URL.type) &#123;
            body = &quot;&#123;\&quot;image_url_1\&quot;: \&quot;&quot; + face1 + &quot;\&quot;, \&quot;image_url_2\&quot;:\&quot;&quot; + face2 + &quot;\&quot;, \&quot;type\&quot;:\&quot;&quot; + type + &quot;\&quot;&#125;&quot;;
        &#125; else &#123;
            GraceException.display(ResponseStatusEnum.FACE_VERIFY_TYPE_ERROR);
        &#125;
//        String body = &quot;&#123;\&quot;content_1\&quot;: \&quot;&quot; + face1 + &quot;\&quot;, \&quot;content_2\&quot;:\&quot;&quot; + face2 + &quot;\&quot;, \&quot;type\&quot;:\&quot;&quot; + &quot;1&quot; + &quot;\&quot;&#125;&quot;;
        PrintWriter out = null;
        BufferedReader in = null;
        String result = &quot;&quot;;
        int statusCode = 200;
        try &#123;
            URL realUrl = new URL(gateway);
            /*
             * http header 参数
             */
            String method = &quot;POST&quot;;
            // 返回值类型
            String accept = &quot;application/json&quot;;
            // 请求内容类型
            String content_type = &quot;application/json&quot;;
            String path = realUrl.getFile();
            // GMT时间
            String date = toGMTString(new Date());
            // 1.对body做MD5+BASE64加密
            String bodyMd5 = MD5Base64(body);
            String stringToSign = method + &quot;\n&quot; + accept + &quot;\n&quot; + bodyMd5 + &quot;\n&quot; + content_type + &quot;\n&quot; + date + &quot;\n&quot;
                    + path;
            // 2.计算 HMAC-SHA1
            String signature = HMACSha1(stringToSign, aliyunResource.getAccessKeySecret());
            // 3.得到 authorization header
            String authHeader = &quot;Dataplus &quot; + aliyunResource.getAccessKeyID() + &quot;:&quot; + signature;
            // 打开和URL之间的连接
            URLConnection conn = realUrl.openConnection();
            // 设置通用的请求属性
            conn.setRequestProperty(&quot;Accept&quot;, accept);
            conn.setRequestProperty(&quot;Content-type&quot;, content_type);
            conn.setRequestProperty(&quot;Date&quot;, date);
            // 认证信息
            conn.setRequestProperty(&quot;Authorization&quot;, authHeader);
            // 发送POST请求必须设置如下两行
            conn.setDoOutput(true);
            conn.setDoInput(true);
            // 获取URLConnection对象对应的输出流
            out = new PrintWriter(conn.getOutputStream());
            // 发送请求参数
            out.print(body);
            // flush输出流的缓冲
            out.flush();
            // 定义BufferedReader输入流来读取URL的响应
            statusCode = ((HttpURLConnection) conn).getResponseCode();
            if (statusCode != 200) &#123;
                in = new BufferedReader(new InputStreamReader(((HttpURLConnection) conn).getErrorStream()));
            &#125; else &#123;
                in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            &#125;
            String line;
            while ((line = in.readLine()) != null) &#123;
                result += line;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (out != null) &#123;
                    out.close();
                &#125;
                if (in != null) &#123;
                    in.close();
                &#125;
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
        if (statusCode != 200) &#123;
            throw new IOException(&quot;\nHttp StatusCode: &quot; + statusCode + &quot;\nErrorMessage: &quot; + result);
        &#125;
        return result;
    &#125;

    /**
     *
     * @param type
     * @param face1
     * @param face2
     * @param targetConfidence
     *          目标可信度，自定义阈值
     * @return
     */
    public boolean faceVerify(int type, String face1, String face2, double targetConfidence) &#123;

        String response = null;
        try &#123;
            response = sendPostVerifyFace(type, face1, face2);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        Map&lt;String, String&gt; map = JsonUtils.jsonToPojo(response, Map.class);
        Object confidenceStr = map.get(&quot;confidence&quot;);
        Double responseConfidence = (Double)confidenceStr;

        logger.info(&quot;人脸对比结果：&#123;&#125;&quot;, responseConfidence);

//        System.out.println(response.toString());
//        System.out.println(map.toString());

        if (responseConfidence &gt; targetConfidence) &#123;
            return true;
        &#125; else &#123;
            return false;
        &#125;
    &#125;

    /**
     *
     * 将图片转换为Base64
     * 将base64编码字符串解码成img图片
     * @param imgUrl
     * @return
     */
    public String getImgBase64(String imgUrl)&#123;
        ByteArrayOutputStream data = new ByteArrayOutputStream();
        try &#123;
            // 创建URL
            URL url = new URL(imgUrl);
            byte[] by = new byte[1024];
            // 创建链接
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod(&quot;GET&quot;);
            conn.setConnectTimeout(5000);
            InputStream is = conn.getInputStream();
            // 将内容放到内存中
            int len = -1;
            while ((len = is.read(by)) != -1) &#123;
                data.write(by, 0, len);
            &#125;
            is.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        // 对字节数组Base64编码
        return Base64.encodeBase64String(data.toByteArray());
    &#125;

//    public static void main(String[] args) &#123;
//        String face3 = &quot;http://122.152.205.72:88/group1/M00/00/05/CpoxxF5MvvGAfnLXAAIHiv37wNk363.jpg&quot;;
//        String face4 = &quot;http://122.152.205.72:88/group1/M00/00/05/CpoxxF5Mv3yAH74mAACOiTd9pO4462.jpg&quot;;
//
//        boolean result = new FaceVerifyUtils().faceVerify(FaceVerifyType.IMAGE_URL.type, face3, face4, 60);
//
//        logger.info(&quot;人脸对比是否成功：&#123;&#125;&quot;, result);
//    &#125;
&#125;
</code></pre>
<h3 id="MongoDB使用场景-【分担数据库的大数据量】"><a href="#MongoDB使用场景-【分担数据库的大数据量】" class="headerlink" title="MongoDB使用场景 【分担数据库的大数据量】"></a>MongoDB使用场景 【分担数据库的大数据量】</h3><ul>
<li><strong>GridFS小文件存储</strong></li>
<li><strong>历史数据快照</strong> [买的东西涨价后 还是原来的价格] 【数据量大存入MongoDB】</li>
<li><strong>用户浏览记录</strong></li>
<li><strong>客服聊天记录</strong> [不是核心数据 可以剥离]</li>
</ul>
<h6 id="这些不建议放在Redis里-因为Redis是存储在内存里的-内存很贵-成本很大"><a href="#这些不建议放在Redis里-因为Redis是存储在内存里的-内存很贵-成本很大" class="headerlink" title="这些不建议放在Redis里 因为Redis是存储在内存里的 [内存很贵 成本很大]"></a>这些不建议放在Redis里 因为Redis是存储在内存里的 [内存很贵 成本很大]</h6><h3 id="友情连接保存与更新-【MongoDB】"><a href="#友情连接保存与更新-【MongoDB】" class="headerlink" title="友情连接保存与更新 【MongoDB】"></a>友情连接保存与更新 【MongoDB】</h3><h6 id="对连接的一些逻辑校验"><a href="#对连接的一些逻辑校验" class="headerlink" title="对连接的一些逻辑校验"></a>对连接的一些逻辑校验</h6><pre><code class="yaml">service-admin  application.yml 【加上mongodb配置】
  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
</code></pre>
<pre><code class="java">service-admin  Application 【注释exclude 把mongodb配置进来】
package com.imooc.admin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication  //(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.admin.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<p>dev-model  com&#x2F;imooc&#x2F;pojo&#x2F;bo&#x2F;SaveFriendLinkBO.java<br>package com.imooc.pojo.bo;</p>
<p>import com.imooc.validate.CheckUrl;</p>
<p>import javax.validation.constraints.NotBlank;<br>import javax.validation.constraints.NotNull;</p>
<p>public class SaveFriendLinkBO {<br>    private String id;<br>    @NotBlank(message &#x3D; “友情链接名不能为空”)<br>    private String linkName;<br>    @NotBlank(message &#x3D; “友情链接地址不能为空”)<br>    @CheckUrl 【ctrl+左键 显示↓ CheckUrl接口】<br>    @CheckName 【 &#x2F;&#x2F;不能有空格 不能为空 字符串长度要在6-12位】<br>    private String linkUrl;<br>    @NotNull(message &#x3D; “请选择保留或删除”)<br>    private Integer isDelete;<br>}Getter+Setter</p>
<pre><code class="java">dev-model  com/imooc/validate/CheckUrl.java
package com.imooc.validate;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CheckUrlValidate.class)
public @interface CheckUrl &#123;

    String message() default &quot;Url不正确&quot;;
    Class&lt;?&gt;[] groups() default &#123;&#125;;
    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/validate/CheckName.java
package com.imooc.validate;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CheckUrlValidate.class)
public @interface CheckName &#123;

    String message() default &quot;Name不正确&quot;;
    Class&lt;?&gt;[] groups() default &#123;&#125;;
    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/validate/CheckUrlValidate.java
package com.imooc.validate;

import com.imooc.utils.UrlUtil;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class CheckUrlValidate implements ConstraintValidator&lt;CheckUrl, String&gt; &#123;

    @Override
    public boolean isValid(String url, ConstraintValidatorContext context) &#123;
        return UrlUtil.verifyUrl(url.trim());
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/validate/CheckNameValidate.java
package com.imooc.validate;

import com.imooc.utils.UrlUtil;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class CheckNameValidate implements ConstraintValidator&lt;CheckName, String&gt; &#123;

    @Override
    public boolean isValid(String name, ConstraintValidatorContext context) &#123;
        return UrlUtil.verifyName(name.trim());
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/UrlUtil.java 【Url+Name校验标准】
package com.imooc.utils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class UrlUtil &#123;

    /**
     * 验证是否是URL
     * @param url
     * @return
     */
    public static boolean verifyUrl(String url)&#123;

        // URL验证规则
//        String regEx =&quot;[A-Za-z]+://[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_%&amp;\\?\\/.=]+&quot;;
        String regEx = &quot;^([hH][tT]&#123;2&#125;[pP]:/*|[hH][tT]&#123;2&#125;[pP][sS]:/*|[fF][tT][pP]:/*)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~\\/])+(\\?&#123;0,1&#125;(([A-Za-z0-9-~]+\\=&#123;0,1&#125;)([A-Za-z0-9-~]*)\\&amp;&#123;0,1&#125;)*)$&quot;;
        // 编译正则表达式
        Pattern pattern = Pattern.compile(regEx);
        // 忽略大小写的写法
        // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(url);
        // 字符串是否与正则表达式相匹配
        boolean rs = matcher.matches();
        return rs;

    &#125;
    //不能有空格 不能为空 字符串长度要在6-12位
    public static boolean verifyName(String name)&#123;
        // Name验证规则
        String nameEx = &quot;^[^\\s]&#123;6,12&#125;$&quot;;
        // 编译正则表达式
        Pattern pattern = Pattern.compile(nameEx);
        // 忽略大小写的写法
        // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(name);
        // 字符串是否与正则表达式相匹配
        boolean rs = matcher.matches();
        return rs;
    &#125;

    public static void main(String[] args) &#123;
        boolean res = verifyUrl(&quot;http://admin.imoocnews.com:9090/imooc-news/admin/friendLinks.html&quot;);
        boolean nres = verifyName(&quot;Jerry&quot;);
        System.out.println(nres);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">dev-model  pom.xml
 &lt;!-- 引入 mongodb 依赖 --&gt; 【springboot整合mongodb】
        &lt;dependency&gt;
            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
            &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;2.7.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h6 id="真正的友链保存接口"><a href="#真正的友链保存接口" class="headerlink" title="真正的友链保存接口"></a>真正的友链保存接口</h6><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
package com.imooc.admin.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.FriendLinkControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import com.imooc.pojo.mo.FriendLinkMO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.Map;

@RestController
public class FriendLinkController extends BaseController implements FriendLinkControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FriendLinkController.class);


    @Override
    public GraceJSONResult saveOrUpdateFriendLink(SaveFriendLinkBO saveFriendLinkBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;

//      saveFriendLinkBO -&gt; ***Mo  MongoDB校验的对象
        FriendLinkMO friendLinkMO = new FriendLinkMO();
        BeanUtils.copyProperties(saveFriendLinkBO,friendLinkMO);
        friendLinkMO.setCreateTime(new Date());
        friendLinkMO.setUpdateTime(new Date());
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/mo/FriendLinkMO.java
//这些都是设置到MongoDB数据库的名字
//@Document(&quot;FriendLink&quot;) //MongoDB文件起别名
public class FriendLinkMO &#123;
    @Id //作为MongDB的主键了
    private String id;
    @Field(&quot;link_name&quot;)
    private String linkName;
    @Field(&quot;link_url&quot;)
    private String linkUrl;
    @Field(&quot;is_delete&quot;)
    private Integer isDelete;
    @Field(&quot;create_time&quot;)
    private Date createTime;
    @Field(&quot;update_time&quot;)
    private Date updateTime;
&#125;Getter + Setter
</code></pre>
<h3 id="Repository持久层操作保存记录"><a href="#Repository持久层操作保存记录" class="headerlink" title="Repository持久层操作保存记录"></a>Repository持久层操作保存记录</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
package com.imooc.admin.controller;

import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.FriendLinkControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import com.imooc.pojo.mo.FriendLinkMO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.Map;

@RestController
public class FriendLinkController extends BaseController implements FriendLinkControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FriendLinkController.class);
    @Autowired
    private FriendLinkService friendLinkService;

    @Override
    public GraceJSONResult saveOrUpdateFriendLink(SaveFriendLinkBO saveFriendLinkBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;

//      saveFriendLinkBO -&gt; ***Mo  MongoDB校验的对象
        FriendLinkMO friendLinkMO = new FriendLinkMO();
        BeanUtils.copyProperties(saveFriendLinkBO,friendLinkMO);
        friendLinkMO.setCreateTime(new Date());
        friendLinkMO.setUpdateTime(new Date());

        friendLinkService.saveOrUpdateFriendLink(friendLinkMO);
        return GraceJSONResult.ok();
    &#125;
&#125;
// http://admin.imoocnews.com:9090/imooc-news/admin/friendLinks.html
/* 友情连接 → 
链接名称：慕课网
链接地址：www.imooc.com
[新增/添加]

打开检查→Console
&#123;&quot;status&quot;:200,&quot;msg&quot;:&quot;操作成功！&quot;,&quot;success&quot;:true,&quot;data&quot;:null&#125;

打开数据库查看MongoDB→friendLinkMO有存入的数据即操作成功
*/
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;

public interface FriendLinkService &#123;
    /**
     * 新增或者更新友情链接
     */
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/FriendLinkServiceImpl.java
package com.imooc.admin.service.impl;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.AdminUserService;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class FriendLinkServiceImpl implements FriendLinkService &#123;

    @Autowired
    private FriendLinkRepository friendLinkRepository;
    @Override
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO) &#123;
        friendLinkRepository.save(friendLinkMO); //有id更新 无id直接保存
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/repository/FriendLinkRepository.java
package com.imooc.admin.repository;

import com.imooc.pojo.mo.FriendLinkMO;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface FriendLinkRepository extends MongoRepository&lt;FriendLinkMO, String&gt; &#123; //持久层
    // 内置提供了很多方法 find.. delete...
&#125;
</code></pre>
<h3 id="友情链接查询列表-【MongoDB】"><a href="#友情链接查询列表-【MongoDB】" class="headerlink" title="友情链接查询列表 【MongoDB】"></a>友情链接查询列表 【MongoDB】</h3><h6 id="Document-“FriendLink”-x2F-x2F-文件起别名-记得要在MongoDB里面找这个-下面搜索的都在这个文件里面"><a href="#Document-“FriendLink”-x2F-x2F-文件起别名-记得要在MongoDB里面找这个-下面搜索的都在这个文件里面" class="headerlink" title="@Document(“FriendLink”) &#x2F;&#x2F;文件起别名 记得要在MongoDB里面找这个 下面搜索的都在这个文件里面"></a>@Document(“FriendLink”) &#x2F;&#x2F;文件起别名 记得要在MongoDB里面找这个 下面搜索的都在这个文件里面</h6><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
    @ApiOperation(value = &quot;查询改友情连接列表&quot;, notes = &quot;查询改友情连接列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getFriendLinkList&quot;)
    public GraceJSONResult getFriendLinkList();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
package com.imooc.admin.controller;

import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.FriendLinkControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import com.imooc.pojo.mo.FriendLinkMO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.Map;

@RestController
public class FriendLinkController extends BaseController implements FriendLinkControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FriendLinkController.class);
    @Autowired
    private FriendLinkService friendLinkService;

    @Override
    public GraceJSONResult saveOrUpdateFriendLink(SaveFriendLinkBO saveFriendLinkBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;

//      saveFriendLinkBO -&gt; ***Mo  MongoDB校验的对象
        FriendLinkMO friendLinkMO = new FriendLinkMO();
        BeanUtils.copyProperties(saveFriendLinkBO,friendLinkMO);
        friendLinkMO.setCreateTime(new Date());
        friendLinkMO.setUpdateTime(new Date());

        friendLinkService.saveOrUpdateFriendLink(friendLinkMO);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult getFriendLinkList() &#123; 
//【用了FriendLinkRepository里面的】extends MongoRepository 中的简单增删改查 
// 里面的删除是逻辑删除
        return GraceJSONResult.ok(friendLinkService.queryAllFriendLinkList());
    &#125;
&#125;
// http://admin.imoocnews.com:9090/imooc-news/admin/friendLinks.html
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;

import java.util.List;

public interface FriendLinkService &#123;
    /**
     * 新增或者更新友情链接
     */
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO);

    /**
     * 查询友情链接
     */
    public List&lt;FriendLinkMO&gt; queryAllFriendLinkList();

&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/FriendLinkServiceImpl.java
package com.imooc.admin.service.impl;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.AdminUserService;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class FriendLinkServiceImpl implements FriendLinkService &#123;

    @Autowired
    private FriendLinkRepository friendLinkRepository;
    @Override
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO) &#123;
        friendLinkRepository.save(friendLinkMO); //有id更新 无id直接保存
    &#125;

    @Override
    public List&lt;FriendLinkMO&gt; queryAllFriendLinkList() &#123;
//        Pageable pageable = PageRequest.of(1,10);
//        friendLinkRepository.findAll(pageable);
        return friendLinkRepository.findAll();
    &#125;
&#125;
</code></pre>
<h3 id="友情链接删除-【MongoDB】-增加真实删除"><a href="#友情链接删除-【MongoDB】-增加真实删除" class="headerlink" title="友情链接删除 【MongoDB】[增加真实删除]"></a>友情链接删除 【MongoDB】[增加真实删除]</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
...
/*
@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
    @ApiOperation(value = &quot;查询改友情连接列表&quot;, notes = &quot;查询改友情连接列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getFriendLinkList&quot;)
    public GraceJSONResult getFriendLinkList();
*/
    @ApiOperation(value = &quot;删除改友情连接列表&quot;, notes = &quot;删除改友情连接列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/delete&quot;)
    public GraceJSONResult delete(@RequestParam String linkId);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
@Override
    public GraceJSONResult delete(String linkId) &#123;
        friendLinkService.delete(linkId);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
    /**
     * 删除友情链接
     */
    public void delete(String linkId);
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
@Override
    public void delete(String linkId) &#123;
        friendLinkRepository.deleteById(linkId);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java 【增加友链拦截器】
/*
package com.imooc.api.config;

import com.imooc.api.interceptors.AdminTokenInterceptor;
import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);
        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;)
                .addPathPatterns(&quot;/fs/uploadToGridFS&quot;)
*/
                .addPathPatterns(&quot;/friendLinkMng/saveOrUpdateFriendLink&quot;)
                .addPathPatterns(&quot;/friendLinkMng/getFriendLinkList&quot;)
                .addPathPatterns(&quot;/friendLinkMng/delete&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="【作业】文章分类管理-新增或修改分类、查询分类列表、用户端查询分类列表"><a href="#【作业】文章分类管理-新增或修改分类、查询分类列表、用户端查询分类列表" class="headerlink" title="【作业】文章分类管理 [新增或修改分类、查询分类列表、用户端查询分类列表]"></a>【作业】文章分类管理 <del>[新增或修改分类、查询分类列表、用户端查询分类列表]</del></h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/categoryMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/categoryMng.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/80972817">@RequestBody的使用-CSDN博客</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/admin/CategoryMngControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveCatrgoryBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@Api(value = &quot;文章分类维护&quot;, tags = &#123;&quot;文章分类维护controller&quot;&#125;)
@RequestMapping(&quot;categoryMng&quot;)
public interface CategoryMngControllerApi &#123;
    @PostMapping(&quot;saveOrUpdateCategory&quot;)
    @ApiOperation(value = &quot;新增或修改分类&quot;, notes = &quot;新增或修改分类&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult saveOrUpdateCategory(@RequestBody @Valid SaveCatrgoryBO saveCatrgoryBO,
                                                BindingResult result);
    @PostMapping(&quot;getCatList&quot;)
    @ApiOperation(value = &quot;查询分类列表&quot;, notes = &quot;查询分类列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult getCatList();

    @GetMapping(&quot;getCats&quot;)
    @ApiOperation(value = &quot;用户端查询分类列表&quot;, notes = &quot;用户端查询分类列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult getCats();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/CategoryMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.CategoryService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.CategoryMngControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Category;
import com.imooc.pojo.bo.SaveCatrgoryBO;
import com.imooc.utils.JsonUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
public class CategoryMngController extends BaseController implements CategoryMngControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(CategoryMngController.class);

    @Autowired
    private CategoryService categoryService;

    @Override
    public GraceJSONResult saveOrUpdateCategory(SaveCatrgoryBO saveCatrgoryBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
        // 判断BindingResult是否保存错误的验证信息，如果有，则直接return
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;
        Category newCat = new Category();
        BeanUtils.copyProperties(saveCatrgoryBO,newCat);
        // id为空新增，不为空修改
        if (saveCatrgoryBO.getId() == null)&#123;
            //查询新增的分类名称不能重复存在
            boolean isExist = categoryService.queryCatIsExist(newCat.getName(), null);
            if (!isExist)&#123;
                //新增到数据库
                categoryService.createCategory(newCat);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.CATEGORY_EXIST_ERROR);
            &#125;
        &#125;else &#123;
            //查询修改的分类名称不能重复存在
            boolean isExist = categoryService.queryCatIsExist(newCat.getName(), saveCatrgoryBO.getOldName());
            if (!isExist)&#123;
                //修改到数据库
                categoryService.modifyCategory(newCat);
            &#125; else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.CATEGORY_EXIST_ERROR);
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult getCatList() &#123;
        List&lt;Category&gt; categoryList = categoryService.queryCategoryList();
        return GraceJSONResult.ok(categoryList);
    &#125;

    @Override
    public GraceJSONResult getCats() &#123;
        // 先从redis中查询，如果有，则返回，如果没有，则查询数据库库后先放缓存，放返回
        String allCatJson = redis.get(REDIS_ALL_CATEGORY);

        List&lt;Category&gt; categoryList = null;
        if (StringUtils.isBlank(allCatJson)) &#123;
            categoryList = categoryService.queryCategoryList();
            redis.set(REDIS_ALL_CATEGORY, JsonUtils.objectToJson(categoryList));
        &#125; else &#123;
            categoryList = JsonUtils.jsonToList(allCatJson, Category.class);
        &#125;

        return GraceJSONResult.ok(categoryList);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/CategoryService.java
package com.imooc.admin.service;

import com.imooc.pojo.Category;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增文章分类
     */
    public void createCategory(Category category);

    /**
     * 修改文章分类列表
     */
    public void modifyCategory(Category category);

    /**
     * 查询分类名是否已经存在
     */
    public boolean queryCatIsExist(String catName, String oldCatName);

    /**
     * 获得文章分类列表
     */
    public List&lt;Category&gt; queryCategoryList();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/CategoryServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.CategoryMapper;
import com.imooc.admin.service.CategoryService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Category;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.List;

import static com.imooc.api.BaseController.REDIS_ALL_CATEGORY;


@Service
public class CategoryServiceImpl implements CategoryService &#123;
    @Autowired
    public CategoryMapper categoryMapper;
    @Autowired
    public RedisOperator redis;

    @Transactional
    @Override
    public void createCategory(Category category) &#123;
// 分类不会很多，所以id不需要自增，这个表的数据也不会多到几万甚至分表，数据都会集中在一起
        int result = categoryMapper.insert(category);
        if (result != 1)&#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
            /**
             * 不建议如下做法：
             * 1. 查询redis中的categoryList
             * 2. 转化categoryList为list类型
             * 3. 在categoryList中add一个当前的category
             * 4. 再次转换categoryList为json，并存入redis中
             */
            // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
            redis.del(REDIS_ALL_CATEGORY);
        &#125;
    &#125;

    @Transactional
    @Override
    public void modifyCategory(Category category) &#123;
        int result = categoryMapper.updateByPrimaryKey(category);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125;
        // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
        redis.del(REDIS_ALL_CATEGORY);
    &#125;

    @Override
    public boolean queryCatIsExist(String catName, String oldCatName) &#123;
        Example example = new Example(Category.class);
        Example.Criteria catCriteria = example.createCriteria();
        catCriteria.andEqualTo(&quot;name&quot;, catName);
        if (StringUtils.isNotBlank(oldCatName)) &#123;
            catCriteria.andNotEqualTo(&quot;name&quot;, oldCatName);
        &#125;

        List&lt;Category&gt; catList = categoryMapper.selectByExample(example);

        boolean isExist = false;
        if (catList != null &amp;&amp; !catList.isEmpty() &amp;&amp; catList.size() &gt; 0) &#123;
            isExist = true;
        &#125;

        return isExist;
    &#125;

    @Override
    public List&lt;Category&gt; queryCategoryList() &#123;
        return categoryMapper.selectAll();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/mapper/CategoryMapper.java
package com.imooc.admin.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Category;
import org.springframework.stereotype.Repository;

@Repository
public interface CategoryMapper extends MyMapper&lt;Category&gt; &#123;
&#125;
</code></pre>
<pre><code class="xml">service-admin  resources/mapper/CategoryMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.admin.mapper.CategoryMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Category&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;tag_color&quot; property=&quot;tagColor&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public abstract class BaseController &#123;
    @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_USER_INFO = &quot;redis_user_info&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_ADMIN_TOKEN = &quot;redis_admin_token&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_ALL_CATEGORY = &quot;redis_all_category&quot;;

    public static final String REDIS_WRITER_FANS_COUNTS = &quot;redis_writer_fans_counts&quot;;
    public static final String REDIS_MY_FOLLOW_COUNTS = &quot;redis_my_follow_counts&quot;;

    public static final String REDIS_ARTICLE_READ_COUNTS = &quot;redis_article_read_counts&quot;;
    public static final String REDIS_ALREADY_READ = &quot;redis_already_read&quot;;

    public static final String REDIS_ARTICLE_COMMENT_COUNTS = &quot;redis_article_comment_counts&quot;;

    @Value(&quot;$&#123;website.domain-name&#125;&quot;)
    public String DOMAIN_NAME;
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;
    public static final Integer COOKIE_DELETE = 0;

    public static final Integer COMMON_START_PAGE = 1;
    public static final Integer COMMON_PAGE_SIZE = 10;
&#125;...
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Category.java
package com.imooc.pojo;

import javax.persistence.Column;
import javax.persistence.Id;

public class Category &#123;
    @Id
    private Integer id;

    /**
     * 分类名，比如：科技，人文，历史，汽车等等
     */
    private String name;

    /**
     * 标签颜色
     */
    @Column(name = &quot;tag_color&quot;)
    private String tagColor;
&#125;Getter + Setter
</code></pre>
<h3 id="查询用户列表-设置时间日期转换配置-【用户管理】"><a href="#查询用户列表-设置时间日期转换配置-【用户管理】" class="headerlink" title="查询用户列表_设置时间日期转换配置 【用户管理】"></a>查询用户列表_设置时间日期转换配置 【用户管理】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/AppUserMngControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.Date;

@Api(value = &quot;用户管理相关的接口定义&quot;,tags = &#123;&quot;用户管理相关功能的controller&quot;&#125;)
@RequestMapping(&quot;appUser&quot;)
public interface AppUserMngControllerApi &#123;
    @ApiOperation(value = &quot;查询所有网站用户&quot;,notes = &quot;查询所有网站用户&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;queryAll&quot;)
    public GraceJSONResult queryAll(@RequestParam String nickname,
                                    @RequestParam Integer status,
                                    @RequestParam Date startDate,
                                    @RequestParam Date endDate,
                                    @RequestParam Integer page,
                                    @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/AppUserMngController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.AppUserMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;

@RestController
public class AppUserMngController extends BaseController implements AppUserMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AppUserMngController.class);
// 字符串无法直接转换成Date类型 需要工具类转换 DateConverterConfig com/imooc/api/config/DateConverterConfig.java

    @Override
    public GraceJSONResult queryAll(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        System.out.println(startDate);
        System.out.println(endDate);
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        return GraceJSONResult.ok();
    &#125;
&#125;
// http://admin.imoocnews.com:9090/imooc-news/admin/userList.html
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/DateConverterConfig.java
package com.imooc.api.config;


import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * 请求路径url中的参数进行时间日期类型的转换，字符串-&gt;日期Date
 */
@Configuration
public class DateConverterConfig implements Converter&lt;String, Date&gt; &#123;

    private static final List&lt;String&gt; formatterList = new ArrayList&lt;&gt;(4);
    static&#123;
        formatterList.add(&quot;yyyy-MM&quot;);
        formatterList.add(&quot;yyyy-MM-dd&quot;);
        formatterList.add(&quot;yyyy-MM-dd hh:mm&quot;);
        formatterList.add(&quot;yyyy-MM-dd hh:mm:ss&quot;);
    &#125;

    @Override
    public Date convert(String source) &#123;
        String value = source.trim();
        if (&quot;&quot;.equals(value)) &#123;
            return null;
        &#125;
        if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(0));
        &#125;else if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(1));
        &#125;else if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; &#123;1&#125;\\d&#123;1,2&#125;:\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(2));
        &#125;else if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; &#123;1&#125;\\d&#123;1,2&#125;:\\d&#123;1,2&#125;:\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(3));
        &#125;else &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_DATE_PARSER_ERROR);
        &#125;
        return null;
    &#125;

    /**
     * 日期转换方法
     * @param dateStr
     * @param formatter
     * @return
     */
    public Date parseDate(String dateStr, String formatter) &#123;
        Date date=null;
        try &#123;
            DateFormat dateFormat = new SimpleDateFormat(formatter);
            date = dateFormat.parse(dateStr);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return date;
    &#125;
&#125;
</code></pre>
<h3 id="查询用户列表-实现service与联调-【用户管理】"><a href="#查询用户列表-实现service与联调-【用户管理】" class="headerlink" title="查询用户列表_实现service与联调 【用户管理】"></a>查询用户列表_实现service与联调 【用户管理】</h3><pre><code class="java">service-user  com/imooc/user/service/AppUserMngService.java
package com.imooc.user.service;

import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;

public interface AppUserMngService &#123;
    /**
     * 查询管理员列表
     * @param nickname
     * @param status
     * @param startDate
     * @param endDate
     * @param page
     * @param pageSize
     * @return
     */
    public PagedGridResult queryAllUserList(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/service/BaseService.java
package com.imooc.api.service;

import com.github.pagehelper.PageInfo;
import com.imooc.utils.PagedGridResult;

import java.util.List;

public class BaseService &#123;
    public PagedGridResult setterPagedGrid(List&lt;?&gt; list, Integer page)&#123; //类型是? 后期不确定是什么泛型
        PageInfo&lt;?&gt; pageList = new PageInfo&lt;&gt;(list);
        PagedGridResult gridResult = new PagedGridResult();
        gridResult.setRows(list);
        gridResult.setPage(page);
        gridResult.setRecords(pageList.getTotal());
        gridResult.setTotal(pageList.getPages());
        return gridResult;

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/AppUserMngServiceImpl.java
package com.imooc.user.service.impl;

import com.github.pagehelper.PageHelper;
import com.imooc.api.service.BaseService;
import com.imooc.enums.Sex;
import com.imooc.enums.UserStatus;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.service.AppUserMngService;
import com.imooc.user.service.UserService;
import com.imooc.utils.*;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class AppUserMngServiceImpl extends BaseService implements AppUserMngService &#123;
    @Autowired
    public AppUserMapper appUserMapper;

    @Override
    public PagedGridResult queryAllUserList(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        Example example = new Example(AppUser.class);
        example.orderBy(&quot;createdTime&quot;).desc();
        Example.Criteria criteria = example.createCriteria();
        if (StringUtils.isNotBlank(nickname)) &#123;
            criteria.andLike(&quot;nickname&quot;, &quot;%&quot; + nickname + &quot;%&quot;);
        &#125;
        if (UserStatus.isUserStatusValid(status))&#123;
            criteria.andEqualTo(&quot;activeStatus&quot;, status); //对比状态
        &#125;
        if (startDate != null)&#123;
            criteria.andGreaterThanOrEqualTo(&quot;createdTime&quot;, startDate);//数据库和传入参数对比
        &#125;
        if (endDate != null)&#123;
            criteria.andLessThanOrEqualTo(&quot;endTime&quot;, endDate);//数据库和传入参数对比
        &#125;
        PageHelper.startPage(page, pageSize);
        List&lt;AppUser&gt; list = appUserMapper.selectByExample(example);

        return setterPagedGrid(list,page);
    &#125;
&#125;
</code></pre>
<h3 id="查询用户账户-冻结与解封-【用户管理】"><a href="#查询用户账户-冻结与解封-【用户管理】" class="headerlink" title="查询用户账户_冻结与解封 【用户管理】"></a>查询用户账户_冻结与解封 【用户管理】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/AppUserMngControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.Date;

@Api(value = &quot;用户管理相关的接口定义&quot;,tags = &#123;&quot;用户管理相关功能的controller&quot;&#125;)
@RequestMapping(&quot;appUser&quot;)
public interface AppUserMngControllerApi &#123;
    @ApiOperation(value = &quot;查询所有网站用户&quot;,notes = &quot;查询所有网站用户&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;queryAll&quot;)
    public GraceJSONResult queryAll(@RequestParam String nickname,
                                    @RequestParam Integer status,
                                    @RequestParam Date startDate,
                                    @RequestParam Date endDate,
                                    @RequestParam Integer page,
                                    @RequestParam Integer pageSize);

    @ApiOperation(value = &quot;查看用户详情&quot;,notes = &quot;查看用户详情&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;userDetail&quot;)
    public GraceJSONResult userDetail(@RequestParam String userId);

    @ApiOperation(value = &quot;冻结用户或者解冻用户&quot;,notes = &quot;冻结用户或者解冻用户&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;freezeUserOrNot&quot;)
    public GraceJSONResult freezeUserOrNot(@RequestParam String userId,@RequestParam Integer doStatus);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/AppUserMngController.java
@RestController
public class AppUserMngController extends BaseController implements AppUserMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AppUserMngController.class);
    
    @Autowired
    private AppUserMngService appUserMngService;
    @Autowired
    private UserService userService;
......
    
     @Override
    public GraceJSONResult freezeUserOrNot(String userId, Integer doStatus) &#123;
        if (!UserStatus.isUserStatusValid(doStatus))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_STATUS_ERROR);
        &#125;
        appUserMngService.freezeUserOrNot(userId, doStatus);
        //若冻结后 用户处于登录状态 还可以进行操作 所以要刷新用户状态
        //方法①：删除用户会话，从而保证用户需要重新登陆以后再来刷新她的会话状态
        redis.del(REDIS_USER_INFO + &quot;:&quot; + userId);
        //方法②：查询最新用户的信息，重新放入redis中，做一次更新
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/AppUserMngService.java
package com.imooc.user.service;

import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;

public interface AppUserMngService &#123;
    /**
     * 查询管理员列表
     */
    public PagedGridResult queryAllUserList(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

    /**
     * 冻结用户账号或者解除冻结
     */
    public void freezeUserOrNot(String userId, Integer doStatus);

&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/AppUserMngServiceImpl.java
    @Transactional
    @Override
    public void freezeUserOrNot(String userId, Integer doStatus) &#123;
        AppUser user = new AppUser();
        user.setId(userId);
        user.setActiveStatus(doStatus);
        appUserMapper.updateByPrimaryKeySelective(user);
    &#125;
</code></pre>
<h3 id="梳理文章article表结构-【文章服务】"><a href="#梳理文章article表结构-【文章服务】" class="headerlink" title="梳理文章article表结构 【文章服务】"></a>梳理文章article表结构 【文章服务】</h3><ul>
<li><strong>构建文章服务</strong></li>
<li><strong>作者中心发表文章</strong></li>
<li><strong>作者中心内容管理</strong></li>
<li><strong>自动审核<del>[阿里客户端]</del>，手动审核</strong></li>
</ul>
<h3 id="构建文章服务工程-【文章服务】"><a href="#构建文章服务工程-【文章服务】" class="headerlink" title="构建文章服务工程 【文章服务】"></a>构建文章服务工程 【文章服务】</h3><blockquote>
<p>新创建一个Module<br>GroupId：com.imooc<br>ArtifactId：imooc-news-dev-service-article<br>pom参考service-admin移植  resources里的所有文件(除mapper)也要移植</p>
</blockquote>
<pre><code class="xml">service-article  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-article&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">resources logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-article&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-article&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/service-article.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java
package com.imooc.article;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;

========================================================================
http://localhost:8001/hello
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: null
&#125;
</code></pre>
<pre><code class="yaml">service-article  application-dev
server:
  port: 8001

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
## setup CN from java, This is resource
website:
  domain-name: imoocnews.com

## open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<pre><code class="yaml">############################################################
#
# admin用户微服务
# web访问端口号  约定：8001
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-article
  datasource: # 数据源的相关配置
    type: com.zaxxer.hikari.HikariDataSource          # 数据源类型：HikariCP
    driver-class-name: org.mariadb.jdbc.Driver       # mysql驱动
    url: jdbc:mysql://localhost:3306/imooc-news-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;sessionVariables=tx_isolation=&#39;READ-COMMITTED&#39;
    username: root
    password: root
    hikari:
      connection-timeout: 30000       # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 默认:30秒
      minimum-idle: 5                 # 最小连接数
      maximum-pool-size: 20           # 最大连接数
      auto-commit: true               # 自动提交
      idle-timeout: 600000            # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟
      pool-name: DateSourceHikariCP     # 连接池名字
      max-lifetime: 1800000           # 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟 1800000ms
      connection-test-query: SELECT 1
      data-source-properties:
        tx_isolation: &#39;READ-COMMITTED&#39;
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8

  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
############################################################
#
# mybatis 配置
#
############################################################
mybatis:
  type-aliases-package: com.imooc.pojo          # 所有POJO类所在包路径
  mapper-locations: classpath:mapper/*.xml      # mapper映射文件

############################################################
#
# mybatis mapper 配置
#
############################################################
# 通用 Mapper 配置
mapper:
  mappers: com.imooc.my.mapper.MyMapper
  not-empty: false    # 在进行数据库操作的的时候，判断表达式 username != null, 是否追加 username != &#39;&#39;
  identity: MYSQL
# 分页插件配置
pagehelper:
  helperDialect: mysql
  supportMethodsArguments: true
</code></pre>
<h3 id="summernote与多文件上传需求-【发头条】"><a href="#summernote与多文件上传需求-【发头条】" class="headerlink" title="summernote与多文件上传需求 【发头条】"></a>summernote与多文件上传需求 【发头条】</h3><p><a target="_blank" rel="noopener" href="https://summernote.org/">https://summernote.org/</a></p>
<pre><code class="html">【前端工程里面的】createArticle.html
...
&lt;script src=&quot;libs/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;libs/axios.min.js&quot;&gt;&lt;/script&gt;

&lt;link href=&quot;./libs/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script src=&quot;./libs/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;libs/layDate-v5.0.9/laydate/laydate.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./libs/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;link href=&quot;./libs/summernote/dist/summernote.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script src=&quot;./libs/summernote/dist/summernote.js&quot;&gt;&lt;/script&gt;
&lt;!-- 中文汉化 --&gt;
&lt;script src=&quot;libs/summernote/lang/summernote-zh-CN.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

......
&lt;!-- 富文本编辑器 --&gt;
        &lt;div id=&quot;editor2&quot; class=&quot;editor-container&quot;&gt;

            &lt;div class=&quot;article-title-wrapper&quot;&gt;
                &lt;input id=&quot;title&quot; class=&quot;article-title&quot; placeholder=&quot;请输入文字标题（6-30长度）&quot; v-model=&quot;articleTitle&quot; maxlength=&quot;30&quot;/&gt;
            &lt;/div&gt;

            &lt;div class=&quot;article-content-wrapper&quot;&gt;
                &lt;div id=&quot;summernote&quot; class=&quot;summernote&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;other-info&quot;&gt;
                &lt;div class=&quot;cover-wrapper&quot;&gt;
                    &lt;div class=&quot;cover&quot;&gt;文章领域&lt;/div&gt;
                    &lt;div class=&quot;choose-type&quot;&gt;
                        &lt;!-- &lt;select v-model=&quot;articleCategory&quot;&gt;
                            &lt;option value=&quot;0&quot;&gt;请选择&lt;/option&gt;
                            &lt;option value=&quot;1&quot;&gt;汽车&lt;/option&gt;
                            &lt;option value=&quot;2&quot;&gt;科技&lt;/option&gt;
                            &lt;option value=&quot;3&quot;&gt;历史&lt;/option&gt;
                        &lt;/select&gt; --&gt;

                        &lt;select v-model=&quot;articleCategory&quot;&gt;
                            &lt;option :value=&quot;cat.id&quot; v-for=&quot;(cat, index) in catList&quot; v-key=&quot;index&quot;&gt;&#123;&#123;cat.name&#125;&#125;&lt;/option&gt;
                        &lt;/select&gt;
                        
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;cover-wrapper&quot;&gt;
                    &lt;div class=&quot;cover&quot;&gt;文章封面&lt;/div&gt;
                    &lt;div class=&quot;choose-type&quot;&gt;
                        &lt;div&gt;&lt;input type=&quot;radio&quot; name=&quot;articleType&quot; v-model=&quot;articleType&quot; value=&quot;1&quot; checked/&gt;&lt;span class=&quot;choose-words&quot;&gt;单封面&lt;/span&gt;&lt;/div&gt;
                        &lt;div style=&quot;margin-left: 30px;&quot;&gt;&lt;input type=&quot;radio&quot; v-model=&quot;articleType&quot; value=&quot;2&quot; name=&quot;articleType&quot;/&gt;&lt;span class=&quot;choose-words&quot;&gt;无封面&lt;/span&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;cover-wrapper&quot; v-show=&quot;articleType==1&quot;&gt;
                    &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;choose-cover&quot;&gt;
                        &lt;div class=&quot;uploader-comp&quot;&gt;
                            &lt;div id=&quot;block-choose&quot; class=&quot;block-choose&quot; :style=&quot;coverStyle&quot;&gt;
                                &lt;img src=&quot;./img/icon-go-upload.png&quot; style=&quot;width: 20px; height: 20px; align-self: center;&quot; v-show=&quot;articleCover == &#39;&#39; || articleCover == null&quot;/&gt;
                            &lt;/div&gt;
                            &lt;input type=&quot;file&quot; @change=&quot;uploadCover&quot; @mouseover=&quot;mouseOver&quot; @mouseout=&quot;mouseOut&quot; id=&quot;inputPic&quot; class=&quot;inputPic&quot; accept=&quot;image/jpeg,image/jpg,image/png&quot;&gt;
                        &lt;/div&gt;
                        &lt;div style=&quot;margin-top: 10px; color: #9b9d9e;&quot;&gt;请上传JPG、JPEG、PNG格式的封面图噢~&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;publish-bottom&quot;&gt;
                &lt;div class=&quot;buttons&quot;&gt;
                    &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;goBack&quot;&gt;返回&lt;/button&gt;
                    &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;preview&quot;&gt;预览&lt;/button&gt;
                    &lt;!-- &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;save&quot;&gt;保存草稿&lt;/button&gt; --&gt;
                    &lt;!-- FIXME: 计算剩余时间，使用RMQ延时队列，或分布式定时任务 --&gt;
                    &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;doTiming&quot;&gt;&#123;&#123;appointWords&#125;&#125;&lt;/button&gt;
                    
                    &lt;input type=&quot;text&quot; class=&quot;timing-date-picker&quot; placeholder=&quot;定时日期&quot; id=&quot;choose-date&quot; v-show=&quot;isAppoint==1&quot; readonly&gt;

                    &lt;button class=&quot;red-btn&quot; type=&quot;button&quot; @click=&quot;publish&quot;&gt;发布文章&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

......
// 初始化编辑器
            $(&#39;#summernote&#39;).summernote(&#123;
                placeholder: &#39;请输入正文...&#39;,
                lang: &#39;zh-CN&#39;,
                height: 600,
                width: 800,
                border: 0,
                // disableDragAndDrop: true, // 禁止文件拖放
                toolbar: [
                    [&#39;style&#39;, [&#39;style&#39;]],
                    [&#39;font&#39;, [&#39;bold&#39;, &#39;underline&#39;, &#39;clear&#39;]],
                    [&#39;color&#39;, [&#39;color&#39;]],
                    [&#39;para&#39;, [&#39;ul&#39;, &#39;ol&#39;, &#39;paragraph&#39;]],
                    [&#39;table&#39;, [&#39;table&#39;]],
                    [&#39;insert&#39;, [&#39;link&#39;, &#39;picture&#39;]],
                    [&#39;view&#39;, [&#39;fullscreen&#39;, &#39;codeview&#39;, &#39;help&#39;]]
                ],
</code></pre>
<h3 id="实现多文件上传uploadSomeFiles-【发头条】"><a href="#实现多文件上传uploadSomeFiles-【发头条】" class="headerlink" title="实现多文件上传uploadSomeFiles 【发头条】"></a>实现多文件上传<del>uploadSomeFiles</del> 【发头条】</h3><p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html">媒体号作家中心 | 发文章 (imoocnews.com)</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploaderControllerApi.java
package com.imooc.api.controller.files;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploaderControllerApi &#123;
    /**
     * 上传单文件
     * @param userId
     * @param file
     * @return
     * @throws Exception
     */
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;上传用户头像&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    /**
     * 上传多文件
     * @param userId
     * @param files
     * @return
     * @throws Exception
     */
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;上传用户头像&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadSomeFiles&quot;)  //因为前端createArticle.html 178行 multiForm.append(&#39;files&#39;,f,f.name);
    public GraceJSONResult uploadSomeFiles(@RequestParam String userId, MultipartFile[] files) throws Exception;
......
&#125;
</code></pre>
<pre><code class="java">service-file  com/imooc/files/controller/FileUploaderController.java
......
@Override
    public GraceJSONResult uploadSomeFiles(String userId, MultipartFile[] files) throws Exception &#123;
        // 声明一个list，用于存放多个图片的地址路径，返回到前端
        List&lt;String&gt; imageUrlList = new ArrayList&lt;&gt;();
        if (files != null &amp;&amp; files.length &gt; 0)&#123;
            for (MultipartFile file: files)&#123;
                String path = &quot;&quot;;
                if (file != null)&#123;
                    // 获得文件上传的名称
                    String fileName = file.getOriginalFilename();
                    //判断文件名不能为空
                    if (StringUtils.isNotBlank(fileName))&#123;
                        String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                        //获得后缀名
                        String suffix = fileNameArr[fileNameArr.length - 1];
                        //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                        if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                                !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                                !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                        )&#123;
                           continue;
                        &#125;
                        // fdfs执行上传     要让外面得以访问 ①需要把内网的环境发布到公网 [内网穿透]  ②路由器端口映射到外网  ③fastdfs安装到公网里
                        // path = uploaderService.uploadFdfs(file, suffix);
                        // OSS执行上传
                        path = uploaderService.uploadOSS(file, userId, suffix);
                    &#125;else &#123;
                        continue;
                    &#125;
                &#125;else &#123;
                    continue;
                &#125;
                String finalPath = &quot;&quot;;
                if (StringUtils.isNotBlank(path))&#123;
//            finalPath = fileResource.getHost() + path;
                    finalPath = fileResource.getOssHost() + path;
                    // FIXME: 放入到imageUrlList之前，需要对图片做一次审核 [doAliImageReview]
                    imageUrlList.add(finalPath);
                &#125;  else&#123;
                    continue;
                &#125;
//                return GraceJSONResult.ok(finalPath);
//        return GraceJSONResult.ok(doAliImageReview(finalPath)); //这里加了图片审核咯
            &#125;
        &#125;
        return GraceJSONResult.ok(imageUrlList);
    &#125;
......
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java 
package com.imooc.api.config;
//【增加拦截uploadSomeFiles】
@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;)
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;);

        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;)
                .addPathPatterns(&quot;/fs/uploadToGridFS&quot;)
                .addPathPatterns(&quot;/friendLinkMng/saveOrUpdateFriendLink&quot;)
                .addPathPatterns(&quot;/friendLinkMng/getFriendLinkList&quot;)
                .addPathPatterns(&quot;/friendLinkMng/delete&quot;)
                .addPathPatterns(&quot;/categoryMng/saveOrUpdateCategory&quot;)
                .addPathPatterns(&quot;/categoryMng/getCatList&quot;);

        registry.addInterceptor(userActiveInterceptor())
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="获得列表-业务接口解耦与Redis缓存应用-【文章领域】"><a href="#获得列表-业务接口解耦与Redis缓存应用-【文章领域】" class="headerlink" title="获得列表_业务接口解耦与Redis缓存应用 【文章领域】"></a>获得列表_业务接口解耦与Redis缓存应用 【文章领域】</h3><blockquote>
<p>getCatList 和 getCats 一个是用户端一个是admin 业务体系不一样 所以同样是查询分类列表<br>但是还是应该拆开 使耦合减少 得到高效解耦<br>查询放在Redis里面 效率变高</p>
<p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html">媒体号作家中心 | 发文章 (imoocnews.com)</a><br>刷新一下 文章领域就可以找到那些分类<br>Redis里面会有信息 redis_all_category<br>[{“id”:2,”name”:”汽车”,”tagColor”:”#8939bd”},{“id”:3,”name”:”娱乐”,”tagColor”:”#c939aa”},{“id”:5,”name”:”地理”,”tagColor”:”#57394a”},{“id”:6,”name”:”历史”,”tagColor”:”#29ab4a”},{“id”:7,”name”:”科技”,”tagColor”:”#2467bc”},{“id”:9,”name”:”体育”,”tagColor”:”#c98f4a”},{“id”:10,”name”:”搞笑”,”tagColor”:”#68b84a”},{“id”:11,”name”:”技术”,”tagColor”:”#c9394a”},{“id”:12,”name”:”慕课”,”tagColor”:”#682aa8”},{“id”:13,”name”:”技能”,”tagColor”:”#c9394a”},{“id”:14,”name”:”课网”,”tagColor”:”#c9a24a”}]</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/admin/CategoryMngControllerApi.java
// 【getCasts】
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveCatrgoryBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@Api(value = &quot;文章分类维护&quot;, tags = &#123;&quot;文章分类维护controller&quot;&#125;)
@RequestMapping(&quot;categoryMng&quot;)
public interface CategoryMngControllerApi &#123;
    @PostMapping(&quot;saveOrUpdateCategory&quot;)
    @ApiOperation(value = &quot;新增或修改分类&quot;, notes = &quot;新增或修改分类&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult saveOrUpdateCategory(@RequestBody @Valid SaveCatrgoryBO saveCatrgoryBO,
                                                BindingResult result);
    @PostMapping(&quot;getCatList&quot;)
    @ApiOperation(value = &quot;查询分类列表&quot;, notes = &quot;查询分类列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult getCatList();

    @GetMapping(&quot;getCats&quot;)
    @ApiOperation(value = &quot;用户端查询分类列表&quot;, notes = &quot;用户端查询分类列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult getCats();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/CategoryMngController.java
@Override
    public GraceJSONResult getCats() &#123;
        // 先从redis中查询，如果有，则返回，如果没有，则查询数据库库后先放缓存，放返回
        String allCatJson = redis.get(REDIS_ALL_CATEGORY);

        List&lt;Category&gt; categoryList = null;
        if (StringUtils.isBlank(allCatJson)) &#123;
            categoryList = categoryService.queryCategoryList();
            redis.set(REDIS_ALL_CATEGORY, JsonUtils.objectToJson(categoryList));
        &#125; else &#123;
            categoryList = JsonUtils.jsonToList(allCatJson, Category.class);
        &#125;

        return GraceJSONResult.ok(categoryList);
    &#125;
</code></pre>
<h3 id="admin端维护数据缓存-【文章领域】"><a href="#admin端维护数据缓存-【文章领域】" class="headerlink" title="admin端维护数据缓存 【文章领域】"></a>admin端维护数据缓存 【文章领域】</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/categoryMng.html">文章分类 | 运营管理平台 (imoocnews.com)</a><br>在管理员修改文章类型后 【课网 → 课课】<br><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html">媒体号作家中心 | 发文章 (imoocnews.com)</a><br>回到用户发文章的文章领域类型也会一起修改<br><a target="_blank" rel="noopener" href="http://www.imoocnews.com:9090/imooc-news/portal/index.html">慕课新闻 | 风间影月 (imoocnews.com)</a><br>同时首页上方的栏目框也会修改</p>
</blockquote>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/CategoryServiceImpl.java
@Service
public class CategoryServiceImpl extends BaseService implements CategoryService &#123;
    @Autowired
    public CategoryMapper categoryMapper;

    @Transactional
    @Override
    public void createCategory(Category category) &#123;
// 分类不会很多，所以id不需要自增，这个表的数据也不会多到几万甚至分表，数据都会集中在一起
        int result = categoryMapper.insert(category);
        if (result != 1)&#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
            /**
             * 不建议如下做法：
             * 1. 查询redis中的categoryList
             * 2. 转化categoryList为list类型
             * 3. 在categoryList中add一个当前的category
             * 4. 再次转换categoryList为json，并存入redis中
             */
            // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
            redis.del(REDIS_ALL_CATEGORY);
        &#125;
    &#125;

    @Transactional
    @Override
    public void modifyCategory(Category category) &#123;
        int result = categoryMapper.updateByPrimaryKey(category);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125;
        // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
        redis.del(REDIS_ALL_CATEGORY);
    &#125;
......
</code></pre>
<h3 id="发布文章入库Controller及验证【发头条】"><a href="#发布文章入库Controller及验证【发头条】" class="headerlink" title="发布文章入库Controller及验证【发头条】"></a>发布文章入库Controller及验证【发头条】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
package com.imooc.api.controller.article;

@Api(value = &quot;文章业务的controller&quot;, tags = &#123;&quot;文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article&quot;)
public interface ArticleControllerApi &#123;
    @PostMapping(&quot;createArticle&quot;)
    @ApiOperation(value = &quot;用户发文&quot;, notes = &quot;用户发文&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult createArticle(@RequestBody @Valid NewArticleBO newArticleBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
package com.imooc.article.controller;

@RestController
public class ArticleController extends BaseController implements ArticleControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(ArticleController.class);

    @Override
    public GraceJSONResult createArticle(NewArticleBO newArticleBO, BindingResult result) &#123;
            if (result.hasErrors())&#123;
                // 判断BindingResult是否保存错误的验证信息，如果有，则直接return
                Map&lt;String, String&gt; errorMap = getErrors(result);
                return GraceJSONResult.errorMap(errorMap);
            &#125;
            // 判断文章封面类型，单图必填，纯文字则设置为空
            if (newArticleBO.getArticleType() == ArticleCoverType.ONE_IMAGE.type)&#123;
                if (StringUtils.isBlank(newArticleBO.getArticleCover()))&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_CATEGORY_NOT_EXIST_ERROR);
                &#125;
            &#125; else if (newArticleBO.getArticleType() == ArticleCoverType.WORDS.type) &#123;
                newArticleBO.setArticleCover(&quot;&quot;);
            &#125;

        // 判断分类id是否存在
        String allCatJson = redis.get(REDIS_ALL_CATEGORY);
        Category temp = null;
        if (StringUtils.isBlank(allCatJson)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125; else &#123;
            List&lt;Category&gt; catList =
                    JsonUtils.jsonToList(allCatJson, Category.class);
            for (Category c : catList) &#123;
                if(c.getId() == newArticleBO.getCategoryId()) &#123;
                    temp = c;
                    break;
                &#125;
            &#125;
            if (temp == null) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_CATEGORY_NOT_EXIST_ERROR);
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
&#125;
http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/NewArticleBO.java
package com.imooc.pojo.bo;

import com.fasterxml.jackson.annotation.JsonFormat;
import org.hibernate.validator.constraints.Length;

import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import java.util.Date;
/**
 * 用户发文的BO
 */
public class NewArticleBO &#123;

    @NotBlank(message = &quot;文章标题不能为空&quot;)
    @Length(max = 30, message = &quot;文章标题长度不能超过30&quot;)
    private String title;

    @NotBlank(message = &quot;文章内容不能为空&quot;)
    @Length(max = 9999, message = &quot;文章内容长度不能超过10000&quot;)
    private String content;

    @NotNull(message = &quot;请选择文章领域&quot;)
    private Integer categoryId;

    @NotNull(message = &quot;请选择正确的文章封面类型&quot;)
    @Min(value = 1, message = &quot;请选择正确的文章封面类型&quot;)
    @Max(value = 2, message = &quot;请选择正确的文章封面类型&quot;)
    private Integer articleType;
    private String articleCover;

    @NotNull(message = &quot;文章发布类型不正确&quot;)
    @Min(value = 0, message = &quot;文章发布类型不正确&quot;)
    @Max(value = 1, message = &quot;文章发布类型不正确&quot;)
    private Integer isAppoint;

    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) // 前端日期字符串传到后端后，转换为Date类型
    private Date publishTime;

    @NotBlank(message = &quot;用户未登录&quot;)
    private String publishUserId;
&#125;Getter + Setter
</code></pre>
<h3 id="发布文章入库Service及联调【也可以定时发布】"><a href="#发布文章入库Service及联调【也可以定时发布】" class="headerlink" title="发布文章入库Service及联调【也可以定时发布】"></a>发布文章入库Service及联调【也可以定时发布】</h3><p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html">http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html</a><br>发布完成后去数据库article中就会存在数据了</p>
<pre><code class="xml">generator-datebase  generatorConfig-article.xml [逆向生成]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;!-- 通用mapper所在目录 --&gt;
        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;com.imooc.my.mapper.MyMapper&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/imooc-news-dev&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 对应生成的pojo所在包 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.imooc.pojo&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot;/&gt;

        &lt;!-- 对应生成的mapper所在目录 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper.article&quot; targetProject=&quot;mybatis-generator-database/src/main/resources&quot;/&gt;

        &lt;!-- 配置mapper对应的java映射 --&gt;
        &lt;javaClientGenerator targetPackage=&quot;com.imooc.article.mapper&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt;

        &lt;!-- 数据库表 --&gt;
        &lt;table tableName=&quot;comments&quot;&gt;&lt;/table&gt;

    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="java">generator-datebase  com/imooc/mybatis/utils/ArticleGenerator.java
//[运行时候就会自动生成对应文件 目录是上面的generatorConfig-article.xml]
package com.imooc.mybatis.utils;

import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;


public class ArticleGenerator &#123;

    public void generator() throws Exception &#123;

        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        //指定 逆向工程配置文件
        File configFile = new File(&quot;mybatis-generator-database&quot;
                                            + File.separator
                                            + &quot;generatorConfig-article.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);

    &#125; 
    
    public static void main(String[] args) throws Exception &#123;
        try &#123;
            ArticleGenerator generatorSqlmap = new ArticleGenerator();
            generatorSqlmap.generator();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  mapper/ArticleMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.ArticleMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Article&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;title&quot; property=&quot;title&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;category_id&quot; property=&quot;categoryId&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;article_type&quot; property=&quot;articleType&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; property=&quot;articleCover&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;is_appoint&quot; property=&quot;isAppoint&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;article_status&quot; property=&quot;articleStatus&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;publish_user_id&quot; property=&quot;publishUserId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;publish_time&quot; property=&quot;publishTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;read_counts&quot; property=&quot;readCounts&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;comment_counts&quot; property=&quot;commentCounts&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;mongo_file_id&quot; property=&quot;mongoFileId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;content&quot; property=&quot;content&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;

import java.util.List;

public interface ArticleService &#123;
    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
package com.imooc.article.service.impl;

import com.imooc.api.service.BaseService;
import com.imooc.article.mapper.ArticleMapper;
import com.imooc.article.service.ArticleService;
import com.imooc.enums.ArticleAppointType;
import com.imooc.enums.ArticleReviewStatus;
import com.imooc.enums.YesOrNo;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Article;
import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.DateUtil;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

import static com.imooc.api.BaseController.REDIS_ALL_CATEGORY;


@Service
public class ArticleServiceImpl extends BaseService implements ArticleService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository
    @Autowired
    private Sid sid;

    @Transactional
    @Override
    public void createArticle(NewArticleBO newArticleBO, Category category) &#123;
        String articleId = sid.nextShort();

        Article article = new Article();
        BeanUtils.copyProperties(newArticleBO, article);

        article.setId(articleId);
        article.setCategoryId(category.getId());
        article.setArticleStatus(ArticleReviewStatus.REVIEWING.type);
        article.setCommentCounts(0);
        article.setReadCounts(0);

        article.setIsDelete(YesOrNo.NO.type);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());

        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;
            article.setPublishTime(newArticleBO.getPublishTime()); //用户可以在前端选择定时发布
        &#125; else if (article.getIsAppoint() == ArticleAppointType.IMMEDIATELY.type) &#123;
            article.setPublishTime(new Date());
        &#125;

        int res = articleMapper.insert(article);
        if (res != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_CREATE_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Article.java
package com.imooc.pojo;

import javax.persistence.Column;
import javax.persistence.Id;
import java.util.Date;

public class Article &#123;
    @Id
    private String id;

    /**
     * 文章标题
     */
    private String title;

    /**
     * 文章所属分类id
     */
    @Column(name = &quot;category_id&quot;)
    private Integer categoryId;

    /**
     * 文章类型，1：图文（1张封面），2：纯文字
     */
    @Column(name = &quot;article_type&quot;)
    private Integer articleType;

    /**
     * 文章封面图，article_type=1 的时候展示
     */
    @Column(name = &quot;article_cover&quot;)
    private String articleCover;

    /**
     * 是否是预约定时发布的文章，1：预约（定时）发布，0：即时发布    在预约时间到点的时候，把1改为0，则发布
     */
    @Column(name = &quot;is_appoint&quot;)
    private Integer isAppoint;

    /**
     * 文章状态，1：审核中（用户已提交），2：机审结束，等待人工审核，3：审核通过（已发布），4：审核未通过；5：文章撤回（已发布的情况下才能撤回和删除）
     */
    @Column(name = &quot;article_status&quot;)
    private Integer articleStatus;

    /**
     * 发布者用户id
     */
    @Column(name = &quot;publish_user_id&quot;)
    private String publishUserId;

    /**
     * 文章发布时间（也是预约发布的时间）
     */
    @Column(name = &quot;publish_time&quot;)
    private Date publishTime;

    /**
     * 用户累计点击阅读数（喜欢数）（点赞） - 放redis
     */
    @Column(name = &quot;read_counts&quot;)
    private Integer readCounts;

    /**
     * 文章评论总数。评论防刷，距离上次评论需要间隔时间控制几秒
     */
    @Column(name = &quot;comment_counts&quot;)
    private Integer commentCounts;

    @Column(name = &quot;mongo_file_id&quot;)
    private String mongoFileId;

    /**
     * 逻辑删除状态，非物理删除，1：删除，0：未删除
     */
    @Column(name = &quot;is_delete&quot;)
    private Integer isDelete;

    /**
     * 文章的创建时间
     */
    @Column(name = &quot;create_time&quot;)
    private Date createTime;

    /**
     * 文章的修改时间
     */
    @Column(name = &quot;update_time&quot;)
    private Date updateTime;

    /**
     * 文章内容，长度不超过9999，需要在前后端判断
     */
    private String content;
</code></pre>
<h3 id="构建定时任务-定时发布文章【定时任务】"><a href="#构建定时任务-定时发布文章【定时任务】" class="headerlink" title="构建定时任务 定时发布文章【定时任务】"></a>构建定时任务 定时发布文章【定时任务】</h3><p><a target="_blank" rel="noopener" href="https://cron.qqe2.com/">在线Cron表达式生成器 (qqe2.com)</a></p>
<pre><code class="java">service-article  com/imooc/article/task/TaskPublishArticles.java
package com.imooc.article.task;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.LocalDateTime;

@Configuration  // 1.标记配置类，使得springboot容器扫描到
@EnableScheduling // 2.开启定时任务
public class TaskPublishArticles &#123;
    @Scheduled(cron = &quot;0/3 * * * * ? &quot;)
    private void publishArticles()&#123;
        System.out.println(&quot;执行定时任务：&quot; + LocalDateTime.now());
    &#125;
&#125;

=================================================================
执行定时任务：2024-07-22T14:34:54.009
执行定时任务：2024-07-22T14:34:57.013
执行定时任务：2024-07-22T14:35:00.012
执行定时任务：2024-07-22T14:35:03.002
执行定时任务：2024-07-22T14:35:06.001
执行定时任务：2024-07-22T14:35:09.006
</code></pre>
<pre><code class="java">service-article  com/imooc/article/task/TaskPublishArticles.java
package com.imooc.article.task;

import com.imooc.article.service.ArticleService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.LocalDateTime;

@Configuration  // 1.标记配置类，使得springboot容器扫描到
@EnableScheduling // 2.开启定时任务
public class TaskPublishArticles &#123;
    @Autowired
    private ArticleService articleService;
    // 添加定时任务，注明定时任务的表达式
    // 【若文章数量庞大 需要RabbitMQ去做优化 后面会讲！】
    @Scheduled(cron = &quot;0/3 * * * * ? &quot;)
    private void publishArticles()&#123;
        System.out.println(&quot;执行定时任务：&quot; + LocalDateTime.now());
        // 4. 调用文章service，把当前时间应该发布的定时文章，状态改为即时
        articleService.updateAppointToPublish();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/ArticleMapperCustom.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Article;
import org.springframework.stereotype.Repository;

@Repository
public interface ArticleMapperCustom extends MyMapper&lt;Article&gt; &#123;
    public void updateAppointToPublish();
&#125;
</code></pre>
<pre><code class="java">service-article resources/mapper/ArticleMapperCustom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.ArticleMapperCustom&quot; &gt;
    &lt;update id=&quot;updateAppointToPublish&quot;&gt;
        update
            article
        set
            is_appoint = 0
        where
            publish_time &amp;lt;= NOW()
        and
            is_appoint = 1
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;

import java.util.List;

public interface ArticleService &#123;

    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

    /**
     * 更新定时发布为即使发布
     */
    public void updateAppointToPublish();

&#125;
</code></pre>
<pre><code class="java">service-article   com/imooc/article/service/impl/ArticleServiceImpl.java

@Transactional //添加事务[更新操作]
    @Override
    public void updateAppointToPublish() &#123;
        articleMapperCustom.updateAppointToPublish();
    &#125;
</code></pre>
<h3 id="文章列表展示-【内容管理】"><a href="#文章列表展示-【内容管理】" class="headerlink" title="文章列表展示 【内容管理】"></a>文章列表展示 【内容管理】</h3><p>[mybatis中关于example类详解mybatis的Example</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/suizhikuo/p/13191209.html">Criteria]的使用 - 万事俱备就差个程序员 - 博客园 (cnblogs.com)</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
@Api(value = &quot;文章业务的controller&quot;, tags = &#123;&quot;文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article&quot;)
public interface ArticleControllerApi &#123;

    @PostMapping(&quot;createArticle&quot;)
    @ApiOperation(value = &quot;用户发文&quot;, notes = &quot;用户发文&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult createArticle(@RequestBody @Valid NewArticleBO newArticleBO, BindingResult result);

    @PostMapping(&quot;queryMyList&quot;) //对应着前端contentMng.html 340行
    @ApiOperation(value = &quot;查询用户的所有文章列表&quot;, notes = &quot;查询用户的所有文章列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult queryMyList(@RequestParam String userId,
                                       @RequestParam String keyword,
                                       @RequestParam Integer status,
                                       @RequestParam Date startDate,
                                       @RequestParam Date endDate,
                                       @RequestParam Integer page,
                                       @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult queryMyList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_QUERY_PARAMS_ERROR);
        &#125;
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        // 查询我的列表，调用service
        PagedGridResult grid =  articleService.queryMyArticleList(userId, keyword, status, startDate, endDate, page, pageSize);
        return GraceJSONResult.ok(grid);
    &#125;
=========================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;
import java.util.List;

public interface ArticleService &#123;

    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

    /**
     * 更新定时发布为即使发布
     */
    public void updateAppointToPublish();

    /**
     * 用户中心-查询我的文章列表
     */
    public PagedGridResult queryMyArticleList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
@Service
public class ArticleServiceImpl extends BaseService implements ArticleService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository
    @Autowired
    private ArticleMapperCustom articleMapperCustom;
    @Autowired
    private Sid sid;
     //匹配到前端的一种显示方法
    @Override
    public PagedGridResult queryMyArticleList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        Example example = new Example(Article.class);
        example.orderBy(&quot;createTime&quot;).desc();
        Example.Criteria criteria = example.createCriteria();
        criteria.andEqualTo(&quot;publishUserId&quot;, userId);
        if (StringUtils.isNotBlank(keyword))&#123;
            //模糊查询
            criteria.andLike(&quot;title&quot;, &quot;%&quot;+keyword+&quot;%&quot;);
        &#125;
        if (ArticleReviewStatus.isArticleStatusValid(status))&#123;
            // 有效就匹配 无效就查询所有
            criteria.andEqualTo(&quot;articleStatus&quot;, status);
        &#125;
        // 12是在前端显示审核中
        if (status != null &amp;&amp; status == 12)&#123;
            criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.REVIEWING.type)
                    .orEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125;
        // 逻辑删除
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        if (startDate != null)&#123; //大于等于
            criteria.andGreaterThanOrEqualTo(&quot;publishTime&quot;, startDate);
        &#125;
        if (startDate != null)&#123; //小于等于
            criteria.andLessThanOrEqualTo(&quot;publishTime&quot;,endDate);
        &#125;
        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(example);
        return setterPagedGrid(list,page);
    &#125;
/*
ArticleMapper 可以实现 selectByExample 是因为它继承了 MyMapper 接口，而 MyMapper 提供了一些通用的 CRUD 操作，这些操作包括 selectByExample。

selectByExample 是 MyBatis 提供的一种动态查询方法。它允许你根据条件动态地生成 SQL 查询，而不需要手动编写复杂的 SQL 语句。这在实际开发中非常方便，因为你可以通过构建 Example 对象来动态设置查询条件。

ArticleMapper 继承了 MyMapper&lt;Article&gt;，这意味着它自动获得了 MyMapper 中定义的所有方法，包括 selectByExample。MyMapper 是一个通用的 Mapper 接口，封装了常用的数据库操作方法。

Example 和 Criteria
Example: 用于构建查询条件的对象。在这里，我们创建了一个 Example 对象，用于设置查询的表（Article.class）和排序规则（按 createTime 降序）。

Criteria: 用于添加具体的查询条件。在 Example 对象中创建 Criteria 对象，并使用它来添加各种条件（例如 publishUserId、title、articleStatus、isDelete 等）。

selectByExample
selectByExample 方法使用 Example 对象中的条件动态生成 SQL 查询，并从数据库中获取符合条件的记录。在这个例子中，我们使用了 articleMapper.selectByExample(example) 来根据构建的 Example 对象进行查询。

Example 详细用法
Example 和 Criteria 的使用使得我们可以非常灵活地构建查询条件，而不需要直接拼接 SQL 语句。这不仅提高了代码的可读性，还减少了 SQL 注入的风险。
*/
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/ArticleMapper.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Article;
import org.springframework.stereotype.Repository;

@Repository
public interface ArticleMapper extends MyMapper&lt;Article&gt; &#123;
&#125;
</code></pre>
<h3 id="阿里AI文本检测【内容审核】-机器审核"><a href="#阿里AI文本检测【内容审核】-机器审核" class="headerlink" title="阿里AI文本检测【内容审核】[机器审核]"></a>阿里AI文本检测【内容审核】<del>[机器审核]</del></h3><pre><code class="xml">dev-common pom.xml 
       &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
            &lt;version&gt;3.10.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-green&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.51&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/extend/AliTextReviewUtils.java
package com.imooc.utils.extend;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.green.model.v20180509.TextScanRequest;
import com.aliyuncs.http.FormatType;
import com.aliyuncs.http.HttpResponse;
import com.aliyuncs.profile.DefaultProfile;
import com.aliyuncs.profile.IClientProfile;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.util.*;

@Component
public class AliTextReviewUtils &#123;

    @Autowired
    private AliyunResource aliyunResource;

    public String reviewTextContent(String content) &#123;
        IClientProfile profile = DefaultProfile.getProfile(&quot;cn-shanghai&quot;,
                aliyunResource.getAccessKeyID(),
                aliyunResource.getAccessKeySecret());
        IAcsClient client = new DefaultAcsClient(profile);
        TextScanRequest textScanRequest = new TextScanRequest();
        textScanRequest.setAcceptFormat(FormatType.JSON); // 指定api返回格式
        textScanRequest.setHttpContentType(FormatType.JSON);
        textScanRequest.setMethod(com.aliyuncs.http.MethodType.POST); // 指定请求方法
        textScanRequest.setEncoding(&quot;UTF-8&quot;);
        textScanRequest.setRegionId(&quot;cn-shanghai&quot;);
        List&lt;Map&lt;String, Object&gt;&gt; tasks = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();
        Map&lt;String, Object&gt; task1 = new LinkedHashMap&lt;String, Object&gt;();
        task1.put(&quot;dataId&quot;, UUID.randomUUID().toString());
        /**
         * 待检测的文本，长度不超过10000个字符
         */
//        抵制毒品交易
//          尼玛
        task1.put(&quot;content&quot;, content);
        tasks.add(task1);
        JSONObject data = new JSONObject();

        /**
         * 检测场景，文本垃圾检测传递：antispam
         **/
        data.put(&quot;scenes&quot;, Arrays.asList(&quot;antispam&quot;));
        data.put(&quot;tasks&quot;, tasks);
        System.out.println(JSON.toJSONString(data, true));

        try &#123;
            textScanRequest.setHttpContent(data.toJSONString().getBytes(&quot;UTF-8&quot;), &quot;UTF-8&quot;, FormatType.JSON);
            // 请务必设置超时时间
            textScanRequest.setConnectTimeout(3000);
            textScanRequest.setReadTimeout(6000);

            HttpResponse httpResponse = client.doAction(textScanRequest);
            if(httpResponse.isSuccess())&#123;
                JSONObject scrResponse = JSON.parseObject(new String(httpResponse.getHttpContent(), &quot;UTF-8&quot;));
                System.out.println(JSON.toJSONString(scrResponse, true));
                if (200 == scrResponse.getInteger(&quot;code&quot;)) &#123;
                    JSONArray taskResults = scrResponse.getJSONArray(&quot;data&quot;);
                    for (Object taskResult : taskResults) &#123;
                        if(200 == ((JSONObject)taskResult).getInteger(&quot;code&quot;))&#123;
                            JSONArray sceneResults = ((JSONObject)taskResult).getJSONArray(&quot;results&quot;);
                            JSONObject sceneResult = (JSONObject)sceneResults.get(0);
        //                            for (Object sceneResult : sceneResults) &#123;
                                String scene = sceneResult.getString(&quot;scene&quot;);
                                String suggestion = sceneResult.getString(&quot;suggestion&quot;);
                                //根据scene和suggetion做相关处理
                                //suggestion == pass 未命中垃圾  suggestion == block 命中了垃圾，可以通过label字段查看命中的垃圾分类
                                System.out.println(&quot;args = [&quot; + scene + &quot;]&quot;);
                                System.out.println(&quot;args = [&quot; + suggestion + &quot;]&quot;);

        //                            suggestion=pass：文本正常，文章状态改为发布通过
        //                            review：需要人工审核，需要在后台管理系统中进行人工审核（很多自媒体平台都会采用机审+人工审的方式）
        //                            block：文本违规，可以直接删除或者做限制处理，审核不通过
        //                            &#125;
                                return suggestion;
                        &#125;else&#123;
                            System.out.println(&quot;task process fail:&quot; + ((JSONObject)taskResult).getInteger(&quot;code&quot;));
                            return null;
                        &#125;
                    &#125;
                &#125; else &#123;
                    System.out.println(&quot;detect not success. code:&quot; + scrResponse.getInteger(&quot;code&quot;));
                    return null;
                &#125;
            &#125;else&#123;
                System.out.println(&quot;response not success. status:&quot; + httpResponse.getStatus());
                return null;
            &#125;
        &#125; catch (UnsupportedEncodingException e) &#123;
            e.printStackTrace();
        &#125; catch (ClientException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<h3 id="实现阿里AI自动审核文章【内容审核】"><a href="#实现阿里AI自动审核文章【内容审核】" class="headerlink" title="实现阿里AI自动审核文章【内容审核】"></a>实现阿里AI自动审核文章【内容审核】</h3><pre><code class="java">【沿用上面的AliTextReviewUtils】
@Service
public class ArticleServiceImpl extends BaseService implements ArticleService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository
    @Autowired
    private ArticleMapperCustom articleMapperCustom;
    @Autowired
    private AliTextReviewUtils aliTextReviewUtils;
    @Autowired
    private Sid sid;

    @Transactional
    @Override
    public void createArticle(NewArticleBO newArticleBO, Category category) &#123;
        String articleId = sid.nextShort();

        Article article = new Article();
        BeanUtils.copyProperties(newArticleBO, article);

        article.setId(articleId);
        article.setCategoryId(category.getId());
        article.setArticleStatus(ArticleReviewStatus.REVIEWING.type);
        article.setCommentCounts(0);
        article.setReadCounts(0);

        article.setIsDelete(YesOrNo.NO.type);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());

        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;
            article.setPublishTime(newArticleBO.getPublishTime()); //用户可以在前端选择定时发布
        &#125; else if (article.getIsAppoint() == ArticleAppointType.IMMEDIATELY.type) &#123;
            article.setPublishTime(new Date());
        &#125;

        int res = articleMapper.insert(article);
        if (res != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_CREATE_ERROR);
        &#125;

        /**
         * FIXME: 我们只检测正常的词汇，非正常词汇大家课后去检测
         */
        // 通过阿里智能AI实现对文章文本的自动检测（自动审核）
//        String reviewTextResult = aliTextReviewUtils.reviewTextContent(newArticleBO.getContent());
        String reviewTextResult = ArticleReviewLevel.REVIEW.type;

        if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.PASS.type)) &#123;
            // 修改当前的文章，状态标记为审核通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.SUCCESS.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.REVIEW.type)) &#123;
            // 修改当前的文章，状态标记为需要人工审核
            this.updateArticleStatus(articleId, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.BLOCK.type)) &#123;
            // 修改当前的文章，状态标记为审核未通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.FAILED.type);
        &#125;
    &#125;
......
......
    @Transactional
    @Override
    public void updateArticleStatus(String articleId, Integer pendingStatus) &#123;
        Example example = new Example(Article.class);
        Example.Criteria criteria = example.createCriteria();
        criteria.andEqualTo(&quot;id&quot;,articleId);

        Article pendingArticle = new Article();
        pendingArticle.setArticleStatus(pendingStatus);
        int res = articleMapper.updateByExampleSelective(pendingArticle, example);
        if (res != 1)&#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;
import java.util.List;

public interface ArticleService &#123;

    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

    /**
     * 更新定时发布为即使发布
     */
    public void updateAppointToPublish();

    /**
     * 用户中心-查询我的文章列表
     */
    public PagedGridResult queryMyArticleList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

    /**
     * 更改文章的状态
     * @param articleId
     * @param pendingStatus
     */
    public void updateArticleStatus(String articleId, Integer pendingStatus);
&#125;
</code></pre>
<h3 id="admin文章管理列表【内容审核】【作业】"><a href="#admin文章管理列表【内容审核】【作业】" class="headerlink" title="admin文章管理列表【内容审核】【作业】"></a>admin文章管理列表【内容审核】<del>【作业】</del></h3><h5 id="管理员查询用户的所有文章列表"><a href="#管理员查询用户的所有文章列表" class="headerlink" title="管理员查询用户的所有文章列表"></a>管理员查询用户的所有文章列表</h5><pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
@PostMapping(&quot;queryAllList&quot;)
    @ApiOperation(value = &quot;管理员查询用户的所有文章列表&quot;, notes = &quot;管理员查询用户的所有文章列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult queryAllList(@RequestParam Integer status,
                                        @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                        @RequestParam Integer page,
                                        @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                        @RequestParam Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult queryAllList(Integer status, Integer page, Integer pageSize) &#123;
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        PagedGridResult gridResult = articleService.queryAllArticleListAdmin(status,page,pageSize);

        return GraceJSONResult.ok(gridResult);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
    /**
     * 管理员查询文章列表
     */
    public PagedGridResult queryAllArticleListAdmin(Integer status, Integer page, Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
@Override
    public PagedGridResult queryAllArticleListAdmin(Integer status, Integer page, Integer pageSize) &#123;
        Example articleExample = new Example(Article.class);
        articleExample.orderBy(&quot;createTime&quot;).desc();
        Example.Criteria criteria = articleExample.createCriteria();
        //这里是检测文章状态 与前端做匹配
        if (ArticleReviewStatus.isArticleStatusValid(status)) &#123;
            criteria.andEqualTo(&quot;articleStatus&quot;, status);
        &#125;

        // 审核中是机审和人审核的两个状态，所以需要单独判断
        if (status != null &amp;&amp; status == 12) &#123;
            criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.REVIEWING.type)
                    .orEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125;
        //isDelete必须是0
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        /**
         * page: 第几页
         * pageSize: 每页显示条数
         */
        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        return setterPagedGrid(list, page);
    &#125;
</code></pre>
<h3 id="人工审核-【内容审核】"><a href="#人工审核-【内容审核】" class="headerlink" title="人工审核 【内容审核】"></a>人工审核 【内容审核】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/contentReview.html">内容审核 | 运营管理平台 (imoocnews.com)</a> 【[待审核]手动审核通过】</p>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
    @PostMapping(&quot;doReview&quot;)
    @ApiOperation(value = &quot;管理员对文章进行审核通过或者失败&quot;, notes = &quot;管理员对文章进行审核通过或者失败&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult doReview(@RequestParam String articleId,
                                    @RequestParam Integer passOrNot);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<h3 id="撤回-删除文章作业-【内容管理】"><a href="#撤回-删除文章作业-【内容管理】" class="headerlink" title="撤回_删除文章作业 【内容管理】"></a>撤回_删除文章作业 【内容管理】</h3><p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html">媒体号作家中心 | 内容管理 (imoocnews.com)</a><br>[这个是用户撤回和删除噢 而不是管理员的撤回与删除]<br><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html">用户：媒体号作家中心 | 内容管理 (imoocnews.com)</a><br><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/contentReview.html">管理员：内容审核 | 运营管理平台 (imoocnews.com)</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
    @PostMapping(&quot;/delete&quot;)
    @ApiOperation(value = &quot;用户删除文章&quot;, notes = &quot;用户删除文章&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult delete(@RequestParam String userId,
                                  @RequestParam String articleId);

    @PostMapping(&quot;/withdraw&quot;)
    @ApiOperation(value = &quot;用户撤回文章&quot;, notes = &quot;用户撤回文章&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult withdraw(@RequestParam String userId,
                                    @RequestParam String articleId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult delete(String userId, String articleId) &#123;
        articleService.deleteArticle(userId,articleId);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult withdraw(String userId, String articleId) &#123;
        articleService.withdrawArticle(userId, articleId);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;
import java.util.List;

public interface ArticleService &#123;

   /**
     * 删除文章
     */
    public void deleteArticle(String userId, String articleId);

    /**
     * 撤回文章
     */
    public void withdrawArticle(String userId, String articleId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
 @Transactional
    @Override
    public void deleteArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setIsDelete(YesOrNo.YES.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_DELETE_ERROR);
        &#125;
    &#125;

    @Transactional
    @Override
    public void withdrawArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setArticleStatus(ArticleReviewStatus.WITHDRAW.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_WITHDRAW_ERROR);
        &#125;
//        deleteHTML(articleId);
    &#125;

    private Example makeExampleCriteria(String userId, String articleId) &#123;
        Example articleExample = new Example(Article.class);
        Example.Criteria criteria = articleExample.createCriteria();
        criteria.andEqualTo(&quot;publishUserId&quot;, userId);
        criteria.andEqualTo(&quot;id&quot;, articleId);
        return articleExample;
    &#125;
</code></pre>
<h2 id="首页-作者页面介绍【章节描述】"><a href="#首页-作者页面介绍【章节描述】" class="headerlink" title="首页_作者页面介绍【章节描述】"></a>首页_作者页面介绍【章节描述】</h2><ul>
<li><strong>开发首页与作家个人展示页</strong></li>
<li><strong>文章列表、友情链接查询</strong></li>
<li><strong>粉丝关注与取关</strong></li>
<li><strong>我的粉丝与粉丝画像</strong></li>
</ul>
<h3 id="根据MongoDB字段查询友情链接"><a href="#根据MongoDB字段查询友情链接" class="headerlink" title="根据MongoDB字段查询友情链接"></a>根据MongoDB字段查询友情链接</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
    @ApiOperation(value = &quot;门户端查询友情链接列表&quot;, notes = &quot;门户端查询友情链接列表&quot;, httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;portal/list&quot;)
    public GraceJSONResult queryPortalAllFriendLinkList();
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
    @Override
    public GraceJSONResult queryPortalAllFriendLinkList() &#123;
        List&lt;FriendLinkMO&gt; list = friendLinkService.queryPortalAllFriendLinkList();
        return GraceJSONResult.ok(list);
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
    /**
     * 首页查询友情链接
     */
    public List&lt;FriendLinkMO&gt; queryPortalAllFriendLinkList();
</code></pre>
<pre><code class="java">service-admin com/imooc/admin/service/impl/FriendLinkServiceImpl.java 
@Override
    public List&lt;FriendLinkMO&gt; queryPortalAllFriendLinkList() &#123;
        return friendLinkRepository.getAllByIsDelete(YesOrNo.NO.type);
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/repository/FriendLinkRepository.java
@Repository
public interface FriendLinkRepository extends MongoRepository&lt;FriendLinkMO, String&gt; &#123; //持久层
    // 内置提供了很多方法 find.. delete...
    public List&lt;FriendLinkMO&gt; getAllByIsDelete(Integer isDelete); //后面可以加ANDID
&#125;
</code></pre>
<h3 id="搜索并展示文章列表【首页】"><a href="#搜索并展示文章列表【首页】" class="headerlink" title="搜索并展示文章列表【首页】"></a>搜索并展示文章列表【首页】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@Api(value = &quot;门户端文章业务的controller&quot;, tags = &#123;&quot;门户端文章业务的controller&quot;&#125;)
@RequestMapping(&quot;portal/article&quot;)
public interface ArticlePortalControllerApi &#123;
    @ApiOperation(value = &quot;首页查询文章列表&quot;, notes = &quot;首页查询文章列表&quot;, httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;list&quot;)
    public GraceJSONResult list(@RequestParam String keyword,
                                @RequestParam Integer category,
                                @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                @RequestParam Integer page,
                                @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
@Service
public class ArticlePortalServiceImpl extends BaseService implements ArticlePortalService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository


    @Override
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 Integer pageSize) &#123;

        Example articleExample = new Example(Article.class);
        articleExample.orderBy(&quot;publishTime&quot;).desc();//使用时间进行排序
        Example.Criteria criteria = articleExample.createCriteria();

        /**
         * 查询首页文章的自带隐性查询条件：
         * isAppoint=即使发布，表示文章已经直接发布的，或者定时任务到点发布的
         * isDelete=未删除，表示文章只能够显示未删除
         * articleStatus=审核通过，表示只有文章经过机审/人工审核之后才能展示
         */
        criteria.andEqualTo(&quot;isAppoint&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.SUCCESS.type);

        if (StringUtils.isNotBlank(keyword)) &#123;
            criteria.andLike(&quot;title&quot;, &quot;%&quot; + keyword + &quot;%&quot;);
        &#125;
        if (category != null) &#123;
            criteria.andEqualTo(&quot;categoryId&quot;, category);
        &#125;

        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        System.out.println(keyword);
        System.out.println(category);
        return setterPagedGrid(list, page);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
public interface ArticlePortalService &#123;

    /**
     * 首页查询文章列表
     */
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 &#125;
</code></pre>
<pre><code class="html">index.html
&lt;!-- 中间容器 --&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;!-- 文章列表 --&gt;
            &lt;div id=&quot;articleList&quot; class=&quot;article-list&quot;&gt;
                &lt;ul&gt;
                    &lt;li class=&quot;single-article-wrapper&quot; v-for=&quot;(article, index) in articleList&quot; :key=&quot;index&quot;&gt;
                        &lt;img :src=&quot;article.articleCover&quot; class=&quot;article-cover&quot; v-show=&quot;article.articleType == 1&quot;&gt;

                        &lt;div class=&quot;single-article&quot;&gt;
                            &lt;div class=&quot;article-title&quot;&gt;
                                &lt;!-- TODO: 后期改为静态页面跳转 --&gt;
                                &lt;a :href=&quot;&#39;detail.html?articleId=&#39;+article.id&quot; target=&quot;_blank&quot; class=&quot;link-article-title&quot;&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;
                            &lt;/div&gt;
                            &lt;div class=&quot;publisher&quot;&gt;
                                &lt;div class=&quot;category-tag&quot; :style=&quot;&#123;color: getCatTagColor(article.categoryId), borderColor: getCatTagColor(article.categoryId) &#125;&quot;&gt;&#123;&#123;getCatName(article.categoryId)&#125;&#125;&lt;/div&gt;
                                &lt;!-- TODO: 这里需要显示用户的昵称以及用户头像 --&gt;
                                    &lt;img src=&quot;img/face1.png&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publishUserId&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                
                                
                                    &lt;img :src=&quot;article.publisherVO.face&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;
                                &lt;!--
                                    &lt;a :href=&quot;&#39;writer.html?writerId=&#39;+article.publisherVO.id&quot; target=&quot;_blank&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publisherVO.nickname&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                &lt;/a&gt;
                                    --&gt;

                                &lt;div class=&quot;article-name&quot;&gt;&amp;nbsp;&#123;&#123;article.readCounts&#125;&#125;阅读&amp;nbsp;⋅&lt;/div&gt;
                                
                                &lt;!-- &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;formatData(article.publishTime)&#125;&#125;&lt;/div&gt; --&gt;
                                &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;getDateBeforeNow(article.publishTime)&#125;&#125;&lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
</code></pre>
<h3 id="文章列表展示发布者需求【首页】"><a href="#文章列表展示发布者需求【首页】" class="headerlink" title="文章列表展示发布者需求【首页】"></a>文章列表展示发布者需求【首页】</h3><pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
[其他不变加上点代码]
package com.imooc.article.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.article.ArticleControllerApi;
import com.imooc.api.controller.article.ArticlePortalControllerApi;
import com.imooc.article.service.ArticlePortalService;
import com.imooc.article.service.ArticleService;
import com.imooc.enums.ArticleCoverType;
import com.imooc.enums.ArticleReviewStatus;
import com.imooc.enums.YesOrNo;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Article;
import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import java.util.*;

@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
   //START
        List&lt;Article&gt; list = (List&lt;Article&gt;) gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idset = new HashSet&lt;&gt;();
        for (Article a : list)&#123;
//            System.out.println(a.getPublishUserId());
            idset.add(a.getPublishUserId());
        &#125;
        System.out.println(idset.toString());
        // 2. 发起远程调用(restTemplate)，请求用户服务获得用户(idSet 发布者)列表

        // 3. 拼接两个list，重组文章列表
   //END
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;
</code></pre>
<h3 id="发起restTemplate请求查询用户服务获得发布者列表【首页】二级用户"><a href="#发起restTemplate请求查询用户服务获得发布者列表【首页】二级用户" class="headerlink" title="发起restTemplate请求查询用户服务获得发布者列表【首页】二级用户"></a>发起restTemplate请求查询用户服务获得发布者列表【首页】<del>二级用户</del></h3><pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
   //START 用户量大就双表关联查询      单表双查询 → 【首页不会显示发布者的用户id 和 头像】
        List&lt;Article&gt; list = (List&lt;Article&gt;) gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idset = new HashSet&lt;&gt;();
        for (Article a : list)&#123;
//            System.out.println(a.getPublishUserId());
            idset.add(a.getPublishUserId());
        &#125;
        System.out.println(idset.toString());
        // 2. 发起远程调用(restTemplate)，请求用户服务获得用户(idSet 发布者)列表
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idset);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity =
        restTemplate.getForEntity(userServerUrlExecute,GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200)&#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        for (AppUserVO u : publisherList)&#123;
            System.out.println(u.toString());
        &#125;
        // 3. 拼接两个list，重组文章列表
   //END
        return GraceJSONResult.ok(gridResult);
    &#125;
===================成功输出二级用户基本信息===============================
AppUserVO&#123;id=&#39;240629F21AK1BHX4&#39;, nickname=&#39;15027597319&#39;, face=&#39;https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/240629F21AK1BHX4/240712FM0G1WMZHH.png&#39;, activeStatus=1&#125;
AppUserVO&#123;id=&#39;200628AFYM7AGWPH&#39;, nickname=&#39;我是慕课网&#39;, face=&#39;https://imooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/200628AFYM7AGWPH/2007088XH2WT7GXP.png&#39;, activeStatus=1&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/AppUserVO.java
public class AppUserVO &#123;
    private String id;
    private String nickname;
    private String face;
    private Integer activeStatus;
&#125;Getter + Setter + ToString
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
@Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;

    private AppUserVO getBasicUserInfo(String userId)&#123;
        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        AppUserVO userVO = new AppUserVO();
        BeanUtils.copyProperties(user, userVO); //拷贝信息
        return userVO;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
                                          BindingResult result);

    @ApiOperation(value = &quot;根据用户的ids查询用户列表&quot;,notes = &quot;根据用户的ids查询用户列表&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/queryByids&quot;)
    public GraceJSONResult queryByIds(@RequestParam String userIds);
&#125;
</code></pre>
<h3 id="重组文章列表并且渲染【首页】"><a href="#重组文章列表并且渲染【首页】" class="headerlink" title="重组文章列表并且渲染【首页】"></a>重组文章列表并且渲染【首页】</h3><pre><code class="html">index.html
&lt;!-- 中间容器 --&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;!-- 文章列表 --&gt;
            &lt;div id=&quot;articleList&quot; class=&quot;article-list&quot;&gt;
                &lt;ul&gt;
                    &lt;li class=&quot;single-article-wrapper&quot; v-for=&quot;(article, index) in articleList&quot; :key=&quot;index&quot;&gt;
                        &lt;img :src=&quot;article.articleCover&quot; class=&quot;article-cover&quot; v-show=&quot;article.articleType == 1&quot;&gt;

                        &lt;div class=&quot;single-article&quot;&gt;
                            &lt;div class=&quot;article-title&quot;&gt;
                                &lt;!-- TODO: 后期改为静态页面跳转 --&gt;
                                &lt;a :href=&quot;&#39;detail.html?articleId=&#39;+article.id&quot; target=&quot;_blank&quot; class=&quot;link-article-title&quot;&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;
                            &lt;/div&gt;
                            &lt;div class=&quot;publisher&quot;&gt;
                                &lt;div class=&quot;category-tag&quot; :style=&quot;&#123;color: getCatTagColor(article.categoryId), borderColor: getCatTagColor(article.categoryId) &#125;&quot;&gt;&#123;&#123;getCatName(article.categoryId)&#125;&#125;&lt;/div&gt;
          &lt;!-- ★★★★★ TODO: 这里需要显示用户的昵称以及用户头像 ★★★★★ --&gt;
                                    &lt;img src=&quot;img/face1.png&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publishUserId&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                    &lt;img :src=&quot;article.publisherVO.face&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;
                                
                                    &lt;a :href=&quot;&#39;writer.html?writerId=&#39;+article.publisherVO.id&quot; target=&quot;_blank&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publisherVO.nickname&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                &lt;/a&gt;            
                                &lt;div class=&quot;article-name&quot;&gt;&amp;nbsp;&#123;&#123;article.readCounts&#125;&#125;阅读&amp;nbsp;⋅&lt;/div&gt;
                                &lt;!-- &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;formatData(article.publishTime)&#125;&#125;&lt;/div&gt; --&gt;
                                &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;getDateBeforeNow(article.publishTime)&#125;&#125;&lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/IndexArticleVO.java
public class IndexArticleVO &#123;

    private String id;
    private String title;
    private Integer categoryId;
    private Integer articleType;
    private String articleCover;
    private Integer isAppoint;
    private Integer articleStatus;
    private String publishUserId;
    private Date publishTime;
    private Integer readCounts;
    private Integer commentCounts;
    private String mongoFileId;
    private Integer isDelete;
    private Date createTime;
    private Date updateTime;
    private String content;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
package com.imooc.article.controller;
......
import java.util.*;

@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
   //START 用户量大就双表关联查询      单表双查询 → 【首页不会显示发布者的用户id 和 头像】
        List&lt;Article&gt; list = (List&lt;Article&gt;) gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idset = new HashSet&lt;&gt;();
        for (Article a : list)&#123;
//            System.out.println(a.getPublishUserId());
            idset.add(a.getPublishUserId());
        &#125;
        System.out.println(idset.toString());
        // 2. 发起远程调用(restTemplate)，请求用户服务获得用户(idSet 发布者)列表
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idset);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity =
        restTemplate.getForEntity(userServerUrlExecute,GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200)&#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
//        for (AppUserVO u : publisherList)&#123;
//            System.out.println(u.toString());
//        &#125;
        // 3. 拼接两个list，重组文章列表
        List&lt;IndexArticleVO&gt; indexArticleList = new ArrayList&lt;&gt;();
        for (Article a : list)&#123;
            IndexArticleVO indexArticleVO = new IndexArticleVO();
            BeanUtils.copyProperties(a, indexArticleVO);

            // 3.1 从publisherList中获得发布者的基本信息
            AppUserVO publisher = getUserIfPublisher(a.getPublishUserId(), publisherList);
            indexArticleVO.setPublisherVO(publisher);
            indexArticleList.add(indexArticleVO);
        &#125;
        gridResult.setRows(indexArticleList);
   //END
        return GraceJSONResult.ok(gridResult);
    &#125;
    // 用于获得publish
    private AppUserVO getUserIfPublisher(String publisherId, List&lt;AppUserVO&gt; publisherList)&#123;
        for (AppUserVO user : publisherList)&#123;
            if (user.getId().equalsIgnoreCase(publisherId))&#123;
                return user;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<h3 id="查询热闻【首页】阅读数从最新新闻进行排名"><a href="#查询热闻【首页】阅读数从最新新闻进行排名" class="headerlink" title="查询热闻【首页】阅读数从最新新闻进行排名"></a>查询热闻【首页】<del>阅读数从最新新闻进行排名</del></h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@Api(value = &quot;门户端文章业务的controller&quot;, tags = &#123;&quot;门户端文章业务的controller&quot;&#125;)
@RequestMapping(&quot;portal/article&quot;)
public interface ArticlePortalControllerApi &#123;
 @GetMapping(&quot;hotList&quot;)
    @ApiOperation(value = &quot;首页查询新闻列表&quot;, notes = &quot;首页查询新闻列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult hotList();
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
public interface ArticlePortalService &#123;

    /**
     * 首页查询文章列表
     */
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 Integer pageSize);
    /**
     * 首页查询热闻列表
     */
    public List&lt;Article&gt; queryHotList();
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
@Override
    public List&lt;Article&gt; queryHotList() &#123;
        Example articleExample = new Example(Article.class);
        Example.Criteria criteria = setDefualArticleExample(articleExample);

        PageHelper.startPage(1, 5);
        List&lt;Article&gt; list  = articleMapper.selectByExample(articleExample);
        return list;
    &#125;

    private Example.Criteria setDefualArticleExample(Example articleExample) &#123;
        articleExample.orderBy(&quot;publishTime&quot;).desc();
        Example.Criteria criteria = articleExample.createCriteria();

        /**
         * 查询首页文章的自带隐性查询条件：
         * isAppoint=即使发布，表示文章已经直接发布的，或者定时任务到点发布的
         * isDelete=未删除，表示文章只能够显示未删除
         * articleStatus=审核通过，表示只有文章经过机审/人工审核之后才能展示
         */
        criteria.andEqualTo(&quot;isAppoint&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.SUCCESS.type);

        return criteria;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult hotList() &#123;
        return GraceJSONResult.ok(articlePortalService.queryHotList());
    &#125;
</code></pre>
<h3 id="基本信息展示-历史文章列表【作者主页】"><a href="#基本信息展示-历史文章列表【作者主页】" class="headerlink" title="基本信息展示_历史文章列表【作者主页】"></a>基本信息展示_历史文章列表【作者主页】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
 package com.imooc.api.controller.article;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewArticleBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import java.util.Date;

@Api(value = &quot;门户端文章业务的controller&quot;, tags = &#123;&quot;门户端文章业务的controller&quot;&#125;)
@RequestMapping(&quot;portal/article&quot;)
public interface ArticlePortalControllerApi &#123;

    @GetMapping(&quot;list&quot;)
    @ApiOperation(value = &quot;首页查询文章列表&quot;, notes = &quot;首页查询文章列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult list(@RequestParam String keyword,
                                @RequestParam Integer category,
                                @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                @RequestParam Integer page,
                                @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                @RequestParam Integer pageSize);

    @GetMapping(&quot;hotList&quot;)
    @ApiOperation(value = &quot;首页查询新闻列表&quot;, notes = &quot;首页查询新闻列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult hotList();

    /**
     * 查询作家发布的所有文章列表
     */
    @GetMapping(&quot;queryArticleListOfWriter&quot;)
    @ApiOperation(value = &quot;查询作家发布的所有文章列表&quot;, notes = &quot;查询作家发布的所有文章列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult queryArticleListOfWriter(@RequestParam String writerId,
                                                    @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                                        @RequestParam Integer page,
                                                    @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                                        @RequestParam Integer pageSize);

    @GetMapping(&quot;queryGoodArticleListOfWriter&quot;)
    @ApiOperation(value = &quot;作家页面查询近期佳文&quot;, notes = &quot;作家页面查询近期佳文&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult queryGoodArticleListOfWriter(@RequestParam String writerId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult queryArticleListOfWriter(String writerId, Integer page, Integer pageSize) &#123;

        System.out.println(&quot;writerId=&quot; + writerId);

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult = articlePortalService.queryArticleListOfWriter(writerId, page, pageSize);
        gridResult = rebuildArticleGrid(gridResult);
        return GraceJSONResult.ok(gridResult);
    &#125;

    @Override
    public GraceJSONResult queryGoodArticleListOfWriter(String writerId) &#123;
        PagedGridResult gridResult = articlePortalService.queryGoodArticleListOfWriter(writerId);
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;
</code></pre>
<pre><code class="java">/* 完全版ArticlePortalController
package com.imooc.article.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.article.ArticlePortalControllerApi;
import com.imooc.article.service.ArticlePortalService;
import com.imooc.article.service.ArticleService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.Article;
import com.imooc.pojo.vo.AppUserVO;
import com.imooc.pojo.vo.IndexArticleVO;
import com.imooc.utils.IPUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
        gridResult = rebuildArticleGrid(gridResult);
        return GraceJSONResult.ok(gridResult);
    &#125;

    private PagedGridResult rebuildArticleGrid(PagedGridResult gridResult) &#123;
        // START

        List&lt;Article&gt; list = (List&lt;Article&gt;)gridResult.getRows();

        // 1. 构建发布者id列表
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        List&lt;String&gt; idList = new ArrayList&lt;&gt;();
        for (Article a : list) &#123;
//            System.out.println(a.getPublishUserId());
            // 1.1 构建发布者的set
            idSet.add(a.getPublishUserId());
            // 1.2 构建文章id的list
            idList.add(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + a.getId());
        &#125;
        System.out.println(idSet.toString());
        // 发起redis的mget批量查询api，获得对应的值
        List&lt;String&gt; readCountsRedisList = redis.mget(idList);
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        // 3. 拼接两个list，重组文章列表
        List&lt;IndexArticleVO&gt; indexArticleList = new ArrayList&lt;&gt;();
        for (int i = 0 ; i &lt; list.size() ; i ++) &#123;
            IndexArticleVO indexArticleVO = new IndexArticleVO();
            Article a = list.get(i);
            BeanUtils.copyProperties(a, indexArticleVO);

            // 3.1 从publisherList中获得发布者的基本信息
            AppUserVO publisher  = getUserIfPublisher(a.getPublishUserId(), publisherList);
            indexArticleVO.setPublisherVO(publisher);

            // 3.2 重新组装设置文章列表中的阅读量
            String redisCountsStr = readCountsRedisList.get(i);
            int readCounts = 0;
            if (StringUtils.isNotBlank(redisCountsStr)) &#123;
                readCounts = Integer.valueOf(redisCountsStr);
            &#125;
            indexArticleVO.setReadCounts(readCounts);

            indexArticleList.add(indexArticleVO);
        &#125;


        gridResult.setRows(indexArticleList);
// END
        return gridResult;
    &#125;

    private AppUserVO getUserIfPublisher(String publisherId,
                                         List&lt;AppUserVO&gt; publisherList) &#123;
        for (AppUserVO user : publisherList) &#123;
            if (user.getId().equalsIgnoreCase(publisherId)) &#123;
                return user;
            &#125;
        &#125;
        return null;
    &#125;

    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;

    @Override
    public GraceJSONResult hotList() &#123;
        return GraceJSONResult.ok(articlePortalService.queryHotList());
    &#125;

    @Override
    public GraceJSONResult queryArticleListOfWriter(String writerId, Integer page, Integer pageSize) &#123;

        System.out.println(&quot;writerId=&quot; + writerId);

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult = articlePortalService.queryArticleListOfWriter(writerId, page, pageSize);
        gridResult = rebuildArticleGrid(gridResult);
        return GraceJSONResult.ok(gridResult);
    &#125;

    @Override
    public GraceJSONResult queryGoodArticleListOfWriter(String writerId) &#123;
        PagedGridResult gridResult = articlePortalService.queryGoodArticleListOfWriter(writerId);
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;

*/
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
public interface ArticlePortalService &#123;

    /**
     * 首页查询文章列表
     */
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 Integer pageSize);
    /**
     * 首页查询热闻列表
     */
    public List&lt;Article&gt; queryHotList();

    /**
     * 查询作家发布的所有文章列表
     */
    public PagedGridResult queryArticleListOfWriter(String writerId,
                                                    Integer page,
                                                    Integer pageSize);

    /**
     * 作家页面查询近期佳文
     */
    public PagedGridResult queryGoodArticleListOfWriter(String writerId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java

@Override
    public PagedGridResult queryArticleListOfWriter(String writerId, Integer page, Integer pageSize) &#123;
        Example articleExample = new Example(Article.class);

        Example.Criteria criteria = setDefualArticleExample(articleExample);
        criteria.andEqualTo(&quot;publishUserId&quot;, writerId);

        /**
         * page: 第几页
         * pageSize: 每页显示条数
         */
        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        return setterPagedGrid(list, page);
    &#125;

    @Override
    public PagedGridResult queryGoodArticleListOfWriter(String writerId) &#123;
        Example articleExample = new Example(Article.class);
        articleExample.orderBy(&quot;publishTime&quot;).desc();

        Example.Criteria criteria = setDefualArticleExample(articleExample);
        criteria.andEqualTo(&quot;publishUserId&quot;, writerId);

        /**
         * page: 第几页
         * pageSize: 每页显示条数
         */
        PageHelper.startPage(1, 5);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        return setterPagedGrid(list, 1);
    &#125;

    private Example.Criteria setDefualArticleExample(Example articleExample) &#123;
        articleExample.orderBy(&quot;publishTime&quot;).desc();
        Example.Criteria criteria = articleExample.createCriteria();

        /**
         * 查询首页文章的自带隐性查询条件：
         * isAppoint=即使发布，表示文章已经直接发布的，或者定时任务到点发布的
         * isDelete=未删除，表示文章只能够显示未删除
         * articleStatus=审核通过，表示只有文章经过机审/人工审核之后才能展示
         */
        criteria.andEqualTo(&quot;isAppoint&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.SUCCESS.type);

        return criteria;
    &#125;
</code></pre>
<h4 id="关注与取关-redis单线程计数统计-【粉丝关注】"><a href="#关注与取关-redis单线程计数统计-【粉丝关注】" class="headerlink" title="关注与取关_redis单线程计数统计 【粉丝关注】"></a>关注与取关_redis单线程计数统计 【粉丝关注】</h4><blockquote>
<p>阅读数可以用数据库COUNT* 但是压力会很大 若很多人一起刷新会音响很大<br>用redis 数量累加累减 单线程安全<br>减少数据库压力</p>
</blockquote>
<pre><code class="mysql">【注意 redis我安装到了本地计算机里面 D:\Redis-x64-3.0.504】
打开redis-cli.exe
127.0.0.1:6379&gt; keys *
1) &quot;redis_all_category&quot;
2) &quot;redis_admin_token:1001&quot;
3) &quot;redis_user_info:1001&quot;
4) &quot;redis_user_info:200628AFYM7AGWPH&quot;
5) &quot;redis_user_token:240629F21AK1BHX4&quot;
6) &quot;redis_user_info:240629F21AK1BHX4&quot;
7) &quot;redis_user_token:200628AFYM7AGWPH&quot;
127.0.0.1:6379&gt; INCR 1001:fans #【增加】
(integer) 1
127.0.0.1:6379&gt; INCR 1001:fans
(integer) 2
127.0.0.1:6379&gt; INCR 1001:fans
(integer) 3
127.0.0.1:6379&gt; get 1001:fans #【获取】
&quot;3&quot;
127.0.0.1:6379&gt; DECR 1001:fans #【减少】
(integer) 2
127.0.0.1:6379&gt; DECR 1001:fans
(integer) 1
127.0.0.1:6379&gt; incr 1001:follows #【关注的粉丝】
(integer) 1
127.0.0.1:6379&gt; get 1001:follows
&quot;1&quot;
</code></pre>
<h3 id="查询用户关注状态【粉丝关注】"><a href="#查询用户关注状态【粉丝关注】" class="headerlink" title="查询用户关注状态【粉丝关注】"></a>查询用户关注状态【粉丝关注】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
    @ApiOperation(value = &quot;查询当前用户是否关注作家&quot;,notes = &quot;查询当前用户是否关注作家&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/isMeFollowThisWriter&quot;)
    public GraceJSONResult isMeFollowThisWriter(@RequestParam String writerId, @RequestParam String fanId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.api.controller.user.MyFansControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.user.service.MyFansService;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(MyFansController.class);

    @Autowired
    private MyFansService myFansService;

    @Override
    public GraceJSONResult isMeFollowThisWriter(String writerId, String fanId) &#123;
        boolean res = myFansService.isMeFollowThisWriter(writerId,fanId);
        return GraceJSONResult.ok(res);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

import java.util.Date;

public interface MyFansService &#123;
    /**
     * 查询当前用户是否关注作家
     */
    public boolean isMeFollowThisWriter(String writerId, String fanId);

&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
package com.imooc.user.service.impl;

import com.github.pagehelper.PageHelper;
import com.imooc.api.service.BaseService;
import com.imooc.enums.UserStatus;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.Fans;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.mapper.FansMapper;
import com.imooc.user.service.AppUserMngService;
import com.imooc.user.service.MyFansService;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
    @Autowired
    public FansMapper fansMapper;


    @Override
    public boolean isMeFollowThisWriter(String writerId, String fanId) &#123;
        Fans fan = new Fans();
        fan.setFanId(fanId);
        fan.setWriterId(writerId);
        int count = fansMapper.selectCount(fan); //前期先放在数据库里
        return count &gt; 0 ? true : false;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/mapper/FansMapper.java
package com.imooc.user.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Fans;
import org.springframework.stereotype.Repository;

@Repository
public interface FansMapper extends MyMapper&lt;Fans&gt; &#123;
&#125;
</code></pre>
<h3 id="用户关注-粉丝累加-amp-amp-粉丝累减"><a href="#用户关注-粉丝累加-amp-amp-粉丝累减" class="headerlink" title="用户关注_粉丝累加 &amp;&amp; 粉丝累减"></a>用户关注_粉丝累加 &amp;&amp; 粉丝累减</h3><pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
    @ApiOperation(value = &quot;用户关注作家，成为粉丝&quot;,notes = &quot;用户关注作家，成为粉丝&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/follow&quot;)
    public GraceJSONResult follow(@RequestParam String writerId, @RequestParam String fanId);
    
    @ApiOperation(value = &quot;取消关注，作家损失粉丝&quot;,notes = &quot;取消关注，作家损失粉丝&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/unfollow&quot;)
    public GraceJSONResult unfollow(@RequestParam String writerId, @RequestParam String fanId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.MyFansControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.user.service.MyFansService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(MyFansController.class);

    @Autowired
    private MyFansService myFansService;

    @Override
    public GraceJSONResult isMeFollowThisWriter(String writerId, String fanId) &#123;
        boolean res = myFansService.isMeFollowThisWriter(writerId,fanId);
        return GraceJSONResult.ok(res);
    &#125;

    @Override
    public GraceJSONResult follow(String writerId, String fanId) &#123;
        myFansService.follow(writerId,fanId);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult unfollow(String writerId, String fanId) &#123;
        myFansService.unfollow(writerId, fanId);
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

public interface MyFansService &#123;
    /**
     * 查询当前用户是否关注作家
     */
    public boolean isMeFollowThisWriter(String writerId, String fanId);

    /**
     * 关注成为粉丝
     */
    public void follow(String writerId, String fanId);
    
    /**
     * 粉丝取消关注
     */
    public void unfollow(String writerId, String fanId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
package com.imooc.user.service.impl;

import com.github.pagehelper.PageHelper;
import com.imooc.api.service.BaseService;
import com.imooc.enums.UserStatus;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.Fans;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.mapper.FansMapper;
import com.imooc.user.service.AppUserMngService;
import com.imooc.user.service.MyFansService;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
    @Autowired
    public FansMapper fansMapper;
    @Override
    public boolean isMeFollowThisWriter(String writerId, String fanId) &#123;
        Fans fan = new Fans();
        fan.setFanId(fanId);
        fan.setWriterId(writerId);
        int count = fansMapper.selectCount(fan); //前期先放在数据库里
        return count &gt; 0 ? true : false;
    &#125;
    
    @Transactional
    @Override
    public void follow(String writerId, String fanId) &#123;
        // 获得粉丝用户的信息
        AppUser fanInfo = userService.getUser(fanId);

        String fanPkId = sid.nextShort();

        Fans fans = new Fans();
        fans.setId(fanPkId);
        fans.setFanId(fanId);
        fans.setWriterId(writerId);

        fans.setFace(fanInfo.getFace());
        fans.setFanNickname(fanInfo.getNickname());
        fans.setSex(fanInfo.getSex());
        fans.setProvince(fanInfo.getProvince());

        fansMapper.insert(fans);

        // redis 作家粉丝数累加
        redis.increment(REDIS_WRITER_FANS_COUNTS + &quot;:&quot; + writerId, 1);  //增加key一次
        // redis 当前用户的(我的)关注数累加
        redis.increment(REDIS_MY_FOLLOW_COUNTS + &quot;:&quot; + fanId, 1);  //增加key一次
    &#125;
    
    @Transactional
    @Override
    public void unfollow(String writerId, String fanId) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);
        fans.setFanId(fanId);

        fansMapper.delete(fans);

        // redis 作家粉丝数累减
        redis.decrement(REDIS_WRITER_FANS_COUNTS + &quot;:&quot; + writerId, 1);  //增加key一次
        // redis 当前用户的(我的)关注数累减
        redis.decrement(REDIS_MY_FOLLOW_COUNTS + &quot;:&quot; + fanId, 1);  //增加key一次
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/service/BaseService.java
package com.imooc.api.service;

import com.github.pagehelper.PageInfo;
import com.imooc.utils.PagedGridResult;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;

public class BaseService &#123;
    public static final String REDIS_ALL_CATEGORY = &quot;redis_all_category&quot;;

    public static final String REDIS_WRITER_FANS_COUNTS = &quot;redis_writer_fans_counts&quot;;
    public static final String REDIS_MY_FOLLOW_COUNTS = &quot;redis_my_follow_counts&quot;;

    public static final String REDIS_ARTICLE_COMMENT_COUNTS = &quot;redis_article_comment_counts&quot;;

    @Autowired
    public RedisOperator redis;
    public PagedGridResult setterPagedGrid(List&lt;?&gt; list, Integer page)&#123; //类型是? 后期不确定是什么泛型
        PageInfo&lt;?&gt; pageList = new PageInfo&lt;&gt;(list);
        PagedGridResult gridResult = new PagedGridResult();
        gridResult.setRows(list);
        gridResult.setPage(page);
        gridResult.setRecords(pageList.getTotal());
        gridResult.setTotal(pageList.getPages());
        return gridResult;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java //增加粉丝接口的拦截
package com.imooc.api.config;

import com.imooc.api.interceptors.AdminTokenInterceptor;
import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;)
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;)
                .addPathPatterns(&quot;/fans/follow&quot;)
                .addPathPatterns(&quot;/fans/unfollow&quot;);

        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;)
                .addPathPatterns(&quot;/fs/uploadToGridFS&quot;)
                .addPathPatterns(&quot;/friendLinkMng/saveOrUpdateFriendLink&quot;)
                .addPathPatterns(&quot;/friendLinkMng/getFriendLinkList&quot;)
                .addPathPatterns(&quot;/friendLinkMng/delete&quot;)
                .addPathPatterns(&quot;/categoryMng/saveOrUpdateCategory&quot;)
                .addPathPatterns(&quot;/categoryMng/getCatList&quot;);

        registry.addInterceptor(userActiveInterceptor())
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;)
                .addPathPatterns(&quot;/fans/follow&quot;)
                .addPathPatterns(&quot;/fans/unfollow&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="粉丝数与关注数页面显示【粉丝关注】"><a href="#粉丝数与关注数页面显示【粉丝关注】" class="headerlink" title="粉丝数与关注数页面显示【粉丝关注】"></a>粉丝数与关注数页面显示【粉丝关注】</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
 @Override
    public GraceJSONResult getUserInfo(String userId) &#123;
        //接口进行解耦!!
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;
        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        AppUserVO userVO = new AppUserVO();
        BeanUtils.copyProperties(user, userVO); //拷贝信息
        // 3. 查询redis中用户的关注数和粉丝数，放入userVO放入前端渲染
        userVO.setMyFansCounts(getCountsFromRedis(REDIS_WRITER_FANS_COUNTS + &quot;:&quot; + userId));
        userVO.setMyFollowCounts(getCountsFromRedis(REDIS_MY_FOLLOW_COUNTS + &quot;:&quot; + userId));
        return GraceJSONResult.ok(userVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public abstract class BaseController &#123;
public Integer getCountsFromRedis(String key)&#123;
        String countsStr = redis.get(key);
        if (StringUtils.isBlank(countsStr)) &#123;
            countsStr = &quot;0&quot;;
        &#125;
        return Integer.valueOf(countsStr);
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/AppUserVO.java
public class AppUserVO &#123;
    private String id;
    private String nickname;
    private String face;
    private Integer activeStatus;

    private Integer myFollowCounts;
    private Integer myFansCounts;
&#125;Getter + Setter
</code></pre>
<h3 id="我的粉丝列表-后端分页查询【粉丝管理】"><a href="#我的粉丝列表-后端分页查询【粉丝管理】" class="headerlink" title="我的粉丝列表_后端分页查询【粉丝管理】"></a>我的粉丝列表_后端分页查询【粉丝管理】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
@ApiOperation(value = &quot;查询我的所有粉丝列表&quot;, notes = &quot;查询我的所有粉丝列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/queryAll&quot;)
    public GraceJSONResult queryAll(
            @RequestParam String writerId,
            @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
            @RequestParam Integer page,
            @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页查询每一页显示的条数&quot;, required = false)
            @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
 @Override
    public GraceJSONResult queryAll(String writerId, Integer page, Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        return GraceJSONResult.ok(myFansService.queryMyFansList(writerId, page, pageSize));
    &#125;
&#125;
===================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/myFans.html
数据库中fans表
weiter_id
可以改成登录的cookie里面的 uid：240629F21AK1BHX4
就可以测试用户粉丝数量
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

public interface MyFansService &#123;
    /**
     * 查询当前用户是否关注作家
     */
    public boolean isMeFollowThisWriter(String writerId, String fanId);

    /**
     * 关注成为粉丝
     */
    public void follow(String writerId, String fanId);

    /**
     * 粉丝取消关注
     */
    public void unfollow(String writerId, String fanId);

    /**
     * 查询我的粉丝
     */
    public PagedGridResult queryMyFansList(String writerId, Integer page, Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
@Override
    public PagedGridResult queryMyFansList(String writerId, Integer page, Integer pageSize) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);

        PageHelper.startPage(page,pageSize); //进行分页
        List&lt;Fans&gt; list = fansMapper.select(fans);
        return setterPagedGrid(list,page);
    &#125;
&#125;
</code></pre>
<h3 id="男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts"><a href="#男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts" class="headerlink" title="男女比例柱状图_饼状图显示【数据可视化-粉丝画像】Echarts"></a>男女比例柱状图_饼状图显示【数据可视化-粉丝画像】<del>Echarts</del></h3><p><a target="_blank" rel="noopener" href="https://echarts.apache.org/zh/index.html">Apache ECharts</a> + 前端 [myFansCharts-static.html + myFansCharts.html]</p>
<pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
@ApiOperation(value = &quot;查询男女粉丝数量&quot;, notes = &quot;查询男女粉丝数量&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/queryRatio&quot;)
    public GraceJSONResult queryRatio(@RequestParam String writerId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
 @Override
    public GraceJSONResult queryRatio(String writerId) &#123;
        int manCount = myFansService.queryFansCounts(writerId, Sex.man);
        int womanCount = myFansService.queryFansCounts(writerId, Sex.woman);

        FansCountsVO fansCountsVO = new FansCountsVO();
        fansCountsVO.setManCounts(manCount);
        fansCountsVO.setWomanCounts(womanCount);
        return GraceJSONResult.ok(fansCountsVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

public interface MyFansService &#123;
     /**
     * 查询粉丝数
     */
    public Integer queryFansCounts(String writerId, Sex sex);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
@Override
    public Integer queryFansCounts(String writerId, Sex sex) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);
        fans.setSex(sex.type);

        int count = fansMapper.selectCount(fans);
        return count;
    &#125;
&#125;
</code></pre>
<h3 id="中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】"><a href="#中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】" class="headerlink" title="中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】"></a>中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】</h3><h3 id="男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts-1"><a href="#男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts-1" class="headerlink" title="男女比例柱状图_饼状图显示【数据可视化-粉丝画像】Echarts"></a>男女比例柱状图_饼状图显示【数据可视化-粉丝画像】<del>Echarts</del></h3><p><a target="_blank" rel="noopener" href="https://echarts.apache.org/zh/index.html">Apache ECharts</a> + 前端 [myFansCharts-static.html + myFansCharts.html]</p>
<pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
@ApiOperation(value = &quot;根据地域查询粉丝数量&quot;, notes = &quot;根据地域查询粉丝数量&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/queryRatioByRegion&quot;)
    public GraceJSONResult queryRatioByRegion(@RequestParam String writerId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
  @Override
    public GraceJSONResult queryRatioByRegion(String writerId) &#123;
        return GraceJSONResult.ok(myFansService.queryRegionRatioCounts(writerId));
    &#125;
&#125;
=====================================================================
将fans里的writer_id【自己的cookie里的uid 属于自己的属性 对应着右面的province省份】
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

public interface MyFansService &#123;
     /**
     * 查询粉丝数
     */
    public List&lt;RegionRatioVO&gt; queryRegionRatioCounts(String writerId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
@Override
    public List&lt;RegionRatioVO&gt; queryRegionRatioCounts(String writerId) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);

        List&lt;RegionRatioVO&gt; list = new ArrayList&lt;&gt;();
        for (String r : regions) &#123;
            fans.setProvince(r);
            Integer count = fansMapper.selectCount(fans);

            RegionRatioVO regionRatioVO = new RegionRatioVO();
            regionRatioVO.setName(r);
            regionRatioVO.setValue(count);

            list.add(regionRatioVO);
        &#125;
        return list;
    &#125;

    public static final String[] regions = &#123;&quot;北京&quot;, &quot;天津&quot;, &quot;上海&quot;, &quot;重庆&quot;,
            &quot;河北&quot;, &quot;山西&quot;, &quot;辽宁&quot;, &quot;吉林&quot;, &quot;黑龙江&quot;, &quot;江苏&quot;, &quot;浙江&quot;, &quot;安徽&quot;, &quot;福建&quot;, &quot;江西&quot;, &quot;山东&quot;,
            &quot;河南&quot;, &quot;湖北&quot;, &quot;湖南&quot;, &quot;广东&quot;, &quot;海南&quot;, &quot;四川&quot;, &quot;贵州&quot;, &quot;云南&quot;, &quot;陕西&quot;, &quot;甘肃&quot;, &quot;青海&quot;, &quot;台湾&quot;,
            &quot;内蒙古&quot;, &quot;广西&quot;, &quot;西藏&quot;, &quot;宁夏&quot;, &quot;新疆&quot;,
            &quot;香港&quot;, &quot;澳门&quot;&#125;;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/RegionRatioVO.java
package com.imooc.pojo.vo;

public class RegionRatioVO &#123;

    private String name;
    private Integer value;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Integer getValue() &#123;
        return value;
    &#125;

    public void setValue(Integer value) &#123;
        this.value = value;
    &#125;
&#125;
</code></pre>
<h2 id="开发文章详情接口-【章节概述】detail-html"><a href="#开发文章详情接口-【章节概述】detail-html" class="headerlink" title="开发文章详情接口 【章节概述】detail.html"></a>开发文章详情接口 【章节概述】<del>detail.html</del></h2><ul>
<li><strong>文章详情页</strong></li>
<li><strong>文章评论模块</strong></li>
<li><strong>评论管理</strong></li>
</ul>
<h3 id="文章详情页"><a href="#文章详情页" class="headerlink" title="文章详情页"></a>文章详情页</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
 @GetMapping(&quot;detail&quot;)
    @ApiOperation(value = &quot;文章详情查询&quot;, notes = &quot;文章详情查询&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult detail(@RequestParam String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
 @Override
    public GraceJSONResult detail(String articleId) &#123;
        ArticleDetailVO detailVO = articlePortalService.queryDetail(articleId);

        Set&lt;String&gt; idSet = new HashSet();
        idSet.add(detailVO.getPublishUserId());
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        if (!publisherList.isEmpty()) &#123;
            detailVO.setPublishUserName(publisherList.get(0).getNickname());
        &#125;

        detailVO.setReadCounts(
                getCountsFromRedis(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId));

        return GraceJSONResult.ok(detailVO);
    &#125;
==================================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=240721DDAHBPWG0H
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
    /**
     * 查询文章详情
     */
    public ArticleDetailVO queryDetail(String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
    @Override
    public ArticleDetailVO queryDetail(String articleId) &#123;
        Article article = new Article();
        article.setId(articleId);
        article.setIsAppoint(YesOrNo.NO.type);
        article.setIsDelete(YesOrNo.NO.type);
        article.setArticleStatus(ArticleReviewStatus.SUCCESS.type);

        Article result = articleMapper.selectOne(article);
        ArticleDetailVO detailVO = new ArticleDetailVO();
        BeanUtils.copyProperties(result, detailVO);
        return detailVO;
    &#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/ArticleDetailVO.java
package com.imooc.pojo.vo;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.util.Date;

public class ArticleDetailVO &#123;

    private String id;
    private String title;
    private String cover;
    private Integer categoryId;
    private String categoryName;
    private String publishUserId;
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date publishTime;
    private String content;

    private String publishUserName;
    private Integer readCounts;
&#125;Getter + Setter
</code></pre>
<h3 id="阅读文章-阅读量redis累加【详情页】"><a href="#阅读文章-阅读量redis累加【详情页】" class="headerlink" title="阅读文章_阅读量redis累加【详情页】"></a>阅读文章_阅读量redis累加【详情页】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@PostMapping(&quot;readArticle&quot;)
    @ApiOperation(value = &quot;阅读文章，文章阅读量累加&quot;, notes = &quot;阅读文章，文章阅读量累加&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult readArticle(@RequestParam String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
  @Override
    public GraceJSONResult detail(String articleId) &#123;
        ArticleDetailVO detailVO = articlePortalService.queryDetail(articleId);

        Set&lt;String&gt; idSet = new HashSet();
        idSet.add(detailVO.getPublishUserId());
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        if (!publisherList.isEmpty()) &#123;
            detailVO.setPublishUserName(publisherList.get(0).getNickname());
        &#125;

        detailVO.setReadCounts( //去redis获取值 关联到前端阅读量增加 关联！！！
                getCountsFromRedis(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId));

        return GraceJSONResult.ok(detailVO);
    &#125;

    @Override
    public GraceJSONResult readArticle(String articleId) &#123;
        redis.increment(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId, 1);
        return GraceJSONResult.ok();
    &#125;
==================================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=240721DDAHBPWG0H
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
public class ArticleDetailVO &#123;

    private String id;
    private String title;
    private String cover;
    private Integer categoryId;
    private String categoryName;
    private String publishUserId;
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date publishTime;
    private String content;

    private String publishUserName;
    private Integer readCounts;
&#125;Getter + Setter
</code></pre>
<h3 id="文章阅读数防刷策略【详情页】"><a href="#文章阅读数防刷策略【详情页】" class="headerlink" title="文章阅读数防刷策略【详情页】"></a>文章阅读数防刷策略【详情页】</h3><blockquote>
<p>限定id去做增加 readArticle中增加拦截器<br>在ArticlePortalControllerApi.java中的readArticle接口 增加 HttpServletRequest request</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@PostMapping(&quot;readArticle&quot;)
    @ApiOperation(value = &quot;阅读文章，文章阅读量累加&quot;, notes = &quot;阅读文章，文章阅读量累加&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult readArticle(@RequestParam String articleId, HttpServletRequest request);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult readArticle(String articleId, HttpServletRequest request) &#123;
        String userIp = IPUtil.getRequestIp(request);
        // 设置针对当前用户ip的永久存在的key，存入redis，表示该ip的用户已经阅读过了 防刷策略
        redis.setnx(REDIS_ALREADY_READ + &quot;:&quot; + articleId + &quot;:&quot; + userIp, userIp);

        redis.increment(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId, 1);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/interceptors/ArticleReadInterceptor.java //【增加拦截器】
package com.imooc.api.interceptors;

import com.imooc.utils.IPUtil;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ArticleReadInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    @Autowired
    public RedisOperator redis;
    public static final String REDIS_ALREADY_READ = &quot;redis_already_read&quot;;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        String articleId = request.getParameter(&quot;articleId&quot;);

        String userIp = IPUtil.getRequestIp(request);
        boolean isExist = redis.keyIsExist(REDIS_ALREADY_READ + &quot;:&quot; +  articleId + &quot;:&quot; + userIp);

        if (isExist) &#123;
            return false;
        &#125;
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
...
    @Bean
    public ArticleReadInterceptor articleReadInterceptor()&#123;
        return new ArticleReadInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
...
        registry.addInterceptor(articleReadInterceptor())
                .addPathPatterns(&quot;/portal/article/readArticle&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="Redis-mget-批量查询组装阅读量并展示【文章列表】"><a href="#Redis-mget-批量查询组装阅读量并展示【文章列表】" class="headerlink" title="Redis mget 批量查询组装阅读量并展示【文章列表】"></a>Redis mget 批量查询组装阅读量并展示【文章列表】</h3><h5 id="Redis-get单个读取-amp-amp-Redis-mget批量读取"><a href="#Redis-get单个读取-amp-amp-Redis-mget批量读取" class="headerlink" title="Redis get单个读取 &amp;&amp; Redis mget批量读取"></a>Redis get单个读取 &amp;&amp; Redis mget批量读取</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/9d581a6e864d203ffb7157e6edd621ef947c4775/data/Redis_mget%E6%89%B9%E9%87%8F%E6%9F%A5%E8%AF%A2.png"></p>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
 private PagedGridResult rebuildArticleGrid(PagedGridResult gridResult) &#123;
        // START
        List&lt;Article&gt; list = (List&lt;Article&gt;)gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        List&lt;String&gt; idList = new ArrayList&lt;&gt;();
        for (Article a : list) &#123;
//            System.out.println(a.getPublishUserId());
            // 1.1 构建发布者的set
            idSet.add(a.getPublishUserId());
            // 1.2 构建文章id的list 包含所有key的值
            idList.add(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + a.getId());
        &#125;
        System.out.println(idSet.toString());
        // 发起redis的mget批量查询api，获得对应的值
        List&lt;String&gt; readCountsRedisList = redis.mget(idList);
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        // 3. 拼接两个list，重组文章列表
        List&lt;IndexArticleVO&gt; indexArticleList = new ArrayList&lt;&gt;();
        for (int i = 0 ; i &lt; list.size() ; i ++) &#123;
            IndexArticleVO indexArticleVO = new IndexArticleVO();
            Article a = list.get(i); //属性值拷贝
            BeanUtils.copyProperties(a, indexArticleVO);

            // 3.1 从publisherList中获得发布者的基本信息
            AppUserVO publisher  = getUserIfPublisher(a.getPublishUserId(), publisherList);
            indexArticleVO.setPublisherVO(publisher);

            // 3.2 重新组装设置文章列表中的阅读量
            String redisCountsStr = readCountsRedisList.get(i);
            int readCounts = 0;
            if (StringUtils.isNotBlank(redisCountsStr)) &#123;
                readCounts = Integer.valueOf(redisCountsStr);
            &#125;
            indexArticleVO.setReadCounts(readCounts);

            indexArticleList.add(indexArticleVO);
        &#125;
        gridResult.setRows(indexArticleList);
// END
        return gridResult;
    &#125;
</code></pre>
<h3 id="用户发表评论【文章评论】"><a href="#用户发表评论【文章评论】" class="headerlink" title="用户发表评论【文章评论】"></a>用户发表评论【文章评论】</h3><pre><code class="xml">mybatis-generator-database generatorConfig-article.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;!-- 通用mapper所在目录 --&gt;
        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;com.imooc.my.mapper.MyMapper&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/imooc-news-dev&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 对应生成的pojo所在包 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.imooc.pojo&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot;/&gt;

        &lt;!-- 对应生成的mapper所在目录 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper.article&quot; targetProject=&quot;mybatis-generator-database/src/main/resources&quot;/&gt;

        &lt;!-- 配置mapper对应的java映射 --&gt;
        &lt;javaClientGenerator targetPackage=&quot;com.imooc.article.mapper&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt;

        &lt;!-- 数据库表 --&gt;
        &lt;table tableName=&quot;comments&quot;&gt;&lt;/table&gt;

    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="java">mybatis-generator-database  com/imooc/mybatis/utils/ArticleGenerator.java //【运行】
package com.imooc.mybatis.utils;

import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;


public class ArticleGenerator &#123;

    public void generator() throws Exception &#123;

        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        //指定 逆向工程配置文件
        File configFile = new File(&quot;mybatis-generator-database&quot;
                                            + File.separator
                                            + &quot;generatorConfig-article.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);

    &#125; 
    
    public static void main(String[] args) throws Exception &#123;
        try &#123;
            ArticleGenerator generatorSqlmap = new ArticleGenerator();
            generatorSqlmap.generator();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/CommentsMapper.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Comments;

public interface CommentsMapper extends MyMapper&lt;Comments&gt; &#123;
&#125;

================================================================

</code></pre>
<pre><code class="java">service-article  resources/mapper/CommentsMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapper&quot;&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot;&gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;writerId&quot; /&gt;
    &lt;result column=&quot;father_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fatherId&quot; /&gt;
    &lt;result column=&quot;article_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleId&quot; /&gt;
    &lt;result column=&quot;article_title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleTitle&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleCover&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserId&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserNickname&quot; /&gt;
    &lt;result column=&quot;comment_user_face&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserFace&quot; /&gt;
    &lt;result column=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot;&gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;writerId&quot; /&gt;
    &lt;result column=&quot;father_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fatherId&quot; /&gt;
    &lt;result column=&quot;article_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleId&quot; /&gt;
    &lt;result column=&quot;article_title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleTitle&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleCover&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserId&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserNickname&quot; /&gt;
    &lt;result column=&quot;comment_user_face&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserFace&quot; /&gt;
    &lt;result column=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot;&gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;writerId&quot; /&gt;
    &lt;result column=&quot;father_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fatherId&quot; /&gt;
    &lt;result column=&quot;article_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleId&quot; /&gt;
    &lt;result column=&quot;article_title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleTitle&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleCover&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserId&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserNickname&quot; /&gt;
    &lt;result column=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
@Api(value = &quot;评论相关业务的controller&quot;, tags = &#123;&quot;评论相关业务的controller&quot;&#125;)
@RequestMapping(&quot;comment&quot;)
public interface CommentControllerApi &#123;

    @PostMapping(&quot;createComment&quot;)
    @ApiOperation(value = &quot;用户评论&quot;, notes = &quot;用户评论&quot;, httpMethod = &quot;POST&quot;) //@Valid是做验证的
    public GraceJSONResult createArticle(@RequestBody @Valid CommentReplyBO commentReplyBO, BindingResult result);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
@RestController
public class CommentController extends BaseController implements CommentControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(CommentController.class);

    @Override
    public GraceJSONResult createArticle(@Valid CommentReplyBO commentReplyBO,
                                         BindingResult result) &#123;
        // 0. 判断BindingResult是否保存错误的验证信息，如果有，则直接return
        if (result.hasErrors()) &#123;
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;

        // 1. 根据留言用户的id查询他的昵称，用于存入到数据表进行字段的冗余处理，从而避免多表关联查询的性能影响
        String userId = commentReplyBO.getCommentUserId();

        // 2. 发起restTemplate调用用户服务，获得用户侧昵称
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        idSet.add(userId);
        String nickname = getBasicUserList(idSet).get(0).getNickname();
...[未完待续]
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public List&lt;AppUserVO&gt; getBasicUserList(Set idSet) &#123;
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; userVOList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            userVOList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return userVOList;
    &#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/CommentReplyBO.java
/**
 * 文章留言的BO
 */
public class CommentReplyBO &#123;

    @NotBlank(message = &quot;留言信息不完整&quot;)
    private String articleId;

    @NotBlank(message = &quot;留言信息不完整&quot;)
    private String fatherId;

    @NotBlank(message = &quot;当前用户信息不正确，请尝试重新登录&quot;)
    private String commentUserId;

    @NotBlank(message = &quot;留言内容不能为空&quot;)
    @Length(max = 50, message = &quot;文章内容长度不能超过50&quot;)
    private String content;
&#125;Getter + Setter + ToString
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Comments.java
public class Comments &#123;
    @Id
    private String id;

    /**
     * 评论的文章是哪个作者的关联id
     */
    @Column(name = &quot;writer_id&quot;)
    private String writerId;

    /**
     * 如果是回复留言，则本条为子留言，需要关联查询
     */
    @Column(name = &quot;father_id&quot;)
    private String fatherId;

    /**
     * 回复的那个文章id
     */
    @Column(name = &quot;article_id&quot;)
    private String articleId;

    /**
     * 冗余文章标题，宽表处理，非规范化的sql思维，对于几百万文章和几百万评论的关联查询来讲，性能肯定不行，所以做宽表处理，从业务角度来说，文章发布以后不能随便修改标题和封面的
     */
    @Column(name = &quot;article_title&quot;)
    private String articleTitle;

    /**
     * 文章封面
     */
    @Column(name = &quot;article_cover&quot;)
    private String articleCover;

    /**
     * 发布留言的用户id
     */
    @Column(name = &quot;comment_user_id&quot;)
    private String commentUserId;

    /**
     * 冗余用户昵称，非一致性字段，用户修改昵称后可以不用同步
     */
    @Column(name = &quot;comment_user_nickname&quot;)
    private String commentUserNickname;

    /**
     * 冗余的用户头像
     */
    @Column(name = &quot;comment_user_face&quot;)
    private String commentUserFace;

    /**
     * 留言内容
     */
    private String content;

    /**
     * 留言时间
     */
    @Column(name = &quot;create_time&quot;)
    private Date createTime;
</code></pre>
<h3 id="用户评论入库保存【文章评论】这里暂时把数据库的comment-user-face删除了"><a href="#用户评论入库保存【文章评论】这里暂时把数据库的comment-user-face删除了" class="headerlink" title="用户评论入库保存【文章评论】这里暂时把数据库的comment_user_face删除了"></a>用户评论入库保存【文章评论】<del>这里暂时把数据库的comment_user_face删除了</del></h3><pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
@Api(value = &quot;评论相关业务的controller&quot;, tags = &#123;&quot;评论相关业务的controller&quot;&#125;)
@RequestMapping(&quot;comment&quot;)
public interface CommentControllerApi &#123;

    @PostMapping(&quot;createComment&quot;)
    @ApiOperation(value = &quot;用户评论&quot;, notes = &quot;用户评论&quot;, httpMethod = &quot;POST&quot;) //@Valid是做验证的
    public GraceJSONResult createArticle(@RequestBody @Valid CommentReplyBO commentReplyBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
@RestController
public class CommentController extends BaseController implements CommentControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(CommentController.class);
    @Autowired
    private CommentPortalService commentPortalService;

    @Override
    public GraceJSONResult createArticle(@Valid CommentReplyBO commentReplyBO,
                                         BindingResult result) &#123;
        // 0. 判断BindingResult是否保存错误的验证信息，如果有，则直接return
        if (result.hasErrors()) &#123;
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;

        // 1. 根据留言用户的id查询他的昵称，用于存入到数据表进行字段的冗余处理，从而避免多表关联查询的性能影响
        String userId = commentReplyBO.getCommentUserId();

        // 2. 发起restTemplate调用用户服务，获得用户侧昵称
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        idSet.add(userId);
        String nickname = getBasicUserList(idSet).get(0).getNickname();

        // 3. 保存用户评论的信息到数据库
        commentPortalService.createComment(commentReplyBO.getArticleId(), commentReplyBO.getFatherId(), commentReplyBO.getContent(), userId, nickname);

        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java
public interface CommentPortalService &#123;
    /**
     * 发表评论
     */
    public void createComment(String articleId,
                              String fatherCommentId,
                              String content,
                              String userId,
                              String nickname);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
package com.imooc.article.service.impl;

import com.imooc.api.service.BaseService;
import com.imooc.article.mapper.CommentsMapper;
import com.imooc.article.service.ArticlePortalService;
import com.imooc.article.service.CommentPortalService;
import com.imooc.pojo.Comments;
import com.imooc.pojo.vo.ArticleDetailVO;
import com.imooc.utils.PagedGridResult;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;


@Service
public class CommentPortalServiceImpl extends BaseService implements CommentPortalService &#123;
    @Autowired
    private ArticlePortalService articlePortalService;
    @Autowired
    private Sid sid;
    @Autowired
    private CommentsMapper commentsMapper;

    @Transactional
    @Override
    public void createComment(String articleId, String fatherCommentId, String content, String userId, String nickname) &#123;
        String commentId = sid.nextShort();
        ArticleDetailVO article = articlePortalService.queryDetail(articleId);
        Comments comments = new Comments();
        comments.setId(commentId);

        comments.setWriterId(article.getPublishUserId());
        comments.setArticleTitle(article.getTitle());
        comments.setArticleCover(article.getCover());
        comments.setArticleId(articleId);

        comments.setFatherId(fatherCommentId);
        comments.setCommentUserId(userId);
        comments.setCommentUserNickname(nickname);

        comments.setContent(content);
        comments.setCreateTime(new Date());

        commentsMapper.insert(comments);

        // 评论数累加
        redis.increment(REDIS_ARTICLE_COMMENT_COUNTS + &quot;:&quot; + articleId, 1);
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Comments.java
public class Comments &#123;
    @Id
    private String id;

    /**
     * 评论的文章是哪个作者的关联id
     */
    @Column(name = &quot;writer_id&quot;)
    private String writerId;

    /**
     * 如果是回复留言，则本条为子留言，需要关联查询
     */
    @Column(name = &quot;father_id&quot;)
    private String fatherId;

    /**
     * 回复的那个文章id
     */
    @Column(name = &quot;article_id&quot;)
    private String articleId;

    /**
     * 冗余文章标题，宽表处理，非规范化的sql思维，对于几百万文章和几百万评论的关联查询来讲，性能肯定不行，所以做宽表处理，从业务角度来说，文章发布以后不能随便修改标题和封面的
     */
    @Column(name = &quot;article_title&quot;)
    private String articleTitle;

    /**
     * 文章封面
     */
    @Column(name = &quot;article_cover&quot;)
    private String articleCover;

    /**
     * 发布留言的用户id
     */
    @Column(name = &quot;comment_user_id&quot;)
    private String commentUserId;

    /**
     * 冗余用户昵称，非一致性字段，用户修改昵称后可以不用同步
     */
    @Column(name = &quot;comment_user_nickname&quot;)
    private String commentUserNickname;

//    /**
//     * 冗余的用户头像
//     */
//    @Column(name = &quot;comment_user_face&quot;)
//    private String commentUserFace;

    /**
     * 留言内容
     */
    private String content;

    /**
     * 留言时间
     */
    @Column(name = &quot;create_time&quot;)
    private Date createTime;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public List&lt;AppUserVO&gt; getBasicUserList(Set idSet) &#123;
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; userVOList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            userVOList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return userVOList;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/CommentsMapper.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Comments;
import org.springframework.stereotype.Repository;

@Repository
public interface CommentsMapper extends MyMapper&lt;Comments&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">service-article  resources/mapper/CommentsMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; property=&quot;writerId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;father_id&quot; property=&quot;fatherId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; property=&quot;articleCover&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; property=&quot;commentUserId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; property=&quot;commentUserNickname&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;content&quot; property=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="评论数累计与显示【文章评论】"><a href="#评论数累计与显示【文章评论】" class="headerlink" title="评论数累计与显示【文章评论】"></a>评论数累计与显示【文章评论】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
@Api(value = &quot;评论相关业务的controller&quot;, tags = &#123;&quot;评论相关业务的controller&quot;&#125;)
@RequestMapping(&quot;comment&quot;)
public interface CommentControllerApi &#123;
@GetMapping(&quot;counts&quot;)
    @ApiOperation(value = &quot;用户评论数查询&quot;, notes = &quot;用户评论数查询&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult commentCounts(@RequestParam String articleId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
 @Override
    public GraceJSONResult commentCounts(String articleId) &#123;
        Integer counts = getCountsFromRedis(REDIS_ARTICLE_COMMENT_COUNTS + &quot;:&quot; + articleId);
        return GraceJSONResult.ok(counts);
    &#125;

--------------------------------------------------------------------------
service-api  com/imooc/api/BaseController.java
public Integer getCountsFromRedis(String key)&#123;
        String countsStr = redis.get(key);
        if (StringUtils.isBlank(countsStr)) &#123;
            countsStr = &quot;0&quot;;
        &#125;
        return Integer.valueOf(countsStr);
    &#125;
</code></pre>
<h3 id="文章评论sql关联查询father-id…"><a href="#文章评论sql关联查询father-id…" class="headerlink" title="文章评论sql关联查询father_id…"></a>文章评论sql关联查询<del>father_id…</del></h3><pre><code class="mysql">【多表关联查询】
SELECT
    c.id as commentId,
    c.father_id as fatherId,
    c.comment_user_id as commentUserId,
    c.comment_user_nickname as commentUserNickname,
    c.article_id as articleId,
    c.content as content,
    c.create_time as createTime,
    f.comment_user_nickname as quoteUserNickname,
    f.content as quoteContent
FROM
    comments c
LEFT JOIN
    comments f
ON
    c.father_id = f.id
WHERE
    c.article_id = &#39;2006117B57WRZGHH&#39;
ORDER BY
    c.create_time
DESC
</code></pre>
<h3 id="显示评论列表【文章评论】"><a href="#显示评论列表【文章评论】" class="headerlink" title="显示评论列表【文章评论】"></a>显示评论列表【文章评论】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
com/imooc/api/controller/article/CommentControllerApi.java 
@GetMapping(&quot;list&quot;)
    @ApiOperation(value = &quot;查询文章的所有评论列表&quot;, notes = &quot;查询文章的所有评论列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult list(@RequestParam String articleId,
                                @RequestParam Integer page,
                                @RequestParam Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
@Override
    public GraceJSONResult list(String articleId, Integer page, Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        PagedGridResult gridResult = commentPortalService.queryArticleComments(articleId, page, pageSize);
        return GraceJSONResult.ok(gridResult);
    &#125;
==============================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=200816961ZYBXFRP
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java
/**
     * 查询文章评论列表
     */
    public PagedGridResult queryArticleComments(String articleId,
                                                Integer page,
                                                Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/CommentsMapperCustom.java
package com.imooc.article.mapper;

import com.imooc.pojo.vo.CommentsVO;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

@Repository
public interface CommentsMapperCustom &#123;

    /**
     * 查询文章评论
     */
    public List&lt;CommentsVO&gt; queryArticleCommentList(@Param(&quot;paramMap&quot;) Map&lt;String, Object&gt; map);

&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
@Override
    public PagedGridResult queryArticleComments(String articleId, Integer page, Integer pageSize) &#123;
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleId&quot;, articleId);

        PageHelper.startPage(page, pageSize);
        List&lt;CommentsVO&gt; list = commentsMapperCustom.queryArticleCommentList(map);
        return setterPagedGrid(list,page);
    &#125;
</code></pre>
<pre><code class="mysql">service-article  resources/mapper/CommentsMapperCustom.xml #【把关于face的字段都删掉】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapperCustom&quot; &gt;

  &lt;select id=&quot;queryArticleCommentList&quot;
          resultType=&quot;com.imooc.pojo.vo.CommentsVO&quot;
          parameterType=&quot;Map&quot;&gt;

    SELECT
      c.id as commentId,
      c.father_id as fatherId,
      c.comment_user_id as commentUserId,
      c.comment_user_nickname as commentUserNickname,
      c.article_id as articleId,
      c.content as content,
      c.create_time as createTime,
      f.comment_user_nickname as quoteUserNickname,
      f.content as quoteContent
    FROM
      comments c
        LEFT JOIN
      comments f
      ON
        c.father_id = f.id
    WHERE
      c.article_id = #&#123;paramMap.articleId&#125;
    ORDER BY
      c.create_time
            DESC

  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="作业-管理评论列表以及删除评论【评论管理】"><a href="#作业-管理评论列表以及删除评论【评论管理】" class="headerlink" title="(作业) 管理评论列表以及删除评论【评论管理】"></a>(作业) 管理评论列表以及删除评论【评论管理】</h3><blockquote>
<p>前端的commentMng.html的VUE有问题<br>需要增加定义userInfo<br>var mainPage &#x3D; new Vue({<br>        el: “#mainPage”,<br>data: {<br>            userInfo: {<br>                activeStatus: 0<br>            },<br>}…</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
    @PostMapping(&quot;mng&quot;)
    @ApiOperation(value = &quot;查询我的评论管理列表&quot;, notes = &quot;查询我的评论管理列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult mng(@RequestParam String writerId,
                               @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                               @RequestParam Integer page,
                               @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                               @RequestParam Integer pageSize);


    @PostMapping(&quot;/delete&quot;)
    @ApiOperation(value = &quot;作者删除评论&quot;, notes = &quot;作者删除评论&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult delete(@RequestParam String writerId,
                                  @RequestParam String commentId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
 @Override
    public GraceJSONResult mng(String writerId, Integer page, Integer pageSize) &#123;

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult = commentPortalService.queryWriterCommentsMng(writerId, page, pageSize);
        return GraceJSONResult.ok(gridResult);
    &#125;

    @Override
    public GraceJSONResult delete(String writerId, String commentId) &#123;
        commentPortalService.deleteComment(writerId, commentId);
        return GraceJSONResult.ok();
    &#125;
==============================================================
http://writer.imoocnews.com:9090/imooc-news/writer/commentMng.html
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java
     /**
     * 查询我的评论管理列表
     */
    public PagedGridResult queryWriterCommentsMng(String writerId, Integer page, Integer pageSize);

    /**
     * 删除评论
     */
    public void deleteComment(String writerId, String commentId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
@Override
    public PagedGridResult queryWriterCommentsMng(String writerId, Integer page, Integer pageSize) &#123;
        Comments comment = new Comments();
        comment.setWriterId(writerId);
        PageHelper.startPage(page, pageSize);
        List&lt;Comments&gt; list = commentsMapper.select(comment);
        return setterPagedGrid(list,page);
    &#125;

    @Override
    public void deleteComment(String writerId, String commentId) &#123;
        Comments comment = new Comments();
        comment.setId(commentId);
        comment.setWriterId(writerId);
        commentsMapper.delete(comment);
    &#125;
</code></pre>
<h3 id="增加评论者头像展示功能需求扩展【文章评论】增加需求字段comment-user-face"><a href="#增加评论者头像展示功能需求扩展【文章评论】增加需求字段comment-user-face" class="headerlink" title="增加评论者头像展示功能需求扩展【文章评论】增加需求字段comment_user_face"></a>增加评论者头像展示功能需求扩展【文章评论】<del>增加需求字段comment_user_face</del></h3><blockquote>
<p>[数据库添加一个新的字段comment_user_face 重新在mybatis-generator-database进行逆向生成覆盖]<br>涉及范围广</p>
<p>在数据库里也要加个字段  在前端需求也要改一下头像</p>
</blockquote>
<pre><code class="html">detail.html
&lt;div class=&quot;all-comments-list&quot; v-for=&quot;(comment,index) in commentList&quot; :key=&quot;index&quot;&gt;
        &lt;div class=&quot;single-comment-wrapper&quot;&gt;
        &lt;!--&lt;img src=&quot;./img/face1.png&quot; class=&quot;user-face&quot;/&gt;--&gt;
        &lt;img :src=&quot;comment.commentUserFace&quot; class=&quot;user-face&quot;/&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="mysql">service-article  resources/mapper/CommentsMapper.xml #【增加字段】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; property=&quot;writerId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;father_id&quot; property=&quot;fatherId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; property=&quot;articleCover&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; property=&quot;commentUserId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; property=&quot;commentUserNickname&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_face&quot; property=&quot;commentUserFace&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;content&quot; property=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="mysql">service-article  resources/mapper/CommentsMapperCustom.xml #【增加字段】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapperCustom&quot; &gt;

  &lt;select id=&quot;queryArticleCommentList&quot;
          resultType=&quot;com.imooc.pojo.vo.CommentsVO&quot;
          parameterType=&quot;Map&quot;&gt;

    SELECT
      c.id as commentId,
      c.father_id as fatherId,
      c.comment_user_id as commentUserId,
      c.comment_user_nickname as commentUserNickname,
      c.comment_user_face as commentUserFace,
      c.article_id as articleId,
      c.content as content,
      c.create_time as createTime,
      f.comment_user_nickname as quoteUserNickname,
      f.content as quoteContent
    FROM
      comments c
        LEFT JOIN
      comments f
      ON
        c.father_id = f.id
    WHERE
      c.article_id = #&#123;paramMap.articleId&#125;
    ORDER BY
      c.create_time
            DESC

  &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java //【增加字段】
 /**
     * 发表评论
     */
    public void createComment(String articleId,
                              String fatherCommentId,
                              String content,
                              String userId,
                              String nickname,
                              String face);
</code></pre>
<pre><code class="java">------------------------------------------------------------
dev-model  com/imooc/pojo/vo/CommentsVO.java //【增加字段属性】
private String commentUserFace;
    【Getter + Setter】

------------------------------------------------------------
dev-model  com/imooc/pojo/Comments.java
/**
     * 冗余的用户头像
     */
@Column(name = &quot;comment_user_face&quot;)
private String commentUserFace;
    【Getter + Setter】
------------------------------------------------------------
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java 
    //【增加 String face = getBasicUserList(idSet).get(0).getFace();】
@Override
    public GraceJSONResult createArticle(@Valid CommentReplyBO commentReplyBO,
                                         BindingResult result) &#123;
        // 0. 判断BindingResult是否保存错误的验证信息，如果有，则直接return
        if (result.hasErrors()) &#123;
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;

        // 1. 根据留言用户的id查询他的昵称，用于存入到数据表进行字段的冗余处理，从而避免多表关联查询的性能影响
        String userId = commentReplyBO.getCommentUserId();

        // 2. 发起restTemplate调用用户服务，获得用户侧昵称
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        idSet.add(userId);
        String nickname = getBasicUserList(idSet).get(0).getNickname();
        String face = getBasicUserList(idSet).get(0).getFace();

        // 3. 保存用户评论的信息到数据库
        commentPortalService.createComment(commentReplyBO.getArticleId(), commentReplyBO.getFatherId(), commentReplyBO.getContent(), userId, nickname,face);

        return GraceJSONResult.ok();
    &#125;
====================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=2006116Z3MAP8SW0
//下面有个评论：牛逼  带着自己上传的头像
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
    //【增加 comments.setCommentUserFace(face);】
@Transactional
    @Override
    public void createComment(String articleId, String fatherCommentId, String content, String userId, String nickname,String face) &#123;
        String commentId = sid.nextShort();
        ArticleDetailVO article = articlePortalService.queryDetail(articleId);
        Comments comments = new Comments();
        comments.setId(commentId);

        comments.setWriterId(article.getPublishUserId());
        comments.setArticleTitle(article.getTitle());
        comments.setArticleCover(article.getCover());
        comments.setArticleId(articleId);

        comments.setFatherId(fatherCommentId);
        comments.setCommentUserId(userId);
        comments.setCommentUserNickname(nickname);
        comments.setCommentUserFace(face);

        comments.setContent(content);
        comments.setCreateTime(new Date());

        commentsMapper.insert(comments);

        // 评论数累加
        redis.increment(REDIS_ARTICLE_COMMENT_COUNTS + &quot;:&quot; + articleId, 1);
    &#125;
</code></pre>
<h3 id="文章静态化技术与Freemarker【文章概述】"><a href="#文章静态化技术与Freemarker【文章概述】" class="headerlink" title="文章静态化技术与Freemarker【文章概述】"></a>文章静态化技术与Freemarker【文章概述】</h3><ul>
<li><strong>页面静态化</strong></li>
<li><strong>Freemarker静态化技术</strong></li>
<li><strong>渲染模板数据</strong></li>
<li><strong>生成并展示静态页面</strong></li>
</ul>
<h5 id="静态化趋势"><a href="#静态化趋势" class="headerlink" title="静态化趋势"></a>静态化趋势</h5><ul>
<li><strong>便于SEO</strong></li>
<li><strong>加速用户访问</strong></li>
<li><strong>降低数据库压力</strong></li>
</ul>
<h5 id="模板引擎技术"><a href="#模板引擎技术" class="headerlink" title="模板引擎技术"></a>模板引擎技术</h5><ul>
<li><strong>JSP</strong></li>
<li><strong>Freemarker</strong></li>
<li><strong>Thymeleaf</strong></li>
<li><strong>Velocity</strong></li>
</ul>
<h5 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/1f57d8e494be53fe2ee4745f819db41fe1e7173a/data/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96.png"></p>
<h3 id="创建并且显示模板ftl"><a href="#创建并且显示模板ftl" class="headerlink" title="创建并且显示模板ftl"></a>创建并且显示模板ftl</h3><pre><code class="xml">service-article  pom.xml
 &lt;!-- freemarker 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        // 定义输出到模板的内容
        // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);

        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;
&#125;
==================================================================
http://localhost:8001/free/hello
</code></pre>
<pre><code class="yaml">service-article  resources/application.yml 【suffix是模板后缀】
  freemarker:
    charset: UTF-8
    content-type: text/html
    suffix: .ftl
    template-loader-path: classpath:/templates/
</code></pre>
<pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Hello Freemarker&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;#-- 
        写完以后去模板页面配置 application.yml
        Freemarker 页面的语法构成：
        1. 注释
        2. 表达式 $&#123;...&#125;
        3. 普通文本，基本的html标签
        4. 指令
    --&gt;
        &lt;div&gt;
            hello $&#123;there&#125;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="输出对象【Freemarker语法】"><a href="#输出对象【Freemarker语法】" class="headerlink" title="输出对象【Freemarker语法】"></a>输出对象【Freemarker语法】</h3><pre><code class="java">dev-model  com/imooc/pojo/Stu.java
public class Stu &#123;
    private String uid;
    private String username;
    private Integer age;
    private Date birthday;
    private Float amount;
    private boolean haveChild;
    private Spouse spouse;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Spouse.java
public class Spouse &#123;
    private String username;
    private Integer age;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        // 定义输出到模板的内容
        // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);

        makeModel(model);
        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;

    private Model makeModel(Model model) &#123;
        Stu stu = new Stu();
        stu.setUid(&quot;10010&quot;);
        stu.setUsername(&quot;imooc&quot;);
        stu.setAmount(88.86f);
        stu.setAge(18);
        stu.setHaveChild(true);
        stu.setBirthday(new Date());

        Spouse spouse = new Spouse();
        spouse.setUsername(&quot;Lucy&quot;);
        spouse.setAge(25);
        stu.setSpouse(spouse);
        model.addAttribute(&quot;stu&quot;,stu);
        return model;
    &#125;
&#125;
==================================================================
http://localhost:8001/free/hello

Hello 慕课网 imooc.com

用户名uid: 10010
用户姓名: imooc
年龄：18
生日：2024-07-29 15:13:05
用户余额：88.86
已育：yes
伴侣：Lucy,25岁
</code></pre>
<pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello Freemarker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;#-- 写完以后去模板页面配置 application.yml
    Freemarker 页面的语法构成：
    1. 注释
    2. 表达式 $&#123;...&#125;
    3. 普通文本，基本的html标签
    4. 指令
--&gt;
    &lt;div&gt;
        hello $&#123;there&#125;
    &lt;/div&gt;
&lt;br&gt;

    &lt;div&gt;
        用户名uid: $&#123;stu.uid&#125;&lt;br&gt;
        用户姓名: $&#123;stu.username&#125;&lt;br&gt;
        年龄：$&#123;stu.age&#125;&lt;br&gt;
        生日：$&#123;stu.birthday?string(&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&lt;br&gt; &lt;#-- 日期转换 --&gt;
        用户余额：$&#123;stu.amount&#125;&lt;br&gt;
        已育：$&#123;stu.haveChild?string(&#39;yes&#39;, &#39;no&#39;)&#125;&lt;br&gt;
        伴侣：$&#123;stu.spouse.username&#125;,$&#123;stu.spouse.age&#125;岁

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="输出list与map【Freemarker语法】"><a href="#输出list与map【Freemarker语法】" class="headerlink" title="输出list与map【Freemarker语法】"></a>输出list与map【Freemarker语法】</h3><pre><code class="java">dev-model  com/imooc/pojo/Stu.java
public class Stu &#123;
    private String uid;
    private String username;
    private Integer age;
    private Date birthday;
    private Float amount;
    private boolean haveChild;

    private Spouse spouse;

    private List&lt;Article&gt; articleList;
    private Map&lt;String, String&gt; parents;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Spouse.java
public class Spouse &#123;
    private String username;
    private Integer age;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.Article;
import com.imooc.pojo.Spouse;
import com.imooc.pojo.Stu;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.*;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        // 定义输出到模板的内容
        // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);

        makeModel(model);
        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;

    private Model makeModel(Model model) &#123;
        Stu stu = new Stu();
        stu.setUid(&quot;10010&quot;);
        stu.setUsername(&quot;imooc&quot;);
        stu.setAmount(88.86f);
        stu.setAge(18);
        stu.setHaveChild(true);
        stu.setBirthday(new Date());

        Spouse spouse = new Spouse();
        spouse.setUsername(&quot;Lucy&quot;);
        spouse.setAge(25);

        stu.setSpouse(spouse);
        stu.setArticleList(getArticles());
        stu.setParents(getParents());

        model.addAttribute(&quot;stu&quot;,stu);
        return model;
    &#125;

    private List&lt;Article&gt; getArticles()&#123;
        Article article1 = new Article();
        article1.setId(&quot;1001&quot;);
        article1.setTitle(&quot;今天天气不错&quot;);

        Article article2 = new Article();
        article2.setId(&quot;1002&quot;);
        article2.setTitle(&quot;今天下雨了&quot;);

        Article article3 = new Article();
        article3.setId(&quot;1003&quot;);
        article3.setTitle(&quot;昨天下雨了&quot;);

        List&lt;Article&gt; list = new ArrayList&lt;&gt;();
        list.add(article1);
        list.add(article2);
        list.add(article3);
        return list;
    &#125;

    private Map&lt;String, String&gt; getParents()&#123;
        Map&lt;String, String&gt; parents = new HashMap&lt;&gt;();
        parents.put(&quot;father&quot;, &quot;XiaoMing&quot;);
        parents.put(&quot;mother&quot;, &quot;LiLi&quot;);
        return parents;
    &#125;
&#125;
==================================================================
http://localhost:8001/free/hello

hello 慕课网 imooc.com

用户名uid: 10010
用户姓名: imooc
年龄：18
生日：2024-07-29 15:39:07
用户余额：88.86
已育：yes
伴侣：Lucy,25岁

1001 今天天气不错
1002 今天下雨了
1003 昨天下雨了

LiLi
XiaoMing
</code></pre>
<pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello Freemarker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;#-- 写完以后去模板页面配置 application.yml
    Freemarker 页面的语法构成：
    1. 注释
    2. 表达式 $&#123;...&#125;
    3. 普通文本，基本的html标签
    4. 指令
--&gt;
    &lt;div&gt;
        hello $&#123;there&#125;
    &lt;/div&gt;
&lt;br&gt;

    &lt;div&gt;
        用户名uid: $&#123;stu.uid&#125;&lt;br&gt;
        用户姓名: $&#123;stu.username&#125;&lt;br&gt;
        年龄：$&#123;stu.age&#125;&lt;br&gt;
        生日：$&#123;stu.birthday?string(&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&lt;br&gt; &lt;#-- 日期转换 --&gt;
        用户余额：$&#123;stu.amount&#125;&lt;br&gt;
        已育：$&#123;stu.haveChild?string(&#39;yes&#39;, &#39;no&#39;)&#125;&lt;br&gt;
        伴侣：$&#123;stu.spouse.username&#125;,$&#123;stu.spouse.age&#125;岁
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.articleList as article&gt;
            &lt;div&gt;
                &lt;span&gt;$&#123;article.id&#125;&lt;/span&gt;
                &lt;span&gt;$&#123;article.title&#125;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.parents?keys as key&gt;
            &lt;div&gt;
                $&#123;stu.parents[key]&#125;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令if【Freemarker语法】"><a href="#指令if【Freemarker语法】" class="headerlink" title="指令if【Freemarker语法】"></a>指令if【Freemarker语法】</h3><pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello Freemarker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;#-- 
    写完以后去模板页面配置 application.yml
    Freemarker 页面的语法构成：
    1. 注释
    2. 表达式 $&#123;...&#125;
    3. 普通文本，基本的html标签
    4. 指令
--&gt;
    &lt;div&gt;
        hello $&#123;there&#125;
    &lt;/div&gt;
&lt;br&gt;

    &lt;div&gt;
        用户名uid: $&#123;stu.uid&#125;&lt;br&gt;
        用户姓名: $&#123;stu.username&#125;&lt;br&gt;
        年龄：$&#123;stu.age&#125;&lt;br&gt;
        生日：$&#123;stu.birthday?string(&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&lt;br&gt; &lt;#-- 日期转换 --&gt;
        用户余额：$&#123;stu.amount&#125;&lt;br&gt;
        已育：$&#123;stu.haveChild?string(&#39;yes&#39;, &#39;no&#39;)&#125;&lt;br&gt;
        &lt;#if stu.spouse??&gt;
            伴侣：$&#123;stu.spouse.username&#125;, $&#123;stu.spouse.age&#125;岁
        &lt;/#if&gt;
        &lt;#if !stu.spouse??&gt;
            单身狗
        &lt;/#if&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.articleList as article&gt;
            &lt;div&gt;
                &lt;span&gt;$&#123;article.id&#125;&lt;/span&gt;
                &lt;span&gt;$&#123;article.title&#125;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.parents?keys as key&gt;
            &lt;div&gt;
                $&#123;stu.parents[key]&#125;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#if stu.uid == &#39;10010&#39;&gt;
            用户id是10010
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if stu.username != &#39;imooc&#39;&gt;
            用户名不是imooc
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if (stu.age &gt;= 18) &gt;
            用户已成年
        &lt;/#if&gt;
        &lt;br&gt;
        &lt;#if (stu.age &gt; 18 || stu.age = 18) &gt;
            成年人
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if (stu.age &lt; 18) &gt;
            未成年
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if stu.haveChild &gt;
            已育
        &lt;/#if&gt;
        &lt;br&gt;
        &lt;#if !stu.haveChild &gt;
             未育
        &lt;/#if&gt;
     &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span style = "color:red">在这里特别注意一下 已经开始第二阶段的代码 进阶篇 所以前端的代码也是需要更新换代的 包括..&#x2F;js&#x2F;app.js里面多了 app.getPageName();</span><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/questiondetail/4daeRX4JGBRPnWEp.html">没有getPageName这个函数-慕课网 (imooc.com)</a><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/questiondetail/224939.html">生成的html调用app.js中getPageName()函数出错的问题-慕课网 (imooc.com)</a></p>
<h3 id="结合动态数据生成静态化HTML【Freemarker】"><a href="#结合动态数据生成静态化HTML【Freemarker】" class="headerlink" title="结合动态数据生成静态化HTML【Freemarker】"></a>结合动态数据生成静态化HTML【Freemarker】</h3><pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
【stu.ftl如上图不变增加java的整合代码】 俗称Java+ftl=HTML
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.Article;
import com.imooc.pojo.Spouse;
import com.imooc.pojo.Stu;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.*;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;

    @Value(&quot;$&#123;freemarker.html.target&#125;&quot;)
    private String htmlTarget;

    @GetMapping(&quot;/createHTML&quot;)
    @ResponseBody
    public String createHTML(Model model) throws IOException, TemplateException &#123;
        // 0. 配置freemarker基本环境
        Configuration cfg = new Configuration(Configuration.getVersion());
        // 声明freemarker模板所需要加载的目录的位置
            //resources/templates/stu.ftl
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File((classpath + &quot;templates&quot;)));

            // 测试打印
        System.out.println(htmlTarget);
        System.out.println(classpath + &quot;templates&quot;);
        /**
         * /workspace/freemarker_html
         * /C:/Users/Pluminary/Desktop/backup/imooc-news-dev/imooc-news-dev-service-article/target/classes/templates
         */
        // 1. 获得现有的模板ftl文件
        Template template = cfg.getTemplate(&quot;stu.ftl&quot;, &quot;utf-8&quot;);

        // 2. 获得动态数据
            // 定义输出到模板的内容
            // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);
        model = makeModel(model);

        // 3. 融合动态数据和ftl，生成html
        File tempDic = new File(htmlTarget);
        if (!tempDic.exists()) &#123;
            tempDic.mkdirs();
        &#125;
        Writer out = new FileWriter(htmlTarget + File.separator + &quot;10010&quot; + &quot;.html&quot;);
        template.process(model, out);
        out.close();
        return &quot;ok&quot;;
        // C:\workspace\freemarker_html\10010.html 里面的数据都是静态数据
    &#125;

    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        makeModel(model);
        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;

    private Model makeModel(Model model) &#123;
        Stu stu = new Stu();
        stu.setUid(&quot;10010&quot;);
        stu.setUsername(&quot;imooc&quot;);
        stu.setAmount(88.86f);
        stu.setAge(18);
        stu.setHaveChild(true);
        stu.setBirthday(new Date());

        Spouse spouse = new Spouse();
        spouse.setUsername(&quot;Lucy&quot;);
        spouse.setAge(25);

        stu.setSpouse(spouse);
        stu.setArticleList(getArticles());
        stu.setParents(getParents());

        model.addAttribute(&quot;stu&quot;,stu);
        return model;
    &#125;

    private List&lt;Article&gt; getArticles()&#123;
        Article article1 = new Article();
        article1.setId(&quot;1001&quot;);
        article1.setTitle(&quot;今天天气不错&quot;);

        Article article2 = new Article();
        article2.setId(&quot;1002&quot;);
        article2.setTitle(&quot;今天下雨了&quot;);

        Article article3 = new Article();
        article3.setId(&quot;1003&quot;);
        article3.setTitle(&quot;昨天下雨了&quot;);

        List&lt;Article&gt; list = new ArrayList&lt;&gt;();
        list.add(article1);
        list.add(article2);
        list.add(article3);
        return list;
    &#125;

    private Map&lt;String, String&gt; getParents()&#123;
        Map&lt;String, String&gt; parents = new HashMap&lt;&gt;();
        parents.put(&quot;father&quot;, &quot;XiaoMing&quot;);
        parents.put(&quot;mother&quot;, &quot;LiLi&quot;);
        return parents;
    &#125;
&#125;
</code></pre>
<h3 id="改写详情页为模板页ftl【页面静态化】"><a href="#改写详情页为模板页ftl【页面静态化】" class="headerlink" title="改写详情页为模板页ftl【页面静态化】"></a>改写详情页为模板页ftl【页面静态化】</h3><blockquote>
<p>地址页不是拼接   将detail.html 的路径都变成绝对路径</p>
<!--<link rel="shortcut icon" href="img/mu-toutiao.ico" />-->
<pre><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;../img/mu-toutiao.ico&quot; /&gt;
</code></pre>
<p>把其拷贝到 resources&#x2F;templates&#x2F;detail.ftl</p>
</blockquote>
<pre><code class="html">【放在d盘 tomcat/webapps中的】detail.ftl
&lt;div class=&quot;big-title&quot;&gt;
     $&#123;articleDetail.title&#125;
&lt;/div&gt;
    &lt;div class=&quot;read-counts&quot; v-show=&quot;articleDetail.readCounts != &#39;&#39; &amp;&amp; articleDetail.readCounts != null&quot;&gt;
     阅读量：$&#123;articleDetail.readCounts&#125;
    &lt;/div&gt;
......
&lt;div class=&quot;date-title&quot;&gt;
       &lt;span class=&quot;year&quot;&gt;$&#123;articleDetail.publishTime?string(&#39;yyyy&#39;)&#125;&lt;/span&gt;
 &lt;/div&gt;
      &lt;div class=&quot;back-year-line&quot;&gt;&lt;/div&gt;

      &lt;div class=&quot;date-md&quot;&gt;$&#123;articleDetail.publishTime?string(&#39;MM/dd&#39;)&#125;&lt;/div&gt;

      &lt;div class=&quot;date-times&quot;&gt;$&#123;articleDetail.publishTime?string(&#39;HH:mm:ss&#39;)&#125;&lt;/div&gt;

      &lt;div class=&quot;writer-name&quot; @click=&quot;showWriter(&#39;$&#123;articleDetail.publishUserId&#125;&#39;)&quot;&gt;
                        $&#123;articleDetail.publishUserName&#125;
                    &lt;/div&gt;
.....
&lt;div class=&quot;article-wrapper&quot;&gt;
   &lt;div class=&quot;content&quot;&gt;
        $&#123;articleDetail.content&#125;
   &lt;/div&gt;
&lt;div class=&quot;declare&quot;&gt;
      免责声明：本平台所有内容仅供测试，且文章来自互联网，不代表慕课网的观点和立场，如有不妥，请联系后删除。
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="文章详情ftl生成静态化页面【页面静态化】"><a href="#文章详情ftl生成静态化页面【页面静态化】" class="headerlink" title="文章详情ftl生成静态化页面【页面静态化】"></a>文章详情ftl生成静态化页面【页面静态化】</h3><pre><code class="yaml">freemarker:
  html:
    target: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
    article: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/ArticleDetailVO.java
public class ArticleDetailVO &#123;

    private String id;
    private String title;
    private String cover;
    private Integer categoryId;
    private String categoryName;
    private String publishUserId;
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date publishTime;
    private String content;

    private String publishUserName;
    private Integer readCounts;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
 @Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);
        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
                 createArticleHTML(articleId);
//                String articleMongoId = createArticleHTMLToGridF(articleId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;

    @Value(&quot;$&#123;freemarker.html.target&#125;&quot;)
    private String articlePath;
    @Autowired
    private RestTemplate restTemplate;
    // 文章生成HTML
    public void createArticleHTML(String articleId) throws IOException, TemplateException &#123;
        Configuration cfg = new Configuration(Configuration.getVersion());
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File(classpath + &quot;templates&quot;));

        Template template = cfg.getTemplate(&quot;detail.ftl&quot;, &quot;utf-8&quot;);

        // 获得文章的详情数据
        ArticleDetailVO detailVO = getArticleDetail(articleId);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleDetail&quot;, detailVO);

        File tempDic = new File(articlePath);
        if (!tempDic.exists()) &#123;
            tempDic.mkdirs();
        &#125;

        String path = articlePath + File.separator + detailVO.getId() + &quot;.html&quot;;

        Writer out = new FileWriter(path);
        template.process(map, out);
        out.close();
    &#125;
    // 发起远程调用rest，获得文章详情数据
    public ArticleDetailVO getArticleDetail(String articleId) &#123;
        String url
                = &quot;http://www.imoocnews.com:8001/portal/article/detail?articleId=&quot; + articleId;
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(url, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        ArticleDetailVO detailVO = null;
        if (bodyResult.getStatus() == 200) &#123;
            String detailJson = JsonUtils.objectToJson(bodyResult.getData());
            detailVO = JsonUtils.jsonToPojo(detailJson, ArticleDetailVO.class);
        &#125;
        return detailVO;
    &#125;
</code></pre>
<pre><code class="java">先去发表头条http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html
再去审核通过http://www.imoocnews.com:9090/imooc-news/admin/contentReview.html
此时运行后 就会有java+ftl=html静态页面在指定位置生成了
指定位置：D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\a
生成了一个文件：240729D9S8683XP0.html  这里面就是刚刚发表头条的内容
此时下面的两个网站都可以打开同样的头条内容
http://www.imoocnews.com:9090/imooc-news/portal/a/240729D9S8683XP0.html
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=240729D9S8683XP0

240729D9S8683XP0.html
&lt;div class=&quot;writer-name&quot; @click=&quot;showWriter(&#39;240629F21AK1BHX4&#39;)&quot;&gt;
      P_luminary
&lt;/div&gt;

// 跳转作家页面
showWriter(writerId) &#123;
    window.open(&quot;../writer.html?writerId=&quot; + writerId);
&#125;,
</code></pre>
<p><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/questiondetail/4daeRX4JGBRPnWEp.html">没有getPageName这个函数-慕课网 (imooc.com)</a></p>
<h3 id="文章阅读量detail单独获取并展示-【页面静态化】"><a href="#文章阅读量detail单独获取并展示-【页面静态化】" class="headerlink" title="文章阅读量detail单独获取并展示 【页面静态化】"></a>文章阅读量<del>detail</del>单独获取并展示 【页面静态化】</h3><p><a target="_blank" rel="noopener" href="http://www.imoocnews.com:9090/imooc-news/portal/a/240730FGXGSCRZ54.html">a5 (imoocnews.com)</a></p>
<pre><code class="java">【去前面代入阅读量】
 &lt;div class=&quot;read-counts&quot;&gt;
            阅读量：&#123;&#123;readCounts&#125;&#125;
        &lt;/div&gt;
【先定义readCounts初始量为0】
var articleList = new Vue(&#123;
        el: &quot;#detailContainer&quot;,
        data: &#123;
            nowReplyingFatherCommentId: 0,  // 根据当前用户正在回复的父commentId进行页面的留言看展示或隐藏
            userInfo: null,
            
            articleId: &quot;&quot;,
            articleDetail: &#123;&#125;,
            readCounts: 0,
        &#125;

// 获得文章阅读数
         this.getArticleReadCounts(articleId);

 // 获得文章阅读数
        getArticleReadCounts(articleId) &#123;
               var me = this;

               var articleServerUrl = app.articleServerUrl;
               axios.defaults.withCredentials = true;
               axios.get(articleServerUrl + &quot;/portal/article/readCounts?articleId=&quot; + articleId)
                .then(res =&gt; &#123;
                  // console.log(JSON.stringify(res.data));
                  this.readCounts = res.data;
                &#125;);
            &#125;,
//★★★★★★★★★★★★★★★★★★★★     ★★★★★★★★★★★★★★★★★★★★★★★\\
然后把这个临时页面修改的地方 移动到后端service-article  resources/templates/detail.ftl中
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public Integer readCounts(String articleId) &#123;
       return getCountsFromRedis(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@GetMapping(&quot;readCounts&quot;)
    @ApiOperation(value = &quot;获得文章阅读数&quot;, notes = &quot;获得文章阅读数&quot;, httpMethod = &quot;GET&quot;)
    public Integer readCounts(@RequestParam String articleId);
</code></pre>
<p><a target="_blank" rel="noopener" href="http://www.imoocnews.com:9090/imooc-news/portal/a/240730FP00HHCF14.html">在这里折腾一天终于好了 文章:a6 (imoocnews.com)</a></p>
<p>9-10</p>
<h3 id="梳理生产端消费端与中间gridfs关系"><a href="#梳理生产端消费端与中间gridfs关系" class="headerlink" title="梳理生产端消费端与中间gridfs关系"></a>梳理生产端消费端与中间gridfs关系</h3><h5 id="静态化高度耦合"><a href="#静态化高度耦合" class="headerlink" title="静态化高度耦合"></a>静态化高度耦合</h5><blockquote>
<p>在本地电脑&#x2F;同一台服务器     &#x3D;&gt;     生成静态页面HTML →<del>(发布)</del> 前端</p>
</blockquote>
<h5 id="解耦静态化"><a href="#解耦静态化" class="headerlink" title="解耦静态化"></a>解耦静态化</h5><blockquote>
<p>后端服务器(生成静态页面HTML)  &#x3D;&gt;  GridFS  &lt;&#x3D;  前端服务器(前端HTML)<br>同时  后端服务器(生成静态页面HTML)  →  前端服务器(前端HTML)</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e63aeac9b0694f2fced26f0349e630e42e51ae54/data/%E9%9D%99%E6%80%81%E5%8C%96%E9%AB%98%E5%BA%A6%E8%80%A6%E5%90%88%E4%B8%8E%E8%A7%A3%E8%80%A6.png"></p>
<pre><code class="java">创建一个新的module =&gt; imooc-news-dev-service-article-html
把service-article中resources的application.yml /dev+prod.yml logback-spring.xml拷贝到article-html模块的resources中

############################################################
http://localhost:8002/hello
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: null
&#125;
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# article文章静态化服务
# web访问端口号  约定：8002
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-article-html
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8

  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
  freemarker:
    charset: UTF-8
    content-type: text/html
    suffix: .ftl
    template-loader-path: classpath:/templates/

# 定义freemarker生成的HTML
freemarker:
  html:
    target: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
    article: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
</code></pre>
<pre><code class="yaml">application-dev.yml
server:
  port: 8002

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379

## setup CN from java, This is resource
website:
  domain-name: imoocnews.com




application-prod.yml
server:
  port: 8002

spring:
  redis:
    database: 0
    host: 47.98.225.105
    port: 6379
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/Application.java
package com.imooc.article.html;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/controller/HelloController.java
package com.imooc.article.html.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<h3 id="生产端存储html道gridfs并关联文章表【静态化解耦】"><a href="#生产端存储html道gridfs并关联文章表【静态化解耦】" class="headerlink" title="生产端存储html道gridfs并关联文章表【静态化解耦】"></a>生产端存储html道gridfs并关联文章表【静态化解耦】</h3><h5 id="静态化解耦步骤"><a href="#静态化解耦步骤" class="headerlink" title="静态化解耦步骤"></a>静态化解耦步骤</h5><ul>
<li><strong>生成html，并上传到gridfs中</strong></li>
<li><strong>获得mongoFileId，关联保存到文章表中</strong></li>
<li><strong>调用消费端，下载gridfs的html进行发布</strong></li>
</ul>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
 /**
     * 关联文章和gridfs的html文件id
     */
    public void updateArticleToGridFS(String articleId, String articleMongoId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
 @Transactional
    @Override
    public void updateArticleToGridFS(String articleId, String articleMongoId) &#123;
        Article pendingArticle = new Article();
        pendingArticle.setId(articleId);
        pendingArticle.setMongoFileId(articleMongoId);
        articleMapper.updateByPrimaryKeySelective(pendingArticle);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);

        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
//                 createArticleHTML(articleId);
                String articleMongoId = createArticleHTMLToGridFS(articleId);
                // 存储到对应的文章 进行关联保存
                articleService.updateArticleToGridFS(articleId, articleMongoId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
......
...
    @Value(&quot;$&#123;freemarker.html.target&#125;&quot;)
    private String articlePath;
    @Autowired
    private RestTemplate restTemplate;
    // 文章生成HTML
    public void createArticleHTML(String articleId) throws IOException, TemplateException &#123;
        Configuration cfg = new Configuration(Configuration.getVersion());
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File(classpath + &quot;templates&quot;));

        Template template = cfg.getTemplate(&quot;detail.ftl&quot;, &quot;utf-8&quot;);

        // 获得文章的详情数据
        ArticleDetailVO detailVO = getArticleDetail(articleId);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleDetail&quot;, detailVO);

        File tempDic = new File(articlePath);
        if (!tempDic.exists()) &#123;
            tempDic.mkdirs();
        &#125;

        String path = articlePath + File.separator + detailVO.getId() + &quot;.html&quot;;

        Writer out = new FileWriter(path);
        template.process(map, out);
        out.close();
    &#125;

    @Autowired
    private GridFSBucket gridFSBucket;
    public String createArticleHTMLToGridFS(String articleId) throws IOException, TemplateException &#123;
        Configuration cfg = new Configuration(Configuration.getVersion());
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File(classpath + &quot;templates&quot;));

        Template template = cfg.getTemplate(&quot;detail.ftl&quot;, &quot;utf-8&quot;);

        // 获得文章的详情数据
        ArticleDetailVO detailVO = getArticleDetail(articleId);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleDetail&quot;, detailVO);

        String htmlContent = FreeMarkerTemplateUtils.processTemplateIntoString(template, map);
//        System.out.println(htmlContent);

        InputStream inputStream = IOUtils.toInputStream(htmlContent);
        ObjectId fileId = gridFSBucket.uploadFromStream(detailVO.getId() + &quot;.html&quot;,inputStream);
        return fileId.toString();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/GridFSConfig.java
package com.imooc.article;

import com.mongodb.MongoClient;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.client.gridfs.GridFSBuckets;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

@Component //可以被容器访问到
public class GridFSConfig &#123;
    @Value(&quot;$&#123;spring.data.mongodb.database&#125;&quot;)
    private String mongodb;

    @Bean
    public GridFSBucket gridFSBucket(MongoClient mongoClient)&#123;
        MongoDatabase mongoDatabase = mongoClient.getDatabase(mongodb);
        GridFSBucket bucket = GridFSBuckets.create(mongoDatabase);//存入mongodatabase
        return bucket;
    &#125;
&#125;
</code></pre>
<h3 id="消费端从gridfs下载HTML到tomcat【静态化解耦】"><a href="#消费端从gridfs下载HTML到tomcat【静态化解耦】" class="headerlink" title="消费端从gridfs下载HTML到tomcat【静态化解耦】"></a>消费端从gridfs下载HTML到tomcat【静态化解耦】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticleHTMLControllerApi.java
package com.imooc.api.controller.article;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewArticleBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.Date;

@Api(value = &quot;静态化文章业务的controller&quot;, tags = &#123;&quot;静态化文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article/html&quot;)
public interface ArticleHTMLControllerApi &#123;

    @GetMapping(&quot;download&quot;)
    @ApiOperation(value = &quot;下载html&quot;, notes = &quot;下载html&quot;, httpMethod = &quot;GET&quot;)
    public Integer download(String articleId, String articleMongoId) throws Exception;
&#125;
</code></pre>
<pre><code class="java">article-html  com/imooc/article/html/controller/ArticleHTMLController.java
package com.imooc.article.html.controller;

import com.imooc.api.controller.article.ArticleHTMLControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.gridfs.GridFS;
import org.bson.types.ObjectId;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.RestController;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;

@RestController
public class ArticleHTMLController implements ArticleHTMLControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticleHTMLController.class);

    @Autowired //相应的下载
    private GridFSBucket gridFSBucket;

    @Value(&quot;$&#123;freemarker.html.article&#125;&quot;)
    private String articlePath;

    @Override
    public Integer download(String articleId, String articleMongoId)
            throws Exception &#123;

        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;

        // 获取文件流，定义存放的位置和名称
        File file = new File(path);
        // 创建输出流
        OutputStream outputStream = new FileOutputStream(file);
        // 执行下载
        gridFSBucket.downloadToStream(new ObjectId(articleMongoId), outputStream);

        return HttpStatus.OK.value();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);

        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
//                 createArticleHTML(articleId);
                String articleMongoId = createArticleHTMLToGridFS(articleId);
                // 存储到对应的文章 进行关联保存
                articleService.updateArticleToGridFS(articleId, articleMongoId);
                // 调用消费端，执行下载html
                doDownloadArticleHTML(articleId,articleMongoId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
    private void doDownloadArticleHTML(String articleId, String articleMongoId) &#123;
        String url = //去SwitchHost弄个新的端口映射
                &quot;http://html.imoocnews.com:8002/article/html/download?articleId=&quot;
                        + articleId +
                        &quot;&amp;articleMongoId=&quot;
                        + articleMongoId;
        ResponseEntity&lt;Integer&gt; responseEntity = restTemplate.getForEntity(url, Integer.class);
        int status = responseEntity.getBody();
        if (status != HttpStatus.OK.value()) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
      /**
     * 关联文章和gridfs的html文件id
     */
    public void updateArticleToGridFS(String articleId, String articleMongoId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
    @Transactional
    @Override
    public void updateArticleToGridFS(String articleId, String articleMongoId) &#123;
        Article pendingArticle = new Article();
        pendingArticle.setId(articleId);
        pendingArticle.setMongoFileId(articleMongoId);
        articleMapper.updateByPrimaryKeySelective(pendingArticle);
    &#125;
</code></pre>
<pre><code class="mysql">【SwitchHosts】
# imooc-news 192.168.1.3
127.0.0.1 www.imoocnews.com
127.0.0.1 writer.imoocnews.com
127.0.0.1 admin.imoocnews.com
```
127.0.0.1 article.imoocnews.com
127.0.0.1 user.imoocnews.com
127.0.0.1 files.imoocnews.com
127.0.0.1 html.imoocnews.com

发布文章后审核文章
此时会发现数据库MongoDB里面的GridFS存储桶有新建的html 包括在 前端也存在此文件
D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\a\240731CN3X1M56Y8.html
</code></pre>
<h3 id="撤回删除文章，删除gridfs文件以及html【静态化解耦】"><a href="#撤回删除文章，删除gridfs文件以及html【静态化解耦】" class="headerlink" title="撤回删除文章，删除gridfs文件以及html【静态化解耦】"></a>撤回删除文章，删除gridfs文件以及html【静态化解耦】</h3><blockquote>
<p>拿到mongodb_id  去删除 在service-html 写个删除接口 拼接删除方法</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleHTMLControllerApi.java
@Api(value = &quot;静态化文章业务的controller&quot;, tags = &#123;&quot;静态化文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article/html&quot;)
public interface ArticleHTMLControllerApi &#123;
@GetMapping(&quot;delete&quot;)
    @ApiOperation(value = &quot;删除html&quot;, notes = &quot;删除html&quot;, httpMethod = &quot;GET&quot;)
    public Integer delete(String articleId) throws Exception;
&#125;
</code></pre>
<pre><code class="java">article-html  com/imooc/article/html/controller/ArticleHTMLController.java
@Override
    public Integer delete(String articleId) throws Exception &#123;
        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;
        // 获取文件流，定义存放的位置和名称
        File file = new File(path);
        // 删除文件
        file.delete();
        return HttpStatus.OK.value();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
 @Override
    public GraceJSONResult delete(String userId, String articleId) &#123;
        articleService.deleteArticle(userId,articleId);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult withdraw(String userId, String articleId) &#123;
        articleService.withdrawArticle(userId, articleId);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
@Transactional
    @Override
    public void deleteArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setIsDelete(YesOrNo.YES.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_DELETE_ERROR);
        &#125;
        deleteHTML(articleId);
    &#125;

    @Transactional
    @Override
    public void withdrawArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setArticleStatus(ArticleReviewStatus.WITHDRAW.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_WITHDRAW_ERROR);
        &#125;
        deleteHTML(articleId);
    &#125;
...
...

    @Autowired
    private GridFSBucket gridFSBucket;
    /**
     * 文章撤回删除后，删除静态化的html
     */

    public void deleteHTML(String articleId) &#123;
        // 1. 查询文章的mongoFileId
        Article pending = articleMapper.selectByPrimaryKey(articleId);
        String articleMongoId = pending.getMongoFileId();

        // 2. 删除GridFS上的文件
        gridFSBucket.delete(new ObjectId(articleMongoId));

        // 3. 删除消费端的HTML文件
        doDeleteArticleHTML(articleId);
//        doDeleteArticleHTMLByMQ(articleId);
    &#125;

    @Autowired
    public RestTemplate restTemplate;
    private void doDeleteArticleHTML(String articleId) &#123;
        String url = &quot;http://html.imoocnews.com:8002/article/html/delete?articleId=&quot; + articleId;
        ResponseEntity&lt;Integer&gt; responseEntity = restTemplate.getForEntity(url, Integer.class);
        int status = responseEntity.getBody();
        if (status != HttpStatus.OK.value()) &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125;
    &#125;
</code></pre>
<h3 id="接口解耦需求【章节概述】"><a href="#接口解耦需求【章节概述】" class="headerlink" title="接口解耦需求【章节概述】"></a>接口解耦需求【章节概述】</h3><ul>
<li><strong>介绍RabbitMQ</strong></li>
<li><strong>RabbitMQ术语</strong></li>
<li><strong>安装与配置消息队列</strong></li>
<li><strong>实现接口调用解耦</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d5205be20fc0bac1de7cadbc9b34f6ff949df3d1/data/Rabbitmq.png"></p>
<h3 id="RabbitMQ概述-MQ模型"><a href="#RabbitMQ概述-MQ模型" class="headerlink" title="RabbitMQ概述_MQ模型"></a>RabbitMQ概述_MQ模型</h3><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><ul>
<li><strong>RabbitMQ</strong></li>
<li><strong>ActiveMQ</strong></li>
<li><strong>RocketMQ</strong></li>
<li><strong>Kafka</strong></li>
</ul>
<h5 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul>
<li><strong>erlang语言开发</strong></li>
<li><strong>AMQP</strong></li>
<li><strong>应用之间通信</strong></li>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></li>
</ul>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li><strong>异步任务</strong></li>
<li><strong>提速</strong></li>
<li><strong>接口解耦</strong></li>
<li><strong>削峰</strong></li>
</ul>
<h5 id="RabbitMQ模型"><a href="#RabbitMQ模型" class="headerlink" title="RabbitMQ模型"></a>RabbitMQ模型</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/d83d056479d71444c598865698d340e2ba01da96/data/RabbitMQ%E6%A8%A1%E5%9E%8B.png"></p>
<h3 id="RabbitMQ-3-8-5-安装与配置详细在”多线程与分布式-md“中有"><a href="#RabbitMQ-3-8-5-安装与配置详细在”多线程与分布式-md“中有" class="headerlink" title="RabbitMQ-3.8.5 安装与配置详细在”多线程与分布式.md“中有"></a>RabbitMQ-3.8.5 安装与配置<del>详细在”多线程与分布式.md“中有</del></h3><blockquote>
<p>E:\Java实例项目1-20套\第04套【项目实战】Spring Cloud分布式微服务实战，打造大型自媒体3大业务平台 分布式前后端分离项目分层聚合 养成应对复杂业务的综合技术能力\imooc-news\rabbitmq-server-3.8.5</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://packagecloud.io/rabbitmq/erlang/install#bash-rpm">rabbitmq&#x2F;erlang - Installation · packagecloud- Bash Scripts</a></p>
<pre><code class="mysql">[imooc@imooc ~]$ curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash
[imooc@imooc ~]$ sudo yum install erlang
[imooc@imooc ~]$ erl
Erlang/OTP 23 [erts-11.2.2.10] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:1] [hipe]

Eshell V11.2.2.10  (abort with ^G)
1&gt; 
[imooc@imooc ~]$ yum list | grep erlang
erlang.x86_64                               23.3.4.11-1.el7            @rabbitmq_erlang
erlang-debuginfo.x86_64                     23.3.4.11-1.el7            rabbitmq_erlang
[imooc@imooc ~]$ sudo rpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey
[imooc@imooc ~]$ sudo rpm --import https://packagecloud.io/gpg.key

将资源包里的文件拷贝过来 rabbitmq.conf 和 rabbitmq-server.rpm
#[先把两个依赖搞好 =&gt; 一个是key 一个是依赖]
[imooc@imooc ~]$ sudo rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
[imooc@imooc ~]$ sudo yum install socat
[imooc@imooc ~]$ sudo rpm -ivh rabbitmq-server-3.8.5-1.el7.noarch.rpm
[imooc@imooc ~]$ sudo vim rabbitmq.conf
#&#123;loopback_users, []&#125; 加上注释#
[imooc@imooc ~]$ cd /etc/rabbitmq/
#把conf移动到etc中
[imooc@imooc rabbitmq]$ sudo cp /home/imooc/rabbitmq.conf .
#重新启动rabbitmq
[imooc@imooc rabbitmq]$ sudo systemctl restart rabbitmq-server
#查看状态
[imooc@imooc rabbitmq]$ sudo systemctl status rabbitmq-server

● rabbitmq-server.service - RabbitMQ broker
   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)
   Active: active (running) since 四 2024-08-01 15:45:54 CST; 13s ago
 Main PID: 5843 (beam.smp)
   Status: &quot;Initialized&quot;
    Tasks: 86
   CGroup: /system.slice/rabbitmq-server.service
           ├─5843 /usr/lib64/erlang/erts-11.2.2.10/bin/beam.smp -W w -K true -A 64 -M...
           ├─5952 erl_child_setup 32768
           ├─6008 inet_gethost 4
           └─6009 inet_gethost 4
           
[imooc@imooc rabbitmq]$ sudo rabbitmq-plugins enable rabbitmq_management
[imooc@imooc rabbitmq]$ ll
总用量 40
-rw-r--r--. 1 root rabbitmq    23 8月   1 15:46 enabled_plugins
-rw-r--r--. 1 root rabbitmq 33325 8月   1 15:35 rabbitmq.conf

http://192.168.170.135:15672/
username: guest
password: guest
[imooc@imooc ~]$ sudo vim rabbitmq.conf #把这个取消注释
loopback_users.guest = false

http://192.168.170.135:15672/#/  #创建虚拟host节点
→ admin → Add a user
</code></pre>
<h3 id="引入依赖和配置【集成Rabbitmq】"><a href="#引入依赖和配置【集成Rabbitmq】" class="headerlink" title="引入依赖和配置【集成Rabbitmq】"></a>引入依赖和配置【集成Rabbitmq】</h3><pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<blockquote>
<p>模块 Module<br>imooc-news-dev-service-article 是生产者[发送消息]<br>→<br>imooc-news-dev-service-article-html 是消费者[处理消息]</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://192.168.170.135:15672/#/vhosts">RabbitMQ Management</a> 在Virtual Hosts → Add a new virtual host → Name: imooc-news-dev<br>退出再重新登陆一下rabbitmq → 账号密码：admin</p>
<pre><code class="yaml">service-article  application.yml
  rabbitmq:
    host: 192.168.170.135
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev
</code></pre>
<pre><code class="yaml">service-article-html  application.yml
  rabbitmq:
    host: 192.168.170.135
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev
</code></pre>
<h3 id="创建交换机和队列【集成Rabbitmq】"><a href="#创建交换机和队列【集成Rabbitmq】" class="headerlink" title="创建交换机和队列【集成Rabbitmq】"></a>创建交换机和队列【集成Rabbitmq】</h3><pre><code class="java">service-api  com/imooc/api/config/RabbitMQConfig.java
package com.imooc.api.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * RabbitMQ 的配置类
 */
@Configuration
public class RabbitMQConfig &#123;

    // 定义交换机的名字
    public static final String EXCHANGE_ARTICLE = &quot;exchange_article&quot;;

    // 定义队列的名字
    public static final String QUEUE_DOWNLOAD_HTML = &quot;queue_download_html&quot;;

    // 创建交换机
    @Bean(EXCHANGE_ARTICLE)
    public Exchange exchange()&#123;
        return ExchangeBuilder
                .topicExchange(EXCHANGE_ARTICLE)
                .durable(true)
                .build();
    &#125;

    // 创建队列
    @Bean(QUEUE_DOWNLOAD_HTML)
    public Queue queue()&#123;
        return new Queue(QUEUE_DOWNLOAD_HTML);
    &#125;

    // 队列绑定交换机
    @Bean
    public Binding binding(
            @Qualifier(QUEUE_DOWNLOAD_HTML) Queue queue,
            @Qualifier(EXCHANGE_ARTICLE) Exchange exchange)&#123;
        return BindingBuilder
                .bind(queue)
                .to(exchange)
                //.with(&quot;article.*&quot;) &quot;article.hello&quot;,  //类似于API的规则
                .with(&quot;article.#.do&quot;)
                .noargs();      // 执行绑定
    &#125;
&#125;
</code></pre>
<h3 id="创建生产者-配置路由规则【集成RabbitMQ】"><a href="#创建生产者-配置路由规则【集成RabbitMQ】" class="headerlink" title="创建生产者_配置路由规则【集成RabbitMQ】"></a>创建生产者_配置路由规则【集成RabbitMQ】</h3><p><a target="_blank" rel="noopener" href="http://localhost:8001/producer/hello">localhost:8001&#x2F;producer&#x2F;hello</a></p>
<blockquote>
<p>{<br>“status”: 200,<br>“msg”: “操作成功！”,<br>“success”: true,<br>“data”: null<br>}</p>
</blockquote>
<pre><code class="java">//如果队列规则改变 就需要把Exchanges里的RoutingKey解绑[Unbind] 否则还是会有以前的规则收到消息
//http://192.168.170.135:15672/#/exchanges/imooc-news-dev/exchange_article 
package com.imooc.article.controller;

import com.imooc.api.config.RabbitMQConfig;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController&#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
    /**
     * RabbitMQ的路由规则 routing key
     * display.*.*  →  * 代表一个占位符
     * .with(&quot;article.#.do&quot;)  //类似于API的规则
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done 不匹配
     *
     * display.# → # 代表任意多个占位符
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done.over 匹配
     */

        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.publish.download.do&quot;, //要绑定规则
                &quot;1001~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.success.do&quot;, //要绑定规则
                &quot;1002~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.play&quot;, //要绑定规则
                &quot;1003~&quot;);
        return GraceJSONResult.ok();
    &#125;
&#125;
http://localhost:8001/producer/hello
</code></pre>
<h3 id="消费者接受消息处理业务【集成RabbitMQ】"><a href="#消费者接受消息处理业务【集成RabbitMQ】" class="headerlink" title="消费者接受消息处理业务【集成RabbitMQ】"></a>消费者接受消息处理业务【集成RabbitMQ】</h3><p><a target="_blank" rel="noopener" href="http://192.168.170.135:15672/#/queues/imooc-news-dev/queue_download_html">RabbitMQ Management</a></p>
<blockquote>
<p>如果消息被消费掉后那么就 需要重新请求消息队列生成</p>
</blockquote>
<pre><code class="java">service-article-html  com/imooc/article/html/RabbitMQConsumer.java
package com.imooc.article.html;

import com.imooc.api.config.RabbitMQConfig;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
//打断点后 只要队列有消息 消费者监听到就会被消费
@Component
public class RabbitMQConsumer &#123;
    @RabbitListener(queues = &#123;RabbitMQConfig.QUEUE_DOWNLOAD_HTML&#125;)//监听哪个队列
    public void watchQueue(String payload, Message message)&#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        if (routingKey.equalsIgnoreCase(&quot;article.publish.download.do&quot;)) &#123;
            System.out.println(&quot;article.publish.download.do&quot;);
        &#125; else if (routingKey.equalsIgnoreCase(&quot;article.success.do&quot;)) &#123;
            System.out.println(&quot;article.success.do&quot;);
        &#125; else &#123;
            System.out.println(&quot;不符合的规则：&quot; + routingKey);
        &#125;
    &#125;
&#125;
==================================================================
// 如果消息被消费掉后那么就 需要重新请求消息队列生成
// 此时需要刷新 http://localhost:8001/producer/hello 重新提交一下消息就可以了
Console：
1001~
article.publish.download.do
1002~
article.success.do
1003~
不符合的规则：article.play
</code></pre>
<h3 id="文章静态化HTML与删除【异步解耦】"><a href="#文章静态化HTML与删除【异步解耦】" class="headerlink" title="文章静态化HTML与删除【异步解耦】"></a>文章静态化HTML与删除【异步解耦】</h3><pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
 @Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);

        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
//                 createArticleHTML(articleId);
                String articleMongoId = createArticleHTMLToGridFS(articleId);
                // 存储到对应的文章 进行关联保存
                articleService.updateArticleToGridFS(articleId, articleMongoId);
                // 调用消费端，执行下载html
//                doDownloadArticleHTML(articleId,articleMongoId);
            ★★  // 发送消息到mq队列，让消费者监听并且下载html  ★★
                doDownloadArticleHTMLByMQ(articleId,articleMongoId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
@Autowired
    private RabbitTemplate rabbitTemplate;
    private void doDownloadArticleHTMLByMQ(String articleId, String articleMongoId) &#123;

        rabbitTemplate.convertAndSend(
                RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.download.do&quot;,
                articleId + &quot;,&quot; + articleMongoId);
    &#125;
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/controller/ArticleHTMLComponent.java
package com.imooc.article.html.controller;

import com.mongodb.client.gridfs.GridFSBucket;
import org.bson.types.ObjectId;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;

@Component
public class ArticleHTMLComponent &#123;

    @Autowired
    private GridFSBucket gridFSBucket;

    @Value(&quot;$&#123;freemarker.html.article&#125;&quot;)
    private String articlePath;

    public Integer download(String articleId, String articleMongoId)
            throws Exception &#123;

        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;

        // 获取文件流，定义存放的位置和名称
        File file = new File(path);
        // 创建输出流
        OutputStream outputStream = new FileOutputStream(file);
        // 执行下载
        gridFSBucket.downloadToStream(new ObjectId(articleMongoId), outputStream);

        return HttpStatus.OK.value();
    &#125;

    public Integer delete(String articleId) throws Exception &#123;

        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;

        // 获取文件流，定义存放的位置和名称
        File file = new File(path);

        // 删除文件
        file.delete();

        return HttpStatus.OK.value();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/RabbitMQConsumer.java
package com.imooc.article.html;

import com.imooc.api.config.RabbitMQConfig;
import com.imooc.article.html.controller.ArticleHTMLComponent;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
//打断点后 只要队列有消息 消费者监听到就会被消费
@Component
public class RabbitMQConsumer &#123;
    @Autowired
    private ArticleHTMLComponent articleHTMLComponent;

    @RabbitListener(queues = &#123;RabbitMQConfig.QUEUE_DOWNLOAD_HTML&#125;)//监听哪个队列
    public void watchQueue(String payload, Message message)&#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        if (routingKey.equalsIgnoreCase(&quot;article.publish.download.do&quot;)) &#123;
            System.out.println(&quot;article.publish.download.do&quot;);
        &#125; else if (routingKey.equalsIgnoreCase(&quot;article.success.do&quot;)) &#123;
            System.out.println(&quot;article.success.do&quot;);
        &#125;else if (routingKey.equalsIgnoreCase(&quot;article.download.do&quot;)) &#123;
            String articleId = payload.split(&quot;,&quot;)[0];
            String articleMongoId = payload.split(&quot;,&quot;)[1];
            try &#123;
                articleHTMLComponent.download(articleId, articleMongoId);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

        &#125; else if (routingKey.equalsIgnoreCase(&quot;article.html.download.do&quot;)) &#123;
            String articleId = payload;
            try &#123;
                articleHTMLComponent.delete(articleId);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125; else &#123;
            System.out.println(&quot;不符合的规则：&quot; + routingKey);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">前端的index.html页面也需要修改成静态页面跳转
&lt;a :href=&quot;&#39;./a/&#39;+article.id+&#39;.html&#39;&quot; target=&quot;_blank&quot; class=&quot;link-article-title&quot;&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;
这样再次刷新 就可以让页面不是articleId=?...
http://www.imoocnews.com:9090/imooc-news/portal/a/240801D7S7PM63R4.html
</code></pre>
<h3 id="延迟队列的需求与安装配置【延迟队列】"><a href="#延迟队列的需求与安装配置【延迟队列】" class="headerlink" title="延迟队列的需求与安装配置【延迟队列】"></a>延迟队列的需求与安装配置【延迟队列】</h3><p>把这个<del>rabbitmq_delayed_message_exchange-3.8.0.ez</del>上传到Linux虚拟机</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/be9aa25974ee850399731a79b57f5cd8c4375356/data/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.jpg"></p>
<pre><code class="mysql">[imooc@imooc rabbitmq]$ cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.5/plugins
[imooc@imooc ~]$ sudo mv /home/imooc/rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.5/plugins
[imooc@imooc plugins]$ sudo systemctl restart rabbitmq-server
[imooc@imooc plugins]$ sudo rabbitmq-plugins list
Listing plugins with pattern &quot;.*&quot; ...
 Configured: E = explicitly enabled; e = implicitly enabled
 | Status: * = running on rabbit@imooc
 |/
[  ] rabbitmq_amqp1_0                  3.8.5
[  ] rabbitmq_auth_backend_cache       3.8.5
[  ] rabbitmq_auth_backend_http        3.8.5
[  ] rabbitmq_auth_backend_ldap        3.8.5
[  ] rabbitmq_auth_backend_oauth2      3.8.5
[  ] rabbitmq_auth_mechanism_ssl       3.8.5
[  ] rabbitmq_consistent_hash_exchange 3.8.5
[  ] rabbitmq_delayed_message_exchange 3.8.0
[  ] rabbitmq_event_exchange           3.8.5
[  ] rabbitmq_federation               3.8.5
[  ] rabbitmq_federation_management    3.8.5
[  ] rabbitmq_jms_topic_exchange       3.8.5
[E*] rabbitmq_management               3.8.5
[e*] rabbitmq_management_agent         3.8.5
[  ] rabbitmq_mqtt                     3.8.5
[  ] rabbitmq_peer_discovery_aws       3.8.5
[  ] rabbitmq_peer_discovery_common    3.8.5
[  ] rabbitmq_peer_discovery_consul    3.8.5
[  ] rabbitmq_peer_discovery_etcd      3.8.5
[  ] rabbitmq_peer_discovery_k8s       3.8.5
[  ] rabbitmq_prometheus               3.8.5
[  ] rabbitmq_random_exchange          3.8.5
[  ] rabbitmq_recent_history_exchange  3.8.5
[  ] rabbitmq_sharding                 3.8.5
[  ] rabbitmq_shovel                   3.8.5
[  ] rabbitmq_shovel_management        3.8.5
[  ] rabbitmq_stomp                    3.8.5
[  ] rabbitmq_top                      3.8.5
[  ] rabbitmq_tracing                  3.8.5
[  ] rabbitmq_trust_store              3.8.5
[e*] rabbitmq_web_dispatch             3.8.5
[  ] rabbitmq_web_mqtt                 3.8.5
[  ] rabbitmq_web_mqtt_examples        3.8.5
[  ] rabbitmq_web_stomp                3.8.5
[  ] rabbitmq_web_stomp_examples       3.8.5
[imooc@imooc plugins]$ service rabbitmq-server restart #[重启服务]
Redirecting to /bin/systemctl restart rabbitmq-server.service
</code></pre>
<h3 id="实现延迟队列【延迟队列】"><a href="#实现延迟队列【延迟队列】" class="headerlink" title="实现延迟队列【延迟队列】"></a>实现延迟队列【延迟队列】</h3><pre><code class="java">service-api  com/imooc/api/config/RabbitMQDelayConfig.java
package com.imooc.api.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * RabbitMQ 的配置类
 */
@Configuration
public class RabbitMQDelayConfig &#123;

    // 定义交换机的名字
    public static final String EXCHANGE_DELAY = &quot;exchange_delay&quot;;

    // 定义队列的名字
    public static final String QUEUE_DELAY = &quot;queue_delay&quot;;

    // 创建延迟交换机
    @Bean(EXCHANGE_DELAY)
    public CustomExchange delayExchange() &#123;
        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
        args.put(&quot;x-delayed-type&quot;, &quot;topic&quot;);
        return new CustomExchange(EXCHANGE_DELAY, &quot;x-delayed-message&quot;, true, false, args);
    &#125;

    // 创建队列
    @Bean(QUEUE_DELAY)
    public Queue queue()&#123;
        return new Queue(QUEUE_DELAY);
    &#125;

    // 队列绑定交换机 ↓ binding必须要唯一
    @Bean
    public Binding delayBinding(
            @Qualifier(QUEUE_DELAY) Queue queue,
            @Qualifier(EXCHANGE_DELAY) Exchange exchange)&#123;
        return BindingBuilder
                .bind(queue)
                .to(exchange)
                .with(&quot;delay.#&quot;)
                .noargs();      // 执行绑定
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/RabbitMQDelayConsumer.java
package com.imooc.article;

import com.imooc.api.config.RabbitMQDelayConfig;
import com.imooc.article.service.ArticleService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class RabbitMQDelayConsumer &#123;

    @Autowired
    private ArticleService articleService;

    @RabbitListener(queues = &#123;RabbitMQDelayConfig.QUEUE_DELAY&#125;)
    public void watchQueue(String payload, Message message) &#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        System.out.println(routingKey);

        System.out.println(&quot;消费者接受的延迟消息：&quot; + new Date());

//        // 消费者接收到定时发布的延迟消息，修改当前的文章状态为`即时发布`
//        String articleId = payload;
//        articleService.updateArticleToPublish(articleId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java
package com.imooc.article.controller;

import com.imooc.api.config.RabbitMQConfig;
import com.imooc.api.config.RabbitMQDelayConfig;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.AmqpException;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageDeliveryMode;
import org.springframework.amqp.core.MessagePostProcessor;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController&#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
    /**
     * RabbitMQ的路由规则 routing key
     * display.*.*  →  * 代表一个占位符
     * .with(&quot;article.#.do&quot;)  //类似于API的规则
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done 不匹配
     *
     * display.# → # 代表任意多个占位符
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done.over 匹配
     */

        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.publish.download.do&quot;, //要绑定规则
                &quot;1001~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.success.do&quot;, //要绑定规则
                &quot;1002~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.play&quot;, //要绑定规则
                &quot;1003~&quot;);
        return GraceJSONResult.ok();
    &#125;

    @GetMapping(&quot;/delay&quot;)
    public Object delay() &#123;
        //重写延迟方法  【生产者】
        MessagePostProcessor messagePostProcessor = new MessagePostProcessor() &#123;
            @Override
            public Message postProcessMessage(Message message) throws AmqpException &#123;
                // 设置消息的持久
                message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                // 设置消息延迟的时间 单位ms毫秒
                message.getMessageProperties().setDelay(5000);
                return message;
            &#125;
        &#125;;
        rabbitTemplate.convertAndSend(RabbitMQDelayConfig.EXCHANGE_DELAY,
                &quot;delay.demo&quot;, //要绑定规则
                &quot;这是一条延时消息~&quot;,
                messagePostProcessor);
        System.out.println(&quot;生产者发送的延迟消息：&quot; + new Date());
        return &quot;OK&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">确保 rabbitmq_delayed_message_exchange 插件正确启用：

复制代码
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
sudo systemctl restart rabbitmq-server

======================================================================
http://localhost:8001/producer/delay

生产者发送的延迟消息：Thu Aug 01 20:17:30 CST 2024

这是一条延时消息~
delay.demo
消费者接受的延迟消息：Thu Aug 01 20:17:35 CST 2024
</code></pre>
<h3 id="实现文章的定时延时发布【延迟队列】"><a href="#实现文章的定时延时发布【延迟队列】" class="headerlink" title="实现文章的定时延时发布【延迟队列】"></a>实现文章的定时延时发布【延迟队列】</h3><pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
/**
     * 更新定时发布为即使发布
     
    public void updateAppointToPublish(); **/

    /**
     * 更新单条文章为记时发布
     */
    public void updateArticleToPublish(String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
【32-64行  89-101行】
 @Transactional
    @Override
    public void createArticle(NewArticleBO newArticleBO, Category category) &#123;
        String articleId = sid.nextShort();

        Article article = new Article();
        BeanUtils.copyProperties(newArticleBO, article);

        article.setId(articleId);
        article.setCategoryId(category.getId());
        article.setArticleStatus(ArticleReviewStatus.REVIEWING.type);
        article.setCommentCounts(0);
        article.setReadCounts(0);

        article.setIsDelete(YesOrNo.NO.type);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());

        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;
            article.setPublishTime(newArticleBO.getPublishTime()); //用户可以在前端选择定时发布
        &#125; else if (article.getIsAppoint() == ArticleAppointType.IMMEDIATELY.type) &#123;
            article.setPublishTime(new Date());
        &#125;

        int res = articleMapper.insert(article);
        if (res != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_CREATE_ERROR);
        &#125;

        // 发送延迟消息到mq，计算定时发布时间和当前时间的时间差，则为往后延迟的时间
        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;

            Date endDate = newArticleBO.getPublishTime();
            Date startDate = new Date();

          int delayTimes = (int)(endDate.getTime() - startDate.getTime());

            System.out.println(DateUtil.timeBetween(startDate, endDate));

            // FIXME: 为了测试方便，写死10s
//            int delayTimes = 10 * 1000;

            MessagePostProcessor messagePostProcessor = new MessagePostProcessor() &#123;
                @Override
                public Message postProcessMessage(Message message) throws AmqpException &#123;
                    // 设置消息的持久
                    message.getMessageProperties()
                            .setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                    // 设置消息延迟的时间，单位ms毫秒
                    message.getMessageProperties()
                            .setDelay(delayTimes);
                    return message;
                &#125;
            &#125;;
            rabbitTemplate.convertAndSend(
                    RabbitMQDelayConfig.EXCHANGE_DELAY,
                    &quot;publish.delay.display&quot;,
                    articleId,
                    messagePostProcessor);

            System.out.println(&quot;延迟消息-定时发布文章：&quot; + new Date());
        &#125;


        /**
         * FIXME: 我们只检测正常的词汇，非正常词汇大家课后去检测
         */
        // 通过阿里智能AI实现对文章文本的自动检测（自动审核）
//        String reviewTextResult = aliTextReviewUtils.reviewTextContent(newArticleBO.getContent());
        String reviewTextResult = ArticleReviewLevel.REVIEW.type;

        if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.PASS.type)) &#123;
            // 修改当前的文章，状态标记为审核通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.SUCCESS.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.REVIEW.type)) &#123;
            // 修改当前的文章，状态标记为需要人工审核
            this.updateArticleStatus(articleId, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.BLOCK.type)) &#123;
            // 修改当前的文章，状态标记为审核未通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.FAILED.type);
        &#125;
    &#125;

@Transactional //添加事务[更新操作]
/** @Override
    public void updateAppointToPublish() &#123;
        articleMapperCustom.updateAppointToPublish();
    &#125; **/

    @Override
    public void updateArticleToPublish(String articleId) &#123;
        Article article = new Article();
        article.setId(articleId);
        article.setIsAppoint(ArticleAppointType.IMMEDIATELY.type);
        articleMapper.updateByPrimaryKeySelective(article);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/RabbitMQDelayConsumer.java
package com.imooc.article;

import com.imooc.api.config.RabbitMQDelayConfig;
import com.imooc.article.service.ArticleService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class RabbitMQDelayConsumer &#123;

    @Autowired
    private ArticleService articleService;

    @RabbitListener(queues = &#123;RabbitMQDelayConfig.QUEUE_DELAY&#125;)
    public void watchQueue(String payload, Message message) &#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        System.out.println(routingKey);

        System.out.println(&quot;消费者接受的延迟消息：&quot; + new Date());

        // 消费者接收到定时发布的延迟消息，修改当前的文章状态为`即时发布`
        String articleId = payload;
        articleService.updateArticleToPublish(articleId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/RabbitMQDelayConfig.java //【换一下绑定类型.with(...)】
package com.imooc.api.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * RabbitMQ 的配置类
 */
@Configuration
public class RabbitMQDelayConfig &#123;

    // 定义交换机的名字
    public static final String EXCHANGE_DELAY = &quot;exchange_delay&quot;;

    // 定义队列的名字
    public static final String QUEUE_DELAY = &quot;queue_delay&quot;;

    // 创建延迟交换机
    @Bean(EXCHANGE_DELAY)
    public CustomExchange delayExchange() &#123;
        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
        args.put(&quot;x-delayed-type&quot;, &quot;topic&quot;);
        return new CustomExchange(EXCHANGE_DELAY, &quot;x-delayed-message&quot;, true, false, args);
    &#125;

    // 创建队列
    @Bean(QUEUE_DELAY)
    public Queue queue()&#123;
        return new Queue(QUEUE_DELAY);
    &#125;

    // 队列绑定交换机 ↓ binding必须要唯一
    @Bean
    public Binding delayBinding(
            @Qualifier(QUEUE_DELAY) Queue queue,
            @Qualifier(EXCHANGE_DELAY) Exchange exchange)&#123;
        return BindingBuilder
                .bind(queue)
                .to(exchange)
                .with(&quot;publish.delay.#&quot;)
                .noargs();      // 执行绑定
    &#125;
&#125;
</code></pre>
<pre><code class="java">http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html 发布一篇定时文章
// 在数据库里面是article → is_appoint 是1 然后延迟3天后会变成0
Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15650472]
JDBC Connection [HikariProxyConnection@441638108 wrapping org.mariadb.jdbc.MariaDbConnection@159b2e33] will be managed by Spring
==&gt;  Preparing: INSERT INTO article ( id,title,category_id,article_type,article_cover,is_appoint,article_status,publish_user_id,publish_time,read_counts,comment_counts,mongo_file_id,is_delete,create_time,update_time,content ) VALUES( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? ) 
==&gt; Parameters: 240801FNS7M8G354(String), b10(String), 14(Integer), 2(Integer), (String), 1(Integer), 1(Integer), 240629F21AK1BHX4(String), 2024-08-04 00:00:00.0(Timestamp), 0(Integer), 0(Integer), null, 0(Integer), 2024-08-01 20:36:24.971(Timestamp), 2024-08-01 20:36:24.971(Timestamp), &lt;p&gt;b10&lt;/p&gt;(String)
//★ &lt;==    Updates: 1 ★
Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15650472]
//★ 2天3小时23分钟 ★
//★ 延迟消息-定时发布文章：Thu Aug 01 20:36:24 CST 2024 ★
Fetched SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15650472] from current transaction
==&gt;  Preparing: UPDATE article SET article_status = ? WHERE ( ( id = ? ) ) 
==&gt; Parameters: 2(Integer), 240801FNS7M8G354(String)
&lt;==    Updates: 1
</code></pre>
<h3 id="互联网框架演变【微服务块】"><a href="#互联网框架演变【微服务块】" class="headerlink" title="互联网框架演变【微服务块】"></a>互联网框架演变【微服务块】</h3><ul>
<li><strong>架构演变</strong></li>
<li><strong>微服务入门</strong></li>
<li><strong>SpringCloud各个组件学习</strong></li>
<li><strong>改造项目服务化</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6d9d64a0daa29b87ebdd0c5ca1240264d5b802ed/data/r%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98.png"></p>
<h3 id="注冊中心模型"><a href="#注冊中心模型" class="headerlink" title="注冊中心模型"></a>注冊中心模型</h3><ul>
<li>Eureka</li>
<li>可以把每個服務注入到eureka，更利於管理和維護，使得服務閒通信更方便</li>
</ul>
<blockquote>
<p>Lilei [上户口] → <strong>派出所</strong>  ← [上户口] HanMeimei</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/317410ba901fb06e893bcdd7e2eb05980a9d19d0/data/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png"></p>
<h3 id="构建Eureka注册服务【eureka】"><a href="#构建Eureka注册服务【eureka】" class="headerlink" title="构建Eureka注册服务【eureka】"></a>构建Eureka注册服务【eureka】</h3><pre><code class="java">springcloud-eureka  com/imooc/eureka/Application.java
package com.imooc.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;


@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, MongoAutoConfiguration.class&#125;)
@EnableEurekaServer // 开启注册中心
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;

&#125;
http://localhost:7000/hello  #运行接口
http://localhost:7000         #运行eureka
</code></pre>
<pre><code class="java">springcloud-eureka  com/imooc/eureka/controller/HelloController.java
package com.imooc.eureka.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">springcloud-eureka  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-eureka&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;
            &lt;/dependency&gt;
            &lt;!-- 其他必要的依赖 --&gt;
    &lt;/dependencies&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR12&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">springcloud-eureka  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-admin&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-dev/springcloud-eureka&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/eureka.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="yaml">springcloud-eureka  application.yml
############################################################
#
# eureka 注册中心
# web访问端口号  约定：7000
#
############################################################
server:
  port: 7000
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-eureka

############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:  # eureka 实例的hostname，也可以是自定义配置hostname
    hostname: eureka
  client:  # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<pre><code class="java">http://localhost:7000/
进入了Spring Eureka
Instances currently registered with Eureka
</code></pre>
<h3 id="实现用户与文章的服务注册【eureka】"><a href="#实现用户与文章的服务注册【eureka】" class="headerlink" title="实现用户与文章的服务注册【eureka】"></a>实现用户与文章的服务注册【eureka】</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/longd123/article/details/124440454">关于eureka客户端启动报错UnknownHostException详细解决方法_eureka unknownhostexception-CSDN博客</a> </p>
<pre><code class="mysql"># 问题：
http://eureka:7000/eureka   找不到 eureka 的服务器 IP 地址

在cmd里面
C:\Users\Pluminary&gt;ping eureka
Ping 请求找不到主机 eureka。请检查该名称，然后重试。

# 解答：
从你的描述来看，主机eureka无法解析，这是导致服务无法注册到Eureka Server的原因。你可以通过以下方法解决这个问题：

1. 更新 hosts 文件
在你的开发机器上更新 hosts 文件以手动解析 eureka 主机名。

Windows
打开记事本以管理员身份运行。

打开文件 C:\Windows\System32\drivers\etc\hosts。

添加以下行，将 &lt;eureka服务器的IP地址&gt; 替换为实际的IP地址：

plaintext
复制代码
&lt;eureka服务器的IP地址&gt; eureka
保存并关闭文件。

=================================================================
# imooc-news 192.168.1.3
127.0.0.1 www.imoocnews.com
127.0.0.1 writer.imoocnews.com
127.0.0.1 admin.imoocnews.com
```
127.0.0.1 article.imoocnews.com
127.0.0.1 user.imoocnews.com
127.0.0.1 files.imoocnews.com
127.0.0.1 html.imoocnews.com
</code></pre>
<pre><code class="yaml">springcloud-eureka  resources/application.yml
############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # eureka 实例的hostname，可以是hostname，也可以自定义配置hostname
    hostname: eureka
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<pre><code class="yaml">service-user  resources/application.yml
上面的其余不变 底下添加eureka
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
      defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
</code></pre>
<pre><code class="java">service-user  com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient // 开启eureka client 注册到server中
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">springcloud-eureka  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-eureka&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">springcloud-eureka  com/imooc/user/Application.java
package com.imooc.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;


@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, MongoAutoConfiguration.class&#125;)
@EnableEurekaServer // 开启注册中心
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
====================================================================
// 先启动这个服务 再启动user的服务
随后就能看见http://localhost:7000/
里面有一个注册的服务
/*  
   Instances currently registered with Eureka
   Application    AMIs    Availability Zones    Status
★ SERVICE-USER    n/a (1)    (1)    UP (1) - localhost:service-user:8003 
*/
</code></pre>
<pre><code class="yaml">service-article  resources/application.yml
# 定义freemarker生成的HTML
freemarker:
  html:
    target: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
    article: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
      defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java 
//【此时再去启动这个article服务 会发现SERVICE-ARTICLE也成功的注册到Eureka中】
package com.imooc.article;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
/*
   Application    AMIs    Availability Zones    Status
★ SERVICE-ARTICLE    n/a (1)    (1)    UP (1) - localhost:service-article:8001
★ SERVICE-USER    n/a (1)    (1)    UP (1) - localhost:service-user:8003
*/
</code></pre>
<h3 id="使用AppName优化服务间的通信【eureka】"><a href="#使用AppName优化服务间的通信【eureka】" class="headerlink" title="使用AppName优化服务间的通信【eureka】"></a>使用AppName优化服务间的通信【eureka】</h3><h6 id="实行动态化调用-地址拼接"><a href="#实行动态化调用-地址拼接" class="headerlink" title="实行动态化调用 地址拼接"></a>实行动态化调用 地址拼接</h6><p>AppName是eureka的ApplicationId &#x3D; <strong>SERVICE-USER</strong></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·[文章article]自媒体接口api</a> 如果页面没有信息那就是在<strong>Swagger2.java</strong>中代码的问题<br><a target="_blank" rel="noopener" href="http://localhost:7000/">Eureka</a></p>
<blockquote>
<p>门户端文章业务的controller →  &#x2F;portal&#x2F;article&#x2F;detail  →  articleId&#x3D;2006117B57WRZGHH</p>
</blockquote>
<pre><code class="java">package com.imooc.api.config;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.RequestHandler;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration //Springboot啓動的時候會被掃描到并且加載
@EnableSwagger2
public class Swagger2 &#123;

    //    http://localhost:8088/swagger-ui.html     原路径
    //    http://localhost:8088/doc.html            新路径

    // 配置swagger2核心配置 docket
    @Bean
    public Docket createRestApi() &#123;
        Predicate&lt;RequestHandler&gt; adminPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.admin.controller&quot;);
        Predicate&lt;RequestHandler&gt; articlePredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.article.controller&quot;);
        Predicate&lt;RequestHandler&gt; userPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.user.controller&quot;);
        Predicate&lt;RequestHandler&gt; filesPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.files.controller&quot;);

        return new Docket(DocumentationType.SWAGGER_2)  // 指定api类型为swagger2
                .apiInfo(apiInfo())                 // 用于定义api文档汇总信息
                .select()
//                .apis(Predicates.or(userPredicate, adminPredicate, filesPredicate))
                .apis(Predicates.or(adminPredicate, articlePredicate, userPredicate, filesPredicate))
                .paths(PathSelectors.any())         // 所有controller
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕课新闻·自媒体接口api&quot;)                       // 文档页标题
                .contact(new Contact(&quot;imooc&quot;,
                        &quot;https://www.imooc.com&quot;,
                        &quot;abc@imooc.com&quot;))                   // 联系人信息
                .description(&quot;专为慕课新闻·自媒体平台提供的api文档&quot;)      // 详细信息
                .version(&quot;1.0.1&quot;)                               // 文档版本号
                .termsOfServiceUrl(&quot;https://www.imooc.com&quot;)     // 网站地址
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
// 注入服务发现，可以获得已经注册的服务相关信息
    @Autowired
    private DiscoveryClient discoveryClient;
    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
        String serviceId = &quot;SERVICE-USER&quot;;
        List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(serviceId);
        ServiceInstance userService = instanceList.get(0);
    // 实行动态化调用 地址拼接
        String userServerUrlExecute
                = &quot;http://&quot;+ userService.getHost() + &quot;:&quot; + userService.getPort() + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;
</code></pre>
<h3 id="动态构建eureka集群【eureka】保证高可用"><a href="#动态构建eureka集群【eureka】保证高可用" class="headerlink" title="动态构建eureka集群【eureka】保证高可用"></a>动态构建eureka集群【eureka】<del>保证高可用</del></h3><blockquote>
<p>创建一个新的<strong>module</strong> 其内容和 <strong>springcloud-eureka</strong> 里面的一样</p>
</blockquote>
<pre><code class="mysql">SwitchHosts配置信息
# imooc-news 192.168.1.3
127.0.0.1 www.imoocnews.com
127.0.0.1 writer.imoocnews.com
127.0.0.1 admin.imoocnews.com
```
127.0.0.1 article.imoocnews.com
127.0.0.1 user.imoocnews.com
127.0.0.1 files.imoocnews.com
127.0.0.1 html.imoocnews.com

# SpringCloud
127.0.0.1 eureka
127.0.0.1 eureka-cluster-7001
127.0.0.1 eureka-cluster-7002
127.0.0.1 eureka-cluster-7003
</code></pre>
<pre><code class="yaml">springcloud-eureka-cluster  application.yml
############################################################
#
# eureka 集群的注册中心
# web访问端口号  约定：7001~7003
#
############################################################
server:
  port: 7001
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-eureka-cluster

############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # 集群中每个eureka的名字都是唯一的
    hostname: eureka-cluster-7001
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

####################################################################################
http://localhost:7001/

DS Replicas
eureka-cluster-7003
eureka-cluster-7002
####################################################################################
如果后面服务很多 100个 那是不是也要创建100个module呢？
并不是 因为每个都是一样的只是改一下application.yml的port端口号而已
所以我们要去把它设置为动态的端口
</code></pre>
<h3 id="↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓"><a href="#↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓" class="headerlink" title="↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓"></a><span style = "color:red">↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></h3><pre><code class="yaml">springcloud-eureka-cluster  application.yml【改后】
############################################################
#
# eureka 集群的注册中心
# web访问端口号  约定：7001~7003
#
############################################################
server:
  port: $&#123;7001&#125;
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-eureka-cluster

############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # 集群中每个eureka的名字都是唯一的
    hostname: eureka-cluster-$&#123;server.port&#125;
    # 自定义端口号
  other-node-port2: $&#123;p2:7002&#125;
  other-node-port3: $&#123;p3:7003&#125;
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://eureka-cluster-$&#123;eureka.other-node-port2&#125;:$&#123;eureka.other-node-port2&#125;/eureka/,http://eureka-cluster-$&#123;eureka.other-node-port3&#125;:$&#123;eureka.other-node-port3&#125;/eureka/

####################################################################################
http://eureka-cluster-7001:7001/  #【可运行】
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyl-0110/p/14368753.html">1一站式管理所有SpringBoot启动类，Services服务窗口 - 喵酱张-Eric - 博客园 (cnblogs.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44603382/article/details/121593216">IDEA 2021没有VM options_idea2021怎么找到“vm options”-CSDN博客</a></p>
<blockquote>
<p>复制eureka-cluster-7001服务 变成eureka-cluster-7002 并且在Edit configuration的地方点击Modify options中的Add VM 输入代码：**-DPORT&#x3D;7002 -DP2&#x3D;7001 -DP3&#x3D;7003**<br>同理弄一个eureka-cluster-7003 输入VM代码：**-DPORT&#x3D;7003 -DP2&#x3D;7001 -DP3&#x3D;7002**<br>全部启动后都可以在浏览器正常运行 【集群】<br><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">http://eureka-cluster-7001:7001/</a>  DS Replicas：<a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a> + <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a><br><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/">http://eureka-cluster-7002:7002/</a>  DS Replicas：<a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a> + <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/eureka/">eureka-cluster-7001</a><br><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/">http://eureka-cluster-7003:7003/</a>  DS Replicas：<a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a> + <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/eureka/">eureka-cluster-7001</a><br>如果把里面的application.yml配置注释掉 就可以把自己注册到eureka中<br>client:<br>  <em>#</em> *是否要把当前的<strong>eureka server</strong>注册到自己<br>    *  register-with-eureka: false<br>  <em>#</em> *从注册中心获得检索服务实例，<strong>server</strong>没有必要，直接<strong>false</strong>即可<br>    *  fetch-registry: false<br>之后再重新启动eureka-cluster-7001~7003</p>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">eureka-cluster-7001:7001</a></p>
<h5 id="DS-Replicas"><a href="#DS-Replicas" class="headerlink" title="DS Replicas"></a>DS Replicas</h5><ul>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a></li>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a></li>
</ul>
<h5 id="Instances-currently-registered-with-Eureka"><a href="#Instances-currently-registered-with-Eureka" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h5><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
</blockquote>
<h3 id="微服务注册到eureka集群【eureka】-port-8003"><a href="#微服务注册到eureka集群【eureka】-port-8003" class="headerlink" title="微服务注册到eureka集群【eureka】${port:8003}"></a>微服务注册到eureka集群【eureka】<del>${port:8003}</del></h3><pre><code class="yaml">service-user  application.yml
    # 注册中心的服务地址
    service-url:
  # defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/ 三个节点的注册
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="yaml">service-article  application.yml
    # 注册中心的服务地址
    service-url:
  # defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口:8001_api</a><br>门户端文章业务的controller → get：&#x2F;portal&#x2F;article&#x2F;detail → articleId：2006117B57WRZGHH</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">Eureka:7001</a></p>
<h6 id="DS-Replicas-1"><a href="#DS-Replicas-1" class="headerlink" title="DS Replicas"></a>DS Replicas</h6><ul>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a></li>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a></li>
</ul>
<h6 id="Instances-currently-registered-with-Eureka-1"><a href="#Instances-currently-registered-with-Eureka-1" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE-ARTICLE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8001/actuator/info">localhost:service-article:8001</a></td>
</tr>
<tr>
<td align="left"><strong>SERVICE-USER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8003/actuator/info">localhost:service-user:8003</a></td>
</tr>
<tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
<h3 id="构建微服务集集群【eureka】"><a href="#构建微服务集集群【eureka】" class="headerlink" title="构建微服务集集群【eureka】"></a>构建微服务集集群【eureka】</h3><blockquote>
<p>复制<strong>service-user:8003</strong>服务 变成service-user:8013 并且在Edit configuration的地方点击Modify options中的Add VM 输入代码：**–DPORT&#x3D;8013** </p>
</blockquote>
<pre><code class="yaml">service-user  application-dev.yml
server:
  port: $&#123;port:8003&#125;

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
# open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# setup CN from java, This is resource
website:
  domain-name: imoocnews.com
</code></pre>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">Eureka:7001</a></p>
<h6 id="DS-Replicas-2"><a href="#DS-Replicas-2" class="headerlink" title="DS Replicas"></a>DS Replicas</h6><ul>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a></li>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a></li>
</ul>
<h6 id="Instances-currently-registered-with-Eureka-2"><a href="#Instances-currently-registered-with-Eureka-2" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE-ARTICLE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8001/actuator/info">localhost:service-article:8001</a></td>
</tr>
<tr>
<td align="left"><strong>SERVICE-USER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (2)</td>
<td align="left">(2)</td>
<td align="left"><strong>UP</strong> (2) - <a target="_blank" rel="noopener" href="http://localhost:8003/actuator/info">localhost:service-user:8003</a> , <a target="_blank" rel="noopener" href="http://localhost:8013/actuator/info">localhost:service-user:8013</a></td>
</tr>
<tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
<h3 id="实现轮训负载均衡【eureka】"><a href="#实现轮训负载均衡【eureka】" class="headerlink" title="实现轮训负载均衡【eureka】"></a>实现轮训负载均衡【eureka】</h3><pre><code class="yaml">imooc-news-dev-service-user  application-dev.yml
server:
  port: $&#123;port:8003&#125;

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
# open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# setup CN from java, This is resource
website:
  domain-name: imoocnews.com
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
//每次调用的时候 都会输出其Port
 @Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;

    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
    // 注入服务发现，可以获得已经注册的服务相关信息
    @Autowired
    private DiscoveryClient discoveryClient;
    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
        String serviceId = &quot;SERVICE-USER&quot;;
//        List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(serviceId);
//        ServiceInstance userService = instanceList.get(0);
    // 实行动态化调用 地址拼接
        String userServerUrlExecute
                //因为seviceId里面的SERVICE—USER就存在着userService.getHost()和.getPort()
                = &quot;http://&quot;+ serviceId + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://&quot;+ userService.getHost() + &quot;:&quot; + userService.getPort() + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        // 为restTemplate增加一个负载均衡 @CloudConfig 
                // public RestTemplate restTemplate()
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;
    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced //添加负载均衡
    public RestTemplate restTemplate() &#123;
        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口:8001-api</a><br>门户端文章业务的controller → articleId：2006117B57WRZGHH</p>
</blockquote>
<h3 id="自我保护功能【eureka】"><a href="#自我保护功能【eureka】" class="headerlink" title="自我保护功能【eureka】"></a>自我保护功能【eureka】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/6475d580b535921c2886327b5964ef9fdcad0663/data/Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4.png"></p>
<pre><code class="yaml">springcloud-eureka-cluster  application.yml
############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # 集群中每个eureka的名字都是唯一的
    hostname: eureka-cluster-$&#123;server.port&#125;
    # 自定义端口号
  other-node-port2: $&#123;p2:7002&#125;
  other-node-port3: $&#123;p3:7003&#125;
  client:
    # 是否要把当前的eureka server注册到自己
      # register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
      # fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://eureka-cluster-$&#123;eureka.other-node-port2&#125;:$&#123;eureka.other-node-port2&#125;/eureka/,http://eureka-cluster-$&#123;eureka.other-node-port3&#125;:$&#123;eureka.other-node-port3&#125;/eureka/
  server:
    enable-self-preservation: false # 关闭eureka的自我保护功能
    eviction-interval-timer-in-ms: 5000 # 清理无效节点的时间，可以缩短为5s 默认60s
</code></pre>
<pre><code class="yaml">springcloud-eureka application.yml
############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # eureka 实例的hostname，可以是hostname，也可以自定义配置hostname
    hostname: eureka
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
  server:
    enable-self-preservation: false # 关闭eureka的自我保护功能
    eviction-interval-timer-in-ms: 5000 # 清理无效节点的时间，可以缩短为5s 默认60s
</code></pre>
<pre><code class="yaml">service-user  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/ 三个节点的注册
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="yaml">service-article  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">Eureka:7001</a><br>先把所有服务全启动<br>eureka:7000<br>eureka-cluster-7001<br>eureka-cluster-7002<br>eureka-cluster-7003<br>service-article:8001<br>service-user:8003<br>service-user:8013<br>然后去刷新</p>
<h6 id="Instances-currently-registered-with-Eureka-3"><a href="#Instances-currently-registered-with-Eureka-3" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE-ARTICLE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8001/actuator/info">localhost:service-article:8001</a></td>
</tr>
<tr>
<td align="left"><strong>SERVICE-USER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (2)</td>
<td align="left">(2)</td>
<td align="left"><strong>UP</strong> (2) - <a target="_blank" rel="noopener" href="http://localhost:8003/actuator/info">localhost:service-user:8003</a> , <a target="_blank" rel="noopener" href="http://localhost:8013/actuator/info">localhost:service-user:8013</a></td>
</tr>
<tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
<p>随后只留下eureka-cluster-7001其他全部Stop<br>再次刷新</p>
<h6 id="Instances-currently-registered-with-Eureka-4"><a href="#Instances-currently-registered-with-Eureka-4" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a></td>
</tr>
</tbody></table>
</blockquote>
<h3 id="负载均衡工具"><a href="#负载均衡工具" class="headerlink" title="负载均衡工具"></a>负载均衡工具</h3><ul>
<li><strong>Ribbon</strong>[本地] &#x3D; <strong>RestTemplate</strong> + <strong>@LoadBalanced</strong></li>
<li><strong>服务间通信的负载均衡工具，提供完善的超时重试机制</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a0b97158e7b360bc72b677aad99c5cb41b32d995/data/ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;

    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced //添加负载均衡 默认的负载均衡算法：枚举
    public RestTemplate restTemplate() &#123;

        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<h3 id="实现多种负载均衡算法【ribbon】"><a href="#实现多种负载均衡算法【ribbon】" class="headerlink" title="实现多种负载均衡算法【ribbon】"></a>实现多种负载均衡算法【ribbon】</h3><h6 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h6><p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口api</a></p>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;

    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced //添加负载均衡 默认的负载均衡算法：枚举
    public RestTemplate restTemplate() &#123;

        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/rule/MyRule.java
package com.rule;

import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.RandomRule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 官方定义了规则不要被 @ComponentScan( 扫描到
@Configuration
public class MyRule &#123;
    @Bean
    public IRule iRule()&#123;// 随机的负载均衡策略
        return new RandomRule();
        // 在调用方article的启动类开启注解 @RibbonClient
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h6 id="运用配置文件进行配置"><a href="#运用配置文件进行配置" class="headerlink" title="运用配置文件进行配置"></a>运用配置文件进行配置</h6><blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口api</a> 发送11次请求 <strong>门户端文章业务</strong>→articleId：2006117B57WRZGHH<br>service-user:8003请求到myPort&#x3D;8003 8次<br>service-user:8013请求到myPort&#x3D;8013 3次</p>
</blockquote>
<pre><code class="yaml">service-article  resources/application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5

# 配置指定自定义的ribbon规则
SERVICE-USER:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="重试机制【ribbon】"><a href="#重试机制【ribbon】" class="headerlink" title="重试机制【ribbon】"></a>重试机制【ribbon】</h3><h6 id="节点有可能因为网络问题访问不到-而为了不让其返回错误-需要重试机制"><a href="#节点有可能因为网络问题访问不到-而为了不让其返回错误-需要重试机制" class="headerlink" title="节点有可能因为网络问题访问不到 而为了不让其返回错误 需要重试机制"></a>节点有可能因为网络问题访问不到 而为了不让其返回错误 需要重试机制</h6><pre><code class="xml">sevice-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
            &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">service-article  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5

# 配置指定自定义的ribbon规则
SERVICE-USER:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule


ribbon:
  ConnectTimeout: 5000          # 创建连接的超时时间，单位：ms
  ReadTimeout: 5000             # 在连接创建好以后，调用接口的超时时间，单位：ms
  MaxAutoRetries: 1             # 最大重试次数
  MaxAutoRetriesNextServer: 2   # 切换到下个微服务实例的重试次数
  # 当请求到某个微服务5s，超时后会进行重试，先重试连接自己当前的这个实例
  # 如果当前重试失败1次，则会切换到访问集群中的下一个微服务实例，切换最大为2次

logging:
  level:
#    com.imooc.api.controller.user.UserControllerApi: debug
    root: debug
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口-8001api</a>     articleId：2006117B57WRZGHH<br>先把所有服务全部启动 然后把service-user:8013 的服务Stop<br>再去api接口发送请求 查看servcice-article:8001的Console输出日志<br>14:10.288 [http-nio-8001-exec-1] DEBUG o.s.retry.support.RetryTemplate - Retry: count&#x3D;0<br>14:10.774 [http-nio-8001-exec-1] DEBUG o.s.web.client.RestTemplate - Response 200 OK<br>14:10.288 [http-nio-8001-exec-1] DEBUG o.s.retry.support.RetryTemplate - Retry: count&#x3D;1<br>14:10.288 [http-nio-8001-exec-1] DEBUG o.s.retry.support.RetryTemplate - Retry: count&#x3D;2<br>14:10.774 [http-nio-8001-exec-1] DEBUG o.s.web.client.RestTemplate - Response 200 OK</p>
</blockquote>
<h3 id="简化服务调用【feign】以Api作为接口-面向接口的编程风格"><a href="#简化服务调用【feign】以Api作为接口-面向接口的编程风格" class="headerlink" title="简化服务调用【feign】以Api作为接口,面向接口的编程风格"></a>简化服务调用【feign】<del>以Api作为接口,面向接口的编程风格</del></h3><h5 id="声明式HTTP工具"><a href="#声明式HTTP工具" class="headerlink" title="声明式HTTP工具"></a>声明式HTTP工具</h5><ul>
<li><strong>Feign</strong></li>
<li><strong>声明式的http工具，用于简化服务调用</strong></li>
</ul>
<pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
    // 注入服务发现，可以获得已经注册的服务相关信息
    @Autowired
    private DiscoveryClient discoveryClient;

    @Autowired
    private UserControllerApi userControllerApi;
    //面向接口 UserControllerApi
    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
//        String serviceId = &quot;SERVICE-USER&quot;;
//        List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(serviceId);
//        ServiceInstance userService = instanceList.get(0);
    // 实行动态化调用 地址拼接
//        String userServerUrlExecute
                //因为seviceId里面的SERVICE—USER就存在着userService.getHost()和.getPort()
//                = &quot;http://&quot;+ serviceId + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        GraceJSONResult bodyResult = userControllerApi.queryByIds(JsonUtils.objectToJson(idSet));
//        String userServerUrlExecute
//                = &quot;http://&quot;+ userService.getHost() + &quot;:&quot; + userService.getPort() + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        // 为restTemplate增加一个负载均衡@CloudConfig public RestTemplate restTemplate()
//        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
//                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
//        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java //【EnableFeignClients】
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
@EnableFeignClients(&#123;&quot;com.imooc&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/MyServiceList.java
package com.imooc.api.config;

public class MyServiceList &#123;
    public static final String SERVICE_USER = &quot;service-user&quot;;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/api/controller/user/UserControllerApi.java【@FeignClient】
package com.imooc.api.controller.user;

import com.imooc.api.config.MyServiceList;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
@FeignClient(value = MyServiceList.SERVICE_USER) //作为客户端直接调用
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
                                          @RequestParam BindingResult result); //RequestParam  BindingResult result 加了肯定在前端不可用 对Feign而言不能存在两个对象不然会认为有两个model

    @ApiOperation(value = &quot;根据用户的ids查询用户列表&quot;,notes = &quot;根据用户的ids查询用户列表&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/queryByIds&quot;)
    public GraceJSONResult queryByIds(@RequestParam String userIds);
&#125;
</code></pre>
<h3 id="统一检验处理【feign】"><a href="#统一检验处理【feign】" class="headerlink" title="统一检验处理【feign】"></a>统一检验处理【feign】</h3><blockquote>
<p>把所有的BindingResult都可以采用全局调用的方法去调用<br><a target="_blank" rel="noopener" href="http://localhost:8003/doc.html">慕课新闻·自媒体接口8003api</a> → 用户信息相关 → 修改&#x2F;完善用户信息  Post &#x2F;user&#x2F;updateUserInfo</p>
</blockquote>
<pre><code class="java">dev-common  com/imooc/exception/GraceExceptionHandler.java
package com.imooc.exception;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MaxUploadSizeExceededException;

import javax.naming.Binding;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 统一异常拦截处理
 * 可以针对异常的类型进行捕获 然后返回json信息到前端
 */
@ControllerAdvice
public class GraceExceptionHandler &#123;
 /* @ExceptionHandler(MyCustomException.class)
    //只要是这个类的异常都会进入下面的方法
    @ResponseBody
    public GraceJSONResult returnMyException(MyCustomException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.exception(e.getResponseStatusEnum());
    &#125;

    @ExceptionHandler(MaxUploadSizeExceededException.class)
    @ResponseBody
    public GraceJSONResult returnMaxUploadSizeExceededException(MaxUploadSizeExceededException e) &#123;
        return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_MAX_SIZE_ERROR);
    &#125;*/

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody //该异常是基于所有的vo验证
    public GraceJSONResult returnException(MethodArgumentNotValidException e) &#123;
        BindingResult result = e.getBindingResult();
        Map&lt;String, String&gt; map = getErrors(result);
        return GraceJSONResult.errorMap(map);
    &#125;

    public Map&lt;String, String&gt; getErrors(BindingResult result) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList) &#123;
            // 发送验证错误的时候所对应的某个属性
            String field = error.getField();
            // 验证的错误消息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
//    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
//    @PostMapping(&quot;/updateUserInfo&quot;)
//    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
//                                          @RequestParam BindingResult result);
    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO);
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
    @Override
  public GraceJSONResult updateUserInfo(@Valid UpdateUserInfoBO updateUserInfoBO)&#123;
    //, BindingResult result) &#123;
//        // 0.校验BO
//        if (result.hasErrors())&#123;
//            Map&lt;String, String&gt; map = getErrors(result);
//            return GraceJSONResult.errorMap(map);
//        &#125;
        // 1.执行更新操作
        userService.updateUserInfo(updateUserInfoBO);
        return GraceJSONResult.ok();
        //调用UserService把独有信息传入
    &#125;
</code></pre>
<h3 id="开启日志调式【feign】基于http的调用"><a href="#开启日志调式【feign】基于http的调用" class="headerlink" title="开启日志调式【feign】基于http的调用"></a>开启日志调式【feign】<del>基于http的调用</del></h3><pre><code class="yaml">service-article  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5

# 配置指定自定义的ribbon规则
SERVICE-USER:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule


ribbon:
  ConnectTimeout: 5000          # 创建连接的超时时间，单位：ms
  ReadTimeout: 5000             # 在连接创建好以后，调用接口的超时时间，单位：ms
  MaxAutoRetries: 1             # 最大重试次数
  MaxAutoRetriesNextServer: 2   # 切换到下个微服务实例的重试次数
  # 当请求到某个微服务5s，超时后会进行重试，先重试连接自己当前的这个实例
  # 如果当前重试失败1次，则会切换到访问集群中的下一个微服务实例，切换最大为2次

logging:
  level:
    com.imooc.api.controller.user.UserControllerApi: debug
#    root: debug 日志打印级别

# 配置feign
feign:
  client:
    config:
      # 配置服务提供方的名称
      service-user:
        logger-level: full
</code></pre>
<blockquote>
<p>重启所有服务 调用<a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口8001api</a>门户端→文章详情 articleId：2006117B57WRZGHH<br>09:19.009 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] &lt;— HTTP&#x2F;1.1 200 (590ms)<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] connection: keep-alive<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] content-type: application&#x2F;json<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] date: Mon, 05 Aug 2024 09:09:19 GMT<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] keep-alive: timeout&#x3D;60<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] transfer-encoding: chunked<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] vary: Access-Control-Request-Headers<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] vary: Access-Control-Request-Method<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] vary: Origin<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds]<br>09:19.013 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] {“status”:200,”msg”:”操作成功！”,”success”:true,”data”:[{“id”:”200628AFYM7AGWPH”,”nickname”:”我是慕课网”,”face”:”<a target="_blank" rel="noopener" href="https://imooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/200628AFYM7AGWPH/2007088XH2WT7GXP.png&quot;,&quot;activeStatus&quot;:1,&quot;myFollowCounts&quot;:null,&quot;myFansCounts&quot;:null%7D]%7D">https://imooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/200628AFYM7AGWPH/2007088XH2WT7GXP.png&quot;,&quot;activeStatus&quot;:1,&quot;myFollowCounts&quot;:null,&quot;myFansCounts&quot;:null}]}</a><br>09:19.013 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] &lt;— END HTTP (286-byte body)<br>09:19.518 [PollingServerListUpdater-0] INFO  c.n.config.ChainedDynamicProperty - Flipping property: service-user.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit &#x3D; 2147483647<br>09:21.013 [scheduling-1] INFO  c.imooc.api.aspect.ServiceLogAspect - 开始执行 class com.imooc.article.service.impl.ArticleServiceImpl.updateAppointToPublish </p>
</blockquote>
<h3 id="阐述断路器及概念【hystrix】"><a href="#阐述断路器及概念【hystrix】" class="headerlink" title="阐述断路器及概念【hystrix】"></a>阐述断路器及概念【hystrix】</h3><h6 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h6><ul>
<li><strong>Hystrix</strong></li>
<li><strong>提供容错机制，避免微服务系统雪崩</strong></li>
</ul>
<h6 id="服务熔断与降级"><a href="#服务熔断与降级" class="headerlink" title="服务熔断与降级"></a>服务熔断与降级</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/397bfbaea5edddda83d11dce86c9e70cbac33f5c/data/hystrix%E6%96%AD%E8%B7%AF%E5%99%A8_%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7.png"></p>
<h3 id="模拟服务故障【hystrix】"><a href="#模拟服务故障【hystrix】" class="headerlink" title="模拟服务故障【hystrix】"></a>模拟服务故障【hystrix】</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口8001api</a>  同上<br>会报Timeout超时的异常</p>
</blockquote>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
   @Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;

    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        // 1.手动触发异常
        int a = 1/0;
        // 2.模拟超时异常
        try &#123;
            Thread.sleep(6000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;


        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="服务提供者熔断【hystrix】"><a href="#服务提供者熔断【hystrix】" class="headerlink" title="服务提供者熔断【hystrix】"></a>服务提供者熔断【hystrix】</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;
    // 添加熔断机制 一旦熔断会有替补方法[降级的方法]
    @HystrixCommand(fallbackMethod = &quot;queryByIdsFallback&quot;)
    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        // 1.手动触发异常
        int a = 1/0;
        // 2.模拟超时异常
        try &#123;
            Thread.sleep(6000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;


    public GraceJSONResult queryByIdsFallback(String userIds) &#123;
        System.out.println(&quot;进入降级方法：queryByIdsFallback&quot;);

        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            // 手动构建空对象，详情页所展示的用户信息可有可无 返回空对象
            AppUserVO userVO = new AppUserVO();
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient   // 开启eureka client 注册到server中
@EnableCircuitBreaker // 开启hystrix的熔断机制
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
===============================================================
进入降级方法
</code></pre>
<pre><code class="yaml">service-user  application.yml
#  配置hystrix
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000   # 设置hystrix超时时间，超过2秒触发降级
</code></pre>
<h3 id="全局降级【hystrix】"><a href="#全局降级【hystrix】" class="headerlink" title="全局降级【hystrix】"></a>全局降级【hystrix】</h3><blockquote>
<p>只需要return一个错误就行了没必要100个方法写100个降级<br>{</p>
<p>​    status: 555,<br>​    msg: “”全局降级：系统繁忙，请稍后再试！””<br>​    success: false,<br>​    data: null</p>
<p>}</p>
</blockquote>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)
public class UserController extends BaseController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    // 其他方法一旦发现异常就会进入这个方法里面 全局唯一 其他的降级方法要注释
    public GraceJSONResult defaultFallback()&#123;
        return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_GLOBAL);
    &#125;
......
&#125;
</code></pre>
<pre><code class="java">// 改动是为了不报错空指针异常 因为已经变成了全局降级  降级的错误信息要调整
    @Autowired
    private UserControllerApi userControllerApi;
    //面向接口 UserControllerApi
    // 发起远程调用，获得用户的基本信息
   /* private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
GraceJSONResult bodyResult = userControllerApi.queryByIds(JsonUtils.objectToJson(idSet)); 
List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;*/ else &#123;
            publisherList = new ArrayList&lt;&gt;();
        &#125;
        return publisherList;
    &#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/grace/result/ResponseStatusEnum.java
 // 系统错误，未预期的错误 555
    SYSTEM_ERROR(555, false, &quot;系统繁忙，请稍后再试！&quot;),
    SYSTEM_OPERATION_ERROR(556, false, &quot;操作失败，请重试或联系管理员&quot;),
    SYSTEM_RESPONSE_NO_INFO(557, false, &quot;&quot;),
    SYSTEM_ERROR_GLOBAL(558, false, &quot;全局降级：系统繁忙，请稍后再试！&quot;),
    SYSTEM_ERROR_FEIGN(559, false, &quot;客户端Feign降级：系统繁忙，请稍后再试！&quot;),
    SYSTEM_ERROR_ZUUL(560, false, &quot;请求系统过于繁忙，请稍后再试！&quot;);
</code></pre>
<h3 id="服务调用者降级【hystrix】"><a href="#服务调用者降级【hystrix】" class="headerlink" title="服务调用者降级【hystrix】"></a>服务调用者降级【hystrix】</h3><pre><code class="yaml">service-article  application.yml
# 配置feign
feign:
  client:
    config:
      # 配置服务提供方的名称
      service-user:
        logger-level: full

  hystrix:  #打开feign客户端的内置hystrix
    enabled: true
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java //【增加一个@EnableHystrix】
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
@EnableFeignClients(&#123;&quot;com.imooc&quot;&#125;)
@EnableHystrix
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
====================================================================================
service-article:8001  进入客户端(服务调用者)的降级方法
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java//【@FeignClient增加fallbackFactory】
package com.imooc.api.controller.user;

import com.imooc.api.config.MyServiceList;
import com.imooc.api.controller.user.fallbacks.UserControllerFactoryFallback;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;) //fallbackFactory所有方法的降级
@FeignClient(value = MyServiceList.SERVICE_USER, fallbackFactory = UserControllerFactoryFallback.class ) //作为客户端直接调用
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

//    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
//    @PostMapping(&quot;/updateUserInfo&quot;)
//    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
//                                          @RequestParam BindingResult result);
    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO);


    @ApiOperation(value = &quot;根据用户的ids查询用户列表&quot;,notes = &quot;根据用户的ids查询用户列表&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/queryByIds&quot;)
    public GraceJSONResult queryByIds(@RequestParam String userIds);
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/fallbacks/UserControllerFactoryFallback.java
package com.imooc.api.controller.user.fallbacks;

import com.imooc.api.controller.user.UserControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.pojo.vo.AppUserVO;
import feign.hystrix.FallbackFactory;
import org.springframework.stereotype.Component;

import javax.validation.Valid;
import java.util.ArrayList;
import java.util.List;

@Component //这个类让容器加载
public class UserControllerFactoryFallback implements FallbackFactory&lt;UserControllerApi&gt; &#123;
    @Override
    public UserControllerApi create(Throwable throwable) &#123;
 // 重写的过程就是降级的过程
        return new UserControllerApi() &#123;
            //SYSTEM_ERROR_FEIGN(559, false, &quot;客户端Feign降级：系统繁忙，请稍后再试！&quot;)
            @Override
            public GraceJSONResult getUserInfo(String userId) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_FEIGN);
            &#125;

            @Override
            public GraceJSONResult getAccountInfo(String userId) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_FEIGN);
            &#125;

            @Override
            public GraceJSONResult updateUserInfo(@Valid UpdateUserInfoBO updateUserInfoBO) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_FEIGN);
            &#125;

            @Override
            public GraceJSONResult queryByIds(String userIds) &#123;
                System.out.println(&quot;进入客户端(服务调用者)的降级方法&quot;);
                List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
                return GraceJSONResult.ok(publisherList);
            &#125;
        &#125;;
    &#125;
&#125;
</code></pre>
<h3 id="自动触发熔断隔离与恢复【hystrix】"><a href="#自动触发熔断隔离与恢复【hystrix】" class="headerlink" title="自动触发熔断隔离与恢复【hystrix】"></a>自动触发熔断隔离与恢复【hystrix】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/c67b7337984e7ad3913d8d161ec90de36aba38a8/data/%E7%86%94%E6%96%AD%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<pre><code class="yaml">service-user  application.yml #【配置熔断器】
#  配置hystrix
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000   # 设置hystrix超时时间，超过2秒触发降级
      circuitBreaker:   # 配置断路器
        enabled: true
        requestVolumeThreshold: 10    # 触发熔断最小请求次数，默认：20
        sleepWindowInMilliseconds: 15000    # 熔断后过几秒后尝试半开状态（请求重试），默认：5s
        errorThresholdPercentage: 50  # 触发熔断的失败率（异常率/阈值），默认：50
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java //[FIXME:]
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;
    // 添加熔断机制 一旦熔断会有替补方法[降级的方法]
    @HystrixCommand//(fallbackMethod = &quot;queryByIdsFallback&quot;)
    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        // 1.手动触发异常
        int a = 1/0;
        // 2.模拟超时异常
        try &#123;
            Thread.sleep(6000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;


        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        // FIXME: 仅用于dev测试，硬编码动态判断来抛出异常
        if (userIdList.size() &gt; 1)&#123;
            System.out.println(&quot;出现异常~~&quot;);
            throw new RuntimeException(&quot;出现异常~~&quot;);
        &#125;

        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<h3 id="微服务网关【zuul】维护微服务的ip地址"><a href="#微服务网关【zuul】维护微服务的ip地址" class="headerlink" title="微服务网关【zuul】维护微服务的ip地址"></a>微服务网关【zuul】<del>维护微服务的ip地址</del></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/56aa521f01816d47174142d710bde78e0f31fd7e/data/%E5%BE%AE1%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3.png"></p>
<h5 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h5><ul>
<li>Zuul (祖尔)</li>
<li>微服务的网关，可以实现动态路由、过滤器等功能</li>
</ul>
<h3 id="构建网关微服务【zuul】"><a href="#构建网关微服务【zuul】" class="headerlink" title="构建网关微服务【zuul】"></a>构建网关微服务【zuul】</h3><pre><code class="java">springcloud-zuul-server  com/imooc/zuul/Application.java
@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
//@EnableZuulServer
@EnableZuulProxy      // @EnableZuulProxy是@EnableZuulServer的一个增强升级版，当zuul和eureka、ribbon等组件共同使用，则使用增强版即可
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;

&#125;
</code></pre>
<pre><code class="xml">springcloud-zuul-server  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/springcloud-zuul&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/zuul.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/logger&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">springcloud-zuul-server  pom.xml 【exclusions是重点】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-zuul-server&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除包--&gt;
                &lt;exclusions&gt;
                    &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--&lt;dependency&gt;--&gt;
        &lt;!--&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;
        &lt;!--&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;--&gt;
        &lt;!--&lt;/dependency&gt;--&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yml">springcloud-zuul-server  application.yml 
############################################################
#
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server

  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1
</code></pre>
<pre><code class="java">zuul-server  com/imooc/zuul/controller/HelloController.java
package com.imooc.zuul.controller;

import com.imooc.grace.result.GraceJSONResult;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<h3 id="配置路由【zuul】"><a href="#配置路由【zuul】" class="headerlink" title="配置路由【zuul】"></a>配置路由【zuul】</h3><pre><code class="yaml">zuul-server  application.yml
# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
      path: /service-article/**       # 请求路径(前缀)
      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
</code></pre>
<pre><code class="yaml">localhost:8001/portal/article/detail?articleId=2006117B57WRZGHH
直接可以访问到详情数据
微服务网关→ 7070
// service-article: /service-article/** # 请求路径(前缀**)
# localhost:7070/service-article/portal/detail?articleId=2006117B57WRZGHH

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
      path: /service-article/**       # 请求路径(前缀)
      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀
# localhost:7070/api/service-article/portal/detail?articleId=2006117B57WRZGHH
</code></pre>
<h3 id="配置微服务实例的路由【zuul】"><a href="#配置微服务实例的路由【zuul】" class="headerlink" title="配置微服务实例的路由【zuul】"></a>配置微服务实例的路由【zuul】</h3><pre><code class="yaml">在路由规则里面的  url: http://192.168.1.2:8001  很容易发生变化
所以直接去请求eureka的SERVICE-USER/ARTICLE
</code></pre>
<pre><code class="xml">springcloud-zuul-server  pom.xml 【取消exclusions注释 包含eureka client】
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除包--&gt;
          &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="java">springcloud-zuul-server  com/imooc/zuul/Application.java 【打开@EnableEurekaClient】
@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@EnableZuulServer
@EnableZuulProxy      // @EnableZuulProxy是@EnableZuulServer的一个增强升级版，当zuul和eureka、ribbon等组件共同使用，则使用增强版即可
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">zuul-server  application.yml 【实现service-id进行请求转发 ip发生变化没有关系】
# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
      service-article:                  # 配置微服务的路由id，微服务的实例id
      path: /service-article/**       # 请求路径(前缀)
      service-id: service-article     # 请求转发的微服务实例id
#     url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀

↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 简化版本 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀
</code></pre>
<h3 id="过滤器【zuul】网端ip黑名单拦截"><a href="#过滤器【zuul】网端ip黑名单拦截" class="headerlink" title="过滤器【zuul】网端ip黑名单拦截"></a>过滤器【zuul】<del>网端ip黑名单拦截</del></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/3cb9704aa86555cd937cb6b045ace81a44ec3dbd/data/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84.png"></p>
<pre><code class="java">zuul-server  com/imooc/zuul/filters/MyFilter.java
package com.imooc.zuul.filters;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.stereotype.Component;

/**
 * 构建zuul的自定义过滤器
 */
@Component
public class MyFilter extends ZuulFilter &#123;

    /**
     * 定义过滤器的类型
     *      pre：    在请求被路由之前执行
     *      route：  在路由请求的时候执行
     *      post：   请求路由以后执行
     *      error：  处理请求时发生错误的时候执行
     * @return
     */
    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    /**
     * 过滤器执行的顺序，配置多个有顺序的过滤
     * 执行顺序从小到大
     * @return
     */
    @Override
    public int filterOrder() &#123;
        return 1;
    &#125;

    /**
     * 是否开启过滤器
     *      true：开启
     *      false：禁用
     * @return
     */
    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;

    /**
     * 过滤器的业务实现
     * @return
     * @throws ZuulException
     */
    @Override
    public Object run() throws ZuulException &#123;

        System.out.println(&quot;display pre zuul filter...&quot;);

        return null;    // 没有意义可以不用管。
    &#125;
&#125;
</code></pre>
<blockquote>
<p> localhost:7070&#x2F;api&#x2F;service-article&#x2F;portal&#x2F;detail?articleId&#x3D;2006117B57WRZGHH<br>刷新成功后 在zuul-7070服务console会有一行<br>display pre zuul filter… [启动成功]</p>
</blockquote>
<h3 id="限制ip黑名单的频繁请求【zuul】"><a href="#限制ip黑名单的频繁请求【zuul】" class="headerlink" title="限制ip黑名单的频繁请求【zuul】"></a>限制ip黑名单的频繁请求【zuul】</h3><pre><code class="yaml">zuul-server  application.yml 【增加ip请求限制的参数配置】
# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
      service-article:                  # 配置微服务的路由id，微服务的实例id
      path: /service-article/**       # 请求路径(前缀)
      service-id: service-article     # 请求转发的微服务实例id
#     url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀

↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 简化版本 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀

# ip请求限制的参数配置
blackIp:
  continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
  timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
  limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
</code></pre>
<pre><code class="java">zuul-server  com/imooc/zuul/filters/BlackIPFilter.java
package com.imooc.zuul.filters;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
/* application.yml
*  blackIp:
   continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
   timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
   limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
* */
@Component
@RefreshScope
public class BlackIPFilter extends ZuulFilter &#123;

    @Value(&quot;$&#123;blackIp.continueCounts&#125;&quot;)
    public Integer continueCounts;
    @Value(&quot;$&#123;blackIp.timeInterval&#125;&quot;)
    public Integer timeInterval;
    @Value(&quot;$&#123;blackIp.limitTimes&#125;&quot;)
    public Integer limitTimes;

    @Autowired
    private RedisOperator redis;

    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 2;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;

    @Override
    public Object run() throws ZuulException &#123;

        System.out.println(&quot;执行【ip黑名单】过滤器...&quot;);

        System.out.println(&quot;continueCounts: &quot; + continueCounts);
        System.out.println(&quot;timeInterval: &quot; + timeInterval);
        System.out.println(&quot;limitTimes: &quot; + limitTimes);


        // 获得上下文对象
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();

        // 获得ip
        String ip = IPUtil.getRequestIp(request);

        /**
         * 需求：
         *  判断ip在10秒内的请求次数是否超过10次
         *  如果超过，则限制这个ip访问15秒，15秒以后再放行
         */

        final String ipRedisKey = &quot;zuul-ip:&quot; + ip;
        final String ipRedisLimitKey = &quot;zuul-ip-limit:&quot; + ip;

        // 获得当前ip这个key的剩余时间
        long limitLeftTime = redis.ttl(ipRedisLimitKey);
        // 如果当前限制ip的key还存在剩余时间，说明这个ip不能访问，继续等待
        if (limitLeftTime &gt; 0) &#123;
            stopRequest(context);
            return null;
        &#125;

        // 在redis中累加ip的请求访问次数
        long requestCounts = redis.increment(ipRedisKey, 1);
        // 从0开始计算请求次数，初期访问为1，则设置过期时间，也就是连续请求的间隔时间
        if (requestCounts == 1) &#123;
            redis.expire(ipRedisKey, timeInterval);
        &#125;

        // 如果还能取得请求次数，说明用户连续请求的次数落在10秒内
        // 一旦请求次数超过了连续访问的次数，则需要限制这个ip的访问
        if (requestCounts &gt; continueCounts) &#123;
            // 限制ip的访问时间
            redis.set(ipRedisLimitKey, ipRedisLimitKey, limitTimes);
            stopRequest(context);
        &#125;

        return null;
    &#125;

    private void stopRequest(RequestContext context) &#123;
        // 停止zuul继续向下路由，禁止请求通信
        context.setSendZuulResponse(false);
        context.setResponseStatusCode(200);
        String result = JsonUtils.objectToJson(
                GraceJSONResult.errorCustom(
                        ResponseStatusEnum.SYSTEM_ERROR_ZUUL));
        context.setResponseBody(result);
        context.getResponse().setCharacterEncoding(&quot;utf-8&quot;);
        context.getResponse().setContentType(MediaType.APPLICATION_JSON_VALUE);
    &#125;
&#125;

=============================================================================
dev-common  com/imooc/grace/result/ResponseStatusEnum.java
SYSTEM_ERROR_ZUUL(560, false, &quot;请求系统过于繁忙，请稍后再试！&quot;);
</code></pre>
<pre><code class="yaml">zuul-server  application.yml 【把redis增加进来】
############################################################
#
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server

  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀



# ip请求限制的参数配置
blackIp:
  continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
  timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
  limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
</code></pre>
<blockquote>
<p>此时redis中会出现<br>zuul-ip(1) → zuul-ip  → Value:1<br>zuul-ip-limit(1) → zuul-ip-limit: 本机地址<br>在zuul-7070服务里的Console 显示：<br>display pre zuul filter …<br>执行【ip黑名单】过滤器…</p>
</blockquote>
<h3 id="分布式配置中心【config】"><a href="#分布式配置中心【config】" class="headerlink" title="分布式配置中心【config】"></a>分布式配置中心【config】</h3><ul>
<li><strong>SpringCloud Config</strong></li>
<li><strong>为所有服务提供统一的配置管理服务</strong><del>微服务配置一下子全部生效</del></li>
<li><strong>包含配置服务端与配置客户端</strong></li>
</ul>
<h5 id="配置中心的功能"><a href="#配置中心的功能" class="headerlink" title="配置中心的功能"></a>配置中心的功能</h5><ul>
<li><strong>统一管理配置</strong></li>
<li><strong>管理不同环境下的配置</strong></li>
<li><strong>动态调整配置</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b1fb9d3f444bf78ad6621441538f809d208f8c1a/data/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.png"></p>
<h3 id="搭配配置中心【config】"><a href="#搭配配置中心【config】" class="headerlink" title="搭配配置中心【config】"></a>搭配配置中心【config】</h3><p><a target="_blank" rel="noopener" href="https://github.com/leechenxiang/imooc-news-config/tree/master">leechenxiang&#x2F;imooc-news-config (github.com)</a></p>
<pre><code class="yaml">zuul-dev.yml
blackIp:
  continueCounts: 10
  timeInterval: 10
  limitTimes: 15

zuul-prod.yml
blackIp:
  continueCounts: 40
  timeInterval: 70
  limitTimes: 315
</code></pre>
<pre><code class="xml">springcloud-config  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-config&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">springcloud-config  com/imooc/config/Application.java
package com.imooc.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.config.server.EnableConfigServer;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
==========================================================================
config-7080
</code></pre>
<pre><code class="yaml">springcloud-config  application.yml
############################################################
#
# 配置服务Config
# web访问端口号  约定：7080
#
############################################################
server:
  port: 7080
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-config
  
  rabbitmq:
    host: 192.168.1.204
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/


# 配置动态刷新git配置的路径终端请求地址
management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;
</code></pre>
<pre><code class="xml">springcloud-config  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/springcloud-config&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/config.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">springcloud-config  com/imooc/config/controller/HelloController.java
package com.imooc.config.controller;

import com.imooc.grace.result.GraceJSONResult;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<h3 id="配置中心实现git配置读取【config】"><a href="#配置中心实现git配置读取【config】" class="headerlink" title="配置中心实现git配置读取【config】"></a>配置中心实现git配置读取【config】</h3><pre><code class="xml">springcloud-config  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-config&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yaml">springcloud-config  application.yml
#增加  cloud:config:server:git: uri
############################################################
#
# 配置服务Config
# web访问端口号  约定：7080
#
############################################################
server:
  port: 7080
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-config
  cloud:
    config:
      server:
        git:
          uri: https://github.com/leechenxiang/imooc-news-config.git
  rabbitmq:
    host: 192.168.1.204
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="java">springcloud-config  com/imooc/config/Application.java
package com.imooc.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.config.server.EnableConfigServer;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
@EnableConfigServer //开启这个配置中心
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/leechenxiang/imooc-news-config/tree/master">leechenxiang&#x2F;imooc-news-config (github.com)</a></p>
<blockquote>
<p>localhost:7080&#x2F;zuul-prod.yml    这里直接引用了github上面的yml<br>localhost:7080&#x2F;master&#x2F;zuul-prod.yml   </p>
</blockquote>
<pre><code class="yaml">zuul-dev.yml
blackIp:
  continueCounts: 10
  timeInterval: 10
  limitTimes: 15

zuul-prod.yml
blackIp:
  continueCounts: 40
  timeInterval: 70
  limitTimes: 315
</code></pre>
<h3 id="配置客户端拉取配置"><a href="#配置客户端拉取配置" class="headerlink" title="配置客户端拉取配置"></a>配置客户端拉取配置</h3><pre><code class="xml">zuul-server  pom.xml
         &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server  resources/bootstrap.yml
############################################################
# 系统全局加载文件 先加载这个文件
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server
  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  cloud:
    config:
      label: master # github上的分支
      name: zuul # 定义的服务
      profile: prod  # 所加载的环境变量
#      uri: http://192.168.1.2:7080
      discovery:
        enabled: true
        service-id: springcloud-config


############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/**
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址
  prefix: /api                        # 请求前缀
</code></pre>
<pre><code class="java">启动zuul-7070  //客户端连接config(server)并且动态获得了github的数据
打印控制台Console
display pre zuul filter...
执行【ip黑名单】过滤器...
// zuul-prod.yml
  continueCounts: 40
  timeInterval: 70
  limitTimes: 315
</code></pre>
<h3 id="动态刷新git配置"><a href="#动态刷新git配置" class="headerlink" title="动态刷新git配置"></a>动态刷新git配置</h3><pre><code class="java">// zuul-prod.yml 动态修改数值
  continueCounts: 35
  timeInterval: 305
  limitTimes: 65
在浏览器会显示更新后的数值 但是在console打印台不会显示改后的 只会显示之前的
需要重启服务才可以达到修改后的效果 显示修改的数值
</code></pre>
<pre><code class="xml">zuul-server  pom.xml
添加健康检测的配置
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">zuul-server  com/imooc/zuul/filters/BlackIPFilter.java
//【开启刷新 @RefreshScope 不能全自动 需要触碰某些请求 在yaml配置动态刷新的地址】
package com.imooc.zuul.filters;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
/* application.yml
*  blackIp:
   continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
   timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
   limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
* */
@Component
@RefreshScope
public class BlackIPFilter extends ZuulFilter &#123;

    @Value(&quot;$&#123;blackIp.continueCounts&#125;&quot;)
    public Integer continueCounts;
    @Value(&quot;$&#123;blackIp.timeInterval&#125;&quot;)
    public Integer timeInterval;
    @Value(&quot;$&#123;blackIp.limitTimes&#125;&quot;)
    public Integer limitTimes;

    @Autowired
    private RedisOperator redis;

    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 2;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">zuul-server  bootstrap.yml  +  springcloud-config  application.yaml
# 配置动态刷新git配置的路径终端请求地址 只需要通过URL请求不用重启就可以自动刷新 后期要通过脚本运行才可【通过请求处理 postman → POST → https://localhost:7070/actuator/refresh】
management:
  endpoints:
    web:
      exposure:
        include: refresh
# 此时回到console就可以有更新后的数据显示了
</code></pre>
<h3 id="消息总线概述【bus】-RabbitMQ"><a href="#消息总线概述【bus】-RabbitMQ" class="headerlink" title="消息总线概述【bus】[RabbitMQ]"></a>消息总线概述【bus】<del>[RabbitMQ]</del></h3><h5 id="Config遗留问题"><a href="#Config遗留问题" class="headerlink" title="Config遗留问题"></a>Config遗留问题</h5><ul>
<li><strong>手动刷新与业务耦合</strong> [也可能在文章&#x2F;user模块发生]</li>
<li>Config配置中心的刷新去解决动态刷新</li>
<li><strong>N个微服务端需要N次手动书信</strong></li>
</ul>
<h5 id="消息总线-要和config与微服务端进行配置"><a href="#消息总线-要和config与微服务端进行配置" class="headerlink" title="消息总线(要和config与微服务端进行配置)"></a>消息总线<del>(要和config与微服务端进行配置)</del></h5><ul>
<li><strong>SpringCloud Bus</strong></li>
<li>为SpringCloud Config提供增益buff</li>
<li><strong>可以实现配置自动刷新</strong>[1k个 1w个]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5fc0f342c2ab14a5e7e3aa9869b97348c7ed39ed/data/%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0.jpg"></p>
<h3 id="配置实现消息统一发送【bus】"><a href="#配置实现消息统一发送【bus】" class="headerlink" title="配置实现消息统一发送【bus】"></a>配置实现消息统一发送【bus】</h3><blockquote>
<p>config把消息推給zull-server</p>
</blockquote>
<pre><code class="xml">springcloud-config  pom.xml    ＋    zuul-server  pom.xml
    &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server  resources/bootstrap.yaml  +  springcloud-config  application.yaml
  rabbitmq:
    host: 192.168.1.204
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev
</code></pre>
<blockquote>
<p>实现刷新server端达到所有的刷新配置<br>【通过请求处理 postman → POST → <a target="_blank" rel="noopener" href="https://localhost:7080/actuator/bus-refresh%E3%80%91">https://localhost:7080/actuator/bus-refresh】</a><br>若想精确刷新某个服务 需要拼接<br> postman → POST → <a target="_blank" rel="noopener" href="https://localhost:7080/actuator/bus-refresh/%7B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E4%BE%8Bid%7D:%7Bport%7D">https://localhost:7080/actuator/bus-refresh/{微服务的实例id}:{port}</a><br>微服务实例id是yaml配置项目信息 → spring.application.name：springcloud-zuul-server<br><a target="_blank" rel="noopener" href="https://localhost:7080/actuator/bus-refresh/springcloud-zuul-server:7070">https://localhost:7080/actuator/bus-refresh/springcloud-zuul-server:7070</a> 【目标微服务地址实现精确打击】</p>
</blockquote>
<h3 id="消息驱动概述【stream】"><a href="#消息驱动概述【stream】" class="headerlink" title="消息驱动概述【stream】"></a>消息驱动概述【stream】</h3><h5 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h5><ul>
<li><strong>SpringCloud Stream</strong></li>
<li><strong><span style = "color:red">统一封装消息的服务框架</span></strong></li>
<li>RabbitMQ，RocketMQ，Kafka，ActiveMQ，ZeroMQ，…</li>
</ul>
<h5 id="Stream消息模型"><a href="#Stream消息模型" class="headerlink" title="Stream消息模型"></a>Stream消息模型</h5><img src="https://raw.githubusercontent.com/P-luminary/images/995964c627f628ee94ebb76bbbe6fe7872884f32/data/Stream%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B.png" style="zoom:80%;" />



<h3 id="实现消费者与生产者【stream】"><a href="#实现消费者与生产者【stream】" class="headerlink" title="实现消费者与生产者【stream】"></a>实现消费者与生产者【stream】</h3><blockquote>
<p>将zuul-server的resources&#x2F;application.yml 恢复到原来配置</p>
</blockquote>
<pre><code class="yaml">############################################################
#
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server

  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀



# ip请求限制的参数配置
blackIp:
  continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
  timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
  limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
</code></pre>
<pre><code class="xml">service-article  pom.xml  +  service-user  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
            &lt;version&gt;4.1.1&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">service-article  application.yaml      +      service-user  application.yaml
    cloud:
    stream:
      bindings:                    # 绑定通道和交换机
        myOutput:                   # 定义生产者的通道
          # 自定义交换机的名字，也就是代码里构建的信息，交给底层mq的交换机
          destination:
        myInput:                    # 定义消费者通道
          # 自定义交换机的名字，也就是消息从底层mq输入到消费端进行消费
          destination:
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamChannel.java
package com.imooc.article.stream;

import org.springframework.cloud.stream.annotation.Input;
import org.springframework.cloud.stream.annotation.Output;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.stereotype.Component;

/**
 * 声明构建通道channel
 */
@Component
public interface MyStreamChannel &#123;

    String OUTPUT = &quot;myOutput&quot;;
    String INPUT = &quot;myInput&quot;;

    @Output(MyStreamChannel.OUTPUT)
    MessageChannel output();

    @Input(MyStreamChannel.INPUT)
    SubscribableChannel input();  //订阅能力的通道
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamChannel.java
package com.imooc.article.stream;


import org.springframework.cloud.stream.annotation.Input;
import org.springframework.cloud.stream.annotation.Output;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.stereotype.Component;

/**
 * 声明构建通道channel
 */
@Component
public interface MyStreamChannel &#123;
    String OUTPUT = &quot;myOutput&quot;;
    String INPUT = &quot;myInput&quot;;

    @Output(MyStreamChannel.OUTPUT)
    MessageChannel output();

    @Input(MyStreamChannel.INPUT)
    SubscribableChannel input();
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamService.java
package com.imooc.article.stream;

public interface StreamService &#123;
    public void sendMsg();
    public void eat(String dumpling);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamServiceImpl.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

/**
 * 开启绑定器
 * 绑定通道channel
 */
@Component
@EnableBinding(MyStreamChannel.class)
public class StreamServiceImpl implements StreamService &#123;

    @Autowired
    private MyStreamChannel myStreamChannel;

    @Override
    public void sendMsg() &#123;
        AppUser user = new AppUser();
        user.setId(&quot;10101&quot;);
        user.setNickname(&quot;imooc&quot;);

        // 消息通过绑定器发送给mq
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(user).build());
    &#125;

    @Override
    public void eat(String dumpling) &#123;
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(dumpling).build());
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamConsumer.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.stereotype.Component;

/**
 * 构建消费端
 */
@Component
@EnableBinding(MyStreamChannel.class) //开启通道绑定
public class MyStreamConsumer &#123;

    /**
     * 监听并且实现消息的消费和相关业务处理
     */
    @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(AppUser user) &#123;
        System.out.println(user.toString());
    &#125;

    @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(String dumpling) &#123;
        System.out.println(dumpling);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private StreamService streamService;

    @GetMapping(&quot;/stream&quot;)
    public Object stream() &#123;
        streamService.sendMsg();

        for (int i = 0 ; i &lt; 10 ; i ++ ) &#123;
            streamService.eat(&quot;我吃了第&quot; + (i+1) + &quot;只饺子~&quot;);
        &#125;

        return &quot;ok~~!!!&quot;;
    &#125;
</code></pre>
<h3 id="消息分组与持久化【stream】"><a href="#消息分组与持久化【stream】" class="headerlink" title="消息分组与持久化【stream】"></a>消息分组与持久化【stream】</h3><blockquote>
<p>避免重复消费  分组group 组内消费者不会重复消费</p>
</blockquote>
<h5 id="Stream消息分组"><a href="#Stream消息分组" class="headerlink" title="Stream消息分组"></a>Stream消息分组</h5><pre><code class="yaml">service-article  application.yml  
  cloud:
    stream:
      bindings:                    # 绑定通道和交换机
        myOutput:                   # 定义生产者的通道
          # 自定义交换机的名字，也就是代码里构建的信息，交给底层mq的交换机
          destination:
        myInput:                    # 定义消费者通道
          # 自定义交换机的名字，也就是消息从底层mq输入到消费端进行消费
          destination:
          group: boys

------------------------------------------------------------------------------

service-user  application.yml
  cloud:
    stream:
      bindings: # 绑定通道和交换机
        myOutput: # 定义生产者的通道
          # 自定义交换机的名字，也就是代码里构建的信息，交给底层mq的交换机
          destination:
        myInput: # 定义消费者通道
          # 自定义交换机的名字，也就是消息从底层mq输入到消费端进行消费
          destination:
          group: girls
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamService.java
package com.imooc.article.stream;

public interface StreamService &#123;
  //public void sendMsg();
    public void eat(String dumpling);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamServiceImpl.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

/**
 * 开启绑定器
 * 绑定通道channel
 */
@Component
@EnableBinding(MyStreamChannel.class)
public class StreamServiceImpl implements StreamService &#123;

    @Autowired
    private MyStreamChannel myStreamChannel;

    @Override
 /* public void sendMsg() &#123;
        AppUser user = new AppUser();
        user.setId(&quot;10101&quot;);
        user.setNickname(&quot;imooc&quot;);

        // 消息通过绑定器发送给mq
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(user).build());
    &#125; */

    @Override
    public void eat(String dumpling) &#123;
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(dumpling).build());
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamConsumer.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.stereotype.Component;

/**
 * 构建消费端
 */
@Component
@EnableBinding(MyStreamChannel.class) //开启通道绑定
public class MyStreamConsumer &#123;

    /**
     * 监听并且实现消息的消费和相关业务处理
     */
 /* @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(AppUser user) &#123;
        System.out.println(user.toString());
    &#125; */

    @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(String dumpling) &#123;
        System.out.println(dumpling);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private StreamService streamService;

    @GetMapping(&quot;/stream&quot;)
    public Object stream() &#123;
     // streamService.sendMsg();

        for (int i = 0 ; i &lt; 10 ; i ++ ) &#123;
            streamService.eat(&quot;我吃了第&quot; + (i+1) + &quot;只饺子~&quot;);
        &#125;

        return &quot;ok~~!!!&quot;;
    &#125;
</code></pre>
<blockquote>
<p>消息不会被重复消费<br>service-article:8001   我吃了1-10只饺子~  【消费的饺子总数一共10次】<br>service-user:8003(女生) 我吃了1 3 5 7 9只饺子~    【饺子随机】<br>service-user:8013(男生) 我吃了2 4 6 8 10只饺子~  【饺子随机】</p>
<p>如果把service-user:8003(女生)  service-user:8013(男生) 服务stop 用户微服务无法接收任何消息<br>但是我们定义了group → 消息是可以持久化的 当重启用户微服务之后  就会打印出刚刚已经吃的饺子了<br>服务器宕机  &#x3D;  吃饺子中途去上厕所 回来后仍然还能吃到饺子</p>
</blockquote>
<h3 id="链路追踪概述与zipkin【sleuth】组件"><a href="#链路追踪概述与zipkin【sleuth】组件" class="headerlink" title="链路追踪概述与zipkin【sleuth】组件"></a>链路追踪概述与zipkin【sleuth】<del>组件</del></h3><h5 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h5><ul>
<li><strong>Sleuth</strong></li>
<li><strong>贯穿整个微服务系统中，追踪一个请求的过程</strong></li>
<li><strong>zipkin 可视化控制面板</strong></li>
</ul>
<blockquote>
<p>下载zipkin-server-2.12.6-exec.jar<br>CMD → C:\Users\Pluminary&gt;java -jar &#x2F;Users&#x2F;Pluminary&#x2F;Desktop&#x2F;zipkin-server-2.12.6-exec.jar<br><a target="_blank" rel="noopener" href="https://localhost:9411/zipkin/">https://localhost:9411/zipkin/</a></p>
</blockquote>
<h3 id="整合zipkin【sleuth】项目入口是网关"><a href="#整合zipkin【sleuth】项目入口是网关" class="headerlink" title="整合zipkin【sleuth】项目入口是网关"></a>整合zipkin【sleuth】<del>项目入口是网关</del></h3><pre><code class="xml">zuul-server  pom.xml  +  service-article  pom.xml  +  service-user  pom.xml
         &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server与service-article与service-user  application.yml
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://localhost:9411/zipkin/">https://localhost:9411/zipkin/</a></p>
</blockquote>
<h3 id="SpringCloud章节总结"><a href="#SpringCloud章节总结" class="headerlink" title="SpringCloud章节总结"></a>SpringCloud章节总结</h3><ul>
<li><strong>eureka 注册中心</strong></li>
<li><strong>ribbon 负载均衡</strong></li>
<li><strong>feign 声明式客户端</strong></li>
<li><strong>hystrix 熔断降级组件</strong></li>
<li><strong>zuul 网关</strong></li>
<li><strong>config 配置中心</strong></li>
<li><strong>bus 消息总线</strong></li>
<li><strong>stream 消息驱动</strong></li>
<li><strong>zipkin + sleuth 链路追踪</strong></li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/05/12/后端/Cloud分布式微服务打造大型自媒体3大业务平台/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/05/04/后端/Zookeeper-Dubbo应用与面试/">
        <h2>
            Zookeeper+Dubbo应用与面试
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/5/4
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Zookeeper-Dubbo与面试周介绍"><a href="#Zookeeper-Dubbo与面试周介绍" class="headerlink" title="Zookeeper+Dubbo与面试周介绍"></a>Zookeeper+Dubbo与面试周介绍</h1><ul>
<li>Zookeeper的下载、配置与运行</li>
<li>数据结构node与常用命令</li>
<li>Watcher机制和权限cal介绍</li>
<li>使用Zookeeper的Java原生客户端和Curator进行开发</li>
<li>RPC调用，在Dubbo架构下各服务的关系</li>
<li>整合Dubbo和Zookeeper</li>
<li>完成Dubbo开发案例</li>
<li>线程进阶面试</li>
<li>分布式、微服务面试题</li>
<li>Spring Cloud、Zookeeper的理解</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li>理解Zookeeper</li>
<li>安装、配置</li>
<li>节点znode</li>
<li>常用命令</li>
<li>Watcher机制</li>
<li>ACL权限控制</li>
<li>代码实操</li>
</ul>
<h3 id="理解Zookeeper"><a href="#理解Zookeeper" class="headerlink" title="理解Zookeeper"></a>理解Zookeeper</h3><ul>
<li>5大特点</li>
<li>集群架构</li>
<li>Zookeeper和CAP关系</li>
<li>Zookeeper作用</li>
</ul>
<h3 id="为什么需要Zookeeper"><a href="#为什么需要Zookeeper" class="headerlink" title="为什么需要Zookeeper"></a>为什么需要Zookeeper</h3><ul>
<li><p>用起来像<strong>单机</strong>但是又比单机更<strong>可靠</strong></p>
</li>
<li><p>leader在团队里的<strong>协调</strong>作用  </p>
</li>
<li><p>内存、单机 </p>
</li>
<li><p>集群、<strong>可靠</strong></p>
</li>
<li><p>当信息<strong>还没同步完成时，不对外提供服务</strong></p>
</li>
<li><p>同步的时间压缩的更短</p>
</li>
</ul>
<h3 id="Zookeeper诞生历史"><a href="#Zookeeper诞生历史" class="headerlink" title="Zookeeper诞生历史"></a>Zookeeper诞生历史</h3><p>雅虎研究室</p>
<ul>
<li>无单点问题的<strong>分布式协调架构</strong>，精力集中在处理业务逻辑</li>
<li>内部很多项目都是使用动物的名字来命名</li>
<li>大型动物园</li>
</ul>
<h3 id="Zookeeper是什么-底层是Java"><a href="#Zookeeper是什么-底层是Java" class="headerlink" title="Zookeeper是什么 [底层是Java]"></a>Zookeeper是什么 [底层是Java]</h3><ul>
<li>Zookeeper是<strong>开源的高性能的分布式应用协调系统</strong>，一个高性能的分布式数据一致性解决方案</li>
</ul>
<h3 id="5大特点"><a href="#5大特点" class="headerlink" title="5大特点"></a>5大特点</h3><ul>
<li>顺序一致性</li>
<li>原子性 [全部成功或者全部不成功]</li>
<li>单一视图 [无论连接哪个 都是一致的信息]</li>
<li>可靠性</li>
<li>及时性 [一定时间内能从服务器读到状态]</li>
</ul>
<h5 id="架构图、集群、工作过程"><a href="#架构图、集群、工作过程" class="headerlink" title="架构图、集群、工作过程"></a>架构图、集群、工作过程</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/b25f2311da13cf23726ffd71545a05cdc2630f95/data/zookeeper%E6%9E%B6%E6%9E%84%E5%9B%BE%E3%80%81%E9%9B%86%E7%BE%A4%E3%80%81%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.jpg"></p>
<h3 id="Zookeeper和CAP的关系"><a href="#Zookeeper和CAP的关系" class="headerlink" title="Zookeeper和CAP的关系"></a>Zookeeper和CAP的关系</h3><ul>
<li>CP：一致性+分区容错性</li>
<li>能<strong>得到一致的数据结果</strong>，同时系统对网络具备容错性</li>
<li>但是它不能保证每次服务请求的可用性</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>分布式服务注册与订阅</li>
<li>统一配置文件</li>
<li>生成分布式唯一ID [&#x2F;order-0000001、&#x2F;order-0000002]</li>
<li>Master节点选举</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/96130bcb29ba40dee3d21543e5d7b46f33ad9920/data/Zookeeper%E7%89%B9%E7%82%B9.jpg"></p>
<h5 id="针对不能同时进行写数据，保证互斥同步-→-分布式锁"><a href="#针对不能同时进行写数据，保证互斥同步-→-分布式锁" class="headerlink" title="针对不能同时进行写数据，保证互斥同步 → 分布式锁"></a>针对不能同时进行写数据，保证互斥同步 → 分布式锁</h5><h3 id="Zookeeper的安装、配置"><a href="#Zookeeper的安装、配置" class="headerlink" title="Zookeeper的安装、配置"></a>Zookeeper的安装、配置</h3><ul>
<li>寻找教辅里的<code>apache-zookeeper-3.6.0-bin.tar</code></li>
<li>解压压缩包：<code>tar zxvf apache-zookeeper-3.6.0-bin.tar.gz</code></li>
<li>进入压缩包：<code>cd apache-zookeeper-3.6.0-bin</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ls
bin  conf  docs  lib  LICENSE.txt  NOTICE.txt  README.md README_packaging.md
</code></pre>
<ul>
<li>配置[进入文件]：<code>cp conf/zoo_sample.cfg conf/zoo</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# cp conf/zoo_sample.cfg conf/zoo
[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ls conf/
configuration.xsl  log4j.properties  zoo  zoo.cfg  zoo_sample.cfg
</code></pre>
<ul>
<li>打开文件, 进行修改：<code>vi conf/zoo.cfg</code></li>
</ul>
<pre><code class="java">找到 dataDir=/tmp/zookeeper
修改成 dataDir=/tmp/lib/zookeeper 以免被自动清除
</code></pre>
<ul>
<li>启动：<code>./bin/zkServer.sh start</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... already running as process 1877.
======================================================================
[root@iZbp1dssknxftmjczbtpndZ bin]# ./zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... ^[[ASTARTED
[root@iZbp1dssknxftmjczbtpndZ bin]# ./zkServer.sh status
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Client port found: 2181. Client address: localhost.
Mode: standalone
======================================================================
</code></pre>
<ul>
<li>停止：<code>./bin/zkServer.sh stop</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh stop
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Stopping zookeeper ... STOPPED
</code></pre>
<h3 id="znode节点-基本数据模型"><a href="#znode节点-基本数据模型" class="headerlink" title="znode节点 [基本数据模型]"></a>znode节点 [基本数据模型]</h3><ul>
<li><h5 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h5></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/15f1b158dfd61ad9498e5febc8d809e4dcb7f0af/data/Znode%E8%8A%82-%20%E6%A0%91%E5%BD%A2%E5%9B%BE.jpg"></p>
<h5 id="节点性质"><a href="#节点性质" class="headerlink" title="节点性质"></a>节点性质</h5><ul>
<li>树形结构，也可以理解为linux的文件目录</li>
<li>每一个节点都是znode，里面可以包含<strong>数据</strong>，也可以有<strong>子节点</strong></li>
<li>点分为<strong>永久节点</strong>和<strong>临时节点</strong>(与客户端绑定) [session失效，也就是客户端断开过，临时节点消失]</li>
<li>每个znode都有<strong>版本号</strong>，每当数据变化，版本号都会累加(<strong>乐观锁</strong>)</li>
<li>删除或修改节点，版本号不匹配的话(版本号已超时), 会报错)</li>
<li>每个节点存储的<strong>数据不宜过大</strong>，几k即可 [保存路径再去查询]</li>
<li>节点可以设置<strong>权限</strong>，来限制用户的访问</li>
<li>Zookeeper保证读和写都是<strong>原子操作</strong>，且每次读写操作都是对数据的完整读取或完整写入</li>
</ul>
<h5 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h5><ul>
<li><strong>持久</strong>节点</li>
<li><strong>临时</strong>节点</li>
<li><strong>顺序</strong>节点</li>
</ul>
<h5 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h5><ul>
<li>dataVersion</li>
<li>cversion [child]</li>
<li>aclVersion [权限]</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><span style = "color:blue">常用命令</span></h2><ul>
<li><p>启动：<code>./bin/zkServer.sh start</code></p>
</li>
<li><p>连接到Zookeeper</p>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... STARTED

[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkCli.sh -server 127.0.0.1:2181
</code></pre>
</li>
<li><p><span style = "color:red"><strong>查看节点</strong></span></p>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 3] ls 
ls [-s] [-w] [-R] path
[zk: 127.0.0.1:2181(CONNECTED) 4] ls /
[zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 5] ls /zookeeper
[config, quota]
[zk: 127.0.0.1:2181(CONNECTED) 6] 
</code></pre>
<ul>
<li>查看节点状态：<code>stat /</code></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 6] stat /
cZxid = 0x0
ctime = Thu Jan 01 08:00:00 CST 1970
mZxid = 0x0
mtime = Thu Jan 01 08:00:00 CST 1970
pZxid = 0x0
cversion = -1    //子节点更改的次数
dataVersion = 0  //数据更改的情况
aclVersion = 0   //权限修改的情况
ephemeralOwner = 0x0  //[0是永久节点 其他的是临时节点]
dataLength = 0
numChildren = 1  //有几个子节点
</code></pre>
<ul>
<li>查看节点的数据和状态：<code>get</code></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 7] get /45
jj
</code></pre>
<ul>
<li>创建、修改、删除节点</li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 8] create
create [-s] [-e] [-c] [-t ttl] path [data] [acl]

//创建
[zk: 127.0.0.1:2181(CONNECTED) 9] create /imooc2
Created /imooc2
[zk: 127.0.0.1:2181(CONNECTED) 10] create /imooc3 123
Created /imooc3
[zk: 127.0.0.1:2181(CONNECTED) 11] get /imooc3
123

[zk: 127.0.0.1:2181(CONNECTED) 12] stat /imooc3
cZxid = 0x5
ctime = Sun May 05 01:41:21 CST 2024
mZxid = 0x5
mtime = Sun May 05 01:41:21 CST 2024
pZxid = 0x5
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0

//修改
[zk: 127.0.0.1:2181(CONNECTED) 13] set /imooc3 456
[zk: 127.0.0.1:2181(CONNECTED) 14] get /imooc3
456
[zk: 127.0.0.1:2181(CONNECTED) 15] stat /imooc3
cZxid = 0x5
ctime = Sun May 05 01:41:21 CST 2024
mZxid = 0x6
mtime = Sun May 05 01:42:16 CST 2024
pZxid = 0x5
cversion = 0
dataVersion = 1
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0
</code></pre>
</li>
</ul>
<h2 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a><span style = "color:blue">高级命令</span></h2><h4 id="创建节点的高级功能"><a href="#创建节点的高级功能" class="headerlink" title="创建节点的高级功能"></a>创建节点的高级功能</h4><ul>
<li><h5 id="创建顺序节点-s-会戴上序号"><a href="#创建顺序节点-s-会戴上序号" class="headerlink" title="创建顺序节点 [-s] (会戴上序号)"></a>创建顺序节点 [-s] (会戴上序号)</h5></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 16] create /imooc4
Created /imooc4
[zk: 127.0.0.1:2181(CONNECTED) 17] create -s /imooc4 /s
Created /imooc40000000003
[zk: 127.0.0.1:2181(CONNECTED) 18] create -s /imooc4 /s
Created /imooc40000000004
</code></pre>
<ul>
<li><h5 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h5><blockquote>
<p>ephemeralOwner &#x3D; 0x0  [0是永久节点 其他的是临时节点]</p>
</blockquote>
</li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 22] create /imooc
Created /imooc
[zk: 127.0.0.1:2181(CONNECTED) 23] create -e /imooc/tmp 123
Created /imooc/tmp
[zk: 127.0.0.1:2181(CONNECTED) 24] stat /imooc/tmp
cZxid = 0xd
ctime = Sun May 05 01:48:50 CST 2024
mZxid = 0xd
mtime = Sun May 05 01:48:50 CST 2024
pZxid = 0xd
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x10085ad02c90001  //[0x0是永久节点 其他的是临时节点]
dataLength = 3
numChildren = 0
</code></pre>
<ul>
<li><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 27] set /imooc 6
[zk: 127.0.0.1:2181(CONNECTED) 28] get /imooc
6
[zk: 127.0.0.1:2181(CONNECTED) 29] stat /imooc
cZxid = 0xc
ctime = Sun May 05 01:48:46 CST 2024
mZxid = 0xe
mtime = Sun May 05 01:51:15 CST 2024
pZxid = 0xd
cversion = 1
dataVersion = 1
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 1
numChildren = 1 
//set -v 1 /imooc 9 是因为上面 dataVersion = 1  指定条件版本更新
[zk: 127.0.0.1:2181(CONNECTED) 35] set -v 1 /imooc 9  
[zk: 127.0.0.1:2181(CONNECTED) 36] get /imooc
9
</code></pre>
<ul>
<li><h5 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h5></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 38] delete
delete [-v version] path //也可以按照版本号去删除
[zk: 127.0.0.1:2181(CONNECTED) 42] ls /
[imooc, imooc2, imooc3, imooc4, imooc40000000003, imooc40000000004, imooc40000000005, zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 43] delete /imooc40000000003
[zk: 127.0.0.1:2181(CONNECTED) 44] ls /
[imooc, imooc2, imooc3, imooc4, imooc40000000004, imooc40000000005, zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 45] 
</code></pre>
<h3 id="Watcher机制"><a href="#Watcher机制" class="headerlink" title="Watcher机制"></a><span style = "color:red">Watcher机制</span></h3><ul>
<li><h5 id="触发器、监督者"><a href="#触发器、监督者" class="headerlink" title="触发器、监督者"></a>触发器、监督者</h5></li>
<li><h5 id="使用场景：统一资源配置-发生变化时-会給所有监听客户端发送信息"><a href="#使用场景：统一资源配置-发生变化时-会給所有监听客户端发送信息" class="headerlink" title="使用场景：统一资源配置 [发生变化时 会給所有监听客户端发送信息]"></a>使用场景：统一资源配置 [发生变化时 会給所有监听客户端发送信息]</h5></li>
</ul>
<h5 id="Watcher事件类型"><a href="#Watcher事件类型" class="headerlink" title="Watcher事件类型"></a>Watcher事件类型</h5><table>
<thead>
<tr>
<th>EventType</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>NodeCreated (节点创建)</td>
<td>Watcher监听的对应数据节点被创建</td>
</tr>
<tr>
<td>NodeDeleted (节点删除)</td>
<td>Watcher监听的对应数据节点被删除</td>
</tr>
<tr>
<td>NodeDataChanged(节点数据修改)</td>
<td>Watcher监听的对应数据节点的数据内容发生变更</td>
</tr>
<tr>
<td>NodeChildrenChanged(子节点变更)</td>
<td>Watcher监听的对应数据节点的子节点列表发生变更</td>
</tr>
</tbody></table>
<h5 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h5><ul>
<li>access control list 权限控制</li>
<li>它使用<strong>权限位</strong>来允许&#x2F;禁止对话节点及其所作用域的各种操作</li>
<li>ACL仅与特定的znode有关，与<strong>子节点无关</strong></li>
</ul>
<h5 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h5><ul>
<li>ACL：[scheme采用的权限机制：id用户：permissions权限组合字符串]</li>
<li>world</li>
<li>auth [认证登录]</li>
<li>digest [密文加密]</li>
<li>ip [只允许特定ip访问]</li>
<li>super [超级权限]</li>
</ul>
<h5 id="权限字符串crdwa"><a href="#权限字符串crdwa" class="headerlink" title="权限字符串crdwa"></a>权限字符串crdwa</h5><ul>
<li><h6 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h6></li>
<li><h6 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h6></li>
<li><h6 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h6></li>
<li><h6 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h6></li>
<li><h6 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h6></li>
</ul>
<h5 id="ACL-权限使用场景"><a href="#ACL-权限使用场景" class="headerlink" title="[ACL]权限使用场景"></a>[ACL]权限使用场景</h5><ul>
<li>区分开发&#x2F;测试&#x2F;运维环境，防止误操作</li>
<li>可以针对不同IP而产生具体的配置，更安全</li>
</ul>
<h3 id="Java原生客户端连接到zookeeper-ZK"><a href="#Java原生客户端连接到zookeeper-ZK" class="headerlink" title="Java原生客户端连接到zookeeper [ZK]"></a>Java原生客户端连接到zookeeper [ZK]</h3><ul>
<li>利用<strong>ZK原生的Java</strong>的API</li>
<li>利用Apache <strong>Curator</strong>作为客户端来操作ZK</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;zk-practicer&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
            &lt;version&gt;3.6.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/zkjavaapi/ZKConnect.java
package com.imooc.zkjavaapi;

import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import org.omg.CORBA.TIMEOUT;

import java.io.IOException;

/**
 * 连接到ZK服务端，打印连接状态
 */
public class ZKConnect implements Watcher &#123;
    public static final String SERVER_PATH=&quot;47.98.225.105:2181&quot;;
    public static final Integer TIMEOUT = 5000;

    public static void main(String[] args) throws IOException, InterruptedException &#123;
        //后面new的相当于把这个作为参数传递进去
        //客户端和服务端是异步连接，连接成功之后，客户端会收到watcher通知
        //connectString：服务器的IP+端口号
        //sessionTImeout：超时时间
        //watcher：接收通知事件
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKConnect());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);
        System.out.println(zk.getState());
    &#125;

    @Override
    public void process(WatchedEvent watchedEvent) &#123;
        System.out.println(&quot;收到了通知&quot; + watchedEvent);
    &#125;
&#125;
===========================================================
17:35:46 INFO zookeeper.ZooKeeper: Client environment:os.memory.free=466MB
17:35:46 INFO zookeeper.ZooKeeper: Client environment:os.memory.max=7209MB
17:35:46 INFO zookeeper.ZooKeeper: Client environment:os.memory.total=487MB
17:35:46 INFO zookeeper.ZooKeeper: Initiating client connection, connectString=127.0.0.1:2181 sessionTimeout=5000 watcher=com.imooc.zkjavaapi.ZKConnect@7591083d
17:35:46 INFO common.X509Util: Setting -D jdk.tls.rejectClientInitiatedRenegotiation=true to disable client-initiated TLS renegotiation
17:35:46 INFO zookeeper.ClientCnxnSocket: jute.maxbuffer value is 1048575 Bytes
17:35:46 INFO zookeeper.ClientCnxn: zookeeper.request.timeout value is 0. feature enabled=false
客户端开始连接ZK服务器了
CONNECTING
17:35:46 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
17:35:46 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
17:35:46 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:50517, server: 127.0.0.1/127.0.0.1:2181
17:35:46 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec08710001, negotiated timeout = 5000
收到了通知WatchedEvent state:SyncConnected type:None path:null
CONNECTED
</code></pre>
<pre><code class="xml">log4j.properties
log4j.rootLogger=INFO, stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d&#123;HH:mm:ss&#125; %p %c&#123;2&#125;: %m%n
</code></pre>
<pre><code class="linux">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... already running as process 4147.
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33316784/article/details/88563482">windows环境下安装zookeeper教程详解（单机版）_windows zooke-CSDN博客</a></p>
<h3 id="用代码对节点进行操作"><a href="#用代码对节点进行操作" class="headerlink" title="用代码对节点进行操作"></a>用代码对节点进行操作</h3><pre><code class="java">com/imooc/zkjavaapi/ZKOperator.java
package com.imooc.zkjavaapi;

import java.io.IOException;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;

/**
 * 描述：     演示对节点的操作，包含创建、读取、删除等。
 */
public class ZKOperator implements Watcher &#123;

    public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;

    public static final Integer TIMEOUT = 5000;

    public static void main(String[] args)
            throws IOException, InterruptedException, KeeperException &#123;
        /**
         * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。
         * connectString：服务器的IP+端口号，比如127.0.0.1:2181
         * sessionTimeout：超时时间
         * watcher：通知事件
         */
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKOperator());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);

        /**
         * path:创建的路径
         * data：存储的数据
         * acl：权限，开放
         * createMode：永久、临时、顺序。
         */
        System.out.println(zk.create(&quot;/imooc-create-node2&quot;, &quot;imooc2&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,
                CreateMode.PERSISTENT));
    &#125;

    @Override
    public void process(WatchedEvent event) &#123;
    &#125;
&#125;
==========================================================================
客户端开始连接ZK服务器了
CONNECTING
17:57:14 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
17:57:14 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
17:57:14 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:57443, server: 127.0.0.1/127.0.0.1:2181
17:57:14 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec08710008, negotiated timeout = 5000
/imooc-create-node2
==========================================================================
==========================================================================
 /**
         * path:创建的路径
         * data：存储的数据
         * acl：权限，开放
         * createMode：永久、临时、顺序。
         */
//        System.out.println(zk.create(&quot;/imooc-create-node2&quot;, &quot;imooc2&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,
//                CreateMode.PERSISTENT));
//        zk.setData(&quot;/imooc-create-node&quot;, &quot;imooc3&quot;.getBytes(), 1);
        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);
        System.out.println(new String(data));
    &#125;
==========================================================================
客户端开始连接ZK服务器了
CONNECTING
17:58:09 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
17:58:09 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
17:58:09 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:57766, server: 127.0.0.1/127.0.0.1:2181
17:58:09 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec08710009, negotiated timeout = 5000
imooc2
</code></pre>
<h5 id="version版本不一样-保证不做修改"><a href="#version版本不一样-保证不做修改" class="headerlink" title="version版本不一样 保证不做修改"></a>version版本不一样 保证不做修改</h5><pre><code class="java">com/imooc/zkjavaapi/ZKOperator.java
修改值 让版本变成1
 zk.setData(&quot;/imooc-create-node2&quot;, &quot;imooc3&quot;.getBytes(), 1);
        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);
        System.out.println(new String(data)); 
----------------------------------------------------------------------------
Exception in thread &quot;main&quot; org.apache.zookeeper.KeeperException$BadVersionException: KeeperErrorCode = BadVersion for /imooc-create-node2
    at org.apache.zookeeper.KeeperException.create(KeeperException.java:122)
    at org.apache.zookeeper.KeeperException.create(KeeperException.java:54)
    at org.apache.zookeeper.ZooKeeper.setData(ZooKeeper.java:2551)
    at com.imooc.zkjavaapi.ZKOperator.main(ZKOperator.java:41)

报错=&gt;版本不一致
===========================================================================
[修改]
 zk.setData(&quot;/imooc-create-node2&quot;, &quot;imooc3&quot;.getBytes(), 0);
        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);
        System.out.println(new String(data));
----------------------------------------------------------------------------
客户端开始连接ZK服务器了
CONNECTING
18:01:35 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
18:01:35 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
18:01:35 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:58870, server: 127.0.0.1/127.0.0.1:2181
18:01:35 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec0871000d, negotiated timeout = 5000
imooc3 [修改成功]
</code></pre>
<h5 id="删除节点-引入回调函数-休眠"><a href="#删除节点-引入回调函数-休眠" class="headerlink" title="删除节点 [引入回调函数+休眠]"></a>删除节点 [引入回调函数+休眠]</h5><pre><code class="java">com/imooc/zkjavaapi/ZKOperator.java
package com.imooc.zkjavaapi;

import java.io.IOException;

import com.imooc.zkjavaapi.callback.DeleteCallBack;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;

/**
 * 描述：     演示对节点的操作，包含创建、读取、删除等。
 */
public class ZKOperator implements Watcher &#123;

    public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;

    public static final Integer TIMEOUT = 5000;

    public static void main(String[] args)
            throws IOException, InterruptedException, KeeperException &#123;
        /**
         * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。
         * connectString：服务器的IP+端口号，比如127.0.0.1:2181
         * sessionTimeout：超时时间
         * watcher：通知事件
         */
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKOperator());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);

        /**
         * path:创建的路径
         * data：存储的数据
         * acl：权限，开放
         * createMode：永久、临时、顺序。
         */
        zk.create(&quot;/imooc-create-node3&quot;, &quot;imooc3&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,
                CreateMode.PERSISTENT);
//        zk.setData(&quot;/imooc-create-node2&quot;, &quot;imooc3&quot;.getBytes(), 0);
//        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);

        String ctx = &quot;删除成功&quot;; //把ctx的内容代入到DeleteCallBack()里面去运行
        zk.delete(&quot;/imooc-create-node3&quot;,0,new DeleteCallBack(),ctx);
        Thread.sleep(2000);
//        System.out.println(new String(data));
    &#125;

    @Override
    public void process(WatchedEvent event) &#123;
    &#125;
&#125;
--------------------------------------------------------------------------------
客户端开始连接ZK服务器了
CONNECTING
18:10:01 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
18:10:01 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
18:10:01 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:2600, server: 127.0.0.1/127.0.0.1:2181
18:10:01 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec0871000f, negotiated timeout = 5000
删除节点/imooc-create-node3
删除成功
</code></pre>
<pre><code class="java">com/imooc/zkjavaapi/callback/DeleteCallBack.java
package com.imooc.zkjavaapi.callback;

import org.apache.zookeeper.AsyncCallback;

/**
 * 删除后运行的方法
 */
public class DeleteCallBack implements AsyncCallback.VoidCallback &#123;
    @Override
    public void processResult(int rc, String path, Object ctx) &#123;
        System.out.println(&quot;删除节点&quot; + path);
        System.out.println((String)ctx);
    &#125;
&#125;
</code></pre>
<h3 id="处理Watcher事件"><a href="#处理Watcher事件" class="headerlink" title="处理Watcher事件"></a>处理Watcher事件</h3><pre><code class="java">com/imooc/zkjavaapi/ZKGetNode.java
package com.imooc.zkjavaapi;

import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.data.Stat;

import java.io.IOException;
import java.util.concurrent.CountDownLatch;

/**
 * 和节点相关：是否存在，获取数据，加上Watch
 */
public class ZKGetNode implements Watcher &#123;
    public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;

    public static final Integer TIMEOUT = 5000;

    //这个是门闩
    private static CountDownLatch countDownLatch = new CountDownLatch(1);

    public static void main(String[] args) throws IOException, InterruptedException, KeeperException &#123;
        /**
         * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。
         * connectString：服务器的IP+端口号，比如127.0.0.1:2181
         * sessionTimeout：超时时间
         * watcher：通知事件
         */
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKGetNode());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);
        System.out.println(zk.getState());

//        Stat exists = zk.exists(&quot;/imooc-create-node&quot;, false);//不需要额外监听
//        if (exists != null)&#123;
//            System.out.println(&quot;节点的版本为： &quot;+exists.getVersion());
//        &#125;else&#123;
//            System.out.println(&quot;该节点不存在&quot;);
//        &#125;
        zk.getData(&quot;/imooc-create-node&quot;, true, null);
        countDownLatch.await();
    &#125;

    @Override
    public void process(WatchedEvent event) &#123;
        if (event.getType() == Event.EventType.NodeChildrenChanged)&#123;
            System.out.println(&quot;数据被改变&quot;);
            countDownLatch.countDown();
        &#125;
        System.out.println(&quot;收到了通知&quot; + event);
    &#125;
&#125;
--------------------------------------------------------------------------------
在运行的情况下 去cmd中 修改
[zk: localhost:2181(CONNECTED) 1] set /imooc-create-node 11
--------------------------------------------------------------------------------
客户端开始连接ZK服务器了
CONNECTING
18:52:14 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
18:52:14 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
18:52:14 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:16204, server: 127.0.0.1/127.0.0.1:2181
18:52:14 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x1000534afde0001, negotiated timeout = 5000
收到了通知WatchedEvent state:SyncConnected type:None path:null
CONNECTED
数据被改变
收到了通知WatchedEvent state:SyncConnected type:NodeDataChanged path:/imooc-create-node
</code></pre>
<h3 id="用Curator操作ZK"><a href="#用Curator操作ZK" class="headerlink" title="用Curator操作ZK"></a><span style = "color:red">用Curator操作ZK</span></h3><h5 id="原生的Java的API的缺点"><a href="#原生的Java的API的缺点" class="headerlink" title="原生的Java的API的缺点"></a>原生的Java的API的缺点</h5><ul>
<li>不支持连接超时后的<strong>自动连接</strong></li>
<li>Watcher<strong>注册一次</strong>后会失效</li>
<li>不支持<strong>递归</strong>创建节点</li>
</ul>
<h5 id="利用Apache-Curator"><a href="#利用Apache-Curator" class="headerlink" title="利用Apache Curator"></a>利用Apache Curator</h5><ul>
<li>解决了Watcher注册一次后会失效的问题</li>
<li>API更加<strong>简单易用</strong>，提供了工具类</li>
</ul>
<pre><code class="java">com/imooc/curator/CuratorTests.java
package com.imooc.curator;

import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;

/**
 * 用Curator来操作ZK
 */
public class CuratorTests &#123;
    public static void main(String[] args) throws Exception &#123;
        String connectString = &quot;127.0.0.1:2181&quot;;
        RetryPolicy retry = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retry);
        client.start();
        String path = &quot;/curator&quot;;
        String data = &quot;test&quot;;
        client.create().withMode(CreateMode.PERSISTENT).forPath(path,data.getBytes());
        byte[] bytes = client.getData().forPath(path);
        System.out.println(new String(bytes));
    &#125;
&#125;
</code></pre>
<h6 id="更改高级一点！！！【添加-修改-删除】"><a href="#更改高级一点！！！【添加-修改-删除】" class="headerlink" title="更改高级一点！！！【添加+修改+删除】"></a>更改高级一点！！！【添加+修改+删除】</h6><pre><code class="java">com/imooc/curator/CuratorTests.java
package com.imooc.curator;

import com.sun.net.httpserver.Authenticator.Retry;
import java.text.MessageFormat;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorEvent;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher.Event.EventType;

/**
 * 描述：     用Curator来操作ZK
 */
public class CuratorTests &#123;

    public static void main(String[] args) throws Exception &#123;
        String connectString = &quot;127.0.0.1:2181&quot;;
        String path = &quot;/curator2&quot;;

        RetryPolicy retry = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retry);
        client.start();
        client.getCuratorListenable().addListener((CuratorFramework c, CuratorEvent event) -&gt; &#123;
            switch (event.getType()) &#123;
                case WATCHED:
                    WatchedEvent watchedEvent = event.getWatchedEvent();
                    if (watchedEvent.getType() == EventType.NodeDataChanged) &#123;
                        System.out.println(new String(c.getData().forPath(path)));
                    &#125;
            &#125;
        &#125;);
        String data = &quot;test&quot;;
        String data2 = &quot;test2&quot;;
        //添加
        client.create().withMode(CreateMode.PERSISTENT).forPath(path, data.getBytes());

        byte[] bytes = client.getData().watched().forPath(path);
        System.out.println(new String(bytes));
        //更改
        client.setData().forPath(path, data2.getBytes());
        //删除
        client.delete().forPath(path);
        Thread.sleep(2000); //保证足够时间运行成功
    &#125;
&#125;
-------------------------------------------------------------------------------------
19:44:41 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
19:44:41 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
19:44:41 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:32984, server: 127.0.0.1/127.0.0.1:2181
19:44:41 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x1000534afde0005, negotiated timeout = 40000
19:44:41 INFO state.ConnectionStateManager: State change: CONNECTED
test
test2
</code></pre>
<h2 id="Dubbo-RPC远程过程调用"><a href="#Dubbo-RPC远程过程调用" class="headerlink" title="Dubbo [RPC远程过程调用]"></a>Dubbo [RPC远程过程调用]</h2><ul>
<li>初识Dubbo</li>
<li><strong>RPC</strong>介绍</li>
<li>Dubbo<strong>工作原理</strong></li>
<li>案例实操：项目编写</li>
<li>整合Dubbo和Zookeeper</li>
<li>实现服务间调用</li>
</ul>
<h3 id="初始Dubbo"><a href="#初始Dubbo" class="headerlink" title="初始Dubbo"></a>初始Dubbo</h3><h5 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么"></a>Dubbo是什么</h5><ul>
<li>轻量级、高性能的<strong>RPC框架</strong></li>
<li>并不是要成为一个微服务的全面解决方案</li>
<li>以Java语言而出名</li>
</ul>
<h5 id="Dubbo现状"><a href="#Dubbo现状" class="headerlink" title="Dubbo现状"></a>Dubbo现状</h5><ul>
<li>全称是<strong>Apache Dubbo</strong></li>
<li>微店、网易云音乐、滴滴、中国电信、中国人寿</li>
<li>star有30K+个，fork有20K+个</li>
</ul>
<h5 id="Dubbo的故事"><a href="#Dubbo的故事" class="headerlink" title="Dubbo的故事"></a>Dubbo的故事</h5><ul>
<li>09年开始做，做的第一个版本</li>
<li>10年初的时候，架构升级，Dubbo2.0</li>
<li><strong>开源</strong></li>
<li>one company战略</li>
<li>合到HSF去</li>
<li>第3节点，捐给Apache</li>
</ul>
<h5 id="开源的理解"><a href="#开源的理解" class="headerlink" title="开源的理解"></a>开源的理解</h5><ul>
<li><strong>共同成长</strong>、巨人的肩膀上</li>
<li>演化慢、不断革新、很强大的生命力</li>
<li>突破任何的束缚，突破任何的常规，<strong>包容和开放</strong></li>
</ul>
<h3 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h3><ul>
<li>RPC ——远程过程调用</li>
<li>早期单机时代：IPC</li>
<li>网络时代：<strong>把IPC扩展到网络上，这就是RPC</strong></li>
<li>实现RPC很头疼，于是有了<strong>RPC框架</strong></li>
<li>调用其他机器上的程序和<strong>调用本地的程序一样方便</strong></li>
</ul>
<h5 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h5><ul>
<li>阿里的Dubbo</li>
<li>新浪的Montan</li>
<li>Facebook的Thrift</li>
<li>各个框架都有其各自的优缺点</li>
</ul>
<h5 id="HTTP和RPC对比"><a href="#HTTP和RPC对比" class="headerlink" title="HTTP和RPC对比"></a>HTTP和RPC对比</h5><ul>
<li><strong>普通话</strong>[通用] 与 <strong>方言</strong>[企业内部]</li>
<li>普通话本质上也是一种方言，只不过它是官方的方言</li>
<li>传输效率 <ul>
<li>RPC定制自己传输请求让传输效率更高</li>
<li>HTTP会包含一些无用的内容效率较低</li>
</ul>
</li>
<li>性能消耗，主要在于序列化和反序列化的耗时</li>
<li>负载均衡</li>
</ul>
<h3 id="Dubbo工作原理"><a href="#Dubbo工作原理" class="headerlink" title="Dubbo工作原理"></a>Dubbo工作原理</h3><h6 id="一旦注册中心的信息有变化的时候会主动推送信息"><a href="#一旦注册中心的信息有变化的时候会主动推送信息" class="headerlink" title="一旦注册中心的信息有变化的时候会主动推送信息"></a>一旦注册中心的信息有变化的时候会主动推送信息</h6><ul>
<li>服务<strong>容器</strong>负责启动，加载，<strong>运行服务提供者</strong></li>
<li><strong>服务提供者</strong>在启动时，向注册中心<strong>注册</strong>自己提供的服务</li>
<li><strong>服务提供者</strong>在启动时，向注册中心<strong>订阅</strong>自己所需的服务</li>
<li>注册中心返回服务提供者<strong>地址列表</strong>给消费者</li>
<li>从提供者地址列表中，<strong>选一台</strong>提供者进行调用</li>
<li>定期发送一次<strong>统计数据</strong>到监控中心</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ded5afda4ae8cff8392f5ccf0217657054c8981/data/Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的控制中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<h3 id="服务提供者开发"><a href="#服务提供者开发" class="headerlink" title="服务提供者开发"></a>服务提供者开发</h3><h5 id="案例实操"><a href="#案例实操" class="headerlink" title="案例实操"></a>案例实操</h5><ul>
<li>引入依赖</li>
<li>添加注解</li>
<li>整合Dubbo和<strong>Zookeeper</strong></li>
</ul>
<pre><code class="xml">pom.xml[dubbo-practice]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;modules&gt;
        &lt;module&gt;producer&lt;/module&gt;
    &lt;/modules&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.12.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt;
    &lt;version&gt;0.0.1&lt;/version&gt;
    &lt;name&gt;dubbo-practice&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;spring-boot.version&gt;2.1.12.RELEASE&lt;/spring-boot.version&gt;
        &lt;dubbo.version&gt;2.7.4.1&lt;/dubbo.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- Spring Boot --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- Apache Dubbo  --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo-dependencies-bom&lt;/artifactId&gt;
                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
                &lt;exclusions&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                        &lt;artifactId&gt;spring&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
                        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;log4j&lt;/groupId&gt;
                        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                &lt;/exclusions&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">pom.xml[dubbo-practice-producer]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;0.0.1&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;producer&lt;/artifactId&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- Dubbo Spring Boot Starter --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.7.4.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- Zookeeper dependencies --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;
            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- Web 功能 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- MySQL connector, 需要与 MySQL 版本对应 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- MyBatis依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/producer/service/CourseListService.java
package com.imooc.producer.service;

import com.imooc.producer.entity.Course;

import java.util.List;

/**
 * 课程列表服务
 */
public interface CourseListService &#123;
    List&lt;Course&gt; getCourseList();
&#125;
</code></pre>
<pre><code class="java">com/imooc/producer/entity/Course.java
package com.imooc.producer.entity;

import java.io.Serializable;

/**
 * 描述：     Course实体类
 */
public class Course implements Serializable &#123;

    Integer id;
    Integer courseId;
    String name;
    //1上架，0下架
    Integer valid;

    @Override
    public String toString() &#123;
        return &quot;Course&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, valid=&quot; + valid +
                &#39;&#125;&#39;;
    &#125; Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/producer/service/impl/CourseListServiceImpl.java
package com.imooc.producer.service.impl;

import com.imooc.producer.entity.Course;
import com.imooc.producer.mapper.CourseMapper;
import com.imooc.producer.service.CourseListService;
import java.util.List;
import org.apache.dubbo.config.annotation.Service;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * 描述：     课程列表服务实现类
 */
@Service(version = &quot;$&#123;demo.service.version&#125;&quot;)
public class CourseListServiceImpl implements CourseListService &#123;

    @Autowired
    CourseMapper courseMapper;

    public List&lt;Course&gt; getCourseList() &#123;
        return courseMapper.findValidCourses();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/producer/mapper/CourseMapper.java
package com.imooc.producer.mapper;

import com.imooc.producer.entity.Course;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Mapper类
 */
@Mapper
@Repository
public interface CourseMapper &#123;
    @Select(&quot;SELECT * FORM course WHERE valid = 1&quot;)
    List&lt;Course&gt; findValidCourses();
&#125;
</code></pre>
<pre><code class="mysql">application.properties
demo.service.version=1.0.0

#server.port=8081

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_prepare?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;


spring.application.name=course-list

#dubbo协议
dubbo.protocol.name=dubbo
dubbo.protocol.port=-1
#dubbo注册
dubbo.registry.address=zookeeper://127.0.0.1:2181
dubbo.registry.file=$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache

mybatis.configuration.map-underscore-to-camel-case=true

dubbo.scan.base-packages=com.imooc.producer.service.impl
</code></pre>
<pre><code class="java">com/imooc/producer/DubboProducerApplication.java
package com.imooc.producer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 描述：     Spring Boot启动类
 */
@EnableAutoConfiguration
public class DubboProducerApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(DubboProducerApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="服务消费方开发"><a href="#服务消费方开发" class="headerlink" title="服务消费方开发"></a>服务消费方开发</h3><p>查看PID为8080：<code>netstat -ano|findstr 8080</code><br>杀死进程：<code>taskkill /pid 查询的PID /f</code></p>
<pre><code class="xml">pom.xml[dubbo-practice-consumer]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;version&gt;0.0.1&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;artifactId&gt;concumer&lt;/artifactId&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- Dubbo Spring Boot Starter --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.7.4.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- Zookeeper dependencies --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;
      &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;!-- Web 功能 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL connector, 需要与 MySQL 版本对应 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- MyBatis依赖--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.imooc&lt;/groupId&gt;
      &lt;artifactId&gt;producer&lt;/artifactId&gt;
      &lt;version&gt;0.0.1&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/consumer/service/CoursePriceService.java
package com.imooc.consumer.service;

import com.imooc.consumer.entity.CourseAndPrice;
import com.imooc.consumer.entity.CoursePrice;
import java.util.List;

/**
 * 描述：     课程价格服务
 */
public interface CoursePriceService &#123;

    CoursePrice getCoursePrice(Integer courseId);

    List&lt;CourseAndPrice&gt; getCoursesAndPrice();
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/service/impl/CoursePriceServiceImpl.java
package com.imooc.consumer.service.impl;

import com.imooc.consumer.dao.CoursePriceMapper;
import com.imooc.consumer.entity.CourseAndPrice;
import com.imooc.consumer.entity.CoursePrice;
import com.imooc.consumer.service.CoursePriceService;
import com.imooc.producer.entity.Course;
import com.imooc.producer.service.CourseListService;
import java.util.ArrayList;
import java.util.List;
import org.apache.dubbo.config.annotation.Reference;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 描述：     课程 价格服务
 */
@Service
public class CoursePriceServiceImpl implements CoursePriceService &#123;

    @Autowired
    CoursePriceMapper coursePriceMapper;

    @Reference(version = &quot;$&#123;demo.service.version&#125;&quot;)
    CourseListService courseListService;

    @Override
    public CoursePrice getCoursePrice(Integer courseId) &#123;
        return coursePriceMapper.findCoursePrices(courseId);
    &#125;

    @Override
    public List&lt;CourseAndPrice&gt; getCoursesAndPrice() &#123;
        List&lt;CourseAndPrice&gt; courseAndPriceList = new ArrayList&lt;&gt;();
        List&lt;Course&gt; courseList = courseListService.getCourseList();
        for (int i = 0; i &lt; courseList.size(); i++) &#123;
            Course course = courseList.get(i);
            if (course != null) &#123;
                CoursePrice price = getCoursePrice(course.getCourseId());
                if (price != null &amp;&amp; price.getPrice() &gt; 0) &#123;
                    CourseAndPrice courseAndPrice = new CourseAndPrice();
                    courseAndPrice.setId(course.getId());
                    courseAndPrice.setCourseId(course.getCourseId());
                    courseAndPrice.setName(course.getName());
                    courseAndPrice.setPrice(price.getPrice());
                    courseAndPriceList.add(courseAndPrice);
                &#125;
            &#125;
        &#125;
        return courseAndPriceList;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/dao/CoursePriceMapper.java
package com.imooc.consumer.dao;

import com.imooc.consumer.entity.CoursePrice;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

/**
 * 描述：     Mapper类
 */
@Mapper
@Repository
public interface CoursePriceMapper &#123;

    @Select(&quot;SELECT * FROM course_price WHERE course_id = #&#123;courseId&#125;&quot;)
    CoursePrice findCoursePrices(Integer courseId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/entity/CourseAndPrice.java
package com.imooc.consumer.entity;

import java.io.Serializable;

/**
 * 描述：     CoursePrice实体类
 */
public class CourseAndPrice implements Serializable &#123;

    Integer id;
    Integer courseId;
    String name;
    Integer price;

    @Override
    public String toString() &#123;
        return &quot;CourseAndPrice&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, price=&quot; + price +
                &#39;&#125;&#39;;
    &#125; Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/entity/CoursePrice.java
package com.imooc.consumer.entity;


import java.io.Serializable;

/**
 * 描述：     CoursePrice实体类
 */
public class CoursePrice implements Serializable &#123;

    Integer id;
    Integer courseId;
    Integer price;
&#125; Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/consumer/controller/CoursePriceController.java
package com.imooc.consumer.controller;

import com.imooc.consumer.entity.CourseAndPrice;
import com.imooc.consumer.entity.CoursePrice;
import com.imooc.consumer.service.CoursePriceService;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 描述：CoursePriceController
 */
@RestController
public class CoursePriceController &#123;

    @Autowired
    CoursePriceService coursePriceService;


    @GetMapping(&#123;&quot;/price&quot;&#125;)
    public Integer getCoursePrice(Integer courseId) &#123;
        CoursePrice coursePrice = coursePriceService.getCoursePrice(courseId);
        if (coursePrice != null) &#123;
            return coursePrice.getPrice();
        &#125; else &#123;
            return -1;
        &#125;
    &#125;


    @GetMapping(&#123;&quot;/coursesAndPrice&quot;&#125;)
    public List&lt;CourseAndPrice&gt; getcoursesAndPrice() &#123;
        return coursePriceService.getCoursesAndPrice();
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">application.properties
demo.service.version=1.0.0

server.port=8084

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_practice?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;


spring.application.name=course-price

#dubboåè®®
dubbo.protocol.name=dubbo
dubbo.protocol.port=-1
#dubboæ³¨å
dubbo.registry.address=zookeeper://127.0.0.1:2181
dubbo.registry.file=$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache
</code></pre>
<pre><code class="java">com/imooc/consumer/DubboConsumerApplication.java
package com.imooc.consumer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 描述：     Spring Boot启动类
 */
@SpringBootApplication
public class DubboConsumerApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(DubboConsumerApplication.class, args);
    &#125;
&#125;
</code></pre>
<h5 id="案例实操总结"><a href="#案例实操总结" class="headerlink" title="案例实操总结"></a>案例实操总结</h5><ul>
<li><strong>自动检查</strong>zk和依赖的服务</li>
<li>dubbo.scan.base-packages配置</li>
<li>实现<strong>服务间调用</strong></li>
</ul>
<h1 id="面试课"><a href="#面试课" class="headerlink" title=" 面试课"></a><span style = "color:red"> 面试课</span></h1><ul>
<li><h5 id="Spring-Boot常见面试题"><a href="#Spring-Boot常见面试题" class="headerlink" title="Spring Boot常见面试题"></a>Spring Boot常见面试题</h5></li>
<li><h5 id="线程常见面试题"><a href="#线程常见面试题" class="headerlink" title="线程常见面试题"></a>线程常见面试题</h5></li>
<li><h5 id="分布式的面试题"><a href="#分布式的面试题" class="headerlink" title="分布式的面试题"></a>分布式的面试题</h5></li>
<li><h5 id="Docker相关面试题"><a href="#Docker相关面试题" class="headerlink" title="Docker相关面试题"></a>Docker相关面试题</h5></li>
<li><h5 id="Nginx和Zookeeper相关面试题"><a href="#Nginx和Zookeeper相关面试题" class="headerlink" title="Nginx和Zookeeper相关面试题"></a>Nginx和Zookeeper相关面试题</h5></li>
<li><h5 id="RabbitMQ相关面试题"><a href="#RabbitMQ相关面试题" class="headerlink" title="RabbitMQ相关面试题"></a>RabbitMQ相关面试题</h5></li>
<li><h5 id="微服务相关"><a href="#微服务相关" class="headerlink" title="微服务相关"></a>微服务相关</h5></li>
<li><h5 id="彩蛋：学习方法"><a href="#彩蛋：学习方法" class="headerlink" title="彩蛋：学习方法"></a>彩蛋：学习方法</h5></li>
<li><h5 id="锁分类、死锁"><a href="#锁分类、死锁" class="headerlink" title="锁分类、死锁"></a>锁分类、死锁</h5></li>
<li><h5 id="HashMap和final"><a href="#HashMap和final" class="headerlink" title="HashMap和final"></a>HashMap和final</h5></li>
<li><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5></li>
<li><h5 id="面试避坑指南"><a href="#面试避坑指南" class="headerlink" title="面试避坑指南"></a>面试避坑指南</h5></li>
<li><h5 id="重要的软实力"><a href="#重要的软实力" class="headerlink" title="重要的软实力"></a>重要的软实力</h5></li>
</ul>
<h3 id="Spring、Spring-Boot和Spring-Cloud的关系？"><a href="#Spring、Spring-Boot和Spring-Cloud的关系？" class="headerlink" title="Spring、Spring Boot和Spring Cloud的关系？"></a>Spring、Spring Boot和Spring Cloud的关系？</h3><ul>
<li>Spring最初利用<strong>IOC</strong>和<strong>AOP</strong>解耦</li>
<li>按照这种模式搞了<strong>MVC框架</strong> [之后就配置太繁琐了]</li>
<li>写了很多样板代码很麻烦，就有了Spring Boot</li>
<li>Spring Boot是在强大的Spring帝国发展起来的，发明Spring Boot是为了让人们更好更高效的使用Spring，Spring Boot理念是约定优于配置</li>
<li>Spring Cloud是在Spring Boot基础上诞生的 [一系列框架的有序集合]</li>
</ul>
<h3 id="Spring-Boot如何配置多环境"><a href="#Spring-Boot如何配置多环境" class="headerlink" title="Spring Boot如何配置多环境"></a>Spring Boot如何配置多环境</h3><ul>
<li><h5 id="开发、测试、预发、生产"><a href="#开发、测试、预发、生产" class="headerlink" title="开发、测试、预发、生产"></a>开发、测试、预发、生产</h5></li>
</ul>
<blockquote>
<p>面试官你好，我这边平时是会使用多套环境，比如说”开发、测试、预发、生产”环境。<br>开发环境通常在本地，它所连接的数据库也是专门用于开发的，里面的数据也是一定情况下算出来的，因为并不需要在开发环境的情况下保证数据的完全精确，为了开发效率的提高，我们通常造一些模拟的数据，通常开发完后我们要把程序部署到测试环境，因为测试环境通常是公司所提供的服务器，而开发环境通常是我们本机，对于本机而言如果关闭或关机后别人就无法访问了，但是测试的同学工作时间不一定能和开发的同学一致，如果把程序关掉了他们就没办法测试了。我们需要给测试同学提供一套稳定的环境去测试。而且有的时候会同时开发多种功能，前一个功能开发完了需要去测试，这个时候就要去开发新的功能了，此时本地的代码已经发生了变化，如果把开发环境当成测试环境的话会发生很多问题，它实际测试的和我们想要测试的不是同一套代码，正是这个原因测试环境是必不可少的，需要用一台稳定的服务器把我们开发好的部署上测试环境中去，这样的话无论电脑是否关机都不会影响测试人员的进度。但是在测试环境的数据库往往可以和开发环境的保持一致可以允许公用同一个数据。<br>预发环境是预备发布，和真正的线上环境高度统一，和测试环境的区别：<br>1.网络隔离 为了保证线上环境的稳定会采取环境隔离，在本地或者测试环境下是没有办法访问到预发环境的机器，不可直接访问。在预发环境通常采用真实的数据库去测试。在测试环境并不能把所有问题都测试出来，所以在测试环境中无法测试到的问题在预发环境就可以暴露出来了，有时候在测试环境中模拟的数据不是准确，比如模拟一个商品详情，报的是50个字，最后发现真实情况是100个字，就能看到数据库大小不够，再次比如测试的是整数，到真实环境中发现是小数。隔离+数据验真<br>生产环境是真实对外的数据，也会有很多流量进来，直接面向所有用户，也有并发问题，要确保数据稳定</p>
</blockquote>
<ul>
<li><h5 id="提供多套配置文件"><a href="#提供多套配置文件" class="headerlink" title="提供多套配置文件"></a>提供多套配置文件</h5></li>
</ul>
<blockquote>
<p>在发布到某个环境之前，不建议把配置文件全部删除替换，有可能漏了文件导致了错误的替换，如果发布环境是测试环境的数据库，有可能会产生对外暴露的是测试环境的情况，这是很严重的事故</p>
</blockquote>
<ul>
<li><h5 id="通过改变application里的profiles-active值来加载对应的环境"><a href="#通过改变application里的profiles-active值来加载对应的环境" class="headerlink" title="通过改变application里的profiles.active值来加载对应的环境"></a>通过改变application里的profiles.active值来加载对应的环境</h5></li>
</ul>
<pre><code class="java">com/imooc/profiles/ProfilesApplication.java
package com.imooc.profiles;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProfilesApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(ProfilesApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">application.properties

spring.profiles.active=prod
</code></pre>
<pre><code class="mysql">application-pre.properties

spring.profiles.active=test
server.port=8082
</code></pre>
<pre><code class="mysql">application-prod.properties

spring.profiles.active=test
server.port=8083
</code></pre>
<pre><code class="mysql">application-test.properties

spring.profiles.active=test
server.port=8081
</code></pre>
<h3 id="实际工作中，如何全局处理异常？"><a href="#实际工作中，如何全局处理异常？" class="headerlink" title="实际工作中，如何全局处理异常？"></a>实际工作中，如何全局处理异常？</h3><ul>
<li><h5 id="为什么异常需要全局处理？不处理行不行？"><a href="#为什么异常需要全局处理？不处理行不行？" class="headerlink" title="为什么异常需要全局处理？不处理行不行？"></a>为什么异常需要全局处理？不处理行不行？</h5></li>
</ul>
<blockquote>
<p>如果我们不进行处理的话，异常可能会把整个堆栈抛出去，一旦发生异常，用户或者别用用心的黑客可以看到详细的异常发生情况，包含详细的错误信息和代码的行数，这样的话对方可以利用一个漏洞进行不同的尝试，而且可以顺藤摸瓜分析出更多潜在的风险，最终把系统攻击破，异常是必须处理的。<br>但为什么要全局处理呢？电商项目→exception→GlobalExceptionHandler</p>
</blockquote>
<ul>
<li><h5 id="GlobalExceptionHandler-使用全局处理"><a href="#GlobalExceptionHandler-使用全局处理" class="headerlink" title="GlobalExceptionHandler [使用全局处理]"></a>GlobalExceptionHandler [使用全局处理]</h5>识别到什么异常，调用什么其处理器。写了全局异常处理器，轻松的针对不同的异常做出定制化的解决方案，不但增加了安全性，对用户也是友好的</li>
</ul>
<pre><code class="java">package com.imooc.mall.exception;

import com.imooc.mall.common.ApiRestResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.ArrayList;
import java.util.List;

/**
 * 19.处理统一异常的handler 业务异常 处理不同逻辑异常  20对密码进行MD5加密UserServiceImpl 先创建MD5Utils
 */
@ControllerAdvice
public class GlobalExceptionHandler &#123;
    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    //   统一处理Exception.class异常 所有异常的父类
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Object handleException(Exception e) &#123;
        log.error(&quot;Default Exception: &quot;, e);
        return ApiRestResponse.error(ImoocMallExceptionEnum.SYSTEM_ERROR);
    &#125;
    
    // 处理自己所定义的异常 用户/密码不能为空......
    @ExceptionHandler(ImoocMallException.class)
    @ResponseBody
    public Object handleImoocMallException(ImoocMallException e) &#123;
        log.error(&quot;ImoocMallException: &quot;, e); //传进来的是什么就传出去
        return ApiRestResponse.error(e.getCode(), e.getMessage());
    &#125;

    //  39.处理方法参数不合规的情况
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public ApiRestResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e) &#123;
        log.error(&quot;handleMethodArgumentNotValidException: &quot;, e);
        return handleBindingResult(e.getBindingResult());
    &#125;
//  40.处理返回异常的ApiRespond 41去pom引入Swagger自动生成API文档
    private ApiRestResponse handleBindingResult(BindingResult result)&#123;
//  把异常处理为对外暴露的提示
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        if (result.hasErrors())&#123;
            List&lt;ObjectError&gt; allErrors = result.getAllErrors();
            for (ObjectError objectError : allErrors) &#123; //itli快速  对着for按alt+回车 改成增强for
                String message = objectError.getDefaultMessage();
                list.add(message);
            &#125;
        &#125;
        if (list.size() == 0)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR);
        &#125; //list.toString()生成所创建的异常描述信息
        return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR.getCode(), list.toString());
    &#125;
&#125;
</code></pre>
<h3 id="线程如何启动？"><a href="#线程如何启动？" class="headerlink" title="线程如何启动？"></a>线程如何启动？</h3><blockquote>
<p>Thread.start.run</p>
</blockquote>
<ul>
<li><h5 id="既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？"><a href="#既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？" class="headerlink" title="既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？"></a>既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？</h5></li>
</ul>
<blockquote>
<p>因为它只是一个普通的java代码，而不会真正的启动一个线程，调用一次run()方法只执行一次，而且是在主线程执行的，就没有起到任何创建线程的效果了。<br>如果选择start方法的话会在后台执行很多操作，比如去申请一个线程、让子方法去执行run()里的内容，而且还包括执行之后的对线程状态的调整。所以说表面上是相同都是执行一段代码，但是实际上是不同的。</p>
</blockquote>
<ul>
<li><h5 id="两次调用start-方法会出现什么情况？"><a href="#两次调用start-方法会出现什么情况？" class="headerlink" title="两次调用start()方法会出现什么情况？"></a>两次调用start()方法会出现什么情况？</h5></li>
</ul>
<blockquote>
<p>两次调用start()方法会报异常，异常类型叫做<code>IllegalThreadStateException</code>，在start()的时候首先会进行线程状态的检测只有是new的时候才能正常启动，不允许启动两次</p>
</blockquote>
<pre><code class="java">com/imooc/interniew/StartTwice.java
package com.imooc.interniew;

/**
 * 描述：     两次启动线程
 */
public class StartTwice &#123;

    public static void main(String[] args) &#123;
        Thread thread = new Thread();
        thread.start();
        thread.start();
    &#125;
&#125;
======================== 报错信息  ==========================
Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException
    at java.lang.Thread.start(Thread.java:705)
    at com.imooc.interniew.StartTwice.main(StartTwice.java:11)
</code></pre>
<pre><code class="java">Thread.java
public synchronized void start() &#123;
        /**
         * This method is not invoked for the main method thread or &quot;system&quot;
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state &quot;NEW&quot;.
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group&#39;s list of threads
         * and the group&#39;s unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try &#123;
            start0();
            started = true;
        &#125; finally &#123;
            try &#123;
                if (!started) &#123;
                    group.threadStartFailed(this);
                &#125;
            &#125; catch (Throwable ignore) &#123;
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="实现多线程的方法有几种？"><a href="#实现多线程的方法有几种？" class="headerlink" title="实现多线程的方法有几种？"></a>实现多线程的方法有几种？</h3><ul>
<li><h5 id="方法一：实现Runnable接口"><a href="#方法一：实现Runnable接口" class="headerlink" title="方法一：实现Runnable接口"></a>方法一：实现<strong>Runnable</strong>接口</h5></li>
</ul>
<pre><code class="java">com/imooc/interniew/createthreads/RunnableStyle.java
package com.imooc.interniew.createthreads;

import java.util.concurrent.Callable;

/**
 * 描述：     用Runnable方式创建线程
 */
public class RunnableStyle implements Runnable &#123;
//new里new的意思是 把这个Runnable类作为参数传进Thread里面
    public static void main(String[] args) &#123;
        Thread thread = new Thread(new RunnableStyle());
        thread.start();
    &#125;

    @Override
    public void run() &#123;
        System.out.println(&quot;用Runnable方法实现线程&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="方法二：继承Thread类"><a href="#方法二：继承Thread类" class="headerlink" title="方法二：继承Thread类"></a>方法二：继承Thread类</h5></li>
</ul>
<pre><code class="java">package com.imooc.interniew.createthreads;

import java.util.Timer;
import java.util.TimerTask;

/**
 * 描述：     利用定时器新建线程
 */
public class TimerDemo &#123;

    public static void main(String[] args) &#123;
        System.out.println(Thread.currentThread().getName());
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() &#123;
            @Override
            public void run() &#123;
                System.out.println(Thread.currentThread().getName());
            &#125;
        &#125;, 1000, 1000);
    &#125;
&#125;
</code></pre>
<h3 id="两种方式的对比"><a href="#两种方式的对比" class="headerlink" title="两种方式的对比"></a>两种方式的对比</h3><h4 id="方法1-实现Runnable接口更好"><a href="#方法1-实现Runnable接口更好" class="headerlink" title="方法1(实现Runnable接口更好)"></a><span style = "color:blue">方法1(实现Runnable接口更好)</span></h4><h5 id="实现多线程——常见面试问题"><a href="#实现多线程——常见面试问题" class="headerlink" title="实现多线程——常见面试问题"></a>实现多线程——常见面试问题</h5><ul>
<li><p><span style = "color:red"><strong>实现Runnable接口和继承Thread类哪种方式更好？</strong></span></p>
<ul>
<li><h5 id="从代码架构角度"><a href="#从代码架构角度" class="headerlink" title="从代码架构角度"></a>从代码架构角度</h5></li>
</ul>
<blockquote>
<p>本意是想让我们的执行类和任务的具体内容解耦，关系不那么密切，从架构角度好<br>★ Runnable具体描述的是工作的内容和线程的启动没有什么关系<br>★ Thread是维护整个线程的: 线程的启动、线程状态更改、线程结束，这两个本身的任务很分明的，不应该过度耦合[未来会发生很难扩展的问题]</p>
</blockquote>
<ul>
<li><h5 id="新建线程损耗"><a href="#新建线程损耗" class="headerlink" title="新建线程损耗"></a>新建线程损耗</h5></li>
</ul>
<blockquote>
<p>★ Runnable 在线程池更高级的用法中，一定不是每个任务都去新建一个线程的，为了提高整体的效率会让有限数量的线程由我们自己来确定，10个线程可以运行成千上万个任务。减少了新建线程的损耗。<br>可以把任务作为一个参数直接传递给线程池，线程池里面用固定的线程去执行任务不需要每次都新建和销毁线程，这样大大降低了线程的开销。</p>
<p>★ Runnable 如果用这个不得不去把线程损耗承担起来，有的时候run方法执行的比较少，开销的少比不上新建线程的开销[捡了芝麻丢了西瓜]。</p>
</blockquote>
<ul>
<li><h5 id="Java不支持双继承"><a href="#Java不支持双继承" class="headerlink" title="Java不支持双继承"></a>Java不支持双继承</h5></li>
</ul>
<blockquote>
<p>public class ThreadStyle extends Thread,Date (×)<br>Class cannot extend multiple classes</p>
<p>从语法的角度不允许继承多个类，一旦选定了一个父类就无法更改了[一辈子就被定死了]。在创建线程起就限制了代码的可扩展性，如果实现Runnable接口就不会出现这个问题，实现接口并不仅仅只能实现一个，实现接口后还可以继承类</p>
<blockquote>
<p>public class RunnableStyle extends Thread implements Runnable,Callable</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="两种方法的本质对比"><a href="#两种方法的本质对比" class="headerlink" title="两种方法的本质对比"></a><span style = "color:blue">两种方法的本质对比</span></h4><h5 id="方法一：最终调用target-run"><a href="#方法一：最终调用target-run" class="headerlink" title="方法一：最终调用target.run();"></a><span style = "color:red">方法一：最终调用target.run();</span></h5><blockquote>
<p>此方法本质是传入类后调用！<br>Ctrl+F12可以精确查找方法<br>@Override<br>public void run(){<br>    if(target !&#x3D; null){<br>        target.run()<br>    }<br>}<br>而target是什么呢？实际上就是我们写的<br>@Override<br>public void run() {<br>    System.<em>out</em>.println(“用Runnable方法实现线程”);<br>}</p>
</blockquote>
<h5 id="方法二：run-整个都被重写"><a href="#方法二：run-整个都被重写" class="headerlink" title="方法二：run()整个都被重写"></a><span style = "color:red">方法二：run()整个都被重写</span></h5><blockquote>
<p>整个重写代码</p>
</blockquote>
<h4 id="若同时使用这两种方法会发生什么？"><a href="#若同时使用这两种方法会发生什么？" class="headerlink" title="若同时使用这两种方法会发生什么？"></a>若同时使用这两种方法会发生什么？</h4><ul>
<li><h5 id="从面向对象的思想去考虑"><a href="#从面向对象的思想去考虑" class="headerlink" title="从面向对象的思想去考虑"></a>从面向对象的思想去考虑</h5></li>
</ul>
<pre><code class="java">com/imooc/interniew/createthreads/BothRunnableThread.java
package com.imooc.interniew.createthreads;
/**
 * 描述：     同时使用RUNNABLE和Thread两种方式实现线程
 */
public class BothRunnableThread &#123;

    public static void main(String[] args) &#123;
        Thread t1 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;实现Runnable接口的方式&quot;);
            &#125;
        &#125;) &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;我来自Thread&quot;);
            &#125;
        &#125;;
        t1.start();
    &#125;
&#125;
=========================================================
我来自Thread
---------------------------------------------------------
因为 run重写会被覆盖！！子类覆盖父类时 实行子类方法
@Override
public void run()&#123;
    if(target != null)&#123;
        target.run()
    &#125;
&#125;
</code></pre>
<h5 id="其他观点分析"><a href="#其他观点分析" class="headerlink" title="其他观点分析"></a>其他观点分析</h5><ul>
<li><p><strong>线程池</strong>创建线程也算是一种新建线程的方式 [把那两种方式进行包装]</p>
</li>
<li><p>通过<strong>Callable</strong>创建线程，也算是一种新建线程的方式</p>
</li>
<li><p>定时器[方法二：extends Thread]</p>
<pre><code class="java">package com.imooc.interniew.createthreads;

import java.util.Timer;
import java.util.TimerTask;

/**
 * 描述：     利用定时器新建线程
 */
public class TimerDemo &#123;

    public static void main(String[] args) &#123;
        System.out.println(Thread.currentThread().getName());
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() &#123;
            @Override
            public void run() &#123;
                System.out.println(Thread.currentThread().getName());
            &#125;
        &#125;, 1000, 1000);
    &#125;
&#125;
=======================================================
main     //两个不一致证明新建了一个线程
Timer-0
Timer-0
......
</code></pre>
</li>
<li><p>匿名内部类</p>
</li>
<li><p>Lambda表达式</p>
</li>
</ul>
<h5 id="实现多线程——常见面试问题-1"><a href="#实现多线程——常见面试问题-1" class="headerlink" title="实现多线程——常见面试问题"></a>实现多线程——常见面试问题</h5><ul>
<li>有多少种实现线程的方法？5点思路<ul>
<li>从<strong>不同的角度</strong>看，会有不同的答案</li>
<li>经典答案是<strong>两</strong>种</li>
<li>我们看原理，两种<strong>本质</strong>都是一样的</li>
<li>具体<strong>展开</strong>说其他方式</li>
</ul>
</li>
</ul>
<h5 id="总结：最精准的描述"><a href="#总结：最精准的描述" class="headerlink" title="总结：最精准的描述"></a>总结：最精准的描述</h5><blockquote>
<p>准确地讲：创建线程只有一种方法那就是构造Thread类，而实现线程的执行单元有两种方式<br>  ★ 方法一：实现<strong>Runnable</strong>接口的run方法，并把Runnable实例传給Thread类<br>  ★ 方法二：重写Thread的run方法(继承<strong>Thread</strong>类)<br>多线程的实现方法，在代码种写法千变万化，但其本质<strong>万变不离其宗</strong></p>
</blockquote>
<h3 id="线程的生命周期是什么？"><a href="#线程的生命周期是什么？" class="headerlink" title="线程的生命周期是什么？"></a>线程的生命周期是什么？</h3><h5 id="线程有几种状态？"><a href="#线程有几种状态？" class="headerlink" title="线程有几种状态？"></a>线程有几种状态？</h5><ul>
<li>有哪<strong>6</strong>种状态</li>
<li><strong>每个状态</strong>是什么含义？</li>
<li>状态间的转化？</li>
<li><strong>阻塞</strong>状态是什么？</li>
</ul>
<h5 id="每个状态是什么含义？"><a href="#每个状态是什么含义？" class="headerlink" title="每个状态是什么含义？"></a>每个状态是什么含义？</h5><ul>
<li>New</li>
<li>Runnable [从new到调用start方法]</li>
<li>Blocked [线程状态由sychronized修饰]</li>
<li>Waiting</li>
<li>Timed Waiting</li>
<li>Terminated</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/215ff6397d1cc14f17c11471dc420af64d92ea83/data/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" style="zoom: 200%;" />



<h3 id="状态转换的注意点和阻塞"><a href="#状态转换的注意点和阻塞" class="headerlink" title="状态转换的注意点和阻塞"></a>状态转换的注意点和阻塞</h3><pre><code class="java">com/imooc/interniew/NewRunnableTerminated.java
package com.imooc.interniew;

/**
 * 描述：     演示New、Runnable、Terminated状态。
 */
public class NewRunnableTerminated &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        Thread thread = new Thread();
        //打印出NEW的状态 线程被创建但没有启动会打出new状态
        System.out.println(thread.getState());
        thread.start();
        //打印出Runnable状态 线程被启动后打印runnable状态
        System.out.println(thread.getState());
        Thread.sleep(100);
        //打印出TERMINATED状态 打印terminate状态
        System.out.println(thread.getState());
    &#125;
&#125;
=================================================================================
NEW
RUNNABLE
TERMINATED

Process finished with exit code 0
</code></pre>
<pre><code class="java">com/imooc/interniew/BlockedWaitingTimedWaiting.java
package com.imooc.interniew;

/**
 * 描述：     展示Blocked、Waiting、Timed_Waiting状态
 */
public class BlockedWaitingTimedWaiting implements Runnable &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        Runnable runnable = new BlockedWaitingTimedWaiting();
        Thread t1 = new Thread(runnable);
        t1.start();
        Thread t2 = new Thread(runnable);
        t2.start();
        Thread.sleep(10);
        //打印Timed_Waiting状态，因为正在执行Thread.sleep(1000);
        System.out.println(t1.getState());
        //打印出BLOCKED状态，因为t2拿不到synchronized锁[线程1还在休眠]
        System.out.println(t2.getState());

        Thread.sleep(1300);
        //打印出WAITING状态，以为执行了wait()
        System.out.println(t1.getState());
    &#125;

    @Override
    public void run() &#123;
        syn();
    &#125;

    private synchronized void syn() &#123; //锁！！
        try &#123;
            Thread.sleep(1000);
            wait();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
=================================================================================
TIMED_WAITING
BLOCKED
WAITING
</code></pre>
<h5 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h5><ul>
<li>一般习惯而言，把<strong>Blocked</strong>(被阻塞)、<strong>Waiting</strong>(等待)、<strong>Timed_waiting</strong>(计时等待)都称为阻塞状态</li>
<li>不仅仅是Blocked</li>
</ul>
<h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a><span style = "color:red">分布式面试题</span></h1><h5 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h5><ul>
<li>饭店厨师的例子<ul>
<li>一个厨师</li>
<li>多个厨师</li>
<li>术业有专攻：配菜师、洗菜工</li>
</ul>
</li>
<li>实际项目的演进过程<ul>
<li>一个项目，大而全</li>
<li>多台机器，部署同样的应用</li>
<li>分布式：权限系统、员工系统、请假系统</li>
</ul>
</li>
</ul>
<h5 id="分布式和单体结构哪个更好？-脱离业务场景和发展阶段的空谈就是耍流氓"><a href="#分布式和单体结构哪个更好？-脱离业务场景和发展阶段的空谈就是耍流氓" class="headerlink" title="分布式和单体结构哪个更好？[脱离业务场景和发展阶段的空谈就是耍流氓]"></a>分布式和单体结构哪个更好？[脱离业务场景和发展阶段的空谈就是耍流氓]</h5><table>
<thead>
<tr>
<th></th>
<th>传统单体架构</th>
<th>分布式架构</th>
</tr>
</thead>
<tbody><tr>
<td>新人的学习成本</td>
<td>业务逻辑成本高</td>
<td>架构逻辑成本高</td>
</tr>
<tr>
<td>部署、运维</td>
<td>容易</td>
<td>发布频繁、发布顺序复杂、运维难</td>
</tr>
<tr>
<td>隔离性</td>
<td>一损俱损，殃及鱼池</td>
<td>故障影响范围小</td>
</tr>
</tbody></table>
<h3 id="CAP理论是什么？-只选其二-三者不可兼得"><a href="#CAP理论是什么？-只选其二-三者不可兼得" class="headerlink" title="CAP理论是什么？[只选其二 三者不可兼得]"></a>CAP理论是什么？[只选其二 三者不可兼得]</h3><ul>
<li>C(Consistency, 一致性)：读操作是否总能读到前一个写操作的结果</li>
<li>A(Availability, 可用性)：非故障节点应该在合理的时间内做出合理的响应</li>
<li>P(Partition tolerance, 分区容错性)：当出现网络分区现象后，系统能够继续运行</li>
</ul>
<h5 id="CAP怎么选？"><a href="#CAP怎么选？" class="headerlink" title="CAP怎么选？"></a>CAP怎么选？</h5><ul>
<li>CP或者AP</li>
<li>在什么场合，可用性高于一致性？</li>
</ul>
<h3 id="为什么需要Docker？"><a href="#为什么需要Docker？" class="headerlink" title="为什么需要Docker？"></a>为什么需要Docker？</h3><ul>
<li>Docker：用来装程序以及环境的容器</li>
<li><strong>环境配置</strong>的难题</li>
<li>虚拟机</li>
</ul>
<h5 id="Docker的用途是什么？"><a href="#Docker的用途是什么？" class="headerlink" title="Docker的用途是什么？"></a>Docker的用途是什么？</h5><ul>
<li>提供<strong>统一</strong>的环境</li>
<li>提供<strong>快速拓展</strong>、弹性伸缩的云服务</li>
<li>防止其他用户的进程把服务器资源<strong>占用过多</strong></li>
</ul>
<p>Docker的架构是什么样的？</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/28665426b3b7f9351280ab4c58b1ea388391f211/data/image%E9%95%9C%E5%83%8F.jpg"></p>
<h5 id="Docker的网络模式有哪些？"><a href="#Docker的网络模式有哪些？" class="headerlink" title="Docker的网络模式有哪些？"></a>Docker的网络模式有哪些？</h5><ul>
<li><strong>Bridge</strong> [桥接 用外面主机的端口号映射到里面的端口号 实现了一座桥]</li>
<li><strong>Host</strong> [里面的容器不会获得独立的网络配置 不会使用虚拟网卡ip 而是使用宿主机上的ip和端口号]</li>
<li>None [不需要网络模式]</li>
</ul>
<h3 id="Nginx的适用场景有哪些？"><a href="#Nginx的适用场景有哪些？" class="headerlink" title="Nginx的适用场景有哪些？"></a>Nginx的适用场景有哪些？</h3><ul>
<li><p>HTTP的<strong>反向代理</strong>服务器</p>
</li>
<li><p><strong>动态静态</strong>资源分离</p>
<ul>
<li>不分离会<strong>变慢</strong></li>
<li>静态资源<strong>无需经过Tomcat</strong>，Tomcat只负责处理动态请求</li>
<li>后缀为gif的时候，Nginx会直接获取到当前请求的文件并返回</li>
<li>静态资源服务器</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/93ef10f6db6a389181a9f20268c6c4b8b82c46d7/data/%E6%AD%A3%E5%90%91_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_.jpg"></p>
<h3 id="Nginx常用命令有哪些？"><a href="#Nginx常用命令有哪些？" class="headerlink" title="Nginx常用命令有哪些？"></a>Nginx常用命令有哪些？</h3><pre><code class="java">/usr/sbin/nginx 启动
-h 帮助
-c 读取指定的配置文件
-t 测试
-v 版本
-s信号
  stop 立即停止(不再接收任何请求立刻停止)  
  quit 优雅停止(不接收了但目前的请求要作完)
  reload 重启
  reopen 更换日志文件
</code></pre>
<h3 id="Zookeeper有哪些节点类型？"><a href="#Zookeeper有哪些节点类型？" class="headerlink" title="Zookeeper有哪些节点类型？"></a>Zookeeper有哪些节点类型？</h3><ul>
<li>持久节点</li>
<li>临时节点</li>
<li>顺序节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/15f1b158dfd61ad9498e5febc8d809e4dcb7f0af/data/Znode%E8%8A%82-%20%E6%A0%91%E5%BD%A2%E5%9B%BE.jpg"></p>
<h3 id="为什么要用消息队列？什么场景用？"><a href="#为什么要用消息队列？什么场景用？" class="headerlink" title="为什么要用消息队列？什么场景用？"></a>为什么要用消息队列？什么场景用？</h3><ul>
<li>系统<strong>解耦</strong></li>
<li><strong>异步</strong>调用</li>
<li>流量<strong>削峰</strong></li>
</ul>
<h5 id="消息队列RabbitMQ核心概念？"><a href="#消息队列RabbitMQ核心概念？" class="headerlink" title="消息队列RabbitMQ核心概念？"></a>消息队列RabbitMQ核心概念？</h5><p>同一个RabbitMQ的Server下建立不同的虚拟主机，他们之间是相互独立的，用于不同的业务线。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8fc65400c147b4cda128b49a11d646330a5860fc/data/RabiitMQ%E6%B6%88%E6%81%AF%E6%B5%81%E8%BD%AC%E6%96%B9%E5%BC%8F.jpg"></p>
<h5 id="交换机工作模式有哪4种？"><a href="#交换机工作模式有哪4种？" class="headerlink" title="交换机工作模式有哪4种？"></a>交换机工作模式有哪4种？</h5><ul>
<li><p><strong>fanout</strong>：广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的</p>
</li>
<li><p><strong>direct</strong>：根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/df64342f867398846ad29a0cb944a8490cd247b0/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-direct.jpg"></p>
<ul>
<li><p><strong>topic</strong>：比如消息严重性怎么样、只想记录error模块的用户信息</p>
<ul>
<li><p>***** 可以替代一个单词</p>
</li>
<li><p><strong>#</strong> 可以替代零个或多个单词</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76b7e6d6ebbac01f8f73850149fefbf50ca51712/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-topic%E7%94%9F%E4%BA%A7%E8%80%85.jpg"></p>
<ul>
<li><strong>headers</strong>：根据发送消息内容中的headers属性来匹配</li>
</ul>
<h1 id="微服务面试题"><a href="#微服务面试题" class="headerlink" title="微服务面试题"></a><span style = "color:red">微服务面试题</span></h1><h3 id="微服务有哪两大门派？"><a href="#微服务有哪两大门派？" class="headerlink" title="微服务有哪两大门派？"></a>微服务有哪两大门派？</h3><ul>
<li><strong>Spring Cloud</strong>：众多子项目</li>
<li><strong>dubbo</strong>：高性能、轻量级的开源RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</li>
<li>dubbo提供的能力只是SpringCloud的一部分<strong>子集</strong></li>
</ul>
<h5 id="Spring-Cloud核心组件有哪些？"><a href="#Spring-Cloud核心组件有哪些？" class="headerlink" title="Spring Cloud核心组件有哪些？"></a>Spring Cloud核心组件有哪些？</h5><table>
<thead>
<tr>
<th align="center">核心组件</th>
<th align="center">Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务注册中心</td>
<td align="center">Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td align="center">服务调用</td>
<td align="center">Spring Cloud Netflix Feign</td>
</tr>
<tr>
<td align="center">服务网关</td>
<td align="center">Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td align="center">断路器</td>
<td align="center">Spring Cloud Netflix Hystrix</td>
</tr>
</tbody></table>
<h5 id="画一下Eureka架构"><a href="#画一下Eureka架构" class="headerlink" title="画一下Eureka架构"></a>画一下Eureka架构</h5><ul>
<li>EureKa <strong>Server</strong> 和 EureKa <strong>Client</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6a3bfcded810da5a827559f3b8f868a0de867787/data/Eureka%E6%9E%B6%E6%9E%84.png"></p>
<ul>
<li><strong>集群</strong> [只要能获得一个Eureka Server 就能获得整个信息]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f756e06eed90edb75c6b3b6f234eee57763d8811/data/Eureka%E6%9E%B6%E6%9E%84-%E9%9B%86%E7%BE%A4.png"></p>
<h5 id="负载均衡的两种类型是什么？"><a href="#负载均衡的两种类型是什么？" class="headerlink" title="负载均衡的两种类型是什么？"></a>负载均衡的两种类型是什么？</h5><ul>
<li><strong>客户端</strong>负载均衡(Ribbon)</li>
<li><strong>服务端</strong>负载均衡(Nginx)</li>
</ul>
<h5 id="负载均衡有哪些策略？"><a href="#负载均衡有哪些策略？" class="headerlink" title="负载均衡有哪些策略？"></a>负载均衡有哪些策略？</h5><ul>
<li>RandomRule表示<strong>随机</strong>策略</li>
<li>RoundRobinRule表示<strong>轮询</strong>策略</li>
<li>ResponseTimeWeightedRule<strong>加权</strong>，根据每一个Server的平均响应时间动态加权</li>
</ul>
<h5 id="为什么需要断路器？"><a href="#为什么需要断路器？" class="headerlink" title="为什么需要断路器？"></a>为什么需要断路器？</h5><p>防止线程突然卡住，当发现某个模块不可用时，把它摘除不影响主要流程。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e441bfbcf0e2cf07f9d53564669b2dbd90533142/data/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%96%AD%E8%B7%AF%E5%99%A8.jpg"></p>
<h5 id="为什么需要网关？"><a href="#为什么需要网关？" class="headerlink" title="为什么需要网关？"></a>为什么需要网关？</h5><ul>
<li>签名校验、登录校验<strong>冗余</strong>问题</li>
<li>统一对外，安全 [对恶意IP进行拦截 打出日志]</li>
</ul>
<h5 id="Dubbo的工作流程是什么？"><a href="#Dubbo的工作流程是什么？" class="headerlink" title="Dubbo的工作流程是什么？"></a>Dubbo的工作流程是什么？</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/2ded5afda4ae8cff8392f5ccf0217657054c8981/data/Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<h3 id="彩蛋：学习编程知识的优质路径"><a href="#彩蛋：学习编程知识的优质路径" class="headerlink" title="彩蛋：学习编程知识的优质路径"></a>彩蛋：学习编程知识的优质路径</h3><ul>
<li><h5 id="宏观上"><a href="#宏观上" class="headerlink" title="宏观上"></a>宏观上</h5></li>
</ul>
<ol>
<li>并不是靠工作年限，有的人工作5年技术却还是只懂皮毛</li>
<li>要有强大的责任心，不放过任何bug，找到原因并去解决，这就是提高</li>
<li>主动：永远不会觉得自己的时间多余，重构、优化、学习、总结等</li>
<li>敢于承担：虽然这个技术难题以前没有碰到过，但是在一定的了解调研后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程种，进步是飞速的</li>
<li>关心产品，关心业务，而不是只写代码</li>
</ol>
<ul>
<li><h5 id="微观上"><a href="#微观上" class="headerlink" title="微观上"></a>微观上</h5></li>
</ul>
<ol>
<li>系统化的学习 看经典的书籍</li>
<li>看官方文档</li>
<li>自己动手写代码，尝试应用到项目中</li>
<li>不理解的内容参考多个知识来源，综合判断</li>
<li>学习开源项目，总结代码</li>
</ol>
<h3 id="Synchronized和Lock"><a href="#Synchronized和Lock" class="headerlink" title="Synchronized和Lock"></a>Synchronized和Lock</h3><h5 id="Lock简介、地址、作用"><a href="#Lock简介、地址、作用" class="headerlink" title="Lock简介、地址、作用"></a>Lock简介、地址、作用</h5><ul>
<li>锁是一种工具，用于控制对<strong>共享资源</strong>的访问</li>
<li>Lock和Synchronized，这两个是最常见的锁，它们都可以达到<strong>线程安全</strong>的目的，但是在使用上和功能上又有较大的不同</li>
<li>Lock并不是用来替代Synchronized的，而是当使用Synchronized不合适或不满足要求的时候，来提供<strong>高级功能</strong>的</li>
<li>Lock接口最常见的实现类是<strong>ReentrantLock</strong></li>
<li><strong>lock()、tryLock()、tryLock(long time, TimeUnit unit)</strong> 和<strong>locakInterruptibly()</strong></li>
</ul>
<h5 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h5><ul>
<li>lock()就是最普通的获取锁。如果锁已经被其他线程获取，则进行等待</li>
<li>Lock不会像Synchronized一样在<strong>异常时自动释放锁</strong></li>
<li>因此最佳实践是，在<strong>finally中释放锁</strong>，以保证发生异常时锁一定被释放</li>
<li>lock()方法不能被中断，这就会带来很大隐患：一旦陷入<strong>死锁</strong>，lock()就会陷入永久等待</li>
</ul>
<h5 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h5><ul>
<li>tryLock()用来<strong>尝试获取锁</strong>，如果当前锁没有被其他线程占用，则获取成功，则返回true，否则返回false，代表获取锁失败</li>
<li>相对比lock，这样的方法显然功能更加强大了，我们可以根据是否能获取到锁来<strong>决定后续程序的行为</strong></li>
<li>该方法会<strong>立即返回</strong>，即便在拿不到锁时不会一直在那等</li>
</ul>
<h5 id="tryLock-long-time-TimeUnit-unit-：超时就放弃"><a href="#tryLock-long-time-TimeUnit-unit-：超时就放弃" class="headerlink" title="tryLock(long time, TimeUnit unit)：超时就放弃"></a>tryLock(long time, TimeUnit unit)：超时就放弃</h5><p><strong>locakInterruptibly()<strong>：相当于tryLock(long time, TimeUnit unit)把超时时间设置为无限。在等待锁的过程中，线程可以被</strong>中断</strong></p>
<p><strong>unlock()：</strong>解锁 [最应该写在try…finally里面]</p>
<h4 id="Synchronized和Lock有什么不同？"><a href="#Synchronized和Lock有什么不同？" class="headerlink" title="Synchronized和Lock有什么不同？"></a>Synchronized和Lock有什么不同？</h4><h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h5><ul>
<li>保障资源线程的安全：目的和作用都是为了 保障资源线程的安全<br>[使用Synchronized后被保护的代码块最多只有一个线程可以访问]</li>
<li>可重入 [不然就必须在获得第二个锁前释放]</li>
</ul>
<pre><code class="java">com/imooc/interniew/Reentrant.java
package com.imooc.interniew;

/**
 * 描述：     synchronized可重入
 */
public class Reentrant &#123;

    public synchronized void f1() &#123;
        System.out.println(&quot;f1方法被运行了&quot;);
        f2();
    &#125;

    public synchronized void f2() &#123;
        System.out.println(&quot;f2方法被运行了&quot;);
    &#125;

    public static void main(String[] args) &#123;
        Reentrant reentrant = new Reentrant();
        reentrant.f1();
    &#125;
&#125;
========================================================
f1方法被运行了
f2方法被运行了
</code></pre>
<ul>
<li><strong>ReentrantLock</strong> [实现了Lock接口]</li>
</ul>
<h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><ul>
<li><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><ul>
<li>Synchronized用在方法上、用在同步代码块上 [隐式]</li>
<li>Lock必须使<u>用lock方法加锁</u>，<u>unlock方法解锁</u> [显式]</li>
</ul>
</li>
<li><h6 id="加解锁顺序不同"><a href="#加解锁顺序不同" class="headerlink" title="加解锁顺序不同"></a>加解锁顺序不同</h6><ul>
<li>Synchronized是java内部控制，自动加解锁</li>
<li>Lock可以手动调节</li>
</ul>
</li>
<li><h6 id="Synchronized锁不够灵活"><a href="#Synchronized锁不够灵活" class="headerlink" title="Synchronized锁不够灵活"></a>Synchronized锁不够灵活</h6><ul>
<li>Synchronized获得了一个锁 其他的只能等待</li>
<li>Lock获得锁很灵活 可以随时调整</li>
</ul>
</li>
<li><h6 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h6><ul>
<li>Synchronized由差到好 目前同等程度的性能</li>
</ul>
</li>
</ul>
<h3 id="你知道有几种锁？"><a href="#你知道有几种锁？" class="headerlink" title="你知道有几种锁？"></a>你知道有几种锁？</h3><ul>
<li><p><span style = "color:blue"><strong>共享锁</strong>[读写锁] 和 <strong>独占锁</strong>[排他锁]</span></p>
</li>
<li><p>共享锁，又称为读锁，获得<strong>共享锁</strong>之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但<strong>无法修改和删除</strong>数据</p>
</li>
<li><p>共享锁和排他锁的典型是读写锁<strong>ReentrantReadWriteLock</strong>，其中<strong>读锁是共享锁，写锁是独享锁</strong></p>
</li>
</ul>
<h5 id="读写锁的作用"><a href="#读写锁的作用" class="headerlink" title="读写锁的作用"></a>读写锁的作用</h5><ul>
<li>在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也<strong>浪费了一定的资源：多个读操作同时进行，并没有线程安全问题</strong></li>
<li>在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果<strong>没有写锁的情况下，读是无阻塞的</strong>，提高了程序的执行效率</li>
</ul>
<h5 id="读写锁的规则"><a href="#读写锁的规则" class="headerlink" title="读写锁的规则"></a>读写锁的规则</h5><ul>
<li>多个线程只申请读锁，都可以申请到</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁</li>
<li>一句话总结：要么是<strong>一个</strong>或<strong>多个</strong>线程同时有<strong>读锁</strong>，要么一个线程有写锁，但是两者不会同时出现(要么多读，要麽一写)</li>
</ul>
<h5 id="公平锁-和-非公平锁"><a href="#公平锁-和-非公平锁" class="headerlink" title="公平锁 和 非公平锁"></a><span style = "color:blue">公平锁 和 非公平锁</span></h5><ul>
<li>公平指的是按照线程请求的顺序，来分配锁</li>
<li>非公平指的是不完全按照请求的顺序，在一定情况下，可以插队 </li>
<li>注意：<strong>非公平</strong>也同样不提倡 ”插队“ 行为，这里的非公平，指的是”在合适的时机”插队，而不是盲目插队</li>
<li>什么是合适的时机呢？<ul>
<li>买火车票被插队的例子，排队买的例子</li>
</ul>
</li>
<li>实际情况并不是这样的，java设计者这样设计的目的是为了<strong>提高效率</strong></li>
<li><span style = "color:red"><strong>避免唤醒带来的空档期，提升吞吐量</strong></span></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>公平锁</td>
<td>各线程公平平等，每个线程在等待一段时间后，总有执行的机会</td>
<td>更慢，吞吐量更小</td>
</tr>
<tr>
<td>不公平锁</td>
<td>更快，吞吐量更大</td>
<td>有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行</td>
</tr>
</tbody></table>
<h5 id="悲观锁-和-乐观锁"><a href="#悲观锁-和-乐观锁" class="headerlink" title=" 悲观锁 和 乐观锁"></a><span style = "color:blue"> 悲观锁 和 乐观锁</span></h5><ul>
<li>从<strong>是否锁住资源</strong>的角度分类</li>
</ul>
<h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><ul>
<li>如果我不锁住这个资源，别人就会来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失</li>
<li>java中悲观锁的实现就是<code>synchronized</code>和<code>Lock</code>相关类</li>
</ul>
<h5 id="乐观锁-1"><a href="#乐观锁-1" class="headerlink" title="乐观锁"></a>乐观锁</h5><ul>
<li>认为自己在处理操作的时候不会有其他线程来干扰，所以并<strong>不会锁住</strong>被操作对象</li>
<li>在更新的时候，去对比在我修改的期间数据有没有被其他人改变过，如果<strong>没被改变过</strong>，就说明真的是只有我自己在操作，那我就正常去修改数据</li>
<li>如果数据和我<strong>一开始拿到的不一样</strong>了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略</li>
<li>乐观锁的实现一般都是利用<strong>CAS</strong>算法来实现的</li>
</ul>
<h6 id="在数据库中"><a href="#在数据库中" class="headerlink" title="在数据库中"></a>在数据库中</h6><ul>
<li><strong>select for update</strong>就是悲观锁</li>
<li>用<strong>version</strong>控制数据库就是乐观锁</li>
</ul>
<h6 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h6><pre><code class="mysql">添加一个字段lock_version
先查询这个更新语句的vesion：SELECT * FROM table
然后
UPDATE SET num = 2, 
version = version + 1 WHERE version = 1 AND id = 5
如果version被更新了等于2，不一样就会更新出错，这就是乐观锁的原理
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a6265784dee5e723d22bfceddca39a9a2afe91b8/data/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.jpg"></p>
<h5 id="自旋锁-和-非自旋锁"><a href="#自旋锁-和-非自旋锁" class="headerlink" title="自旋锁 和 非自旋锁"></a><span style = "color:blue">自旋锁 和 非自旋锁</span></h5><ul>
<li>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间</li>
<li>如果同步代码块的内容过于简单，<strong>状态转换消耗的时间有可能比用户代码执行的时间还要长</strong></li>
<li>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复线程的花费可能会让系统<strong>得不偿失</strong></li>
<li>如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁 </li>
<li>而为了让当前线程“<strong>稍等一下</strong>”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而<strong>避免切换线程的开销</strong>，这就是自旋锁。</li>
</ul>
<h5 id="自旋锁的缺点"><a href="#自旋锁的缺点" class="headerlink" title="自旋锁的缺点"></a>自旋锁的缺点</h5><ul>
<li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源</li>
<li>在自旋的过程中，一直消耗CPU，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的</li>
</ul>
<h5 id="可重入锁-和-非可重入锁"><a href="#可重入锁-和-非可重入锁" class="headerlink" title="可重入锁 和 非可重入锁"></a><span style = "color:blue">可重入锁 和 非可重入锁</span></h5><ul>
<li><p>什么是可重入 [摇一个号拿N个牌]</p>
</li>
<li><p>好处 [避免死锁]</p>
</li>
</ul>
<h5 id="可中断锁-和-不可中断锁"><a href="#可中断锁-和-不可中断锁" class="headerlink" title="可中断锁 和 不可中断锁"></a><span style = "color:blue">可中断锁 和 不可中断锁</span></h5><ul>
<li>可中断锁 [可以随时中断]</li>
</ul>
<h3 id="死锁相关"><a href="#死锁相关" class="headerlink" title="死锁相关"></a>死锁相关</h3><h5 id="写一个必然死锁的例子？"><a href="#写一个必然死锁的例子？" class="headerlink" title="写一个必然死锁的例子？"></a>写一个必然死锁的例子？</h5><h6 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h6><ul>
<li><p>发生在<strong>并发</strong>中</p>
</li>
<li><p><strong>互不相让</strong>：当两个(或更多)线程(或进程)相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁</p>
</li>
<li><p>一图胜千言</p>
</li>
<li><p>线程A持有锁1但试图获取锁2 线程B持有锁2但视图获取锁1</p>
</li>
</ul>
<h5 id="多个线程造成死锁的情况"><a href="#多个线程造成死锁的情况" class="headerlink" title="多个线程造成死锁的情况"></a>多个线程造成死锁的情况</h5><ul>
<li>如果多个线程之间的依赖关系是<strong>环形</strong>，存在环路的锁的依赖关系，那么也可能会发生死锁</li>
</ul>
<h5 id="死锁的影响"><a href="#死锁的影响" class="headerlink" title="死锁的影响"></a>死锁的影响</h5><ul>
<li>死锁的影响在不同系统中是不一样的，这取决于系统对死锁的处理能力<ul>
<li><strong>数据库</strong>中：检测并放弃事务</li>
<li><strong>JVM</strong>中：无法自动处理</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ce81bd17386cbcc3d04b5ef352a1c492ec9b0668/data/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81.jpg"></p>
<h5 id="几率不高但危害大"><a href="#几率不高但危害大" class="headerlink" title="几率不高但危害大"></a>几率不高但危害大</h5><ul>
<li>不一定发生，但是遵守<strong>墨菲定律</strong></li>
<li>一旦发生，多是<strong>高并发</strong>场景，影响用户多</li>
<li>整个<strong>系统崩溃</strong>、子系统崩溃、性能降低</li>
<li>压力测试<strong>无法找出</strong>所有潜在的死锁</li>
</ul>
<pre><code class="java">deadlock/DeadLock.java
package deadlock;

/**
 * 描述：     必然发生死锁
 */
public class DeadLock implements Runnable &#123;

    public int flag;

    static Object o1 = new Object();
    static Object o2 = new Object();

    public void run() &#123;
        System.out.println(&quot;开始执行&quot;);
        if (flag == 1) &#123;
            synchronized (o1) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o2) &#123;
                    System.out.println(&quot;成功获取到了两把锁&quot;);
                &#125;
            &#125;
        &#125;
        if (flag == 2) &#123;
            synchronized (o2) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o1) &#123;
                    System.out.println(&quot;成功获取到了两把锁&quot;);
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        DeadLock r1 = new DeadLock();
        DeadLock r2 = new DeadLock();
        r1.flag = 1;
        r2.flag = 2;
        new Thread(r1).start();
        new Thread(r2).start();
    &#125;
&#125;
====================================== 分析 =======================================
★ 当类的对象flag=1时(T1),先锁定O1,睡眠500毫秒，然后锁定O2;
★ 而T1在睡眠的时候另一个flag=2的对象(T2)线程启动，先锁定O2，睡眠500毫秒，等待T1释放O1;
★ T1睡眠结束后需要锁定O2才能继续执行，而此时O2已被T2锁定
★ T2睡眠结束后需要锁定O1才能继续执行，而此时O1已被T1锁定
★ T1、T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁
</code></pre>
<h3 id="哲学家就餐问题？"><a href="#哲学家就餐问题？" class="headerlink" title="哲学家就餐问题？"></a>哲学家就餐问题？</h3><ul>
<li>先拿起左手的筷子</li>
<li>然后拿起右手的筷子</li>
<li>如果筷子被人使用了，那就等别人用完</li>
</ul>
<pre><code class="java">while(true)&#123; //伪代码
    think();
    pick_up_left_fork();
    pick_up_right_fork();
    eat();
    put_down_right_fork();
    put_down_left_fork();
&#125;
</code></pre>
<pre><code class="java">package deadlock;

/**
 * 描述：     哲学家就餐问题导致的死锁
 */
public class DiningPhilosophers &#123;

    public static class Philosopher implements Runnable &#123;

        private Object leftChopstick;

        public Philosopher(Object leftChopstick, Object rightChopstick) &#123;
            this.leftChopstick = leftChopstick;
            this.rightChopstick = rightChopstick;
        &#125;

        private Object rightChopstick;

        @Override
        public void run() &#123;
            try &#123;
                while (true) &#123;
                    doAction(&quot;Thinking&quot;);
                    synchronized (leftChopstick) &#123;
                        doAction(&quot;Picked up left chopstick&quot;);
                        synchronized (rightChopstick) &#123;
                            doAction(&quot;Picked up right chopstick - eating&quot;);
                            doAction(&quot;Put down right chopstick&quot;);
                        &#125;
                        doAction(&quot;Put down left chopstick&quot;);
                    &#125;
                &#125;
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        private void doAction(String action) throws InterruptedException &#123;
            System.out.println(Thread.currentThread().getName() + &quot; &quot; + action);
            Thread.sleep((long) (Math.random() * 10));
        &#125;
    &#125;

    public static void main(String[] args) &#123;//五个哲学家方便管理
        Philosopher[] philosophers = new Philosopher[5];
        Object[] chopsticks = new Object[philosophers.length];
        for (int i = 0; i &lt; chopsticks.length; i++) &#123;
            chopsticks[i] = new Object();
        &#125;
        for (int i = 0; i &lt; philosophers.length; i++) &#123;
            Object leftChopstick = chopsticks[i]; //从0开始 i为5 所以底下要加1 但是越界就取余
            Object rightChopstick = chopsticks[(i + 1) % chopsticks.length];
            //领导调节(检测与恢复策略) [定期巡视命令哲学家] 让最后一个 跟别人不一样 
            //别人都是先左后右面 它是先后面再左边 避免了环路的形成
            //直接避免死锁发生！！！！！
            if (i == philosophers.length - 1) &#123;
                philosophers[i] = new Philosopher(rightChopstick, leftChopstick);
            &#125; else &#123;
                philosophers[i] = new Philosopher(leftChopstick, rightChopstick);
            &#125;
            new Thread(philosophers[i], &quot;哲学家&quot; + (i + 1) + &quot;号&quot;).start();
        &#125;
    &#125;
&#125;
=============================================================================
哲学家4号 Thinking
哲学家5号 Thinking
哲学家3号 Thinking
哲学家1号 Thinking
哲学家2号 Thinking
哲学家2号 Picked up left chopstick
哲学家3号 Picked up left chopstick
哲学家1号 Picked up left chopstick
哲学家4号 Picked up left chopstick
哲学家4号 Picked up right chopstick - eating
哲学家4号 Put down right chopstick
哲学家4号 Put down left chopstick
哲学家4号 Thinking
哲学家3号 Picked up right chopstick - eating
哲学家3号 Put down right chopstick
哲学家3号 Put down left chopstick
哲学家4号 Picked up left chopstick
哲学家4号 Picked up right chopstick - eating
哲学家4号 Put down right chopstick
哲学家4号 Put down left chopstick
哲学家3号 Thinking
哲学家2号 Picked up right chopstick - eating
哲学家4号 Thinking
哲学家2号 Put down right chopstick
哲学家4号 Picked up left chopstick
哲学家4号 Picked up right chopstick - eating
.............................
发生死锁的时候哲学家都拿着左边的筷子
原理：Thread.sleep((long) (Math.random() * 10));
random到了一个更大的数
</code></pre>
<h5 id="多种解决策略"><a href="#多种解决策略" class="headerlink" title="多种解决策略"></a>多种解决策略</h5><ul>
<li>服务员检查(避免策略) [提前看一看是否发生死锁]</li>
<li><strong>改变一个哲学家拿叉子的顺序</strong>(避免策略)</li>
<li>餐票(避免策略)</li>
<li>领导调节(检测与恢复策略) [定期巡视命令哲学家]</li>
</ul>
<h5 id="实际工程中如何避免死锁"><a href="#实际工程中如何避免死锁" class="headerlink" title="实际工程中如何避免死锁"></a>实际工程中如何避免死锁</h5><h6 id="①-设置超时时间"><a href="#①-设置超时时间" class="headerlink" title="① 设置超时时间"></a>① 设置<strong>超时</strong>时间</h6><ul>
<li>Lock的<strong>tryLock</strong>(long timeout, TImeUnit unit)</li>
<li><strong>synchronized</strong>不具备尝试锁的能力</li>
<li>造成超时的可能性很多：发生了死锁、线程陷入死循环、线程执行很慢</li>
<li>获取锁失败：打日志、发报警邮件、<strong>重启</strong>等</li>
<li>代码演示：<strong>退一步海阔天空</strong></li>
</ul>
<pre><code class="java">package deadlock;

import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 描述：     用tryLock来避免死锁
 */
public class TryLockDeadlock implements Runnable &#123;

    int flag = 1;
    static Lock lock1 = new ReentrantLock();
    static Lock lock2 = new ReentrantLock();

    public static void main(String[] args) &#123;
        TryLockDeadlock r1 = new TryLockDeadlock();
        TryLockDeadlock r2 = new TryLockDeadlock();
        r1.flag = 1;
        r2.flag = 0;
        new Thread(r1).start();
        new Thread(r2).start();
    &#125;

    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            if (flag == 1) &#123;
                try &#123;
                    if (lock1.tryLock(800, TimeUnit.MILLISECONDS)) &#123;
                        System.out.println(&quot;线程1获取到了锁1&quot;);
                        Thread.sleep(new Random().nextInt(1000));
                        if (lock2.tryLock(800, TimeUnit.MILLISECONDS)) &#123;
                            System.out.println(&quot;线程1获取到了锁2&quot;);
                            System.out.println(&quot;线程1成功获取到了两把锁&quot;);
                            lock2.unlock();
                            lock1.unlock();
                            break;
                        &#125; else &#123;
                            System.out.println(&quot;线程1尝试获取锁2失败，已重试&quot;);
                            lock1.unlock();
                            Thread.sleep(new Random().nextInt(1000));
                        &#125;
                    &#125; else &#123;
                        System.out.println(&quot;线程1获取锁1失败，已重试&quot;);
                    &#125;
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if (flag == 0) &#123;
                try &#123;
                    if (lock2.tryLock(3000, TimeUnit.MILLISECONDS)) &#123;
                        System.out.println(&quot;线程2获取到了锁2&quot;);

                        Thread.sleep(new Random().nextInt(1000));
                        if (lock1.tryLock(3000, TimeUnit.MILLISECONDS)) &#123;
                            System.out.println(&quot;线程2获取到了锁1&quot;);
                            System.out.println(&quot;线程2成功获取到了两把锁&quot;);
                            lock1.unlock();
                            lock2.unlock();
                            break;
                        &#125; else &#123;
                            System.out.println(&quot;线程2尝试获取锁1失败，已重试&quot;);
                            lock2.unlock();
                            Thread.sleep(new Random().nextInt(1000));
                        &#125;
                    &#125; else &#123;
                        System.out.println(&quot;线程2获取锁2失败，已重试&quot;);
                    &#125;
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
====================================================================================
线程1获取到了锁1
线程2获取到了锁2
线程1尝试获取锁2失败，已重试 【正是有了线程1的释放 才让线程2拿到了锁1】
线程2获取到了锁1
线程2成功获取到了两把锁
线程1获取到了锁1
线程1获取到了锁2
线程1成功获取到了两把锁
</code></pre>
<h6 id="②-多使用并发类而不是自己设置锁"><a href="#②-多使用并发类而不是自己设置锁" class="headerlink" title="② 多使用并发类而不是自己设置锁"></a>② 多使用并发类而不是自己设置锁</h6><h6 id="③-尽量降低锁的使用粒度：用不同的锁而不是一个锁"><a href="#③-尽量降低锁的使用粒度：用不同的锁而不是一个锁" class="headerlink" title="③ 尽量降低锁的使用粒度：用不同的锁而不是一个锁"></a>③ 尽量降低锁的使用粒度：用不同的锁而不是一个锁</h6><h6 id="④-如果能使用同步代码块，就不使用同步方法：自己锁定锁对象"><a href="#④-如果能使用同步代码块，就不使用同步方法：自己锁定锁对象" class="headerlink" title="④ 如果能使用同步代码块，就不使用同步方法：自己锁定锁对象"></a>④ 如果能使用同步代码块，就不使用同步方法：自己锁定锁对象</h6><h6 id="⑤-给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践"><a href="#⑤-给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践" class="headerlink" title="⑤ 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践"></a>⑤ 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践</h6><h3 id="Hashmap为什么-线程-不安全？"><a href="#Hashmap为什么-线程-不安全？" class="headerlink" title="Hashmap为什么[线程]不安全？"></a>Hashmap为什么[线程]不安全？</h3><ul>
<li><p>i++</p>
<ul>
<li>第一个步骤是<strong>读取</strong></li>
<li>第二个步骤是<strong>增加</strong></li>
<li>第三个步骤是<strong>保存</strong></li>
</ul>
<p>有可能会发生线程不安全的情况<br><img src="https://raw.githubusercontent.com/P-luminary/images/ae6685b2f5be7812a77134895bdd7c4fe843933f/data/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8.jpg"></p>
</li>
<li><p>同时put碰撞导致数据丢失</p>
</li>
<li><p>可见性问题无法保证</p>
</li>
</ul>
<h3 id="final的作用是什么？有哪些用法？"><a href="#final的作用是什么？有哪些用法？" class="headerlink" title="final的作用是什么？有哪些用法？"></a>final的作用是什么？有哪些用法？</h3><ul>
<li>final修饰<strong>变量</strong></li>
<li>final修饰<strong>方法</strong></li>
<li>final修饰<strong>类</strong></li>
</ul>
<h5 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h5><ul>
<li>早期<ul>
<li>锁定</li>
<li>final效率：早期的Java实现版本中，会将final方法转为内嵌调用</li>
</ul>
</li>
<li>现在<ul>
<li><strong>类防止被继承、方法防止被重写、变量防止被修改</strong></li>
<li>天生是<strong>线程安全</strong>的，而不需要额外的同步开销</li>
</ul>
</li>
</ul>
<h5 id="final的3种用法"><a href="#final的3种用法" class="headerlink" title="final的3种用法"></a>final的3种用法</h5><h6 id="final修饰变量：赋值时机"><a href="#final修饰变量：赋值时机" class="headerlink" title="final修饰变量：赋值时机"></a>final修饰变量：赋值时机</h6><ul>
<li><p><strong>属性</strong>被声明为final后，该变量则<strong>只能被赋值一次</strong>。且一旦被赋值，final的变量就<strong>不能再被改变</strong>，无论如何也不会改变</p>
</li>
<li><p>final修饰<strong>变量</strong></p>
<ul>
<li><p>final instance variable (类中的final属性) </p>
<ul>
<li>第一种是在声明变量的<strong>等号右边</strong>直接赋值</li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰变量
 */
public class FinalVariable &#123;

    public static int a = 5;

    public static void main(String[] args) &#123;
        FinalVariable.a = 8;
    &#125;
&#125;
</code></pre>
<ul>
<li>第二种就是<strong>构造函数</strong>中赋值</li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰变量
 */
public class FinalVariable &#123;

    public final int a;

    public testFinal(int a) &#123;
        this.a = b;
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<ul>
<li>第三种就是在类的<strong>初始代码块种</strong>赋值(不常用)</li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰变量
 */
public class FinalVariable &#123;

    public static final int a;

    static &#123;
        a = 9;
    &#125;

    void testFinal() &#123;
        final int b;
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<ul>
<li>如果不采用第一种赋值方法，那么就必须在第2、3种挑一个来赋值，而不能不赋值，这是final语法所 规定的</li>
</ul>
</li>
<li><p>final <strong>static</strong> variable (类中的static final属性)</p>
<ul>
<li>两种赋值时机：除了在声明变量的<strong>等号右边</strong>直接赋值外，static final变量还可以用<strong>static初始代码块</strong>赋值，但是不能用普通的初始代码块赋值</li>
</ul>
</li>
<li><p>final <strong>local</strong> variable (方法中的final变量)</p>
<ul>
<li>和前两种不同，由于这里的变量是在方法里的，所以没有构造函数，也不存在初始代码块</li>
<li>final local variable不规则赋值时机，只要求在<strong>使用前必须赋值</strong>，这和方法中的非final变量的要求也是一样的</li>
</ul>
</li>
</ul>
<h6 id="为什么要规定赋值时机？"><a href="#为什么要规定赋值时机？" class="headerlink" title="为什么要规定赋值时机？"></a>为什么要规定赋值时机？</h6><ul>
<li>如果初始化不赋值，<strong>后续赋值，就是从null变成你的赋值</strong>，这就违反final不变的规则了</li>
</ul>
</li>
<li><p>final修饰<strong>方法</strong></p>
<ul>
<li><strong>构造方法</strong>不允许final修饰</li>
<li><strong>不可被重写</strong>，也就是不能被<strong>override</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰方法
 */
public class FinalMethodDemo&#123;

    public void drink() &#123;
    &#125;

    public final void eat() &#123;
    &#125;
&#125;

class SubClass extends FinalMethodDemo &#123;

    @Override
    public void drink() &#123;
        super.drink();
    &#125;

//    @Override
//    public void eat() &#123;
//        super.drink();
//    &#125;
&#125;
</code></pre>
</li>
<li><p>final修饰<strong>类</strong></p>
<ul>
<li><strong>不可被继承</strong></li>
<li>例如经典的<strong>String类就是final</strong>的，我们从见过哪个类是继承String类的</li>
</ul>
</li>
</ul>
<h3 id="单例模式你会写吗？"><a href="#单例模式你会写吗？" class="headerlink" title="单例模式你会写吗？"></a><span style = "color:red">单例模式你会写吗？</span></h3><ul>
<li><h5 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h5></li>
</ul>
<p>保证只有一个实例且提供只有一个全局入口</p>
<ul>
<li><h5 id="为什么需要单例：节省内存和计算、保证结果正确、方便管理"><a href="#为什么需要单例：节省内存和计算、保证结果正确、方便管理" class="headerlink" title="为什么需要单例：节省内存和计算、保证结果正确、方便管理"></a>为什么需要单例：节省内存和计算、保证结果正确、方便管理</h5></li>
<li><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>无状态的工具类</li>
<li>全局信息类</li>
</ul>
</li>
<li><h5 id="单例模式的8种写法"><a href="#单例模式的8种写法" class="headerlink" title="单例模式的8种写法"></a>单例模式的8种写法</h5><ul>
<li>饿汉式(静态常量) [可用]</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     饿汉式（静态常量）（可用）
 */
public class Singleton1 &#123;

    private Singleton1() &#123;

    &#125;

    private final static Singleton1 INSTANCE = new Singleton1();
// [未达到懒加载] 直接创建出来了
    public static Singleton1 getInstance() &#123;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>饿汉式(静态代码块) [可用]</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     饿汉式（静态代码块）（可用） // [未达到懒加载]
 */
public class Singleton2 &#123;

    private Singleton2() &#123;

    &#125;

    static &#123;
        INSTANCE = new Singleton2();
    &#125;
    private final static Singleton2 INSTANCE;

    public static Singleton2 getInstance() &#123;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>懒汉式(线程不安全) <strong>[不可用]</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程不安全）
 */
public class Singleton3 &#123;

    private Singleton3() &#123;

    &#125;

    private static Singleton3 INSTANCE;

    public static Singleton3 getInstance() &#123;
        if (INSTANCE == null) &#123;//第一次访问方法
            INSTANCE = new Singleton3();//初始化
        &#125;
        //此时如果两个线程同时访问，都是null，就创造了两个初始化 违反单例模式
        return INSTANCE; //已经被初始化 就返回
    &#125;
&#125;
</code></pre>
<ul>
<li>懒汉式(线程安全，同步方法) <strong>[不推荐用]</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程安全，同步方法）（不推荐）
 */
public class Singleton4 &#123;

    private Singleton4() &#123;

    &#125;

    private static Singleton4 INSTANCE;
    //synchronized同步关键字 最多一个线程访问
    //不推荐用的原因是因为一旦适用了synchronized同步关键字 线程就要排队 并发量大
    public synchronized static Singleton4 getInstance() &#123;
        if (INSTANCE == null) &#123;
            INSTANCE = new Singleton4();
        &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//方法上不进行同步了
package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程安全，同步方法）（不推荐）
 */
public class Singleton5 &#123;

    private Singleton5() &#123;

    &#125;

    private static Singleton5 INSTANCE;

    public static Singleton5 getInstance() &#123;
        if (INSTANCE == null) &#123; //此时不会存在两个线程同时出来了
            synchronized (Singleton5.class) &#123;
                //假如第一个执行完了 第二个进去执行 那么结果还是生成了两个 不符合单例
                INSTANCE = new Singleton5();
            &#125;
        &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>双重检查[推荐用]</strong><ul>
<li>新建一个对象，但还未初始化</li>
<li>调用构造函数等来初始化该对象</li>
<li>把对象指向引用</li>
</ul>
</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程安全，同步方法）（不推荐）
 */
public class Singleton6 &#123;

    private Singleton6() &#123;//2

    &#125;

    private static volatile Singleton6 INSTANCE;

    public static Singleton6 getInstance() &#123;
        if (INSTANCE == null) &#123;
            synchronized (Singleton6.class) &#123;
                if (INSTANCE == null) &#123; //3
                    //就不会出现多个结果了
                    INSTANCE = new Singleton6 //1
                &#125;
            &#125;
        &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>静态内部类[推荐用]</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     静态内部类写法（推荐用）
 */
public class Singleton7 &#123;

    private Singleton7() &#123;

    &#125;

    private static class SingletonInstance &#123;
        private static Singleton7 INSTANCE = new Singleton7();
    &#125;

    public static Singleton7 getInstance() &#123;
        return SingletonInstance.INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>枚举[推荐用]</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     枚举单例模式
 */
public enum Singleton8 &#123;
    //1.写法简洁
    //2.线程安全
    //3.防止反射
    
    INSTANCE;
&#125;
</code></pre>
</li>
</ul>
<h5 id="不同写法对比"><a href="#不同写法对比" class="headerlink" title="不同写法对比"></a>不同写法对比</h5><ul>
<li><strong>饿汉</strong>：简单，但是没有lazy loading</li>
<li><strong>懒汉</strong>：有线程安全问题</li>
<li><strong>静态内部类</strong>：可用</li>
<li><strong>双重检查：面试用</strong></li>
<li><strong>枚举：最好</strong></li>
</ul>
<h5 id="单例模式面试常见问题"><a href="#单例模式面试常见问题" class="headerlink" title="单例模式面试常见问题"></a>单例模式面试常见问题</h5><ul>
<li>饿汉式的缺点？[没有懒加载]</li>
<li>懒汉式的缺点？[不可以保证线程安全]</li>
<li><strong>为什么要用double-check</strong>？不用就不安全吗？</li>
<li>为什么双重检查模式要用<strong>volatile</strong>？</li>
<li>应该如何选择，<strong>用哪种单例的实现方案最好</strong>？<ul>
<li>单元素的枚举类型已经成为实现Singleton的最佳方法</li>
<li>写法简单</li>
<li>线程安全有保障</li>
<li>避免反射破坏单例</li>
</ul>
</li>
</ul>
<h3 id="面试避坑指南-1"><a href="#面试避坑指南-1" class="headerlink" title="面试避坑指南"></a>面试避坑指南</h3><ul>
<li>何时投简历 [Offer数量只会越来越少，越早越好]  秋招7-9月 社招金3银4 </li>
<li>信息尽量全面</li>
<li>技术栈契合</li>
<li>慎用”<strong>精通</strong>“ [对源码有很多熟悉] &#x3D;&gt; 多写<strong>熟悉</strong></li>
<li>面试无处不在 [如果没时间可以申请换一个时间节点 并询问对方是否有时间]</li>
<li>提前调试设备</li>
<li>仪容仪表、提前到场 [提前5分钟左右联系面试官]</li>
<li>确认问题 [实在不会可以说思路设想]</li>
<li>问面试官的问题 [提前查公司信息 我了解到我们公司… 可不可以介绍一下… 未来规划… 技术栈…]</li>
</ul>
<h3 id="哪些软素质值得面试官认可？"><a href="#哪些软素质值得面试官认可？" class="headerlink" title="哪些软素质值得面试官认可？"></a>哪些软素质值得面试官认可？</h3><ul>
<li>基本能力：聆听、沟通表达、<strong>学习能力</strong></li>
<li>工作能力：<strong>协作</strong>、<strong>执行力</strong>、管理能力</li>
<li>个人素质：技术自驱力、韧性、积极开放的心态</li>
</ul>
<h3 id="面试课总结"><a href="#面试课总结" class="headerlink" title="面试课总结"></a>面试课总结</h3><ul>
<li>Spring Boot常见面试题</li>
<li>线程常见面试题</li>
<li>分布式的面试题</li>
<li>Docker相关面试题</li>
<li>Nginx和Zookeeper相关面试题</li>
<li>RabbitMQ相关面试题</li>
<li>微服务相关</li>
<li>彩蛋：学习方法</li>
<li>锁分类、死锁</li>
<li>HashMap和final</li>
<li>单例模式[高频考点]</li>
<li>面试避坑指南</li>
<li>重要的软实力</li>
</ul>
<h4 id="2024-5-9-14-34-在创新楼B105-JSP动态网页设计课上-完成了java-4399全部课程的学习"><a href="#2024-5-9-14-34-在创新楼B105-JSP动态网页设计课上-完成了java-4399全部课程的学习" class="headerlink" title="2024.5.9 14:34   在创新楼B105-JSP动态网页设计课上  完成了java+4399全部课程的学习"></a><span style = "color:red">2024.5.9 14:34   在创新楼B105-JSP动态网页设计课上  完成了java+4399全部课程的学习</span></h4>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/05/04/后端/Zookeeper-Dubbo应用与面试/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/04/17/英语/2024万能论据/">
        <h2>
            2024万能论据
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><pre><code class="java">1.sth contribute to one&#39;s health by giving sb some physical exercise.
  某物能有助于身体健康通过给某人一些身体锻炼
2.sth is harmful to/bad for/detrimental to health.
  某物对健康有害
3.sth exert great pressure on sb.
  某物给某人施加重压
4.sb may become more solitary and even suffer from certain mental illness.
  某人可能变得孤僻甚至产生某些心理疾病
5.Exercise can enhance immune function.
  锻炼可以增强免疫力
6.adopt a healthy and meaningful life style.
  采取一个健康和有意义的生活方式
7.release pressure.
  ★减压 
</code></pre>
<h2 id="乐趣"><a href="#乐趣" class="headerlink" title="乐趣"></a>乐趣</h2><pre><code class="java">1.sth will make ones&#39;s life more enjoyable. That is to say, sth can add color to the dull routine of everyday life.
  某物可以使某人的生活更加有乐趣，也就是说，某物为每天枯燥的生活增添了一些色彩
2.sth have become the foucus of one&#39;s life and the source of one&#39;s happiness and contentment.
  某物已成为某人生活的中心和快乐的来源
</code></pre>
<h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><pre><code class="java">1.equip sb with the ability to do sth.
  ★使某人拥有做某事的能力
2.be competent enough to do sth.
  ★有能力做某事
3.tell the useful information from the useless one.
  ★从无用信息中挑出有用信息
4.sth will provide sb with more opportunities to develop one’s interpersonal skills, which may put them in a favorable position in the future job markets.
  某事会使某人有更多机会发展人际交往能力，而这对他（们）未来找工作是非常有好处的
5.By doing sth, sb can not only improve one’s academic studies, but gain many abilities which he will never be able to get from the textbooks.
  通过做某事，某人不仅能够提高他们的专业能力，而且能获得从课本上得不到的能力
6.tap one&#39;s potential.
  ★开发潜能
7.sth will help people foster one&#39;s independence.
  某物帮助某人培养独立
8.help strengthen one&#39;s sense of responsibility.
  ★帮助加强某人的责任感
9.achieve one&#39;s goal.
  ★达成某人的目标
10.learn from mistake.
  ★吸取教训
11.surmount difficulities
  ★战胜困难
</code></pre>
<h3 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h3><pre><code class="java">1.develop and cultivate character and interpersonal skills.
  ★培养性格和人际交往的能力
2.make eye contact.
  ★做眼神交流
3.live only in the virtual world.
  ★仅仅生活在虚拟世界
4.hinder communication.
  ★阻碍沟通
5.The over-dependence on mobile phones can harm the relationship among friends and family.
  过度依赖手机会伤害朋友以及家人的关系
6.At dinner tables, instead of chatting and laughing with each other, many people choose to chat with other friends online.
  在饭桌前，人们不是相互聊天谈笑，而是选择和朋友在网上聊天
7.Many people have become over-dependent on the Internet and neglected face-to-face communication.
  很多人变得太依赖网络并且忽略了面对面交流。
8.The Internet enables more effective communication in some situations, but over-dependence on it actually pulls people apart.
  网络在一些情况下使交流更有效，但是过度依赖它实际是人们更疏远
</code></pre>
<h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><pre><code class="java">1.Little by little, our knowledge will be well enriched, and our horizons will be greatly broadened.
  逐渐的，我们的知识会得到增加，我们的视野将会大大的拓宽
2.reduce study load 
  ★减轻学习负担
3.sth can broaden people&#39;s minds to the extent which may not be reached previously.
  某物可以扩大人们的视野到一个之前不能到达的程度
</code></pre>
<h3 id="方便"><a href="#方便" class="headerlink" title="方便"></a>方便</h3><pre><code class="java">1.sth can save sb a great deal of time, so sb would be able to concentrate more time and energy on one&#39;s academic work.
  某物能节省大量时间，这会使某人有更多的时间和精力放在学习上
2.sth have brought people great convenience in doing sth.
  某物在人们做某事时带来了巨大的方便
3.There is no denying that sth have greatly enhanced work/study efficiency.
  毋庸置疑，某物很大的提升了工作/学习效率
</code></pre>
<h3 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h3><pre><code class="java">1.relieve one&#39;s families&#39; financial burden to some extent.
  这在一定基础上可以缓解某人家庭的经济负担
2.The welfare and salary have been improved greatly.
  福利和收入得到了巨大的提升
3.Money is so indispensable in people’s lives that without it no material comforts or well-being can be guaranteed.
  钱在生活中必不可少，没有了钱，也就谈不上物质享受和幸福了
4.Money doesn&#39;t necessarily ensure happiness or well-being. 
  钱不一定能保证幸福
5.can afford the huge cost of sth.
  ★能够承担某物的高额
6.bring huge economic loss to sb.
  ★给某人带来巨大经济损失
</code></pre>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><pre><code class="java">1.sth pose a great threat to one&#39;s safety.
  某物对某人的安全造成巨大威胁
2.ensure the safety of sb. 
  ★确保某人的安全
3.sth add to the safety of sth.
  某物增加了某事的安全
4.food safety.
  ★食品安全
</code></pre>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><pre><code class="java">1.To balance economic growth with environmental protection is highly important.
  权衡经济发展和环境保护是高度重要的
2.We all should bear in mind that environmental protection is everybody&#39;s duty.
  我们都应该记住环境保护使每个人的职责
3.sth help to build harmonious cooperation and effective communication, which helps to create a pleasant working atmosphere.
  某事帮助建立和谐的合作关系和有效的沟通，这将帮助建立一个愉快的工作氛围
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#ffa2c4>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2024/04/17/英语/2024万能论据/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/04/11/后端/SpringCloud基础-电商实战/">
        <h2>
            SpringCloud基础+电商实战
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring-Cloud基础介绍"><a href="#Spring-Cloud基础介绍" class="headerlink" title="Spring Cloud基础介绍"></a>Spring Cloud基础介绍</h1><ul>
<li>微服务的基本概念、设计与拆分原则</li>
<li>微服务和Spring Cloud的关系</li>
<li>微服务常见的组件和功能</li>
<li>课程查询案例基本介绍、系统架构设计和接口设计</li>
<li>分模块构建Spring Cloud项目</li>
<li>完成课程列表、课程价格服务开发</li>
<li>课程服务整合，服务注册与发现</li>
<li>整合Feign实现服务间调用</li>
<li>网关的集成与开发，并接入服务</li>
<li>引入服务的熔断与降级，并进行实操演练</li>
</ul>
<h2 id="微服务基础"><a href="#微服务基础" class="headerlink" title="微服务基础"></a>微服务基础</h2><ul>
<li><strong>什么是</strong>微服务？</li>
<li>微服务的<strong>特点</strong></li>
<li>微服务<strong>优缺点</strong></li>
<li>微服务的<strong>两大门派</strong> [Spring Cloud 和 Dubbo]</li>
<li>微服务<strong>拆分</strong></li>
<li>微服务<strong>扩展</strong></li>
<li>微服务<strong>重要模块</strong></li>
</ul>
<h3 id="微服务热度"><a href="#微服务热度" class="headerlink" title="微服务热度"></a>微服务热度</h3><h5 id="单体应用的痛点"><a href="#单体应用的痛点" class="headerlink" title="单体应用的痛点"></a>单体应用的痛点</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/ebd1e99f500608925cfe2623d05c22b5a75cb4a3/data/%E5%8D%95%E4%BD%93%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB.jpg"></p>
<h5 id="什么是服务化"><a href="#什么是服务化" class="headerlink" title="什么是服务化"></a>什么是服务化</h5><ul>
<li>把传统的单机应用中的本地方法调用，改造成通过<strong>RPC、HTTP</strong>产生的远程方法调用</li>
<li>把模块从单体应用中拆分出来，<strong>独立</strong>成一个服务部署</li>
</ul>
<h5 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h5><ul>
<li><p>一系列、一部分</p>
</li>
<li><p>是一种架构风格</p>
</li>
<li><p>开发单体应用作为一系列<strong>小型服务</strong>的套件，其中每个服务都运行再<strong>自己的进程</strong>中，并且通过<strong>轻量级</strong>的机制实现彼此间的通信，这通常是<strong>HTTP</strong>资源API</p>
</li>
<li><p>这些服务是围绕着业务功能构建的，并且可以通过完全<strong>自动化的部署</strong>机制进行独立部署</p>
</li>
<li><p>这些服务的集中式管理做到了最小化(例如<strong>docker</strong>相关技术)，每一种服务都可以通过<strong>不同的编程语言</strong>进行编写，并且可以使用<strong>不同的数据存储</strong>技术</p>
</li>
</ul>
<h3 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h3><ul>
<li><p>组件以<strong>服务</strong>形式来提供</p>
</li>
<li><p>产品不是项目</p>
</li>
<li><p>轻量级通信、独立进程</p>
</li>
<li><p><strong>分散</strong>治理、去中心化治理</p>
</li>
<li><p><strong>容错性</strong>设计</p>
</li>
<li><h6 id="会带来团队组织架构的调整"><a href="#会带来团队组织架构的调整" class="headerlink" title="会带来团队组织架构的调整"></a>会带来团队组织架构的调整</h6></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/82f8b26e0790184252e432ce2e28a606fb938e89/data/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AF%B9%E5%9B%A2%E9%98%9F%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84%E7%9A%84%E8%B0%83%E6%95%B4.jpg"></p>
<h3 id="微服务优缺点"><a href="#微服务优缺点" class="headerlink" title="微服务优缺点"></a>微服务优缺点</h3><ul>
<li>服务简单、便于学习和上手，相对<strong>易于维护</strong></li>
<li>独立部署，<strong>灵活</strong>扩展</li>
<li><strong>技术栈</strong>丰富</li>
</ul>
<h5 id="微服务缺点"><a href="#微服务缺点" class="headerlink" title="微服务缺点"></a>微服务缺点</h5><ul>
<li><strong>运维</strong>成本过高 [磁盘满 CPU高]</li>
<li>接口可能<strong>不匹配</strong></li>
<li>代码可能<strong>重复</strong> [要非常明确的定义每个API]</li>
<li><strong>架构复杂度</strong>提高</li>
</ul>
<h3 id="微服务两大门派"><a href="#微服务两大门派" class="headerlink" title="微服务两大门派"></a>微服务两大门派</h3><ul>
<li><strong>Spring Cloud</strong>：众多子项目【最大供应者：Netflix内容付费知识】</li>
<li><strong>dubbo</strong>：高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</li>
<li>dubbo提供的能力只是SpringCloud的一部分<strong>子集</strong></li>
</ul>
<h6 id="Dubbo虽然有很多不提供的组件-但是可以和其他供应商合作完成提供任务"><a href="#Dubbo虽然有很多不提供的组件-但是可以和其他供应商合作完成提供任务" class="headerlink" title="[Dubbo虽然有很多不提供的组件 但是可以和其他供应商合作完成提供任务]"></a>[Dubbo虽然有很多不提供的组件 但是可以和其他供应商合作完成提供任务]</h6><table>
<thead>
<tr>
<th>核心组件</th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册中心</td>
<td>Zookeeper</td>
<td>Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td>服务调用方式</td>
<td>RPC</td>
<td>REST API</td>
</tr>
<tr>
<td>服务网关</td>
<td>无</td>
<td>Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td>断路器</td>
<td>不完善</td>
<td>Spring Cloud Netflix Hystrix</td>
</tr>
<tr>
<td>分布式配置</td>
<td>无</td>
<td>Spring Cloud Config</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>无</td>
<td>Spring Cloud Sleuth</td>
</tr>
<tr>
<td>消息总线</td>
<td>无</td>
<td>Spring Cloud Bus</td>
</tr>
<tr>
<td>数据流</td>
<td>无</td>
<td>Spring Cloud Stream</td>
</tr>
<tr>
<td>批量任务</td>
<td>无</td>
<td>Spring Cloud Task</td>
</tr>
</tbody></table>
<h5 id="通信协议对比"><a href="#通信协议对比" class="headerlink" title="通信协议对比"></a>通信协议对比</h5><ul>
<li><strong>RPC</strong> vs <strong>REST</strong></li>
<li>服务提供方与调用方接口依赖方式太强</li>
<li>服务对平台敏感，难以简单复用</li>
</ul>
<h5 id="文档质量对比"><a href="#文档质量对比" class="headerlink" title="文档质量对比"></a>文档质量对比</h5><ul>
<li>Dubbo的文档可以说再国内开源框架中算是一流的，提供了中文与英文两种版本</li>
<li>Spring Cloud文档体量大，更多的是偏向整合，更深的使用方法还是需要查看整合组件的详细文档</li>
</ul>
<h5 id="两大门派选型建议"><a href="#两大门派选型建议" class="headerlink" title="两大门派选型建议"></a>两大门派选型建议</h5><ul>
<li>Dubbo &#x3D;&gt; 组装电脑 【中文文档多】</li>
<li>Spring Cloud &#x3D;&gt; 品牌机【稳定可靠】</li>
</ul>
<h3 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h3><h5 id="什么时候进行服务化拆分"><a href="#什么时候进行服务化拆分" class="headerlink" title="什么时候进行服务化拆分"></a>什么时候进行服务化拆分</h5><ul>
<li><strong>第一阶段</strong>的主要目标是快速开发和验证想法</li>
<li>进一步增加<strong>更多的新特性</strong>来吸引更多的目标用户</li>
<li>同时进行开发的人员<strong>超过10人</strong>，这个时候就该考虑到服务化拆分了</li>
</ul>
<h5 id="不适合拆分的情况"><a href="#不适合拆分的情况" class="headerlink" title="不适合拆分的情况"></a>不适合拆分的情况</h5><ul>
<li>小团队，技术基础较薄弱</li>
<li>流量不高，压力小，业务变化也不大</li>
<li>对延迟很敏感的低延迟高并发系统</li>
</ul>
<h5 id="服务化拆分的两种方式"><a href="#服务化拆分的两种方式" class="headerlink" title="服务化拆分的两种方式"></a>服务化拆分的两种方式</h5><ul>
<li>纵向拆分[上方区别图]</li>
<li>横向拆分</li>
<li>结合业务综合分析</li>
</ul>
<h3 id="服务扩展"><a href="#服务扩展" class="headerlink" title="服务扩展"></a>服务扩展</h3><h5 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/2f5e67f1d4e1d9f7acb927786096a1527bfd282b/data/%E7%BB%B4%E5%BA%A6-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95.jpg"></p>
<h5 id="自动按需扩展"><a href="#自动按需扩展" class="headerlink" title="自动按需扩展"></a>自动按需扩展</h5><ul>
<li>根据CPU负载程度、特定时间(比如周末)、消息中间件的队列长度、业务具体规则、预测等来决定是否扩展</li>
<li>自动分配一个新的服务实例，提高<strong>可用性</strong></li>
<li>提高了<strong>可伸缩性</strong>(双11之后，自动减少服务器)</li>
<li>具有<strong>最佳使用率</strong>，节约成本</li>
</ul>
<h3 id="微服务重要模块"><a href="#微服务重要模块" class="headerlink" title="微服务重要模块"></a>微服务重要模块</h3><ul>
<li>服务描述</li>
<li>注册中心</li>
<li>服务框架</li>
<li>负载均衡</li>
<li>熔断和降级</li>
<li>网关</li>
</ul>
<h1 id="Spring-Cloud课程查询"><a href="#Spring-Cloud课程查询" class="headerlink" title="Spring Cloud课程查询"></a><span style = "color:red">Spring Cloud课程查询</span></h1><ul>
<li>Spring Cloud简介</li>
<li>项目<strong>整体设计</strong></li>
<li>课程列表模块开发</li>
<li><span style = "color:red">课程价格模块开发</span> [模块间互相调用]</li>
<li>服务注册与发现<strong>Eureka</strong></li>
<li>服务间调用<strong>Feign</strong></li>
<li>负载均衡<strong>Ribbon</strong></li>
<li>熔断器<strong>Hystrix</strong> [兜底界面 默认返回]</li>
<li>网关<strong>Zuul</strong></li>
<li>整体测试</li>
</ul>
<h3 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h3><ul>
<li>成熟的微服务框架，定位为开发人员提供工具，以快速构建分布式系统</li>
</ul>
<h5 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h5><table>
<thead>
<tr>
<th align="center">核心组件</th>
<th align="center">Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务注册中心</td>
<td align="center">Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td align="center">服务调用方式</td>
<td align="center">REST API、Feign、Ribbon</td>
</tr>
<tr>
<td align="center">服务网关</td>
<td align="center">Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td align="center">熔断器</td>
<td align="center">Spring Cloud Netflix Hystrix</td>
</tr>
</tbody></table>
<h3 id="项目整体设计"><a href="#项目整体设计" class="headerlink" title="项目整体设计"></a>项目整体设计</h3><ul>
<li><p>项目介绍</p>
</li>
<li><h5 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h5><ul>
<li>课程列表</li>
<li>单个课程价格</li>
<li>整合课程列表和价格</li>
</ul>
</li>
<li><p><strong>表设计</strong></p>
</li>
</ul>
<h3 id="系统数据流向"><a href="#系统数据流向" class="headerlink" title="系统数据流向"></a>系统数据流向</h3><blockquote>
<p>【课程列表数据】→ 【课程列表服务】<br>                                                  ↓<br>【课程价格数据】→ 【课程价格服务】→ 【整体列表+价格】</p>
</blockquote>
<h3 id="新建多模块项目"><a href="#新建多模块项目" class="headerlink" title="新建多模块项目"></a>新建多模块项目</h3><pre><code class="java">创建一个 spring-cloud-course-pracice 并删除src文件夹
新建New → module → Maven → course-service → 删除src
    新建New → module → New Module → Maven → course-list → Parent：course-service 
    新建New → module → New Module → Maven → course-price → Parent：course-service 
D:\Java+4399\阶段5：Java分布与微服务实战\第32周 Spring Cloud基础\第2节 Spring Cloud开发课程查询功能\辅助材料\SpringCloud课程查询源码【优质it资源微信it-wangke18】.zip\SpringCloud课程查询源码\课程价格模块开发后\spring-cloud-course-practice
</code></pre>
<h5 id="course-service-course-list"><a href="#course-service-course-list" class="headerlink" title="course-service.course-list"></a>course-service.course-list</h5><pre><code class="xml">pom.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;course-service&lt;/artifactId&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;artifactId&gt;course-list&lt;/artifactId&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/course/controller/CourseListController.java
package com.imooc.course.controller;

import com.imooc.course.entity.Course;
import com.imooc.course.service.CourseListService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * CourseListController课程列表Controller
 */

@RestController
public class CourseListController &#123;
    //提供课程列表服务
    @Autowired //引入课程服务
    CourseListService courseListService;


    @GetMapping(&quot;/courses&quot;)
    public List&lt;Course&gt; courseList() &#123;
        //return → service
        return courseListService.getCourseList();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/CourseListService.java
package com.imooc.course.service;

import com.imooc.course.entity.Course;

import java.util.List;

/**
 * 课程列表服务
 */
public interface CourseListService &#123;
    List&lt;Course&gt; getCourseList();
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/impl/CourseListServiceImpl.java
package com.imooc.course.service.impl;

import com.imooc.course.dao.CourseMapper;
import com.imooc.course.entity.Course;
import com.imooc.course.service.CourseListService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 课程服务实现类
 */
@Service
public class CourseListServiceImpl implements CourseListService &#123;
    @Autowired
    CourseMapper courseMapper;
    @Override
    public List&lt;Course&gt; getCourseList() &#123;
        return courseMapper.findValidCourses();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/entity/Course.java
package com.imooc.course.entity;

import java.io.Serializable;

/**
 * Course的实体类
 */
public class Course implements Serializable &#123;
    Integer id;
    Integer courseId;
    String courseName;
    Integer valid;

    @Override
    public String toString() &#123;
        return &quot;Course&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, courseName=&#39;&quot; + courseName + &#39;\&#39;&#39; +
                &quot;, valid=&quot; + valid +
                &#39;&#125;&#39;;
    &#125;
    Getter+Setter  
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/dao/CourseMapper.java
package com.imooc.course.dao;

import com.imooc.course.entity.Course;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 描述课程的Mapper类
 */
@Mapper
@Repository
public interface CourseMapper &#123;
    @Select(&quot;SELECT * FROM course WHERE valid = 1&quot;)
    List&lt;Course&gt; findValidCourses();
&#125;
</code></pre>
<pre><code class="java">application.properties

server.port=8081
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_practice?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root
logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;
# entity的实体类与数据库名进行驼峰命名转换
mybatis.configuration.map-underscore-to-camel-case=true 
spring.application.name=course-list
</code></pre>
<pre><code class="java">com/imooc/course/CoursePriceApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CoursePriceApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(CoursePriceApplication.class, args);
    &#125;
&#125;
=====================================================================
</code></pre>
<pre><code class="mysql">数据库名：course_practice
   表名：course
   字段：id[自增]   course_id   course_name   valid
</code></pre>
<h5 id="课程列表模块开发-总结-注意点"><a href="#课程列表模块开发-总结-注意点" class="headerlink" title="课程列表模块开发-总结 [注意点]"></a>课程列表模块开发-总结 [注意点]</h5><ul>
<li>多模块开发</li>
<li>实体类实现Serializable接口、set方法</li>
<li>MyBatis的驼峰配置</li>
</ul>
<h5 id="course-list-course-price"><a href="#course-list-course-price" class="headerlink" title="course-list.course-price"></a>course-list.course-price</h5><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;course-service&lt;/artifactId&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;artifactId&gt;course-price&lt;/artifactId&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/course/controller/CoursePriceController.java
package com.imooc.course.controller;

import com.imooc.course.entity.CoursePrice;
import com.imooc.course.service.CoursePriceService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 课程价格控制器
 */

@RestController
public class CoursePriceController &#123;
    @Autowired
    CoursePriceService coursePriceService;
    @GetMapping(&quot;/price&quot;)
    public Integer getCoursePrice(Integer courseId)&#123;
        CoursePrice coursePrice = coursePriceService.getCoursePrice(courseId);
        return coursePrice.getPrice();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/CoursePriceService.java
package com.imooc.course.service;

import com.imooc.course.entity.CoursePrice;

import java.util.List;

/**
 * 课程价格服务
 */
public interface CoursePriceService &#123;
    CoursePrice getCoursePrice(Integer courseId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/impl/CoursepriceServiceImpl.java
package com.imooc.course.service.impl;

import com.imooc.course.dao.CoursePriceMapper;
import com.imooc.course.entity.CoursePrice;
import com.imooc.course.service.CoursePriceService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 课程价格的服务实现类
 */
@Service
public class CoursepriceServiceImpl implements CoursePriceService &#123;
    @Autowired
    CoursePriceMapper coursePriceMapper;
    @Override
    public CoursePrice getCoursePrice(Integer courseId) &#123;
        return coursePriceMapper.findCoursePrice(courseId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/entity/CoursePrice.java
package com.imooc.course.entity;

import java.io.Serializable;

/**
 * CoursePrice的实体类
 */
public class CoursePrice implements Serializable &#123;
    Integer id;
    Integer courseId;
    Integer price;

    @Override
    public String toString() &#123;
        return &quot;CoursePrice&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, price=&quot; + price +
                &#39;&#125;&#39;;
    &#125;
    Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/dao/CoursePriceMapper.java
package com.imooc.course.dao;

import com.imooc.course.entity.CoursePrice;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

/**
 * 课程价格Mapper类
 */
@Mapper
@Repository
public interface CoursePriceMapper &#123;
    @Select(&quot;SELECT * FROM course_price WHERE course_id = #&#123;courseId&#125;&quot;)
    CoursePrice findCoursePrice(Integer courseId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/CoursePriceApplication.java
package com.imooc.course;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CoursePriceApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(CoursePriceApplication.class, args);
    &#125;
&#125;
==========================================================
http://127.0.0.1:8082/price?courseId=409
</code></pre>
<pre><code class="mysql">数据库名：course_practice
   表名：course_price
   字段：id[自增]   course_id    price
</code></pre>
<h3 id="Eureka的作用和架构"><a href="#Eureka的作用和架构" class="headerlink" title="Eureka的作用和架构"></a>Eureka的作用和架构</h3><h5 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h5><ul>
<li>用于定位服务，直接找到组件中的各个服务地址</li>
<li>114[各种服务的提供者]、物业[维护各个住户的信息(注册中心)]</li>
</ul>
<h5 id="为什么需要服务注册与发现-移除不影响-但会有很多麻烦"><a href="#为什么需要服务注册与发现-移除不影响-但会有很多麻烦" class="headerlink" title="为什么需要服务注册与发现 [移除不影响 但会有很多麻烦]"></a>为什么需要服务注册与发现 [移除不影响 但会有很多麻烦]</h5><ul>
<li>IP变化</li>
<li>难以维护</li>
<li>改进<ul>
<li><strong>节点变化</strong>[服务的提供者和消费者] [消费者需要调用提供者的API来获得服务] 若提供者修改了ip 此时应该上传到注册中心，消费者此时需要得到IP和API 无需直接找提供者 直接去<strong>注册中心</strong>调用</li>
</ul>
</li>
</ul>
<h5 id="Eureka架构"><a href="#Eureka架构" class="headerlink" title="Eureka架构"></a>Eureka架构</h5><ul>
<li>EureKa <strong>Server</strong> 和 EureKa <strong>Client</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6a3bfcded810da5a827559f3b8f868a0de867787/data/Eureka%E6%9E%B6%E6%9E%84.png"></p>
<ul>
<li><strong>集群</strong> [只要能获得一个Eureka Server 就能获得整个信息]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f756e06eed90edb75c6b3b6f234eee57763d8811/data/Eureka%E6%9E%B6%E6%9E%84-%E9%9B%86%E7%BE%A4.png"></p>
<h3 id="引入Eureka"><a href="#引入Eureka" class="headerlink" title="引入Eureka"></a>引入Eureka</h3><ul>
<li><h6 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h6></li>
<li><h6 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h6></li>
<li><h6 id="启动注解"><a href="#启动注解" class="headerlink" title="启动注解"></a>启动注解</h6></li>
</ul>
<pre><code class="xml">pom.xml(eureka-server)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;spring-cloud-course-practice&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;eureka-server&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;!-- 模块名及描述信息 --&gt;
    &lt;name&gt;course-eureka-server&lt;/name&gt;
    &lt;description&gt;Spring Cloud Eureka&lt;/description&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">pom.xml(Spring-cloud-course-practice)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;modules&gt;
    &lt;module&gt;course-service&lt;/module&gt;
    &lt;module&gt;eureka-server&lt;/module&gt;
  &lt;/modules&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.12.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;com.imooc&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-course-practice&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;spring-cloud-course-practice&lt;/name&gt;
  &lt;description&gt;course project for Spring Cloud&lt;/description&gt;

  &lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;!--  表示Spring Cloud的版本--&gt;
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
        &lt;version&gt;Greenwich.SR5&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties(eureka-server)

spring.application.name=eureka-server
server.port=8000
eureka.instance.hostname=localhost
#fetch-registry???????????????????
eureka.client.fetch-registry=false
#register-with-eureka??????????Eureka Server????true?
eureka.client.register-with-eureka=false
eureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<pre><code class="mysql">application.properties(course-list)

server.port=8081
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_practice?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root
logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;
# entity?????????????????
mybatis.configuration.map-underscore-to-camel-case=true 
spring.application.name=course-list
#??????? eureka-server??application.properties?defaultZone????????????????
eureka.client.service-url.defaultZone=http://localhost:8000/eureka/
</code></pre>
<pre><code class="mysql">application.properties(course-price)

server.port=8082
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_practice?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root
logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;
mybatis.configuration.map-underscore-to-camel-case=true
spring.application.name=course-price
eureka.client.service-url.defaultZone=http://localhost:8000/eureka/
</code></pre>
<pre><code class="java">com/imooc/course/EurekaServerApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * Eureka的服务端
 */
@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaServerApplication.class, args);
    &#125;
&#125;
========================================================
http://127.0.0.1:8000/
</code></pre>
<h3 id="利用Feign实现服务间调用"><a href="#利用Feign实现服务间调用" class="headerlink" title="利用Feign实现服务间调用"></a>利用Feign实现服务间调用</h3><h5 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h5><ul>
<li>声明式、模板化的HTTP客户端，方便的调用远程的HTTP请求 [基于接口实现]</li>
</ul>
<h6 id="集成Feign"><a href="#集成Feign" class="headerlink" title="集成Feign"></a>集成Feign</h6><ul>
<li>引入依赖</li>
<li>配置文件</li>
<li>注解</li>
</ul>
<pre><code class="xml">pom.xml (course-price)
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
    &lt;/dependency&gt;

application.properties
eureka.client.service-url.defaultZone=http://localhost:8000/eureka/
</code></pre>
<pre><code class="java">com/imooc/course/controller/CoursePriceController.java
package com.imooc.course.controller;

import com.imooc.course.client.CourseListClient;
import com.imooc.course.entity.Course;
import com.imooc.course.entity.CoursePrice;
import com.imooc.course.service.CoursePriceService;
import java.util.List;
import javax.xml.ws.Action;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 描述：     课程价格控制器
 */
@RestController
public class CoursePriceController &#123;

    @Autowired
    CoursePriceService coursePriceService;

    @Autowired
    CourseListClient courseListClient;

    @GetMapping(&quot;/price&quot;)
    public Integer getCoursePrice(Integer courseId) &#123;
        CoursePrice coursePrice = coursePriceService.getCoursePrice(courseId);
        return coursePrice.getPrice();
    &#125;

    @GetMapping(&quot;/coursesInPrice&quot;)
    public List&lt;Course&gt; getCourseListInPrice(Integer courseId) &#123;
        List&lt;Course&gt; courses = courseListClient.courseList();
        return courses;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/client/CourseListClient.java[接口]
package com.imooc.course.client;

import com.imooc.course.entity.Course;
import java.util.List;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

/**
 * 描述：     课程列表的Feign客户端
 */
@FeignClient(&quot;course-list&quot;)
public interface CourseListClient &#123;

    @GetMapping(&quot;/courses&quot;)
    List&lt;Course&gt; courseList();
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/CoursePriceApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class CoursePriceApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(CoursePriceApplication.class, args);
    &#125;
&#125;
=============================================================
http://127.0.0.1:8082/coursesInPrice

[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 362,
        &quot;courseName&quot;: &quot;SpringCloud自学&quot;,
        &quot;valid&quot;: 1
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;courseId&quot;: 409,
        &quot;courseName&quot;: &quot;玩转Java并发工具&quot;,
        &quot;valid&quot;: 1
    &#125;
]
</code></pre>
<h3 id="负载均衡的两种类型"><a href="#负载均衡的两种类型" class="headerlink" title="负载均衡的两种类型"></a>负载均衡的两种类型</h3><ul>
<li><strong>客户端</strong>负载均衡(Ribbon)</li>
<li><strong>服务端</strong>负载均衡(Nginx)</li>
</ul>
<h5 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h5><ul>
<li>RandomRule 表示<strong>随机</strong>策略</li>
<li>RoundRobinRule 表示<strong>轮询</strong>策略</li>
<li>ResponseTimeWeightedRule<strong>加权</strong>，根据每一个Server的平均响应时间动态加权</li>
</ul>
<h5 id="配置不同的负载均衡方式"><a href="#配置不同的负载均衡方式" class="headerlink" title="配置不同的负载均衡方式"></a>配置不同的负载均衡方式</h5><ul>
<li>Ribbon.NFLoadBalancerRuleClassName</li>
</ul>
<pre><code class="java">application.properties(course-price)
course-list.ribbon.NFLoadBanlancerRuleClassName=com.netflix.loadbalancer.RoundRobinRule
</code></pre>
<h3 id="为什么要断路器"><a href="#为什么要断路器" class="headerlink" title="为什么要断路器"></a>为什么要断路器</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e441bfbcf0e2cf07f9d53564669b2dbd90533142/data/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%96%AD%E8%B7%AF%E5%99%A8.jpg"></p>
<h5 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h5><pre><code class="xml">pom.xml(course-price)   
&lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<pre><code class="java">application.properties(course-price)
feign.hystrix.enabled=true
</code></pre>
<pre><code class="java">com/imooc/course/CoursePriceApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableCircuitBreaker
public class CoursePriceApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(CoursePriceApplication.class, args);
    &#125;
&#125;
================================================================
所有服务都打开时 http://127.0.0.1:8082/coursesInPrice
[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 362,
        &quot;courseName&quot;: &quot;SpringCloud白学&quot;,
        &quot;valid&quot;: 1
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;courseId&quot;: 409,
        &quot;courseName&quot;: &quot;玩转Java并发工具&quot;,
        &quot;valid&quot;: 1
    &#125;
]
当把CouresListApplication服务关闭的时候
[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 1,
        &quot;courseName&quot;: &quot;默认课程&quot;,
        &quot;valid&quot;: 1
    &#125;
]
</code></pre>
<h3 id="整合两个服务"><a href="#整合两个服务" class="headerlink" title="整合两个服务"></a>整合两个服务</h3><pre><code class="java">com/imooc/course/controller/CoursePriceController.java
    @GetMapping(&quot;/coursesAndPrice&quot;)
    public List&lt;CourseAndPrice&gt; getCoursesAndPrice()&#123;
        List&lt;CourseAndPrice&gt; courseAndPrices = coursePriceService.getCourseAndPrice();
        return courseAndPrices;
    &#125;
=====================================================
http://127.0.0.1:8082/coursesAndPrice
[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 362,
        &quot;name&quot;: &quot;SpringCloud自学&quot;,
        &quot;price&quot;: 348
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;courseId&quot;: 409,
        &quot;name&quot;: &quot;玩转Java并发工具&quot;,
        &quot;price&quot;: 399
    &#125;
]
</code></pre>
<pre><code class="java">com/imooc/course/service/CoursePriceService.java
public interface CoursePriceService &#123;

    CoursePrice getCoursePrice(Integer courseId);
    List&lt;CourseAndPrice&gt; getCourseAndPrice();
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/service/impl/CoursePriceServiceImpl.java
package com.imooc.course.service.impl;

import com.imooc.course.client.CourseListClient;
import com.imooc.course.dao.CoursePriceMapper;
import com.imooc.course.entity.Course;
import com.imooc.course.entity.CourseAndPrice;
import com.imooc.course.entity.CoursePrice;
import com.imooc.course.service.CoursePriceService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

/**
 * 描述：     课程价格的服务实现类
 */
@Service
public class CoursePriceServiceImpl implements CoursePriceService &#123;

    @Autowired
    CoursePriceMapper coursePriceMapper;
    @Autowired
    CourseListClient courseListClient;

    @Override
    public CoursePrice getCoursePrice(Integer courseId) &#123;
        return coursePriceMapper.findCoursePrice(courseId);
    &#125;

    @Override
    public List&lt;CourseAndPrice&gt; getCourseAndPrice() &#123;
        List&lt;CourseAndPrice&gt; courseAndPrices = new ArrayList&lt;&gt;();
        List&lt;Course&gt; courses = courseListClient.courseList();
        for (int i = 0; i &lt; courses.size(); i++) &#123;
            Course course = courses.get(i);
            //inn
            if (course != null) &#123;
                CoursePrice coursePrice = getCoursePrice(course.getCourseId());
                CourseAndPrice courseAndPrice = new CourseAndPrice();
                courseAndPrice.setPrice(coursePrice.getPrice());
                courseAndPrice.setName(course.getCourseName());
                courseAndPrice.setId(coursePrice.getId());
                courseAndPrice.setCourseId(course.getCourseId());
                courseAndPrices.add(courseAndPrice);
            &#125;
        &#125;
        return courseAndPrices;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/entity/CourseAndPrice.java
package com.imooc.course.entity;

/**
 * 课程与价格的融合类
 */
public class CourseAndPrice &#123;
    Integer id;
    Integer courseId;
    String name;
    Integer price;
&#125;
</code></pre>
<h3 id="网关Zuul"><a href="#网关Zuul" class="headerlink" title="网关Zuul"></a>网关Zuul</h3><ul>
<li>为什么<strong>需要</strong>网关</li>
<li>签名校验、登录校验<strong>冗余</strong>问题</li>
<li>Spring Cloud <strong>Zuul</strong> 与 Spring Cloud</li>
<li>API网关允许您将API请求(内部或外部)路由到正确的位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1f9e4c61e576605cf2c814d0d8f069c61bcef0da/data/%E7%BD%91%E5%85%B3Zuul.jpg"></p>
<h3 id="集成Zuul-统一修改访问url地址"><a href="#集成Zuul-统一修改访问url地址" class="headerlink" title="集成Zuul [统一修改访问url地址]"></a>集成Zuul [统一修改访问url地址]</h3><ul>
<li>把自己注册到Eureka这个注册中心</li>
<li>引入依赖</li>
<li>配置路由地址</li>
</ul>
<pre><code class="xml">pom.xml(course-zuul)
     &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">com/imooc/course/ZuulGatewayApplication.java
package com.imooc.course;

import org.springframework.boot.SpringApplication;

/**
 * 网关启动类
 */
@EnableZuulProxy
@SpringCloudApplication
public class ZuulGatewayApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ZuulGatewayApplication.class, args);
    &#125;
&#125;
===============================================================
http://127.0.0.1:9000/imooc/price/coursesInPrice
[
    &#123;
        &quot;id&quot;: 1,
        &quot;courseId&quot;: 362,
        &quot;courseName&quot;: &quot;SpringCloud自学&quot;,
        &quot;valid&quot;: 1
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;courseId&quot;: 409,
        &quot;courseName&quot;: &quot;玩转Java并发工具&quot;,
        &quot;valid&quot;: 1
    &#125;
]
</code></pre>
<pre><code class="mysql">application.properties

spring.application.name=course-gateway
server.port=9000
logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;
mybatis.configuration.map-underscore-to-camel-case=true
eureka.client.service-url.defaultZone=http://localhost:8000/eureka/

zuul.prefix=/imooc
zuul.routes.course-list.path=/list/**
zuul.routes.course-list.service-id=course-list
zuul.routes.course-price.path=/price/**
zuul.routes.course-price.service-id=course-price
</code></pre>
<h3 id="利用网关实现过滤器"><a href="#利用网关实现过滤器" class="headerlink" title="利用网关实现过滤器"></a>利用网关实现过滤器</h3><ul>
<li><strong>pre</strong> 过滤器在路由请求之前运行</li>
<li>route 过滤器可以处理请求的实际路由</li>
<li><strong>post</strong> 路由请求后运行过滤器</li>
<li>error 如果在处理请求的过程中发生错误，则过滤器将运行</li>
</ul>
<pre><code class="java">com/imooc/course/filter/PreRequestFilter.java
package com.imooc.course.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;
import org.springframework.stereotype.Component;

/**
 * 记录请求时间
 */
@Component
public class PreRequestFilter extends ZuulFilter &#123;

    @Override
    public String filterType() &#123;
        //过滤器的类型
        return FilterConstants.PRE_TYPE;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 0;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        //是否启用过滤器
        return true;
    &#125;

    @Override
    public Object run() throws ZuulException &#123;
        //通过时间戳 获取上下文
        RequestContext currentContext = RequestContext.getCurrentContext();
        currentContext.set(&quot;startTime&quot;,System.currentTimeMillis());
        System.out.println(&quot;过滤器已经记录时间&quot;);
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/course/filter/PostRequestFilter.java
package com.imooc.course.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;
import org.springframework.stereotype.Component;

/**
 * 请求处理后的过滤器
 */
@Component //有了才能被spring捕捉到
public class PostRequestFilter extends ZuulFilter &#123;
    @Override
    public String filterType() &#123;
        return FilterConstants.POST_TYPE;
    &#125;

    @Override
    public int filterOrder() &#123; //在其之前-1 先运行
        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        return false;
    &#125;

    @Override
    public Object run() throws ZuulException &#123;
        RequestContext currentContext = RequestContext.getCurrentContext();
        Long startTime = (Long) currentContext.get(&quot;startTime&quot;);
        long duration = System.currentTimeMillis() - startTime;
        String requestURI = currentContext.getRequest().getRequestURI();
        System.out.println(&quot;uri:&quot; + requestURI + &quot;,处理时长：&quot; + duration);
        return null;
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<h3 id="Spring-Cloud电商实践"><a href="#Spring-Cloud电商实践" class="headerlink" title="Spring Cloud电商实践"></a>Spring Cloud电商实践</h3><ul>
<li>服务拆分过程分析和经验分享</li>
<li>完成用户、商品、购物车和订单等服务开发</li>
<li>通用common模块的拆分和应用</li>
<li>Eureka server注册中心开发，用Feign完成服务之间的调用</li>
<li>共享Session的处理方案</li>
<li>统一网关的集成与开发</li>
</ul>
<h3 id="Spring-Cloud电商项目"><a href="#Spring-Cloud电商项目" class="headerlink" title="Spring Cloud电商项目"></a>Spring Cloud电商项目</h3><ul>
<li>项目介绍<ul>
<li>在Spring Boot的基础上升级为<strong>Spring Cloud</strong></li>
<li>从0到1 (Spring Boot)</li>
<li><strong>从1到多</strong>、微服务</li>
</ul>
</li>
<li>模块拆分</li>
<li>Eureka-server开发</li>
<li><strong>用户模块开发</strong></li>
<li><strong>公共模块开发</strong></li>
<li><strong>网关模块开发</strong></li>
<li><strong>商品分类和商品模块开发</strong></li>
<li><strong>购物车和订单模块开发</strong></li>
<li>总结</li>
</ul>
<h3 id="模块拆分"><a href="#模块拆分" class="headerlink" title="模块拆分"></a>模块拆分</h3><ul>
<li><p><strong>粒度</strong>：过粗、适中、过细</p>
</li>
<li><p>人员的角度</p>
</li>
<li><p>业务的角度：相关、独立</p>
</li>
<li><p>Eureka-server模块</p>
</li>
<li><p>网关模块</p>
</li>
<li><p>公共模块 (md5、统一API返回、常量、异常、异常枚举、二维码、工具类模块……)</p>
</li>
<li><p>用户模块 (相对来说比较独立，登录的时候无需获得商品信息)</p>
</li>
<li><p><strong>商品分类和商品模块</strong></p>
</li>
<li><p><strong>购物车和订单模块</strong></p>
</li>
</ul>
<h3 id="功能模块介绍"><a href="#功能模块介绍" class="headerlink" title="功能模块介绍"></a>功能模块介绍</h3><ul>
<li><h4 id="项目功能："><a href="#项目功能：" class="headerlink" title="项目功能："></a>项目功能：</h4><ul>
<li><h5 id="前台-用户、商品分类、商品信息、购物车、订单"><a href="#前台-用户、商品分类、商品信息、购物车、订单" class="headerlink" title="前台  {用户、商品分类、商品信息、购物车、订单}"></a><span style = "color:red">前台  {用户、商品分类、商品信息、购物车、订单}</span></h5><ul>
<li><strong>用户模块</strong>{注册、登录、更新签名、身份认证、登出}</li>
<li><strong>商品分类模块</strong>{多级目录、递归查询、缓存}</li>
<li><strong>商品模块</strong>{商品搜索、商品排序、商品列表、目录展示、商品详情}</li>
<li><strong>购物车模块</strong>{加入商品、列表显示、数量更改、删除商品、勾选反选、全选全不选}</li>
<li><strong>订单模块</strong>{下单、订单流程、订单详情、取消订单、支付二维码、扫码支付、个人订单、确认收货}</li>
</ul>
</li>
<li><h5 id="后台-用户、商品分类、商品信息、订单"><a href="#后台-用户、商品分类、商品信息、订单" class="headerlink" title="后台  {用户、商品分类、商品信息、订单}"></a><span style = "color:red">后台  {用户、商品分类、商品信息、订单}</span></h5><ul>
<li><strong>管理员模块</strong>{登录登出、身份认证、安全限制}</li>
<li><strong>商品分类模块</strong>{分类列表、增加分类、修改分类、删除分类}</li>
<li><strong>商品模块</strong>{商品列表、新增商品、图片上传、更新删除、批量上下架}</li>
<li><strong>订单模块</strong>{订单列表、地址信息、发货、订单完结}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&#96;&#96;</p>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><h5 id="Eureka-server模块开发"><a href="#Eureka-server模块开发" class="headerlink" title="Eureka-server模块开发"></a>Eureka-server模块开发</h5><ul>
<li>引入依赖</li>
<li>配置文件</li>
<li>启动注解</li>
</ul>
<blockquote>
<p>由于是多模块开发，创建了maven项目后把cloud-mall-practice的src删除</p>
</blockquote>
<pre><code class="xml">pom.xml(cloud-mall-practice)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;cloud-mall-practice&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;cloud-mall-eureka-server&lt;/module&gt;
    &lt;/modules&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.12.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Greenwich.SR5&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.7&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;verbose&gt;true&lt;/verbose&gt;
                    &lt;overwrite&gt;true&lt;/overwrite&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">cloud-mall-eureka-server/com/imooc/cloud/mall/practice/eureka/EurekaServerApplication.java
package com.imooc.cloud.mall.practice.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * 1. Eureka Server的启动类，提供服务注册与发现
 * 2写其pom和resources的配置文件
 *
 */
@EnableEurekaServer //对外提供服务
@SpringBootApplication
public class EurekaServerApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaServerApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml(cloud-mall-eureka-server)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;cloud-mall-practice&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;cloud-mall-eureka-server&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;name&gt;
        cloud-mall-eureka-server
    &lt;/name&gt;
    &lt;description&gt;Spring cloud Eureka Server&lt;/description&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties

spring.application.name=eureka-server
server.port=8000
eureka.instance.hostname=localhost
#是否同步其他节点的信息
eureka.client.fetch-registry=false
#是否把自己作为服务注册在服务上
eureka.client.register-with-eureka=false
#eureka-server所在的地址
eureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<h3 id="用户模块知识点"><a href="#用户模块知识点" class="headerlink" title="用户模块知识点"></a>用户模块知识点</h3><blockquote>
<p>登录、注册[加盐md5]、重名校验[注册就不可注册]、密码加密存储、Session的使用、越权校验[不可编辑别人的签名]</p>
</blockquote>
<h5 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h5><ul>
<li>表设计</li>
<li>开发</li>
<li>测试</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_62117675/article/details/127938285">idea中如何将包名折叠或者或如何将折叠的包名展开_idea包名折叠-CSDN博客</a></p>
<h3 id="用户模块初始化"><a href="#用户模块初始化" class="headerlink" title="用户模块初始化"></a>用户模块初始化</h3><h5 id="公共模块"><a href="#公共模块" class="headerlink" title="公共模块"></a>公共模块</h5><ul>
<li>常量、异常、工具类</li>
<li>自身不是Spring Boot项目</li>
</ul>
<h6 id="进行模块各层级的重构-用户模块的测试"><a href="#进行模块各层级的重构-用户模块的测试" class="headerlink" title="进行模块各层级的重构 + 用户模块的测试"></a>进行模块各层级的重构 + 用户模块的测试</h6><pre><code class="mysql">一定要记得如果引用其他muder的时候 要在xml中假如其项目文件的依赖才可以跨项目引用
比如我这个项目是【一定要引用噢！！ 不然在非其项目的时候找不到import导包】
pom.xml(cloud-mall-zuul)
           &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-mall-user&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="网关模块开发"><a href="#网关模块开发" class="headerlink" title="网关模块开发"></a>网关模块开发</h3><pre><code class="xml">pom.xml(cloud-mall-zuul)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;cloud-mall-practice&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;cloud-mall-zuul&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties(cloud-mall-zuul)
server.port=8083

spring.datasource.name=imooc_mall_datasource
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=UTC
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root

mybatis.mapper-locations=classpath*:mappers/*.xml

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;

eureka.client.service-url.defaultZone=http://localhost:8000/eureka/

spring.application.name=cloud-mall-zuul

zuul.prefix=/
#凡是用户模块都要走/user地址
zuul.routes.cloud-mall-user.path=/user/**
#模块的名字
zuul.routes.cloud-mall-user.service-id=cloud-mall-user
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/zuul/filter/UserFilter.java
package com.imooc.cloud.mall.practice.zuul.filter;

import com.imooc.cloud.mall.practice.common.common.Constant;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import com.imooc.cloud.mall.practice.user.model.pojo.User;
import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

/**
 * 用户鉴权过滤器
 */
@Component
public class UserFilter extends ZuulFilter &#123;
    @Override
    public String filterType() &#123;
        return FilterConstants.PRE_TYPE;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 0;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
        String requestURI = request.getRequestURI();
        //不经过过滤器
        if (requestURI.contains(&quot;images&quot;) || requestURI.contains(&quot;pay&quot;)) &#123;
            return false;
        &#125;
        if (requestURI.contains(&quot;cart&quot;) || requestURI.contains(&quot;order&quot;)) &#123;//前置条件必须要登录！
            return true;
        &#125;
        return false;
    &#125;

    @Override
    //用户过滤器
    public Object run() throws ZuulException &#123;//返回true的时候执行的
        RequestContext currentContext = RequestContext.getCurrentContext();//获取request
        //获取session 因为user对象保存在里面  session.getAttribute取出session对象
        HttpServletRequest request = currentContext.getRequest();
        HttpSession session = request.getSession();
        //拿出User对象
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            //无需通过网关再去发送
            currentContext.setSendZuulResponse(false);
            //返回给前端的对象
            currentContext.setResponseBody(&quot;&#123;\n&quot;
                    + &quot;    \&quot;status\&quot;: 10007,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            currentContext.setResponseStatusCode(200);
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/zuul/filter/AdminFilter.java
package com.imooc.cloud.mall.practice.zuul.filter;

import com.imooc.cloud.mall.practice.common.common.Constant;
import com.imooc.cloud.mall.practice.user.model.pojo.User;
import com.imooc.cloud.mall.practice.zuul.feign.UserFeignClient;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

/**
 * 管理员鉴权过滤器
 */
@Component
public class AdminFilter extends ZuulFilter &#123;
    @Autowired
    UserFeignClient userFeignClient;

    @Override
    public String filterType() &#123;
        return FilterConstants.PRE_TYPE;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 0;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
        String requestURI = request.getRequestURI();
        //不经过过滤器
        if (requestURI.contains(&quot;adminLogin&quot;))&#123;
            return false;
        &#125;
        if (requestURI.contains(&quot;admin&quot;))&#123;
            return true;
        &#125;
        if (requestURI.contains(&quot;cart&quot;) || requestURI.contains(&quot;order&quot;)) &#123;//前置条件必须要登录！
            return true;
        &#125;
        return false;
    &#125;

    @Override
    //用户过滤器
    public Object run() throws ZuulException &#123;//返回true的时候执行的
        RequestContext currentContext = RequestContext.getCurrentContext();//获取request
        //获取session 因为user对象保存在里面  session.getAttribute取出session对象
        HttpServletRequest request = currentContext.getRequest();
        HttpSession session = request.getSession();
        //拿出User对象
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            //无需通过网关再去发送
            currentContext.setSendZuulResponse(false);
            //返回给前端的对象
            currentContext.setResponseBody(&quot;&#123;\n&quot;
                    + &quot;    \&quot;status\&quot;: 10010,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            currentContext.setResponseStatusCode(200);
            return null; //程序可以停止了
        &#125;
        //进一步判断是否是管理员
        Boolean adminRole = userFeignClient.checkAdminRole(currentUser);
        if (!adminRole)&#123;
            currentContext.setSendZuulResponse(false);
            //返回给前端的对象
            currentContext.setResponseBody(&quot;&#123;\n&quot;
                    + &quot;    \&quot;status\&quot;: 10011,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_ADMIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            currentContext.setResponseStatusCode(200);
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/zuul/feign/UserFeignClient.java
package com.imooc.cloud.mall.practice.zuul.feign;

import com.imooc.cloud.mall.practice.user.model.pojo.User;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

/**
 * UserFeignClient
 */
@FeignClient(value = &quot;cloud-mall-user&quot;)
public interface UserFeignClient &#123;
    @PostMapping(&quot;/checkAdminRole&quot;)
    public Boolean checkAdminRole(@RequestBody User user);
&#125;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/zuul/ZuulGatewayApplication.java
网关模块加上SpringBoot启动类

package com.imooc.cloud.mall.practice.zuul;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.cloud.openfeign.EnableFeignClients;

/**
 * 网关启动类
 */
@EnableZuulProxy
@EnableFeignClients
@SpringBootApplication
public class ZuulGatewayApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ZuulGatewayApplication.class, args);
    &#125;
&#125;
=================================================================
127.0.0.1:8083/user/login?userName=mumu9&amp;password=lihao123
&#123;
    &quot;status&quot;: 10000,
    &quot;msg&quot;: &quot;SUCCESS&quot;,
    &quot;data&quot;: &#123;
        &quot;id&quot;: 21,
        &quot;username&quot;: &quot;mumu9&quot;,
        &quot;password&quot;: null,
        &quot;personalizedSignature&quot;: &quot;乘风破浪的姐姐&quot;,
        &quot;role&quot;: 2,
        &quot;createTime&quot;: &quot;2024-04-17T18:08:15.000+0000&quot;,
        &quot;updateTime&quot;: &quot;2024-04-17T18:10:49.000+0000&quot;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>POSTMAN中cloud-mall-practice的注册新用户、用户登录、管理员登录、登出模块都通过网关共用地址的调用，但是更新个性签名不可以，提示需要登录，因为更新签名需要提前登录。但是问题的最主要的点就是没有拿到session所以并没有把用户信息传到个性签名中 这是就需要Session共享机制</p>
</blockquote>
<h3 id="Session共享机制"><a href="#Session共享机制" class="headerlink" title="Session共享机制"></a>Session共享机制</h3><h5 id="登录功能分析"><a href="#登录功能分析" class="headerlink" title="登录功能分析"></a>登录功能分析</h5><ul>
<li>登录状态需要保持</li>
<li>session的实现方案：登陆后，会保存用户信息到session</li>
<li>之后的访问，先从session中获取用户信息，然后再执行业务逻辑</li>
</ul>
<h6 id="目前遇到的障碍-记得去电脑端启动Redis"><a href="#目前遇到的障碍-记得去电脑端启动Redis" class="headerlink" title="目前遇到的障碍 [记得去电脑端启动Redis]"></a>目前遇到的障碍 [记得去电脑端启动Redis]</h6><ul>
<li>session被网关过滤</li>
<li><strong>共享session</strong> [现在是多模块项目 其他项目保存了session 另一个项目无法获得]</li>
<li><strong><span style ="color:red">EnableRedisHttpSession</span></strong>[需要通过中介Redis去调取]</li>
</ul>
<pre><code class="java">在cloud-mall-user/application.properties中
server.port=8081

spring.datasource.name=imooc_mall_datasource
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=UTC
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root

mybatis.mapper-locations=classpath*:mappers/*.xml

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;

eureka.client.service-url.defaultZone=http://localhost:8000/eureka/

spring.application.name=cloud-mall-user

spring.session.store-type=redis
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
</code></pre>
<pre><code class="java">在cloud-mall-zuul/application.properties中
server.port=8083

spring.datasource.name=imooc_mall_datasource
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=UTC
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=root

mybatis.mapper-locations=classpath*:mappers/*.xml

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;

eureka.client.service-url.defaultZone=http://localhost:8000/eureka/

spring.application.name=cloud-mall-zuul

spring.session.store-type=redis
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=

#没有敏感的需要过滤
zuul.sensitive-headers=
zuul.host.connect-timeout-millis=15000
zuul.prefix=/
#凡是用户模块都要走/user地址
zuul.routes.cloud-mall-user.path=/user/**
#模块的名字
zuul.routes.cloud-mall-user.service-id=cloud-mall-user
</code></pre>
<pre><code class="java">之后在UserApplication和ZuulGatewayApplication前面加上@EnableRedisHttpSession

com/imooc/cloud/mall/practice/user/UserApplication.java
package com.imooc.cloud.mall.practice.user;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

/**
 * 启动类
 */
@SpringBootApplication
@EnableSwagger2
@MapperScan(basePackages = &quot;com.imooc.cloud.mall.practice.user.model.dao&quot;)
@EnableRedisHttpSession
public class UserApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(UserApplication.class, args);
    &#125;
&#125;

-------------------------------------------------------------------------------------

com/imooc/cloud/mall/practice/zuul/ZuulGatewayApplication.java
package com.imooc.cloud.mall.practice.zuul;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

/**
 * 网关启动类
 */
@EnableZuulProxy
@EnableFeignClients
@SpringBootApplication
@EnableRedisHttpSession
public class ZuulGatewayApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ZuulGatewayApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="商品分类与商品模块初始化"><a href="#商品分类与商品模块初始化" class="headerlink" title="商品分类与商品模块初始化"></a>商品分类与商品模块初始化</h3><h5 id="什么是商品分类"><a href="#什么是商品分类" class="headerlink" title="什么是商品分类"></a>什么是商品分类</h5><ul>
<li>条理清楚，层次分明</li>
<li>方便用户进行筛选和辨别</li>
<li>可以通过分类的设置快速的进入对应的商品列表页面进行商品选择</li>
</ul>
<h5 id="分类层级"><a href="#分类层级" class="headerlink" title="分类层级"></a>分类层级</h5><ul>
<li>在商品分类上需要继续做归类操作</li>
<li>分类设置成三级</li>
<li>层级太深的弊端：<ul>
<li>一是对用户不太友好，不利于寻找</li>
<li>二是对于后台管理人员不友好，不方便管理</li>
</ul>
</li>
</ul>
<blockquote>
<p>[cloud-mall-category-product]创造出来，将controller,model(dao,pojo),service,impi 里转入 Category来搞 因为在网关项目里写了关于管理员校验的方法 所以在此次处CategoryController把session里的校验删除</p>
</blockquote>
<pre><code class="xml">要让商品和商品目录用到User类 一定要去pom文件里添加依赖 不然idea找不到
pom.xml(cloud-mall-category-product)
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-mall-user&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/categoryproduct/config/CachingConfig.java
创建处理缓存的配置类 configpackage com.imooc.cloud.mall.practice.categoryproduct.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.RedisConnectionFactory;

import java.time.Duration;

*/**
* ** 57.缓存的配置类 想要运行成功保存序列化 要去弄个序列化接口
*   CategoryVO implements Serializable
* **/
*@Configuration
@EnableCaching
public class  CachingConfig &#123;
    @Bean
    public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory) &#123;

        RedisCacheWriter redisCacheWriter = RedisCacheWriter
                .lockingRedisCacheWriter(connectionFactory);
        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
        cacheConfiguration = cacheConfiguration.entryTtl(Duration.ofSeconds(30));

        RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter,
                cacheConfiguration);
        return redisCacheManager;
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">在网关中增加path和service-id
zuul.routes.cloud-mall-user.path=/user/**
zuul.routes.cloud-mall-user.service-id=cloud-mall-user

zuul.routes.cloud-mall-category-product.path=/category-product/**
zuul.routes.cloud-mall-category-product.service-id=cloud-mall-category-product
</code></pre>
<pre><code class="java">查端口  =&gt; netstat -ano | findstr :8083 [pid为7812]
杀死端口PID =&gt; taskkill /PID 7812 /f
</code></pre>
<h3 id="商品模块"><a href="#商品模块" class="headerlink" title="商品模块"></a>商品模块</h3><h5 id="更新和新增商品"><a href="#更新和新增商品" class="headerlink" title="更新和新增商品"></a>更新和新增商品</h5><ul>
<li>合并写法不可取</li>
<li>业务逻辑清晰、独立</li>
</ul>
<h5 id="批量上下架"><a href="#批量上下架" class="headerlink" title="批量上下架"></a>批量上下架</h5><ul>
<li>MyBatis遍历List</li>
<li>where语句拼接</li>
</ul>
<h5 id="商品列表：搜索功能"><a href="#商品列表：搜索功能" class="headerlink" title="商品列表：搜索功能"></a>商品列表：搜索功能</h5><h6 id="入参判空-→-加-通配符-→-like关键字"><a href="#入参判空-→-加-通配符-→-like关键字" class="headerlink" title="入参判空 → 加%通配符 → like关键字"></a>入参判空 → 加%通配符 → like关键字</h6><h5 id="对于查询目录的in处理"><a href="#对于查询目录的in处理" class="headerlink" title="对于查询目录的in处理"></a>对于查询目录的in处理</h5><ul>
<li>目录处理：如果查某个目录下的商品，不仅是需要查出来该目录的，还需要查出来子目录的所有商品</li>
<li>这里要拿到某一个目录Id下的所有子目录id的List</li>
</ul>
<h3 id="前台：商品列表"><a href="#前台：商品列表" class="headerlink" title="前台：商品列表"></a>前台：商品列表</h3><ul>
<li>排序功能</li>
<li>Mybatis PageHelper</li>
<li>枚举：order by</li>
</ul>
<pre><code class="java">把所有product的java都移动过去 controller/service/impl/modal.dao/modal.pojo/query.ProductListQuery/request.AddProductReq、ProductListReq、UpdateProductReq/resourcs.mappers.ProductMapper.xml
</code></pre>
<pre><code class="java">将Constant里的@Value(&quot;$&#123;file.upload.dir&#125;&quot;)的文件上传目录重构到category-product项目中
然后在其项目中的resources的application.properties中写一下路径
</code></pre>
<pre><code class="java">文件地址映射：config/imoocMallWebMvcConfig
</code></pre>
<h3 id="图片端口的特殊处理"><a href="#图片端口的特殊处理" class="headerlink" title="图片端口的特殊处理"></a>图片端口的特殊处理</h3><pre><code class="java">application.properties(cloud-mall-category-product)
file.upload.dir=/Users/Pluminary/Desktop/idea_Space/imooc-mall-prepare-static/

不能再通过获取getHost来配置了 根据实际情况去配置 没有办法获取到网关对外暴露的真正端口号
 private URI getHost(URI uri)&#123;
        URI effectiveURI;
        try &#123;
            effectiveURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(),null,null,null);
        &#125; catch (URISyntaxException e) &#123;
            effectiveURI = null; //如果新建失败 就返回回去
        &#125;
        return effectiveURI;
    &#125;

要改为com/imooc/cloud/mall/practice/categoryproduct/controller/ProductAdminController.java
/**
 * 58.后台商品管理Controller  pojo的product复制一份到request变成AddProductReq  59.需要ProductService.java
 */
@RestController
public class ProductAdminController &#123;

    @Autowired
    ProductService productService;

    @Value(&quot;$&#123;file.upload.ip&#125;&quot;)
    String ip;

    @Value(&quot;$&#123;file.upload.port&#125;&quot;)
    Integer port;

    @PostMapping(&quot;/admin/product/add&quot;)
    public ApiRestResponse addProduct(@Valid @RequestBody AddProductReq addProductReq) &#123;
        productService.add(addProductReq);
        return ApiRestResponse.success();
    &#125;

    @PostMapping(&quot;/admin/upload/file&quot;)
    public ApiRestResponse upload(HttpServletRequest httpServletRequest,
                                  @RequestParam(&quot;file&quot;) MultipartFile file) &#123;
        String fileName = file.getOriginalFilename();
        String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));
        //生成文件名称UUID
        UUID uuid = UUID.randomUUID();
        String newFileName = uuid.toString() + suffixName;
        //创建文件
        File fileDirectory = new File(ProductConstant.FILE_UPLOAD_DIR);
        File destFile = new File(ProductConstant.FILE_UPLOAD_DIR + newFileName);
        if (!fileDirectory.exists()) &#123;
            if (!fileDirectory.mkdir()) &#123;
                throw new ImoocMallException(ImoocMallExceptionEnum.MKDIR_FAILED);
            &#125;
        &#125;
        try &#123;
            file.transferTo(destFile);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            return ApiRestResponse
                    .success(getHost(new URI(httpServletRequest.getRequestURL() + &quot;&quot;)) + &quot;/category-product/images/&quot;
                            + newFileName);
        &#125; catch (URISyntaxException e) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.UPLOAD_FAILED);
        &#125;
    &#125;

    private URI getHost(URI uri) &#123;
        URI effectiveURI;
        try &#123;
            effectiveURI = new URI(uri.getScheme(), uri.getUserInfo(), ip, port,
                    null, null, null);
        &#125; catch (URISyntaxException e) &#123;
            effectiveURI = null;
        &#125;
        return effectiveURI;
    &#125;
</code></pre>
<h3 id="阶段性重难点和常见错误"><a href="#阶段性重难点和常见错误" class="headerlink" title="阶段性重难点和常见错误"></a>阶段性重难点和常见错误</h3><h5 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h5><ul>
<li>重难点：模块拆分设计、公共模块、<strong>Zuul(网关)过滤器</strong>、Session处理、Feign调用<br>Session在微服务的情况下就不容易处理到了可以共享Session，把其放<u>在Redis中实现</u>共享<br>Feign模块之间的接口调用[HTTP是手动调用]</li>
<li>常见错误：模块粒度不合适、无公共模块、各接口独立校验、session无法共享、HTTP手动调用</li>
</ul>
<h5 id="模块拆分-1"><a href="#模块拆分-1" class="headerlink" title="模块拆分"></a>模块拆分</h5><ul>
<li><strong>粒度</strong>：过粗、适中、过细</li>
<li>人员的角度</li>
<li>业务的角度：相关、独立</li>
</ul>
<h3 id="购物车与订单模块"><a href="#购物车与订单模块" class="headerlink" title="购物车与订单模块"></a>购物车与订单模块</h3><h5 id="购物车模块"><a href="#购物车模块" class="headerlink" title="购物车模块"></a>购物车模块</h5><ul>
<li><p>添加商品到购物车 → 商品是否在售、是否有库存 </p>
<ul>
<li><p>→[否] 提示用户</p>
</li>
<li><p>→[是] 该商品之前就在购物车里</p>
<ul>
<li>→[否] 添加新商品</li>
<li>→[是] 原有基础上添加数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">创建一个module 加入关于cart的controller/model.dao.pojo.vo/service.impl
其中ProductMapper productMapper会爆红是理所应当的 这样证明耦合不是很严重
利用远程调用Feign进行调用
思路：通过调查发现productMapper只用于挑选ID
Product product = productMapper.selectByPrimaryKey(productId);
所以可以去重构一下代码 回到商品模块的地方cloud-mall-category-product
其中controller中的ProductController
//com/imooc/cloud/mall/practice/categoryproduct/controller/ProductController.java
//这个是服务与服务之间的内部调用 不需要层层包装 只需要返回就好
    @GetMapping(&quot;product/detailForFeign&quot;)
    public Product detailForFeign(@RequestParam Integer id)&#123;
       Product product = productService.detail(id);
       return product;
    &#125;
//千万不要直接引用另一个项目的mapper 因为耦合有点严重 只要对面发生变化 就完蛋了
//com/imooc/cloud/mall/practice/cartorder/feign/ProductFeignClient.java
package com.imooc.cloud.mall.practice.cartorder.feign;

import com.imooc.cloud.mall.practice.categoryproduct.model.pojo.Product;
import org.springframework.web.bind.annotation.RequestParam;

public interface ProductFeignClient &#123;
    Product detailForFeign(@RequestParam Integer id);
&#125;
</code></pre>
<h3 id="用户模块提供获取当前用户接口"><a href="#用户模块提供获取当前用户接口" class="headerlink" title="用户模块提供获取当前用户接口"></a>用户模块提供获取当前用户接口</h3><pre><code class="java">com/imooc/cloud/mall/practice/user/controller/UserController.java
 @GetMapping(&quot;/getUser&quot;)
    @ResponseBody
    public User getUser(HttpSession session)&#123;
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        return currentUser;
    &#125; /**
     * 获取当前登录的User对象 为了避免暴露用户信息，可以再filter中对getUser进行拦截
     * @param session
     * @return
     */
    @GetMapping(&quot;/getUser&quot;)
    @ResponseBody
    public User getUser(HttpSession session)&#123;
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        return currentUser;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/cartorder/feign/UserFeignClient.java
package com.imooc.cloud.mall.practice.cartorder.feign;

import com.imooc.cloud.mall.practice.user.model.pojo.User;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

/**
 * UserFeign客户端
 */
@FeignClient(value = &quot;cloud-mall-user&quot;)
public interface UserFeignClient &#123;
    /**
     * 获取当前登录的user对象
     */
    @GetMapping(&quot;/getUser&quot;)
    User getUser();
&#125;
修改CaetMapper.xml的路径名
</code></pre>
<pre><code class="java">com/imooc/cloud/mall/practice/cartorder/feign/ProductFeignClient.java
package com.imooc.cloud.mall.practice.cartorder.feign;

import com.imooc.cloud.mall.practice.cartorder.pojo.Product;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
/**
 * 描述：     商品FeignClient
 */
@FeignClient(value = &quot;cloud-mall-category-product&quot;)
public interface ProductFeignClient &#123;
    //不经过网关 只是内部调用
    @GetMapping(&quot;product/detailForFeign&quot;)
    Product detailForFeign(@RequestParam Integer id);

    @PostMapping(&quot;product/updateStock&quot;)
    void updateStock(@RequestParam Integer productId, @RequestParam Integer stock);

&#125;
</code></pre>
<pre><code class="java">将新增模块加入到网关[前缀地址] zuul
zuul.routes.cloud-mall-user.path=/user/**
zuul.routes.cloud-mall-user.service-id=cloud-mall-user
zuul.routes.cloud-mall-category-product.path=/category-product/**
zuul.routes.cloud-mall-category-product.service-id=cloud-mall-category-product
zuul.routes.cloud-mall-cart-order.path=/cart-order/**
zuul.routes.cloud-mall-cart-order.service-id=cloud-mall-cart-order
</code></pre>
<h3 id="让Feign携带Session信息"><a href="#让Feign携带Session信息" class="headerlink" title="让Feign携带Session信息"></a>让Feign携带Session信息</h3><blockquote>
<p>错误新消息：500 Internal Server Error<br>在购物车中去调用User的getUser方法 是经过Feign<br>但是Feign的调用不经过网关 它是一个HTTP的调用<br>需要携带网关的Session信息</p>
</blockquote>
<ul>
<li><strong>FeignRequestInterceptor</strong> [对每一个发出的Feign进行拦截]<br>把网关的所有信息都复制到Feign的请求上 就不会遗漏相关信息</li>
</ul>
<pre><code class="java">com/imooc/cloud/mall/practice/cartorder/filter/FeignRequestInterceptor.java
package com.imooc.cloud.mall.practice.cartorder.filter;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import java.util.Enumeration;
import javax.servlet.http.HttpServletRequest;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

/**
 * 描述：     Feign请求拦截器
 */
@EnableFeignClients
@Configuration
public class FeignRequestInterceptor implements RequestInterceptor &#123;

    @Override
    public void apply(RequestTemplate requestTemplate) &#123;
        //通过RequestContextHolder获取到请求 拿到requestAttributes
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        if (requestAttributes == null) &#123;
            return;
        &#125;//类型转换 拿到Request
        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
        Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); //拿到所有Header名字
        if (headerNames != null) &#123;
            while (headerNames.hasMoreElements()) &#123; //如果还有新的元素 先获取
                String name = headerNames.nextElement(); //获取相关的值
                Enumeration&lt;String&gt; values = request.getHeaders(name);
                while (values.hasMoreElements()) &#123;//获取到当前元素
                    String value = values.nextElement();
                    requestTemplate.header(name, value);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="订单模块"><a href="#订单模块" class="headerlink" title="订单模块"></a>订单模块</h3><ul>
<li><h5 id="表设计和接口设计"><a href="#表设计和接口设计" class="headerlink" title="表设计和接口设计"></a>表设计和接口设计</h5></li>
</ul>
<pre><code class="java">&quot;订单编号的名字也要改 不能是以前的自增id 要变成order_no&quot;
order_no是每一种商品的id
否则黑客早上下一单 晚上下一单 相减 就可以估计客流量 
分成了很详细的字段名
product_id/name/img 都是之前购买过的订单产生的数据
</code></pre>
<h3 id="生成订单–用户下单"><a href="#生成订单–用户下单" class="headerlink" title="生成订单–用户下单"></a>生成订单–用户下单</h3><ul>
<li>入参</li>
<li>从购物车中查询已经勾选的商品</li>
<li>判断商品是否正在售卖中</li>
<li>判断库存，保证不超卖</li>
<li>调用商品服务扣库存 [及时更新库存]</li>
<li>删除购物车为中对应的商品</li>
<li>生成订单</li>
<li>订单号生成规则</li>
<li>循环保存每一个商品到order_item表</li>
</ul>
<h3 id="图片路径配置"><a href="#图片路径配置" class="headerlink" title="图片路径配置"></a>图片路径配置</h3><pre><code class="java">com/imooc/cloud/mall/practice/cartorder/config/ImoocMallWebMvcConfig.java
package com.imooc.cloud.mall.practice.cartorder.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 描述：     地址映射配置
 */
@Configuration
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;

    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    String FILE_UPLOAD_DIR;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + FILE_UPLOAD_DIR);
    &#125;

</code></pre>
<h3 id="购物车和订单模块-重难点"><a href="#购物车和订单模块-重难点" class="headerlink" title="购物车和订单模块-重难点"></a>购物车和订单模块-重难点</h3><ul>
<li>订单表[多个关联(订单编号+状态)]、订单状态设计</li>
<li>购物车流程</li>
<li>下单流程</li>
<li>Feign调用的处理</li>
</ul>
<h5 id="购物车和订单模块-常见错误"><a href="#购物车和订单模块-常见错误" class="headerlink" title="购物车和订单模块-常见错误"></a>购物车和订单模块-常见错误</h5><ul>
<li>Feign调用取不到User对象</li>
<li>URL错误拦截(图片url可以不拦截[订单+购物车])</li>
<li>路由配置错误(二维码&#x2F;图片不显示)</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/04/11/后端/SpringCloud基础-电商实战/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/04/04/后端/多线程与分布式/">
        <h2>
            多线程与分布式
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/4
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="多线程与分布式-周介绍"><a href="#多线程与分布式-周介绍" class="headerlink" title="多线程与分布式 [周介绍]"></a>多线程与分布式 [周介绍]</h1><ul>
<li><h6 id="线程池的基本使用、特点、注意点"><a href="#线程池的基本使用、特点、注意点" class="headerlink" title="线程池的基本使用、特点、注意点"></a>线程池的基本使用、特点、注意点</h6></li>
<li><h6 id="ThreadLoacal的基本使用、原理和注意事项"><a href="#ThreadLoacal的基本使用、原理和注意事项" class="headerlink" title="ThreadLoacal的基本使用、原理和注意事项"></a>ThreadLoacal的基本使用、原理和注意事项</h6></li>
<li><h6 id="分布式基础、核心概念"><a href="#分布式基础、核心概念" class="headerlink" title="分布式基础、核心概念"></a>分布式基础、核心概念</h6></li>
<li><h6 id="docker的下载、安装和基本命令"><a href="#docker的下载、安装和基本命令" class="headerlink" title="docker的下载、安装和基本命令"></a>docker的下载、安装和基本命令</h6></li>
<li><h6 id="独立制作docker容器"><a href="#独立制作docker容器" class="headerlink" title="独立制作docker容器"></a>独立制作docker容器</h6></li>
<li><h6 id="Nginx的安装、基本使用和使用命令"><a href="#Nginx的安装、基本使用和使用命令" class="headerlink" title="Nginx的安装、基本使用和使用命令"></a>Nginx的安装、基本使用和使用命令</h6></li>
<li><h6 id="使用Nginx搭建文件服务"><a href="#使用Nginx搭建文件服务" class="headerlink" title="使用Nginx搭建文件服务"></a>使用Nginx搭建文件服务</h6></li>
<li><h6 id="消息队列RabbitMQ的核心概念queue、message和exchange"><a href="#消息队列RabbitMQ的核心概念queue、message和exchange" class="headerlink" title="消息队列RabbitMQ的核心概念queue、message和exchange"></a>消息队列RabbitMQ的核心概念queue、message和exchange</h6></li>
<li><h6 id="RabbitMQ的四种交换机模式"><a href="#RabbitMQ的四种交换机模式" class="headerlink" title="RabbitMQ的四种交换机模式"></a>RabbitMQ的四种交换机模式</h6></li>
<li><h6 id="SpringBoot整合RabbitMQ案例"><a href="#SpringBoot整合RabbitMQ案例" class="headerlink" title="SpringBoot整合RabbitMQ案例"></a>SpringBoot整合RabbitMQ案例</h6></li>
</ul>
<h2 id="线程池-——-治理线程的法宝"><a href="#线程池-——-治理线程的法宝" class="headerlink" title="线程池 —— 治理线程的法宝"></a>线程池 —— 治理线程的法宝</h2><ul>
<li>线程池的<strong>自我介绍</strong></li>
<li><strong>创建</strong>和停止线程池</li>
<li><strong>常见线程池</strong>的特点和用法</li>
<li>任务太多，怎么<strong>拒绝</strong></li>
<li>钩子方法，给线程池加点料</li>
<li>实现<strong>原理、源码分析</strong></li>
<li>使用线程池的注意点</li>
</ul>
<h5 id="线程池的自我介绍"><a href="#线程池的自我介绍" class="headerlink" title="线程池的自我介绍"></a>线程池的自我介绍</h5><ul>
<li>线程池的重要性 [可以复用我们的线程]</li>
<li>什么是”池” – 软件中的”池”，可以理解为计划经济</li>
<li>如果不适用线程池，每个任务都新开一个线程处理<ul>
<li>一个线程</li>
<li>for循环创建线程</li>
<li>当任务数量上升到1000<br><code>这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题</code>[多了会报错 内存不足异常]</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/ForLoop.java
package threadpool;
/**
 * 描述：     TODO
 */
public class ForLoop &#123;

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            Thread thread = new Thread(new Task());
            thread.start();
        &#125;
    &#125;

    static class Task implements Runnable &#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;执行了任务&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h5><ul>
<li>问题一：反复创建线程开销大</li>
<li>问题二：过多的线程会占用太多内存</li>
<li>解决以上两个问题的思路<ul>
<li>用少量的线程——避免内存占用过多</li>
<li>让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗</li>
</ul>
</li>
</ul>
<h5 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h5><ul>
<li>加快响应速度</li>
<li>合理利用CPU和内存</li>
<li>统一管理</li>
</ul>
<h5 id="线程池使用应用的场合"><a href="#线程池使用应用的场合" class="headerlink" title="线程池使用应用的场合"></a>线程池使用应用的场合</h5><ul>
<li>服务器(Tomcat)接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少现成的创建和销毁次数，提高服务器的工作效率</li>
<li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li>
</ul>
<h3 id="线程增减的时机"><a href="#线程增减的时机" class="headerlink" title="线程增减的时机"></a>线程增减的时机</h3><h5 id="创建和停止线程池"><a href="#创建和停止线程池" class="headerlink" title="创建和停止线程池"></a>创建和停止线程池</h5><ul>
<li>线程池<strong>构造方法的参数</strong></li>
<li>线程池应该<strong>手动创建</strong>还是自动创建</li>
<li>线程池里的<strong>线程数量</strong>设定为多少比较合适</li>
<li><strong>停止</strong>线程池的方法</li>
</ul>
<h5 id="线程池构造方法的参数"><a href="#线程池构造方法的参数" class="headerlink" title="线程池构造方法的参数"></a>线程池构造方法的参数</h5><table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>int</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>保持存活时间</td>
</tr>
<tr>
<td>workQueue</td>
<td>BlockingQueue</td>
<td>任务存储队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>当线程池需要新的线程的时候，会使用threadFactory来生成新的线程</td>
</tr>
<tr>
<td>Handler</td>
<td>RejectedExecutionHandler</td>
<td>由于线程池无法接收你所提交的任务的拒绝策略</td>
</tr>
</tbody></table>
<h5 id="参数中的corePoolSize和maxPoolSize"><a href="#参数中的corePoolSize和maxPoolSize" class="headerlink" title="参数中的corePoolSize和maxPoolSize"></a>参数中的corePoolSize和maxPoolSize</h5><ul>
<li><p><strong>corePoolSize</strong>指的是核心线程数<br>线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新的线程去执行任务</p>
</li>
<li><p>最大量<strong>maxPoolSize</strong><br>在核心线程数的基础上，格外增加的线程数的上限</p>
</li>
</ul>
<h5 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h5><ol>
<li>如果线程数小于corePoolSize，创建一个新线程来运行新任务</li>
<li>如果线程数等于(或大于) corePoolSize但少于maximumPoolSize，则将任务放入<strong>队列</strong></li>
<li>如果队列已满，并且线程数小于maxPoolSize，则创建一个<strong>新线程</strong></li>
<li>如果队列已满，并且线程数大于或等于maxPoolSize，则<strong>拒绝</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4cb2755066dc76e6602ff1110cfc24124f38b42f/data/%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png"></p>
<ul>
<li>是否需要增加线程的判断顺序是：<ul>
<li>corePoolSize</li>
<li>workQueue</li>
<li>maxPoolSize</li>
</ul>
</li>
</ul>
<h6 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h6><ul>
<li>线程池：核心池大小为5，最大池大小为10，队列为100</li>
<li>因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程maxPoolSize，最多到10个线程，如果再来任务，就拒绝</li>
</ul>
<h5 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h5><ul>
<li>通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池</li>
<li>线程池<strong>希望保持较小的线程数</strong>，并且只有在负载变得很大时才增加它</li>
<li>通过设置maximumPoolSize为很高的值，可以允许线程池容纳任意数量的并发任务</li>
<li>只有在队列填满时才创建多于corePoolSize的线程，如果使用的是无界队列，那么线程数就不会超过corePoolSize</li>
</ul>
<h3 id="线程存活时间和工作队列"><a href="#线程存活时间和工作队列" class="headerlink" title="线程存活时间和工作队列"></a>线程存活时间和工作队列</h3><h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><ul>
<li>如果线程池当前的线程多余corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，它们就会被终止</li>
</ul>
<h5 id="ThreadFactory-用来创建线程"><a href="#ThreadFactory-用来创建线程" class="headerlink" title="ThreadFactory 用来创建线程"></a>ThreadFactory 用来创建线程</h5><ul>
<li>默认使用Executors.defaultThreadFactory()</li>
<li>创建出来的线程都在同一个线程组</li>
<li>如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等</li>
</ul>
<h5 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h5><ul>
<li>有三种最常见的队列类型<ul>
<li>直接交接：SynchronousQueue</li>
<li>无界队列：LinkedBlockingQueue</li>
<li>有界队列：ArrayBlockingQueue</li>
</ul>
</li>
</ul>
<h3 id="自动创建线程池的风险"><a href="#自动创建线程池的风险" class="headerlink" title="自动创建线程池的风险"></a>自动创建线程池的风险</h3><h5 id="线程池应该手动创建还是自动创建"><a href="#线程池应该手动创建还是自动创建" class="headerlink" title="线程池应该手动创建还是自动创建"></a>线程池应该手动创建还是自动创建</h5><ul>
<li>手动创建更好，因为这样可以更加明确线程池的运行规则，避免资源耗尽的风险<br>自动创建线程池(即直接调用JDK封装好的构造方法) 可能会带来哪些问题？</li>
<li><strong>newFixedThreadPool</strong><ul>
<li>容易造成大量内存占用，可能会导致OOM</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/FixedThreadPoolThread.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class FixedThreadPoolThread &#123;
    public static void main(String[] args) &#123; //核心线程数量
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
class Task implements Runnable&#123;

    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
        System.out.println(Thread.currentThread().getName());
    &#125;
&#125;
=======================================================================
pool-1-thread-3
pool-1-thread-4
pool-1-thread-1
pool-1-thread-2
    
pool-1-thread-3
pool-1-thread-1
pool-1-thread-4
pool-1-thread-2
因为核心线程数量只规定了4个 这有这四个线程跑程序
</code></pre>
<pre><code class="java">threadpool/FixedThreadPoolOOM.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示nexFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM &#123;
    private static ExecutorService executorService = Executors.newFixedThreadPool(1);

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; Integer.MAX_VALUE; i++)&#123;
            executorService.execute(new SubThread());
        &#125;
    &#125;
&#125;
class SubThread implements Runnable&#123;

    @Override
    public void run() &#123;
        try&#123;//一直睡觉 不让它结束
            Thread.sleep(1000000000);
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
=======================================================================
报错：java.lang.OutOfMemoryError:GC overhead limilt exceeded
</code></pre>
<ul>
<li><strong>newSingleThreadExecutor</strong> [单独的线程]<ul>
<li>当请求堆积的时候，可能会占用大量的内存</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/SingleThreadExecutor.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SingleThreadExecutor &#123;
    public static void main(String[] args) &#123;
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
=======================================================================
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
</code></pre>
<ul>
<li><strong>CachedThreadPool</strong> [可缓存线程池]<ul>
<li>特点：具有自动回收多余线程的功能</li>
<li>弊端在于第二个参数maximumPoolSize被设置为了Integer.MAX_VALUE, 这可能会创建数量非常多的线程，甚至导致OOM</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/CachedThreadPool.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CachedThreadPool &#123;
    public static void main(String[] args) &#123;
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>newScheduledThreadPool</strong> [跟时间相关的]</li>
</ul>
<pre><code class="java">threadpool/ScheduledThreadPool.java
package threadpool;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledThreadPool &#123;
    public static void main(String[] args) &#123;
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
        threadPool.schedule(new Task(), 5, TimeUnit.SECONDS);
        threadPool.scheduleAtFixedRate(new Task(), 1, 3, TimeUnit.SECONDS);//每隔3s运行
    &#125;
&#125;
</code></pre>
<ul>
<li>正确的创建线程池的方法<ul>
<li><strong>根据不同的业务场景</strong>，设置线程池参数</li>
<li>比如：内存有多大，给线程取什么名字等等</li>
</ul>
</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="线程池里的线程数量设定为多少比较合适？"><a href="#线程池里的线程数量设定为多少比较合适？" class="headerlink" title="线程池里的线程数量设定为多少比较合适？"></a>线程池里的线程数量设定为多少比较合适？</h3><ul>
<li><strong>CPU密集型</strong>(加密、计算hash等)：最佳线程数为CPU核心数的1-2倍左右</li>
<li><strong>耗时IO型</strong>(读写数据库、文件、网络读写等)：最佳线程数一般会大于CPU核心数很多倍<br>参考Brain Goetz推荐的计算方法：<br><span style = "color:red"><strong>线程数 &#x3D; CPU核心数 × (1 + 平均等待时间 &#x2F; 平均工作时间)</strong></span></li>
</ul>
<h3 id="对比各种线程池的特点"><a href="#对比各种线程池的特点" class="headerlink" title="对比各种线程池的特点"></a>对比各种线程池的特点</h3><h5 id="常见的线程池的特点"><a href="#常见的线程池的特点" class="headerlink" title="常见的线程池的特点"></a>常见的线程池的特点</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/ee67f47de97062e593b16348ff148cd52f7b7d6e/data/%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg"></p>
<h5 id="以上4种线程池的构造方法的参数"><a href="#以上4种线程池的构造方法的参数" class="headerlink" title="以上4种线程池的构造方法的参数"></a>以上4种线程池的构造方法的参数</h5><table>
<thead>
<tr>
<th>Parameter</th>
<th>FixedThreadPool</th>
<th>CachedThreadPool</th>
<th>ScheduledThreadPool</th>
<th>SingleThreaded</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>constructor-arg</td>
<td>0</td>
<td>constructor-arg</td>
<td>1</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>same as corePoolSize</td>
<td>Integer.MAX_VALUE</td>
<td>Integer.MAX_VALUE</td>
<td>1</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>0 seconds</td>
<td>60 seconds</td>
<td>0 seconds</td>
<td>0 seconds</td>
</tr>
</tbody></table>
<h3 id="阻塞队列分析"><a href="#阻塞队列分析" class="headerlink" title="阻塞队列分析"></a>阻塞队列分析</h3><ul>
<li>FixedThreadPool和SingleThreadExecutor的Queue是<strong>LinedBlockingQueue</strong>？</li>
<li>CachedThreadPool使用的是Queue是<strong>SynchronousQueue</strong>？</li>
<li>ScheduledThreadPool使用延迟队列DelayedWorkQueue</li>
</ul>
<h5 id="workStealingPool是JDK1-8加入的"><a href="#workStealingPool是JDK1-8加入的" class="headerlink" title="workStealingPool是JDK1.8加入的"></a>workStealingPool是JDK1.8加入的</h5><ul>
<li>这个线程池和之前的都有很大不同</li>
<li>子任务</li>
<li>窃取 [并行执行]</li>
</ul>
<h3 id="如何正确关闭线程池"><a href="#如何正确关闭线程池" class="headerlink" title="如何正确关闭线程池"></a>如何正确关闭线程池</h3><h5 id="停止线程池的正确方法"><a href="#停止线程池的正确方法" class="headerlink" title="停止线程池的正确方法"></a>停止线程池的正确方法</h5><ul>
<li><strong>shutdown</strong> [再给就拒绝 新的任务不会增加了]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        executorService.execute(new ShutDownTask());
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;

=================================================================================
pool-1-thread-4
pool-1-thread-9
pool-1-thread-10
Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task threadpool.ShutDownTask@61bbe9ba rejected from java.util.concurrent.ThreadPoolExecutor@610455d6[Shutting down, pool size = 10, active threads = 10, queued tasks = 970, completed tasks = 20]
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)
    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)
    at threadpool.Shutdown.main(Shutdown.java:18)
pool-1-thread-8
pool-1-thread-1
pool-1-thread-3
</code></pre>
<ul>
<li><strong>isShutdown</strong> [判断是否进入停止状态]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        System.out.println(executorService.isShutdown());//false
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        System.out.println(executorService.isShutdown());//true 已经结束了
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>isTerminated</strong> [线程停止返回 整个程序执行完毕]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        System.out.println(executorService.isShutdown());//false
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        System.out.println(executorService.isShutdown());//true 已经结束了
        System.out.println(executorService.isTerminated());
        Thread.sleep(10000);
        System.out.println(executorService.isTerminated());
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
==========================================================================
pool-1-thread-5
pool-1-thread-10
false
true
false
pool-1-thread-2
pool-1-thread-6
pool-1-thread-6
pool-1-thread-2
true
</code></pre>
<ul>
<li><strong>awaitTermination</strong> [测试一段时间内线程会不会完全停止的方法 <u>等待的时间进程被打乱了</u> 等待的时间到了]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500); //七秒钟之内是否完全运行完毕了
        executorService.shutdown();
        boolean b = executorService.awaitTermination(7L, TimeUnit.SECONDS);
        System.out.println(b);
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>shutdownNow</strong> [立刻关闭线程池]</li>
</ul>
<pre><code class="java">///正在执行的和不要关闭 正在等待的内容直接返回 如何优雅编写？
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500); //七秒钟之内是否完全运行完毕了
        executorService.shutdownNow();//暴力关闭线程
        //这是正在队列中的数据 取了个List集合 都到runnableList里面了 要给它一个交代
        List&lt;Runnable&gt; runnableList = executorService.shutdownNow();
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;被中断了&quot;);
        &#125;
    &#125;
&#125;

=================================================================
pool-1-thread-6
pool-1-thread-4
pool-1-thread-10
pool-1-thread-8
pool-1-thread-3被中断了
pool-1-thread-1被中断了
pool-1-thread-8被中断了
pool-1-thread-2被中断了
</code></pre>
<h3 id="暂停和恢复线程池"><a href="#暂停和恢复线程池" class="headerlink" title="暂停和恢复线程池"></a>暂停和恢复线程池</h3><ul>
<li><strong>拒绝时机</strong><ul>
<li>当Executor关闭时，提交<strong>新任务</strong>会<strong>被拒绝</strong></li>
<li>以及当Executor对最大线程和工作队列容量使用有限边界并且<strong>已经饱和</strong>时</li>
</ul>
</li>
</ul>
<h5 id="4种拒绝策略"><a href="#4种拒绝策略" class="headerlink" title="4种拒绝策略"></a>4种拒绝策略</h5><ul>
<li><strong>AbortPolicy</strong> [直接抛出异常]</li>
<li><strong>DiscardPolicy</strong> [默默的丢弃]</li>
<li><strong>DiscardOldestPolicy</strong> [丢弃最老的]</li>
<li><strong>CallerRunsPolicy</strong> [誰提交任务誰去跑(避免了业务损失 提交任务速度下降 给了线程池缓冲时间)]</li>
</ul>
<h5 id="钩子方法，给线程池加点料"><a href="#钩子方法，给线程池加点料" class="headerlink" title="钩子方法，给线程池加点料"></a>钩子方法，给线程池加点料</h5><ul>
<li>每个任务执行前后</li>
<li>日志、统计</li>
<li>代码演示</li>
</ul>
<pre><code class="java">threadpool/PauseableThreadPool.java
package threadpool;

import java.util.concurrent.*;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 演示每个任务执行前后放钩子函数
 */
public class PauseableThreadPool extends ThreadPoolExecutor &#123;
    private final ReentrantLock lock = new ReentrantLock();
    private Condition unpaused = lock.newCondition();
    private boolean isPaused;
    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    &#125;

    @Override //在执行任务之前都会调用这个函数
    protected void beforeExecute(Thread t, Runnable r) &#123;
        super.beforeExecute(t, r);
        lock.lock();
        //如果检测到就暂停休息
        try &#123;
            while (isPaused) &#123;
                unpaused.await();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private void pause()&#123;
        lock.lock();
        try&#123;
            isPaused = true;
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;
    public void resume()&#123;
        lock.lock();
        try&#123;
            isPaused = false;
            unpaused.signalAll(); //唤醒全部
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        PauseableThreadPool pauseableThreadPool = new PauseableThreadPool(10, 20, 10l,
                TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());
        Runnable runnable = new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;我被执行&quot;);
                try &#123;
                    Thread.sleep(10);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;;
        for (int i = 0; i &lt; 10000; i++) &#123;
            pauseableThreadPool.execute(runnable);
        &#125;
            Thread.sleep(1500);
            pauseableThreadPool.pause();
            System.out.println(&quot;线程池被暂停了&quot;);
            Thread.sleep(1500);
            pauseableThreadPool.resume();
            System.out.println(&quot;线程池被恢复了&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="线程池实现复用的原因"><a href="#线程池实现复用的原因" class="headerlink" title="线程池实现复用的原因"></a>线程池实现复用的原因</h3><ul>
<li>线程池组成部分<ul>
<li>线程池管理器</li>
<li>工作线程</li>
<li>任务队列</li>
<li>任务接口(Task)</li>
</ul>
</li>
</ul>
<h5 id="Executor家族"><a href="#Executor家族" class="headerlink" title="Executor家族"></a>Executor家族</h5><ul>
<li><p>线程池、ThreadPoolExecutor、ExecutorService、Executor、Executors等这么多和线程池相关的类，都是什么关系？</p>
<p>Executor ← ExecutorService ← AbstractExecutorService ← ThreadPoolExecutor</p>
</li>
</ul>
<h5 id="线程池实现任务复用的原理"><a href="#线程池实现任务复用的原理" class="headerlink" title="线程池实现任务复用的原理"></a>线程池实现任务复用的原理</h5><ul>
<li>相同线程执行不同任务</li>
</ul>
<h3 id="线程池状态和使用注意点"><a href="#线程池状态和使用注意点" class="headerlink" title="线程池状态和使用注意点"></a>线程池状态和使用注意点</h3><h5 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h5><table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>接收新任务并处理排队任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>不接受新任务，但处理排队任务</td>
</tr>
<tr>
<td>STOP</td>
<td>不接受新任务，也不处理排队任务，并中断正在进行的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>所有任务都已终止，workerCount为零时，线程会转换到TIDYING状态，并将运行terminate()钩子方法</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>terminate()运行完成</td>
</tr>
</tbody></table>
<h5 id="使用线程池的注意点"><a href="#使用线程池的注意点" class="headerlink" title="使用线程池的注意点"></a>使用线程池的注意点</h5><ul>
<li>避免任务<strong>堆积</strong></li>
<li>避免线程数<strong>过度增加</strong></li>
<li>排查<strong>线程泄露</strong></li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h6 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h6><ul>
<li>让某个需要用到的对象在<strong>线程间隔离</strong></li>
<li>在任何方法中都可以<strong>轻松获取</strong>到该对象 .get</li>
</ul>
<p>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get和set方法访问) 时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是ptivate static类型的，用于关联线程和线程上下文，它的作用是：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂性。</p>
<ul>
<li>定义：提供<strong>线程局部</strong>变量；一个线程局部变量在多个线程中，分别由独立的值(副本)</li>
<li>特点：简单(开箱即用)、快速(无格外开销)、安全(线程安全)</li>
<li>场景：多线程场景(<strong>资源持有、线程一致性、并发计算、线程安全</strong>等场景)</li>
<li>实现原理：Java中使用<strong>哈希表</strong>实现</li>
<li>应用范围：几乎<strong>所有</strong>提供多线程特征的语言</li>
<li>设计者追求开箱即用的体验</li>
</ul>
<h3 id="ThreadLocal-API"><a href="#ThreadLocal-API" class="headerlink" title="ThreadLocal API"></a>ThreadLocal API</h3><ul>
<li>构造函数 <strong>ThreadLocal<T>()</strong></li>
<li>初始化 <strong>initialValue()</strong><ul>
<li>该方法会返回当前线程对应的”初始值”，这是一个<strong>延迟加载</strong>的方法，只有在<strong>调用get</strong>的时候，才会触发</li>
<li>当线程<strong>第一次使用get</strong>方法访问变量时，将调用此方法</li>
<li>每个线程最多调用<strong>一次</strong>此方法，但如果已经调用了remove()后，在调用get()，则可以再次调用此方法</li>
<li>如果不重写本方法，这个方法会返回null。一般使用匿名内部类的方法来**重写initialValue()**方法</li>
</ul>
</li>
<li>访问器 T <strong>get</strong>()：得到这个线程对应的value，如果是首次调用get()则会调用initialize来得到这个值 &#x2F;&#x2F; void <strong>set</strong>(T t)：为这个线程设置一个新值</li>
<li>回收 void <strong>remove</strong>(): 删除这个线程</li>
</ul>
<h6 id="根据共享对象的生成时机不同，选择initialValue或set来保存对象"><a href="#根据共享对象的生成时机不同，选择initialValue或set来保存对象" class="headerlink" title="根据共享对象的生成时机不同，选择initialValue或set来保存对象"></a>根据共享对象的生成时机不同，选择initialValue或set来保存对象</h6><h6 id="场景一：initialValue"><a href="#场景一：initialValue" class="headerlink" title="场景一：initialValue"></a>场景一：initialValue</h6><ul>
<li>在ThreadLocal<strong>第一次get</strong>的时候把对象給初始化出来，对象的初始化时机可以<strong>由我们控制</strong></li>
</ul>
<h6 id="场景二：set"><a href="#场景二：set" class="headerlink" title="场景二：set"></a>场景二：set</h6><ul>
<li>如果需要保存到ThreadLocal里的对象的生成时机<strong>不由我们随机控制</strong>，例如拦截器生成的用户信息</li>
<li>用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用</li>
</ul>
<h6 id="使用ThreadLocal带来的好处"><a href="#使用ThreadLocal带来的好处" class="headerlink" title="使用ThreadLocal带来的好处"></a>使用ThreadLocal带来的好处</h6><ul>
<li>达到<strong>线程安全</strong></li>
<li><strong>不需要加锁</strong>，提高执行<strong>效率</strong></li>
<li>更高效地<strong>利用内存、节省开销</strong></li>
<li><strong>避免传参</strong>的繁琐</li>
</ul>
<pre><code class="java">threadpool/ThreadLocalAPI.java
package threadpool;

public class ThreadLocalAPI &#123;
    public static ThreadLocal&lt;Long&gt; x = new ThreadLocal()&#123;
        @Override
        protected Long initialValue()&#123;
            System.out.println(&quot;Inital Value run...&quot;);
            return Thread.currentThread().getId();
        &#125;
    &#125;;

    public static void main(String[] args) &#123;
        new Thread() &#123;
            @Override
            public void run() &#123;
                System.out.println(x.get());
            &#125;
        &#125;.start(); //调用一次initialValue 每个线程单独拥有一个
        x.set(101l);
        x.remove();//清空线程 结果为1 因为 Thread.currentThread().getId();
        System.out.println(x.get());//发现x.remove被移除了 结果去重新触发initialValue
        System.out.println(x.get());
    &#125;
&#125;
========================================================================
Inital Value run...
Inital Value run...
20
1
1

若注释掉x.remove则会出现结果：
Inital Value run...
101
101
20
</code></pre>
<h3 id="ThreadLocal的4种核心场景"><a href="#ThreadLocal的4种核心场景" class="headerlink" title="ThreadLocal的4种核心场景"></a>ThreadLocal的4种核心场景</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e19e3d304bdfe6eeda2ae3a7f83a22ad4b9f274c/data/ThreadLocal%E7%9A%844%E7%A7%8D%E6%A0%B8%E5%BF%83%E5%9C%BA%E6%99%AF.png"></p>
<ul>
<li><strong>持有资源</strong>——持有线程资源供线程的各个部分使用，全局获取，减少<strong>编程难度</strong></li>
<li><strong>线程一致</strong>——帮助需要保持线程一致的资源(如数据库事务) 维护一致性，降低<strong>编程难度</strong></li>
<li><strong>线程安全</strong>——帮助只考虑了单线程的程序库，无缝向多线程场景迁移</li>
</ul>
<h3 id="ThreadLocal并发场景分析01"><a href="#ThreadLocal并发场景分析01" class="headerlink" title="ThreadLocal并发场景分析01"></a>ThreadLocal并发场景分析01</h3><h5 id="例1-200QPS压测统计接口"><a href="#例1-200QPS压测统计接口" class="headerlink" title="例1 200QPS压测统计接口"></a>例1 200QPS压测统计接口</h5><ul>
<li>观察200QPS下Spring框架的执行情况</li>
<li>目标：理解并发、竞争条件、临界区等概念</li>
<li>代表场景：交易场景</li>
</ul>
<h5 id="并发、竞争条件和临界区"><a href="#并发、竞争条件和临界区" class="headerlink" title="并发、竞争条件和临界区"></a>并发、竞争条件和临界区</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/7abcc6448891d1b18f32a37dcaf90210ca396b58/data/ThreadLocal%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF.jpg" alt="ThreadLocal并发场景"></p>
<ul>
<li>并发：多个程序<strong>同时执行</strong></li>
<li>竞争条件：多个进程(线程)同时访问<strong>同一个内存资源</strong>，最终的执行结果依赖于多个进程执行时的<strong>精确时序</strong></li>
<li>临界区：访问共享内存的程序片段</li>
</ul>
<pre><code class="java">StatController.java
package com.imooc.springbootlearn;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller //并发可能导致同时 数据错误 需要加★后面的代码
public class StatController &#123;
    //★★ 避免用锁 导致当数据多的话线程缓慢
    static ThreadLocal&lt;Integer&gt; c = new ThreadLocal&lt;Integer&gt;() &#123;
        @Override
        protected Integer initialValue() &#123;
            return 0;
        &#125;
    &#125;;
    //★ 请求并发也要排队synchronized(但是不要轻易使用锁) 应该怎么办 见★★
    synchronized void _add() throws InterruptedException &#123;
        Thread.sleep(100);
        c.set(c.get() + 1);
    &#125;

    @RequestMapping(&quot;/stat&quot;)
    public Integer stat() &#123;
        return c.get();
    &#125;

    @RequestMapping(&quot;/add&quot;)
    public Integer add() throws InterruptedException &#123;
//        Thread.sleep(100l);
//        c++;
        _add();
        return 1;
    &#125;

&#125;
</code></pre>
<pre><code class="java">SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages=&quot;com.imooc&quot;)
public class SpringBootlearnApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;
&#125;
</code></pre>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>基于线程池模型synchronize(排队操作很危险)</li>
<li>用ThreadLocal收集数据很快速且安全</li>
<li>思考：如何在多个ThreadLocal中收集数据？</li>
</ul>
<h3 id="ThreadLocal场景分析——减少同步"><a href="#ThreadLocal场景分析——减少同步" class="headerlink" title="ThreadLocal场景分析——减少同步"></a>ThreadLocal场景分析——减少同步</h3><h5 id="ThreadLocal-lt-T-gt-同步"><a href="#ThreadLocal-lt-T-gt-同步" class="headerlink" title="ThreadLocal&lt; T &gt;同步"></a>ThreadLocal&lt; T &gt;同步</h5><pre><code class="java">StatController.java    高效解决高并发
package com.imooc.springbootlearn;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.HashSet;

@Controller //并发可能导致同时 数据错误 需要加★后面的代码
public class StatController &#123;

    static HashSet&lt;Val&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();
    synchronized static void addSet(Val&lt;Integer&gt; v)&#123;
        set.add(v);
    &#125;

    //★★ 避免用锁 导致当数据多的话线程缓慢
    static ThreadLocal&lt;Val&lt;Integer&gt;&gt; c = new ThreadLocal&lt;Val&lt;Integer&gt;&gt;() &#123;
        @Override
        protected Val&lt;Integer&gt; initialValue() &#123;
            Val&lt;Integer&gt; v = new Val&lt;&gt;();
            v.set(0);
            //set.add(v);//容易产生同步问题 小锁一下
            return v;
        &#125;
    &#125;;

    //★ 请求并发也要排队synchronized(但是不要轻易使用锁) 应该怎么办 见★★
/*synchronized*/void _add() throws InterruptedException &#123;
        Thread.sleep(100); //高并发
        Val&lt;Integer&gt; v = c.get();
        v.set(v.get() + 1);
    &#125;

    @RequestMapping(&quot;/stat&quot;)
    public Integer stat() &#123;
        return set.stream().map(x -&gt; x.get()).reduce((a, x) -&gt; a + x).get();
    &#125;

    @RequestMapping(&quot;/add&quot;)
    public Integer add() throws InterruptedException &#123;
//        Thread.sleep(100l);
//        c++;
        _add();
        return 1;
    &#125;
&#125;
</code></pre>
<pre><code class="java">Val.java
package com.imooc.springbootlearn;

public class Val&lt;T&gt;&#123;
    T v;
    public void set(T _v)&#123;
        v = _v;
    &#125;
    public T get()&#123;
        return v;
    &#125;
&#125;
</code></pre>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul>
<li>完全避免同步(<strong>难</strong>)</li>
<li>缩小同步范围(<strong>简单</strong>) + ThreadLocal解决问题</li>
<li>思考：还可以用在哪些场景？</li>
</ul>
<h6 id="源码分析1-Quartz-SimpleSemaphore"><a href="#源码分析1-Quartz-SimpleSemaphore" class="headerlink" title="源码分析1-Quartz SimpleSemaphore"></a>源码分析1-Quartz SimpleSemaphore</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/d20d4cb3a98413a2fb910922671f8a98e6d114a5/data/Quartz%E4%BB%8B%E7%BB%8D.png"></p>
<ul>
<li>Quartz的SimpleSemaphore提供资源隔离(上锁)</li>
<li>SimpleSemaphore中的lockOwners(ThreadLocal)为重度锁操作前置过滤</li>
<li>思考：学易，用难！</li>
</ul>
<h6 id="源码分析2-Mybatis框架保持连接池线程一致"><a href="#源码分析2-Mybatis框架保持连接池线程一致" class="headerlink" title="源码分析2-Mybatis框架保持连接池线程一致"></a>源码分析2-Mybatis框架保持连接池线程一致</h6><h5 id="什么是本地事务"><a href="#什么是本地事务" class="headerlink" title="什么是本地事务"></a>什么是本地事务</h5><ul>
<li>A(Atomic)原子性，操作不可分割</li>
<li>C(Consistency)一致性，任何时刻数据都能保持一致</li>
<li>I(Isolation)隔离性，多事务并发执行的时许不影响结果</li>
<li>D(Durability)持久性，对数据结构的存储是永久的</li>
</ul>
<p>Begin → [本地事务：(更新订单状态 →&lt;订单状态更新成功&gt;→发放资源) → <strong>资源发放成功(提交)</strong> → Commit →&lt;持久化&gt;→DB。**若资源发放失败(回滚)**→Rollback]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9693ffeda32d871b1665958a7febca56da0011bd/data/Mybatis%E6%A1%86%E6%9E%B6%E4%BF%9D%E6%8C%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%BA%BF%E7%A8%8B%E4%B8%80%E8%87%B4.jpg"></p>
<h6 id="源码分析03-Spring框架对分布式事务的支持"><a href="#源码分析03-Spring框架对分布式事务的支持" class="headerlink" title="源码分析03 Spring框架对分布式事务的支持"></a>源码分析03 Spring框架对分布式事务的支持</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/b2cc782319836bb4d81765c38fe5b8de5098bb21/data/Spring%E6%A1%86%E6%9E%B6%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81.jpg"></p>
<h3 id="技术选型——实现自己的ThreadLocal"><a href="#技术选型——实现自己的ThreadLocal" class="headerlink" title="技术选型——实现自己的ThreadLocal"></a>技术选型——实现自己的ThreadLocal</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ec226021e343c1f8dbc268e9809361c629e6cb4d/data/threadLocalMap.jpg"></p>
<pre><code class="java">MyThreadLocal.java
package com.imooc.springbootlearn;

import java.util.HashMap;
import java.util.Objects;

class MyThreadLocal&lt;T&gt; &#123;
    static HashMap&lt;Thread, HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt;&gt; threadLocalMap = new HashMap&lt;&gt;();//这里会产生临界区

    synchronized static HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt; getMap() &#123; //这是锁临界区
        var thread = Thread.currentThread();
        if (!threadLocalMap.containsKey(thread)) &#123;
            threadLocalMap.put(thread, new HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt;());
        &#125;
        return threadLocalMap.get(thread);
    &#125;

    T value;

    protected T initialValue() &#123;
        return null;
    &#125;

    public T get() &#123;
        var map = getMap();
        if (!map.containsKey(this)) &#123;
            map.put(this, initialValue());
        &#125;
        return (T) map.get(this);
    &#125;

    public void set(T v)&#123;
        var map = getMap();
        map.put(this, v);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Test.java
package com.imooc.springbootlearn;

public class Test &#123;
    static MyThreadLocal&lt;Long&gt; v = new MyThreadLocal&lt;Long&gt;()&#123;
        @Override
        protected Long initialValue() &#123;
         return Thread.currentThread().getId();
        &#125;
    &#125;;

    public static void main(String[] args) &#123;
        for (Integer i = 0; i &lt; 100; i++) &#123;
            new Thread(()-&gt;&#123;
                System.out.println(v.get());
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>HashMap中直接存储了MyThreadLocal的引用，导致内存无法回收</li>
<li>思考：可以用整数ID替代对MyThreadLocal的引用</li>
</ul>
<pre><code class="java">MyThreadLocal.java
package com.imooc.springbootlearn;

import java.util.HashMap;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;

class MyThreadLocal&lt;T&gt; &#123;
    static AtomicInteger atomic = new AtomicInteger(); //保证数据唯一性
    Integer threadLocalHash = atomic.addAndGet(0x61c88647); //这个值保证hash的更平均性
    static HashMap&lt;Thread, HashMap&lt;Integer, Objects&gt;&gt; threadLocalMap = new HashMap&lt;&gt;();//这里会产生临界区

    synchronized static HashMap&lt;Integer, Objects&gt; getMap() &#123; //这是锁临界区
        var thread = Thread.currentThread();
        if (!threadLocalMap.containsKey(thread)) &#123;
            threadLocalMap.put(thread, new HashMap&lt;Integer, Objects&gt;());
        &#125;
        return threadLocalMap.get(thread);
    &#125;

    T value;

    protected T initialValue() &#123;
        return null;
    &#125;

    public T get() &#123;
        var map = getMap();
        if (!map.containsKey(this.threadLocalHash)) &#123;
            map.put(this.threadLocalHash, initialValue());
        &#125;
        return (T) map.get(this.threadLocalHash);
    &#125;

    public void set(T v)&#123;
        var map = getMap();
        map.put(this.threadLocalHash, v);
    &#125;
&#125;
</code></pre>
<ul>
<li>HashMap无限增加？初始空间分配是否合理？</li>
</ul>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h5 id="源码解读——哈希表实现ThreadLocal"><a href="#源码解读——哈希表实现ThreadLocal" class="headerlink" title="源码解读——哈希表实现ThreadLocal"></a>源码解读——哈希表实现ThreadLocal</h5><h6 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h6><p><strong>哈希表</strong>(散列 HashTable) 根据键(Key) 访问&#x2F;设置内存中存储的位置的值</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c2851c7bd5792200e8f9af16f6f08a33520c6f2d/data/%E9%80%89%E5%AD%A6HashTable.png"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>架构是严密且精确的东西(切记夸夸其谈)</li>
<li>并发是一个很危险的场景，提高能力才会获得安全感</li>
<li>保持怀疑，持续学习</li>
<li>会用 → 场景查找 → 轻量实现 → 源码对照 → 场景沉淀</li>
<li>程序架构：低耦合(独立)、高内聚(组合做到开箱即用)</li>
<li>无论达到什么高度，要永远认为自己是个<strong>菜鸡</strong></li>
</ul>
<h2 id="分布式章节"><a href="#分布式章节" class="headerlink" title="分布式章节"></a>分布式章节</h2><ul>
<li><h5 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h5></li>
<li><h5 id="分布式的作用"><a href="#分布式的作用" class="headerlink" title="分布式的作用"></a>分布式的作用</h5></li>
<li><h5 id="分布式和单体结构的对比"><a href="#分布式和单体结构的对比" class="headerlink" title="分布式和单体结构的对比"></a>分布式和单体结构的对比</h5></li>
<li><p><strong>CAP</strong>定理</p>
</li>
<li><p><span style = "color:red"><strong>集群、分布式、微服务</strong></span>的区别</p>
</li>
</ul>
<h3 id="什么是分布式-1"><a href="#什么是分布式-1" class="headerlink" title="什么是分布式"></a>什么是分布式</h3><ul>
<li><p>利用物理架构形成多个自治的处理元素，<strong>不共享主内存</strong>，但是通过<strong>发送信息</strong>合作。</p>
</li>
<li><h6 id="饭店初始的例子"><a href="#饭店初始的例子" class="headerlink" title="饭店初始的例子"></a>饭店初始的例子</h6><ul>
<li><strong>一个</strong>厨师 [单例]</li>
<li><strong>多个</strong>厨师 </li>
<li>术业有<strong>专攻</strong>：配菜师、洗菜工</li>
</ul>
</li>
<li><p>实际项目的演进过程</p>
<ul>
<li>一个项目，<strong>大而全</strong></li>
<li><strong>多台机器</strong>，部署相同的应用</li>
<li><strong>分布式</strong>：权限系统、员工系统、请假系统</li>
</ul>
</li>
</ul>
<h3 id="分布式的作用-1"><a href="#分布式的作用-1" class="headerlink" title="分布式的作用"></a>分布式的作用</h3><h5 id="为什么需要分布式"><a href="#为什么需要分布式" class="headerlink" title="为什么需要分布式"></a>为什么需要分布式</h5><ul>
<li>实际工作中的痛点<ul>
<li>工程<strong>臃肿</strong> [相互耦合 相互冲突]</li>
<li>测试、上线<strong>繁琐</strong></li>
<li>开发<strong>效率低</strong></li>
</ul>
</li>
</ul>
<h5 id="单体应用的问题"><a href="#单体应用的问题" class="headerlink" title="单体应用的问题"></a>单体应用的问题</h5><ul>
<li>应用代码<strong>耦合</strong>严重，功能扩展难</li>
<li>新需求开发交互周期长，测试工作量大</li>
<li>新加入的开发同事需要很长时间才能熟悉系统</li>
<li>升级维护也很困难(改动任何一点地方都要升级整个系统)</li>
<li>系统性能提升艰难，可用性低，不稳定</li>
</ul>
<h5 id="分布式的好处"><a href="#分布式的好处" class="headerlink" title="分布式的好处"></a>分布式的好处</h5><ul>
<li>增大系统容量</li>
<li>加强系统可用[某个模块出bug 但不影响其他]</li>
<li>因为模块化，所以系统模块重用度更高</li>
<li>因为软件服务模块被拆分，开发和发布速度可以并行而变得更快</li>
<li>系统<strong>扩展性</strong>更高</li>
<li>团队<strong>协作流程</strong>也会得到改善</li>
<li><strong>技术升级</strong></li>
</ul>
<h3 id="单体和分布式的对比"><a href="#单体和分布式的对比" class="headerlink" title="单体和分布式的对比"></a>单体和分布式的对比</h3><h5 id="分布式和单体结构的对比-1"><a href="#分布式和单体结构的对比-1" class="headerlink" title="分布式和单体结构的对比"></a>分布式和单体结构的对比</h5><table>
<thead>
<tr>
<th></th>
<th>传统单体构架</th>
<th>分布式构架</th>
</tr>
</thead>
<tbody><tr>
<td><strong>新人的学习成本</strong></td>
<td>业务逻辑成本高</td>
<td>架构逻辑成本高</td>
</tr>
<tr>
<td><strong>部署、运维</strong></td>
<td>容易</td>
<td>发布频繁，顺序复杂、运维难</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>一损俱损，殃及鱼池</td>
<td>故障影响范围小</td>
</tr>
<tr>
<td><strong>架构设计</strong></td>
<td>难度低</td>
<td>难度指数级上升</td>
</tr>
<tr>
<td><strong>系统性能</strong></td>
<td>响应快、吞吐量小</td>
<td>响应慢、吞吐量大</td>
</tr>
<tr>
<td><strong>测试成本</strong></td>
<td>低</td>
<td>很高</td>
</tr>
<tr>
<td><strong>技术多样性</strong></td>
<td>技术单一且封闭</td>
<td>技术多样且开放</td>
</tr>
<tr>
<td><strong>系统扩展性</strong></td>
<td>扩展性差</td>
<td>扩展性很好</td>
</tr>
<tr>
<td><strong>系统管理成本</strong></td>
<td>成本低</td>
<td>成本高</td>
</tr>
</tbody></table>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><h5 id="CAP的重要性"><a href="#CAP的重要性" class="headerlink" title="CAP的重要性"></a>CAP的重要性</h5><p>分布式不可能同时满足三个条件</p>
<h5 id="CAP理论是什么？"><a href="#CAP理论是什么？" class="headerlink" title="CAP理论是什么？"></a>CAP理论是什么？</h5><ul>
<li><span style = "color:red"><strong>C</strong>(Consistency, 一致性)</span>：读操作是否总能读到前一个写操作的结果</li>
<li><span style = "color:red"><strong>A</strong>(Availability, 可用性)</span>：非故障节点应该在合理的时间内作出合理的响应(不是错误或超时的响应),但是可能<strong>不是最新的数据</strong>。</li>
<li><span style = "color:red"><strong>P</strong>(Partition tolerance, 分区容错)</span>：当出现网络分区现象后，系统能够继续运行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/793eb4ab3003af82869b186bcc016fcb8c2c2f5b/data/CAP%E5%AE%9A%E7%90%86.jpg"></p>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
</ul>
<h3 id="集群、分布式、微服务的区别"><a href="#集群、分布式、微服务的区别" class="headerlink" title="集群、分布式、微服务的区别"></a>集群、分布式、微服务的区别</h3><h5 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h5><ul>
<li>分布式：一个业务分拆<strong>多个子业务</strong>，部署在不同的服务器上 [服务器之间要通信]</li>
<li>集群：<strong>同一个</strong>业务，部署在多个服务器上 [五台机器可以不通信]</li>
</ul>
<h5 id="集群和微服务的区别"><a href="#集群和微服务的区别" class="headerlink" title="集群和微服务的区别"></a>集群和微服务的区别</h5><ul>
<li>集群：分散<strong>压力</strong></li>
<li>微服务：分散<strong>压力</strong></li>
</ul>
<h5 id="微服务和分布式的区别"><a href="#微服务和分布式的区别" class="headerlink" title="微服务和分布式的区别"></a>微服务和分布式的区别</h5><ul>
<li><p>微服务是<strong>架构设计</strong>方式 [逻辑架构]</p>
</li>
<li><p>分布式是<strong>系统部署</strong>方式 [物理架构]</p>
</li>
<li><p>微服务：是一种架构方式 [大的服务拆成小的服务 每个服务独立开发测试]</p>
</li>
<li><p>分布式：主要强调部署的方式</p>
</li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul>
<li>基本概念、用途、核心思想</li>
<li>Docker的组成、架构、重要概念</li>
<li>Docker的安装</li>
<li><strong>第一个Docker容器</strong></li>
<li>运用Nginx镜像，并访问到Docker容器内部 [从外部进行访问]</li>
<li>制作自己的Docker容器，<strong>dockerfile</strong>实战</li>
</ul>
<h3 id="Docker的基本概念、用途、核心思想"><a href="#Docker的基本概念、用途、核心思想" class="headerlink" title="Docker的基本概念、用途、核心思想"></a>Docker的基本概念、用途、核心思想</h3><ul>
<li>Docker应用广泛<br>京东618：15万个Docker实例，所有业务全部容器化</li>
<li>Docker是什么？<br>[以前的图标是大鲸鱼拖着集装箱]<ul>
<li>Docker是一个用来装程序及其环境的<strong>容器</strong>[类似于<u>安装包.exe</u>]，属于Linux容器的一种封装，提供简单易用的容器使用接口。它是目前<strong>最流行</strong>的Linux容器解决方案</li>
<li>比喻：客车可以装人，衣柜可以放衣服 [Windows下写的小游戏也可以放在Docker中]</li>
</ul>
</li>
</ul>
<h3 id="为什么需要Docker"><a href="#为什么需要Docker" class="headerlink" title="为什么需要Docker"></a>为什么需要Docker</h3><ul>
<li><strong>环境配置</strong>的难题</li>
<li>虚拟机[资源占用很多 模拟一套完整系统但步骤多(有些步骤无法跳过) 启动慢]</li>
<li>Docker的基础——<strong>Linux容器</strong> [体积小 速度快 轻量级虚拟机]</li>
</ul>
<h3 id="Docker的用途"><a href="#Docker的用途" class="headerlink" title="Docker的用途"></a>Docker的用途</h3><ul>
<li>提供<strong>统一</strong>的环境</li>
<li>提供<strong>快速拓展</strong>、弹性伸缩的云服务 [解决双十一淘宝+天猫 数据量剧增问题]</li>
<li>防止其他用户的进程把服务器资源<strong>占用过多</strong> [程序相互之间可以隔离]</li>
<li>部署简单 运维简单 节省服务器资源</li>
</ul>
<h3 id="Docker的特点"><a href="#Docker的特点" class="headerlink" title="Docker的特点"></a>Docker的特点</h3><h5 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h5><ul>
<li><p><strong>运输方式</strong>(把程序和环境从一个机器运送到另一个机器)</p>
</li>
<li><p><strong>存储方式</strong>(程序和环境的存储)</p>
</li>
<li><p><strong>API接口</strong>(不需要Tomcat等应用的命令了，都标准化了)</p>
</li>
<li><p><strong>灵活</strong>：即使是最复杂的应用也可以集装箱化</p>
</li>
<li><p><strong>轻量级</strong>：容器利用并共享主机内核</p>
</li>
<li><p><strong>便携式</strong>：可以在本地构建，部署到云，并在任何地方运行</p>
</li>
</ul>
<h5 id="Docker带来的好处"><a href="#Docker带来的好处" class="headerlink" title="Docker带来的好处"></a>Docker带来的好处</h5><ul>
<li>开发团队的好处 完全可以控制所有的环境[同一个镜像] 降低了风险</li>
</ul>
<h3 id="image镜像"><a href="#image镜像" class="headerlink" title="image镜像"></a>image镜像</h3><ul>
<li>存储：联合文件系统，UnionFS</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/28665426b3b7f9351280ab4c58b1ea388391f211/data/image%E9%95%9C%E5%83%8F.jpg"></p>
<h3 id="容器和仓库"><a href="#容器和仓库" class="headerlink" title="容器和仓库"></a>容器和仓库</h3><ul>
<li><strong>镜像类似于Java中的类，而容器就是实例化</strong></li>
<li>容器的这一层是可以修改的，而镜像是不可以修改的</li>
<li>同一个镜像可以生成多个容器独立运行，而她们之间没有任何的干扰</li>
</ul>
<h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><ul>
<li><strong>hub.docker.com</strong></li>
<li><a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></li>
<li>共有、私有</li>
</ul>
<h5 id="client和deamon"><a href="#client和deamon" class="headerlink" title="client和deamon"></a>client和deamon</h5><ul>
<li><strong>client</strong>[<strong>客户端</strong>]：提供給用户一个终端，用户输入Docker提供的命令来管理本地或远程的服务器</li>
<li><strong>deamon</strong>：<strong>服务端</strong>守护进程，接收Client发送的命令并执行相应的操作</li>
</ul>
<h3 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h3><ul>
<li><h6 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h6><a target="_blank" rel="noopener" href="https://www.docker.com/products/docker-desktop/">Docker Desktop: The #1 Containerization Tool for Developers | Docker</a></li>
</ul>
<h5 id="更换系统镜像"><a href="#更换系统镜像" class="headerlink" title="更换系统镜像"></a>更换系统镜像</h5><p><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/region/cn-hangzhou">云服务器管理控制台 (aliyun.com)</a> → 实例 → 更多 → 更换操作系统 → CentOS 7.6 64位</p>
<pre><code class="java">C:\Users\Pluminary&gt;ssh root@47.98.225.105
    
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:THXnakQ0Se5ee+d7oHO0NYKBTW7mhEKc426m9+rQgnk.
Please contact your system administrator.
Add correct host key in C:\\Users\\Pluminary/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in C:\\Users\\Pluminary/.ssh/known_hosts:7
Host key for 47.98.225.105 has changed and you have requested strict checking.
Host key verification failed.
    
//使用命令或手动删除 C:\\Users\\Pluminary/.ssh/known_hosts 防火墙拦截了
vim C:\\Users\\Pluminary/.ssh/known_hosts

C:\Users\Pluminary&gt;ssh root@47.98.225.105
root@47.98.225.105&#39;s password:Panchunyao123!

[root@iZbp1dssknxftmjczbtpndZ ~]# cat /etc/redhat-release
CentOS Linux release 7.6.1810 (Core)
//yum地址换成国内yum源
   //wget-O 这是大写的字母O 含义是放到指定目录下 替换本地文件为国内文件
[root@iZbp1dssknxftmjczbtpndZ ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
[root@iZbp1dssknxftmjczbtpndZ ~]# yum clean all
[root@iZbp1dssknxftmjczbtpndZ ~]# yum makecache //读取新的源

//较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。
[root@iZbp1dssknxftmjczbtpndZ ~]# yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
//如果yum报告未安装这些软件包，也没问题。
    //更新yum 先查看需要更新哪些
[root@iZbp1dssknxftmjczbtpndZ ~]# yum check-update
[root@iZbp1dssknxftmjczbtpndZ ~]# yum update
// 安装所需的软件包
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install -y yum-utils \
                  device-mapper-persistent-data \
                  lvm2
// 使用以下命令来设置稳定的存储库 sudo是用超级管理员
[root@iZbp1dssknxftmjczbtpndZ ~]# sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

// 查看docker版本
[root@iZbp1dssknxftmjczbtpndZ ~]# yum list docker-ce --showduplicates | sort -r
// 安装指定的版本
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io
// Docker 是服务器----客户端架构
// 命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动
[root@iZbp1dssknxftmjczbtpndZ ~]# systemctl start docker
// 安装完成后，运行下面的命令，验证是否安装成功。
[root@iZbp1dssknxftmjczbtpndZ ~]# docker version 或者 docker info
</code></pre>
<h3 id="第一个Docker容器"><a href="#第一个Docker容器" class="headerlink" title="第一个Docker容器"></a>第一个Docker容器</h3><ul>
<li><span style = "color:red"><strong>下载镜像</strong></span></li>
<li><strong>docker pull [OPTIONS] NAME[:TAG]</strong></li>
<li><strong>docker images [OPTIONS] [REPOSITORY[:TAG]]</strong> 查看本机有没有任何镜像</li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
c1ec31eb5944: Pull complete
Digest: sha256:53641cd209a4fecfc68e21a99871ce8c6920b2e7502df0a20671c6fccc73a7c6
Status: Downloaded newer image for hello-world:latest
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              d2c94e258dcb        11 months ago       13.3kB
</code></pre>
<ul>
<li><span style = "color:red"><strong>运行镜像</strong></span></li>
<li><strong>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</strong></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hello-world
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal. 

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre>
<h3 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h3><h5 id="运行Nginx镜像，并访问到Docker容器内部"><a href="#运行Nginx镜像，并访问到Docker容器内部" class="headerlink" title="运行Nginx镜像，并访问到Docker容器内部"></a>运行Nginx镜像，并访问到Docker容器内部</h5><ul>
<li><strong>前台、后台</strong></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker images //查看一下程序镜像是否还在
[root@iZbp1dssknxftmjczbtpndZ ~]# docker pull hub.c.163.com/library/nginx:1.13.0
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello-world                   latest              d2c94e258dcb        11 months ago       13.3kB
hub.c.163.com/library/nginx   1.13.0              46102226f2fd        6 years ago         109MB
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hub.c.163.com/library/nginx:1.13.0
//上面的没反应是正常情况，再开一个cmd窗口


//第二个窗口：另一个cmd窗口 
C:\Users\Pluminary&gt;ssh root@47.98.225.105
root@47.98.225.105&#39;s password:
Last login: Sun Apr  7 16:30:40 2024 from 182.102.75.173

Welcome to Alibaba Cloud Elastic Compute Service !
//展示当前容器列表
[root@iZbp1dssknxftmjczbtpndZ ~]# docker ps
CONTAINER ID        IMAGE                                COMMAND                  CREATED              STATUS              PORTS               NAMES
298f7e19f6a8        hub.c.163.com/library/nginx:1.13.0   &quot;nginx -g &#39;daemon of…&quot;   About a minute ago   Up About a minute   80/tcp              kind_taussig
//这时回到第一个窗口 ctrl+c 关掉运行 这时去第二个窗口docker ps的时候已经没有了
// ↓↓↓↓↓↓ 要把Nginx在后台运行才可以解决上述问题 ↓↓↓↓↓↓
[root@iZbp1dssknxftmjczbtpndZ ~]# docekr run -d hub.c.163.com/library/nginx:1.13.0
f124fc9171824e508639768b800efba5c780385dc1d135ab0ff70d80d3d75510 //返回容器ID
//此时再去第二个窗口 docker ps就会看到 CONTAINER ID 有f124fc917182
//第一个窗口 查看容器内部的风景 -i让容器输入有效 t是給我们分配一个终端 bash是启动终端
[root@iZbp1dssknxftmjczbtpndZ ~]# docker exec -it f124 bash //让docker明白我们让哪个启动
root@f124fc917182:/#  //已经进入到容器内部
root@f124fc917182:/# pwd
/
root@f124fc917182:/# touch 1 //创建了一个1
root@f124fc917182:/# ls
1  bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@f124fc917182:/# which nginx
/usr/sbin/nginx
</code></pre>
<h3 id="Docker三种网络模式-网络会隔离-需要配置进行端口映射"><a href="#Docker三种网络模式-网络会隔离-需要配置进行端口映射" class="headerlink" title="Docker三种网络模式 [网络会隔离 需要配置进行端口映射]"></a>Docker三种网络模式 [网络会隔离 需要配置进行端口映射]</h3><ul>
<li><strong>Bridge</strong> 网卡网络独立的端口</li>
<li><strong>Host</strong> 同步宿主机的端口</li>
<li>None</li>
<li>端口映射技术</li>
</ul>
<h5 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h5><ul>
<li>访问Docker内的Nginx</li>
</ul>
<pre><code class="java">cmd窗口2
[root@iZbp1dssknxftmjczbtpndZ ~]# docker stop f12
f12
[root@iZbp1dssknxftmjczbtpndZ ~]# docker ps //目前没有容器在运行了
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
    //-p 本机的8080端口去映射内部的80端口 前面的是本机 后面的是容器内部的
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run -d -p 8080:80 hub.c.163.com/library/nginx:1.13.0
3906129ced72b668581a58dc36595b08734b82e247e2927eb2a8da6fbe7508ae
//拔出端口的信息
[root@iZbp1dssknxftmjczbtpndZ ~]# netstat -na|grep 8080
tcp6       0      0 :::8080                 :::*                    LISTEN

在网页上输入 http://47.98.225.105:8080/

Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.
For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.
Thank you for using nginx.

这个不是在宿主机启动的nginx 而是在容器中启动的【通过宿主机中转 并通过Bridge实现独立】
★★ 通过一台服务器上去布置多台Docker 而每台docker里面是独立的 并且可以通过一个端口 来实现和外界的映射关系 ★★
//这个与7行代码的区别 这里是大P 将这个容器的所有端口都进行映射
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run -d -P hub.c.163.com/library/nginx:1.13.0
</code></pre>
<h3 id="制作自己的Docker容器，dockerfile实战"><a href="#制作自己的Docker容器，dockerfile实战" class="headerlink" title="制作自己的Docker容器，dockerfile实战"></a>制作自己的Docker容器，dockerfile实战</h3><p>[把自己的软件程序打包好传給别人]</p>
<ul>
<li>dockerfile作用</li>
<li>使用dockerfile的好处[一目了然 哪个环境跑在什么环境下 非常方便知道如何配置]</li>
<li>写一个自己的dockerfile</li>
</ul>
<blockquote>
<p>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p>
</blockquote>
<pre><code class="sql">FROM alpine:latest #继承父类 alpine及其小的环境
MAINTAINER imooc   #描述这个镜像由誰维护的
CMD echo &#39;hello my dockerfile&#39;  #进入任何想要的dockerfile命令
</code></pre>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# touch Dockerfile
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
Dockerfile
[root@iZbp1dssknxftmjczbtpndZ ~]# vim Dockerfile
//按小写i进入编辑模式  按ESC退出编辑模式 :wq会保存
//取名字 .dockerfile现在的路径
[root@iZbp1dssknxftmjczbtpndZ ~]# docker build -t hello_docker .
    //先发送到服务器
Sending build context to Docker daemon  285.7kB
    //从父类中拉取下来
Step 1/3 : FROM alpine:latest
latest: Pulling from library/alpine
4abcf2066143: Pull complete
Digest: sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6b
Status: Downloaded newer image for alpine:latest
 ---&gt; 05455a08881e
    //写定它的维护者
Step 2/3 : MAINTAINER imooc
 ---&gt; Running in 38a73abca50e
Removing intermediate container 38a73abca50e
---&gt; f44831f49afe
    //把这个语句写进去
Step 3/3 : CMD echo &#39;hello my dockerfile&#39;
 ---&gt; Running in 1ff431539208
Removing intermediate container 1ff431539208
 ---&gt; f45b88d0cabc
Successfully built f45b88d0cabc
Successfully tagged hello_docker:latest

//运行自己的镜像
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello_docker                  latest              f45b88d0cabc        3 minutes ago       7.38MB
alpine                        latest              05455a08881e        2 months ago        7.38MB
hello-world                   latest              d2c94e258dcb        11 months ago       13.3kB
hub.c.163.com/library/nginx   1.13.0              46102226f2fd        6 years ago         109MB
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hello_docker
hello my dockerfile
</code></pre>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><ul>
<li><h6 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h6></li>
<li><h6 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h6></li>
<li><h6 id="常用命令讲解和演示"><a href="#常用命令讲解和演示" class="headerlink" title="常用命令讲解和演示"></a>常用命令讲解和演示</h6></li>
<li><h6 id="配置文件讲解"><a href="#配置文件讲解" class="headerlink" title="配置文件讲解"></a>配置文件讲解</h6></li>
<li><h6 id="场景实战：搭建一个静态文件的Nginx服务"><a href="#场景实战：搭建一个静态文件的Nginx服务" class="headerlink" title="场景实战：搭建一个静态文件的Nginx服务"></a>场景实战：搭建一个静态文件的Nginx服务</h6></li>
</ul>
<h3 id="Nginx介绍-1"><a href="#Nginx介绍-1" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h3><ul>
<li>Nginx是什么、适用场景</li>
<li>Nginx应用广泛</li>
<li>Nginx优点</li>
</ul>
<h4 id="Nginx是什么、适用场景"><a href="#Nginx是什么、适用场景" class="headerlink" title="Nginx是什么、适用场景"></a>Nginx是什么、适用场景</h4><ul>
<li>HTTP的<strong>反向代理</strong>服务器</li>
<li><strong>动态静态</strong>资源分离</li>
</ul>
<h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a><span style = "color:red">正向代理</span></h5><p>普通的请求转发，客户端把信息传递到代理服务器，代理服务器找到信息转发给我们<br>提供安全功能 代理服务器有防火墙，可以隐藏自身的信息 </p>
<h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><span style = "color:red">反向代理</span></h5><p>提供安全和防火墙 在多个服务器后端提供负载均衡 为服务器提供缓存 把来自用户的压力平均分配[负载均衡]</p>
<h5 id="动态静态资源分离-加速访问-整体速度提高"><a href="#动态静态资源分离-加速访问-整体速度提高" class="headerlink" title="动态静态资源分离 [加速访问 整体速度提高]"></a><span style = "color:red">动态静态资源分离</span> [加速访问 整体速度提高]</h5><ul>
<li>不分离会<strong>变慢</strong></li>
<li>静态资源<strong>无需经过Tomcat</strong>，Tomcat只负责处理动态请求</li>
<li>后缀为gif的时候，Nginx会<strong>直接</strong>获取到当前请求的文件并返回</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/93ef10f6db6a389181a9f20268c6c4b8b82c46d7/data/%E6%AD%A3%E5%90%91_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_.jpg"></p>
<h3 id="Nginx应用广泛"><a href="#Nginx应用广泛" class="headerlink" title="Nginx应用广泛"></a>Nginx应用广泛</h3><h5 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h5><ul>
<li>高并发、高性能</li>
<li>可扩展性好</li>
<li>高可靠性 [服务器运行可以达到数年之久]</li>
<li>热部署</li>
<li>开源、可商用</li>
</ul>
<h3 id="Nginx的安装-1"><a href="#Nginx的安装-1" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h3><h5 id="Nginx在CentOs安装"><a href="#Nginx在CentOs安装" class="headerlink" title="Nginx在CentOs安装"></a>Nginx在CentOs安装</h5><pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# yum install yum-utils
[root@iZbp1dssknxftmjczbtpndZ ~]# vim /etc/yum.repos.d/nginx.repo  //输入源信息 告诉它从哪下载
//输入：3-18行 配置源
[root@iZbp1dssknxftmjczbtpndZ ~]# [nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/
gpgcheck=1
enabled=0
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
    //然后查看源 列出可以使用的ngix地址
[root@iZbp1dssknxftmjczbtpndZ ~]# yum list | grep nginx
    //运行安装命令
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install nginx 1:1.16.1-1.el7.ngx
    //查看版本，若出现版本号，则安装成功
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx -v
nginx version: nginx/1.24.0
用whereis nginx可以查看到目录：
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz
</code></pre>
<h3 id="常用命令讲解和演示-1"><a href="#常用命令讲解和演示-1" class="headerlink" title="常用命令讲解和演示"></a>常用命令讲解和演示</h3><pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# /usr/sbin/ngix 启动
[root@iZbp1dssknxftmjczbtpndZ ~]# systemctl stop docker //把之前的docker关停
[root@iZbp1dssknxftmjczbtpndZ ~]# ps -aux | grep nginx //提取相关进程 80是默认端口
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx -h //提取帮助
    
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /etc/nginx
[root@iZbp1dssknxftmjczbtpndZ nginx]# ls //里面有nginx.conf配置文件 conf.d中也有一个defalut.conf
conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params
[root@iZbp1dssknxftmjczbtpndZ nginx]# cd conf.d/
    
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c   //读取指定配置文件
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -s stop //停止nginx
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c /etc/nginx/nginx.conf //以这个文件启动nginx

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -t //发布前的测试
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -s stop
[root@iZbp1dssknxftmjczbtpndZ conf.d]# /usr/sbin/nginx //开启nginx
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -t //查看使用的哪个配置文件
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -v //打印版本信息
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -V //打印详细参数
    
[root@iZbp1dssknxftmjczbtpndZ conf.d]# whereis uginx//找nginx的路径
nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz
[root@iZbp1dssknxftmjczbtpndZ conf.d]# ps aux | grep nginx //打印进程信息

    //-s信号 1.stop立即停止 2.quit优雅停止 3.reload重启[优雅停止quit] 4.reopen更换日志文件
</code></pre>
<h3 id="配置文件讲解-1"><a href="#配置文件讲解-1" class="headerlink" title="配置文件讲解"></a>配置文件讲解</h3><ul>
<li><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li>“; “ 结尾</li>
<li>“{}” 组织多条指令 </li>
<li>“include” 引入</li>
<li>‘’#’’ 注释</li>
</ul>
</li>
<li><h5 id="实操演示"><a href="#实操演示" class="headerlink" title="实操演示"></a>实操演示</h5></li>
<li><h5 id="默认配置文件分析"><a href="#默认配置文件分析" class="headerlink" title="默认配置文件分析"></a>默认配置文件分析</h5><ul>
<li>nginx.conf</li>
<li>default.conf</li>
</ul>
</li>
</ul>
<pre><code class="mysql">[root@iZbp1dssknxftmjczbtpndZ conf.d]# cat /etc/nginx/nginx.conf //打开文件配置
nginx.conf配置文件讲解
首先我们进入到cd etc/nginx.然后通过ls查看nginx目录的相关内容。在nginx目录下，我们需要关注nginx.conf文件，这个文件是我们的主配置文件，cat打开：
cat nginx.conf 【效果显示在下方分割线后】

[root@iZbp1dssknxftmjczbtpndZ conf.d]# cd /usr/share/nginx/html
[root@iZbp1dssknxftmjczbtpndZ html]# vim stst.html //新建文件
[root@iZbp1dssknxftmjczbtpndZ html]# ls
50x.html     index.html
[root@iZbp1dssknxftmjczbtpndZ html# vim test.html //新建一个html文件保存下来
//i编辑       hello nginx           esc + :wq
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c /etc/nginx/nginx.conf //启动！
//如果不显示一定是服务器规则组的问题  自定义 TCP    目的:1/65535   源:0.0.0.0/0
网址输入：http://47.98.225.105/test.html 
============================================================================
# 运行用户，默认是nginx
user  nginx;
# nginx进程数,一般设置为和cpu核数一样
worker_processes  1;

# 全局错误日志路径
error_log  /var/log/nginx/error.log warn;
# 进程pid路径
pid        /var/run/nginx.pid;
 
events &#123;
# 最大连接数
    worker_connections  1024;
&#125;

# 设置http服务器
http &#123;
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
# 设置日志的格式
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
# 访问日志的路径
    access_log  /var/log/nginx/access.log  main;

# 开启高效传输模式
    sendfile        on;
    #tcp_nopush     on;
# 长连接超时时间，单位是秒
    keepalive_timeout  65;
#传输时是否压缩，压缩的话需要解压，但是传的大小就小了
    #gzip  on;
#加载其他的配置文件，一带多
    include /etc/nginx/conf.d/*.conf;
&#125;
============================================================================
</code></pre>
<h3 id="搭建静态资源服务器"><a href="#搭建静态资源服务器" class="headerlink" title="搭建静态资源服务器"></a>搭建静态资源服务器</h3><h5 id="搭建一个静态文件的Nginx服务"><a href="#搭建一个静态文件的Nginx服务" class="headerlink" title="搭建一个静态文件的Nginx服务"></a>搭建一个静态文件的Nginx服务</h5><ul>
<li>实操演示</li>
<li>配置和网页文件作为教辅提供 [静态网页]</li>
</ul>
<pre><code class="java">//scp传输文件 -r每一个文件夹都传递归 /usr/share/nginx/web/ 上传到这个文件夹
cmd本机框
C:\Users\Pluminary&gt; scp -r /Users/Pluminary/Desktop/静态资源/静态网页/ root@47.98.225.105:/usr/share/nginx/web/

cmd服务器框
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/share/nginx/web/
[root@iZbp1dssknxftmjczbtpndZ web]# pwd //查看现在位置
/usr/share/nginx/web
[root@iZbp1dssknxftmjczbtpndZ web]# ls
css  fonts  images  index.html  js
//修改文件 可以让nginx访问到文件 访问web下面的内容
[root@iZbp1dssknxftmjczbtpndZ web]# vim /etc/nginx/conf.d/default.conf  
//修改location：.../web
===============================================================
location / &#123;
        root   /usr/share/nginx/web;
        index  index.html index.htm;
    &#125;

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html &#123;
        root   /usr/share/nginx/web;
    &#125;
===============================================================
[root@iZbp1dssknxftmjczbtpndZ web]# nginx -t //测试一下是否有问题
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@iZbp1dssknxftmjczbtpndZ web]# nginx -s reload //重启服务
//浏览器访问：http://47.98.225.105/index.html
[root@iZbp1dssknxftmjczbtpndZ web]# cat /etc/nginx/nginx.conf
//进去看到 access_log  /var/log/nginx/access.log  main; 打开它
[root@iZbp1dssknxftmjczbtpndZ web]# cat /var/log/nginx/access.log //打开日志文件
</code></pre>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><ul>
<li><h5 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h5></li>
<li><h5 id="RabbitMQ的安装和启动-Erlang语言"><a href="#RabbitMQ的安装和启动-Erlang语言" class="headerlink" title="RabbitMQ的安装和启动 [Erlang语言]"></a>RabbitMQ的安装和启动 [Erlang语言]</h5></li>
<li><h5 id="RabbitMQ管理后台"><a href="#RabbitMQ管理后台" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h5></li>
<li><h5 id="实战案例演示"><a href="#实战案例演示" class="headerlink" title="实战案例演示"></a>实战案例演示</h5></li>
<li><h5 id="交换机工作模式-fanout、direct、topic、headers"><a href="#交换机工作模式-fanout、direct、topic、headers" class="headerlink" title="交换机工作模式 [fanout、direct、topic、headers]"></a>交换机工作模式 [fanout、direct、topic、headers]</h5></li>
<li><h5 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h5></li>
</ul>
<h3 id="初识RabbitMQ-1"><a href="#初识RabbitMQ-1" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h3><ul>
<li><p>核心思想：<strong>接收并转发消息</strong>。类似于<strong>邮局</strong></p>
</li>
<li><p><strong>producer</strong>：<u>信息生产者</u></p>
</li>
<li><p><strong>queue</strong>：<u>队列</u></p>
</li>
<li><p><strong>consumer</strong>：<u>会从queue中获取消息</u></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ca2883b4e8981a89118a71e0e1590f837b4300de/data/RabbitMQ.jpg"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>什么是消息队列</li>
<li><strong>MQ</strong>(Message Queue)</li>
</ul>
<h5 id="消息队列的性质"><a href="#消息队列的性质" class="headerlink" title="消息队列的性质"></a>消息队列的性质</h5><ul>
<li>业务无关 [不需要考虑上层业务模型]</li>
<li>FIFO [先进先出]</li>
<li>容灾 [对于消息队列可以持久化 断电后也可以保存数据后重新发送]</li>
<li>性能</li>
</ul>
<h5 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h5><ul>
<li>系统<strong>解耦</strong></li>
<li><strong>异步</strong>调用 [我告诉你要做 我可以不等你做完 我再返回 <u>相互不影响</u>]<br>[点外卖 用户发送外卖请求給中间件，随后MQ帮助分发后续流程(扣钱、召唤骑手 计算天气、时间等)]</li>
<li>流量<strong>削峰</strong> [MQ把请求先存在队列中 以合适的速度发送 化解压力]</li>
</ul>
<h3 id="RabbitMQ的特点和核心概念"><a href="#RabbitMQ的特点和核心概念" class="headerlink" title="RabbitMQ的特点和核心概念"></a>RabbitMQ的特点和核心概念</h3><ul>
<li>开源、跨语言</li>
<li>Erlang语言编写 [交换机、通信方面] [数据复制与转发性能好]</li>
<li>应用广泛</li>
<li>社区活跃、API丰富</li>
</ul>
<h5 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h5><ul>
<li>Advanced Message Queuing Protocol 高级消息队列协议</li>
</ul>
<h5 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h5><ul>
<li><strong>Server</strong>：服务</li>
<li><strong>connection</strong>：与Server建立连接</li>
<li><strong>channel</strong>：信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道</li>
<li><strong>message</strong>：消息，由properties和body组成</li>
<li><strong>virtual host</strong>：虚拟主机，顶层隔离。同一个虚拟主机下，不能由重复的交换机和queue</li>
<li><strong>Exchange</strong>：交换机，接收生产者的信息的，然后根据指定的路由器把消息转发到所绑定的队列上</li>
<li><strong>binding</strong>：绑定交换机和队列</li>
<li><strong>routing key</strong>：路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个路由</li>
<li><strong>queue</strong>：队列，消费者只需要监听队列来消费消息，不需要关注消息来自于哪个Exchange</li>
<li>Exchange和Message Queue存在着绑定的关系，一个Exchange可以绑定多个消息队列</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8fc65400c147b4cda128b49a11d646330a5860fc/data/RabiitMQ%E6%B6%88%E6%81%AF%E6%B5%81%E8%BD%AC%E6%96%B9%E5%BC%8F.jpg"></p>
<h3 id="RabbitMQ的安装和启动"><a href="#RabbitMQ的安装和启动" class="headerlink" title="RabbitMQ的安装和启动"></a>RabbitMQ的安装和启动</h3><ul>
<li>安装<strong>Erlang</strong></li>
<li><strong>安装</strong>RabbitMQ</li>
<li><strong>启动</strong>RabbitMQ</li>
</ul>
<h5 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h5><ul>
<li>安装erlang-rpm包，该包经过RabbitMQ官方处理</li>
<li>使用Erlang Solutions源进行安装</li>
<li>使用EPEL(“Extra Packages for Enterprise Linux”)进行安装</li>
</ul>
<pre><code class="java">我们先准备两个安装包：//★★★★别看下面胡咧咧 直接教辅中有erlang和rabbitmq与教材相同★★★★
RabbitMQ： https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.13
Erlang：https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm

注意： 如果说你选的是最新的版本那么你就要选取对应支持的 erlang 的版本才行，具体看下面的连接
https://www.rabbitmq.com/which-erlang.html

这些都准备好之后我们使用 Xptf 软件把这个安装包传输到 linux 端对应文件下（自己建一个文件夹）即可。

安装
第一步：
我们第一步先要对 linux 端进行一个 erlang 的环境配置，所以我们要先解压 erlang 包。
    # rpm -Uvh erlang-solutions-2.0-1.noarch.rpm
    # yum install -y erlang
安装完成后，查看一下版本号，能查到说明就是安装好了
    # erl -v

第二步：
在安装一下
    # yum install -y socat

第三步：
接下来我们就需要进行 RabbitMQ 的安装了

    # rpm -Uvh rabbitmq-server-3.8.33-1.el8.noarch.rpm 
    # yum install rabbitmq-server -y

安装完之后我们来启动测试一下：

    # systemctl start rabbitmq-server
    # systemctl status rebbitmq-server

最后一步：
安装跑起来之后我们设置一下开机自启动

    # systemctl enable rabbitmq-server
    # systemctl stop rabbitmq-server   # 关闭开机自起
=========================================================
可以在这些目录中查找RabbitMQ的配置文件、启动脚本等。另外，RabbitMQ的启动脚本通常会被安装到/usr/sbin或/usr/bin目录下。你可以尝试使用以下命令来查找RabbitMQ的启动脚本位置：

find /usr/sbin /usr/bin -name &#39;rabbitmq*&#39;
=========================================================
</code></pre>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/sbin
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl start rabbitmq-server
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl status rabbitmq-server
● rabbitmq-server.service - RabbitMQ broker
   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)
   Active: active (running) since Mon 2024-04-08 23:24:39 CST; 38min ago
 Main PID: 3570 (beam.smp)
===================================================================================
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl enable rabbitmq-server
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl stop rabbitmq-server   # 关闭开机自起
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_57828911/article/details/131777471?ops_request_misc=%7B%22request_id%22:%22171259388816800186514596%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171259388816800186514596&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-131777471-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=linux%E5%8D%B8%E8%BD%BDrabbitmq&spm=1018.2226.3001.4187">Linux环境如何彻底卸载感干净RabbitMQ_linux卸载rabbitmq-CSDN博客</a></p>
<pre><code class="java">停止RabbitMQ
$rabbitmqctl stop

设置开机启动
$ systemctl enable rabbitmq-server 

启动RabbitMQ
$ systemctl start rabbitmq-server

看看端口有没有起来，查看状态

$ rabbitmqctl status 

要检查RabbitMQ服务器的状态，请运行：

systemctl status rabbitmq-server

开启web管理界面
rabbitmq-plugins enable rabbitmq_management
</code></pre>
<h3 id="RabbitMQ管理后台-1"><a href="#RabbitMQ管理后台-1" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h3><h5 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h5><ul>
<li>启动RabbitMQ：<code>systemctl start rabbitmq-server</code></li>
<li>查看状态：<code>rabbitmqctl status</code></li>
<li>启动管理台</li>
<li>配置admin用户</li>
</ul>
<pre><code class="mysql">[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmq-plugins enable rabbitmq_management
Enabling plugins on node rabbit@iZbp1dssknxftmjczbtpndZ:
rabbitmq_management
The following plugins have been configured:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@iZbp1dssknxftmjczbtpndZ...
Plugin configuration unchanged. ##添加账户
[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmqctl add_user admin password
Adding user &quot;admin&quot; ...            ##设置管理员
[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmqctl set_user_tags admin administrator
Setting tags for user &quot;admin&quot; to [administrator] ...
浏览器进入RabbitMQ管理后台 输入 http://47.98.225.105:15672/
</code></pre>
<h5 id="RabbitMQ管理后台-2"><a href="#RabbitMQ管理后台-2" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h5><ul>
<li>浏览页面</li>
<li>添加用户</li>
<li>创建虚拟主机(Virtual Hosts) &#x3D;&gt; 都有各自的队列、交换机</li>
</ul>
<h3 id="第一个生产者"><a href="#第一个生产者" class="headerlink" title="第一个生产者"></a>第一个生产者</h3><h5 id="实战案例演示-1"><a href="#实战案例演示-1" class="headerlink" title="实战案例演示"></a>实战案例演示</h5><ul>
<li>新建项目</li>
<li>Hello World<br>P(生产者)→hello→C(消费者)</li>
<li>创建一个rabbitmq(Maven)新项目</li>
<li>rabbitmq支持多语言</li>
</ul>
<pre><code class="java">登录上RabbitMQ后台 上面Admin 右面Virtual Hosts 
点表里的 /  下面增加一个admin

pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;rabbitmq&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;20&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;20&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
            &lt;version&gt;5.8.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;
            &lt;version&gt;1.7.29&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">helloworld/send.java
package helloworld;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Hello World的发送类，连接到RabbitMQ服务端，然后发送一条消息后退出
 */
public class send &#123;
    //队列名字
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(QUEUE_NAME,false,false,false,null);
        //发布消息
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + message);
        //关闭连接
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">helloworld/Recv.java
package helloworld;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;
import java.io.IOException;

/**
 * 接收消息，并打印，持续运行
 */
public class Recv &#123;
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws Exception &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        //接收消息并消费 2:是否确认收到(快递签收 自动消息确认) 3：消息收到后进行处理
        channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) &#123;
            //收到信息后会执行的函数
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body)
                    throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot; + message);
            &#125;
        &#125;);
    &#125;
&#125;
=======================================================
//由于是持续接收消息的 若将send.java中改为Hello World2 将会持续打印到控制台
开始接收消息
收到消息：Hello World!
收到消息：Hello World2!
</code></pre>
<h3 id="根据消息内容做处理"><a href="#根据消息内容做处理" class="headerlink" title="根据消息内容做处理"></a>根据消息内容做处理</h3><h5 id="多个消费者分担压力"><a href="#多个消费者分担压力" class="headerlink" title="多个消费者分担压力"></a>多个消费者分担压力</h5><p><strong>RabbitMQ后台</strong><a target="_blank" rel="noopener" href="http://47.98.225.105:15672/">http://47.98.225.105:15672/</a></p>
<h6 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h6><pre><code class="java">workqueues/NewTask.java
package workqueues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 生产者：生产批量消息
 */
public class NewTask &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME,true,false,false,null);
        for (int i = 0; i &lt; 10; i++) &#123;
            String message = i + &quot;...&quot;;
            channel.basicPublish(&quot;&quot;,TAKS_QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;发送了消息：&quot; + message);
        &#125;
        //关闭连接
        channel.close();
        connection.close();
    &#125;
&#125;
=============================================================================================
发送了消息：0...
发送了消息：1...
发送了消息：2...
发送了消息：3...
发送了消息：4...
发送了消息：5...
发送了消息：6...
发送了消息：7...
发送了消息：8...
发送了消息：9...
</code></pre>
<pre><code class="java">workqueues/Worker.java
package workqueues;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 消费者，接收前面的批量消息
 */
public class Worker &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME, true, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        channel.basicConsume(TAKS_QUEUE_NAME, true, new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到了消息：&quot; + message);
                try&#123;
                    doWork(message);
                &#125;finally &#123;
                    System.out.println(&quot;完成消息处理&quot;);
                &#125;
            &#125;
        &#125;);
    &#125;

    private static void doWork(String task) &#123;
        //有点延迟1秒
        char[] chars = task.toCharArray();
        for (char ch : chars) &#123;
            if (ch == &#39;.&#39;) &#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
==========================================================================================
收到了消息：0...
完成消息处理
收到了消息：1...
完成消息处理
收到了消息：2...
完成消息处理
收到了消息：3...
完成消息处理
收到了消息：4...
完成消息处理
收到了消息：5...
完成消息处理
收到了消息：6...
完成消息处理
收到了消息：7...
完成消息处理
收到了消息：8...
完成消息处理
收到了消息：9...
完成消息处理
</code></pre>
<h5 id="并行-多个消费者平均压力！！！"><a href="#并行-多个消费者平均压力！！！" class="headerlink" title="并行 多个消费者平均压力！！！"></a>并行 多个消费者平均压力！！！</h5><h6 id="公平派遣-因为奇数偶数压力不同-消息确认-【以工作量的程度去分任务】"><a href="#公平派遣-因为奇数偶数压力不同-消息确认-【以工作量的程度去分任务】" class="headerlink" title="公平派遣[因为奇数偶数压力不同] + 消息确认 【以工作量的程度去分任务】"></a>公平派遣[因为奇数偶数压力不同] + 消息确认 【<u>以工作量的程度去分任务</u>】</h6><pre><code class="java">//在Worker消费方打开并行消费 Run/Debug Configurations → Modify options蓝字 → Allow multiple instances             此时两个woker开始配合平均压力 一起工作
workqueues/Worker.java
package workqueues;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 消费者，接收前面的批量消息
 */
public class Worker &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME, true, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        channel.basicQos(1); //最希望处理的数量 处理完之前不会接收下一个任务
        channel.basicConsume(TAKS_QUEUE_NAME, false, new DefaultConsumer(channel) &#123; //关掉自动接收 要手动确认false
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到了消息：&quot; + message);
                try&#123;
                    doWork(message);
                &#125;finally &#123;
                    System.out.println(&quot;完成消息处理&quot;);
                    channel.basicAck(envelope.getDeliveryTag(), false); //false 不同时一起确认 手动确认消息
                &#125;
            &#125;
        &#125;);
    &#125;

    private static void doWork(String task) &#123;
        //有点延迟1秒
        char[] chars = task.toCharArray();
        for (char ch : chars) &#123;
            if (ch == &#39;.&#39;) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
=======================================================================================
开始接收消息
收到了消息：1
消息处理完成
收到了消息：2...
消息处理完成
......
</code></pre>
<h3 id="交换机工作模式"><a href="#交换机工作模式" class="headerlink" title="交换机工作模式"></a>交换机工作模式</h3><ul>
<li><strong>fanout</strong>：广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的</li>
<li><strong>direct</strong>：根据RoutingKey匹配消息路由到指定队列</li>
<li><strong>topic</strong>：生产者指定RoutingKey消息根据消费端指定的队列通过模糊匹配的方式进行相应转发</li>
<li><strong>headers</strong>：根据发送消息内容中的headers属性来匹配</li>
</ul>
<h5 id="fanout模式"><a href="#fanout模式" class="headerlink" title="fanout模式"></a>fanout模式</h5><h6 id="广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的-所有消息无差别发送"><a href="#广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的-所有消息无差别发送" class="headerlink" title="广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的 [所有消息无差别发送]"></a>广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的 [所有消息无差别发送]</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/3aa53b6e78e1fd67145c5d2acf905c22eee0b44a/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-fanout.png"></p>
<pre><code class="java">fanout/EmitLog.java【生产者】
package fanout;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 发送日志信息
 */
public class EmitLog &#123;
    //创建交换机
    private static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        String message = &quot;info: Hello World！&quot;;
        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + message);
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">fanout/ReceiveLogs.java【消费者】
package fanout;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 描述：接收日志消息 有多个接收同样的消息
 */
public class ReceiveLogs &#123;
    private static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        //非持久会自动删除的队列 在同一个类中多次启动 每一次队列名字都不一样
        String queueName = channel.queueDeclare().getQueue();
        //交换机和队列的绑定
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);
        System.out.println(&quot;开始接收消息&quot;);
        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
</code></pre>
<h5 id="direct模式"><a href="#direct模式" class="headerlink" title="direct模式"></a>direct模式</h5><h6 id="根据RoutingKey匹配消息路由到指定队列-消费者接收消息不一致"><a href="#根据RoutingKey匹配消息路由到指定队列-消费者接收消息不一致" class="headerlink" title="根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]"></a>根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/df64342f867398846ad29a0cb944a8490cd247b0/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-direct.jpg"></p>
<pre><code class="java">direct/ReceiveLogsDirect1.java
package direct;

import com.rabbitmq.client.*;

import java.io.IOException;

/**
 * 接收3个等级的日志
 */
public class ReceiveLogsDirect1 &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        //生成一个随机的临时的queue
        String queueName = channel.queueDeclare().getQueue();

        //一个交换机同时绑定三个queue
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;error&quot;);

        System.out.println(&quot; 开始接收消息&quot;);

        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
=============================================================================
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
</code></pre>
<pre><code class="java">direct/ReceiveLogsDirect2.java
package direct;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;
import java.io.IOException;

/**
 * 接收1个等级的日志
 */
public class ReceiveLogsDirect2 &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        //生成一个随机的临时的queue
        String queueName = channel.queueDeclare().getQueue();

        //一个交换机同时绑定两个queue，比刚第一个Receiver少接收了一个error等级
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
=============================================================================
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
</code></pre>
<pre><code class="java">direct/EmitLogDirect.java
package direct;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class EmitLogDirect &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机 DIRECT
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        String message = &quot;Hello World！&quot;;
        //发送第一个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;info&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为info,消息内容：&quot; + message);

        //发送第二个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;warning&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为warning,消息内容：&quot; + message);

        //发送第三个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;error&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为error,消息内容：&quot; + message);
        channel.close();
        connection.close();
    &#125;
&#125;
=============================================================================
发送了消息：等级为info,消息内容：Hello World！
发送了消息：等级为warning,消息内容：Hello World！
发送了消息：等级为error,消息内容：Hello World！
</code></pre>
<h5 id="topic模式"><a href="#topic模式" class="headerlink" title="topic模式"></a><span style = "color:red"><strong>topic模式</strong></span></h5><h6 id="比如消息严重性怎么样、只想记录error模块的用户信息"><a href="#比如消息严重性怎么样、只想记录error模块的用户信息" class="headerlink" title="比如消息严重性怎么样、只想记录error模块的用户信息"></a>比如消息严重性怎么样、只想记录error模块的用户信息</h6><ul>
<li>***** 可以替代一个单词</li>
<li><strong>#</strong> 可以替代零个或多个单词</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76b7e6d6ebbac01f8f73850149fefbf50ca51712/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-topic%E7%94%9F%E4%BA%A7%E8%80%85.jpg"></p>
<pre><code class="java">【发送者/生产者】
topic/EmitLogTopic.java
package topic;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

/**
 * topic模式交换机，发送消息
 */
public class EmitLogTopic &#123;

    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) &#123;
        Connection connection = null;
        Channel channel = null;
        try &#123;
            ConnectionFactory factory = new ConnectionFactory();
            factory.setHost(&quot;47.98.225.105&quot;);
            factory.setUsername(&quot;admin&quot;);
            factory.setPassword(&quot;password&quot;);

            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);

            String message = &quot;Animal WorldroutingKey&quot;;

            String[] routingKeys = new String[9];
            routingKeys[0] = &quot;quick.orange.rabbit&quot;;
            routingKeys[1] = &quot;lazy.orange.elephant&quot;;
            routingKeys[2] = &quot;quick.orange.fox&quot;;
            routingKeys[3] = &quot;lazy.brown.fox&quot;;
            routingKeys[4] = &quot;lazy.pink.rabbit&quot;;
            routingKeys[5] = &quot;quick.brown.fox&quot;;
            routingKeys[6] = &quot;orange&quot;;
            routingKeys[7] = &quot;quick.orange.male.rabbit&quot;;
            routingKeys[8] = &quot;lazy.orange.male.rabbit&quot;;
            for (int i = 0; i &lt; routingKeys.length; i++) &#123;
                channel.basicPublish(EXCHANGE_NAME, routingKeys[i], null,
                        message.getBytes(&quot;UTF-8&quot;));
                System.out.println(&quot;发送了：&quot; + message + &quot;:&quot; + routingKeys[i]);
            &#125;


        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (connection != null) &#123;
                try &#123;
                    connection.close();
                &#125; catch (Exception ignore) &#123;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
==================================================================================
发送了：Animal WorldroutingKey:quick.orange.rabbit
发送了：Animal WorldroutingKey:lazy.orange.elephant
发送了：Animal WorldroutingKey:quick.orange.fox
发送了：Animal WorldroutingKey:lazy.brown.fox
发送了：Animal WorldroutingKey:lazy.pink.rabbit
发送了：Animal WorldroutingKey:quick.brown.fox
发送了：Animal WorldroutingKey:orange
发送了：Animal WorldroutingKey:quick.orange.male.rabbit
发送了：Animal WorldroutingKey:lazy.orange.male.rabbit
</code></pre>
<pre><code class="java">【接收者/消费者Ⅰ(对&quot;*.orange.*&quot; 数据感兴趣)】
package topic;

import com.rabbitmq.client.*;

import java.io.IOException;
/**
 * 特定路由键
 */
public class ReceiveLogsTopic1 &#123;
    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        String queueName = channel.queueDeclare().getQueue();

        //指定bindingKey 最重要的一步！
        String bindingKey = &quot;*.orange.*&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer = new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                    AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(
                        &quot; 接收消息： &quot; + message + &quot;:&quot; + envelope.getRoutingKey());
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
==================================================================================
开始接收消息
 接收消息： Animal WorldroutingKey:quick.orange.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.elephant
 接收消息： Animal WorldroutingKey:quick.orange.fox
</code></pre>
<pre><code class="java">【接收者/消费者Ⅱ(对&quot;*.*.rabbit&quot; 和 &quot;lazy.#&quot; 数据感兴趣)】
package topic;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;

import java.io.IOException;
/**
 * 特定路由键
 */
public class ReceiveLogsTopic2 &#123;

    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        String queueName = channel.queueDeclare().getQueue();

        //指定bindingKey
        String bindingKey1 = &quot;*.*.rabbit&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey1);
        String bindingKey2 = &quot;lazy.#&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey2);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer = new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                    AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(
                        &quot; 接收消息： &quot; + message + &quot;:&quot; + envelope.getRoutingKey());
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
==================================================================================
开始接收消息
 接收消息： Animal WorldroutingKey:quick.orange.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.elephant
 接收消息： Animal WorldroutingKey:lazy.brown.fox
 接收消息： Animal WorldroutingKey:lazy.pink.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.male.rabbit
</code></pre>
<ul>
<li><h6 id="headers：根据发送消息内容中的headers属性来匹配"><a href="#headers：根据发送消息内容中的headers属性来匹配" class="headerlink" title="headers：根据发送消息内容中的headers属性来匹配"></a>headers：根据发送消息内容中的headers属性来匹配</h6></li>
</ul>
<h3 id="Spring-Boot整合RabbitMQ"><a href="#Spring-Boot整合RabbitMQ" class="headerlink" title="Spring Boot整合RabbitMQ"></a>Spring Boot整合RabbitMQ</h3><ul>
<li><h6 id="实操代码演示"><a href="#实操代码演示" class="headerlink" title="实操代码演示"></a>实操代码演示</h6></li>
</ul>
<blockquote>
<p>创建两个Springboot项目<br>spring-boot-rabbitmq-consumer 和 spring-boot-rabbitmq-consumer<br>在application.properties中设置 如果是本机用户名和密码都是guest<br>spring.rabbitmq.username&#x3D;guest</p>
</blockquote>
<h6 id="项目：spring-boot-rabbitmq-producer-消息发送者-x2F-生产者"><a href="#项目：spring-boot-rabbitmq-producer-消息发送者-x2F-生产者" class="headerlink" title="项目：spring-boot-rabbitmq-producer [消息发送者&#x2F;生产者]"></a>项目：spring-boot-rabbitmq-producer [消息发送者&#x2F;生产者]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-rabbitmq-consumer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-rabbitmq-consumer&lt;/name&gt;
    &lt;description&gt;spring-boot-rabbitmq-consumer&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties
spring.application.name=spring-boot-rabbitmq-producer
server.port=8080
spring.rabbitmq.addresses=127.0.0.1:5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000
</code></pre>
<pre><code class="java">com/imooc/springbootrabbitmqproducer/MsgSender.java
package com.imooc.springbootrabbitmqproducer;

import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * 发送消息
 */
//@Component让springboot发现
@Component
public class MsgSender &#123;
    @Autowired
    private AmqpTemplate rabbitmqTemplate;
    public void send1()&#123;
        String message = &quot;This is message 1, routing key is dog.red&quot;;
        System.out.println(&quot;发送了：&quot; + message);
        //指定交换机的名字  routing key is dog.red  消息内容
        this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;,&quot;dog.red&quot;,message);
    &#125;
    public void send2()&#123;
        String message = &quot;This is message 2, routing key is dog.black&quot;;
        System.out.println(&quot;发送了：&quot; + message);
        //指定交换机的名字  routing key is dog.red  消息内容
        this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;,&quot;dog.black&quot;,message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootrabbitmqproducer/TopicRabbitConfig.java
package com.imooc.springbootrabbitmqproducer;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


/**
 * rabbitmq配置类
 */
@Configuration
public class TopicRabbitConfig &#123;
    @Bean
    public Queue queue1()&#123;
        return new Queue(&quot;queue1&quot;);
    &#125;
    @Bean
    public Queue queue2()&#123;
        return new Queue(&quot;queue2&quot;);
    &#125;
    //用一个Bean定义交换机
    @Bean
    TopicExchange exchange()&#123;
        return new TopicExchange(&quot;bootExchange&quot;);
    &#125;

    //有了Q1 Q2后去指定一个topic交换机
    //绑定到交换机上
    @Bean
    Binding bingdingExchangeMessage1(Queue queue1, TopicExchange exchange)&#123;
        //to绑定到哪个交换机 with指定routingKey
        return BindingBuilder.bind(queue1()).to(exchange).with(&quot;dog.red&quot;);
    &#125;
    @Bean
    Binding bingdingExchangeMessage2(Queue queue2, TopicExchange exchange)&#123;
        //to绑定到哪个交换机 with指定routingKey
        return BindingBuilder.bind(queue2()).to(exchange).with(&quot;dog.#&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">用test的测试类
com/imooc/springbootrabbitmqproducer/SpringBootRabbitmqProducerApplicationTests.java
package com.imooc.springbootrabbitmqproducer;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SpringBootRabbitmqProducerApplicationTests &#123;

    @Autowired
    MsgSender msgSender;

    @Test
    public void send1()&#123;
        msgSender.send1();
    &#125;
    @Test
    public void send2()&#123;
        msgSender.send2();
    &#125;
&#125;
</code></pre>
<h6 id="项目：spring-boot-rabbitmq-consumer-消息接收者-x2F-消费者"><a href="#项目：spring-boot-rabbitmq-consumer-消息接收者-x2F-消费者" class="headerlink" title="项目：spring-boot-rabbitmq-consumer [消息接收者&#x2F;消费者]"></a>项目：spring-boot-rabbitmq-consumer [消息接收者&#x2F;消费者]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-rabbitmq-consumer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-rabbitmq-consumer&lt;/name&gt;
    &lt;description&gt;spring-boot-rabbitmq-consumer&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties
spring.application.name=spring-boot-rabbitmq-consumer
server.port=8081
spring.rabbitmq.addresses=127.0.0.1:15672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000
</code></pre>
<pre><code class="java">Receiver1.java
package com.imooc.springbootrabbitmqconsumer;

import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 消费者1
 */
@Component
@RabbitListener(queues = &quot;queue1&quot;)
public class Receiver1 &#123;
    @RabbitHandler //收到这个消息后怎么处理
    public void process(String message)&#123;
        System.out.println(&quot;Receiver1：&quot; + message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Receiver2.java
package com.imooc.springbootrabbitmqconsumer;

import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 消费者2
 */
@Component
@RabbitListener(queues = &quot;queue2&quot;)
public class Receiver2 &#123;
    @RabbitHandler //收到这个消息后怎么处理
    public void process(String message)&#123;
        System.out.println(&quot;Receiver2：&quot; + message);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>先启动消费者 然后再启动生产者test中的测试<br>就可以发现<br>send1() → 发送了：This is message 1, routing key is dog.red<br>send2() → 发送了：This is message 2, routing key is dog.black</p>
</blockquote>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/04/04/后端/多线程与分布式/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/03/28/面试/Java面试/">
        <h2>
            Java面试
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/3/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Java面试-——-准备"><a href="#Java面试-——-准备" class="headerlink" title="Java面试 —— 准备"></a>Java面试 —— 准备</h1><h3 id="給职场新人的建议"><a href="#給职场新人的建议" class="headerlink" title="給职场新人的建议"></a>給职场新人的建议</h3><ul>
<li>不要有为老板工作的心态</li>
<li>永远不要敷衍工作</li>
<li>事情做完马上汇报</li>
<li>管理好自己的情绪，做一个可爱的人</li>
<li>接受任务有确认机制</li>
<li>注意工作汇报方式</li>
<li>注重细节</li>
<li>提建议要有数据支撑</li>
<li>給主管选择题 而不是判断题 </li>
<li>要提升自己的价值 [人脉网]</li>
<li>认真对待工作汇报3</li>
</ul>
<h3 id="介绍面试环节中常见问题"><a href="#介绍面试环节中常见问题" class="headerlink" title="介绍面试环节中常见问题"></a>介绍面试环节中常见问题</h3><h5 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h5><ul>
<li><h6 id="我是誰"><a href="#我是誰" class="headerlink" title="我是誰"></a>我是誰</h6></li>
<li><h6 id="我做过什么"><a href="#我做过什么" class="headerlink" title="我做过什么"></a>我做过什么</h6></li>
<li><h6 id="我的优势在哪里"><a href="#我的优势在哪里" class="headerlink" title="我的优势在哪里"></a>我的优势在哪里</h6></li>
</ul>
<blockquote>
<p>张总你好，我叫潘春尧，<strong>今年23岁</strong>，来自河北唐山人，来<strong>应聘贵公司的Java软件工程师职位</strong>，26年毕业于南昌工学院<strong>软件工程专业</strong>，从事Java开发有2年的工作时间了，我<strong>对编程有着浓厚的兴趣</strong>，擅长基于HTML5的互联网应用开发，擅长使用Mysql数据库对大数据量方面的调优有经验，同时具备完整的项目开发能力，具备一定的分布式架构经验，之前<strong>我做过两个项目</strong>，都是独立完成的，<strong>第一个</strong>是XX 在2024年开发，这是一个电商网站，已经运用了一年的时间，我负责底层的架构搭建与前后端开发，技术方面采用了XXXX。架构方面底层使用了XXX，我负责的模块设计XXX，这些都是由我完整开发的，而<strong>第二个</strong>项目是由我开发的xxx，这是一个xxx平台，基于阿里云搭建，技术方面与上一个相似，工作原因产品需要增加XXX，我负责的网站模块主要负责xxx，这也是由我负责开发的，以上是我的个人介绍，有不足的请您多保函。</p>
</blockquote>
<h5 id="现场面对面-要面试官知道我有闪光的价值"><a href="#现场面对面-要面试官知道我有闪光的价值" class="headerlink" title="现场面对面  [要面试官知道我有闪光的价值]"></a>现场面对面  [要面试官知道我有闪光的价值]</h5><ul>
<li><strong>容貌要求</strong> [注意形象(<u>刮胡子,短发,指甲</u>)]</li>
<li><strong>着装要求</strong> [品牌+面料+皮鞋(商务休闲)]</li>
<li><strong>面试礼仪</strong> [提前15分钟到达面试场地填写表格、敬语(您好,感谢,再见)、善意的微笑] [和前台了解面试官的称呼和职位 主动握手 张总… ] [跟着面试官进去后 注意关门  进去前注意敲门] [沟通时眼神不要游离] [提交简历调转180°双手呈递] [不要抖腿翘腿] [手放腿上 十指交叉放桌子上 不许靠着椅子靠背]</li>
<li><strong>一对多面试</strong> [一男一女   <strong>男:</strong> 技术主管[考察技术能力]  <strong>女:</strong> HR[根据动作分析本人能力]] [面试紧张的时候要降低语速]</li>
</ul>
<h5 id="面试必知必会"><a href="#面试必知必会" class="headerlink" title="面试必知必会"></a>面试必知必会</h5><ul>
<li><h6 id="谈谈你的职业规划-对未来职业有清晰的规划"><a href="#谈谈你的职业规划-对未来职业有清晰的规划" class="headerlink" title="谈谈你的职业规划 [对未来职业有清晰的规划]"></a>谈谈你的职业规划 [对未来职业有清晰的规划]</h6></li>
</ul>
<blockquote>
<p>我从小对软件技术有着很浓厚的兴趣，在未来我五年内我希望从事于与技术相关的岗位，我给自己定位了一个小目标，在五年的时间内我希望拿下系统架构师的认证，同时在分布式、微服务的领域有自己独道的见识。希望在未来的一段时间里公司能给我提供成长的机会。</p>
</blockquote>
<ul>
<li><h6 id="与同时遇到正面冲突，你会怎么办"><a href="#与同时遇到正面冲突，你会怎么办" class="headerlink" title="与同时遇到正面冲突，你会怎么办"></a>与同时遇到正面冲突，你会怎么办</h6></li>
</ul>
<blockquote>
<p>[不诋毁任何人 不传达任何负面情绪 以大局为重]<br>我很少与别人产生正面的冲突，面对别人对我个人的职责批评，我通常先会反思我是不是真的做错了，如果是我会虚心接受，尽快改正。如果是别人对我无端的诽谤，在公共场合也会保持沉默，我会在私下跟他心平气和的沟通看看之间是不是有什么误会。如果是在工作中就某些问题产生了分歧。在会议时直接打开天窗说亮话，阐述自己的观点，这种是典型的对事不对人，这也是点到为止，如果双方意见僵持不下，这可能需要项目经理在中间做出定夺，他看到的问题可能比我们的更加全面而且更有建设性，总之我处事的原则是对事不对人，做事必须认真，做人还是要谦虚一些</p>
</blockquote>
<ul>
<li><h6 id="你生活中最重要的是什么"><a href="#你生活中最重要的是什么" class="headerlink" title="你生活中最重要的是什么"></a>你生活中最重要的是什么</h6></li>
</ul>
<blockquote>
<p>[考察你对待工作 生活 家庭是什么态度] [<strong>强调以事业为重</strong>]<br>我一个人来到XX打拼，目前是单身，对于我现在而言，事业就是我的全部，我会珍惜每一天，让自己尽快的成长起来</p>
</blockquote>
<ul>
<li><h6 id="这份工作你能遇见哪些问题"><a href="#这份工作你能遇见哪些问题" class="headerlink" title="这份工作你能遇见哪些问题"></a>这份工作你能遇见哪些问题</h6></li>
</ul>
<blockquote>
<p>[不能太过实在 避重就轻 强调自己的特性]<br>我对咱们公司的业务不太了解，经验很少，进入公司以后我会听取领导的指示和要求，尽快的熟悉公司的业务和技能，并且制定一份近期的工作计划并报告給领导批准，最后按照计划展开工作，其实针对这个问题，明眼人都看得出来，都说了一堆套话，废话，但是对于面试官来说，你正面的回答了这些问题。而这些问题肯定是现实中存在的，这样既无伤大雅又巧妙的表达了自己对这份工作的期望</p>
</blockquote>
<ul>
<li><h6 id="你希望与什么样的同事或上级公事"><a href="#你希望与什么样的同事或上级公事" class="headerlink" title="你希望与什么样的同事或上级公事"></a>你希望与什么样的同事或上级公事</h6></li>
</ul>
<blockquote>
<p>[考察情商]<br>作为刚步入社会的新人，我应该要求自己多熟悉工作环境适应环境，而不是对环境提出要求，对于我的工作只要能发挥我的专长就可以了，如果工作中有做的不对的地方还请领导多批评指正</p>
</blockquote>
<ul>
<li><h6 id="你将如何开展工作"><a href="#你将如何开展工作" class="headerlink" title="你将如何开展工作"></a>你将如何开展工作</h6></li>
</ul>
<blockquote>
<p>[面试通过几率已经很大了]<br>每天我会提高工作效率，完成公司交付的工作任务，任务未完成绝不下班，根据领导的指示和工作安排制定好工作计划，提前预备并按照计划完成，多请示领导及时汇报，如果有遇到不明白的地方要向前辈们请教，抓住缝隙时间多学习多提升，尽快的提高自己的专业能力与业务水平</p>
</blockquote>
<ul>
<li><h6 id="你有想过创业吗"><a href="#你有想过创业吗" class="headerlink" title="你有想过创业吗"></a>你有想过创业吗</h6></li>
</ul>
<blockquote>
<p>[面试官喜欢有冲劲的小伙子 给出明确的时间规划 不要说我是来公司学习的]<br>我当然有想过创业，但我觉得不是现在，我计划在30岁前后选择创业，软件行业需要大量的技术积累才能有竞争力，同时呢创业对我来说也需要很多的资金，我是一名刚走出校园的新人，在这两方面都不成熟，所以在未来的5年时间内，我会努力的工作，在经验和资金方面做好准备，同时之所以来贵公司，是因为贵公司在XXX行业是一个知名的企业，我想在为公司创造价值的同时，也能进一步的掌握咱们行业最新的动向，希望您能给我一次证明自己的机会，我肯定不会让公司失望的。</p>
</blockquote>
<ul>
<li><h6 id="你还应聘了哪些公司"><a href="#你还应聘了哪些公司" class="headerlink" title="你还应聘了哪些公司"></a>你还应聘了哪些公司</h6></li>
</ul>
<blockquote>
<p>[千万不能说海投 也不能说hr打了电话才来 最好不要跨行业]<br>做一些准备了</p>
</blockquote>
<ul>
<li><h6 id="为什么你的学历是专科"><a href="#为什么你的学历是专科" class="headerlink" title="为什么你的学历是专科"></a>为什么你的学历是专科</h6></li>
</ul>
<blockquote>
<p>[很难回答 送命题 学历非常重要的 话术把劣势转换优势]<br>实话实说上高中的时候我并不是一个好学生，在那时候爱玩电脑，确实也耽误了不少学业。但我认为学历的高低并不代表能力的好坏，在我上了专科以后我更加意识到因为学历比别人落后，自己就更需要努力了，从小对编程感兴趣，上了大学后就更有时间朝着自己喜欢的领域努力。在大学几年的时间里面我没有醉生梦死，自己呢也连续学习了XXX技术内容，我知道有朝一日，这些知识一定能给我带来用处，我一定能成为所向往的软件工程师，我能用实际行动来证明专科不比本科差</p>
</blockquote>
<ul>
<li><h6 id="谈谈你对加班的看法"><a href="#谈谈你对加班的看法" class="headerlink" title="谈谈你对加班的看法"></a>谈谈你对加班的看法</h6></li>
</ul>
<blockquote>
<p>[测试你是否能为公司奉献 要强调上班提高效率 强调加班并不是我的工作效率低下]<br>上班时间我会提高效率，做到当日事当日毕，但是如果当天的事没有按时完成，我会义不容辞的加班，现在我是单身，没有家庭的负担，可以全身心的工作</p>
</blockquote>
<ul>
<li><h6 id="你的薪资的要求"><a href="#你的薪资的要求" class="headerlink" title="你的薪资的要求"></a>你的薪资的要求</h6></li>
</ul>
<blockquote>
<p>[提前有明确主张 自己能赚多少钱 给出hr谈薪资的余地期待8k 可以报价8.5k 千万不要说区间6-8k]<br>我期望的薪资是8.5k，每一个公司都有自己的薪资结构，咱们公司是xxx行业中是非常有实力的企业，相对于薪资来说我更看重技术和行业本身，如果您觉得薪资水平超出了公司的预期的话，这个咱们可以谈</p>
</blockquote>
<ul>
<li><h6 id="谈谈你对跳槽的看法"><a href="#谈谈你对跳槽的看法" class="headerlink" title="谈谈你对跳槽的看法"></a>谈谈你对跳槽的看法</h6></li>
</ul>
<blockquote>
<p>[千万不要说负面话语 也不能说工资太低、福利太差、没有晋升空间]<br>我这个人稳定性很好，本身反对频繁跳槽，但是有一种情况我会选择跳槽，就是公司的发展对于我的事业规划不符，我之前在进入xxx公司的时候，公司主要从事金融行业的项目开发，后来该行业金融不理想改作了电信行业了，当我的长期规划是想成为长期的金融软件工程师与架构师，如果遇到这种情况我会好不容易的选择离开。</p>
</blockquote>
<h1 id="Java面试——Java基础面试技巧"><a href="#Java面试——Java基础面试技巧" class="headerlink" title="Java面试——Java基础面试技巧"></a>Java面试——Java基础面试技巧</h1><h3 id="JDK、JRE、JVM有什么区别"><a href="#JDK、JRE、JVM有什么区别" class="headerlink" title="JDK、JRE、JVM有什么区别"></a>JDK、JRE、JVM有什么区别</h3><ul>
<li><strong>JDK：</strong>Java Development Kit 针对Java程序员的产品</li>
<li><strong>JRE：</strong>Java Runtime Environment是运行Java的环境集合</li>
<li><strong>JVM</strong>：Java虚拟机用于运行Java字节码文件[class]，跨平台的核心。通过JVM隐藏了操作系统最底层的API，对于我们java工程师只需要面对jvm层面进行开发，再转移到其他就可以了</li>
</ul>
<h5 id="为什么可以跨平台？"><a href="#为什么可以跨平台？" class="headerlink" title="为什么可以跨平台？"></a>为什么可以跨平台？</h5><p>因为JVM可以跨平台，JVM只认识<strong>字节码</strong>，能够解释到系统的API调用，对于不同的系统有不同的JVM实现。Windows和Linux有不同的JVM实现，但是编成字节码后都是一样的。</p>
<h3 id="常用数字类型的区别"><a href="#常用数字类型的区别" class="headerlink" title="常用数字类型的区别"></a>常用数字类型的区别</h3><table>
<thead>
<tr>
<th align="center">名次</th>
<th align="center">取值范围</th>
<th align="center">存储空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节(byte)</td>
<td align="center">-$2^7$ ~ $2^7$-1<br />-128 ~ 127</td>
<td align="center">1个字节</td>
</tr>
<tr>
<td align="center">短整数(short)</td>
<td align="center">-$2^{15}$ ~ $2^{15}$-1 <br />-32768 ~ 32767</td>
<td align="center">2个字节</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>整数(int)</strong></span></td>
<td align="center"><span style = "color:red"> -$2^{31}$ ~ $2^{31}$-1<br />-2147483648 ~ 2147483647</span></td>
<td align="center"><span style = "color:red">4个字节</span></td>
</tr>
<tr>
<td align="center">长整数(long)</td>
<td align="center">-$2^{63}$ ~ $2^{63}$-1</td>
<td align="center">8个字节</td>
</tr>
<tr>
<td align="center">单精度(float)</td>
<td align="center">$2^{-149}$ ~ $2^{128}$-1</td>
<td align="center">4个字节</td>
</tr>
<tr>
<td align="center">双精度(double)</td>
<td align="center">$2^{-1074}$ ~ $2^{1024}$-1</td>
<td align="center">8个字节</td>
</tr>
</tbody></table>
<h3 id="Float在JVM的表达方式及使用陷阱"><a href="#Float在JVM的表达方式及使用陷阱" class="headerlink" title="Float在JVM的表达方式及使用陷阱"></a>Float在JVM的表达方式及使用陷阱</h3><pre><code class="java">float d1 = 423432423f;
float d2 = d1 + 1;
if(d1 == d2)&#123;
    System.out.println(&quot;d1==d2&quot;);
&#125;else&#123;
    System.out.println(&quot;d1!=d2&quot;);
&#125;

答案：d1 == d2
对于单精度浮点型float d1在内存中是采用科学计数法表示
表达为：4.2343242E7 保留小数点后七位 [如果更高精度的用double]
d1是八位数
无论是d1还是d2不考虑最后一位
d2用科学计数法表示同样为4.2343242E7
因此 d1 == d2

银行业务数值精确计算要用BigDecimal类进行加减乘除的计算
</code></pre>
<h3 id="随机数的使用"><a href="#随机数的使用" class="headerlink" title="随机数的使用"></a>随机数的使用</h3><pre><code class="java">编程题：随机生成30~100之间的整数
==========================================================
package com.example.demo12;

import java.util.Random;

public class RandomSample &#123;
    public Integer randomInt1()&#123;
        int min = 30;
        int max = 100;
        //生成正整数范围0-70的随机数 =&gt; 30~100
        int result = new Random().nextInt(max - min) + min;
        return  result;
    &#125;
    public Integer randomInt2()&#123;
        int min = 30;
        int max = 100;
        int result = (int)(Math.random() * (max-min)) + min;
        return result;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(new RandomSample().randomInt1());
        System.out.println(new RandomSample().randomInt2());
    &#125;
&#125;
</code></pre>
<pre><code class="java">编程题：列出1-1000的质数[大于1的情况下 只能被1和自身整除的数]
==========================================================
package com.example.demo12;

public class PrimeNumber &#123;
    public static void main(String[] args) &#123;
        for (int i = 2; i &lt;= 1000; i++)&#123;
            boolean flag = true;
            for (int j = 2; j &lt; i; j++)&#123;
                if(i % j == 0)&#123;
                    flag = false;
                    break;
                &#125;
            &#125;
            if (flag)&#123;
                System.out.println(i);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="面向对象的三大特征是什么"><a href="#面向对象的三大特征是什么" class="headerlink" title="面向对象的三大特征是什么"></a>面向对象的三大特征是什么</h3><ul>
<li><p><strong>封装</strong><br>对同一类事务的特征和功能包装到一起，只对外暴露需要调用接口而已<br>[我想让你看到的你能看到 不想让你看到的不能看到]。作用：对接口进行实现的过程中每一个接口的实现类对接口进行了实现，但是在调用的时候通常是面对接口的，对于使用者来说只需要知道接口对应的哪些方法做什么用的就可以了，对内部的什么是不需要理解的。接口是体现封装的常见方法<br><strong>封装的好处</strong>：</p>
<ol>
<li>实现专业的分工</li>
<li>减少代码耦合</li>
<li>可以自由修改类的内部结构</li>
</ol>
</li>
<li><p><strong>继承</strong><br>是Java中面向对象最显著的特征，继承是从已有的类中派生出新的类，新的类能够吸收原有属性的属性和行为并扩展新的类，<u>Java中类是不支持多继承的，接口可以，一个接口可以继承多个其他接口</u> 父类是子类的抽象化，子类是父类的具体化。<br><strong>接口与抽象类有那些异同？</strong></p>
<table>
<thead>
<tr>
<th align="center">相同点</th>
<th align="center">不同点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">都是上层的抽象</td>
<td align="center">抽象类可包含方法的实现<br />接口则只能包含方法的声明</td>
</tr>
<tr>
<td align="center">不能被实例化 [不可new]</td>
<td align="center">继承类只能继承一个抽象类<br />实现类可以实现多个接口</td>
</tr>
<tr>
<td align="center">都可以包含抽象发发</td>
<td align="center">抽象级别：接口&gt;抽象类&gt;实现类</td>
</tr>
</tbody></table>
<p><span style = "color : red"><strong>作用不同</strong>：接口用于约束程序行为。继承则用于代码复用</span><br>注意：JDK8以上版本，接口可以有default方法，包含方法实现</p>
</li>
<li><p><strong>多态</strong><br>最重要的特性 前面是为多态服务的<br>多态是三大特性中最重要的操作<br>多态是同一个行为具有多个不同表现形式或形态的能力<br>多态是同一个接口，使用不同的实例而执行不同操作</p>
</li>
</ul>
<h3 id="静态和实例变量-方法-的区别"><a href="#静态和实例变量-方法-的区别" class="headerlink" title="静态和实例变量(方法)的区别"></a>静态和实例变量(方法)的区别</h3><ul>
<li><strong>语法区别</strong>：静态变量前要加static关键字，实例则不用</li>
<li><strong>隶属区别</strong>：实例变量属于某个对象的属性，而静态属于类</li>
<li><strong>运行区别</strong>：<u>静态变量</u>在JVM加载类字节码创建，<u>实例变量</u>在实例化对象时创建</li>
</ul>
<h6 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h6><p>在类中定义，使用static关键字修饰<br>静态方法：可以通过类名直接访问，也可以通过对象访问<br>调用上下文：不依赖于类的实例，不能访问实例变量和实例方法<br>生命周期：从类加载到类卸载，生命周期与类相同</p>
<h6 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h6><p>在类中定义，不适用static关键字修饰<br>实例方法：只能通过对象访问<br>调用上下文：依赖于类的实例，可以访问实例变量和实例方法<br>生命周期：从对象创建到对象被垃圾回收，生命周期与对象相同</p>
<h3 id="类的执行顺序"><a href="#类的执行顺序" class="headerlink" title="类的执行顺序"></a>类的执行顺序</h3><pre><code class="java">package com.example.text;
//请写出程序输出结果
//1. 静态优先
//2. 父类优先
//3. 非静态块优先于构造函数
public class ExecutionSequence &#123;
    public static void main(String[] args) &#123;
        new GeneralClass();
    &#125;
&#125;
class ParentClass&#123;
    static &#123;
        System.out.println(&quot;①我是父类静态块&quot;);
    &#125;

    &#123;
        System.out.println(&quot;②我是父类非静态块&quot;);
    &#125;
    public ParentClass()&#123;
        System.out.println(&quot;③我是父类构造函数&quot;);
    &#125;
&#125;

class GeneralClass extends ParentClass&#123;
    static&#123;
        System.out.println(&quot;④我是子类静态块&quot;);
    &#125;

    &#123;
        System.out.println(&quot;⑤我是子类非静态块&quot;);
    &#125;

    public GeneralClass()&#123;
        System.out.println(&quot;⑥我是子类构造函数&quot;);
    &#125;
&#125;
/*
①我是父类静态块
④我是子类静态块
②我是父类非静态块
③我是父类构造函数
⑤我是子类非静态块
⑥我是子类构造函数
*/
</code></pre>
<blockquote>
<p>总结<br>静态块：静态块在类加载时执行，且父类静态块先于子类静态块执行。<br>非静态块和构造函数：在对象创建时，先执行父类的非静态块和构造函数，再执行子类的非静态块和构造函数。</p>
</blockquote>
<h3 id="请说明java的异常体系"><a href="#请说明java的异常体系" class="headerlink" title="请说明java的异常体系"></a>请说明java的异常体系</h3><p>Error → Throwable<br>RuntimeException → Exception → Throwable<br>运行时产生的异常不要求对其强制try catch…</p>
<h5 id="Error和Exception的区别和联系"><a href="#Error和Exception的区别和联系" class="headerlink" title="Error和Exception的区别和联系"></a>Error和Exception的区别和联系</h5><table>
<thead>
<tr>
<th align="center">Exception</th>
<th align="center">Error</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可以是可被控制或不可控制的</td>
<td align="center">总是不可控制的</td>
</tr>
<tr>
<td align="center">表示一个由程序员导致的错误</td>
<td align="center">经常用来用于表示系统错误或低层资源的错误</td>
</tr>
<tr>
<td align="center">表示在应用程序级被处理</td>
<td align="center">如果可能的话，应该在系统级被捕捉</td>
</tr>
</tbody></table>
<h3 id="String与字符串常量池-比较内存地址"><a href="#String与字符串常量池-比较内存地址" class="headerlink" title="String与字符串常量池 [比较内存地址]"></a>String与字符串常量池 [比较内存地址]</h3><pre><code class="java">String s1 = &quot;abc&quot;;
String s2 = &quot;abc&quot;;
String s3 = &quot;abc&quot;+&quot;def&quot;;
String s4 = &quot;abcdef&quot;;
String s5 = s2 + &quot;def&quot;;
String s6 = new String(&quot;abc&quot;);
System.ouut.println(s1==s2); //true
System.ouut.println(s3==s4); //true 相等的都保存到常量池
System.ouut.println(s4==s5); //false 
//s5中的s2属于引用类型 在java编译期间无法确定其类型 只有在运行时才能确定具体的值 会产生一个新的内存地址给s5 所以不相等
System.ouut.println(s4.equals(s5));//true equals比较的是内容
System.ouut.println(s1==s6); //false
//s1是在常量池的常量 new String(&quot;abc&quot;);创建的东西不在常量池 存储的地方是完全不同的
</code></pre>
<h3 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h3><table>
<thead>
<tr>
<th></th>
<th align="center">String</th>
<th align="center">StringBuffer</th>
<th align="center">StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>执行速度</td>
<td align="center">最差</td>
<td align="center">其次</td>
<td align="center">最高</td>
</tr>
<tr>
<td>线程安全</td>
<td align="center">线程安全</td>
<td align="center">线程安全</td>
<td align="center">线程不安全</td>
</tr>
<tr>
<td>使用场景</td>
<td align="center">少量字符串操作</td>
<td align="center">多线程环境下的大量操作</td>
<td align="center">单线程环境下的大量操作</td>
</tr>
</tbody></table>
<blockquote>
<p>优先使用哪个？<br><strong>单线程环境</strong>：优先使用 <strong>StringBuilder</strong>。因为 StringBuilder 没有线程同步开销，性能更高。<br><strong>多线程环境</strong>：优先使用 <strong>StringBuffer</strong>。因为 StringBuffer 提供了线程安全的保证，避免了多线程环境下的并发问题</p>
</blockquote>
<h3 id="List与Set的区别"><a href="#List与Set的区别" class="headerlink" title="List与Set的区别"></a>List与Set的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">List</th>
<th align="center">Set</th>
</tr>
</thead>
<tbody><tr>
<td align="center">允许重复</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">是否允许null</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">是否有序</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">常用类</td>
<td align="center">ArrayList<br />LinkedList</td>
<td align="center">HashSet<br />LinkedHashSet<br />TreeSet</td>
</tr>
</tbody></table>
<h3 id="ArrayList与LinkedList的区别"><a href="#ArrayList与LinkedList的区别" class="headerlink" title="ArrayList与LinkedList的区别"></a>ArrayList与LinkedList的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">ArrayList</th>
<th align="center">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储结构</td>
<td align="center">基于动态数组</td>
<td align="center">基于链表</td>
</tr>
<tr>
<td align="center">遍历方式</td>
<td align="center">连续读取</td>
<td align="center">基于指针</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">大数据量读取</td>
<td align="center">频繁新增、插入[写入类型]</td>
</tr>
</tbody></table>
<h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">HashSet</th>
<th align="center">TreeSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">排序方式</td>
<td align="center">不能保证顺序</td>
<td align="center">按预置规则顺序</td>
</tr>
<tr>
<td align="center">底层存储</td>
<td align="center">基于HashMap</td>
<td align="center">基于TreeMap</td>
</tr>
<tr>
<td align="center">底层实现</td>
<td align="center">基于Hash表实现</td>
<td align="center">基于二叉树实现</td>
</tr>
</tbody></table>
<h3 id="List排序的编码实现"><a href="#List排序的编码实现" class="headerlink" title="List排序的编码实现"></a>List排序的编码实现</h3><pre><code class="java">编程题：List排序
Employee.java
package com.example.text;

public class Employee &#123;
    private String ename;
    private Integer age;
    private Float salary;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, salary=&quot; + salary +
                &#39;&#125;&#39;;
    &#125;

    public Employee() &#123;&#125;
    public Employee(String ename, Integer age, Float salary) &#123;
        this.ename = ename;
        this.age = age;
        this.salary = salary;
    &#125;
    public String getEname() &#123; return ename;&#125;
    public void setEname(String ename) &#123;this.ename = ename;&#125;
    public Integer getAge() &#123; return age;&#125;
    public void setAge(Integer age) &#123;this.age = age;&#125;
    public Float getSalary() &#123;return salary;&#125;
    public void setSalary(Float salary) &#123;this.salary = salary;&#125;
&#125;
</code></pre>
<pre><code class="java">ListSorter.java
package com.example.text;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ListSorter &#123;
    public static void main(String[] args) &#123;
        List&lt;Employee&gt; emps = new ArrayList&lt;&gt;();
        emps.add(new Employee(&quot;张三&quot;, 33, 1800f));
        emps.add(new Employee(&quot;李四&quot;, 55, 3800f));
        emps.add(new Employee(&quot;王五&quot;, 40, 2300f));
        Collections.sort(emps, new Comparator&lt;Employee&gt;() &#123;
            @Override
            public int compare(Employee o1, Employee o2) &#123;
                //以薪资排序 如果是以年龄的话o1.getAge() - o2.getAge();
                return (int) (o1.getSalary() - o2.getSalary());
                //返回正数 第一个大于第二个
            &#125;
        &#125;);
        System.out.println(emps);
    &#125;
&#125;
</code></pre>
<h3 id="TreeSet排序的编码实现"><a href="#TreeSet排序的编码实现" class="headerlink" title="TreeSet排序的编码实现"></a>TreeSet排序的编码实现</h3><pre><code class="java">编程题:TreeSet排序
Employee.java 同上
[自定义排序]
SetSorter.java 
package com.example.text.TreeSet;

import java.util.*;

//自定义排序
public class SetSorter &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Employee&gt; emps = new TreeSet&lt;Employee&gt;(new Comparator&lt;Employee&gt;() &#123;
            @Override
            public int compare(Employee o1, Employee o2) &#123;
                return (int)(o2.getSalary() - o1.getSalary());
            &#125;
        &#125;);
        emps.add(new Employee(&quot;张三&quot;, 33, 1800f));
        emps.add(new Employee(&quot;李四&quot;, 55, 3800f));
        emps.add(new Employee(&quot;王五&quot;, 40, 2300f));
    &#125;
&#125;
</code></pre>
<pre><code class="java">[自然排序]
package com.example.text;

public class Employee implements Comparable&lt;Employee&gt;&#123;
    private String ename;
    private Integer age;
    private Float salary;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, salary=&quot; + salary +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Employee o)&#123;
 //如果返回-1 Employee对象返回到红黑树的左边 采用降序排列
 //如果返回1
        return this.getAge().compareTo(o.getAge());
//      return o.getAge().compareTo(this.getAge()); 输出降序
//如果前面比后面大 返回1 反之返回-1 如果两者相等返回0
    &#125;
    public Employee() &#123;&#125;
    public Employee(String ename, Integer age, Float salary) &#123;
        this.ename = ename;
        this.age = age;
        this.salary = salary;
    &#125;
    public String getEname() &#123; return ename;&#125;
    public void setEname(String ename) &#123;this.ename = ename;&#125;
    public Integer getAge() &#123; return age;&#125;
    public void setAge(Integer age) &#123;this.age = age;&#125;
    public Float getSalary() &#123;return salary;&#125;
    public void setSalary(Float salary) &#123;this.salary = salary;&#125;
&#125;
=============================================================
SetSorter.java 
package com.example.text.TreeSet;

import java.util.*;

//自定义排序
public class SetSorter &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Employee&gt; emps = new TreeSet&lt;Employee&gt;
        emps.add(new Employee(&quot;张三&quot;, 33, 1800f));
        emps.add(new Employee(&quot;李四&quot;, 55, 3800f));
        emps.add(new Employee(&quot;王五&quot;, 40, 2300f));
        System.out.println(emps);
    &#125;
&#125;
</code></pre>
<h3 id="hashCode与equals的联系与区别"><a href="#hashCode与equals的联系与区别" class="headerlink" title="hashCode与equals的联系与区别"></a>hashCode与equals的联系与区别</h3><h5 id="Object类hashCode-和equals-的区别"><a href="#Object类hashCode-和equals-的区别" class="headerlink" title="Object类hashCode()和equals()的区别"></a>Object类hashCode()和equals()的区别</h5><ul>
<li><p>equals()方法用来判断两个对象是否”相同”</p>
</li>
<li><p>hashCode()返回一个int，代表”将该对象的内部地址” [如果不相等肯定不是同一个对象] [小概率情况下不同的对象也产生相同的hashCode(), 之后再用equals()去比较]</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">两个对象如果equals()成立, hashcode()一定成立</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">如果equals()不成立, hashcode()可能成立</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">如果hashcode()成立, equals()不一定成立</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">hashcode()不相等, equals()一定不成立</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>hashCode 方法用于快速定位哈希表中的桶（bucket），而 equals 方法用于确认桶中的具体对象。通过 hashCode 快速过滤掉大部分不相等的对象，可以显著提高查找效率。<br>通常是先调用 hashCode 方法来定位桶，然后再调用 equals 方法来确认具体对象。equals 方法不会直接调用 hashCode 方法，而是依赖于 hashCode 方法的一致性。</p>
</blockquote>
<h3 id="Java-IO中有集中类型的流"><a href="#Java-IO中有集中类型的流" class="headerlink" title="Java IO中有集中类型的流"></a>Java IO中有集中类型的流</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节流</td>
<td align="center">InputStream[父类]<br />     FileInputStream<br />BufferedInputStream[缓存]</td>
<td align="center">OutputStream[父类]<br />      FileOutputStream<br />  BufferedOutputStream[缓存]</td>
</tr>
<tr>
<td align="center">字符流</td>
<td align="center">Reader<br />FileReader<br />InputStreamReader<br />BufferedReader</td>
<td align="center">Writer<br />FileWeiter<br />OutputStreamWriter<br />BufferedWeiter</td>
</tr>
</tbody></table>
<h3 id="★-利用IO实现文件复制-★-笔试"><a href="#★-利用IO实现文件复制-★-笔试" class="headerlink" title="★ 利用IO实现文件复制 ★ [笔试]"></a>★ 利用IO实现文件复制 ★ [笔试]</h3><pre><code class="java">编程题：复制文件到指定文件夹
package com.example.text.FileCopy;

import java.io.*;

public class FileCopy &#123;
    public static void main(String[] args) &#123;
        //1. 利用JavaIo
        File source = new File(&quot;D:/application.rar&quot;);
        File target = new File(&quot;D:/target/application.rar&quot;);
        InputStream input = null;
        OutputStream output = null;
        try &#123;
            input = new FileInputStream(source);
            output = new FileOutputStream(target);
            byte[] buf = new byte[1024];
            int byteRead;
            while((byteRead = input.read(buf)) != -1)&#123;
                output.write(buf,0,byteRead);
            &#125;
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            try &#123;
                input.close();
                output.close();
            &#125; catch (IOException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;
        //2. 利用FileChannel实现文件复制
        //3. Commons Io组件实现文件复制
        //FileUtils.copyFile(Source,Target);
    &#125;
&#125;
</code></pre>
<h3 id="请介绍JVM的内存组成"><a href="#请介绍JVM的内存组成" class="headerlink" title="请介绍JVM的内存组成"></a>请介绍JVM的内存组成</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/c2c6b396e3573fda209d5b4db42d40799b0be3f1/data/JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90.png"></p>
<blockquote>
<p>[共享区：供所有对象共享 所有线程都访问到的地方]<br><strong>堆</strong>：垃圾回收销毁处理区<br><strong>方法区</strong>：虚拟机加载的类的信息、常量、静态变量等信息</p>
<p>[私有区：所有对象都是私有的]<br><strong>程序计数器PC</strong>： 当前线程所执行的字节码指令的行号指示器[<strong>分值、跳转</strong>、循环、异常处理、线程恢复] 每个线程都有单独的程序计数器 [私有的]<br><strong>虚拟机栈VM Stack</strong>：为Java的方法服务 当线程创建的时候虚拟机栈会为线程分配一个虚拟机栈，在线程执行的时候创建的每个方法都会创建一个栈针，用于存放局部变量、操作方法等 [入栈+出栈]<br><strong>本地方法栈</strong>：类似于虚拟机栈，本地方法栈是执行<u>本地方法使用</u>的</p>
</blockquote>
<h3 id="请简述Java的垃圾回收-GC"><a href="#请简述Java的垃圾回收-GC" class="headerlink" title="请简述Java的垃圾回收(GC)"></a>请简述Java的垃圾回收(GC)</h3><ul>
<li>GC(Garbage Collection)用于回收不再使用的内存</li>
<li>GC负责3项任务：分配内存、确保引用、回收内存</li>
<li>GC回收的依据某对象没有任何引用、则可以被回收</li>
</ul>
<h5 id="垃圾回收-GC-算法"><a href="#垃圾回收-GC-算法" class="headerlink" title="垃圾回收(GC)算法"></a>垃圾回收(GC)算法</h5><ul>
<li><strong>引用计数算法</strong> [计数器 引用到这个对象的时候+1  被释放或断开计数器-1  当计数器变成0就可以被垃圾回收]<br>若两个对象相互引用就会产生循环计数器 这个对于引用计数算法是无效的</li>
<li><strong>跟踪回收算法</strong> [利用JVM维护的对象引用图 每个对象彼此依赖和引用 从根节点标记对象引用图和可以被标记的对象 遍历结束以后未被标记的对象是不能够使用的对象可以被回收]</li>
<li><strong>压缩回收算法</strong> [将JVM堆中活动的对象放到一个集中的区域中 另外一大块留出一个活动的区域 对堆中的碎片进行集中的处理]</li>
<li><strong>复制回收算法</strong> [把堆分成两个相同大小的区域 只有其中的一个区域被使用 直到这个区域被消耗完 垃圾回收器就会中断这个程序的运行 以遍历的方式把活动的对象移动到另一个区域 移动的过程中对象是紧密挨在一起的 可以消除其中的碎片 【在复制的同时也对对象进行重新复制和安排 一次性解决了内存碎片的问题】【需要两倍大小的内存空间 降低了效率】]</li>
<li><strong>按代回收算法</strong> [把堆分成多个子堆，每个堆命名成一代，算法优先收集年幼年轻的对象，在这其中对象仍然存活的就把它移动到高级堆中 【减少扫描次数和范围 提高回收效益】]</li>
</ul>
<h3 id="Java的内存泄露的场景"><a href="#Java的内存泄露的场景" class="headerlink" title="Java的内存泄露的场景"></a>Java的内存泄露的场景</h3><h5 id="请列举Java中内存泄漏的场景"><a href="#请列举Java中内存泄漏的场景" class="headerlink" title="请列举Java中内存泄漏的场景"></a>请列举Java中内存泄漏的场景</h5><p>一个不需要使用的对象还在内存中占用并使用其内存空间，忘记释放就会存在内存泄露</p>
<ul>
<li><strong>静态集合类</strong> static描述对象 存储在方法区 垃圾回收器不会对其扫描回收</li>
<li><strong>各种连接</strong> JVM一直可达不会被回收</li>
<li><strong>监听器</strong> 全局存在的</li>
<li><strong>不合理的作用域</strong> 能用在方法中public 不要用在方法外private</li>
<li>没有把对象及时设置为null【极少发生】</li>
</ul>
<h3 id="请实现对象的浅复制与深复制"><a href="#请实现对象的浅复制与深复制" class="headerlink" title="请实现对象的浅复制与深复制"></a>请实现对象的浅复制与深复制</h3><ul>
<li><strong>浅复制</strong>：只对对象及变量值进行复制，引用对象地址不变</li>
<li><strong>深复制</strong>[序列化方式]：创建一个新的对象，并且复制所有引用类型字段的对象。修改新对象的引用类型字段不会影响原对象。[彼此互不干扰]</li>
</ul>
<pre><code class="java">com/example/text/clone/Dancer.java
package com.example.text.clone;

import java.io.*;

public class Dancer implements Cloneable,Serializable&#123;
    private String name;
    private Dancer partner;

    public Dancer() &#123;
    &#125;

    public Dancer(String name, Dancer partner) &#123;
        this.name = name;
        this.partner = partner;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Dancer getPartner() &#123;
        return partner;
    &#125;

    public void setPartner(Dancer partner) &#123;
        this.partner = partner;
    &#125;
    public Dancer deepClone() throws IOException, ClassNotFoundException &#123;
        //序列化, 将内存中的对象序列化为字节数组
        //序列化要注意加Serializable接口
        ByteArrayOutputStream bos = new ByteArrayOutputStream();//字节数组
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        //反序列化, 将字节数组转回到对象, 同时完成深复制的任务
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis); //字节数组还原成对象
        return (Dancer) ois.readObject();
    &#125;
    //初始化一下
    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException &#123;
        Dancer d1 = new Dancer();
        d1.setName(&quot;小明&quot;);
        Dancer d2 = new Dancer();
        d2.setName(&quot;小红&quot;);
        d1.setPartner(d2);
        //hashCode()是内存地址转化后的一个整数
        System.out.println(&quot;Partner:&quot; + d2.hashCode());
        //浅复制
        Dancer shallow =  (Dancer)d1.clone();
        System.out.println(&quot;浅复制：&quot; + shallow.getPartner().hashCode());
        //深复制
        Dancer deep = (Dancer) d1.deepClone();
        System.out.println(&quot;深复制：&quot; + deep.getPartner().hashCode());
    &#125;
&#125;
</code></pre>
<h5 id="简述一下equalsIgnoreCase和equals的区别"><a href="#简述一下equalsIgnoreCase和equals的区别" class="headerlink" title="简述一下equalsIgnoreCase和equals的区别"></a>简述一下equalsIgnoreCase和equals的区别</h5><pre><code class="java">equalsIgnoreCase：比较两个字符串的内容是否相等, 忽略大小写
equals：比较两个字符的内容是否完全相等, 包括大小写
equalsIgnoreCase 和 equals 都是 String 类的方法，用于比较两个字符串是否相等(返回值都是Boolean)。它们的主要区别在于对大小写的处理方式。
</code></pre>
<h1 id="Java面试——Web基础与数据处理"><a href="#Java面试——Web基础与数据处理" class="headerlink" title="Java面试——Web基础与数据处理"></a>Java面试——Web基础与数据处理</h1><h3 id="请说明Servlet执行流程"><a href="#请说明Servlet执行流程" class="headerlink" title="请说明Servlet执行流程"></a>请说明Servlet执行流程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/94561f5b5984c6a6ac9be3dd6a81d295e2955040/data/Servlet%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p>
<h6 id="问：Servlet什么时候被实例化的呢？"><a href="#问：Servlet什么时候被实例化的呢？" class="headerlink" title="问：Servlet什么时候被实例化的呢？"></a>问：Servlet什么时候被实例化的呢？</h6><blockquote>
<p>Servlet默认情况下是<u>第一次访问的时候</u><strong>实例化</strong>的<br>也可以通过web.xml配置load-on-startup，使其在服务启动的时候实例化</p>
</blockquote>
<h6 id="问：Servlet在并发条件下如何处理的？"><a href="#问：Servlet在并发条件下如何处理的？" class="headerlink" title="问：Servlet在并发条件下如何处理的？"></a>问：Servlet在并发条件下如何处理的？</h6><blockquote>
<p>基于<strong>单例多线程</strong>技术提供web服务<br>使用servlet时不允许使用存在状态改变的变量</p>
</blockquote>
<blockquote>
<p>补充：</p>
<p><strong><u>单例多线程技术</u></strong><br><strong>单例模式</strong>：Servlet 实例在 Web 容器中通常是单例的，即一个 Servlet 类只有一个实例。这意味着所有的请求都会共享同一个 Servlet 实例。<br>优点：减少了对象的创建和销毁开销，提高了性能。<br>缺点：需要特别注意线程安全问题，因为多个请求可能会同时访问同一个 Servlet 实例。</p>
<p><strong>多线程</strong>：Web 容器为每个请求分配一个独立的线程来处理。当多个请求同时到达时，这些请求会被分配到不同的线程中，但这些线程都共享同一个 Servlet 实例。<br>线程安全：由于多个线程共享同一个 Servlet 实例，因此必须确保 Servlet 实例中的代码是线程安全的。</p>
<p><u><strong>状态改变的变量</strong></u><br><strong>状态改变的变量</strong>：指的是在 Servlet 实例中定义的成员变量（实例变量），这些变量在不同请求之间可能会被修改。</p>
<p><strong>线程安全问题</strong>：<u>如果多个线程同时访问和修改同一个成员变量，可能会导致数据不一</u>致、<strong>竞态条件</strong>等问题。<br>竞态条件（Race Condition）是指在多线程或多进程环境中，由于多个线程或进程对共享资源的访问顺序不确定，导致程序的行为依赖于这些线程或进程的执行顺序，从而产生不可预测的结果。简单来说，竞态条件发生在多个线程或进程竞争同一资源时，如果这些线程或进程的执行顺序不同，会导致不同的结果。</p>
</blockquote>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><ul>
<li><h6 id="启动时装载-web-xml"><a href="#启动时装载-web-xml" class="headerlink" title="启动时装载 - web.xml"></a>启动时装载 - web.xml</h6></li>
<li><h6 id="创建-构造函数"><a href="#创建-构造函数" class="headerlink" title="创建 - 构造函数"></a>创建 - 构造函数</h6></li>
<li><h6 id="初始化-init-专门的初始化资源"><a href="#初始化-init-专门的初始化资源" class="headerlink" title="初始化 - init()  [专门的初始化资源]"></a>初始化 - init()  [专门的初始化资源]</h6></li>
<li><h6 id="提供服务-service-对于发来的请求无论是get-post-一律使用service进行处理-细化分出doget-dopost"><a href="#提供服务-service-对于发来的请求无论是get-post-一律使用service进行处理-细化分出doget-dopost" class="headerlink" title="提供服务 - service() [对于发来的请求无论是get post 一律使用service进行处理] [细化分出doget() dopost()]"></a>提供服务 - service() [对于发来的请求无论是get post 一律使用service进行处理] [细化分出doget() dopost()]</h6></li>
<li><h6 id="停止时销毁-destory-销毁资源"><a href="#停止时销毁-destory-销毁资源" class="headerlink" title="停止时销毁 - destory() [销毁资源]"></a>停止时销毁 - destory() [销毁资源]</h6></li>
</ul>
<pre><code class="java">com/example/text/servlet/SampleServlet.java
package com.example.text.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class SampleServlet extends HttpServlet &#123;
    public SampleServlet()&#123;
        System.out.println(&quot;正在创建Servlet&quot;);
    &#125;

    @Override
    public void init() throws ServletException &#123;
        System.out.println(&quot;正在初始化Servlet&quot;);
    &#125;

    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;
        System.out.println(this.hashCode() + &quot;: Service()正在提供服务&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        resp.getWriter().print(this.hashCode() + &quot;: Service()正在提供服务&quot;);
    &#125;

    @Override
    public void destroy()&#123;
        System.out.println(&quot;正在销毁Servlet&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SampleServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.example.text.servlet.SampleServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SampleServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/sample&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;

=================================================
http://localhost:8080/sample

正在创建Servlet 【启动时】
正在初始化Servlet
1025518765: Service()正在提供服务
正在销毁Servlet 【停止时】
</code></pre>
<h3 id="请求与响应的结构"><a href="#请求与响应的结构" class="headerlink" title="请求与响应的结构"></a>请求与响应的结构</h3><ul>
<li>HTTP请求包含三部分：请求行、请求头、请求体</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/22dcc798c61eeec0f74ca5dd6e7372dfa0fa135e/data/HTTP%E8%AF%B7%E6%B1%82%E4%B8%89%E9%83%A8%E5%88%86.jpg" alt="HTTP请求三部分"></p>
<ul>
<li>HTTP响应包含三部分：响应行、响应头、响应体</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c6c25addb904f020840b00a3b10ed5b3c707469/data/HTTP%E5%93%8D%E5%BA%94%E4%B8%89%E9%83%A8%E5%88%86.jpg" alt="HTTP响应三部分"></p>
<h3 id="请求转发与响应重定向的区别"><a href="#请求转发与响应重定向的区别" class="headerlink" title="请求转发与响应重定向的区别"></a>请求转发与响应重定向的区别</h3><h5 id="请求转发-一次请求"><a href="#请求转发-一次请求" class="headerlink" title="请求转发 [一次请求]"></a>请求转发 [一次请求]</h5><ul>
<li>请求转发是<strong>服务器跳转</strong>，只会产生一次请求</li>
<li>请求转发语句是：<code>request.getRequestDispatcher().forward()</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c6c25addb904f020840b00a3b10ed5b3c707469/data/HTTP%E5%93%8D%E5%BA%94%E4%B8%89%E9%83%A8%E5%88%86.jpg" alt="请求转发"></p>
<blockquote>
<p>网页请求Tomcat的Servlet1，Servlet1请求Servlet2，Servlet2响应给网页，网页收到响应</p>
</blockquote>
<h5 id="响应重定向-两次请求"><a href="#响应重定向-两次请求" class="headerlink" title="响应重定向 [两次请求]"></a>响应重定向 [两次请求]</h5><ul>
<li>重定向则是<strong>浏览器端跳转</strong>，会产生两次请求</li>
<li>响应重定向语句是：<code>response.sendRedirect()</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/de72ec8d8af2b71272c785f5fb04bad0df88d78f/data/%E5%93%8D%E5%BA%94%E9%87%8D%E5%AE%9A%E5%90%911.jpg" alt="响应重定向"></p>
<blockquote>
<p>网页$请求_1$Tomcat的Servlet1，Servlet1直接$响应_1$给网页，网页收到$响应_1$[让网页创建一个新的$请求_2$]<br>网页新创了一个$请求_2$Tomcat的Servlet2，Servlet2只对请求进行处理返回给$响应_2$网页</p>
</blockquote>
<h3 id="请阐述Session的原理"><a href="#请阐述Session的原理" class="headerlink" title="请阐述Session的原理"></a>请阐述Session的原理</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e69d245dd6d92882f32e9bee19e85bb5646a145c/data/%E7%AE%80%E8%BF%B0Session%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="简述Session的原理"></p>
<blockquote>
<p>浏览器第一次向Tomcat发送请求，Tomcat收到请求自动在tomcat运行内存中生成一个存储空间并赋予一个SessionId:7U809J唯一编号，<strong>若使用了session.setAttribute(name,小潘)<strong>，会在那个运行内存中存放一个</strong>小潘</strong>的内存属性[name:小潘] 当程序处理完后返回给浏览器其中包含了一个特殊信息SessionId:7U809J，浏览器收到响应后把SessionId:7U809J保存到浏览器的Cookie中SessionId:7U809J[只要当前浏览器没有被关闭的话 Cookie会一直存在 会在发送请求的时候一并发送给服务器]，当第二次发送请求的时候浏览器会把SessionId:7U809J第二次发送给Tomcat，<strong>若使用了session.getAttribute(name) &#x3D; 小潘</strong>，得到的结果就出现了小潘 返回浏览器响应</p>
</blockquote>
<h3 id="JSP九大内置对象是什么"><a href="#JSP九大内置对象是什么" class="headerlink" title="JSP九大内置对象是什么"></a>JSP九大内置对象是什么</h3><table>
<thead>
<tr>
<th align="left">内置对象</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">request</td>
<td align="left">请求对象 - HttpServletRequest</td>
</tr>
<tr>
<td align="left">response</td>
<td align="left">响应对象 - HttpServletResponse</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">用户会话 - HttpSession</td>
</tr>
<tr>
<td align="left">application [全局实例]</td>
<td align="left">应用全局对象 - ServletContext</td>
</tr>
<tr>
<td align="left">out</td>
<td align="left">输出对象 - PrintWriter</td>
</tr>
<tr>
<td align="left">page</td>
<td align="left">当前页面对象 - this [Object实例]</td>
</tr>
<tr>
<td align="left">pageContext</td>
<td align="left">页面上下文对象 - PageContext</td>
</tr>
<tr>
<td align="left">config [全局参数]</td>
<td align="left">应用配置对象 - ServletConfig</td>
</tr>
<tr>
<td align="left">exception</td>
<td align="left">应用异常对象 - Throwable</td>
</tr>
</tbody></table>
<h3 id="Statement-和-PreparedStatement的区别"><a href="#Statement-和-PreparedStatement的区别" class="headerlink" title="Statement 和 PreparedStatement的区别"></a>Statement 和 PreparedStatement的区别</h3><ul>
<li>PreparedStatement是预编译的SQL语句，效率高于Statement</li>
<li>PreparedStatement支持 ‘?’ 操作符，相对于Statement更加灵活</li>
<li>PreparedStatement可以防止SQL注入，安全性高于Statement</li>
</ul>
<pre><code class="java">package com.example.text.jdbc;

import java.sql.*;

public class StatementSample &#123;
    //使用Statement sql语句解释N多次
    //SQL注入攻击：  &#39; or 1=1 or &#39;
    public void findByEname1(String ename) &#123;
        String driverName = &quot;com.mysql.jdbc.Driver&quot;;
        String URL = &quot;jdbc:mysql://127.0.0.1:3306/scott&quot;;
        String username = &quot;root&quot;;
        String password = &quot;root&quot;;
        Connection conn = null;
        try &#123;
            Class.forName(driverName);
            conn = DriverManager.getConnection(URL, username, password);
            Statement ps = conn.createStatement();
            //使用Statement
            String sql = &quot;SELECT * FROM emp where ename = &#39;&quot; + ename + &quot;&#39; &quot;;
            System.out.println(sql);
            ResultSet rs = ps.executeQuery(sql);

            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; +
                        rs.getString(&quot;job&quot;) + &quot;,&quot; +
                        rs.getFloat(&quot;sal&quot;));
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //5.关闭连接
        finally &#123;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.example.text.jdbc;

import java.sql.*;

public class StatementSample &#123;

    //使用预编译PreparedStatement sql语句解释一次
    public void findByEname2(String ename) &#123;
        String driverName = &quot;com.mysql.jdbc.Driver&quot;;
        String URL = &quot;jdbc:mysql://127.0.0.1:3306/scott&quot;;

        String username = &quot;root&quot;;
        String password = &quot;root&quot;;
        Connection conn = null;
        try &#123;
            Class.forName(driverName);
            conn = DriverManager.getConnection(URL, username, password);

            //使用预编译PreparedStatement
            String sql = &quot;SELECT * FROM emp where ename = ?&quot;;
            System.out.println(sql);
            PreparedStatement ps = conn.prepareStatement(sql);
            ps.setString(1, ename);
            ResultSet rs = ps.executeQuery();

            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; +
                        rs.getString(&quot;job&quot;) + &quot;,&quot; +
                        rs.getFloat(&quot;sal&quot;));
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //5.关闭连接
        finally &#123;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        StatementSample sample = new StatementSample();
        sample.findByEname1(&quot;SMITH&#39; or 1=1 or &#39;&quot;); //SQL注入攻击
        sample.findByEname2(&quot;SMITH&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="请说明JDBC的使用步骤"><a href="#请说明JDBC的使用步骤" class="headerlink" title="请说明JDBC的使用步骤"></a>请说明JDBC的使用步骤</h3><ul>
<li>加载JDBC驱动</li>
<li>创建数据库连接(Connection)</li>
<li>创建命令(Statement)</li>
<li>处理结果(ResultSet)</li>
<li>关闭连接</li>
</ul>
<pre><code class="java">package com.example.text.jdbc;

import java.sql.*;

public class MysqlJDBC &#123;
    public static void main(String[] args) &#123;
        //连接需要提前下载好包   mysql-connector-java-5.1.47.jar
        String driverName = &quot;com.mysql.jdbc.Driver&quot;;
        String URL = &quot;jdbc:mysql://127.0.0.1:3306/scott&quot;;
        String sql = &quot;SELECT * FROM emp&quot;;
        String username = &quot;root&quot;;
        String password = &quot;root&quot;;
        Connection conn = null;
        try &#123;
            //1.加载JDBC驱动
            Class.forName(driverName);
            //2.建立连接
            conn = DriverManager.getConnection(URL, username, password);
            //3.创建命令（Statement)
            Statement ps = conn.createStatement();
            //4.处理结果
            ResultSet rs = ps.executeQuery(sql);
            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; +
                        rs.getString(&quot;job&quot;) + &quot;,&quot; +
                        rs.getFloat(&quot;sal&quot;));
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //5.关闭连接
        finally &#123;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="SQL编程训练"><a href="#SQL编程训练" class="headerlink" title="SQL编程训练"></a>SQL编程训练</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/bc48ea2eefeb9921758f69d1ee9d506366d73753/data/scott_sql%E7%BB%83%E4%B9%A0%E9%A2%98.png"></p>
<pre><code class="sql">scott.sql文件已准备好

★按部门编号升序、工资倒序的排列员工信息
SELECT * FROM emp ORDER BY deptno ASC, sal DESC

★列出deptno=30的部门名称及员工[关联查询]
SELECT dept.dname, emp.* FROM emp,dept
WHERE emp.deptno = dept.deptno
AND dept.deptno = 30

★列出每个部门最高、最低、平均工资 #若再列出人数只需要再SELECT后面加 COUNT(*)
SELECT deptno, max(sal), min(sal), avg(sal)
FROM emp 
GROUP BY deptno  

★列出市场部(SALES)及研发部(RESEARCH)的员工
SELECT * FROM dept d, emp e
WHERE d.deptno = e.deptno 
AND (d.dname = &#39;SALES&#39; or d.dname = &#39;RESEARCH&#39;)

★列出人数超过3人的部门 #按照部门分组 
# WHERE对原始数据进行筛选[在GROUP BY之前进行的] 
# HAVING对分组后的进行二次筛选[在GROUP BY之后进行的]
SELECT d.dname, count(*)
FROM dept d, emp e
WHERE d.deptno = e.deptno 
GROUP BY d.dname 
HAVING count(*)&gt;3

★计算MILLER年薪比SMITH高多少
SELECT a.a_sal, b.b_sal, a.a_sal - b.b_sal FROM 
(SELECT sal * 12 a_sal FROM emp WHERE ename = &#39;MILLER&#39;) a,
(SELECT sal * 12 b_sal FROM emp WHERE ename = &#39;SMITH&#39;) b

★★列出直接向King汇报的员工
SELECT * FROM emp
WHERE mgr = (SELECT empno FROM emp WHERE ename = &#39;KING&#39;)
#或
SELECT e.* FROM emp e, (SELECT empno FROM emp WHERE ename = &#39;KING&#39;) k
WHERE e.mgr = k.empno

★★列出公司所有员工的工龄，并倒序排列 
# NOW获取当前时间 
# SELECT DATE_FORMAT(date,format)   DATE_FORMAT只对日期形式的数据生效
SELECT * FROM(
    SELECT emp.*, DATE_FORMAT(NOW(),&quot;%Y&quot;) - DATE_FORMAT(hiredate,&quot;%Y&quot;) yg 
    FROM emp
)d 
ORDER BY d.yg DESC

★★计算管理者与基层员工平均薪资差额
SELECT a_avg - b_avg 
FROM
 (SELECT avg(sal) a_avg 
 FROM emp
 WHERE job = &#39;MANAGER&#39; OR job = &#39;PRESIDENT&#39;) a,
  (SELECT avg(sal) b_avg
  FROM emp
  WHERE job IN (&#39;CLERK&#39;,&#39;SALESMAN&#39;,&#39;ANALYST&#39;))b
</code></pre>
<h1 id="Java面试-——-主流框架"><a href="#Java面试-——-主流框架" class="headerlink" title="Java面试 —— 主流框架"></a>Java面试 —— 主流框架</h1><h3 id="谈谈你对IOC和DI的理解"><a href="#谈谈你对IOC和DI的理解" class="headerlink" title="谈谈你对IOC和DI的理解"></a>谈谈你对IOC和DI的理解</h3><ul>
<li><h6 id="IOC控制反转，设计理念，由第三方来管理与控制对象"><a href="#IOC控制反转，设计理念，由第三方来管理与控制对象" class="headerlink" title="IOC控制反转，设计理念，由第三方来管理与控制对象"></a>IOC控制反转，设计理念，由第三方来管理与控制对象</h6></li>
<li><h6 id="DI依赖注入，具体实现，由对象容器在运行时动态注入对象"><a href="#DI依赖注入，具体实现，由对象容器在运行时动态注入对象" class="headerlink" title="DI依赖注入，具体实现，由对象容器在运行时动态注入对象"></a>DI依赖注入，具体实现，由对象容器在运行时动态注入对象</h6></li>
</ul>
<p>[<strong><u>DI是一种具体的技术实现，是对宏观IOC里面的一种技术上的形式，在Spring中使用了反射+工厂模式来实现DI</u></strong>]</p>
<pre><code class="java">IDAO dao = new UserDao(); //原始版本 原本的容器控制器

运行时Spring动态进行创建 对程序进行有效的解耦 //将控制权交给第三方控制容器  IOC容器
// applicationContext最底层是类工厂模式
IDAO dao = (IDAO)applicationContext.getBean(&quot;userDAO&quot;); //ICO容器 动态实例化DAO
 &lt;bean id = &quot;userDAO&quot; class = &quot;com.imooc.dao.UserDAO&quot;/&gt;
 &lt;bean id = &quot;userDAO&quot; class = &quot;com.imooc.dao.UserExtDAO&quot;/&gt; //方便随时更改
</code></pre>
<h3 id="Spring中Bean实例化有几种方式"><a href="#Spring中Bean实例化有几种方式" class="headerlink" title="Spring中Bean实例化有几种方式"></a>Spring中Bean实例化有几种方式</h3><ul>
<li>使用<strong>类构造器</strong>实例化</li>
<li>使用<strong>静态工厂方法</strong>实例化</li>
<li>使用<strong>实例工厂方法</strong>实例化</li>
</ul>
<pre><code class="java">com/example/text/spring/Person.java
package com.example.text.spring;

public class Person &#123;

    private String name;
    private Integer age;


    public Person() &#123;
        System.out.println(&quot;Person默认构造函数&quot;);
    &#125;

    public Person(String name, Integer age) &#123;
        this.name = name;
        this.age = age;

        System.out.println(&quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/spring/PersonStaticFactory.java
package com.example.text.spring;

/**
 * Person静态工厂
 */
public class PersonStaticFactory &#123;
    public static Person createPerson(String name,int age)&#123;
        return new Person(name,age);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/spring/PersonFactory.java
package com.example.text.spring;

/**
 * Person实例工厂 实例化以后才可以调用
 */
public class PersonFactory &#123;
    public Person createPerson(String name,int age)&#123;
        return new Person(name,age);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">C:\Users\Pluminary\Desktop\text\src\main\resources\applicationContext.xml
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--构造函数实例化--&gt;
    &lt;!-- 1.调用无参构造函数 --&gt;
    &lt;bean id=&quot;person1&quot; class=&quot;com.imooc.spring.instance.Person&quot;&gt;&lt;/bean&gt;

    &lt;!-- 2.调用有参构造函数 --&gt;
    &lt;bean id=&quot;person2&quot; class=&quot;com.imooc.spring.instance.Person&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;枫叶(构造函数)&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;/&gt;
    &lt;/bean&gt;


    &lt;!-- 通过静态工厂创建对象--&gt;
    &lt;bean id=&quot;person3&quot; class=&quot;com.imooc.spring.instance.PersonStaticFactory&quot; factory-method=&quot;createPerson&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;蓝天(静态工厂)&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;27&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 通过实例工厂创建对象--&gt;
&lt;!-- 实例化PersonFactory--&gt;
    &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.imooc.spring.instance.PersonFactory&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;person4&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;createPerson&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;绿地(实例工厂)&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;29&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/example/text/Application.java
package com.example.text;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Application &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
===================================================================
Person默认构造函数
Person&#123;name=&#39;枫叶(构造函数)&#39;,age=23&#125;
Person&#123;name=&#39;蓝天(静态工厂)&#39;,age=27&#125;
Person&#123;name=&#39;绿地(实例工厂)&#39;,age=29&#125;
</code></pre>
<h3 id="Bean注入属性有哪几种方式"><a href="#Bean注入属性有哪几种方式" class="headerlink" title="Bean注入属性有哪几种方式"></a>Bean注入属性有哪几种方式</h3><ul>
<li><h6 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h6></li>
<li><h6 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h6></li>
<li><h6 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h6></li>
<li><h6 id="Java-Config注入"><a href="#Java-Config注入" class="headerlink" title="Java Config注入"></a>Java Config注入</h6></li>
</ul>
<h6 id="setter注入-1"><a href="#setter注入-1" class="headerlink" title="setter注入"></a>setter注入</h6><blockquote>
<p>在UserService使用的时候依赖于UserDao，目前UserDao是空的，要想运行时通过setter方法注入的话，我们需要在injection.xml中<br>&lt;context:component-scan base-package&#x3D;”com.imooc.spring”&#x2F;&gt;<br><bean id="userDAO" class="com.imooc.spring.injection.UserDAOImpl"/><br><bean id="userService" class="com.imooc.spring.injection.UserService"><br>    <property name="userDAO" ref="userDAO"/><br>    <constructor-arg name="userDAO" ref="userDAO"/><br>前面的name&#x3D;”userDAO”对应着UserService.java中的userDAO属性 <code>private UserDAO userDAO</code><br>后面的ref&#x3D;”userDAO”对应着当前文件中的bean id &#x3D; “userDAO”<br></bean></p>
</blockquote>
<pre><code class="java">com/example/text/injection/UserDAO.java
package com.example.text.injection;

public interface UserDAO &#123;
    public void insert();
&#125;
</code></pre>
<pre><code class="java">com/example/text/injection/UserDAOImpl.java
package com.example.text.injection;

import org.springframework.stereotype.Repository;

//@Repository(&quot;userDAO&quot;) ★注解方式注入
public class UserDAOImpl implements UserDAO&#123;
    public UserDAOImpl()&#123;
        System.out.println(this + &quot;已创建&quot;);
    &#125;
    public void insert() &#123;
        System.out.println(this + &quot;:正在调用UserDAOImpl.insert()&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/injection/UserService.java
package com.example.text.injection;

import org.springframework.stereotype.Service;

import javax.annotation.Resource;

//@Service(&quot;userService&quot;) ★注解方式注入
//spring需要动态将userDao注入到UserService上
public class UserService &#123;
//  @Resource(name=&quot;userDAO&quot;)  注解方式注入 可以把原始的bean都注释掉
    private UserDAO userDAO;

    public UserService() &#123;
        System.out.println(this + &quot;已创建&quot;);
    &#125;
/* 注解方式这些可以抛弃 并且摒弃了xml的那些bean 只需要增加个扫描的注解方式注入
    //通过构造函数注入
    public UserService(UserDAO userDAO) &#123;
        this.userDAO = userDAO;
        System.out.println(this + &quot;:正在调用构造函数注入，UserService(&quot; + userDAO + &quot;)&quot;);
    &#125;

    //通过Setter方法注入
    public void setUserDAO(UserDAO userDAO) &#123;
        this.userDAO = userDAO;
        System.out.println(this + &quot;:正在调用Setter方法注入，setUserDAO(&quot; + userDAO + &quot;)&quot;);
    &#125;
*/

    public void createUser()&#123;
        System.out.println(this + &quot;:正在调用UserService.createUser()&quot;);
        userDAO.insert();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/InjectionRunner.java
package com.example.text;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class InjectionRunner &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:injection.xml&quot;);
        UserService userService = (UserService)ctx.getBean(&quot;userService&quot;);
        userService.createUser();
    &#125;
&#125;

==============================================================
UserDAOImpl@531be3c5对象已创建
UserService@5034c75a对象已创建
UserService@5034c75a:正在调用Setter方法注入,setUserDAO
UserService@5034c75a:正在调用UserService.createUser()
UserDAOImpl@531be3c5:正在调用UserDAOImpl.insert()
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\text\src\main\resources\injection.xml
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.spring&quot;/&gt; //★扫描注解方式注入
    &lt;bean id=&quot;userDAO&quot; class=&quot;com.imooc.spring.injection.UserDAOImpl&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.injection.UserService&quot;&gt;
        &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt; //★这个是setter注入
        &lt;constructor-arg name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt; //★这个是构造函数注入
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="Java-config注入"><a href="#Java-config注入" class="headerlink" title="Java config注入"></a>Java config注入</h6><pre><code class="java">Appconfig.java 
[配置文件 在原有代码之外的东西 优点：不用破坏原始代码去达到效果 比xml优点在于java可以及时检查]
package com.imooc.spring.injection;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig &#123; //类似创建对象的方法
    @Bean(name=&quot;userDAO&quot;)
    public UserDAO userDAO()&#123;
        return new UserDAOImpl();
    &#125;

    @Bean(name=&quot;userService&quot;)
    public UserService userService()&#123;
        UserService userService = new UserService();
        userService.setUserDAO(this.userDAO());
        return userService;
    &#125;
&#125;
</code></pre>
<h3 id="Spring常见面试问题"><a href="#Spring常见面试问题" class="headerlink" title="Spring常见面试问题"></a>Spring常见面试问题</h3><pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;bean id=&quot;userDAO&quot; class=&quot;com.imooc.spring.scope.UserDAOImpl&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.scope.UserService&quot; scope=&quot;prototype&quot; lazy-init=&quot;false&quot;&gt;  
//scope是控制对象的数量是单例(singleton)还是多例(prototype)[每一次创建getbean创建对象]
//还有两个不常见的值 request[同一个对象是同一个请求 不同对象ICO容器创建不同对象] 和 
//session[调用多个getbean是同一个对象 不同session是不同对象] [SpringMVC时用]
        //lazy-init=&quot;true&quot; 延迟初始化 需要的时候才会加载 若getBean被注释则不会加载
        &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">ScopeRunner.java
package com.imooc.spring.scope;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ScopeRunner &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:scope.xml&quot;);
        UserService userService1 = (UserService)ctx.getBean(&quot;userService&quot;);
        UserService userService2 = (UserService)ctx.getBean(&quot;userService&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserDAO.java   UserDAOImpl.java   UserService.java 与上方相同
</code></pre>
<h6 id="两个注解"><a href="#两个注解" class="headerlink" title="两个注解"></a>两个注解</h6><p><code>@Autowired</code>[第三方] 和 <code>@Resource</code>[官方推荐]</p>
<blockquote>
<p>@Resource(name&#x3D;”userDAO”) &#x2F;&#x2F;设置了则进行精准匹配<br>private UserDAO userDAO;&#x2F;&#x2F;没设置则优先将名字userDAO在beanId内查找, 再没有就按照UserDAO类型在IOC容器中查找</p>
</blockquote>
<h3 id="AOP有几种通知类型"><a href="#AOP有几种通知类型" class="headerlink" title="AOP有几种通知类型"></a>AOP有几种通知类型</h3><h6 id="在不修改原始程序的前提下使用通知来对程序进行扩展"><a href="#在不修改原始程序的前提下使用通知来对程序进行扩展" class="headerlink" title="在不修改原始程序的前提下使用通知来对程序进行扩展"></a>在不修改原始程序的前提下使用通知来对程序进行扩展</h6><ul>
<li><h6 id="前置通知-Before"><a href="#前置通知-Before" class="headerlink" title="前置通知[Before]"></a>前置通知[Before]</h6></li>
<li><h6 id="返回通知-After-returning"><a href="#返回通知-After-returning" class="headerlink" title="返回通知[After returning]"></a>返回通知[After returning]</h6></li>
<li><h6 id="异常通知-After-throwing"><a href="#异常通知-After-throwing" class="headerlink" title="异常通知[After throwing]"></a>异常通知[After throwing]</h6></li>
<li><h6 id="后置通知-After"><a href="#后置通知-After" class="headerlink" title="后置通知[After]"></a>后置通知[After]</h6></li>
<li><h6 id="环绕通知-Around-统统实现"><a href="#环绕通知-Around-统统实现" class="headerlink" title="环绕通知[Around] (统统实现)"></a><span style = "color:red">环绕通知[Around]</span> (统统实现)</h6></li>
</ul>
<pre><code class="java">SampleAspect.java
package com.imooc.spring.aop;

import java.util.Date;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;

//切面类
public class SampleAspect &#123;
    
    //1.前置通知
    public void doBefore(JoinPoint jp)&#123;
        String clzName = jp.getTarget().getClass().getName();
        //getTarget() 获取即将要执行的对象
        String method = jp.getSignature().getName();//即将要执行的方法
        Object args = jp.getArgs();
        System.out.println(&quot;【前置通知】&quot;  + clzName + &quot;.&quot; + method );
    &#125;
    
    //2.后置通知
    public void doAfter(JoinPoint jp)&#123;
        String clzName = jp.getTarget().getClass().getName();
        //getTarget() 获取即将要执行的对象
        String method = jp.getSignature().getName();//即将要执行的方法
        System.out.println(&quot;【后置通知】&quot;  + clzName + &quot;.&quot; + method );

    &#125;
    
    //3.返回通知
    public void doAfterReturning(JoinPoint jp , Object ret)&#123;
        System.out.println(&quot;【返回后通知】&quot; + ret);
        
    &#125;
    //4.异常通知
    public void doAfterThrowing(JoinPoint jp , Throwable t)&#123;
        System.out.println(&quot;【异常通知】&quot; + t.getMessage());
    &#125;

    //5.环绕通知
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable&#123;
        String clzName = pjp.getTarget().getClass().getName();
        //getTarget() 获取即将要执行的对象
        String method = pjp.getSignature().getName();//即将要执行的方法
        Object args = pjp.getArgs();
        System.out.println(&quot;【前置通知】&quot;  + clzName + &quot;.&quot; + method );
        Object ret = null;
        try &#123;
            ret = pjp.proceed();//执行目标方法
            System.out.println(&quot;【返回后通知】&quot; + ret);
        &#125; catch (Throwable t) &#123;
            // TODO Auto-generated catch block
            System.out.println(&quot;【异常通知】&quot; + t.getMessage());
            throw t;
        &#125;finally&#123;
            System.out.println(&quot;【后置通知】&quot;  + clzName + &quot;.&quot; + method + &quot;()&quot;);
        &#125;
        return ret;
    &#125;
    
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.aop;

import com.imooc.spring.scope.UserDAO;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
//@Transactional(propagation = Propagation.REQUIRED , rollbackFor = Exception.class)
@Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true )
public class UserService &#123;

    public String createUser()&#123;
        //打开事务
        System.out.println(this + &quot;:正在调用UserService.createUser()&quot;);
        //提交事务
        //catch块中回滚事务 - RuntimeException
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">AOPRunner.java
package com.imooc.spring.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AOPRunner &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:aop.xml&quot;);
        UserService userService1 = (UserService)ctx.getBean(&quot;userService&quot;);
        userService1.createUser();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">aop.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/context
 http://www.springframework.org/schema/context/spring-context.xsd
 http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!-- 定义类被Spring IOC容器管理 --&gt;
    &lt;bean name=&quot;sampleAspect&quot; class=&quot;com.imooc.spring.aop.SampleAspect&quot;&gt;&lt;/bean&gt;
    &lt;bean name=&quot;userService&quot; class=&quot;com.imooc.spring.aop.UserService&quot;&gt;&lt;/bean&gt;
    &lt;!-- 配置Spring AOP --&gt;
    &lt;aop:config&gt;
        &lt;!-- 配置过程中引用切面类  sampleAspect是切面 扩展--&gt;
        &lt;aop:aspect ref=&quot;sampleAspect&quot;&gt;
            &lt;!-- PointCut(切点) 限制了切面应用的范围 ↓↓aop作用了哪些方法上↓↓--&gt;
            &lt;aop:pointcut id=&quot;samplePC&quot; expression=&quot;execution(* com.imooc.spring.aop.*Service.create*(..))&quot; /&gt;
            &lt;!-- 定义通知 --&gt;
            &lt;!-- 前置通知 method=对应着SampleAspect.java中的doBefore--&gt;
            &lt;aop:before pointcut-ref=&quot;samplePC&quot; method=&quot;doBefore&quot;/&gt;
            &lt;!-- 后置通知 --&gt;
            &lt;aop:after pointcut-ref=&quot;samplePC&quot; method=&quot;doAfter&quot;/&gt;
            &lt;!-- 返回后通知，注意：返回后通知需要增加retruning属性
            指向doAfterReturning的名为ret的参数，使用ret参数获取方法的返回值 --&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; pointcut-ref=&quot;samplePC&quot; returning=&quot;ret&quot;/&gt; 
&lt;!--3.ret是返回通知里面的参数 public void doAfterReturning(JoinPoint jp , Object ret)--&gt;
             &lt;!-- 异常通知 --&gt;
&lt;!--public void doAfterThrowing(JoinPoint jp , Throwable t)中的Throwable的参数是目标方法所抛出的异常  throwing=&quot;t&quot;相关噢~ --&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; pointcut-ref=&quot;samplePC&quot; throwing=&quot;t&quot;/&gt;
            --&gt;
            &lt;!-- ★★★★ 环绕通知 ★★★★ --&gt;
            &lt;aop:around method=&quot;doAround&quot; pointcut-ref=&quot;samplePC&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="请介绍Spring的声明式事务"><a href="#请介绍Spring的声明式事务" class="headerlink" title="请介绍Spring的声明式事务"></a>请介绍Spring的声明式事务</h3><p>Spring的声明式事务是Spring框架提供的一种管理事务的方法，它允许开发者通过声明的方式管理事务，而不是通过编写繁琐的事务管理代码。这种方式使得事务管理更加解耦，业务逻辑代码不需要直接处理事务的开启、提交、回滚等操作，从而使得代码更加简洁和易于维护。</p>
<ul>
<li>在执行方法前自动开启的事务</li>
<li>声明式事务式指利用AOP自动提交、回滚数据库事务</li>
<li>声明式事务式规则进入方法打开事务，成功提交，<strong>运行时异常</strong>回滚</li>
<li><code>@Transactional</code>是声明式事务的注解 放在类上则所有方法执行此事务 放在方法上则单独方法执行此事务</li>
<li>propagation &#x3D; 确定方法是否启动事务[Propagation.REQUIRED]执行的方法自动使用事务<br>rollbackFor &#x3D; Exception.class在什么时机进行回滚  readOnly &#x3D; true 方法只读</li>
<li>通过程序打开或关闭事务属于<strong>编程式事务</strong></li>
</ul>
<pre><code class="java">UserService.java
package com.imooc.spring.aop;

import com.imooc.spring.scope.UserDAO;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
//@Transactional(propagation = Propagation.REQUIRED , rollbackFor = Exception.class)
@Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true )
public class UserService &#123;
    public String createUser()&#123;
        //进入方法 → 打开事务
        System.out.println(this + &quot;:正在调用UserService.createUser()&quot;);
        //方法执行成功 → 提交事务
        
        //方法抛出运行时异常 → 回滚事务
        //catch块中回滚事务 - RuntimeException[及其子类会自动回滚]
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="使用SpringMVC实现REST风格"><a href="#使用SpringMVC实现REST风格" class="headerlink" title="使用SpringMVC实现REST风格"></a>使用SpringMVC实现REST风格</h3><ul>
<li>REST(表述性状态传递)以URL表示要访问的资源</li>
<li><strong>GET&#x2F;POST&#x2F;PUT&#x2F;DELETE</strong>对应<strong>查询、新增、更新、删除</strong>操作[浏览器不支持PUT和DELETE操作]<br><span style = "color:red"><strong>[用GET对应查询操作(写)、用POST对应新增、更新、删除操作(写)]</strong></span></li>
<li><u>REST风格<strong>只响应的数据</strong>，通常是以JSON形式体现</u></li>
</ul>
<p>以下是一些常用的HTTP方法及其在REST中的用途：</p>
<ul>
<li><strong>GET</strong>：检索资源的表示。</li>
<li><strong>POST</strong>：创建新的资源或子资源。</li>
<li><strong>PUT</strong>：更新或替换资源。</li>
<li><strong>DELETE</strong>：删除资源。</li>
</ul>
<p>REST风格的API通常被称为RESTful API，它们通过使用标准的HTTP方法、状态代码和URI来提供一种简单、一致和可预测的方式来访问和操作网络资源。RESTful API的设计通常遵循一些最佳实践，比如使用名词而不是动词来命名资源，使用HTTP状态码来传达操作的结果等。</p>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;interview-springmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.54&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">web/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">interview-springmvc\src\main\resources\applicationContext.xml
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- 配置扫描的包 --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.interview&quot;/&gt;
    &lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 开启注解模式--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!-- 访问静态资源 --&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt; //所有URL不分层级和格式
            &lt;bean class=&quot;com.imooc.interview.rest.MyInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">Employee.java
package com.imooc.interview.rest;

public class Employee &#123;
    private String name;
    private int age;
    private String department;

    public Employee(String name, int age, String department) &#123;
        this.name = name;
        this.age = age;
        this.department = department;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getDepartment() &#123;
        return department;
    &#125;

    public void setDepartment(String department) &#123;
        this.department = department;
    &#125;
&#125;
</code></pre>
<pre><code class="java">RestfulController.java
package com.imooc.interview.rest;

import com.alibaba.fastjson.JSON;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
@Controller //在IOC容器初始化的情况下自动扫描这个类进行加载并且通知IOC容器 这个是一个MVC中的控制类
//@RestController
public class RestfulController &#123; //&#123;XXX&#125;是路径变量 随时产生变化的 注解@PathVariable(&quot;DEPT&quot;)
    @GetMapping(&quot;/emp/list/&#123;DEPT&#125;&quot;) //响应GET请求 前面的是响应URL输入这个的时候响应下面的方法
    @ResponseBody
    public String list(@PathVariable(&quot;DEPT&quot;) String department) &#123;
        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
        if (department.equals(&quot;RESEARCH&quot;)) &#123;
            list.add(new Employee(&quot;JAMES&quot;, 38, &quot;RESEARCH&quot;));
            list.add(new Employee(&quot;ANDY&quot;, 23, &quot;RESEARCH&quot;));
            list.add(new Employee(&quot;SMITH&quot;, 31, &quot;RESEARCH&quot;));
        &#125;
        return JSON.toJSONString(list);//只返回纯粹的JSON数据 只返回页面名称
        //如何只返回数据不跳转页面呢？ 用 @RespondBoday 直接将返回的数据输出到客户端
//但是可以简化使用 @RestController 所有的可以直接不用写 @RespondBoday
    &#125;
&#125;//前端使用AJAX技术接收数据
</code></pre>
<h3 id="请说明SpringMVC拦截器的作用-底层就是AOP面向切面编程技术"><a href="#请说明SpringMVC拦截器的作用-底层就是AOP面向切面编程技术" class="headerlink" title="请说明SpringMVC拦截器的作用 [底层就是AOP面向切面编程技术]"></a>请说明SpringMVC拦截器的作用 [底层就是AOP面向切面编程技术]</h3><ul>
<li>SpringMVC拦截器用于对控制器方法进行前置、后置处理</li>
<li>拦截器的底层实现技术是AOP(面向切面编程)</li>
<li>拦截器必须实现HandlerInterceptor接口</li>
</ul>
<pre><code class="java">★★ 上一个代码通用 ★★
interview-springmvc\src\main\java\com\imooc\interview\rest\MyInterceptor.java
package com.imooc.interview.rest;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.logging.Logger;

public class MyInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(&quot;进入 preHandle 方法...&quot; + request.getRequestURL().toString());
        return true;
    &#125;
 

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;进入 postHandle 方法...&quot; + request.getRequestURL().toString());
    &#125;
 

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(&quot;进入 afterCompletion 方法...&quot; + request.getRequestURL().toString());
    &#125;
&#125;
====================================================================================
查看上面的applicationContext.xml
&lt;bean&gt;
&lt;!-- 访问静态资源 --&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt; //所有URL不分层级和格式
            &lt;bean class=&quot;com.imooc.interview.rest.MyInterceptor&quot;/&gt; 
            //对上面这个类进行处理和拦截
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/bfd26ff021aa3755cfc43c62bfa86e0b3ef77144/data/SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg"></p>
<h3 id="说明Mybatis的开发过程"><a href="#说明Mybatis的开发过程" class="headerlink" title="说明Mybatis的开发过程"></a>说明Mybatis的开发过程</h3><blockquote>
<p>案例沿用之前的scott.sql表</p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
             
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;interview-mybatis&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.46&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">mybatis.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;!-- 配置数据库连接信息 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接池的方式--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/scott&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mapper/emp.xml&quot;&gt;&lt;/mapper&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">Employee.java
package com.imooc.interview.mybatis.entity;

import java.io.Serializable;
import java.util.Date;

public class Employee implements Serializable &#123;
    private Integer empno;
    private String ename;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Float sal;
    private Float comm;
    private Integer deptno;
&#125;Getter + Setter
</code></pre>
<pre><code class="xml">用于查询的配置文件 emp.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!-- 命名空间是个虚拟的类 --&gt;
&lt;mapper namespace=&quot;com.imooc.interview.mybatis.mapper.EmpMapper&quot;&gt; 
    &lt;cache size=&quot;512&quot; eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;true&quot;/&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;com.imooc.interview.mybatis.entity.Employee&quot; useCache=&quot;false&quot;&gt;
        select * from emp
    &lt;/select&gt;
&lt;!-- 类型是int 把传入的int代入到#&#123;value&#125;中 --&gt;
    &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; 
            resultType=&quot;com.imooc.interview.mybatis.entity.Employee&quot; useCache=&quot;true&quot;&gt;
        select * from emp where empno = #&#123;value&#125;
&lt;!--查询数据 根据数据自动创建Employee对象 根据字段名把值一一的设置到属性中--&gt;
&lt;!--记得写完以后再mybatis.xml中注册 通知mybatis 有个&lt;mapper resource=&quot;mapper/emp.xml&quot;&gt;--&gt;
&lt;!--至此mybatis的配置全部完成 --&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">MybatisRunner.java
package com.imooc.interview.mybatis.entity;

import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.InputStream;

public class MybatisRunner &#123;
    public static void main(String[] args) &#123;
        //mybatis的配置文件 核心配置文件↓
        String resource = &quot;mybatis.xml&quot;;
        InputStream is = MybatisRunner.class.getClassLoader().getResourceAsStream(resource);
        //构建sqlSession的工厂(对Mybatis进行解析)  build(is)是初始化
        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);
//com.imooc.interview.mybatis.mapper.EmpMapper前面是命名空间
        //.findById对应着select的Id
        String statement = &quot;com.imooc.interview.mybatis.mapper.EmpMapper.findById&quot;;
        SqlSession session = sessionFactory.openSession();
//selectOne获取唯一的查询结果  之前定义了要传入整数int
        Employee emp1 = session.selectOne(statement, 7566);
        System.out.println(emp1);
        session.close();
    &#125;
&#125;
</code></pre>
<h3 id="Mybatis的缓存机制"><a href="#Mybatis的缓存机制" class="headerlink" title="Mybatis的缓存机制"></a>Mybatis的缓存机制</h3><h6 id="把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率"><a href="#把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率" class="headerlink" title="把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率"></a>把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率</h6><ul>
<li><p>Mybatis存在两级缓存</p>
<ul>
<li><p>一级缓存与SqlSession会话绑定，默认开启 [巨大的HashMap] [默认开启]</p>
</li>
<li><p>二级缓存是应用全局缓存，所有SqlSession共享 [分布式数据库等]</p>
</li>
</ul>
</li>
</ul>
<pre><code class="java">//一级缓存验证结果
Employee emp1 = session.selectOne(statement, 7566);
Employee emp2 = session.selectOne(statement, 7566);
System.out.println(emp1);
System.out.println(emp2);
======================打印结果========================
com.imooc.interview.mybatis.entity.Employee@6a41eaa2
com.imooc.interview.mybatis.entity.Employee@6a41eaa2
从缓存中将这个7566提出来，所以对象是一样的
随着session的关闭 → session.close(); 一级缓存也随着消失; 输出的对象结果就不相同了
</code></pre>
<pre><code class="java">//二级缓存验证结果  让7566全局缓存 默认是不开启的 需要在mapper中开启 → emp.xml
//在缓存中最大容纳512个对象 缓存多余清除策略[FIFO先进先出算法 LRU访问最少的对象清除] 
//flushInterval=&gt;时间间隔定时清理缓存[毫秒数 每60秒]
&lt;cache size=&quot;512&quot; eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;true&quot;/&gt;
//若对全部查找 则不适合使用缓存 因为每次都变化 这样就可以设置useCache=&quot;false&quot;
&lt;select id=&quot;findAll&quot; resultType=&quot;com.imooc.interview.mybatis.entity.Employee&quot; useCache=&quot;false&quot;&gt;
//对数据进行新增、修改、删除也会对缓存进行强制更新 上面设置 readOnly=&quot;true&quot; 保存在缓存中的数据都是只读的
//二级缓存要对工具类Employee进行接口的实现
public class Employee implements Serializable &#123;...&#125;
</code></pre>
<h3 id="Spring、SpringMVC与SpringBoot的区别"><a href="#Spring、SpringMVC与SpringBoot的区别" class="headerlink" title="Spring、SpringMVC与SpringBoot的区别"></a>Spring、SpringMVC与SpringBoot的区别</h3><ul>
<li>Spring是所有应用的基础，提供了IOC与AOP特性实现对对象轻松的管理</li>
<li>SpringMVC是Spring的子项目用于提供Web支持 替代传统的Servlet [<u>提高兼容性和可维护性</u>]</li>
<li>SpringBoot是Spring体系的敏捷开发框架，提高了开发效率 [<u>对Spring整个体系都有良好的支撑</u>]<ul>
<li>Spring Framework是整个Spring的框架基础</li>
<li>Spring Cloud对分布式架构与微服务提供了良好的支持</li>
<li>Spring Data简化关系型数据库 非关系型数据库 大数据源</li>
<li>Spring Batch提供高效率的批处理任务</li>
<li>Spring Security超级牛逼的安全框架 登录验证之类的</li>
<li>Spring Amqp消息队列进行支持 统一的接口进行适配</li>
<li>Spring Mobile手机开发特性</li>
</ul>
</li>
</ul>
<h3 id="SpringBoot面试题"><a href="#SpringBoot面试题" class="headerlink" title="SpringBoot面试题"></a>SpringBoot面试题</h3><ul>
<li><p>Spring Initializr是创建SpringBoot Project的唯一方法吗？</p>
<blockquote>
<p>否！也可以用Maven进行手动创建，也可以官网创建</p>
</blockquote>
</li>
<li><p>SpringBoot支持几种配置文件？</p>
<blockquote>
<p>只有两种</p>
<pre><code class="xml">一种
server.port=80
debug=false
server.servlet.context-path=/myspringboot
logging.file=d:/logs/msb.log
spring.mvc.date-format=yyyy-MM-dd
</code></pre>
<pre><code class="xml">二种 [按层级进行区分 yml 对程序维护有很大帮助]
debug:false
server:
  port:8000
  servlet:
    context-path:/
spring:
  mvc:
    date-format:yyyy-MM-dd
</code></pre>
</blockquote>
</li>
<li><p>请列举至少五个SpringBoot中配置选项</p>
<table>
<thead>
<tr>
<th>配置名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>server.port</td>
<td>8080</td>
<td>端口号</td>
</tr>
<tr>
<td>server.servlet.context-path</td>
<td>&#x2F;</td>
<td>设置应用上下文</td>
</tr>
<tr>
<td>logging.file</td>
<td>无</td>
<td>日志文件输出路径</td>
</tr>
<tr>
<td>logging.level</td>
<td>info</td>
<td>最低日志输出级别</td>
</tr>
<tr>
<td>debug</td>
<td>false</td>
<td>开启&#x2F;关闭调试模式</td>
</tr>
<tr>
<td>spring.datasource.*</td>
<td></td>
<td>与数据库相关的设置</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="Maven的构建生命周期"><a href="#Maven的构建生命周期" class="headerlink" title="Maven的构建生命周期"></a>Maven的构建生命周期</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mvn archetype:generate</td>
<td align="center">创建Maven工程构建</td>
</tr>
<tr>
<td align="center">mvn validate</td>
<td align="center">验证工程结构</td>
</tr>
<tr>
<td align="center">mvn compile</td>
<td align="center">编译源代码</td>
</tr>
<tr>
<td align="center">mvn test</td>
<td align="center">执行测试用例</td>
</tr>
<tr>
<td align="center">mvn package</td>
<td align="center">项目打包</td>
</tr>
<tr>
<td align="center">mvn install</td>
<td align="center">安装至本地仓库</td>
</tr>
<tr>
<td align="center">mvn deploy</td>
<td align="center">发布至远程仓库</td>
</tr>
</tbody></table>
<h3 id="请简述一下Java反射的作用和原理"><a href="#请简述一下Java反射的作用和原理" class="headerlink" title="请简述一下Java反射的作用和原理"></a>请简述一下Java反射的作用和原理</h3><p><strong>作用：</strong><br>Java反射(Reflection)允许程序在运行时检查和操作类、接口、字段和方法的信息<br>① 动态获取类的信息：获取类的名称、父类、实现的接口等；获取类的构造方法、字段和方法的信息<br>② 动态创建和访问对象：创建类的实例；访问和修改对象的字段；调用对象的方法<br>③ 动态调用方法：调用私有方法、静态方法、实例方法等；传递参数和处理返回值<br>④ 动态代理：创建动态代理类，实现接口和动态代理</p>
<p><strong>原理：</strong><br>① 获取Class对象：<br>   Ⅰ. 通过类名获取：Class.forName(“类的路径”)；<br>  Ⅱ. 通过类字面常量获取：类名.class；<br> Ⅲ. 通过对象获取：对象名.getClass();<br>② 获取类的信息：<br>   Ⅰ. 获取类名：类名.getName;<br>  Ⅱ. 获取父名：类名.getSuperclass();<br> Ⅲ. 获取实现的接口：类名.getInterfaces();<br> Ⅳ. 获取构造方法：类名.getConstructors();<br>  Ⅴ. 获取字段：类名.getFields();<br> Ⅵ. 获取方法：类名.getMethods();</p>
<p><strong>优点和缺点</strong>：<br>优点：能够运行时动态获取类的实例，提高灵活性；与动态编译结合<br>缺点：使用反射性能较低，需要解析字节码，将内存中的对象进行解析<br>  解决办法→通过setAccessible(true)关闭JDK的安全检查来提升反射速度；多次创建一个类的实例时有缓存会快很多</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>；；；；；；；；；；；；；；；；；；；；<strong>洪哥面试题分隔符</strong>；；；；；；；；；；；；；；；；；；；；；；</p>
<h4 id="线程池的执行流程大致如下"><a href="#线程池的执行流程大致如下" class="headerlink" title="线程池的执行流程大致如下:"></a><strong>线程池的执行流程大致如下</strong>:</h4><p>线程池：ThreadPoolExecutor<br>一开始new的时候没有 是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><strong>怎么确定核心线程数和最大线程数</strong>？</p>
<h6 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h6><ul>
<li>CPU密集型任务：如果任务是CPU密集型的，即任务主要是进行计算而不是等待I&#x2F;O操作，核心线程数通常设置为CPU核心数加1。这样可以确保CPU在忙于计算的同时，还有额外的线程来处理可能出现的临时高峰。【纯内存计算 不涉及到网络计算和io计算】<ul>
<li>八个核 创建十个cpu 没意义 因为最多并发只是8，建议保持一致或者+1，<u>减少加入队列和创建队列的开销</u></li>
<li>先把其当成io密集 因为层级不一样 不断压测去逼近最理想值</li>
</ul>
</li>
<li>I&#x2F;O密集型任务：对于I&#x2F;O密集型任务，由于线程在等待I&#x2F;O操作时会阻塞，因此可以设置更多的核心线程数。一个常用的经验法则是核心线程数设置为CPU核心数的两倍。【线程数越多越好】【压测无限逼近取最合适的线程数】</li>
</ul>
<h6 id="最大线程数"><a href="#最大线程数" class="headerlink" title="最大线程数"></a>最大线程数</h6><p>需要一开始创建好线程等着访问来，如果 <u>核心&#x3D;最大</u>，此时没有临时线程</p>
<h4 id="创建线程有几种方式（必会）"><a href="#创建线程有几种方式（必会）" class="headerlink" title="创建线程有几种方式（必会）"></a>创建线程有几种方式（必会）</h4><p>1.继承Thread类并重写 run 方法创建线程，实现简单但不可以继承其他类<br>2.实现Runnable接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。<br>3.实现 Callable接口并重写 call 方法，创建线程。可以获取线程执行结果的返回值，并且可以抛出异常。<br>4.使用线程池创建（使用java.util.concurrent.Executor接口）</p>
<ul>
<li>想获得线程池里的返回结果用什么？<strong>execute + submit</strong></li>
<li>线程有哪些状态？ java线程有哪些状态？</li>
<li>线程池有哪些状态？</li>
</ul>
<h4 id="线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池"><a href="#线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池" class="headerlink" title="线程池哪些类型？通过JUC[包]的executes可以创建这四个类型的线程池"></a>线程池哪些类型？<del>通过JUC[包]的executes可以创建这四个类型的线程池</del></h4><p>问题：为什么阿里巴巴不推荐JUC？有可能会出现OOM、资源浪费</p>
<ul>
<li>单线程线程池</li>
<li>可缓存线程池&#x2F;定长</li>
<li>变长的线程池</li>
<li>定时任务的线程池</li>
</ul>
<h4 id="java-线程池创建时核心参数-高薪常问"><a href="#java-线程池创建时核心参数-高薪常问" class="headerlink" title="java 线程池创建时核心参数(高薪常问)"></a>java 线程池创建时核心参数(高薪常问)</h4><p>核心线程池大小、线程池创建线程的最大个数(核心+非核心[临时线程])、临时线程存活时间、时间单位、阻塞队列、线程工厂(指定线程池创建线程的命名)、拒绝策略<br><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>阻塞队列常用的队列</u>：</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
</ol>
<h4 id="线程池的应用要有实际的业务场景"><a href="#线程池的应用要有实际的业务场景" class="headerlink" title="线程池的应用要有实际的业务场景"></a>线程池的应用<del>要有实际的业务场景</del></h4><ul>
<li>异步任务处理：将任务提交到线程池异步执行，而不阻塞主线程</li>
</ul>
<h4 id="你单独部署过项目吗？"><a href="#你单独部署过项目吗？" class="headerlink" title="你单独部署过项目吗？"></a>你单独部署过项目吗？</h4><p>前端打包ng配置文件<br>git所有人都用 需要拉分支 maven打包后端 包放到远程服务器 java -jar 启动！【不应该有人去做】<br>有专门工具去流水线制作 → <strong>Jenkins</strong>是一个开源的自动化服务器，它可以帮助您实现自动化构建、测试和部署项目   <strong><u>JenKins + docker 做自动化部署</u></strong><br>部署是建立本地的项目再推到服务器</p>
<h4 id="你的期望薪资？"><a href="#你的期望薪资？" class="headerlink" title="你的期望薪资？"></a>你的期望薪资？</h4><p>我目前的薪资是8000，考虑到我即将承担的职责和我的职业发展，我期望的薪资是在现有基础上有所提升，大约在8000到10000之间。当然，我对整体的薪酬包[包括福利、奖金和职业发展机会]也很感兴趣。薪资是如何构成的，包括固定工资、奖金、股权、福利等。</p>
<h4 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h4><h6 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h6><ul>
<li>请求指定的资源。使用GET的目的是获取数据，</li>
<li>数据在URL中传输，通过将数据附在URL之后，以查询字符串的形式出现</li>
<li>由于数据在URL中可见，因此安全性较低，敏感数据不应通过过GET请求发送</li>
<li>URL长度限制通常在2000个字符左右，这意味着GET请求能够传输的数据有限</li>
<li>可以被缓存，也会被浏览器保存在历史记录中</li>
<li>常用于信息查询、数据检索等操作.</li>
</ul>
<h6 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h6><ul>
<li>向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在请求体中。</li>
<li>数据存储在请求体(HTTP消息主体)中，不会密在URL上</li>
<li>数据不会出现在URL中，相对更安全，适合传输敏感信息。</li>
<li>理论上没有大小限制，适用于传输大量数据.</li>
<li>不会被缓存，且不会保存在浏觉器历史记录中</li>
<li>常用于数据提交、表单提交等操作</li>
</ul>
<p>请求行：请求类型 请求方法 url http版本1.1 老式1.0不支持长连接<br>请求头：key value<br>   <u>常见请求头</u>： 请求数据类型，restful基于json<br><strong>Content-Type</strong>：上传文件不用application 要用 multipart&#x2F;form-data”<br><strong>Host</strong>：指定请求的服务器的域名和端口号。<br><strong>User-Agent</strong>：包含发出请求的用户代理软件信息，通常包括浏览器类型和版本<br>请求体：get请求可以有请求体<br>响应：响应行 响应体 状态码 描述<br>  <u>常见响应头</u>：<strong>Content-Type</strong>：返回数据的格式   <strong>Content-Length</strong>：响应体的长度，以字节为单位</p>
<p>post请求也可以用问号的形式拼接到浏览器 也可以用路径参数</p>
<p>很大区别：get一般放在url后面 会展示url和后面参数 会暴露传参隐私  登录接口用post来做 有密码敏感信息<br>表单、密码、长数据用post 不过怕黑客抓包 相对来说安全<br>get请求后面传参的大小限制 理论上没有限制 只是浏览器厂商会有限制<br>get用来查询 post新增提交表单</p>
<h4 id="是否上传过图片"><a href="#是否上传过图片" class="headerlink" title="是否上传过图片"></a>是否上传过图片</h4><p>阿里云是最后存储的<br>完整的上传图片应该：<br><strong>前端</strong>要配合(表单 post提交)  <strong>Content-Type</strong>：上传文件不用application 要用 multipart&#x2F;form-data”  同一个请求能边上传图片和文本数据<br><strong>后端</strong>的操作：传到后端controller接收，有一个类multipart 专门接收二进制数据 图片视频等，有很多api → get input stream封装util 调用upload上传。中小型企业都用阿里云oss 因为要考虑容灾 地震 容易数据丢失，要考虑备份→集群，服务器有物理硬件上限(要有运维成本)，文件维护很专业交给专业的人。阿里云的机房在深圳，广州的人访问会比哈尔滨的更快。光纤受物理限制 越长越有损耗。大型运营商在全国各地都有机房，可以智能判断比如哈尔滨的就去访问黑龙江服务器。CSDN内容分发(收费)</p>
<h4 id="前端传过来的图片怎么设置图片大小-有没有什么办法？"><a href="#前端传过来的图片怎么设置图片大小-有没有什么办法？" class="headerlink" title="前端传过来的图片怎么设置图片大小 有没有什么办法？"></a>前端传过来的图片怎么设置图片大小 有没有什么办法？</h4><p>思考：为什么后端要限制前端图片传的大小？<br>大图片 + 多人上传，首先后端要读到jvm内存再二进制流给到阿里云，同时并发有可能超出OM的java内存大小<br>springboot yml加文件上传大小配置</p>
<pre><code class="yaml">spring:
  servlet:
    multipart:
      max-file-size: 10MB # 单个文件的最大大小
      max-request-size: 20MB # 整个请求的最大大小，包括多个文件的总和
</code></pre>
<h4 id="你在里面主要负责哪方面的工作？"><a href="#你在里面主要负责哪方面的工作？" class="headerlink" title="你在里面主要负责哪方面的工作？"></a>你在里面主要负责哪方面的工作？</h4><p>我之前负责后端开发 也会参与一部分<strong>设计工作</strong><br>开发完会协助测试 和前端进行联调<br>和组长一起进行测试<br>和前后端的逻辑基本上都是可以的</p>
<h4 id="上家公司的离职原因，薪资多少，薪资结构"><a href="#上家公司的离职原因，薪资多少，薪资结构" class="headerlink" title="上家公司的离职原因，薪资多少，薪资结构"></a>上家公司的离职原因，薪资多少，薪资结构</h4><p>不要说一些面试官能挑刺的理由<br>发展前景？表明上家公司不好<br>太想进步？表名上家公司提供的技术不好 自己技术不好<br>在上家公司我学习了很多 成长了很多，个人发展原因 ，想要涨薪</p>
<pre><code class="java">// 来自AI的答案 仅供参考
我在上家公司学到了很多，但我觉得为了我的职业发展，我需要寻找一个能够提供更多成长机会和挑战的职位。我想要在[技能/领域]上进一步深耕，而贵公司的职位看起来非常符合我的职业规划；我在上家公司的年薪大约在6000到7000之间；我的薪资结构主要包括基本工资、每年两次的绩效奖金、股票期权以及一些标准福利，比如健康保险、退休金计划等。此外，公司还提供了一些额外的福利，比如灵活的工作时间和远程工作的机会
</code></pre>
<h6 id="简历公司"><a href="#简历公司" class="headerlink" title="简历公司"></a>简历公司</h6><p>上家公司<strong>如果问工作不好找 为什么不先找到再离职</strong>？<br>我在这一块想好好准备面试 但是上班的时间不好分配 我想专心去找工作<br>上家工作繁忙抽不出时间去准备 所以我想多多准备<br>若<strong>异地</strong>公司 → 万能理由：现在面的公司在哪家里人就在哪[地理位置要接近 精确到哪个城市] 异地很多都线下不方便先离职专心准备</p>
<h6 id="薪资多少"><a href="#薪资多少" class="headerlink" title="薪资多少"></a>薪资多少</h6><p>现在期望12k 上家最好保证**20%-30%**区间→8-9-10k(参考城市不同)</p>
<h6 id="薪资结构"><a href="#薪资结构" class="headerlink" title="薪资结构"></a>薪资结构</h6><p>基本工资(七八成)+绩效工资(20%-30%) 有公司先扣除 有的当月发<br>A 120%  S 150%-200%  C 80%</p>
<h6 id="你对上家公司的看法"><a href="#你对上家公司的看法" class="headerlink" title="你对上家公司的看法"></a>你对上家公司的看法</h6><p>不能贬低 要说优点 学习成长了很多 同事和领导都很照顾我</p>
<h6 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h6><p>三个工作日 到 一周之间</p>
<h6 id="你离职了-现在有多少个offer了？"><a href="#你离职了-现在有多少个offer了？" class="headerlink" title="你离职了 现在有多少个offer了？"></a>你离职了 现在有多少个offer了？</h6><p>不能说一个都没有</p>
<ul>
<li>我已经有2个offer 但是一定要表达对当前公司的期待 经过我的了解 我更喜欢贵公司的发展和文化</li>
<li>我也是刚刚开始找工作…</li>
</ul>
<h4 id="你可以接受加班吗"><a href="#你可以接受加班吗" class="headerlink" title="你可以接受加班吗"></a>你可以接受加班吗</h4><p>(必须完全接受全部加班 先拿到offer再说)</p>
<h4 id="Controller和RestController的区别"><a href="#Controller和RestController的区别" class="headerlink" title="Controller和RestController的区别"></a>Controller和RestController的区别</h4><p>@RestController &#x3D; @Controller + @ResponseBody</p>
<p>@Controller如果要返回JSON&#x2F;XML等格式的数据给客户端，必须显式的使用@ResponseBody注解将返回的对象转换为HTTP响应体内容。<br>@RestController 专门为构建RESTful Web服务设计的控制器。它简化了创建API的过程，因为所有方法默认都会将返回值直接写入HTTP响应体中作为JSON或XML格式的数据。</p>
<p>@Controller可以声明一个类为一个bean 控制器用<br>@ResponseBody 具体方法和类都可以 不是包装类和字符 都可以自动转成json数据格式 更符合restful风格</p>
<h4 id="在yaml文件中定义了一些参数，该怎么调用"><a href="#在yaml文件中定义了一些参数，该怎么调用" class="headerlink" title="在yaml文件中定义了一些参数，该怎么调用"></a><strong>在yaml文件中定义了一些参数，该怎么调用</strong></h4><ul>
<li>使用 @Value 注解，这是最直接的方式，适用于简单的属性注入。是bean的注解 <strong>用${key}还可以用#</strong><ul>
<li><code>$&#123;&#125;</code>：用于注入外部配置文件的值。它告诉Spring需要从环境变量、属性文件、系统属性等地方查找相应的值。</li>
<li><code>#&#123;&#125;</code>：用于执行SpEL（Spring Expression Language，Spring表达式语言）表达式。它允许你在注入值时执行一些简单的计算或逻辑。</li>
<li>如果在多个类里引用 配置多 杂乱  可以写个配置类写一堆的属性 提供get set方法 配置类.get获取到配置</li>
</ul>
</li>
<li>使用 @ConfigurationProperties 注解，通常会指定一个<strong>前缀</strong>（<strong>prefix</strong>），这个前缀用于指定配置文件中哪些属性应该被绑定到这个 Bean 上。<br><code>@ConfigurationProperties(prefix = &quot;prefix&quot;)</code></li>
</ul>
<h4 id="IOC和DI有了解过吗，它们的好处是什么"><a href="#IOC和DI有了解过吗，它们的好处是什么" class="headerlink" title="IOC和DI有了解过吗，它们的好处是什么"></a>IOC和DI有了解过吗，它们的好处是什么</h4><p><span style = "color:red">它们的目的是为了<strong>解耦</strong></span><br>IOC(控制反转)是Spring的两大核心之一，DI(依赖注入)<br>IOC把控制权交给spring容器<br>对象创建好之后 之间会有依赖关系 DI因此而生<br>实现方式：DI通常有四种实现方式</p>
<ul>
<li><p><strong>属性注入</strong> <del>注解注入</del></p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，用于自动装配 Bean。它可以用于字段、构造函数、方法或设置器上。当 Spring 容器启动时，它会自动查找并注入匹配的 Bean。<ul>
<li>偶尔有不影响程序运行的报错？写spring技术人员是根据jdk写，怕别人不用。</li>
</ul>
</li>
<li><code>@Resource</code> 是 Java 的注解[JDK的]，用于依赖注入，它也可以用于字段、方法或设置器上。与 <code>@Autowired</code> 不同的是，<code>@Resource</code> 默认通过名称进行匹配，如果未指定名称，则尝试通过类型进行匹配。</li>
<li>两者区别<ul>
<li>@Autowired 先根据<strong>属性类型</strong> 去容器里面找 如果找不到 再根据**属性名称[字段]**去找 如果实在找不到就会报错 [@Autowired永远不会放弃你的 尽其所能去帮你找]</li>
<li>@Resource 先根据属性名称去找 要么找不到 要么找到一个 找到就去注入 如果找不到 可以再根据属性类型去找 [类型找不到 或者 找到多个 也会报错]</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>构造函数注入</strong> [默认生成空参构造方法 若写有参构造原来无参会被覆盖 参数根据类型去找和@Autowired类型一样 可以写多个构造方法 如果去多个构造方法重载会报错 怎么办？加个<code>@Autowired[属性,构造方法,参数]都可加</code> 不可多个方法都加@Autowired  反射会触发构造方法 @Bean &#x3D;&gt; new ] </p>
</li>
<li><p>Set方法注入[原生spring 用xml去定义才有 SpringBoot没有这个注入 ]</p>
</li>
<li><p><strong>普通方法注入</strong></p>
</li>
</ul>
<h4 id="测试过程有没有出现反复的困扰"><a href="#测试过程有没有出现反复的困扰" class="headerlink" title="测试过程有没有出现反复的困扰?"></a>测试过程有没有出现反复的困扰?</h4><p>客户<strong>需求频繁更改</strong><br>测试用例没有覆盖到<br>开发和测试环境未协调</p>
<p>太复杂的改动要先报备技术经理、项目经理</p>
<p>测试：自测 单元测试 专业人员</p>
<h4 id="公司使用哪些技术？"><a href="#公司使用哪些技术？" class="headerlink" title="公司使用哪些技术？"></a>公司使用哪些技术？</h4><p>后端：Redis RabbitMQ 搜索引擎 微服务常用组件 远程调用 统一网关 Springboot Springcloud MybatisPlus</p>
<h4 id="项目有多少个成员？"><a href="#项目有多少个成员？" class="headerlink" title="项目有多少个成员？"></a>项目有多少个成员？</h4><p>2前 8后 1测 1运维 1项目经理(小公司约13人左右) 要具体人数<br>自研公司？外包？</p>
<p><strong>自研公司</strong>：</p>
<ul>
<li>创业型自研公司：通常员工人数在10-50人之间，初期可能更少，只有几人到十几人。</li>
<li>成熟自研公司：员工人数可能从几十人到几百人甚至更多。</li>
</ul>
<p><strong>外包公司</strong>：</p>
<ul>
<li>小型外包公司：员工人数可能在10-50人之间。</li>
<li>中型外包公司：员工人数可能在50-200人之间。</li>
<li>大型外包公司：员工人数可能超过200人。</li>
</ul>
<h4 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h4><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>jdk1.8之前底层结构是<strong>数组+链表</strong>(key+value)  数据结构通用的[键值对+哈希表的数据结构]<br>jdk1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时且数组长度大于64时，将链表转化为红黑树，以减少搜索时间。扩容 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。后期使用map获取值时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>底层的地址运算出来 如果地址不一样计算出来的hashcode不一样，hashcode一般是数字[整数(±或0)] 通过key进行hashcode运算 对数组长度取模 eg：任何整数去取模10   可以定位到value可以放在哪个桶下面</p>
<p>hashcode本身不同的对象算出来的hashcde值是相同的怎么办呢？<br>两个value不可能放在同一个桶 这就是hash冲突  如果数组长度是8 算出来一个hashcode值是8 和 16 此时取模余数相同这样的情况也是相同。所以此时应该用<strong>拉链法</strong>[小葡萄串]，即使桶一样 可以用指针一个个指，此时的链表是单项链表[linkedlist才是双向链表]。拉链法的解决哈希冲突。<br>在1.8后指出如果同一个桶的葡萄串太多了，此时要拿出数据，时间复杂度就是O(n)，如果没有很多就是O(1)数组的长度。红黑树的引入是解决链表过长的问题。<br>红黑树是树形的高级数据结构 时间复杂度O(logn)<br>二叉树在某些情况下会退化成链表 右子树永远比根节点大<br>红黑树会旋转自平衡[局部旋转达到平衡] 超过多少层会旋转 不至于退化成链表。</p>
<h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>new的初始化 数组为空<br>当第一次put的时候才不会为空 为16<br>扩容因子为什么是0.75？hashmap不仅仅java 其他语言也有这种数据结构 但扩容因子可能不同，是通过大量的数学概率统计出的最好最平衡的值。达到12的时候会扩容成2倍<br>new一个hashmap可以指定数组长度为7 此时数组长度是8【hashmap的长度永远是2的幂次方 比你传入的长度永远大 且 是2的幂次方】 为什么2的幂次方？因为1.7要数组取模 怎么打这个符号 shift+5 &#x3D;&gt; %，1.8之后用了位运算，&gt;&gt;2 &lt;&lt;2 让你的取模运算更快。如果出现hash冲突会拉链 当它的<strong>数组长度</strong>大于64 并且 <strong>链表长度</strong>大于8时，当链表长度小于等于6临界值会变回来【为什么是6？避免频繁切换(离8太近) 链表 ←→ 红黑树[消耗性能]】</p>
<p>链表1.7之前是头插法 会产生一条首尾相接的死循环【并发情况<del>[但是hashmap线程不安全不会用在并发，要用ConcurrentHashMap]</del>一起put 且 同一个桶】<br>1.8之后是尾插法，并发情况下不会出现cpu飙高，</p>
<h5 id="HashSet底层数据结构"><a href="#HashSet底层数据结构" class="headerlink" title="HashSet底层数据结构"></a>HashSet底层数据结构</h5><p>底层是包装了一个hashmap，无序 key不允许重复  value可重复<br>HashSet单列无序不重复的 key就是那个元素 value就是new了一个无意义的object对象</p>
<p>ArrayList和LinkedList不是线程安全的 用什么？</p>
<ul>
<li>Vector 读写都加锁。</li>
<li>CopyOnWriteArrayList读不加锁 写加锁</li>
</ul>
<p>ConcurrentHashMap能存null吗？不允许使用 <code>null</code> 作为键，但是允许使用 <code>null</code> 作为值。<br>HashMap：null默认放在第一个桶下面 下标写死为0</p>
<h6 id="Hashcode相同equals一定相同吗？"><a href="#Hashcode相同equals一定相同吗？" class="headerlink" title="Hashcode相同equals一定相同吗？"></a>Hashcode相同equals一定相同吗？</h6><p><code>hashCode()</code> 相同不一定意味着 <code>equals()</code> 相同，但 <code>equals()</code> 相同则 <code>hashCode()</code> 必须相同。</p>
<ul>
<li><code>equals()</code> 方法用于判断两个对象是否逻辑上相等。</li>
<li><code>hashCode()</code> 方法用于返回对象的哈希码，这个哈希码通常用于哈希表的快速查找。</li>
</ul>
<p>key可以放复合对象，要注意要重写 hashcode()和equals() 如果不重写 new了的两个对象有可能会相同<br><code>&quot;重地&quot;</code> 和 <code>&quot;通话&quot;</code> 。计算hashcode会比equals更快，一个对象new出来后hashcode已经计算出来了。equals要比较每个对象值，所以先判断hashcode 再判断equals   重写：@Override 用属性里面的hashcode，user里面包含了复杂对象order 此时order也要重写。包装类已经重写了hashcode，要整个对象返回true才为正确的，要层层递进去判断。hashmap重写复杂对象就一定要重写那俩个 ∵ 是比较对象里的属性值<br>list 有序可重复单列<br>map 双列key不能重复value可重复  treemap是有序的<br>set 单列不重复无序 hashset 无序 treeset 有序 </p>
<p>&#x3D;&#x3D; 值 + 地址值<br>equals 是对象属性值是否一 一相等</p>
<h4 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h4><p>不安全的，可以使用ConcurrentHashMap、Collections.synchronizedMap()、<strong>HashTable</strong><br><strong>线程安全</strong>：多线程对同一个数据进行增删改是否受到影响<br>怎么办？</p>
<ul>
<li><p><strong>加锁</strong></p>
<ul>
<li>synchronized</li>
<li>ReentrantLock</li>
</ul>
<p>加锁为什么能解决线程安全问题？线程访问资源的先后顺序<br>多线程访问同一个数据 &#x3D;&gt; 多个线程访问同一个数据<br><strong>秒杀</strong> &#x3D;&gt;[思想] 1w个人买 对 100个库存进行扣减，只搞100个线程 把100个库存分成10份 其中每份有10个</p>
<pre><code class="java">初始化库存： 创建一个共享的库存计数器，初始值为100。
创建线程： 创建100个线程，每个线程在启动时分配到一个特定的库存分片。
扣减库存： 每个线程尝试扣减其分配到的库存分片中的一个商品。扣减操作必须是原子的，以确保线程安全。
同步机制： 使用适当的同步机制（如synchronized关键字、ReentrantLock等）来保护库存扣减操作，防止并发问题。
库存检查： 在扣减前，线程需要检查当前分片是否有剩余库存。如果没有，则线程可以终止或进行其他处理。
</code></pre>
<p>hashtable不管读写都会用synchronized加锁，并发一起来读都加锁 没必要，所以用了ConcurrentHashMap读不加锁 写加锁。<br>随着时间的推移，<code>Hashtable</code> 已经被认为是遗留代码，现代Java代码更倾向于使用 <code>HashMap</code>（非线程安全）或 <code>ConcurrentHashMap</code>（线程安全）。</p>
</li>
</ul>
<h4 id="红黑树查询效率高的原因"><a href="#红黑树查询效率高的原因" class="headerlink" title="红黑树查询效率高的原因"></a>红黑树查询效率高的原因</h4><p>红黑树是一种自平衡的二叉搜索树，它通过特定的规则来保持树的平衡，这些规则确保了树的高度大约是log(n)<br>自平衡 局部旋转 </p>
<p>hashMap时间复杂度</p>
<ul>
<li>O(1)：不涉及到拉链</li>
<li>O(n)：拉链不是树</li>
<li>O(logn)：桶为红黑树</li>
</ul>
<h4 id="这个测试是你做的吗，还是你们团队去做的？"><a href="#这个测试是你做的吗，还是你们团队去做的？" class="headerlink" title="这个测试是你做的吗，还是你们团队去做的？"></a>这个测试是你做的吗，还是你们团队去做的？</h4><p>像自测的话是我自己去做的(测试用例、apifox)，然后交给专业测试人员</p>
<h4 id="团队是怎么协作的？"><a href="#团队是怎么协作的？" class="headerlink" title="团队是怎么协作的？"></a>团队是怎么协作的？</h4><p>像我们团队的话，有使用禅道来做我们的文档管理，需求管理和需求的变更控制，和工作的一个统计报表，大部分的协作任务都可以在禅道上完成，代码这一块我们是使用git来做一个代码管理和协作的。</p>
<h4 id="linux查看每个文件夹下的文件大小的命令"><a href="#linux查看每个文件夹下的文件大小的命令" class="headerlink" title="linux查看每个文件夹下的文件大小的命令"></a>linux查看每个文件夹下的文件大小的命令</h4><p>ls -lh</p>
<h4 id="linux查看文件夹大小的命令"><a href="#linux查看文件夹大小的命令" class="headerlink" title="linux查看文件夹大小的命令"></a>linux查看文件夹大小的命令</h4><p>du -sh<br>du -sh –all 隐藏<br>du -sh .&#x2F;* : 单独列出各子项占用的容量</p>
<h4 id="linux查看进程的命令，动态查看一个文件的最后100行的命令"><a href="#linux查看进程的命令，动态查看一个文件的最后100行的命令" class="headerlink" title="linux查看进程的命令，动态查看一个文件的最后100行的命令"></a>linux查看进程的命令，动态查看一个文件的最后100行的命令</h4><p>ps -ef<br>ps aux [查看所有用户的进程（包括其他用户的进程）：]<br>ps -ef | grep mysql</p>
<p><strong>动态</strong>：tail  -n 100 -f xxx 【-f → follow】<br><strong>静态</strong>：tail  -n 100 xxx</p>
<h4 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h4><h6 id="rm-x3D-romove"><a href="#rm-x3D-romove" class="headerlink" title="rm &#x3D; romove"></a>rm &#x3D; romove</h6><p>用于删除文件和目录<br> rm [-rf] name<br>-r(recursive递归)：将目录及目录中所有文件（目录）逐一删除，即递归删除<br>-f(force)：无需确认，直接删除</p>
<h6 id="rmdir-x3D-remove-directory"><a href="#rmdir-x3D-remove-directory" class="headerlink" title="rmdir &#x3D; remove directory"></a>rmdir &#x3D; remove directory</h6><p>它用于删除空目录。如果目录不为空，即目录中包含文件或其他子目录，rmdir 命令将无法删除该目录</p>
<h6 id="pwd-x3D-print-working-directory"><a href="#pwd-x3D-print-working-directory" class="headerlink" title="pwd &#x3D; print working directory"></a>pwd &#x3D; print working directory</h6><p>打印出当前工作目录的绝对路径。当你需要知道你在文件系统中的当前位置时，这个命令非常有用</p>
<h6 id="cp-x3D-copy"><a href="#cp-x3D-copy" class="headerlink" title="cp &#x3D; copy"></a>cp &#x3D; copy</h6><p>复制文件和目录。这个命令可以用来创建文件的副本或将文件从一个位置移动到另一个位置。<br>cp [-r] source dest<br>-r (recursive递归)：如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件</p>
<h6 id="mv-x3D-move"><a href="#mv-x3D-move" class="headerlink" title="mv &#x3D; move"></a>mv &#x3D; move</h6><p>为文件或目录改名、或将文件或目录移动到其他位置【移动 重命名 修改】</p>
<h6 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h6><p>用于搜索文本数据，特别是使用正则表达式来匹配指定的模式<br>查看特定进程的详细信息，例如进程名为 <u>mysql</u><br>ps -ef | grep mysql</p>
<h6 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar [tape archive]"></a>tar [tape archive]</h6><p>用于打包多个文件和目录到一个归档文件中，或者从归档文件中提取文件</p>
<h6 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h6><p>切换路径</p>
<h6 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h6><p>编辑文件</p>
<h6 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h6><p>查看文件[head]</p>
<h6 id="如何查日志"><a href="#如何查日志" class="headerlink" title="如何查日志"></a>如何查日志</h6><p>查看<code>/var/log/user.log</code>文件，并且想要跟踪用户 <u>name：<code>pcy</code></u> 的活动</p>
<p>tail -f &#x2F;var&#x2F;log&#x2F;user.log | grep “pcy”<br><span style = "color:red"><strong>高级专用使用</strong></span>：<code>awk</code> 可以用正则等一些逻辑操作去获取日志</p>
<blockquote>
<h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p><code>awk</code> 非常强大，可以用于执行复杂的文本分析和报告生成，<code>awk</code> 有许多内建函数，如 <code>length()</code>、<code>toupper()</code>、<code>tolower()</code> 等。</p>
<p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;print toupper($0)&#125;&#39; filename  # 将所有内容转换为大写
</code></pre>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;if ($1 &gt; 100) print$1&#125;&#39; filename
</code></pre>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;for (i=1; i&lt;=NF; i++) print $i&#125;&#39; filename
</code></pre>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;count[$1]++&#125; END &#123;for (word in count) print word, count[word]&#125;&#39; filename
</code></pre>
</blockquote>
<h4 id="你们接口是如何让前端调用的"><a href="#你们接口是如何让前端调用的" class="headerlink" title="你们接口是如何让前端调用的"></a>你们接口是如何让前端调用的</h4><p>我们会在设计阶段提前设计好给前端 并行开发 前后端联调[本地ip端口告诉前端]</p>
<h4 id="接口文档怎么定下来的"><a href="#接口文档怎么定下来的" class="headerlink" title="接口文档怎么定下来的"></a>接口文档怎么定下来的</h4><p>根据页面原型、需求设计接口文档[后端自己写]，绝大部分后端看原型的出参入参 无太大需求和前端商量。【前端组件库】[若修改返回结构的时候] [按照数据结构修改] 需要听前端意见</p>
<h4 id="前端调用后端用的是什么请求方式"><a href="#前端调用后端用的是什么请求方式" class="headerlink" title="前端调用后端用的是什么请求方式"></a>前端调用后端用的是什么请求方式</h4><p>WebSocket【基于长连接通讯】<br>HTTP</p>
<blockquote>
<p>前端开发中，以下是一些常见的使用场景：</p>
<ul>
<li>获取数据：使用GET请求。</li>
<li>提交表单或数据：使用POST请求。</li>
<li>更新资源：使用PUT或PATCH请求。</li>
<li>删除资源：使用DELETE请求。</li>
</ul>
<p>前端可以通过多种方式发起这些请求，例如：</p>
<ul>
<li>使用HTML表单（通常用于GET和POST请求）。</li>
<li>使用JavaScript的<code>XMLHttpRequest</code>对象或者更现代的<code>fetch</code> API来发起各种类型的HTTP请求。</li>
<li>使用各种前端框架和库（如React, Angular, Vue.js）中提供的封装好的HTTP服务。</li>
</ul>
</blockquote>
<h4 id="SpringBoot主要的一些注解？都有哪些，以及主要作用"><a href="#SpringBoot主要的一些注解？都有哪些，以及主要作用" class="headerlink" title="SpringBoot主要的一些注解？都有哪些，以及主要作用"></a><strong>SpringBoot主要的一些注解？都有哪些，以及主要作用</strong></h4><pre><code class="java">SpringBoot：
@SpringBootApplication [见↓↓]
@ConfigurationProperties：注解用于将外部配置（如来自properties文件、YAML文件或环境变量）绑定到JavaBean上。它的作用是将配置文件中的属性映射到JavaBean的属性上，这样就可以在应用程序中使用这些配置属性。
@SpringBootTest：用于测试 Spring Boot 应用，提供测试环境的支持
@EnableConfigurationProperties：启用对配置属性的支持，允许将配置文件中的属性注入到 bean 中。


Spring：
@Component 
@ComponentScan 
@Conditional 
</code></pre>
<pre><code class="java">@SpringBootApplication 是一个组合注解，它结合了以下三个注解的功能：
1. @SpringBootConfiguration: 表示这是一个Spring Boot配置类，它本质上是一个@Configuration注解，用于定义配置类，可以包含多个@Bean注解的方法。
2. @EnableAutoConfiguration: 告诉Spring Boot基于类路径设置、其他bean和各种属性设置来添加bean。例如，如果你添加了spring-webmvc和thymeleaf的依赖，这个注解就会自动配置你的应用程序为一个web应用程序。
3. @ComponentScan: 告诉Spring在包及其子包下扫描注解定义的组件（如@Component, @Service, @Repository等）。
</code></pre>
<h4 id="aop在项目中有没有使用？aop使用的一些注解及其功能"><a href="#aop在项目中有没有使用？aop使用的一些注解及其功能" class="headerlink" title="aop在项目中有没有使用？aop使用的一些注解及其功能"></a><strong>aop在项目中有没有使用？aop使用的一些注解及其功能</strong></h4><p>一定要描述项目场景，web使用aop打印操作日志、使用aop做数据脱敏(150***8786)<br><u>过滤器</u>是Servlet技术的一部分，它是Java EE规范的一部分<br><u>拦截器</u>是Spring MVC框架的一部分，用于在处理HTTP请求时拦截控制器方法调用。<br>AOP底层是动态代理设计模式，在<u>理论上</u>效果在一定程度上相同<br>过滤器拦截器一般拦截某个web的前后，在controller执行前后<br>AOP是万物皆可拦截、甚至接口和类都可以切，可以增强controller、service、mapper……</p>
<p>定义一个切面类 <code>@Aspect</code> 声明为切面类 + @Component<br>定义切点 <code>@Pointcut</code> 声明切点表达式</p>
<blockquote>
<p>eg：@AfterReturning(pointcut &#x3D; “execution(public String com.example.yourpackage.Controller.*(..))”, returning &#x3D; “result”)</p>
</blockquote>
<h6 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h6><ul>
<li>前置  @Before</li>
<li>后置  @After</li>
<li>返回  @AfterReturning</li>
<li>异常  @AfterThrowing</li>
<li>环绕  @Around</li>
</ul>
<h4 id="你在公司里负责的内容"><a href="#你在公司里负责的内容" class="headerlink" title="你在公司里负责的内容"></a><strong>你在公司里负责的内容</strong></h4><h4 id="想在controller访问完之后，想在aop实现之后再进行操作"><a href="#想在controller访问完之后，想在aop实现之后再进行操作" class="headerlink" title="想在controller访问完之后，想在aop实现之后再进行操作"></a><strong>想在controller访问完之后，想在aop实现之后再进行操作</strong></h4><p>UserThreadLocal 在执行完之后要 remove 出去，抛异常也会执行<br>@After 不管有无异常都会执行<br>@Around 结合try…catch…finally 里也可以达到同样效果</p>
<blockquote>
<p><code>@After</code>：这个注解用于定义一个通知（Advice），它在目标方法执行之后执行，无论目标方法执行的结果如何（成功或异常）。</p>
</blockquote>
<pre><code class="java">@Aspect
@Component
public class AroundFinallyAspect &#123;

    // 定义切点
    @Pointcut(&quot;execution(* com.example.yourpackage.controller..*(..))&quot;)
    public void controllerMethods() &#123;
    &#125;

    // 环绕通知
    @Around(&quot;controllerMethods()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        Object result = null;
        try &#123;
            // 在目标方法执行之前执行
            result = joinPoint.proceed(); // 执行目标方法
            // 在目标方法成功执行之后执行
        &#125; catch (Throwable e) &#123;
            // 在目标方法抛出异常时执行
            throw e; // 可以选择处理异常或者重新抛出
        &#125; finally &#123;
            // 无论目标方法是否成功执行或者是否抛出异常，这里的代码都会执行
            performFinallyAction();
        &#125;
        return result;
    &#125;

    private void performFinallyAction() &#123;
        // 在这里放置最终要执行的代码
    &#125;
&#125;

--------------------------------------------------------------------------------
// 后置通知
    @After(&quot;execution(* com.example.service.*.*(..))&quot;)
    public void afterAdvice(JoinPoint joinPoint) &#123;
        // 在目标方法执行之后执行的逻辑
    &#125;

    // 返回后通知
    @AfterReturning(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;, returning = &quot;result&quot;)
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) &#123;
        // 在目标方法成功执行并返回结果后执行的逻辑
    &#125;

在第一个例子中，你直接在@After注解中指定了切点表达式，因此不需要额外的pointcut属性。

对于@AfterReturning注解，它不仅需要在目标方法执行之后执行通知，还需要访问目标方法的返回值。因此，@AfterReturning注解有一个额外的pointcut属性，用于指定切点表达式。此外，@AfterReturning注解还有一个returning属性，用于指定一个参数名，该参数将接收目标方法的返回值
</code></pre>
<p>@AfterReturning：在方法执行后返回结果后执行通知。【如果有异常不会处理】</p>
<h4 id="你们这个项目怎么技术选型的"><a href="#你们这个项目怎么技术选型的" class="headerlink" title="你们这个项目怎么技术选型的"></a>你们这个项目怎么技术选型的</h4><p>我进到项目中很多已经确认下来的 一般由组长确定了</p>
<h6 id="那你自己怎么想的？-开放性问题"><a href="#那你自己怎么想的？-开放性问题" class="headerlink" title="那你自己怎么想的？[开放性问题]"></a>那你自己怎么想的？[开放性问题]</h6><p>选xxx技术 网上资料&#x2F;备书 比较多可以参考[用的人多]<br>学习成本[框架厉害但上手复杂不好用]<br>社区的活跃度[官网持续更新版本 框架会不断发展]</p>
<h4 id="你处于后端的什么位置"><a href="#你处于后端的什么位置" class="headerlink" title="你处于后端的什么位置"></a>你处于后端的什么位置</h4><p>初级 中级 高级<br>中级 骨干开发位置[协助组长完成]<br>中高级 完成设计类</p>
<h4 id="你对你的职业规划是什么"><a href="#你对你的职业规划是什么" class="headerlink" title="你对你的职业规划是什么"></a>你对你的职业规划是什么</h4><p>讲实际的话<br>想成为高级开发&#x2F;某个领域的专家<br>提前了解公司领域，有备而来</p>
<h4 id="java基本类型"><a href="#java基本类型" class="headerlink" title="java基本类型"></a>java基本类型</h4><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20241222141950707.png" alt="image-20241222141950707" style="zoom:200%;" />

<p>short   可以占两个字节   可以用16位<br>int        可以占四个字节    -21亿 ~ 21亿<br>long     可以占八个字节   天文数字<br>float      可以占四个字节 0.2F&#x2F;f<br>double  可以占八个字节 0.2D&#x2F;d</p>
<p>float double尽量不要进行运算 ，在Java中进行金钱运算时，应当特别注意浮点数的精度问题，因为浮点数（如<code>float</code>和<code>double</code>）在表示某些数值时可能会丢失精度，这对于需要精确计算的金融计算来说是非常不合适的。</p>
<p>1.金钱转成分 向下取整<br>2.BigDecimal</p>
<p>ASCII码占1个字节 → Unicode字符占2个字节【有些汉字存不了】→ UTF-8占1-3个字节[灵活可变]<br>在我们性能中一般走Unicode编码性能更高一点 在网络中&#x2F;存入磁盘Unicode转成ASCII码</p>
<p>jdk？之后 jdk开始存储大量英文和数字 String类也作了更新 不是基于基本数据类型 而是基于byte数组</p>
<pre><code class="java">在Java的早期版本中（例如JDK 1.4及之前版本），String类内部确实使用char数组来存储字符串数据。每个char在Java中占用16位（2个字节），这意味着不管存储的是英文字符还是数字，每个字符都会占用2个字节的内存空间。

从JDK 5开始，Java平台引入了一些变化，但String类的内部表示仍然基于char数组。直到JDK 6和JDK 7，String类的内部表示并没有改为基于byte数组。

真正发生变化的是在JDK 9中，String类内部表示从char数组转变为byte数组加上一个编码标识（coder），这种改变是为了更有效地存储只有ASCII字符的字符串。ASCII字符只需要一个字节来表示，因此使用byte数组可以节省内存空间。当字符串包含Unicode字符时，String类可能会使用更多的编码方式，例如LATIN1或UTF-16。
</code></pre>
<h4 id="String是基础类型吗"><a href="#String是基础类型吗" class="headerlink" title="String是基础类型吗"></a>String是基础类型吗</h4><p>不是，是<code>java.lang</code>下的类</p>
<blockquote>
<p>String 在 Java 中并不是基础类型，而是一个引用类型。因为 String 是一个类，所以它是引用类型，意味着当我们声明一个 String 变量时，你实际上是指向一个 String 对象的引用</p>
</blockquote>
<pre><code class="java">String 的特性
不可变性：String 对象一旦创建就不能被修改。任何改变 String 内容的操作都会创建一个新的 String 对象。
线程安全：由于 String 的不可变性，它们是线程安全的，可以自由地在多个线程之间共享。
字符串池：为了提高性能和减少内存使用，Java 为 String 提供了字符串常量池（String Pool）。当创建一个新字符串时，如果字符串池中已经存在相同内容的字符串，则会返回池中的实例，而不是创建新的对象。
</code></pre>
<h4 id="java集合中list和set的区别"><a href="#java集合中list和set的区别" class="headerlink" title="java集合中list和set的区别?"></a>java集合中list和set的区别?</h4><p>都是接口 某个实现类</p>
<p>单链 有顺序 可重复 有索引[有下标]<br>单链 不可重复 无索引[无下标] 不能说是无序 因为TreeSet有序 HashSet就是无序的</p>
<h4 id="做了几年开发呢-实际几个项目"><a href="#做了几年开发呢-实际几个项目" class="headerlink" title="做了几年开发呢? 实际几个项目?"></a>做了几年开发呢? 实际几个项目?</h4><p>三年[初中级] → 四~五个项目</p>
<h4 id="你觉得敲代码最重要的是什么"><a href="#你觉得敲代码最重要的是什么" class="headerlink" title="你觉得敲代码最重要的是什么?"></a>你觉得敲代码最重要的是什么?</h4><p><strong>理解需求</strong>、<strong>前期设计工作</strong>[数据库、接口 → 流程图(思路清晰)]、<strong>编码阶段</strong>[考虑方法封装、注释、考虑代码后期和维护性(设计模式 → 可维护性+扩展性)]、<strong>编码风格</strong>[阿里巴巴规范]</p>
<h4 id="你的项目有上线吗-多少人进行开发-你主要负责后端吗"><a href="#你的项目有上线吗-多少人进行开发-你主要负责后端吗" class="headerlink" title="你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?"></a>你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?</h4><p>有，介绍一下项目组成结构，是的[再问再回答]</p>
<h4 id="SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件"><a href="#SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件" class="headerlink" title="SpringBoot的自动装配原理[启动过程中的一部分]SpringBoot启动原理&amp;&amp;如何内嵌外部原件"></a><span style = "color:red"><strong>SpringBoot的自动装配原理</strong></span>[启动过程中的一部分]<del>SpringBoot启动原理&amp;&amp;如何内嵌外部原件</del></h4><p>Spring Boot的自动装配原理是基于Spring框架的IoC（控制反转）和DI（依赖注入）的核心概念，并结合了一系列的约定和条件注解来实现配置类的自动加载和Bean的自动注册</p>
<h6 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h6><pre><code class="xml">&lt;!-- Maven项目的依赖示例 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.xxx&lt;/groupId&gt;
    &lt;artifactId&gt;xxx-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>三大优点</strong>：依赖Maven特性[依赖传递]  自动配置  内嵌Tomcat<br>Spring Boot的自动装配原理是<br>在<code>src/main/resources/META-INF</code>目录下创建<code>spring.factories</code>文件，添加自动配置类的全限定名<br>我们可以在-info定义spring.factories位于<code>META-INF</code>目录下，Spring Boot使用它来发现和加载自动配置类。</p>
<p><strong>配置类扫描</strong>: 通过<code>@SpringBootApplication</code>注解，Spring Boot会触发对<code>@EnableAutoConfiguration</code>注解的处理，该注解会查找<code>spring.factories</code>文件中定义的自动配置类。</p>
<p>Maven里面写test类 用configuration声明 写很多的test类 但是我可以自己写test类然后调不同的方法 <strong>应该怎么办</strong>？@Conditional[Spring的注解] → 做成非常灵活的 如果没有就用自己写的 </p>
<h4 id="Spring里面的事务传播行为"><a href="#Spring里面的事务传播行为" class="headerlink" title="Spring里面的事务传播行为"></a><strong>Spring里面的事务传播行为</strong></h4><p>在Spring框架中，事务传播行为定义了事务方法之间的调用关系，即一个事务方法被另一个事务方法调用时，事务应该如何传播。</p>
<ol>
<li><span style = "color:blue"><u><strong>REQUIRED</strong>（默认值）</u></span> required<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
</ul>
</li>
<li><strong>SUPPORTS</strong> supports<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</li>
</ul>
</li>
<li><strong>MANDATORY</strong> mandatory<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
</ul>
</li>
<li><strong>REQUIRES_NEW</strong> requires_new<ul>
<li>创建一个新的事务，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NOT_SUPPORTED</strong> not_supported<ul>
<li>以非事务方式执行操作，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NEVER</strong> never<ul>
<li>以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ul>
</li>
<li><strong>NESTED</strong> nested<ul>
<li>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则行为类似于<code>REQUIRED</code>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>REQUIRED：通常用于方法需要在一个事务中运行，但如果已经有一个事务在运行，那么它应该加入这个事务。<br>SUPPORTS：用于方法不需要事务上下文，但如果已经在一个事务中，它也可以在这个事务中运行。<br>MANDATORY：用于方法必须在事务中运行，如果没有事务，则会抛出异常。<br><strong>REQUIRES_NEW</strong>：用于方法必须在自己的新事务中运行，即使当前已经有一个事务在运行。<br>[一般适用于不管有没有抛出异常 都要记录某些操作日志 不能在同一个类里底层是动态代理]<br>[如果a()和b()方法在同一个类中，并且a()直接调用b()，那么Spring的事务代理无法拦截这个内部调用，因此b()的REQUIRES_NEW事务传播行为不会生效。这是因为内部方法调用不会通过代理，而是直接在同一个对象实例上调用。]</p>
<pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.annotation.Propagation;

@Service
public class MyService &#123;

    @Autowired
    private MyService self; // 注入自身代理实例

    public void methodA() &#123;
        // ... 业务逻辑 ...

        self.methodB(); // 通过代理实例调用，事务注解将生效
    &#125;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() &#123;
        // ... 业务逻辑 ...
    &#125;
&#125;
</code></pre>
<p>NOT_SUPPORTED：用于方法不应该在事务中运行，如果有一个事务在运行，它将被挂起。<br>NEVER：用于方法绝对不应该在事务中运行，如果有一个事务在运行，将抛出异常。<br>NESTED：用于方法应该在嵌套事务中运行，嵌套事务可以独立于外部事务进行提交或回滚</p>
</blockquote>
<h4 id="用过Spring的事务吗"><a href="#用过Spring的事务吗" class="headerlink" title="用过Spring的事务吗"></a><strong>用过Spring的事务吗</strong></h4><p>一组数据库的增删改操作<br><strong>声明式事务管理</strong>：这是Spring推荐的用法，它通过使用注解（如<code>@Transactional</code>）或基于XML的配置来声明事务边界。底层基于AOP实现动态代理增强方法<br><strong>编程式事务管理</strong>：允许你通过编程的方式直接管理事务，通常使用<code>TransactionTemplate</code>或者直接使用底层的<code>PlatformTransactionManager</code>。</p>
<h4 id="你熟悉的技术栈有哪些，用了哪些"><a href="#你熟悉的技术栈有哪些，用了哪些" class="headerlink" title="你熟悉的技术栈有哪些，用了哪些?"></a>你熟悉的技术栈有哪些，用了哪些?</h4><p>SpringBoot Vue Git Maven MyBatis……</p>
<h4 id="解决难点的决策有和用户沟通的吗？"><a href="#解决难点的决策有和用户沟通的吗？" class="headerlink" title="解决难点的决策有和用户沟通的吗？"></a>解决难点的决策有和用户沟通的吗？</h4><p>有过沟通 让他们了解一下我们的方案</p>
<h6 id="万一用户听不懂怎么办？"><a href="#万一用户听不懂怎么办？" class="headerlink" title="万一用户听不懂怎么办？"></a>万一用户听不懂怎么办？</h6><p>我会用一些更加直白通俗的语言让用户理解我们的方案</p>
<h6 id="用户不接受这个方案怎么办？"><a href="#用户不接受这个方案怎么办？" class="headerlink" title="用户不接受这个方案怎么办？"></a>用户不接受这个方案怎么办？</h6><p>我们可以提供不止一个方案 或者 提供他提的方案 综合一下各种方案告诉其优缺点(站在我们的专业角度意见)和风险 让客户明知 让其选择</p>
<h4 id="通常一般怎么学习的？最近在研究什么技术？"><a href="#通常一般怎么学习的？最近在研究什么技术？" class="headerlink" title="通常一般怎么学习的？最近在研究什么技术？"></a>通常一般怎么学习的？<del>最近在研究什么技术？</del></h4><p>想面试的目的 要給公司带来一些好的<br>一般<strong>以公司的实际项目中为切入点</strong>去学习会更有效率</p>
<h5 id="学习一个新的技术大概要多久？"><a href="#学习一个新的技术大概要多久？" class="headerlink" title="学习一个新的技术大概要多久？"></a>学习一个新的技术大概要多久？</h5><p>1-2天 首先看官网 这个技术是解决哪些 看我们的项目需要哪些技术切入点能引用 然后去专门针对这个技术功能点去学习快速上手的接口文档</p>
<h4 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h4><ul>
<li><strong>主数据基于内存操作</strong></li>
<li><strong>Redis是单线程</strong>[操作数据的线程]，避免上下文的频繁切换<del>整个redis不是就一个线程</del></li>
<li><strong>底层基于C语言实现</strong> <del>得益于底层良好的数据结构[]</del></li>
<li><strong>基于<span style = "color:red">非阻塞</span>的IO</strong><del>提升IO读写性能，NIO,BIO,AIO…</del></li>
</ul>
<h6 id="Java四大杀手"><a href="#Java四大杀手" class="headerlink" title="Java四大杀手"></a>Java四大杀手</h6><p><u>集合数据结构     jvm    并发编程    网络IO</u></p>
<h4 id="redis的数据类型以及使用场景分别是什么"><a href="#redis的数据类型以及使用场景分别是什么" class="headerlink" title="redis的数据类型以及使用场景分别是什么"></a>redis的数据类型以及使用场景分别是什么</h4><ul>
<li><strong>String</strong>：存储对象信息(转JSON)、</li>
<li><strong>List</strong>：链表，查询记录的缓存、列表，朋友圈，微博，队列数据结构</li>
<li><strong>Hash</strong>：获取局部属性，小key不能设置过期时间</li>
<li><strong>Set</strong>：无序不可重复的，收藏，点赞，社交场景，聚合计算(∩∪差集)</li>
<li><strong>Zset</strong>：排序场景，排行榜，姓名排序</li>
</ul>
<p>分布式锁都可以用。Redisson是Redis的儿子，底层为Hash</p>
<h4 id="redis数据过期策略"><a href="#redis数据过期策略" class="headerlink" title="redis数据过期策略"></a>redis数据过期策略</h4><ul>
<li>惰性删除：键过期时不会立即删除，当访问该键时判断是否过期，如果过期就删除</li>
<li>定时删除：设置键的过期时间，当键过期时，立即删除</li>
</ul>
<h6 id="高薪冲刺-→-定时删除详细策略"><a href="#高薪冲刺-→-定时删除详细策略" class="headerlink" title="高薪冲刺 → 定时删除详细策略"></a><span style = "color:red">高薪冲刺 → 定时删除详细策略</span></h6><blockquote>
<p>要扫描所有的定期任务删除 有策略可以设置阈值</p>
</blockquote>
<h4 id="啥时候离职的？半个月太长了"><a href="#啥时候离职的？半个月太长了" class="headerlink" title="啥时候离职的？半个月太长了"></a>啥时候离职的？<del>半个月太长了</del></h4><p>刚刚离职 也是刚刚开始投</p>
<h4 id="主要工作职责"><a href="#主要工作职责" class="headerlink" title="主要工作职责"></a>主要工作职责</h4><p>主要负责后端工作，协助测试，运维上线</p>
<h4 id="你对前端有了解过吗？"><a href="#你对前端有了解过吗？" class="headerlink" title="你对前端有了解过吗？"></a>你对前端有了解过吗？</h4><p>有了解过，如HTML、CSS、JavaScript、框架[Vue、Element]等 可以很快的上手<br><u>我主要专长在于后端开发，可以学习和了解更多的前端知识</u>。</p>
<h4 id="各种淘汰策略介绍"><a href="#各种淘汰策略介绍" class="headerlink" title="各种淘汰策略介绍"></a>各种淘汰策略介绍</h4><blockquote>
<p>Redis提供了8种淘汰策略，可以分成两大类：</p>
<p><strong>1、针对所有键的策略：</strong>对所有键进行选择和淘汰。</p>
<p><strong>2、仅针对有过期时间的键的策略：</strong>只在设置了过期时间的键中选择淘汰对象。</p>
</blockquote>
<p><strong>以下具体策略：</strong><br><strong>可以区分为两类</strong>：[有设置过期时间的key  不管你有没有设置过期时间]</p>
<h5 id="1-noeviction【默认】"><a href="#1-noeviction【默认】" class="headerlink" title="1. noeviction【默认】"></a>1. <strong>noeviction</strong>【默认】</h5><ul>
<li><strong>描述</strong>：达到内存限制时，不再执行删除操作，直接拒绝所有写入请求（包括插入和更新）。[可以读 但是拒绝写请求]</li>
<li><strong>适用场景</strong>：<u>希望数据永不丢失的场景</u>，但需要保证内存充足，否则会导致写入操作失败。</li>
</ul>
<h5 id="2-allkeys-lru（最近最少使用）"><a href="#2-allkeys-lru（最近最少使用）" class="headerlink" title="2. allkeys-lru（最近最少使用）"></a>2. <strong>allkeys-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：在所有的键中使用 LRU算法，删除最近最少使用的键。</li>
<li><strong>适用场景</strong>：适合缓存场景，保留<strong>频繁访问</strong>的键，逐出很少被访问的键。</li>
</ul>
<h5 id="3-allkeys-lfu（最少使用频率）【电商】"><a href="#3-allkeys-lfu（最少使用频率）【电商】" class="headerlink" title="3. allkeys-lfu（最少使用频率）【电商】"></a>3. <strong>allkeys-lfu（最少使用频率）</strong>【电商】</h5><ul>
<li><strong>描述</strong>：在所有键中使用 LFU 算法，删除使用频率最低的键。</li>
<li><strong>适用场景</strong>：适用于需根据<strong>使用频率</strong>进行淘汰的场景，更关注访问次数而非访问时间。</li>
</ul>
<h5 id="4-volatile-lru（最近最少使用）"><a href="#4-volatile-lru（最近最少使用）" class="headerlink" title="4. volatile-lru（最近最少使用）"></a>4. <strong>volatile-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LRU 算法。</li>
<li><strong>适用场景</strong>：适合缓存一些有过期时间的数据，希望根据<strong>访问频率</strong>来进行内存管理的场景。</li>
</ul>
<h5 id="5-volatile-lfu（最少使用频率）【电商】"><a href="#5-volatile-lfu（最少使用频率）【电商】" class="headerlink" title="5. volatile-lfu（最少使用频率）【电商】"></a>5. <strong>volatile-lfu（最少使用频率）【电商】</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LFU算法。</li>
<li><strong>适用场景</strong>：同 volatile-lru，但更关注<strong>使用频率</strong>。</li>
</ul>
<h5 id="6-allkeys-random"><a href="#6-allkeys-random" class="headerlink" title="6. allkeys-random"></a>6. <strong>allkeys-random</strong></h5><ul>
<li><strong>描述</strong>：在所有键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适用于缓存数据访问频率没有明显差异的情况。</li>
</ul>
<h5 id="7-volatile-random"><a href="#7-volatile-random" class="headerlink" title="7. volatile-random"></a>7. <strong>volatile-random</strong></h5><ul>
<li><strong>描述</strong>：在所有设置了过期时间的键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适合缓存带有过期时间的数据，删除哪个数据不重要的场景。</li>
</ul>
<h5 id="8-volatile-ttl"><a href="#8-volatile-ttl" class="headerlink" title="8. volatile-ttl"></a>8. <strong>volatile-ttl</strong></h5><ul>
<li><strong>描述</strong>：在设置了过期时间的键中，优先删除剩余生存时间（TTL）较短的键。</li>
<li><strong>适用场景</strong>：适合希望优先清理<strong>即将过期</strong>的数据的场景。</li>
</ul>
<h4 id="缓存三兄弟-穿透、击穿、雪崩"><a href="#缓存三兄弟-穿透、击穿、雪崩" class="headerlink" title="缓存三兄弟(穿透、击穿、雪崩)"></a>缓存三兄弟(穿透、击穿、雪崩)</h4><p>一般在读缓存的时候出现的问题。<strong>思路</strong>：产生的原因 + 解决的方案</p>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：用户或前端查询到一个在数据库中不存在的数据，先查redis再走数据库。对数据库压力会很大。<u>关系型数据库是性能的瓶颈 希望把高数量都挡在数据库前面</u>。查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong> 【空字符串】<del>没有Null的数据类型</del>下一次读取直接把空串返回<br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</li>
</ul>
<p>如果一直模拟一个不同的不存在的key 这时候就要用到<strong>布隆过滤器</strong></p>
<ul>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)<br> [商品读多写少上缓存，要把商品数据写到布隆过滤器中，以商品的id<del>独一无二</del>计算hashcode，用布隆过滤器。取模数组落到桶内 会把0置为1]<br>有很多个二进制数组每个二进制数组用不同的hash算法进行计算此时落到的桶就不一样<br>作用：读的时候 前端传id 之前怎么写进去就怎么拿出来。[位运算(与)速度很快 把多个数组的数据拿出来与运算如果都是1 则这个数据可能存在<del>再查一遍缓存</del> 若不存在直接return返回] 布隆过滤器说你不存在 一定不存在，说你存在 则可能存在[哈希冲突] </p>
<h6 id="★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？"><a href="#★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？" class="headerlink" title="★ 项目上线很久了 商品早就下架不卖了 这时候会发生什么问题？"></a>★ 项目上线很久了 商品早就下架不卖了 <strong>这时候会发生什么问题</strong>？</h6><p>这时候布隆过滤器还有之前的痕迹，需要把那些1设置为0。<br>布隆过滤器 不支持对某个的1设置0 → 因为有哈希冲突<del>我不知道这个1曾经是誰设置的</del><br>支持将整个都置为0，之后可以搞个定时任务<br><strong>布隆过滤器具体实现</strong>：Redis、Redission<del>亲儿子</del>、1cache、咖啡因（Caffeine<del>提供了一种非常高效且易于使用的缓存解决方案，它支持多种缓存过期策略</del>）、Guava<del>谷歌</del></p>
<h6 id="★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据"><a href="#★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据" class="headerlink" title="★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 怎么解决？存量数据"></a>★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 <strong>怎么解决</strong>？<del>存量数据</del></h6><p>写一个定时任务</p>
<h6 id="★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了"><a href="#★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了" class="headerlink" title="★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)用户量太多了"></a>★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)<del>用户量太多了</del></h6><p>搞一个二进制数组，10亿长度的数组，每个数组是一个bit &#x3D; 10亿个位，一个字节<del>1&#x2F;bit</del>&#x3D;8个位，综合计算后大概消耗119MB的空间<del>每天</del>。用用户id去hash 如果用户登录将0置为1<del>有单独的位图结构</del>，统计时间就可以拿日期 往前面数 拿某个id去取模得到桶 找前七个，去进行与运算，连续为1就达到了重复连续七天前端。否则非连续七天。</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<p>**bitmap（位图）<del>巨大的二进制数组</del>**：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大 【要数组足够大 误判率就小】</p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给某<strong>一个</strong>热点key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿<del>微博[鹿晗+关晓彤]</del>【并发同一时间访问】</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】[控制一个个来访问的次数]</p>
<p><del>AQS、ReentrantLock</del>是进程级别的互斥锁，因为有数据在节点1或节点2，<strong>分布式锁</strong>是在不同场景都可以锁也可以控制访问顺序。</p>
<p>以商品id作为key  先redis开始查缓存 判断是否为空 不为空直接return后解锁，空就先<strong>加锁</strong> 去数据库查完备份一份redis后<strong>解锁</strong>。被锁的其他线程在外面等待。</p>
<h6 id="★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"><a href="#★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。" class="headerlink" title="★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"></a>★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。</h6><p>方案：**<u>双重缓存校验</u>**  先查缓存 查不到加锁 再查缓存 查不到再去数据库 查完后看是否备份后解锁<del>冷代码</del></p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[  <u><em>不设置过期时间</em></u>  ] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内<strong>大量</strong>的缓存key同时失效或者<u>Redis服务宕机</u>，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值<del>不在同一时间过期</del></li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<h6 id="★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？"><a href="#★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？" class="headerlink" title="★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？"></a>★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？</h6><p>try catch 在里面继续再去查mysql数据库</p>
<h6 id="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"><a href="#降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。" class="headerlink" title="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"></a>降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。</h6><pre><code class="java">public boolean setData(String key, String value) &#123;
    try &#123;
        // 尝试将数据设置到Redis
        redisTemplate.opsForValue().set(key, value);
        return true;
    &#125; catch (Exception e) &#123;
        // 日志记录Redis错误
        log.error(&quot;Redis is down, failing over to MySQL&quot;, e);
        
        // Redis设置失败，降级到MySQL
        return setDataToMySQL(key, value);
    &#125;
&#125;

private boolean setDataToMySQL(String key, String value) &#123;
    // 这里实现将数据写入MySQL的逻辑
    // 例如：
    // mySqlTemplate.update(&quot;INSERT INTO cache (key, value) VALUES (?, ?)&quot;, key, value);
    // 注意：这里的mySqlTemplate和SQL语句需要根据实际情况调整
    return true; // 假设写入成功
&#125;
</code></pre>
<h6 id="如果公司对要求更高，需要限流降级、熔断"><a href="#如果公司对要求更高，需要限流降级、熔断" class="headerlink" title="如果公司对要求更高，需要限流降级、熔断"></a>如果公司对要求更高，需要限流<del>降级、熔断</del></h6><p>同一时间设置QPS为100 超过的返回友好提示[商品太火爆啦，请稍后再试]</p>
<h4 id="你有自己部署过环境吗"><a href="#你有自己部署过环境吗" class="headerlink" title="你有自己部署过环境吗"></a>你有自己部署过环境吗</h4><p>公司里面用 Jenkins + docker 测试环境我们部署 生产环境是组长部署</p>
<h4 id="未来1-3年规划"><a href="#未来1-3年规划" class="headerlink" title="未来1-3年规划"></a>未来1-3年规划</h4><p>将具体一点，从业务技术上提升自己的深度和广度达到高级工程师</p>
<h4 id="你平时做笔记吗"><a href="#你平时做笔记吗" class="headerlink" title="你平时做笔记吗"></a>你平时做笔记吗</h4><p>有做笔记 Xmind + Markdown<br>因为我觉得无论从网上的还是别人请教的不经历我的消化都不是我的东西<br>我还是会将这些知识点总结起来变成自己的知识</p>
<h4 id="什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？"><a href="#什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？" class="headerlink" title="什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？"></a>什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？</h4><h6 id="代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式"><a href="#代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式" class="headerlink" title="代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系装饰者模式"></a>代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系<del>装饰者模式</del></h6><p>在程序运行期间才会产生代理类加载到我们jvm中</p>
<ul>
<li><h6 id="JDK动态代理是基于接口实现来实现增强"><a href="#JDK动态代理是基于接口实现来实现增强" class="headerlink" title="JDK动态代理是基于接口实现来实现增强"></a>JDK动态代理是基于接口实现来实现增强</h6><p>[txt文本 把目标增强类 作为接口<del>本身就是接口</del> 实现过来写成源码 源文件 再用jdk工具把源码编译成class字节码 再用类加载器把class加载到jvm中]</p>
</li>
<li><h6 id="CGLIB动态代理是基于继承目标类并覆写其方法来实现"><a href="#CGLIB动态代理是基于继承目标类并覆写其方法来实现" class="headerlink" title="CGLIB动态代理是基于继承目标类并覆写其方法来实现"></a>CGLIB动态代理是基于继承目标类并覆写其方法来实现</h6><p>[ASN字节码机制直接生成class 直接加载到内存中]<del>性能较高，速度更快。因为直接生成class</del></p>
</li>
</ul>
<p>要调用某个方法 CGLIB性能高 是通过反射来实现的 老版本的jdk的反射性能较低。如今在调用方法的性能上差距不大</p>
<p><strong>区别</strong>：</p>
<ul>
<li>JDK动态代理要求目标类必须实现一个或多个接口，而CGLIB没有这个要求。</li>
<li>JDK动态代理生成的代理类是接口的实现，而CGLIB生成的代理类是目标类的子类。</li>
<li>性能上，CGLIB通常比JDK动态代理更快，因为它直接操作字节码生成新的类。</li>
</ul>
<h4 id="什么样的代码是静态代理？"><a href="#什么样的代码是静态代理？" class="headerlink" title="什么样的代码是静态代理？"></a>什么样的代码是静态代理？</h4><p>发生在我们写代码的过程中 在编译阶段产生了代理类<br>静态代理是指代理类在编译时就已经确定，通常由程序员手动编写</p>
<h4 id="你用过Linux吗？"><a href="#你用过Linux吗？" class="headerlink" title="你用过Linux吗？"></a>你用过Linux吗？</h4><p>是的，我在工作中经常使用Linux操作系统。我熟悉Linux的基本命令<br>基础的命令：xxx【查看之前笔记】</p>
<h4 id="你工作的时候有需求文档吗？"><a href="#你工作的时候有需求文档吗？" class="headerlink" title="你工作的时候有需求文档吗？"></a>你工作的时候有需求文档吗？</h4><p>有的，有一些简单的需求是没有的[沟通成本太高了]<br>稍微复杂的需求会有需求文档，我会根据需求文档来理解项目需求，并进行系统设计和开发。</p>
<h4 id="你有什么需要了解的？不要难为面试官-不问技术栈"><a href="#你有什么需要了解的？不要难为面试官-不问技术栈" class="headerlink" title="你有什么需要了解的？不要难为面试官,不问技术栈"></a><span style="color:red">你有什么需要了解的？</span><del>不要难为面试官,不问技术栈</del></h4><p>我想了解一下贵公司的业务是什么…好的那我这块已经没有什么想了解的了 <span style="color:red">感谢面试官</span><br>HR：想了解一下贵公司的上班时间…<br>我没有什么想了解的，来之前有了解过贵公司</p>
<h4 id="平时用注解创建的bean是单例的还是多例的？"><a href="#平时用注解创建的bean是单例的还是多例的？" class="headerlink" title="平时用注解创建的bean是单例的还是多例的？"></a>平时用注解创建的bean是单例的还是多例的？</h4><p>默认情况下，通过注解（如@Component、@Service、@Repository、@Bean等）创建的Bean是单例的。如果需要创建多例Bean，可以在注解上添加@Scope(“prototype”)来指定。</p>
<h4 id="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"><a href="#SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？" class="headerlink" title="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"></a>SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？</h4><p><code>FROM -&gt; Join -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY -&gt; limit</code><br>这样的顺序是为了优化查询性能。首先确定数据来源（FROM），然后筛选出满足条件的数据（WHERE），接着进行分组（GROUP BY），在分组的基础上进行进一步筛选（HAVING），然后选择需要的数据（SELECT），最后对结果进行排序（ORDER BY）。这样的顺序可以减少中间结果集的大小，提高查询效率。</p>
<h6 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h6><p><code>select -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; having -&gt; order by -&gt; limit</code></p>
<h4 id="线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答"><a href="#线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答" class="headerlink" title="线上项目发生死锁如何去解决？ 我暂时没遇到过→分布式事务上去答"></a>线上项目发生死锁如何去解决？ <del>我暂时没遇到过→分布式事务上去答</del></h4><p><strong>死锁</strong>：两个线程争夺两个资源的时候  <code>1线程拿到a 想拿b   2线程拿到了b 想拿a</code><br><strong>四个原因</strong>：<u>互斥条件 请求保持 不可剥夺 循环等待</u><br>产生死锁的四个因素 同时满足才会死锁     想要解决死锁 需要打破其中一个原因就行</p>
<blockquote>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时使用。即某个资源在一段时间内只能由一个线程占用，其他线程必须等待该资源被释放后才能使用。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源又被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：已经分配给某个线程的资源在该线程完成任务前不能被抢占，即只能由线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一种线程资源的循环等待链，每个线程都在等待下一个线程所持有的资源。</li>
</ol>
</blockquote>
<blockquote>
<h4 id="在实际操作中，以下是一些打破死锁的具体方法："><a href="#在实际操作中，以下是一些打破死锁的具体方法：" class="headerlink" title="在实际操作中，以下是一些打破死锁的具体方法："></a>在实际操作中，以下是一些打破死锁的具体方法：</h4><ul>
<li><strong>资源分配图</strong>：使用资源分配图来检测循环等待条件，并在检测到循环时采取措施。</li>
<li><strong>锁排序</strong>：确保所有线程以相同的顺序获取锁，从而避免循环等待。</li>
<li><strong>超时机制</strong>：线程在请求资源时设置超时时间，如果超过时间未获得资源，则放弃当前任务并释放已持有的资源。</li>
<li><strong>死锁检测算法</strong>：运行死锁检测算法，如银行家算法，来检测系统中的死锁，并在必要时采取措施。</li>
<li><strong>线程中断</strong>：允许系统或其他线程中断正在等待资源的线程。</li>
<li><strong>回滚操作</strong>：如果检测到死锁，可以让某些线程回滚它们的工作，并释放资源，从而打破死锁。</li>
</ul>
</blockquote>
<p>MySQL是不会有死锁的 自身会检测 [让后面的超时释放回滚]<br>在分布式事务 线程1拿着资源a是数据库1 线程2拿着资源b是数据库2<br>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<h4 id="如果你遇到-新的-技术栈，怎么去解决"><a href="#如果你遇到-新的-技术栈，怎么去解决" class="headerlink" title="如果你遇到(新的)技术栈，怎么去解决?"></a>如果你遇到(新的)技术栈，怎么去解决?</h4><p>【return Previous.notes(NowDay);】</p>
<h4 id="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通"><a href="#如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通" class="headerlink" title="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?"></a>如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?</h4><p>首先尝试自己解决问题，通过搜索引擎、官方文档、Debug等。<br>尽可能不让这个问题不出现风险 实在解决不了就向上反馈 寻求帮助 请教上司领导或同事<br>平常和项目经理进行沟通 如果需求评审有些不理解还是会及时沟通 不清楚的一定要及时明确</p>
<h4 id="对于加班情况怎么看"><a href="#对于加班情况怎么看" class="headerlink" title="对于加班情况怎么看?"></a>对于加班情况怎么看?</h4><p>为了确保项目进度和团队利益，加班是可以接受的。</p>
<h4 id="多线程怎么保证线程之间的安全"><a href="#多线程怎么保证线程之间的安全" class="headerlink" title="多线程怎么保证线程之间的安全"></a>多线程怎么保证线程之间的安全</h4><h6 id="加锁-不让多线程抢夺资源"><a href="#加锁-不让多线程抢夺资源" class="headerlink" title="加锁  不让多线程抢夺资源"></a>加锁  不让多线程抢夺资源</h6><p>互斥锁、读写锁、线程局部存储(ThreadLocal每个线程独享自己变量)</p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h4 id="mybatis中-和-的区别，哪个更好-为什么"><a href="#mybatis中-和-的区别，哪个更好-为什么" class="headerlink" title="mybatis中${}和#{}的区别，哪个更好? 为什么?"></a>mybatis中${}和#{}的区别，哪个更好? 为什么?</h4><ol>
<li><h5 id="（字符串替换）："><a href="#（字符串替换）：" class="headerlink" title="${}（字符串替换）："></a><code>$&#123;&#125;</code>（字符串替换）：</h5><ul>
<li><code>$&#123;&#125;</code>会将参数直接替换到SQL语句中，不进行任何转义处理。</li>
<li>它适用于动态SQL中的表名或列名，或者在SQL语句中需要使用特定数据库函数的情况。</li>
<li>使用<code>$&#123;&#125;</code>时，如果参数是用户输入的，那么可能会引发SQL注入攻击，因为它不会对参数进行转义。</li>
</ul>
</li>
<li><h5 id="（预处理语句参数）："><a href="#（预处理语句参数）：" class="headerlink" title="#{}（预处理语句参数）："></a><code>#&#123;&#125;</code>（预处理语句参数）：</h5><ul>
<li><code>#&#123;&#125;</code>会创建预处理语句（prepared statement）的参数占位符，并在设置参数时进行适当的转义处理。</li>
<li>它适用于大部分情况，特别是当参数是用户输入时，可以有效防止SQL注入攻击。</li>
<li>MyBatis会根据参数的类型自动选择<code>setString</code>、<code>setInt</code>、<code>setDate</code>等预处理语句方法。</li>
</ul>
</li>
<li><h5 id="在大多数情况下，-是更好的选择，因为它提供了以下优势："><a href="#在大多数情况下，-是更好的选择，因为它提供了以下优势：" class="headerlink" title="在大多数情况下，#{}是更好的选择，因为它提供了以下优势："></a>在大多数情况下，<code>#&#123;&#125;</code>是更好的选择，因为它提供了以下优势：</h5><ul>
<li><strong>安全性</strong>：<code>#&#123;&#125;</code>可以防止SQL注入攻击，因为它会自动转义参数。</li>
<li><strong>类型处理</strong>：MyBatis会根据参数的实际类型来设置预处理语句的参数，这减少了类型错误的可能性。</li>
<li><strong>可读性和维护性</strong>：使用<code>#&#123;&#125;</code>可以使SQL语句更加清晰，因为它清楚地标识了参数的位置。</li>
</ul>
<p>然而，在某些特定的场景下，如需要动态地指定表名或列名时，<code>$&#123;&#125;</code>是必要的，因为预处理语句</p>
</li>
</ol>
<h4 id="说一下内连接和外连接的区别"><a href="#说一下内连接和外连接的区别" class="headerlink" title="说一下内连接和外连接的区别"></a>说一下内连接和外连接的区别</h4><p><strong>左外连接（Left Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：左外连接返回左表中的所有行，即使在右表中没有匹配的行。对于左表中没有匹配的行，结果集中的右表部分将包含NULL。</li>
</ul>
<p><strong>右外连接（Right Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：右外连接返回右表中的所有行，即使在左表中没有匹配的行。对于右表中没有匹配的行，结果集中的左表部分将包含NULL。</li>
</ul>
<p><strong>全外连接（Full Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：全外连接返回左表和右表中的所有行。当某行在另一个表中没有匹配时，结果集中的相应部分将包含NULL。</li>
</ul>
<h4 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>xxx</p>
<h4 id="你觉得学习我们这些技术最重要的是什么"><a href="#你觉得学习我们这些技术最重要的是什么" class="headerlink" title="你觉得学习我们这些技术最重要的是什么?"></a>你觉得学习我们这些技术最重要的是什么?</h4><p>首先要清楚这个技术是解决什么领域的问题，学习技术很多方面都是用来服务业务的，结合实际业务来学习技术融合性会更强</p>
<h4 id="技术栈有些不同，有没有想过换方向发展"><a href="#技术栈有些不同，有没有想过换方向发展" class="headerlink" title="技术栈有些不同，有没有想过换方向发展?"></a>技术栈有些不同，有没有想过换方向发展?</h4><p>没问题的 因为技术是相通的 可以去学新技术</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>ThreadLocal(定义全局静态变量 项目中共用)是Java中的一个线程局部变量工具类，它提供了一种在多线程环境下，每个线程都可以独立访问自己的变量副本的机制。ThreadLocal中存储的数据对于每个线程来说都是独立的，互不干扰。</p>
<h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h2><p>ThreadLocal适用于以下场景：</p>
<ul>
<li>在多线程环境下，需要保持线程安全性的数据访问。</li>
<li>需要在多个方法之间共享数据，但又不希望使用传递参数的方式。<ul>
<li>在传递登录用户id是非常方便且适用</li>
</ul>
</li>
</ul>
<p>以后获取用户id不用再解析token了，线程拿仅仅拿当前线程的数据 每个登录的用户都有自己的threadlocal数据</p>
<p><strong>ThreadLocal</strong>并不是一个Thread，<strong>而是Thread的局部变量</strong>【可以存储数据】<br>ThreadLocal<strong>为每个线程提供单独一份存储空间</strong>，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。**<u>ThreadLocal实现一个线程内传递数据</u>**[就不用一个个参数往后传递了]<br>注意：客户端发送的每次请求，后端的tomcat服务器都会分配一个单独的线程来处理请求</p>
<ul>
<li><strong><u>一个请求是一个线程</u></strong>[意义：在第一个线程里面使用ThreadLocal存储用户Id 在后面controller或service中就可以取出来用户id]</li>
<li>第二个请求就是另一个线程 线程池用完第一个放回线程池 也有可能把上一个线程接着给它用</li>
</ul>
<p><code>postHandle </code>只有在正确调用返回才会引用 如果抛出异常则不会使用<br><code>afterCompletion </code>无论怎样最后都要运行</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h6 id="3-1-创建ThreadLocal对象"><a href="#3-1-创建ThreadLocal对象" class="headerlink" title="3.1 创建ThreadLocal对象"></a>3.1 创建ThreadLocal对象</h6><p>首先，我们需要创建一个ThreadLocal对象来存储线程局部变量。可以使用ThreadLocal的默认构造函数创建一个新的实例。【给每个线程拷贝一份 synchn + Lock锁】</p>
<pre><code class="Java">ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</code></pre>
<h6 id="3-2-设置线程局部变量的值"><a href="#3-2-设置线程局部变量的值" class="headerlink" title="3.2 设置线程局部变量的值"></a>3.2 设置线程局部变量的值</h6><p>使用<code>set()</code>方法可以设置当前线程的局部变量的值。</p>
<pre><code class="Java">threadLocal.set(&quot;value&quot;);
</code></pre>
<h6 id="3-3-获取线程局部变量的值"><a href="#3-3-获取线程局部变量的值" class="headerlink" title="3.3 获取线程局部变量的值"></a>3.3 获取线程局部变量的值</h6><p>使用<code>get()</code>方法可以获取当前线程的局部变量的值。</p>
<pre><code class="Java">String value = threadLocal.get();
</code></pre>
<h6 id="3-4-清除线程局部变量的值"><a href="#3-4-清除线程局部变量的值" class="headerlink" title="3.4 清除线程局部变量的值"></a>3.4 清除线程局部变量的值</h6><p>使用<code>remove()</code>方法可以清除当前线程的局部变量的值，建议在整个请求使用完一定要执行remove清除数据，不然可能会发生内存泄漏问题。</p>
<pre><code class="Java">threadLocal.remove();
</code></pre>
<h6 id="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"><a href="#下面是一个简单的示例代码，演示了如何使用ThreadLocal。" class="headerlink" title="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"></a>下面是一个简单的示例代码，演示了如何使用ThreadLocal。</h6><pre><code class="Java">public class ThreadLocalTest &#123;

    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();

    public static void main(String[] args) &#123;

        Thread t1 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itheima&quot;);
            getData(&quot;t1&quot;);
        &#125;, &quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itcast&quot;);
            getData(&quot;t2&quot;);
        &#125;, &quot;t1&quot;);

        t1.start();
        t2.start();

    &#125;

    private static void getData(String threadName)&#123;
        Object data = THREAD_LOCAL.get();
        System.out.println(threadName+&quot;-&quot;+data);
    &#125;
&#125;
</code></pre>
<p>运行以上代码，输出结果为：</p>
<pre><code class="Plain">t1-itheima
t2-itcast
</code></pre>
<p>在任意位置都可以调用Threadlocal，线程隔离互不影响，解决了线程安全问题：[每个线程存一份 线程不共享]</p>
<p>用mybatis+建造者模式 一定要在类里面加 一定要具有有参和无参构造缺一不可 否则mybatis数据封装无法映射<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Builder</p>
<h4 id="字符和字符串类型的区别"><a href="#字符和字符串类型的区别" class="headerlink" title="字符和字符串类型的区别"></a>字符和字符串类型的区别</h4><p>字符是基本数据类型 没有null 用单引号<br>字符串是引用数据类型[一个类] 用双引号</p>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250102142357092.png" alt="image-20250102142357092"></p>
<h4 id="操作字符串的工具类是什么"><a href="#操作字符串的工具类是什么" class="headerlink" title="操作字符串的工具类是什么"></a>操作字符串的工具类是什么</h4><p>apache的common提供的String Utils工具类，hutool也有String Utils</p>
<h4 id="局部变量和成员变量的区别"><a href="#局部变量和成员变量的区别" class="headerlink" title="局部变量和成员变量的区别"></a>局部变量和成员变量的区别</h4><p>成员变量是在jvm的堆<br>局部变量是在jvm的栈<br>基本数据类型的引用类型 类在堆<br>基本数据类型的成员变量在堆 非静态在堆 静态变量在方法区<br>引用类型 无论静态还是非静态成员变量都在堆区</p>
<p>局部变量是在方法或代码块内部声明的变量，其作用域仅限于声明它的方法或代码块<br>局部变量不能被static修饰<br>局部变量必须被初始化才能使用</p>
<p>成员变量是在类内部声明的变量，其作用域是整个类<br>成员变量可以被static修饰<br>成员变量有默认值</p>
<h4 id="你编写完代码，写完这个功能后，会进行什么操作呢"><a href="#你编写完代码，写完这个功能后，会进行什么操作呢" class="headerlink" title="你编写完代码，写完这个功能后，会进行什么操作呢"></a>你编写完代码，写完这个功能后，会进行什么操作呢</h4><p>进行代码审查，检查代码是否符合编码规范和设计要求。</p>
<ul>
<li>进行单元测试，确保代码的功能正确无误。</li>
<li>进行代码优化，提高代码的性能和可维护性。</li>
<li>与团队成员进行代码合并，确保代码的集成。</li>
<li>编写文档，记录功能实现和代码变更。</li>
</ul>
<h4 id="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"><a href="#上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？" class="headerlink" title="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"></a>上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？</h4><p>期望薪资：<br>了解过广东这边的市场 我想换工作想涨薪10~20%<br>节假日会发放礼品和福利</p>
<h4 id="可以接受低代码平台吗？"><a href="#可以接受低代码平台吗？" class="headerlink" title="可以接受低代码平台吗？"></a>可以接受低代码平台吗？</h4><p>可以接受<br>低代码平台：类若依</p>
<h4 id="具体说说Java面向对象"><a href="#具体说说Java面向对象" class="headerlink" title="具体说说Java面向对象"></a>具体说说Java面向对象</h4><p>Java面向对象是一种编程范式，它将现实世界的事物抽象成程序中的对象。Java面向对象的主要特征包括：</p>
<ul>
<li>封装：将对象的属性和行为封装在一起，对外只暴露必要的接口，隐藏内部实现细节。</li>
<li>继承：允许子类继承父类的属性和行为，实现代码的复用。</li>
<li>多态：同一个接口可以有多个不同的实现，通过对象的类型和方法的调用，实现不同的功能。</li>
</ul>
<h4 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别"></a>&#x3D;&#x3D; 和 equals 的区别</h4><ul>
<li>&#x3D;&#x3D;：比较基本数据类型时，比较的是值；比较引用数据类型时，比较的是对象的内存地址。</li>
<li>equals：是Object类的一个方法，默认比较的是对象的内存地址。但在很多类中（如String、Integer等），equals方法被重写，用于比较对象的内容是否相等。<br>没重写 就是 &#x3D;&#x3D; 比较对象地址。重写过的话就比较对象的值。</li>
</ul>
<h4 id="有没有做过权限控制，整个系统的权限"><a href="#有没有做过权限控制，整个系统的权限" class="headerlink" title="有没有做过权限控制，整个系统的权限"></a>有没有做过权限控制，整个系统的权限</h4><p>有过 SpringSecurity</p>
<h6 id="能具体说一下权限控制怎么做？"><a href="#能具体说一下权限控制怎么做？" class="headerlink" title="能具体说一下权限控制怎么做？"></a>能具体说一下权限控制怎么做？</h6><p>使用RBAC模型 不是把用户关联资源 而是中间利用角色间接关联<br><u>用户+角色+资源+用户角色中间表+角色资源中间表<del>多对多</del></u></p>
<h6 id="SpringSecurity-具体怎么实现"><a href="#SpringSecurity-具体怎么实现" class="headerlink" title="SpringSecurity 具体怎么实现"></a>SpringSecurity 具体怎么实现</h6><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息。</p>
<h4 id="线程池有哪些状态，这些状态是怎么进行转换的"><a href="#线程池有哪些状态，这些状态是怎么进行转换的" class="headerlink" title="线程池有哪些状态，这些状态是怎么进行转换的"></a>线程池有哪些状态，这些状态是怎么进行转换的</h4><p>线程池有以下几种状态：</p>
<ul>
<li>RUNNING：线程池正常运行，可以接受新的任务和处理任务队列中的任务。</li>
<li>SHUTDOWN：线程池不再接受新的任务，但会处理任务队列中的任务。</li>
<li>STOP：线程池不再接受新的任务，也不处理任务队列中的任务，并且会中断正在执行的任务。</li>
<li>TIDYING：所有任务都已终止，线程池即将关闭。</li>
<li>TERMINATED：线程池已关闭。</li>
</ul>
<p>状态转换过程如下：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：调用shutdown()方法。</li>
<li>RUNNING -&gt; STOP：调用shutdownNow()方法。</li>
<li>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空时。</li>
<li>STOP -&gt; TIDYING：当线程池为空时。</li>
<li>TIDYING -&gt; TERMINATED：当terminated()钩子方法执行完成后。</li>
</ul>
<h4 id="说一下怎么使用多线程？"><a href="#说一下怎么使用多线程？" class="headerlink" title="说一下怎么使用多线程？"></a>说一下怎么使用多线程？</h4><ul>
<li><p>继承Thread类，并重写run()方法。</p>
</li>
<li><p>实现Runnable接口，并将实现类传递给Thread对象。</p>
</li>
<li><p>实现Callable接口，实现<code>call()</code>方法</p>
</li>
<li><p>使用Executor框架，如ExecutorService和ThreadPoolExecutor来管理线程池。</p>
</li>
</ul>
<h4 id="操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？"><a href="#操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？" class="headerlink" title="操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？"></a>操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？</h4><ul>
<li>新建（New）：创建后尚未启动的线程处于这个状态。<code>new Thread</code></li>
<li>可运行（Runnable）：包括运行（Running）和就绪（Ready）状态，线程正在执行或等待CPU调度。</li>
<li>阻塞（Blocked）：线程因为等待某些资源或锁而被阻塞。notify可以唤醒阻塞状态 睡眠完会自动唤醒</li>
<li>等待（Waiting）：线程等待其他线程执行特定操作（如通知）。</li>
<li>计时等待（Timed Waiting）：线程在一定时间内等待另一个线程的通知。</li>
<li>终止（Terminated）：线程执行完成或因异常而终止。</li>
</ul>
<h6 id="怎么把线程杀死-终止"><a href="#怎么把线程杀死-终止" class="headerlink" title="怎么把线程杀死 终止"></a>怎么把线程杀死 终止</h6><p><strong>stop</strong>()方法[暴力方法]    <strong>interrupt</strong>()方法[优雅关闭线程]    正常回收</p>
<h4 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h4><p>乐观锁：读多写少 线程执行时间相差较大  并发不太激烈</p>
<p>悲观锁：写多读少 线程执行时间相差不大 竞争激烈 并发锁多</p>
<p>加锁的时机不一样，<br>悲观锁：没改数据的时候先加锁 比较明显利用底层操作系统api实现<br>乐观锁：在改数据的时候才加锁 依靠底层的硬件</p>
<p><strong>java层面</strong>：<code>synchronized  ReentrantLock</code></p>
<p><strong>数据库层面</strong>：<br>悲观锁：select for update是mysql的的实现<br>乐观锁：JUC Java Util Concurrent）是Java并发工具包</p>
<blockquote>
<p><code>SELECT ... FOR UPDATE</code>：这个语句在读取记录时会锁定这些记录，直到事务提交或回滚。其他的事务不能更新这些锁定的记录，这是悲观锁的一个典型实现</p>
</blockquote>
<p>乐观锁要读取目前旧的值再将新设置的值以及旧的值比较 如果相同 就把新的值更新 如果不相同 就把旧的值重新提取 因为在这期间有人读取了这个数据跟我之前不一样(底层api 要调用两个 一个旧的值 一个新的值)。一般乐观锁是结合自旋 类于while(true)直到读到为止 <code>要设计次数后再报错</code></p>
<p>要更新数据库某个值 把旧的值读出来 想更新银行里的余额<br>这是<strong>典型的ABA问题</strong>：<u>要用<strong>时间戳</strong>或<strong>自增版本号</strong>去做</u></p>
<h4 id="Stream流的使用及常用API"><a href="#Stream流的使用及常用API" class="headerlink" title="Stream流的使用及常用API"></a>Stream流的使用及常用API</h4><p>Stream是Java 8中引入的一种新特性，用于简化数据处理和操作。它可以用来解决集合循环遍历处理的问题。在此之前用循环来代替</p>
<blockquote>
<h3 id="基础Stream操作"><a href="#基础Stream操作" class="headerlink" title="基础Stream操作"></a>基础Stream操作</h3><ul>
<li><code>stream()</code>: 为集合创建串行流。</li>
<li><code>parallelStream()</code>: 为集合创建并行流。</li>
<li><code>forEach</code>: 对每个元素执行操作。</li>
<li><code>map</code>: 将每个元素映射到对应的结果。</li>
<li><code>filter</code>: 过滤出满足条件的元素。</li>
<li><code>limit</code>: 限制流的大小。</li>
<li><code>skip</code>: 跳过流中的前n个元素。</li>
<li><code>sorted</code>: 对流进行排序。</li>
</ul>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><ul>
<li><code>collect</code>: 将流转换为其他形式，比如列表、集合或Map。</li>
<li><code>reduce</code>: 通过一个起始值，反复利用BinaryOperator来处理和累积元素，返回一个值。</li>
<li><code>count</code>: 返回流中元素的数量。</li>
<li><code>min</code> &#x2F; <code>max</code>: 找到流中的最小&#x2F;最大值。</li>
<li><code>anyMatch</code>: 流中是否有一个元素匹配给定的谓词。</li>
<li><code>allMatch</code>: 流中的所有元素是否都匹配给定的谓词。</li>
<li><code>noneMatch</code>: 流中没有任何元素匹配给定的谓词。</li>
<li><code>findFirst</code>: 返回第一个元素。</li>
<li><code>findAny</code>: 返回当前流中的任意元素。</li>
</ul>
</blockquote>
<h4 id="项目中具体用到哪些设计模式"><a href="#项目中具体用到哪些设计模式" class="headerlink" title="项目中具体用到哪些设计模式"></a>项目中具体用到哪些<span style = "color:red">设计模式</span></h4><p><del><strong>单例模式</strong>：确保一个类只有一个实例，例如配置文件管理器。</del>[<u>Spring原本设计好的</u>]<br>**<u>工厂模式</u>**：创建对象时无需指定具体的类，例如日志工厂。<br><strong>观察者模式</strong>：当一个对象状态发生改变时，所有依赖于它的对象都得到通知并自动更新，例如事件监听。<br>**<u>策略模式</u>**：定义一系列算法，将每个算法封装起来，并使它们可以互换，例如支付策略。<br><strong>模板方法模式</strong>：在项目中，我有一些具有相同操作步骤但具体实现不同的算法，我使用了模板方法模式来定义这些步骤的骨架，将具体的步骤实现留给子类。任链模式的目的是将请求的发送者和接收者解耦，从而使得多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。<br><strong>责任链模式</strong>：它允许将请求沿着处理者链进行发送。收到请求后，每个处理者都有机会对请求进行处理，或者将其传递给链上的下一个处理者。这样，请求就能在一系列处理者中传递，直到有一个处理者对其进行处理为止。    1.<u>递归方式</u> ：在递归模式中，每个处理者内部调用下一个处理者的处理方法。如果当前处理者无法处理请求，它会直接调用下一个处理者的处理方法。这种方式通常是通过递归调用来实现的<br>2.<u>迭代模式</u>：在迭代模式中，处理者链被构建为一个线性结构，每个处理者都有一个指向下一个处理者的引用。请求从链的第一个处理者开始，依次传递给下一个处理者，直到找到能够处理该请求的处理者为止。这种方式通常是通过循环迭代来实现的<br><strong>代理模式</strong>：为了控制对远程服务的访问，我使用了代理模式。代理负责处理所有与服务对象的交互，并在必要时进行延迟加载。</p>
<p>在我的项目中结合<strong>工厂模式</strong>和<strong>策略模式</strong>来设计登录接口时，我们可以将登录验证的逻辑抽象为一个策略接口，并为每种登录方式（如：用户名密码登录、手机验证码登录、社交账号登录等）实现具体的策略类。工厂类则负责创建并管理这些策略对象</p>
<h6 id="思考一个问题：哪些方式创建单例模式？"><a href="#思考一个问题：哪些方式创建单例模式？" class="headerlink" title="思考一个问题：哪些方式创建单例模式？"></a>思考一个问题：哪些方式创建单例模式？</h6><h4 id="MySQL支持四种隔离级别"><a href="#MySQL支持四种隔离级别" class="headerlink" title="MySQL支持四种隔离级别"></a><span style = "color:red"><u>MySQL支持四种隔离级别</u></span></h4><p>第一个是<strong>读未提交</strong>(readuncomm itted)它解决不了刚才提出的所有问题，一般项目中也不用这个。存在脏读问题  可解决不可重复读 幻读<br>第二个是<strong>读已提交</strong>(readcomm ited)它能解决脏读的问题的，但是解决不了不可重复读和幻读。<br>第三个是<strong>可重复读</strong>(repeatable read)它能解决脏读和不可重复读，但是解决不了幻读[解决了一部分]，这个也是mysql默认的隔离级别。<br>第四个是<strong>串行化</strong>(serializable)它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。<br>串行化里的读也要加锁 表锁：整个表上锁            行锁：只对一行加锁</p>
<h6 id="什么时候上行锁-x2F-表锁？"><a href="#什么时候上行锁-x2F-表锁？" class="headerlink" title="什么时候上行锁&#x2F;表锁？"></a>什么时候上行锁&#x2F;表锁？</h6><p>insert不带查询筛选条件  上行锁<del>底层是索引，b+树底层叶子</del><br>update看where后面的条件 带索引加行锁<del>构建b+树</del> 不带索引的加表锁<br>表锁的速度比行锁速度快</p>
<p>MVCC底层是多版本并发控制 但底层并不怎么了解</p>
<h4 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h4><p><strong>浅拷贝</strong>：只复制对象的基本数据类型和引用类型地址，不复制引用类型指向的对象。如果原对象和浅拷贝对象中的一个改变了引用类型，另一个也会受到影响。旧对象改变新对象也会改变。<br><strong>深拷贝</strong>：复制对象的所有字段，包括基本数据类型和引用类型指向的对象。原对象和深拷贝对象之间不会相互影响。旧对象改变新对象不会改变<br>  Java是值传递 </p>
<h6 id="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"><a href="#如何实现深拷贝？数组不需要重写【体现了原型设计模式】" class="headerlink" title="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"></a>如何实现深拷贝？<del>数组不需要重写</del>【体现了<code>原型设计模式</code>】</h6><ul>
<li><p>实现<strong>Cloneable接口</strong>并重写<strong>clone</strong>方法 会调用构造方法</p>
<p>这是最常见的实现深拷贝的方法。首先，你的类需要实现<code>Cloneable</code>接口，然后重写<code>clone()</code>方法<del>构造新对象的过程</del>，并在该方法中调用<code>super.clone()</code>，同时递归地克隆所有引用类型的字段。[如果里面有多层嵌套复杂对象 在每层都要实现Cloneable接口一直重写到基本数据类型的时候才停止]</p>
</li>
</ul>
<pre><code class="java">public class Person implements Cloneable &#123;
    private int age;
    private Address address;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Person cloned = (Person) super.clone();
        // 假设Address也实现了Cloneable接口
        cloned.address = (Address) this.address.clone(); 
        return cloned;
    &#125;
&#125;

public class Address implements Cloneable &#123;
    private String street;
    private String city;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
&#125;
</code></pre>
<ul>
<li>通过<strong>序列化</strong><del>对象转二进制</del>和<strong>反序列化</strong><del>二进制转对象</del>。这种方式不需要实现<code>Cloneable</code>接口，但你的类需要实现<code>Serializable</code>接口。反序列化不会调用构造方法</li>
</ul>
<h4 id="开启线程的时候为什么用的是thread-start方法："><a href="#开启线程的时候为什么用的是thread-start方法：" class="headerlink" title="开启线程的时候为什么用的是thread.start方法："></a>开启线程的时候为什么用的是thread.start方法：</h4><p>thread.start()方法用于启动一个新线程，并执行该线程的run()方法。调用start()方法后，线程会被放入线程调度队列，等待CPU调度执行。</p>
<p>直接调用run()方法，并不会启动一个新线程，而是在当前线程中执行run()方法，这不符合多线程编程的目的。使用start()方法可以确保线程并发执行，提高程序的性能和响应速度。</p>
<p>java没权限开启一个线程 要调用底层的操作系统 在JVM的底层实现中，会有相应的本地（C或C++）方法来处理线程的创建和管理</p>
<h4 id="你在你们项目中使用过多线程吗"><a href="#你在你们项目中使用过多线程吗" class="headerlink" title="你在你们项目中使用过多线程吗?"></a>你在你们项目中使用过多线程吗?</h4><p>是的，在我们的项目中，我确实使用过多线程。 【结合项目去说】<br>在处理大量数据计算或执行耗时的IO操作时，我会使用Java的线程池（如ExecutorService）来并行处理任务，以提高系统的响应速度和吞吐量<br><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250107153246645.png" alt="image-20250107153246645"></p>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><p><strong>sleep</strong>是Thread类的一个静态方法，它使当前线程暂停执行指定的时间，但不会释放锁资源。<br><strong>wait</strong>是Object类的一个方法，它使当前线程暂停执行并释放当前对象上的锁，直到另一个线程调用同一个对象的<code>notify()</code>或<code>notifyAll()</code>方法，或者过了指定的等待时间。</p>
<p>sleep是线程内的静态方法 需要指定睡眠的时间 或者自动自己唤醒 不会释放锁<br>wait是Object类的一个方法 可以指定睡眠时间 不指定就等于无限期 要释放锁<br>wait一定要搭配<code>synchronized</code>，且都为同一个对象 synchronized锁住了wait<del>万物对象皆为锁</del><br>可以被唤醒<code>notify()</code>或<code>notifyAll()</code>方法   区别：notify是唤醒一个 notifyall会唤醒全部</p>
<p>普通方法上 锁的是this<br>静态方法上 锁的是当前类的class对象</p>
<h4 id="ConcurrentHashMap-和-HashTable的区别"><a href="#ConcurrentHashMap-和-HashTable的区别" class="headerlink" title="ConcurrentHashMap 和 HashTable的区别"></a>ConcurrentHashMap 和 HashTable的区别</h4><h6 id="是否支持传入NULL"><a href="#是否支持传入NULL" class="headerlink" title="是否支持传入NULL"></a>是否支持传入NULL</h6><p>HashMap可以支持为null<br>若尝试将 <code>null</code> 作为键或值放入 <code>ConcurrentHashMap</code> 将会抛出 <code>NullPointerException</code><br>ConcurrentHashMap 不能支持存null</p>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><p>ConcurrentHashMap 1.8之前是分段锁来实现 默认是16个HashTable<br>1.8之后无限接近单个的HashMap  底层用CAS+synchronized<br>HashTable通过加<code>synchronized</code>锁来控制线程安全 </p>
<p>ConcurrentHashMap 读不要加锁 [读写的读也不会加锁] 会走最终一致性<br>HashTable 读要加锁 [读读都加锁]</p>
<h4 id="为什么要用Redis"><a href="#为什么要用Redis" class="headerlink" title="为什么要用Redis"></a>为什么要用Redis</h4><p><strong>高性能</strong>：Redis是基于内存的数据结构存储，可以提供高速的数据读写操作。<br><strong>数据结构丰富</strong>：Redis支持多种数据结构，如字符串、列表、集合、散列表、有序集合等，非常适合各种场景。<br><strong>持久化</strong>：Redis支持数据持久化，可以将内存中的数据保存到磁盘中，防止数据丢失。<br><strong>分布式</strong>：Redis支持主从复制、哨兵和集群模式，可以轻松实现分布式缓存。</p>
<h4 id="Redis中缓存了哪些数据"><a href="#Redis中缓存了哪些数据" class="headerlink" title="Redis中缓存了哪些数据"></a>Redis中缓存了哪些数据</h4><p>若放登录的信息到Redis的时候 不再用JWT了<br>Session在集群里面不能用了<br>替代方案：<span style = "color:red"><strong>用Redis 不用JWT</strong></span><br>JWT是无状态 无需集中存储</p>
<p>在我们的项目中，Redis中缓存了以下类型的数据：<br>会话信息：如用户登录信息、购物车内容等。<br><strong>热点数据</strong>：如热门商品信息、推荐内容等。<br><strong>计数器</strong>：如用户访问次数、点赞数、评论数等。<br>缓存数据库查询结果：减少数据库访问次数，提高系统响应速度。</p>
<h4 id="检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考"><a href="#检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考" class="headerlink" title="检测数据存在Redis中，有过期时间吗? 过期时间是多少?仅参考"></a>检测数据存在Redis中，有过期时间吗? 过期时间是多少?<del>仅参考</del></h4><p>是的，我们在Redis中缓存的数据通常会设置过期时间，以避免过时的数据占用内存。具体的过期时间取决于数据的类型和业务需求。对于会话信息，我们可能会设置较短的过期时间，如30分钟或1小时；而对于热点数据，可能会设置较长的过期时间，如几小时或一天。具体的过期时间需要根据实际业务场景和数据访问模式来决定。</p>
<h4 id="微服务之间如何调用？"><a href="#微服务之间如何调用？" class="headerlink" title="微服务之间如何调用？"></a>微服务之间如何调用？</h4><p>通过注册中心去协调的<br>首先是有三个重要的概念，服务消费者，注册中心，服务提供者提供者在第一次会把自己的信息注册到注册中心中，比如ip端口，服务功能等消费者需要到注册中心来寻找服务进行消费，在服务消费者第一次请求的时候会拉取服务提供者的信息，注册中心会把提供者的实例列表给到消费者供消费者选择，使用负载均衡来选择服务，默认为轮询，还有加权轮询，随机。同时服务消费者还会定时去注册中心拉取服务提供者的信息如果我们的服务挂掉了怎么办?<br>服务提供者会每隔一段时间去向注册中心报告自己的状态，如果没有向注册中心报告状态，那么这个时候注册中心会认为服务提供者已经宕机，同时会推送到我们的服务消费者，这个服务提供者已经宕机</p>
<h4 id="微服务的五大组件"><a href="#微服务的五大组件" class="headerlink" title="微服务的五大组件"></a>微服务的五大组件</h4><ol>
<li><strong>服务注册与发现</strong>：如Eureka<del>已过时</del>、<strong>Nacos</strong>、Consul，用于服务的注册和发现。</li>
<li><strong>配置管理</strong>：如Spring Cloud Config、<strong>OpenFeign</strong> 用于集中管理服务的配置。</li>
<li><strong>服务网关</strong>：如Zuul、Spring Cloud <strong>Gateway</strong>，作为系统的唯一入口，处理外部请求的路由和过滤。</li>
<li><strong>负载均衡</strong>：如<strong>Ribbon</strong>，用于在多个服务实例之间分配请求。</li>
<li><strong>断路器</strong>：如<strong>Hystrix</strong>，用于服务熔断，防止系统雪崩</li>
</ol>
<h4 id="对于服务注册这块有什么了解？"><a href="#对于服务注册这块有什么了解？" class="headerlink" title="对于服务注册这块有什么了解？"></a>对于服务注册这块有什么了解？</h4><ul>
<li><strong>服务注册中心</strong>：服务实例在启动时向服务注册中心注册自己的地址和端口信息。检查 心跳 如果未查询就剔除，同时也有注册中心主动发起请求。</li>
<li><strong>健康检查</strong>：服务注册中心通常会定期对已注册的服务进行健康检查，以确保服务的可用性。</li>
<li><strong>服务发现</strong>：服务消费者通过服务注册中心查找可用的服务实例，以进行服务调用。</li>
<li><strong>服务去注册</strong>：当服务实例关闭或出现故障时，它需要从服务注册中心注销，以避免调用不可用的服务。</li>
</ul>
<h4 id="你能说一下小程序的登录流程吗"><a href="#你能说一下小程序的登录流程吗" class="headerlink" title="你能说一下小程序的登录流程吗?"></a>你能说一下小程序的登录流程吗?</h4><p>调用微信api，根据code获取openid；根据openid查询用户为空就新增；调用微信api <code>WechatService + WechatServiceImpl</code>(openId+phoneCode) 获取用户绑定的手机号；保存或修改该用户；将用户id存入token返回(JWT生成token)</p>
<h4 id="有哪些方式可以创建单例？"><a href="#有哪些方式可以创建单例？" class="headerlink" title="有哪些方式可以创建单例？"></a>有哪些方式可以创建单例？</h4><ol>
<li><strong>饿汉式</strong>：在<strong>类加载</strong>时就立即初始化并创建单例对象。</li>
<li><strong>懒汉式</strong>：在<strong>第一次调用时</strong>初始化单例对象，通常需要考虑线程安全问题。</li>
<li><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</li>
<li><strong>静态内部类</strong>：利用静态内部类的加载机制来确保单例对象的唯一性。</li>
<li><strong>枚举</strong>：利用枚举的特性，保证单例对象的唯一性和线程安全【不可用反射】</li>
</ol>
<h6 id="并发情况下严格控制单例？volatile→禁止进行指令重排序"><a href="#并发情况下严格控制单例？volatile→禁止进行指令重排序" class="headerlink" title="并发情况下严格控制单例？volatile→禁止进行指令重排序"></a>并发情况下严格控制单例？<del>volatile→禁止进行指令重排序</del></h6><p><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</p>
<h4 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h4><ul>
<li><strong>公平锁</strong>：多个线程按照它们请求锁的顺序来获取锁，先来先得。这种方式不会产生饥饿现象，但可能会降低吞吐量，因为需要额外的开销来维护等待队列的顺序。【僵尸线程】<u>对资源顺序有严格要求</u></li>
<li><strong>非公平锁</strong>：线程获取锁的顺序不一定是按照请求锁的顺序，允许线程“插队”。这种方式可能会提高吞吐量，但可能导致某些线程长时间无法获取锁，产生饥饿现象。【为什么性能高？不用沉睡和阻塞 避免来回切换】<u>对性能要求高</u></li>
</ul>
<p>ReentrantLock 看传参 <u>公平&#x2F;非公平</u>都支持<br>Synchronized 公平锁</p>
<h4 id="SpringMVC的工作原理"><a href="#SpringMVC的工作原理" class="headerlink" title="SpringMVC的工作原理"></a>SpringMVC的工作原理</h4><ul>
<li><p>前端的HTTP请求到达时首先被<strong>DispatcherServlet</strong>接收</p>
</li>
<li><p>DispatcherServlet根据请求信息<del>路径</del>查找合适的<strong>HandlerMapping</strong>来确定哪个<strong>Controller</strong>应该处理该请求。</p>
</li>
<li><p>找到合适的Controller后，DispatcherServlet将请求转发给它处理。</p>
</li>
<li><p>Controller处理完请求后返回一个<strong>ModelAndView</strong>对象给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet再通过<strong>ViewResolver</strong>解析ModelAndView中的视图逻辑名，找到对应的视图。</p>
</li>
<li><p>最后，DispatcherServlet将模型数据渲染到视图上并响应给客户端。</p>
</li>
</ul>
<h4 id="OpenFeign的底层原理"><a href="#OpenFeign的底层原理" class="headerlink" title="OpenFeign的底层原理"></a>OpenFeign的底层原理</h4><p>OpenFeign 实现了简洁、声明式的 HTTP 请求调用，并且与 Spring Cloud 集成后能提供更多的功能如负载均衡等</p>
<p><strong>动态代理</strong>： OpenFeign 使用 Java 动态代理技术，基于接口创建代理类，代理类会自动发起 HTTP 请求。你定义的接口方法会映射到 HTTP 请求上，OpenFeign 会根据注解（如 <code>@RequestMapping</code>, <code>@GetMapping</code> 等）来构建请求。</p>
<p><strong>注解解析</strong>： OpenFeign 会解析接口方法上的注解，构造 HTTP 请求的 URL、请求方法类型（GET、POST 等），以及请求体和请求头等信息。</p>
<p><strong>请求拦截和处理</strong>： 在请求发起之前，OpenFeign 允许通过拦截器（<code>RequestInterceptor</code>）来修改请求，比如设置请求头、参数等。</p>
<p><strong>负载均衡与容错</strong>： 如果与 Spring Cloud 一起使用，OpenFeign 会集成 Ribbon（负载均衡）和 Hystrix（容错），使得服务调用更加健壮和可靠。</p>
<p><strong>序列化与反序列化</strong>： OpenFeign 会利用 Jackson 等库进行请求和响应的序列化和反序列化，将 Java 对象与 HTTP 请求&#x2F;响应内容相互转换</p>
<p>在使用OpenFeign时，开发者只需要定义接口并添加相应的注解，OpenFeign会在运行时动态生成实现类来执行HTTP请求。</p>
<h4 id="对Volatile的理解"><a href="#对Volatile的理解" class="headerlink" title="对Volatile的理解"></a>对Volatile的理解</h4><p>确保了不同线程对这个变量进行读写操作时的可见性。<br>是java的关键字是修饰共享的变量，不能修饰局部变量。<br>修饰普通或静态成员变量，主要用来保证可见性和有序性。</p>
<h4 id="Spring-Security的实现"><a href="#Spring-Security的实现" class="headerlink" title="Spring Security的实现"></a>Spring Security的实现</h4><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息</p>
<h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><p>是多线程中的<del>抽象</del>队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，是一个抽象类。<br>像ReentrantLock都是基于AQS实现的<br>定义了一个并发情况下一些抽象的资源 资源能否共享&#x2F;独享 定义了公平和非公平<br>如果是非公平锁如果来了个新的线程来抢线程 也是会去抢一次<br>AQS成为了JUC很多类都去继承的 它<strong>抽象了很多并发的属性和行为</strong>，让子类去继承它扩展自己</p>
<h4 id="Synchronized的锁升级"><a href="#Synchronized的锁升级" class="headerlink" title="Synchronized的锁升级"></a>Synchronized的锁升级</h4><ul>
<li>Monitor实现的锁属于重量级锁，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<p>一段很长的时间内都只被一个线程使用锁 <strong>偏向锁</strong><br>有线程交替或线程加锁的时间是错开的 <strong>轻量级锁</strong><br>有很多线程来抢 <strong>重量级锁</strong></p>
<p>java语言是高级语言如果想调用底层的操作系统和硬件要通过操作系统的API去操作。以前老的JDK版本 数据是在操作系统找的数据<del>锁</del>，Monitor的标志0 和 1，底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 。<br>引入新型锁后，java里是用对象头找个地方存一把锁，这样就不涉及到调用操作系统底层。一开始new了个对象 此时是无锁状态。接下来来人拿锁，长期一个人拿到那个锁 此时是<strong>偏向锁</strong><del>竞争不激烈</del>。后面多线程一起来 <u>交替抢锁</u> 此时是<strong>轻量级锁</strong>。随着并发越来越高 此时在一个线程拿到锁后很多线程来抢锁 线程先尝试自己先获取几次(自旋锁64次未拿到锁就会升级为重量级锁) 这时就涉及到操作系统的底层对象涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低。锁不可逆<del>可能新版本可以降级</del></p>
<h4 id="Dockerfile-常用命令"><a href="#Dockerfile-常用命令" class="headerlink" title="Dockerfile 常用命令"></a>Dockerfile 常用命令</h4><ul>
<li><code>FROM</code>: 指定基础镜像。</li>
<li><code>ENV</code>: 设置环境变量。</li>
<li><code>RUN</code>: 执行命令并创建新的镜像层。</li>
<li><code>COPY</code>: 将文件从宿主机复制到容器中。</li>
<li><code>EXPOSE</code>: 声明容器运行时将监听的端口。</li>
<li><code>ENTRYPOINT</code>: 配置容器启动时运行的命令。</li>
</ul>
<h4 id="常用的-Docker-命令"><a href="#常用的-Docker-命令" class="headerlink" title="常用的 Docker 命令"></a>常用的 Docker 命令</h4><ul>
<li><code>docker run</code>: 创建一个新的容器并运行一个命令。</li>
<li><code>docker pull</code>: 从仓库中拉取或者更新一个镜像。</li>
<li><code>docker push</code>：推送镜像到服务</li>
<li><code>docker build</code>: 从 Dockerfile 构建一个镜像。</li>
<li><code>docker images</code>: 列出本地镜像。</li>
<li><code>docker ps</code>: 列出运行中的容器。</li>
<li><code>docker stop</code>: 停止一个运行中的容器。</li>
<li><code>docker start</code>: 启动一个停止的容器。</li>
<li><code>docker rm</code>: 删除一个容器。</li>
<li><code>docker rmi</code>: 删除一个镜像。</li>
<li><code>docker exec</code>: 在运行中的容器内执行命令。</li>
<li><code>docker logs</code>: 获取容器的日志。</li>
</ul>
<pre><code class="java">- docker volume create：创建数据卷
- docker volume ls：查看所有数据卷
- docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置
- docker volume rm：删除指定数据卷
</code></pre>
<p>Docker Compose 常用命令</p>
<ul>
<li><code>docker-compose up</code>: 启动所有服务的容器。</li>
<li><code>docker-compose down</code>: 停止并删除容器、网络、卷和镜像。</li>
<li><code>docker-compose ps</code>: 列出项目中所有的容器。</li>
<li><code>docker-compose exec</code>: 进入指定的容器。</li>
<li><code>docker-compose build</code>: 构建或重建服务。</li>
<li><code>docker-compose logs</code>: 查看服务的日志输出。</li>
<li><code>docker-compose stop</code>: 停止运行的容器。</li>
</ul>
<h4 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h4><ul>
<li><code>synchronized</code> 是Java的一个关键字<del>用于方法和代码块中</del>，而 <code>ReentrantLock</code> 是JUC包的一个类。</li>
<li><code>synchronized</code> 可以自动加锁和解锁，而 <code>ReentrantLock</code> 需要手动加锁和解锁。</li>
<li><code>synchronized</code> 的锁是非公平的，而 <code>ReentrantLock</code> 默认也是非公平的，但可以设置为公平锁。</li>
</ul>
<h4 id="你们公司是怎么部署项目的"><a href="#你们公司是怎么部署项目的" class="headerlink" title="你们公司是怎么部署项目的"></a>你们公司是怎么部署项目的</h4><p>是通过docker + jenkins<br>测试环境我们参与 生产环境组长部署</p>
<h4 id="varchar-与-char-区别"><a href="#varchar-与-char-区别" class="headerlink" title="varchar 与 char 区别"></a>varchar 与 char 区别</h4><ul>
<li><code>varchar</code> 是可变长度的字符串，而 <code>char</code> 是固定长度的字符串。</li>
<li><code>varchar</code> 的性能通常比 <code>char</code> 差，因为需要处理额外的长度信息。</li>
<li>当数据长度变化很大时，推荐使用 <code>varchar</code>；当数据长度几乎固定时，使用 <code>char</code> 可能更合适。</li>
</ul>
<h4 id="Redis的持久化有哪几种-它们的区别是什么"><a href="#Redis的持久化有哪几种-它们的区别是什么" class="headerlink" title="Redis的持久化有哪几种? 它们的区别是什么?"></a>Redis的持久化有哪几种? 它们的区别是什么?</h4><p>完整性 大小 数据恢复速度 建议</p>
<p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果</p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照哦</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h4 id="项目中是怎么使用redis的"><a href="#项目中是怎么使用redis的" class="headerlink" title="项目中是怎么使用redis的"></a>项目中是怎么使用redis的</h4><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题</p>
<p>用Hash类型  大Key是Id  小key是商品id value是商品数量<br>数据量点击量 用String类型<br>用Set类型 Zset做排行榜</p>
<h4 id="你的项目中哪里使用到分布式锁"><a href="#你的项目中哪里使用到分布式锁" class="headerlink" title="你的项目中哪里使用到分布式锁?"></a>你的项目中哪里使用到分布式锁?</h4><p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、EX是设置超时时间<br><strong>SET lock value NX EX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h4 id="你可以说一下redis的分布式锁的原理吗"><a href="#你可以说一下redis的分布式锁的原理吗" class="headerlink" title="你可以说一下redis的分布式锁的原理吗"></a>你可以说一下redis的分布式锁的原理吗</h4><h4 id="我在项目中是集成了redisson-底层基于Lua脚本-具有原子性"><a href="#我在项目中是集成了redisson-底层基于Lua脚本-具有原子性" class="headerlink" title="我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])"></a><del>我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])</del></h4><p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责<strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h4 id="redis和mysql怎么保证数据一致性"><a href="#redis和mysql怎么保证数据一致性" class="headerlink" title="redis和mysql怎么保证数据一致性"></a>redis和mysql怎么保证数据一致性</h4><p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行<br><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】<del>有过期时间兜底</del></p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知：</strong>&#x3D;&#x3D;<u>异步通知保证数据的最终一致性</u>(需要保证MQ的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先将数据写入Redis，然后通过异步通知机制触发数据库的更新操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog<br>可以解析binlog文件 可以存放mysql里面的数据 看最近有无增删改查 转换成redis命令 再给redis里面</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<h4 id="synchronized可以作用在哪些地方，分别锁的是什么"><a href="#synchronized可以作用在哪些地方，分别锁的是什么" class="headerlink" title="synchronized可以作用在哪些地方，分别锁的是什么"></a>synchronized可以作用在哪些地方，分别锁的是什么</h4><p>在Java中，<code>synchronized</code>关键字可以用来实现线程同步，它可以作用在不同的地方，并且锁定的对象也不同：</p>
<ol>
<li><p><strong>实例方法</strong>：</p>
<ul>
<li>作用在实例方法上时，锁的是调用该方法的<strong>对象实例</strong>（即**<u>this对象</u>**）。</li>
<li>任何线程想要执行这个方法，都必须获得该对象实例的锁。</li>
</ul>
<pre><code>public synchronized void synchronizedMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>静态方法</strong>：</p>
<ul>
<li>作用在静态方法上时，锁的是类的<strong>Class对象</strong>。</li>
<li>由于静态方法是属于类的，而不是属于任何特定实例，所以所有线程要想执行这个静态同步方法，都必须获得该类的Class对象的锁。</li>
</ul>
<pre><code>public static synchronized void synchronizedStaticMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>代码块</strong>：</p>
<ul>
<li>作用在代码块上时，可以指定一个<strong>锁对象<del>括号里的对象</del><strong>，可以是</strong>任何对象</strong>。</li>
<li>当进入这个代码块时，线程必须获得指定锁对象的锁。</li>
</ul>
<pre><code>public void synchronizedBlock() &#123;
    synchronized(this) &#123; // 锁定当前对象实例
        // 代码块
    &#125;
&#125;

public void synchronizedBlockWithObject() &#123;
    Object lock = new Object();
    synchronized(lock) &#123; // 锁定指定的对象
        // 代码块
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行<strong>运算操作</strong>，索引将失效</li>
<li>字符串不加单引号，造成索引失效。(类型转换)</li>
<li>以%开头的Like模糊查询，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span><del>索引很多就会有很多B+树</del></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong> [where、group by、order by]<br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><del>对存储节省空间</del></p>
<pre><code class="java">如果我们经常根据客户ID和订单日期来查询订单，那么可以在 customer_id 和 order_date 上创建一个联合索引。
CREATE INDEX idx_customer_date ON orders (customer_id, order_date);

这个联合索引 idx_customer_date 有以下几个特点：

索引顺序：首先根据 customer_id 排序，然后在每个 customer_id 的基础上根据 order_date 排序。
查询优化：以下查询可以利用这个联合索引：
SELECT * FROM orders WHERE customer_id = ? AND order_date = ?;
SELECT * FROM orders WHERE customer_id = ?;
</code></pre>
<p>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它<br>大字段不建议建立索引是因为B+树一个叶子节点&#x2F;一个非叶子节点 差不多16k 一个节点对应一个[页] 多的话会更多层<br>尽量不用性别去创建索引</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<h4 id="mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层"><a href="#mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层" class="headerlink" title="mysql底层为什么用B+树利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层"></a>mysql底层为什么用B+树<del>利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层</del></h4><p><del><strong>二叉树</strong> O(logn) 容易退化成链表 所以不用它</del><br><del><strong>平衡二叉树</strong> 全部倾斜</del><br><del><strong>红黑树</strong> 一个节点只能存一个数据</del><br>B树能不能除了叶子节点其他不存数据呢？</p>
<blockquote>
<p>你可以设计一种变体的B树，其中只有叶子节点存储数据，而所有其他非叶子节点仅作为导航节点，不存储实际的数据。这种结构在概念上类似于B树的一个特例，通常被称为B树索引结构的一部分，其中非叶子节点存储的是键值，而叶子节点存储的是实际的数据记录或者是指向数据记录的指针</p>
</blockquote>
<p>B+树第三层2000多万条数据，尽量不要把数据达到2000多万<br>B+树叶子节点加了双向链表 让我们查询更加稳定 范围查询会更快</p>
<h6 id="mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高"><a href="#mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高" class="headerlink" title="mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高"></a>mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高</h6><p><strong>R—Tree</strong>：地理位置搜索</p>
<h6 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h6><p><code>where b= AND c= AND a= </code> 这样走索引都能走 底层自己排序<br>为什么联合索引要遵循最左匹配原则【里面的b+树 先按照a排序 再b 因为要二分查找 不排序怎么找？】</p>
<p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span><del>查询前用explain查询是否走了索引等问题</del></p>
<h6 id="explain查询后的列："><a href="#explain查询后的列：" class="headerlink" title="explain查询后的列："></a>explain查询后的列：</h6><pre><code class="java">id：查询中SELECT语句的序列号，如果该行引用其他行的并集结果，则该值可以为空。
select_type：表示查询的类型，常见的类型有：
SIMPLE：简单的SELECT查询，不使用UNION或子查询。
PRIMARY：最外层的SELECT查询。
UNION：在UNION中的第二个或随后的SELECT查询。
DEPENDENT UNION：在UNION中的第二个或随后的SELECT查询，取决于外层查询。
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT。
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外层查询。
table：查询的是哪个表。
type：这是你提到的一个非常重要的列，它表示MySQL在表中找到所需行的方式，也称为“访问类型”。以下是一些常见的访问类型，从最好到最差排序：
system：表只有一行（系统表）。
const：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，所以优化器的其余部分可以将这一行视为常量。
eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这通常是最好的联接类型，除了const类型。
ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。
fulltext：使用全文索引执行查询。
ref_or_null：与ref类似，但是MySQL会额外搜索包含NULL值的行。
index_merge：表示查询使用了两个或更多的索引。
unique_subquery：用于IN子查询，子查询返回不重复的值集。
index_subquery：用于IN子查询，子查询返回不重复的值集，可以使用索引。
range：使用索引来检索给定范围的行。
index：全索引扫描（比ALL快，因为索引通常比数据行小）。
ALL：全表扫描，这是最差的一种类型，因为MySQL必须检查每一行以找到匹配的行。
possible_keys：指出MySQL能使用哪些索引来优化查询。
key：MySQL实际决定使用的索引。
key_len：使用的索引的长度。越短越好。
ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。
rows：MySQL认为必须检查的用来返回请求数据的行数。
filtered：显示了通过条件过滤出的行数的百分比估计。
Extra：包含MySQL解析查询的额外信息，例如是否使用了索引，是否排序了结果，是否使用了临时表等
</code></pre>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、SKywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li><strong>聚簇索引(聚集索引)<strong>：数据与索引放到一块，B+树的叶子节点保存了整行数据，</strong>有且只有一个</strong>【id存放的b+树】</li>
<li>**非聚簇索引(二级索引)**：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个【叶子就是id的字段】</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
<p>怎么避免回表 → 使用覆盖索引！<br>需要name 直接 select name 而不用 select *<br>要按需来查找</p>
</blockquote>
<pre><code class="java">除了InnoDB，MySQL数据库还支持多种其他存储引擎，其中最著名的是MyISAM。以下是InnoDB和MyISAM两个存储引擎的主要区别：

事务支持：
InnoDB：支持事务，它遵循ACID原则（原子性、一致性、隔离性和持久性）。如果事务中的某个操作失败，整个事务可以回滚到开始状态。
MyISAM：不支持事务，这意味着你无法回滚操作，这对于数据完整性和恢复可能是一个问题。
    
锁定机制：
InnoDB：使用行级锁定，只锁定需要的特定行，这可以大大减少数据库操作的冲突。
MyISAM：使用表级锁定，每次操作都会锁定整个表，这在并发操作较多时可能导致性能问题。
    
崩溃恢复：
InnoDB：具有自动崩溃恢复功能，即使数据库崩溃，也不会丢失数据，因为它将事务日志写入磁盘。
MyISAM：在崩溃后恢复较为困难，可能会丢失数据，因为它不记录事务日志。
    
全文搜索：
InnoDB（MySQL 5.6及以后版本）：支持全文索引，但功能上不如MyISAM的全文搜索强大。
MyISAM：提供了更强大的全文搜索功能，但在MySQL 5.6之前，这是MyISAM相对于InnoDB的主要优势。
    
存储限制：
InnoDB：表的大小理论上受限于操作系统的文件大小限制，通常可以处理更大的数据量。
MyISAM：表的大小受限于最大文件大小，通常是2GB到4GB，这取决于文件系统的限制。
    
外键支持：
InnoDB：支持外键约束，这有助于保持数据的引用完整性。
MyISAM：不支持外键约束。
    
存储空间：
InnoDB：通常需要更多的存储空间，因为它存储了额外的信息来支持事务和行级锁定。
MyISAM：通常占用更少的存储空间，因为它不需要存储这些额外的信息
</code></pre>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<h4 id="MySQL的日志文件有哪些，它们的作用是什么"><a href="#MySQL的日志文件有哪些，它们的作用是什么" class="headerlink" title="MySQL的日志文件有哪些，它们的作用是什么"></a>MySQL的日志文件有哪些，它们的作用是什么</h4><p><strong>MySQL的日志文件有哪些，它们的作用是什么？</strong></p>
<p>MySQL主要有以下几种日志文件：</p>
<ul>
<li>错误日志（Error Log）：记录MySQL服务的启动、运行或停止过程中的错误信息。</li>
<li>查询日志（General Query Log）：记录所有MySQL执行的SQL命令，无论这些命令是否正确执行。</li>
<li>慢查询日志（Slow Query Log）：记录执行时间超过指定阈值的查询语句。</li>
<li><strong><u>二进制日志</u>（Binary Log）</strong>：<u>记录所有更改数据的SQL语句，用于主从复制和数据恢复。</u>事务的提交 和 主从复制</li>
<li><strong><u>事务日志&#x2F;重做日志</u>（InnoDB Redo Log）</strong>：<u>记录InnoDB存储引擎的事务操作，用于崩溃恢复。</u></li>
<li><strong><u>回滚日志&#x2F;撤销日志</u>（InnoDB Undo Log）</strong>：<u>用于事务回滚，保证事务的原子性。</u></li>
</ul>
<blockquote>
<p><span style = "color:red"><strong>undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是数据页的物理变化，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undo log保证了事务的原子性和一致性</p>
</blockquote>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
</blockquote>
<h4 id="MySQL主从同步原理？"><a href="#MySQL主从同步原理？" class="headerlink" title="MySQL主从同步原理？"></a><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></h4><blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
<pre><code class="java">主服务器（Master）上的数据更改（如INSERT、UPDATE、DELETE操作）会被记录到二进制日志中。
从服务器（Slave）上的I/O线程连接到主服务器，请求主服务器上的二进制日志。
主服务器将二进制日志发送给从服务器，从服务器将这些日志事件写入到本地的中继日志（Relay Log）。
从服务器上的SQL线程读取中继日志中的事件，并在本地执行这些事件，从而实现数据的复制。
</code></pre>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<h4 id="项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下"><a href="#项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下" class="headerlink" title="项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下"></a>项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下</h4><p>分布式事务问题可能出现在跨多个服务或数据库的操作中，例如在订单服务中同时更新订单状态和扣减库存。<del>秒杀案例：是先扣库存提前缓存到redis里，判断够不够，用RabbitMQ异步下来</del></p>
<p>解决方案：可以使用分布式事务框架，如Seata，其中AT模式是一种常见的解决方案。</p>
<p><strong>AT模式原理：</strong></p>
<ul>
<li>AT模式基于两阶段提交，分为两个阶段：一阶段 prepare 和二阶段 commit&#x2F;rollback。</li>
<li>在业务方法开始时，Seata会拦截业务SQL，记录业务数据在执行前后的镜像，生成行锁。</li>
<li>如果一阶段 prepare 成功，则二阶段进行 commit，直接提交事务；如果 prepare 失败，则执行 rollback，利用之前保存的数据镜像回滚到执行前的状态。</li>
</ul>
<h4 id="项目中哪里用到MQ，用来干什么？"><a href="#项目中哪里用到MQ，用来干什么？" class="headerlink" title="项目中哪里用到MQ，用来干什么？"></a><strong>项目中哪里用到MQ，用来干什么？</strong></h4><p>异步发优惠卷 + 积分 [用户对于实时性要求不是很高]</p>
<ul>
<li><h5 id="使用MQ的场景：订单处理"><a href="#使用MQ的场景：订单处理" class="headerlink" title="使用MQ的场景：订单处理"></a>使用MQ的场景：订单处理</h5><h5 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h5><p>当用户在电子商务平台上成功下单后，订单服务需要执行以下操作：</p>
<ol>
<li>更新订单状态为“已支付”。</li>
<li>扣减商品库存。</li>
<li>通知支付服务处理支付。</li>
<li>通知物流服务准备发货。</li>
</ol>
<h5 id="使用MQ的原因"><a href="#使用MQ的原因" class="headerlink" title="使用MQ的原因"></a>使用MQ的原因</h5><p>在这些操作中，更新订单状态和扣减库存是实时且同步的操作，但通知支付服务和物流服务则可以异步进行。使用MQ可以帮助我们实现以下目标：</p>
<ul>
<li><strong>解耦服务</strong>：订单服务不需要直接调用支付服务和物流服务，降低了服务间的耦合度。</li>
<li><strong>异步处理</strong>：订单服务可以立即响应客户端，不必等待支付和物流服务的处理结果。</li>
<li><strong>流量削峰</strong>：在高峰期，MQ可以缓冲大量的订单处理请求，避免服务被压垮。</li>
</ul>
</li>
</ul>
<p><strong>订单服务生产消息：</strong> 当订单服务完成订单状态更新和库存扣减后，它将以下消息发送到</p>
<pre><code>&#123;
  &quot;orderId&quot;: &quot;123456789&quot;,
  &quot;status&quot;: &quot;paid&quot;,
  &quot;userId&quot;: &quot;user123&quot;,
  &quot;items&quot;: [
    &#123;&quot;productId&quot;: &quot;prod123&quot;, &quot;quantity&quot;: 1&#125;,
    &#123;&quot;productId&quot;: &quot;prod456&quot;, &quot;quantity&quot;: 2&#125;
  ]
&#125;
</code></pre>
<p>这个消息将被发送到不同的主题或队列，例如<code>payment_topic</code>和<code>logistics_topic</code>。</p>
<p><strong>2. 支付服务和物流服务消费消息：</strong></p>
<ul>
<li><strong>支付服务</strong>订阅<code>payment_topic</code>，当接收到订单支付消息后，它会处理支付逻辑，如验证支付状态、记录交易日志等。</li>
<li><strong>物流服务</strong>订阅<code>logistics_topic</code>，当接收到订单消息后，它会准备发货，更新物流信息，并通知用户。</li>
</ul>
<p>通过这种方式，订单服务可以快速响应用户请求，而支付和物流服务可以按照自己的节奏处理订单相关的操作，整个系统因此变得更加灵活和可扩展。</p>
<h4 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a><strong>如何保证消息不丢失？</strong></h4><p>保证生产者能够成功发送到交换机和队列(存储消息)，生产者提供了消息确认机制<br>到队列后消息要有持久化机制<br>消费者要有一个消息确认机制 保证消费者至少消费成功消息一次</p>
<blockquote>
<ul>
<li><p>开启生产者确认机制，确保生产者的消息能到达队列<br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
</li>
<li><p>开启持久化功能，确保消息未消费前在队列中不会丢失<br>万一broker挂掉就惨了 保证至少成功一次消费</p>
</li>
<li><p>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack<br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息，而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h4 id="如何解决消息积压？"><a href="#如何解决消息积压？" class="headerlink" title="如何解决消息积压？"></a><strong>如何解决消息积压？</strong></h4><p>产生原因：当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h4 id="如何保证消费幂等性【MQ】"><a href="#如何保证消费幂等性【MQ】" class="headerlink" title="如何保证消费幂等性【MQ】"></a>如何保证消费幂等性【MQ】</h4><p>幂等性是指同一个操作执行多次和执行一次的效果相同。在消息消费的场景中，保证幂等性通常有以下几种方法：<br><strong><u>利用数据库的唯一约束</u><strong>：<br>在数据库中为消息设置唯一标识（如消息ID），在处理消息前先检查该标识是否已存在。<br>导致重复消费 返回ack，blocker未收到。一定要在</strong>生产者</strong>投递的时候生成全局唯一的id，消费者就会去判断。异步生成 拿订单号去数据库查 如果查得到就直接return<br><strong>精髓就是全局唯一</strong><br>UUID不行 因为每次发送的消息都不是同一个UUID 要用业务上的</p>
<h6 id="哪些地方还会有幂等问题？"><a href="#哪些地方还会有幂等问题？" class="headerlink" title="哪些地方还会有幂等问题？"></a>哪些地方还会有幂等问题？</h6><p>提供者的openfegin、xxl-job、被别人调用且涉及到增删改</p>
<h6 id="状态记录："><a href="#状态记录：" class="headerlink" title="状态记录："></a>状态记录：</h6><p>在消费消息前，记录消息的状态（如已处理），处理完毕后再更新状态。要根据订单ID+状态 来保证消费幂等性。订单存在且未支付 → 更新<del>锁订单ID</del></p>
<h6 id="并发情况幂等性："><a href="#并发情况幂等性：" class="headerlink" title="并发情况幂等性："></a>并发情况幂等性：</h6><p>完美的幂等要加上分布式锁<del>对敏感性要求高，且要控制好锁的力度</del></p>
<h4 id="如何保证消费有序性"><a href="#如何保证消费有序性" class="headerlink" title="如何保证消费有序性"></a>如何保证消费有序性</h4><p>队列中可以指定消息的消费顺序</p>
<p>  <strong>RabbitMQ</strong> → 多个生产者并发投，所以生产者不能保证有序性，只考虑消费有序性。以消息进入的MQ的消息去回答。</p>
<h5 id="怎么保证？"><a href="#怎么保证？" class="headerlink" title="怎么保证？"></a>怎么保证？</h5><h6 id="单线程消费："><a href="#单线程消费：" class="headerlink" title="单线程消费："></a>单线程消费：</h6><p>在消费者端使用单个线程处理消息，确保消息按顺序处理。</p>
<h6 id="分区有序："><a href="#分区有序：" class="headerlink" title="分区有序："></a>分区有序：</h6><p>在如Kafka这样的消息队列中，可以保证同一个分区内的消息是有序的。</p>
<h4 id="如何既要又要【有序-速度快】"><a href="#如何既要又要【有序-速度快】" class="headerlink" title="如何既要又要【有序 + 速度快】"></a>如何既要又要【有序 + 速度快】</h4><p>既要又要”通常指的是在保证消息的幂等性和有序性的同时，还需要考虑其他特性（如高性能、高可用等）<br>在一些场景下，可能需要在性能和一致性之间做权衡。例如，可以选择最终一致性来换取更高的性能。<br>Kafka 和 RocketMQ可以天生实现【底层Hash取模】</p>
<h6 id="若非要用RabbitMQ实现呢？"><a href="#若非要用RabbitMQ实现呢？" class="headerlink" title="若非要用RabbitMQ实现呢？"></a>若非要用RabbitMQ实现呢？</h6><p>不同订单之间是否要求一定顺序？？<br>镜像集群，先搭3个节点的镜像集群，建立三个队列分为不同的镜像节点 各占一个队列，需要自己去实现<br>对订单号进行hash取模看到落到哪个节点<br>三个队列至少三个消费者 分别去消费它们<br>此时就可以并行有三个消费者去执行<br>把业务数据没关系的放在不同的队列去管理</p>
<h6 id="万一挂掉了呢？"><a href="#万一挂掉了呢？" class="headerlink" title="万一挂掉了呢？"></a>万一挂掉了呢？</h6><p>队列有持久化不用担心</p>
<h4 id="能说一下如何使用死信交换机吗支付"><a href="#能说一下如何使用死信交换机吗支付" class="headerlink" title="能说一下如何使用死信交换机吗支付"></a>能说一下如何使用死信交换机吗<del>支付</del></h4><p>死信交换机（DLX）用于处理无法正常消费的消息<br>创建一个正常的交换机和队列，以及一个死信交换机和死信队列。</p>
<blockquote>
<ol>
<li><strong>定义死信交换机</strong>：创建一个用于处理死信的交换机。</li>
<li><strong>定义死信队列</strong>：创建一个队列用于接收死信，并将其绑定到死信交换机。</li>
<li><strong>配置主队列的死信交换机属性</strong>：在主队列上设置参数，指定当消息无法正常处理时应该发送到哪个死信交换机。</li>
<li><strong>发送消息到主队列</strong>：生产者将消息发送到主交换机，进而路由到主队列。</li>
<li><strong>消费主队列消息</strong>：消费者从主队列中获取消息并进行处理。如果消息处理失败，它将被路由到死信交换机。</li>
<li><strong>消费死信队列消息</strong>：设置消费者来处理死信队列中的消息，进行错误处理或记录日志等操作。</li>
</ol>
</blockquote>
<h4 id="mysql如何提升深分页查询效率子查询-索引"><a href="#mysql如何提升深分页查询效率子查询-索引" class="headerlink" title="mysql如何提升深分页查询效率子查询+索引"></a>mysql如何提升深分页查询效率<del>子查询+索引</del></h4><p><strong>使用索引</strong>：</p>
<ul>
<li>确保查询中使用的列上有适当的索引，这样可以加快查找速度。</li>
</ul>
<p>**避免使用<code>OFFSET</code>和<code>LIMIT</code>**：</p>
<ul>
<li>使用<code>OFFSET</code>进行深分页时，MySQL需要遍历所有<code>OFFSET</code>之前的行。可以通过记住上一次查询的最大ID来避免使用<code>OFFSET</code>。</li>
</ul>
<p><strong>使用条件过滤</strong>：</p>
<ul>
<li>如果可能，使用WHERE子句来减少需要扫描的数据量。</li>
</ul>
<p><strong>增加<code>LIMIT</code>的大小</strong>：</p>
<ul>
<li>如果业务允许，可以增加每次查询返回的结果集大小，减少分页次数。</li>
</ul>
<p><strong>缓存</strong>：</p>
<ul>
<li>对于不经常变更的数据，可以使用缓存来存储已经查询过的页。</li>
</ul>
<p><strong>使用<code>EXPLAIN</code>分析查询</strong>：</p>
<ul>
<li>使用<code>EXPLAIN</code>来分析查询计划，找出性能瓶颈并进行优化。</li>
</ul>
<h4 id="能说一下常用的存储引擎以及它们的差异吗"><a href="#能说一下常用的存储引擎以及它们的差异吗" class="headerlink" title="能说一下常用的存储引擎以及它们的差异吗"></a>能说一下常用的存储引擎以及它们的差异吗</h4><p><strong>InnoDB</strong>：<br>支持事务、行级锁和外键。<br>适合处理大量短期事务。<br>为了维护数据的完整性，写操作相对较慢</p>
<p><strong>MyISAM</strong>：</p>
<p>不支持事务、不支持行锁只支持表锁<br>并发没那么大 事务要求没那么高可以用</p>
<h4 id="能说一下倒排索引的原理吗？"><a href="#能说一下倒排索引的原理吗？" class="headerlink" title="能说一下倒排索引的原理吗？"></a>能说一下倒排索引的原理吗？</h4><p>根据参与文档中的字段 要构建倒排就会去分词<br>根据用户索引也会分词 就会去查文档id 再去查文档<br>中文词库为IK <del>(Ikun 你干嘛 哎哟~)</del></p>
<h4 id="es的text和keyword的区别"><a href="#es的text和keyword的区别" class="headerlink" title="es的text和keyword的区别"></a>es的text和keyword的区别</h4><h6 id="text"><a href="#text" class="headerlink" title="text"></a>text</h6><p>用于全文搜索，会分词，字符串类型</p>
<h6 id="keywod"><a href="#keywod" class="headerlink" title="keywod"></a>keywod</h6><p>用于精确搜索字段，不会被分词，字符串类型</p>
<h4 id="es在你的项目中是用来做什么的"><a href="#es在你的项目中是用来做什么的" class="headerlink" title="es在你的项目中是用来做什么的"></a>es在你的项目中是用来做什么的</h4><p>快速搜索<del>商品(C端)、订单(后台)</del> + 日志查询 + 地理位置搜索<del>经纬度定位附近的事物</del></p>
<h4 id="mysql和ElasticSearch如何做数据同步"><a href="#mysql和ElasticSearch如何做数据同步" class="headerlink" title="mysql和ElasticSearch如何做数据同步"></a>mysql和ElasticSearch如何做数据同步</h4><p>mysql进行增删改的时候<br>对数据敏感性实时性要求没那么高 只看<u>可靠性</u>[<strong>MQ</strong>异步  +  <strong>定时任务</strong>  &#x3D; 没有那么强一致性]</p>
<h6 id="如果数据量没那么大-有没有必要上ES？"><a href="#如果数据量没那么大-有没有必要上ES？" class="headerlink" title="如果数据量没那么大 有没有必要上ES？"></a>如果数据量没那么大 有没有必要上ES？</h6><p>没有必要，正排索引不走全表扫描也蛮快<br>组长进行技术选型 考虑到以后的业务增长</p>
<h6 id="项目已经上线了-但是中途想换成ES-怎么办"><a href="#项目已经上线了-但是中途想换成ES-怎么办" class="headerlink" title="项目已经上线了 但是中途想换成ES 怎么办"></a>项目已经上线了 但是中途想换成ES 怎么办</h6><p>mysql是全量数据 mq只能同步增量数据 怎么办呢？<br>新上架的只能到ES 那应该如何？</p>
<p>此时涉及到全量和增量的同步<del>与Redis不一样</del><br>加定时任务每周&#x2F;每天 会定期重构一次索引库<del>晚上跑→兜底模式</del>，全量同步，后期再增量同步</p>
<h4 id="能说一下分词的原理吗"><a href="#能说一下分词的原理吗" class="headerlink" title="能说一下分词的原理吗"></a>能说一下分词的原理吗</h4><p>底层是大数据量的内容 树的结构来构建分词 IK，<u>字符分割、词汇识别、过滤停用词</u><br>不好意思面试官 具体底层原理不是很了解</p>
<h4 id="使用ES有遇到什么问题吗"><a href="#使用ES有遇到什么问题吗" class="headerlink" title="使用ES有遇到什么问题吗"></a>使用ES有遇到什么问题吗</h4><p>类似于深分页！<br>测试环境数据量不会很大 等到上线后才会有这种问题</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/03/28/面试/Java面试/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/02/28/后端/SpringBoot入门及电商项目[SpringBoot_MyBatis.generator_Swagger2_Redis_Postman_RESTful_AOP_UUID_QRCode_Linux_Aliyun]/">
        <h2>
            SpringBoot入门及电商项目[SpringBoot_MyBatis.generator_Swagger2_Redis_Postman_RESTful_AOP_UUID_QRCode_Linux_Aliyun]
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/2/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring-Boot电商项目入门与实战"><a href="#Spring-Boot电商项目入门与实战" class="headerlink" title="Spring Boot电商项目入门与实战"></a>Spring Boot电商项目入门与实战</h1><ul>
<li>重量级的电商项目，前后端彻底分离</li>
<li>体验企业级开发流程：需求分析、设计、编码、测试、上线</li>
<li>用户管理、商品分析、商品管理、购物车、订单等核心功能</li>
<li>数据库的设计与实现</li>
<li>应用<strong>RESTful</strong>进行接口设计，并使用<strong>Postman</strong>进行接口测试</li>
<li>应用<strong>MyBatis generator</strong>代码自动生成插件，提升开发效率</li>
<li>使用阿里云完成项目的线上部署</li>
<li>使用<strong>Swagger2</strong>构建强大的API文档</li>
<li>使用<strong>Redis</strong>对商品分类信息进行缓存</li>
<li>使用<strong>JSR-303</strong>实现请求参数校验</li>
</ul>
<h2 id="Spring-Boot入门"><a href="#Spring-Boot入门" class="headerlink" title="Spring Boot入门"></a>Spring Boot入门</h2><h5 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h5><ul>
<li>Java 1.8.0</li>
<li>MySQL 8.0.12</li>
<li>Maven 3.3.9</li>
<li>Spring Boot 2.2.1(严格一致)</li>
</ul>
<h3 id="Spring-Boot诞生历史"><a href="#Spring-Boot诞生历史" class="headerlink" title="Spring Boot诞生历史"></a>Spring Boot诞生历史</h3><ul>
<li>Spring的缺点：配置过于繁琐</li>
<li>Spring Boot开发团队：Pivotal</li>
</ul>
<h3 id="Spring-Boot简介"><a href="#Spring-Boot简介" class="headerlink" title="Spring Boot简介"></a>Spring Boot简介</h3><ul>
<li>简化初始搭建以及开发过程</li>
<li>不再需要定义样板化的配置</li>
<li>快速应用开发领域</li>
</ul>
<h3 id="Spring、Spring-MVC、Spring-Boot"><a href="#Spring、Spring-MVC、Spring-Boot" class="headerlink" title="Spring、Spring MVC、Spring Boot"></a>Spring、Spring MVC、Spring Boot</h3><ul>
<li><strong>Spring</strong>最初利用IOC和AOP解耦</li>
<li>按照这种模式搞了MVC框架</li>
<li>写很多样板代码很麻烦，就有了<strong>Spring Boot</strong></li>
<li><strong>Spring Cloud</strong>是在Spring Boot基础上</li>
</ul>
<h3 id="Spring-Boot核心特点"><a href="#Spring-Boot核心特点" class="headerlink" title="Spring Boot核心特点"></a>Spring Boot核心特点</h3><ul>
<li>开箱即用</li>
<li>约定优于配置</li>
</ul>
<h3 id="Spring-Boot版本介绍"><a href="#Spring-Boot版本介绍" class="headerlink" title="Spring Boot版本介绍"></a>Spring Boot版本介绍</h3><ul>
<li>CURRENT             2.2.1 CURRENT GA [最新版本]</li>
<li>GA                         2.2.2 SNAPSHOT [GA&#x3D;General Availability 面向大众稳定版本 版本永恒不变]</li>
<li>SNAPSHOT          2.1.11 SNAPSHOT [快照 版本随时被修改]</li>
<li>如何选择版本？   <strong>2.1.10 GA</strong></li>
</ul>
<h3 id="新建Spring-Boot项目演示"><a href="#新建Spring-Boot项目演示" class="headerlink" title="新建Spring Boot项目演示"></a>新建Spring Boot项目演示</h3><ul>
<li>Spring官网 <strong><a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a></strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c9c72f61bc8fdb6d207a1221c3e2fb6ed9dcad81/data/%E6%96%B0%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%BC%94%E7%A4%BA.jpg"></p>
<ul>
<li>IDEA集成的Spring Initializr</li>
</ul>
<h3 id="第一个接口开发"><a href="#第一个接口开发" class="headerlink" title="第一个接口开发"></a>第一个接口开发</h3><pre><code class="java">com/imooc/springbootlearn/SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringBootlearnApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;

&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/ParaController.java
package com.imooc.springbootlearn;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 演示各种传参形式
 */
@RestController
public class ParaController &#123;
    @GetMapping(&#123;&quot;/firstrequest&quot;&#125;)
    public String firstRequest()&#123;
        return &quot;第一个Spring Boot接口&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;SpringBootlearn&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;SpringBootlearn&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id="多种配置URL的方式"><a href="#多种配置URL的方式" class="headerlink" title="多种配置URL的方式"></a>多种配置URL的方式</h3><pre><code class="java">com/imooc/springbootlearn/ParaController.java
package com.imooc.springbootlearn;

import org.springframework.web.bind.annotation.*;

/**
 * 演示各种传参形式
 */
@RestController
@RequestMapping(&quot;/prefix&quot;)//统一增加公共前缀
public class ParaController &#123;
    @GetMapping(&#123;&quot;/firstrequest&quot;&#125;)
    public String firstRequest() &#123;
        return &quot;第一个Spring Boot接口&quot;;
    &#125;

    //@RequestParam 从请求中找到这个参数进行绑定
    @GetMapping(&#123;&quot;/requestpara&quot;&#125;)
    public String requestpara(@RequestParam Integer num) &#123;
        return &quot;para from request: &quot; + num;
    &#125;

    //@PathVariable 从URL中寻找对应的参数进行绑定
    @GetMapping(&#123;&quot;/para/&#123;num&#125;&quot;&#125;)
    public String pathpara(@PathVariable Integer num) &#123;
        return &quot;para from path: &quot; + num;
    &#125;

    //多URL的用法
    @GetMapping(&#123;&quot;/multiurl1&quot;, &quot;/multiurl2&quot;&#125;)
    public String multiurl(@RequestParam Integer num) &#123;
        return &quot;para from path: &quot; + num;
    &#125;

    //增加程序健壮性 不一定必须传值
    @GetMapping(&#123;&quot;/required&quot;&#125;)
    public String required(@RequestParam(required =
            false, defaultValue = &quot;0&quot;) Integer num) &#123;
        return &quot;para form request: &quot; + num;
    &#125;
&#125;
</code></pre>
<h3 id="Web项目的三层结构"><a href="#Web项目的三层结构" class="headerlink" title="Web项目的三层结构"></a>Web项目的三层结构</h3><ul>
<li><strong>Controller职责</strong>：对外暴露接口</li>
<li><strong>Service职责</strong>：复杂业务场景下对业务逻辑做一层抽象和封装，保持Controller的简洁和独立，抽象出来的Service可以被Controller重复调用。具体业务代码写在service层，Controller只做简单的逻辑判断</li>
<li><strong>DAO层职责</strong>：和数据相关的、增删改查数据库代码</li>
</ul>
<h3 id="配置文件简介"><a href="#配置文件简介" class="headerlink" title="配置文件简介"></a>配置文件简介</h3><ul>
<li><p><strong>properties</strong>：容器端口名、数据库信息、日志级别…</p>
<ul>
<li>environments.dev.url&#x3D;<a target="_blank" rel="noopener" href="http://imooc.com/">http://imooc.com</a></li>
<li>environments.dev.name&#x3D;Developer</li>
</ul>
</li>
<li><p><strong>yml</strong>：分层级，冒号后需要空格</p>
<ul>
<li>enviroments:<ul>
<li>dev:<ul>
<li>url: <a target="_blank" rel="noopener" href="http://imooc.com/">http://imooc.com</a></li>
<li>name: Developer</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以自动转换的网址：<a target="_blank" rel="noopener" href="https://www.toyaml.com/">在线yaml转properties-在线properties转yaml-ToYaml.com</a></p>
<pre><code class="java">Properties:
server.port=8081
server.servlet.context-path=/first
============================================================
YAML:
server:
  port: 8081
  servlet:
    context-path: /first
</code></pre>
<h3 id="进行自定义配置"><a href="#进行自定义配置" class="headerlink" title="进行自定义配置"></a>进行自定义配置</h3><p><strong>注解类</strong>配置载入数据[利用@Value注解]</p>
<pre><code class="java">com/imooc/springbootlearn/PropertiesController.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 演示读取配置的Controller
 */
@RestController
public class PropertiesController &#123;
    //用@Value将properties的设置值进行绑定
    @Value(&quot;$&#123;school.grade&#125;&quot;)
    Integer grade;
    @Value(&quot;$&#123;school.classnum&#125;&quot;)
    Integer classnum;
    @GetMapping(&quot;/gradeclass&quot;)
    public String gradeClass()&#123;
        return &quot;年级： &quot; + grade + &quot; 班级：&quot; + classnum;
    &#125;
&#125;
</code></pre>
<pre><code class="java">resoources/application.properties
#server.port=8081
##对于整个项目建立统一的前缀 http://127.0.0.1:8081/first/prefix/required
#server.servlet.context-path=/first
#school.方便分类
school.grade=3
school.classnum=6
</code></pre>
<p><strong>配置类</strong>文件配置载入数据</p>
<pre><code class="java">com/imooc/springbootlearn/SchoolConfig.java
package com.imooc.springbootlearn;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * School配置类
 */
@Component
@ConfigurationProperties(prefix = &quot;school&quot;)
public class SchoolConfig &#123;
    //自动去配置信息里寻找且绑定
    Integer grade;
    Integer classnum;

    public Integer getGrade() &#123;
        return grade;
    &#125;

    public void setGrade(Integer grade) &#123;
        this.grade = grade;
    &#125;

    public Integer getClassnum() &#123;
        return classnum;
    &#125;

    public void setClassnum(Integer classnum) &#123;
        this.classnum = classnum;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/ConfigController.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 读取配置类
 */
@RestController
public class ConfigController &#123;
    @Autowired
    SchoolConfig schoolConfig;
    @GetMapping(&#123;&quot;/gradefromconfig&quot;&#125;)
    public String gradeclass()&#123;
        return &quot;年级： &quot; + schoolConfig.grade + &quot; 班级：&quot; + schoolConfig.classnum;

    &#125;
&#125;
</code></pre>
<h3 id="Service和Dao的编写"><a href="#Service和Dao的编写" class="headerlink" title="Service和Dao的编写"></a>Service和Dao的编写</h3><ul>
<li><h5 id="学生信息查询案例"><a href="#学生信息查询案例" class="headerlink" title="学生信息查询案例"></a>学生信息查询案例</h5></li>
</ul>
<pre><code class="java">com/imooc/springbootlearn/Student.java
package com.imooc.springbootlearn;

/**
 * 学生实体类
 */
public class Student &#123;
    Integer id;
    String name;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/StudentController.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 学生Controller
 */
@RestController
public class StudentController &#123;
    @Autowired
    StudentService studentService;
    //服务层 去中转

    @GetMapping(&quot;/student&quot;)
    public String student(@RequestParam Integer num)&#123;
        Student student = studentService.findStudent(num);
        return student.toString();
    &#125;
&#125;
/*
联系
@Autowired和@Resource注解都是作为bean对象注入的时候使用的
两者都可以声明在字段和setter方法上
注意：如果声明在字段上，那么就不需要再写setter方法。但是本质上，该对象还是作为set方法的实参，通过执行set方法注入，只是省略了setter方法罢了

区别
@Autowired注解是Spring提供的，而@Resource注解是J2EE本身提供的
@Autowird注解默认通过byType方式注入，而@Resource注解默认通过byName方式注入
@Autowired注解注入的对象需要在IOC容器中存在，否则需要加上属性required=false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错
*/
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/StudentService.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 学生Service  之后调用mapper操作数据库[interface]
 */
@Service
public class StudentService &#123;
    @Autowired
    StudentMapper studentMapper;

    public Student findStudent(Integer id)&#123;
        return studentMapper.findById(id);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/StudentMapper.java 【接口】
package com.imooc.springbootlearn;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

/**
 * 学生Mapper
 */
@Mapper
@Repository
public interface StudentMapper &#123;
    @Select(&quot;select * from students where id = #&#123;id&#125;&quot;)
    Student findById(Integer id);
&#125;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;springbootlearn&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;SpringBootlearn&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages=&quot;com.imooc&quot;)
public class SpringBootlearnApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;

&#125;
</code></pre>
<pre><code class="java">application.properties
#server.port=8081
#server.servlet.context-path=/first
school.grade=10
school.classnum=6

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<hr>
<hr>
<h1 id="SpringBoot电商项目"><a href="#SpringBoot电商项目" class="headerlink" title="SpringBoot电商项目"></a>SpringBoot电商项目</h1><p><a target="_blank" rel="noopener" href="http://127.0.0.1:8083/#/index">慕慕生鲜前台</a><br><a target="_blank" rel="noopener" href="http://127.0.0.1:8083//admin/index.html#/login">慕慕生鲜后台</a></p>
<h3 id="课程整体介绍"><a href="#课程整体介绍" class="headerlink" title="课程整体介绍"></a>课程整体介绍</h3><ul>
<li>为什么要做电商项目</li>
<li>项目亮点以及功能模块介绍</li>
<li>项目演示</li>
<li>项目开发所需要工具准备</li>
<li>数据库设计与项目初始化</li>
<li>功能模块开发</li>
<li>阿里云部署</li>
<li>项目总结</li>
</ul>
<h3 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h3><ul>
<li>最新的业界的互联网企业的优质技术</li>
<li>代码规范简介，充分优化</li>
<li>流程完整、电商功能丰富</li>
<li>前后端彻底分离，符合未来趋势，学了就能用</li>
</ul>
<h3 id="功能模块介绍"><a href="#功能模块介绍" class="headerlink" title="功能模块介绍"></a>功能模块介绍</h3><ul>
<li><h4 id="项目功能："><a href="#项目功能：" class="headerlink" title="项目功能："></a>项目功能：</h4><ul>
<li><h5 id="前台-用户、商品分类、商品信息、购物车、订单"><a href="#前台-用户、商品分类、商品信息、购物车、订单" class="headerlink" title="前台  {用户、商品分类、商品信息、购物车、订单}"></a><span style = "color:red">前台  {用户、商品分类、商品信息、购物车、订单}</span></h5><ul>
<li><strong>用户模块</strong>{注册、登录、更新签名、身份认证、登出}</li>
<li><strong>商品分类模块</strong>{多级目录、递归查询、缓存}</li>
<li><strong>商品模块</strong>{商品搜索、商品排序、商品列表、目录展示、商品详情}</li>
<li><strong>购物车模块</strong>{加入商品、列表显示、数量更改、删除商品、勾选反选、全选全不选}</li>
<li><strong>订单模块</strong>{下单、订单流程、订单详情、取消订单、支付二维码、扫码支付、个人订单、确认收货}</li>
</ul>
</li>
<li><h5 id="后台-用户、商品分类、商品信息、订单"><a href="#后台-用户、商品分类、商品信息、订单" class="headerlink" title="后台  {用户、商品分类、商品信息、订单}"></a><span style = "color:red">后台  {用户、商品分类、商品信息、订单}</span></h5><ul>
<li><strong>管理员模块</strong>{登录登出、身份认证、安全限制}</li>
<li><strong>商品分类模块</strong>{分类列表、增加分类、修改分类、删除分类}</li>
<li><strong>商品模块</strong>{商品列表、新增商品、图片上传、更新删除、批量上下架}</li>
<li><strong>订单模块</strong>{订单列表、地址信息、发货、订单完结}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h3><ul>
<li>前后端分离</li>
<li>接口文档</li>
<li>全栈、CTO</li>
<li>核心是接口的设计</li>
</ul>
<h3 id="项目开发所需工具准备"><a href="#项目开发所需工具准备" class="headerlink" title="项目开发所需工具准备"></a>项目开发所需工具准备</h3><ul>
<li><strong>IDEA</strong>常用优质插件介绍<ul>
<li>Maven Helper</li>
<li>Free MyBatis plugin [跳转&#x2F;识别mapper语法错误]</li>
</ul>
</li>
<li><strong>Postman</strong>安装和常用功能演示</li>
<li><strong>MySQL可视化工具</strong></li>
</ul>
<h3 id="数据库设计与项目初始化"><a href="#数据库设计与项目初始化" class="headerlink" title="数据库设计与项目初始化"></a>数据库设计与项目初始化</h3><ul>
<li>表设计</li>
<li>技术选型、思路</li>
<li>新建项目，整合Mybatis，跑通接口</li>
<li>引用log4j2日志组件</li>
<li>使用AOP统一处理Web请求日志 [请求的参数  返回的商品、字段]</li>
</ul>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul>
<li>Spring Boot 2.2.1RELEASE</li>
<li>MyBatis 3.4.6(优点)</li>
<li>Maven 3.6.1</li>
</ul>
<h3 id="技术选型需要考虑的点"><a href="#技术选型需要考虑的点" class="headerlink" title="技术选型需要考虑的点"></a>技术选型需要考虑的点</h3><ul>
<li>选择你最熟悉的技术 [最好不要超过30%的新技术]</li>
<li>选择拥有强大社区支撑的开源技术</li>
<li>确保技术前进步伐</li>
<li>学会从业务端开始思考</li>
<li>重视经验</li>
</ul>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><ul>
<li>新建项目</li>
<li>mybatis-generator的安装配置</li>
<li>自动生成DAO层文件</li>
<li>跑通接口</li>
</ul>
<p>【下方链接的主要问题就是 由于项目中的jdk和你实际安装的jdk不匹配】<br>{修改Project Structure → Project的版本}<br>{修改启动Edit的版本}<br>{修改setting→Build,Execution,Deployment→Compiler→Java Compiler中的<strong>Project version</strong>以及项目的<strong>Target version</strong>}</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44664231/article/details/131544077">【Java异常】完美解决this version of the Java Runtime only recognizes class file versions up to xx.0异常_java runtime (class file version 61.0), this versi-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51970165/article/details/128242289">fileversion 55.0 this version of the Java Runtime only recognizes class file versions up to 52.0：已解决_class file version 55.0-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_54878983/article/details/134912368">彻底解决：IDEA java: 警告: 源发行版 17 需要目标发行版 17-CSDN博客</a></p>
<pre><code class="xml">generatorConfig.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
  &lt;!-- 配置文件，放在resource目录下即可 --&gt;
  &lt;!--数据库驱动个人配置--&gt;
  &lt;classPathEntry
    location=&quot;/Users/Pluminary/.m2/repository/mysql/mysql-connector-java/8.0.18/mysql-connector-java-8.0.18.jar&quot;/&gt;
  &lt;context id=&quot;MysqlTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
    &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt;
    &lt;!--可以使用``包括字段名，避免字段名与sql保留字冲突报错--&gt;
    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;
    &lt;commentGenerator&gt;
      &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;
      &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;
    &lt;/commentGenerator&gt;
    &lt;!--数据库链接地址账号密码--&gt;
    &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
      connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&quot;
      userId=&quot;root&quot;
      password=&quot;root&quot;&gt;
      &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;
    &lt;/jdbcConnection&gt;
    &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;
    &lt;javaTypeResolver&gt;
      &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
    &lt;/javaTypeResolver&gt;
    &lt;!--生成Model类存放位置--&gt;
    &lt;javaModelGenerator targetPackage=&quot;com.imooc.mall.model.pojo&quot;
      targetProject=&quot;src/main/java&quot;&gt;
      &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
      &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;
      &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
      &lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;
      &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;
    &lt;/javaModelGenerator&gt;
    &lt;!--生成mapper映射文件存放位置--&gt;
    &lt;sqlMapGenerator targetPackage=&quot;mappers&quot; targetProject=&quot;src/main/resources&quot;&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/sqlMapGenerator&gt;
    &lt;!--生成Dao类存放位置--&gt;
    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.imooc.mall.model.dao&quot;
      targetProject=&quot;src/main/java&quot;&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/javaClientGenerator&gt;
    &lt;!--生成对应表及类名--&gt;
    &lt;table schema=&quot;root&quot; tableName=&quot;imooc_mall_cart&quot; domainObjectName=&quot;Cart&quot;
      enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_category&quot; domainObjectName=&quot;Category&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_order&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_order_item&quot; domainObjectName=&quot;OrderItem&quot;
      enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_product&quot; domainObjectName=&quot;Product&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;

  &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="xml">application.properties
spring.datasource.name=imooc_mall_datasource
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;mall&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;small&lt;/name&gt;
    &lt;description&gt;small&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;!--  1.依赖mysql-connector-java  mybatis-spring-boot-starter 加入generatorConfig.xml 写下面的Plugins--&gt;
&lt;!-- 2. 加入imooc_mall_local.sql后 点Maven -&gt; Plugins -&gt; mybatis-generator -&gt; 点击第一个 --&gt;
&lt;!--  通过插件生成 此时就出来了com/imooc/mall/model/dao里面所有的 和 com/imooc/mall/model/pojo里面所有的 和 mappers--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.7&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;verbose&gt;true&lt;/verbose&gt;
                    &lt;overwrite&gt;true&lt;/overwrite&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">package com.imooc.mall.controller;

import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 用户控制器
 */
@Controller
public class UserController &#123;
    //4.返回对象的基本信息 return里面会写和service相关的  5建立Service层
    @Autowired
    UserService userService;
    @GetMapping(&quot;/test&quot;)
    @ResponseBody //返回Json格式内容
    public User personalPage()&#123;
//  6.补全return 7告诉mapper在哪里怎么去找 去application.properties编写 mybatis.mapper-locations:......
//  去主类里编写@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;) 以防找不到mapper 8.去配置端口8083
//   9.加入log4j2.xml
        return userService.getUser();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/UserService.java
package com.imooc.mall.service;

import com.imooc.mall.model.pojo.User;

//5.这是抽象的接口 还要让它实现 再创建一个impl 实现接口类 UserServiceImpl.java
public interface UserService &#123;
    User getUser();
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.model.dao.UserMapper;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * UserService实现类
 */
@Service
//5.重写里面的方法  @Autowired引入一个mapper去查询数据库返回真正的信息 6返回UserController补全return
public class UserServiceImpl implements UserService &#123;
    @Autowired
    UserMapper userMapper;

    @Override
    public User getUser()&#123;
        //通过主键来查询一个对象
        return userMapper.selectByPrimaryKey(1);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.mall;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;)
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="log4j2日志"><a href="#log4j2日志" class="headerlink" title="log4j2日志"></a>log4j2日志</h3><ul>
<li>日志级别(优先级降低)：error, warn, info, debug, trace</li>
<li>排除Logback依赖</li>
</ul>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">log4j2.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;fatal&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;baseDir&quot; value=&quot;$&#123;sys:user.home&#125;/Desktop/idea_Space/logs&quot;/&gt;
  &lt;/Properties&gt;

  &lt;Appenders&gt;
    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
      &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt;
      &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot;
        onMismatch=&quot;DENY&quot;/&gt;
      &lt;PatternLayout
        pattern=&quot;[%d&#123;MM:dd HH:mm:ss.SSS&#125;] [%level] [%logger&#123;36&#125;] - %msg%n&quot;/&gt;
    &lt;/Console&gt;

    &lt;!--debug级别日志文件输出--&gt;
    &lt;RollingFile name=&quot;debug_appender&quot; fileName=&quot;$&#123;baseDir&#125;/debug.log&quot;
      filePattern=&quot;$&#123;baseDir&#125;/debug_%i.log.%d&#123;yyyy-MM-dd&#125;&quot;&gt;
      &lt;!-- 过滤器 --&gt;
      &lt;Filters&gt;
        &lt;!-- 限制日志级别在debug及以上在info以下 --&gt;
        &lt;ThresholdFilter level=&quot;debug&quot;/&gt;
        &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
      &lt;/Filters&gt;
      &lt;!-- 日志格式 --&gt;
      &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;
      &lt;!-- 策略 --&gt;
      &lt;Policies&gt;
        &lt;!-- 每隔一天转存 --&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
        &lt;!-- 文件大小 --&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;

    &lt;!-- info级别日志文件输出 --&gt;
    &lt;RollingFile name=&quot;info_appender&quot; fileName=&quot;$&#123;baseDir&#125;/info.log&quot;
      filePattern=&quot;$&#123;baseDir&#125;/info_%i.log.%d&#123;yyyy-MM-dd&#125;&quot;&gt;
      &lt;!-- 过滤器 --&gt;
      &lt;Filters&gt;
        &lt;!-- 限制日志级别在info及以上在error以下 --&gt;
        &lt;ThresholdFilter level=&quot;info&quot;/&gt;
        &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
      &lt;/Filters&gt;
      &lt;!-- 日志格式 --&gt;
      &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;
      &lt;!-- 策略 --&gt;
      &lt;Policies&gt;
        &lt;!-- 每隔一天转存 --&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
        &lt;!-- 文件大小 --&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;

    &lt;!-- error级别日志文件输出 --&gt;
    &lt;RollingFile name=&quot;error_appender&quot; fileName=&quot;$&#123;baseDir&#125;/error.log&quot;
      filePattern=&quot;$&#123;baseDir&#125;/error_%i.log.%d&#123;yyyy-MM-dd&#125;&quot;&gt;
      &lt;!-- 过滤器 --&gt;
      &lt;Filters&gt;
        &lt;!-- 限制日志级别在error及以上 --&gt;
        &lt;ThresholdFilter level=&quot;error&quot;/&gt;
      &lt;/Filters&gt;
      &lt;!-- 日志格式 --&gt;
      &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;
      &lt;Policies&gt;
        &lt;!-- 每隔一天转存 --&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
        &lt;!-- 文件大小 --&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;debug&quot;&gt;
      &lt;AppenderRef ref=&quot;Console&quot;/&gt;
      &lt;AppenderRef ref=&quot;debug_appender&quot;/&gt;
      &lt;AppenderRef ref=&quot;info_appender&quot;/&gt;
      &lt;AppenderRef ref=&quot;error_appender&quot;/&gt;
    &lt;/Root&gt;

  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h3 id="AOP统一处理Web请求日志"><a href="#AOP统一处理Web请求日志" class="headerlink" title="AOP统一处理Web请求日志"></a>AOP统一处理Web请求日志</h3><ul>
<li>为什么需要AOP统一处理Web请求日志 [对系统健壮性的保证 创建filter]</li>
</ul>
<pre><code class="java">com/imooc/mall/filter/WebLogAspect.java
package com.imooc.mall.filter;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.util.Arrays;

/**
 * 打印请求和响应信息
 */
@Aspect
@Component
public class WebLogAspect &#123;
    //生成loger类
    private final Logger log = LoggerFactory.getLogger(WebLogAspect.class);
//10.增加一个拦截点AOP
    @Pointcut(&quot;execution(public * com.imooc.mall.controller..*.*(..))&quot;)
    public void webLog()&#123;

    &#125;
//  10.提供请求参数
    @Before(&quot;webLog()&quot;)
    public void doBefore(JoinPoint joinPoint)&#123;
        //收到请求,记录请求内容  请求到来所作的事情
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        log.info(&quot;URL: &quot; + request.getRequestURI().toString());
        log.info(&quot;HTTP_METHOD: &quot; + request.getMethod());
        log.info(&quot;IP: &quot; + request.getRemoteAddr());
        log.info(&quot;CLASS_METHOD: &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());
        log.info(&quot;ARGS: &quot; + Arrays.toString(joinPoint.getArgs()));
    &#125;
//  11.返回的时候也要拦截  返回参数res 拦截点webLog
    @AfterReturning(returning = &quot;res&quot;,pointcut = &quot;webLog()&quot;)
    public void doAfterReturning(Object res)throws Exception&#123;
        //处理完请求,返回内容
        log.info(&quot;RESPONSE: &quot; + new ObjectMapper().writeValueAsString(res));
    &#125;
&#125;
</code></pre>
<h3 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h3><ul>
<li>整体介绍：知识点、功能点<br> [<u>登录、注册、重名校验、密码加密存储、Session的使用、越权校验、统一响应对象、异常枚举、Java异常体系、Postman实操、统一异常处理、更新个人信息</u>]</li>
<li>接口设计</li>
<li>编码设计</li>
</ul>
<h3 id="API统一返回对象"><a href="#API统一返回对象" class="headerlink" title="API统一返回对象"></a>API统一返回对象</h3><pre><code class="java">package com.imooc.mall.common;

import com.imooc.mall.exception.ImoocMallExceptionEnum;

/**
 * 通用返回对象 T有可能是返回的购物车对象
 * 12.编写响应API      13创建枚举异常com/imooc/mall/exception/ImoocMallExceptionEnum.java
 */
public class ApiRestResponse&lt;T&gt; &#123;
    private Integer status;
    private String msg;
    private T data;
    private static final int OK_CODE = 10000;
    private static final String OK_MSG = &quot;SUCCESS&quot;;

    public ApiRestResponse(Integer status, String msg, T data) &#123;
        this.status = status;
        this.msg = msg;
        this.data = data;
    &#125;

    public ApiRestResponse(Integer status, String msg) &#123;
        this.status = status;
        this.msg = msg;
    &#125;

    public ApiRestResponse() &#123;
        //默认请求信息
        this(OK_CODE, OK_MSG);
    &#125;
    public static&lt;T&gt; ApiRestResponse&lt;T&gt; success()&#123;
//   建立带着10000 和 SUCCESS的方法
        return new ApiRestResponse&lt;&gt;();
    &#125;

    public static &lt;T&gt; ApiRestResponse&lt;T&gt; error(Integer code, String msg) &#123;
        return new ApiRestResponse&lt;&gt;(code, msg);
    &#125;
//  14.用枚举来搞错误 为了方便调试编写完后生成一个toString方法 15修改UserController的register()
    public static &lt;T&gt; ApiRestResponse&lt;T&gt; error(ImoocMallExceptionEnum ex) &#123;
        return new ApiRestResponse&lt;&gt;(ex.getCode(), ex.getMsg());
    &#125;
//   把错误[异常]创建成一个枚举类

    public static&lt;T&gt; ApiRestResponse&lt;T&gt; success(T result)&#123;
//    两个成功success的方法
        ApiRestResponse&lt;T&gt; response = new ApiRestResponse&lt;&gt;();
        response.setData(result);
        return response;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;ApiRestResponse&#123;&quot; +
                &quot;status=&quot; + status +
                &quot;, msg=&#39;&quot; + msg + &#39;\&#39;&#39; +
                &quot;, data=&quot; + data +
                &#39;&#125;&#39;;
    &#125;

    public Integer getStatus() &#123;
        return status;
    &#125;

    public void setStatus(Integer status) &#123;
        this.status = status;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;

    public T getData() &#123;
        return data;
    &#125;

    public void setData(T data) &#123;
        this.data = data;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
package com.imooc.mall.exception;

/**
 * 异常枚举
 */
//13.编写异常枚举 注意类是enum噢  14返回ApiRestResponse
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;);


    //异常码
    Integer code;
    //异常信息
    String msg;

    ImoocMallExceptionEnum(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<h3 id="注册接口开发"><a href="#注册接口开发" class="headerlink" title="注册接口开发"></a>注册接口开发</h3><pre><code class="java">com/imooc/mall/controller/UserController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 用户控制器
 */
@Controller
public class UserController &#123;
    //4.返回对象的基本信息 return里面会写和service相关的  5建立Service层
    @Autowired
    UserService userService;
    @GetMapping(&quot;/test&quot;)
    @ResponseBody //返回Json格式内容
    public User personalPage()&#123;
//  6.补全return 7告诉mapper在哪里怎么去找 去application.properties编写 mybatis.mapper-locations:......
//  去主类里编写@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;) 以防找不到mapper 8.去配置端口8083
//   9.加入log4j2.xml  增加aop的pom
        return userService.getUser();
    &#125;
// 12.创造一个统一返回对象 com/imooc/mall/common/ApiRestResponse.java
    // 15.参数加在请求中所以加上@RequestParam 编写校验  16去UserService增加register接口
    @PostMapping(&quot;/register&quot;)
    @ResponseBody
    public ApiRestResponse register(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password) throws ImoocMallException &#123;
//    字符串为空 || 符合参数
        if (StringUtils.isEmpty(userName))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;if (StringUtils.isEmpty(password))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;
//   防止用户密码长度设置简单 密码长度不能少于8
        if (password.length()&lt;8)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.PASSWORD_TOO_SHORT);
        &#125;
 //18.补全操作  19进行统一处理异常[对前端安全考虑] GlobalExceptionHandler.java
        userService.register(userName, password);
        return ApiRestResponse.success();
    &#125;
&#125;

=========================================
http://127.0.0.1:8083/register

Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Wed Mar 06 00:06:06 CST 2024
There was an unexpected error (type=Method Not Allowed, status=405).
Request method &#39;GET&#39; not supported
    
因为注册的时候采用的是@PostMapping(&quot;/register&quot;)
单纯查询用get 往数据库写东西post
@RequestMapping(&quot;/register&quot;)是GET和POST都支持的 但是不推荐
根据不同的业务逻辑选择类型

打开postman 新建一个去查询post
POST: 127.0.0.1:8083/register?userName=mumu&amp;password=12345678

&#123;
    &quot;status&quot;: 10000,
    &quot;msg&quot;: &quot;SUCCESS&quot;,
    &quot;data&quot;: null
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/UserService.java
package com.imooc.mall.service;

import com.imooc.mall.model.pojo.User;

//5.这是抽象的接口 还要让它实现 再创建一个impl 实现接口类 UserServiceImpl.java
public interface UserService &#123;
    User getUser();
// 16.写完接口去实现接口UserServiceImpl.java
    void register(String userName, String password);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.UserMapper;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * UserService实现类
 */
@Service
//5.重写里面的方法  @Autowired引入一个mapper去查询数据库返回真正的信息 6返回UserController补全return
public class UserServiceImpl implements UserService &#123;
    @Autowired
    UserMapper userMapper;

    @Override
    public User getUser()&#123;
        //通过主键来查询一个对象
        return userMapper.selectByPrimaryKey(1);
    &#125;
    @Override
    public void register(String userName, String password) throws ImoocMallException &#123;
//    16.查询用户名是否存在, 不允许重名 用userMapper去查数据
//    但未编写功能 去手动编写UserMapper.java
        User result = userMapper.selectByName(userName);
        if (result != null)&#123;
//    17. 用户已存在 在Service层不能直接return但是controller可以直接返回
            // 创建一个异常类 com/imooc/mall/exception/ImoocMallException.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
    // 通过检测 允许写入数据库
        User user = new User();
        user.setUsername(userName);
        user.setPassword(password);
        //先判断是不是空 不是空才修改  实现完以后回到controller层进行调用
        int count = userMapper.insertSelective(user);
        if (count==0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.INSERT_FAILED);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/UserMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.User;
import org.springframework.stereotype.Repository;

@Repository
public interface UserMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(User record);

    int insertSelective(User record);

    User selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(User record);

    int updateByPrimaryKey(User record);

    // 16. 新增功能 去对应的UserMapper.xml进行描述 117行  BaseResultMap就是一开始自动生成的User对象
    // &lt;include refid=&quot;Base_Column_List&quot;/&gt; 选取完整的User对象
    User selectByName(String userName);
&#125;
</code></pre>
<pre><code class="xml">mappers/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.mall.model.dao.UserMapper&quot;&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;
    &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt;
    &lt;result column=&quot;personalized_signature&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;personalizedSignature&quot; /&gt;
    &lt;result column=&quot;role&quot; jdbcType=&quot;INTEGER&quot; property=&quot;role&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
    &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;sql id=&quot;Base_Column_List&quot;&gt;
    id, username, `password`, personalized_signature, `role`, create_time, update_time
  &lt;/sql&gt;
  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select 
    &lt;include refid=&quot;Base_Column_List&quot; /&gt;
    from imooc_mall_user
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/select&gt;
  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from imooc_mall_user
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/delete&gt;
  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    insert into imooc_mall_user (id, username, `password`, 
      personalized_signature, `role`, create_time, 
      update_time)
    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, 
      #&#123;personalizedSignature,jdbcType=VARCHAR&#125;, #&#123;role,jdbcType=INTEGER&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;, 
      #&#123;updateTime,jdbcType=TIMESTAMP&#125;)
  &lt;/insert&gt;
  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    insert into imooc_mall_user
    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
      &lt;if test=&quot;id != null&quot;&gt;
        id,
      &lt;/if&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        username,
      &lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;
        `password`,
      &lt;/if&gt;
      &lt;if test=&quot;personalizedSignature != null&quot;&gt;
        personalized_signature,
      &lt;/if&gt;
      &lt;if test=&quot;role != null&quot;&gt;
        `role`,
      &lt;/if&gt;
      &lt;if test=&quot;createTime != null&quot;&gt;
        create_time,
      &lt;/if&gt;
      &lt;if test=&quot;updateTime != null&quot;&gt;
        update_time,
      &lt;/if&gt;
    &lt;/trim&gt;
    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
      &lt;if test=&quot;id != null&quot;&gt;
        #&#123;id,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        #&#123;username,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;
        #&#123;password,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;personalizedSignature != null&quot;&gt;
        #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;role != null&quot;&gt;
        #&#123;role,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;createTime != null&quot;&gt;
        #&#123;createTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;updateTime != null&quot;&gt;
        #&#123;updateTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
    &lt;/trim&gt;
  &lt;/insert&gt;
  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    update imooc_mall_user
    &lt;set&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        username = #&#123;username,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;
        `password` = #&#123;password,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;personalizedSignature != null&quot;&gt;
        personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;role != null&quot;&gt;
        `role` = #&#123;role,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;createTime != null&quot;&gt;
        create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;updateTime != null&quot;&gt;
        update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
    &lt;/set&gt;
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/update&gt;
  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    update imooc_mall_user
    set username = #&#123;username,jdbcType=VARCHAR&#125;,
      `password` = #&#123;password,jdbcType=VARCHAR&#125;,
      personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,
      `role` = #&#123;role,jdbcType=INTEGER&#125;,
      create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,
      update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/update&gt;
  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select
        &lt;include refid=&quot;Base_Column_List&quot;/&gt;
        from imooc_mall_user
        where username = #&#123;userName,jdbcType=VARCHAR&#125;
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallException.java
package com.imooc.mall.exception;

/**
 * 17. 统一异常(感觉像递归之前编写的枚举异常)
 */
public class ImoocMallException extends Exception&#123;
    private final Integer code;
    private final String message;

    public ImoocMallException(Integer code, String message) &#123;
        this.code = code;
        this.message = message;
    &#125;

    public ImoocMallException(ImoocMallExceptionEnum exceptionEnum) &#123;
        this(exceptionEnum.getCode(), exceptionEnum.getMsg());
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    @Override
    public String getMessage() &#123;
        return message;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
package com.imooc.mall.exception;

/**
 * 异常枚举
 */
//13.编写异常枚举 注意类是enum噢  14返回ApiRestResponse
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;);


    //异常码
    Integer code;
    //异常信息
    String msg;

    ImoocMallExceptionEnum(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<h3 id="GlobalExceptionHandler编写"><a href="#GlobalExceptionHandler编写" class="headerlink" title="GlobalExceptionHandler编写"></a>GlobalExceptionHandler编写</h3><ul>
<li>对前端安全考虑，敏感信息不会暴露给用户</li>
<li>抛出异常，直接转化为Json的APIResponse</li>
<li>抛出重名异常</li>
<li>拦截异常并且转变成APIRespond统一类型输出</li>
</ul>
<pre><code class="java">com/imooc/mall/exception/GlobalExceptionHandler.java
package com.imooc.mall.exception;

import com.imooc.mall.common.ApiRestResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 19.处理统一异常的handler 业务异常 处理不同逻辑异常  
   20对密码进行MD5加密UserServiceImpl 先创建MD5Utils
 */
@ControllerAdvice
public class GlobalExceptionHandler &#123;
    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    //   统一处理Exception.class异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Object handleException(Exception e) &#123;
        log.error(&quot;Default Exception: &quot;, e);
        return ApiRestResponse.error(ImoocMallExceptionEnum.SYSTEM_ERROR);
    &#125;
    @ExceptionHandler(ImoocMallException.class)
    @ResponseBody
    public Object handleImoocMallException(ImoocMallException e) &#123;
        log.error(&quot;ImoocMallException: &quot;, e); //传进来的是什么就传出去
        return ApiRestResponse.error(e.getCode(), e.getMessage());
    &#125;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e682b6dfead4194de33f37c0a5d1f116f2d9ad96/data/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png"></p>
<h3 id="对密码进行MD5保护"><a href="#对密码进行MD5保护" class="headerlink" title="对密码进行MD5保护"></a>对密码进行MD5保护</h3><pre><code class="java">com/imooc/mall/util/MD5Utils.java
package com.imooc.mall.util;

import com.imooc.mall.common.Constant;
import org.apache.tomcat.util.codec.binary.Base64;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

//20.不具备解密的协议 哈希算法  因为有破解MD5的网站所以需要加盐 21com/imooc/mall/common/Constant.java
public class MD5Utils &#123;
    public static String getMD5Str(String strValue) throws NoSuchAlgorithmException &#123;
        MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
        return Base64.encodeBase64String(md5.digest((strValue+ Constant.SALT).getBytes()));
    &#125;
//  用这个方法测试生成MD5的值
    public static void main(String[] args) throws NoSuchAlgorithmException &#123;
        String md5Str = getMD5Str(&quot;12345&quot;);
        System.out.println(md5Str);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.UserMapper;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import com.imooc.mall.util.MD5Utils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.security.NoSuchAlgorithmException;

/**
 * UserService实现类
 */
@Service
//5.重写里面的方法  @Autowired引入一个mapper去查询数据库返回真正的信息 6返回UserController补全return
public class UserServiceImpl implements UserService &#123;
    @Autowired
    UserMapper userMapper;

    @Override
    public User getUser()&#123;
        //通过主键来查询一个对象
        return userMapper.selectByPrimaryKey(1);
    &#125;
    @Override
    public void register(String userName, String password) throws ImoocMallException, NoSuchAlgorithmException &#123;
//    16.查询用户名是否存在, 不允许重名 用userMapper去查数据
//    但未编写功能 去手动编写UserMapper.java
        User result = userMapper.selectByName(userName);
        if (result != null)&#123;
//    17. 用户已存在 在Service层不能直接return但是controller可以直接返回
            // 创建一个异常类 com/imooc/mall/exception/ImoocMallException.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
    // 通过检测 允许写入数据库
        User user = new User();
        user.setUsername(userName);
//        user.setPassword(password);
        //21.重写密码
        user.setPassword(MD5Utils.getMD5Str(password));
        //先判断是不是空 不是空才修改  18实现完以后回到controller层进行调用
        int count = userMapper.insertSelective(user);
        if (count==0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.INSERT_FAILED);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="登录功能分析"><a href="#登录功能分析" class="headerlink" title="登录功能分析"></a>登录功能分析</h3><ul>
<li>登录状态需要保持 </li>
<li>session的实现方案：登陆后，会保存用户信息到session</li>
<li>之后的访问，会先从session中获取用户信息，然后再执行业务逻辑</li>
</ul>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
</code></pre>
<pre><code class="java">com/imooc/mall/controller/UserController.java
//22登录login接口的开发 23返回UserServiceImpl写login
    @PostMapping(&quot;/login&quot;)
    @ResponseBody
    public ApiRestResponse login(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws ImoocMallException, NoSuchAlgorithmException &#123;
        if (StringUtils.isEmpty(userName))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;if (StringUtils.isEmpty(password))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;//26.编写完毕login接口
        User user = userService.login(userName, password);
        //保存用户信息时，不保存密码
        user.setPassword(null);
        //把对象放入session中
        session.setAttribute(Constant.IMOOC_MALL_USER,user);
        return ApiRestResponse.success(user);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
    //23.写方法判断md5与其匹配
    @Override
    public User login(String userName, String password) throws ImoocMallException &#123;
        String md5Password = null;
        try &#123;
            md5Password = MD5Utils.getMD5Str(password);
        &#125; catch (NoSuchAlgorithmException e) &#123;
            e.printStackTrace();
        &#125;
//   23写方法判断md5与其匹配 UserMapper中写 login
        //25.匹配 且去接口增加
        User user = userMapper.selectLogin(userName, password);
        if (user == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_PASSWORD);
        &#125;//能找到就返回用户 直接从上面写@Override再自动修复就可以自动生成login的接口
        //26.返回UserController写完login接口
        return user;
    &#125;
</code></pre>
<h3 id="用户模块剩余接口开发-更新个性签名"><a href="#用户模块剩余接口开发-更新个性签名" class="headerlink" title="用户模块剩余接口开发 [更新个性签名]"></a>用户模块剩余接口开发 [更新个性签名]</h3><pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/UserController.java
//22登录login接口的开发 23返回UserServiceImpl写login
    @PostMapping(&quot;/login&quot;)
    @ResponseBody
    public ApiRestResponse login(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws ImoocMallException, NoSuchAlgorithmException &#123;
        if (StringUtils.isEmpty(userName)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;
        if (StringUtils.isEmpty(password)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;//26.编写完毕login接口  27更新个性签名接口
        User user = userService.login(userName, password);
        //保存用户信息时，不保存密码
        user.setPassword(null);
        //把对象放入session中 KEY
        session.setAttribute(Constant.IMOOC_MALL_USER, user);
        return ApiRestResponse.success(user);
    &#125;

    //  27.个性签名接口 28编写UserServiceImpl的updateUserInfo方法
    @PostMapping(&quot;/user/update&quot;)
    @ResponseBody
    public ApiRestResponse updateUserInfo(HttpSession session, @RequestParam String signature) throws ImoocMallException &#123;
        User currentUser = (User)session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;
        User user = new User();
        user.setId(currentUser.getId());
        user.setPersonalizedSignature(signature);
        //29.搞全代码
        userService.updateInformation(user);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
//23.写方法判断md5与其匹配
    @Override
    public User login(String userName, String password) throws ImoocMallException &#123;
        String md5Password = null;
        try &#123;
            md5Password = MD5Utils.getMD5Str(password);
        &#125; catch (NoSuchAlgorithmException e) &#123;
            e.printStackTrace();
        &#125;
//   23写方法判断md5与其匹配 UserMapper中写 login
        //25.匹配 且去接口增加
        User user = userMapper.selectLogin(userName, md5Password);
        if (user == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_PASSWORD);
        &#125;//能找到就返回用户 直接从上面写@Override再自动修复就可以自动生成login的接口
        //26.返回UserController写完login接口
        return user;
    &#125;
// 28写updateUserInfo方法 不需要返回任何信息 只需要提醒更行成功即可
    @Override
    public void updateInformation(User user) throws ImoocMallException &#123;
//    更新个性签名
        int updateCount = userMapper.updateByPrimaryKeySelective(user);
        if(updateCount&gt;1)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;
        //快速使用@Override 快速补全接口代码 29返回UserController补全代码
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/UserService.java
package com.imooc.mall.service;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.model.pojo.User;

import java.security.NoSuchAlgorithmException;

//5.这是抽象的接口 还要让它实现 再创建一个impl 实现接口类 UserServiceImpl.java
public interface UserService &#123;
    User getUser();
// 16.写完接口去实现接口UserServiceImpl.java
    void register(String userName, String password) throws ImoocMallException, NoSuchAlgorithmException;

    //23.写方法判断md5与其匹配
    User login(String userName, String password) throws ImoocMallException;

    // 28写updateUserInfo方法 不需要返回任何信息 只需要提醒更行成功即可
    void updateInformation(User user) throws ImoocMallException;
&#125;
</code></pre>
<h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><pre><code class="java">com/imooc/mall/controller/UserController.java
//30.退出登录接口
    @PostMapping(&quot;/user/logout&quot;)
    @ResponseBody
    public ApiRestResponse logout(HttpSession session)&#123;
        session.removeAttribute(Constant.IMOOC_MALL_USER);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<h3 id="管理员接口"><a href="#管理员接口" class="headerlink" title="管理员接口"></a>管理员接口</h3><pre><code class="java">com/imooc/mall/controller/UserController.java
    //  31.管理员登录接口 思路可以借鉴
    @PostMapping(&quot;/adminLogin&quot;)
    @ResponseBody
    public ApiRestResponse adminLogin(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws ImoocMallException, NoSuchAlgorithmException &#123;
        if (StringUtils.isEmpty(userName)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;
        if (StringUtils.isEmpty(password)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;//31.拿到用户名和密码的时候 对其进行校验是否为管理员
        //数据库中 role=1是普通用户   role=2是管理员用户
        // 32去serviceImpl写一个方法
        User user = userService.login(userName, password);
        //33.判断是否为管理员
//        userService.checkAdminRole(user).if
        if (userService.checkAdminRole(user)) &#123;
            //是管理员
            //保存用户信息时，不保存密码
            user.setPassword(null);
            //把对象放入session中 KEY
            session.setAttribute(Constant.IMOOC_MALL_USER, user);
            return ApiRestResponse.success(user);
        &#125;else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;
    //  34.创建分类接口 CategoryController
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
//  32.拿到用户  role=1是普通用户   role=2是管理员用户
    //33.回到Controller
    @Override
    public boolean checkAdminRole(User user)&#123;
        return user.getRole().equals(2);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    NEED_ADMIN(10009,&quot;无管理员权限&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
&#125;
</code></pre>
<h3 id="总结用户模块"><a href="#总结用户模块" class="headerlink" title="总结用户模块"></a>总结用户模块</h3><ul>
<li><strong>重难点</strong>：统一响应对象、登录状态保持、统一异常处理</li>
<li><strong>常见错误</strong>：响应对象不规范、异常不统一处理</li>
</ul>
<h3 id="商品分类管理模块开发"><a href="#商品分类管理模块开发" class="headerlink" title="商品分类管理模块开发"></a>商品分类管理模块开发</h3><ul>
<li>模块介绍</li>
<li>编码</li>
<li>自测</li>
<li>总结</li>
</ul>
<h5 id="什么是商品分类"><a href="#什么是商品分类" class="headerlink" title="什么是商品分类"></a>什么是商品分类</h5><ul>
<li>条例清楚，层次分明</li>
<li>方便用户进行筛选和辨别</li>
<li>可以通过分类的设置快速的进入对应的商品列表页面进行商品选择</li>
</ul>
<h5 id="分类层级"><a href="#分类层级" class="headerlink" title="分类层级"></a>分类层级</h5><ul>
<li>在商品分类上需要继续做归类操作</li>
<li>分类设置成三级</li>
<li>层级太深的弊端：<ul>
<li>一是对用户不太友好，不利于寻找</li>
<li>二是对后台管理人员不友好，不方便管理</li>
</ul>
</li>
</ul>
<h3 id="分类模块的主要功能"><a href="#分类模块的主要功能" class="headerlink" title="分类模块的主要功能"></a>分类模块的主要功能</h3><ul>
<li>分类数据的设置</li>
<li>分类的父一级目录、递归</li>
</ul>
<h5 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h5><ul>
<li>接口设计</li>
<li>表设计</li>
</ul>
<h3 id="开发添加分类接口part1"><a href="#开发添加分类接口part1" class="headerlink" title="开发添加分类接口part1"></a>开发添加分类接口part1</h3><pre><code class="java">com/imooc/mall/controller/CategoryController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.model.AddCategoryReq;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.CategoryService;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpSession;

//  34.创建分类接口 CategoryController
@Controller
public class CategoryController &#123;
    @Autowired
    UserService userService;
    @Autowired
    CategoryService categoryService;
    @PostMapping(&quot;admin/category/add&quot;)
    @ResponseBody
    public ApiRestResponse addCategory(HttpSession session, @RequestBody AddCategoryReq addCategoryReq) &#123;
        //登录且必须为管理员才可以 参数中需要添加很多元素 可以使用封装来搞
        //com/imooc/mall/model/model/AddCategoryReq.java
        if (addCategoryReq.getName() == null || addCategoryReq.getType() == null || addCategoryReq.getParentId() == null || addCategoryReq.getOrderNum() == null) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.PARA_NOT_NULL);
        &#125;
        //对身份进行校验 用session获取当前的用户
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole)&#123; //35.创建一个CategoryService 分类目录Service
        //37.补全代码 是管理员  在上面添加@RequestBody 去postman Body-&gt;(raw/JSON)里测试接口
            categoryService.add(addCategoryReq);
            return ApiRestResponse.success();
        &#125;else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;
//38.简化参数校验过程 || || || ||  @Valid  @Size(AddCategoryReq) @NotNull
        //39.增加GlobalExceptionHandler.java中的提示代码 不仅仅只提供20000 系统异常 handleMethodArg。。。
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/model/AddCategoryReq.java
package com.imooc.mall.model.model;

/**
 * 34.AddCategoryReq 新建一个类 供添加接口进行封装 回去引用
 */
public class AddCategoryReq &#123;
    private String name;
    private Integer type;
    private Integer parentId;
    private Integer orderNum;
&#125;+GETTER SETTER
</code></pre>
<pre><code class="java">com/imooc/mall/service/CategoryService.java
package com.imooc.mall.service;

import com.imooc.mall.model.model.AddCategoryReq;
import com.imooc.mall.model.pojo.Category;

//35.创建一个CategoryService 分类目录Service 36创建一个它的实现类CategoryServiceImpl
public interface CategoryService &#123;
    void add(AddCategoryReq addCategoryReq);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
package com.imooc.mall.service.impl;

import com.fasterxml.jackson.databind.util.BeanUtil;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.CategoryMapper;
import com.imooc.mall.model.model.AddCategoryReq;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.service.CategoryService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 36.目录分类Service实现类
 */
@Service
public class CategoryServiceImpl implements CategoryService &#123;
    @Autowired
//   去Mapper里增加selectbyName 117行
    CategoryMapper categoryMapper;
    public void add(AddCategoryReq addCategoryReq) &#123;
        Category category = new Category();
//        category.setName(addCategoryReq.getName());
        //字段类型一样 字段名一样的话可以自动拷贝进去
        BeanUtils.copyProperties(addCategoryReq,category);
        Category categoryOld = categoryMapper.selectByName(addCategoryReq.getName());
        if (categoryOld != null)&#123; //重名目录 不允许创建 (优化)将ImoocMallException中的extends换一个
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
        int count = categoryMapper.insertSelective(category);
        if (count == 0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;//37.回到CategoryController.java
    &#125;
&#125;
</code></pre>
<pre><code class="xml">mappers/CategoryMapper.xml
  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_category
    where name = #&#123;name,jdbcType=VARCHAR&#125;
  &lt;/select&gt;
</code></pre>
<h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Valid</td>
<td>需要验证</td>
</tr>
<tr>
<td>@NotNull</td>
<td>非空</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>最大值</td>
</tr>
<tr>
<td>@Size(max, min)</td>
<td>字符串长度范围限制</td>
</tr>
</tbody></table>
<pre><code class="java">com/imooc/mall/model/model/AddCategoryReq.java
package com.imooc.mall.model.model;

import javax.validation.constraints.Max;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

/**
 * 34.AddCategoryReq 新建一个类 供添加接口进行封装 回去引用
 */
public class AddCategoryReq &#123;
    @Size(min=2,max=5)
    private String name;
    @NotNull
    @Max(3)
    private Integer type;
    @NotNull(message = &quot;parentId不能为null&quot;)
    private Integer parentId;
    @NotNull
    private Integer orderNum;
    
===================================================
POST:127.0.0.1:8083/admin/category/add
Body→raw→JSON：&#123;&quot;name&quot;:&quot;鸭货伴手零食&quot;,&quot;type&quot;:2,&quot;parentId&quot;:6,&quot;orderNum&quot;:10&#125;

&#123;
    &quot;status&quot;: 20000,
    &quot;msg&quot;: &quot;系统异常&quot;,
    &quot;data&quot;: null
&#125;

org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [1] in public com.imooc.mall.common.ApiRestResponse com.imooc.mall.controller.CategoryController.addCategory(javax.servlet.http.HttpSession,com.imooc.mall.model.model.AddCategoryReq): [Field error in object &#39;addCategoryReq&#39; on field &#39;name&#39;: rejected value [鸭货伴手零食]; codes [Size.addCategoryReq.name,Size.name,Size.java.lang.String,Size]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [addCategoryReq.name,name]; arguments []; default message [name],5,2]; default message [个数必须在2和5之间]] 
</code></pre>
<pre><code class="java">com/imooc/mall/exception/GlobalExceptionHandler.java
package com.imooc.mall.exception;

import com.imooc.mall.common.ApiRestResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.ArrayList;
import java.util.List;

/**
 * 19.处理统一异常的handler 业务异常 处理不同逻辑异常  20对密码进行MD5加密UserServiceImpl 先创建MD5Utils
 */
@ControllerAdvice
public class GlobalExceptionHandler &#123;
    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    //   统一处理Exception.class异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Object handleException(Exception e) &#123;
        log.error(&quot;Default Exception: &quot;, e);
        return ApiRestResponse.error(ImoocMallExceptionEnum.SYSTEM_ERROR);
    &#125;

    @ExceptionHandler(ImoocMallException.class)
    @ResponseBody
    public Object handleImoocMallException(ImoocMallException e) &#123;
        log.error(&quot;ImoocMallException: &quot;, e); //传进来的是什么就传出去
        return ApiRestResponse.error(e.getCode(), e.getMessage());
    &#125;

    //  39.处理方法参数不合规的情况
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public ApiRestResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e) &#123;
        log.error(&quot;handleMethodArgumentNotValidException: &quot;, e);
        return handleBindingResult(e.getBindingResult());
    &#125;
//  40.处理返回异常的ApiRespond 41去pom引入Swagger自动生成API文档
    private ApiRestResponse handleBindingResult(BindingResult result)&#123;
//  把异常处理为对外暴露的提示
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        if (result.hasErrors())&#123;
            List&lt;ObjectError&gt; allErrors = result.getAllErrors();
            for (ObjectError objectError : allErrors) &#123; //itli快速  对着for按alt+回车 改成增强for
                String message = objectError.getDefaultMessage();
                list.add(message);
            &#125;
        &#125;
        if (list.size() == 0)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR);
        &#125; //list.toString()生成所创建的异常描述信息
        return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR.getCode(), list.toString());
    &#125;
&#125;
</code></pre>
<h3 id="Swagger自动生成API文档"><a href="#Swagger自动生成API文档" class="headerlink" title="Swagger自动生成API文档"></a>Swagger自动生成API文档</h3><pre><code class="xml">pom.xml
&lt;!--41.导入Swagger自动生成API文档 并在main函数中加入注解 @EnableSwagger2--&gt;
&lt;!--42.再去创造一个config  配置文件    --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/config/SpringFoxConfig.java
package com.imooc.mall.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

@Configuration
public class SpringFoxConfig &#123;
 //41.访问http://localhost:8083/swagger-ui.html可以看到API文档 
    //42创建ImoocMallWebMvcConfig
    @Bean
    public Docket api() &#123;
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.any())
                .paths(PathSelectors.any())
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕慕生鲜&quot;)
                .description(&quot;&quot;)
                .termsOfServiceUrl(&quot;&quot;)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/MallApplication.java
package com.imooc.mall;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;)
@EnableSwagger2
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
package com.imooc.mall.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 
 * 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
   44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;

    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
==================================================
http://localhost:8083/swagger-ui.html
</code></pre>
<h3 id="更新目录接口"><a href="#更新目录接口" class="headerlink" title="更新目录接口"></a>更新目录接口</h3><pre><code class="java">com/imooc/mall/model/request/UpdateCategoryReq.java
package com.imooc.mall.model.request;

import javax.validation.constraints.Max;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

/**
 * 45.CategoryController.java中创建新增方法
 */
public class UpdateCategoryReq &#123;
    @NotNull(message = &quot;id不能为null&quot;)
    private Integer id;

    @Size(min=2,max=5)
    private String name;
    @Max(3)
    private Integer type;

    private Integer parentId;
    private Integer orderNum;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CategoryController.java
 //    45.创建新增接口   46在CategoryServiceImpl.java中新增更新方法
    @ApiOperation(&quot;后台更新目录&quot;)
    @PostMapping(&quot;admin/category/update&quot;)
    @ResponseBody
    public ApiRestResponse updateCategory( @Valid @RequestBody UpdateCategoryReq updateCategoryReq, HttpSession session) &#123;
        //对身份进行校验 用session获取当前的用户
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole) &#123;
            //补全代码 是管理员  在上面添加@RequestBody 去postman Body-&gt;(raw/JSON)里测试接口
            //46.补全接口代码
            Category category = new Category(); //复制过来
            BeanUtils.copyProperties(updateCategoryReq, category);
            categoryService.update(category);
            return ApiRestResponse.success();
        &#125; else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;//47.为了统一接口校验管理员身份 NEED_LOGIN NEED_ADMIN
        // 创建一个com/imooc/mall/filter/AdminFilter.java
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
 @Override //47.快速生成
    // 46在CategoryServiceImpl.java中新增更新方法
    public void update(Category updateCategory)&#123;
        if (updateCategory.getName() != null)&#123;
            Category categoryOld = categoryMapper.selectByName(updateCategory.getName());
            if (categoryOld != null &amp;&amp; !categoryOld.getId().equals(updateCategory.getId()))&#123; //不能为空且和原来的名字不一样
                throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
            &#125;
        &#125;
        categoryMapper.updateByPrimaryKeySelective(updateCategory); //根据主键更新
// 不和其他名字冲突
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/CategoryService.java
package com.imooc.mall.service;

import com.imooc.mall.model.pojo.Category;
import com.imooc.mall .model.request.AddCategoryReq;

//35.创建一个CategoryService 分类目录Service 36创建一个它的实现类CategoryServiceImpl
public interface CategoryService &#123;
    void add(AddCategoryReq addCategoryReq);

    //47.快速生成
    // 46在CategoryServiceImpl.java中新增更新方法
    void update(Category updateCategory);
&#125;
</code></pre>
<h3 id="统一校验管理员身份"><a href="#统一校验管理员身份" class="headerlink" title="统一校验管理员身份"></a>统一校验管理员身份</h3><pre><code class="java">com/imooc/mall/controller/CategoryController.java
//    45.创建新增接口   46在CategoryServiceImpl.java中新增更新方法
    @ApiOperation(&quot;后台更新目录&quot;)
    @PostMapping(&quot;admin/category/update&quot;)
    @ResponseBody
    public ApiRestResponse updateCategory( @Valid @RequestBody UpdateCategoryReq updateCategoryReq, HttpSession session) &#123;
        //对身份进行校验 用session获取当前的用户
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole) &#123;
            //补全代码 是管理员  在上面添加@RequestBody 去postman Body-&gt;(raw/JSON)里测试接口
            //46.补全接口代码
            Category category = new Category(); //复制过来
            BeanUtils.copyProperties(updateCategoryReq, category);
            categoryService.update(category);
            return ApiRestResponse.success();
        &#125; else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;//47.为了统一接口校验管理员身份 NEED_LOGIN NEED_ADMIN
        // 创建一个com/imooc/mall/filter/AdminFilter.java
    &#125;
    @ApiOperation(&quot;后台更新目录&quot;)
    @PostMapping(&quot;admin/category/update&quot;)
    @ResponseBody //没有在接口里做权限校验
    public ApiRestResponse deleteCategory()&#123;
        return null;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/filter/AdminFilter.java
package com.imooc.mall.filter;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.PrintWriter;

/**
 *
 * 47. 管理员校验过滤器  48.Admin过滤器的配置
 */
public class AdminFilter implements Filter &#123;
    @Autowired
    UserService userService;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        //对身份进行校验 用session获取当前的用户
        HttpServletRequest request = (HttpServletRequest)servletRequest;
        HttpSession session = request.getSession();
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) servletResponse).getWriter();
            out.write(&quot;&#123;\n&quot; //用户未登录
                    + &quot;    \&quot;status\&quot;: 10007,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            out.flush();
            out.close();
            return;
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole) &#123; //放行代码
            filterChain.doFilter(servletRequest,servletResponse);
        &#125; else &#123;
            PrintWriter out = new HttpServletResponseWrapper(
                    (HttpServletResponse) servletResponse).getWriter();
            out.write(&quot;&#123;\n&quot;
                    + &quot;    \&quot;status\&quot;: 10009,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_ADMIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            out.flush();
            out.close();
        &#125;
    &#125;

    @Override
    public void destroy() &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/filter/AdminFilterConfig.java
package com.imooc.mall.filter;

import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Admin过滤器的配置
 */
@Configuration
public class AdminFilterConfig &#123;
    @Bean
    public AdminFilter adminFilter()&#123;
        return new AdminFilter();
    &#125;
    @Bean(name = &quot;adminFilterConf&quot;)
    public FilterRegistrationBean adminFilterConfig()&#123;
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
        filterRegistrationBean.setFilter(adminFilter());
        filterRegistrationBean.addUrlPatterns(&quot;/admin/category/*&quot;);
        filterRegistrationBean.addUrlPatterns(&quot;/admin/product/*&quot;);
        filterRegistrationBean.addUrlPatterns(&quot;/admin/order/*&quot;);
        filterRegistrationBean.setName(&quot;adminFilterConfig&quot;);
        return filterRegistrationBean;
    &#125;
&#125;
com/imooc/mall/filter/AdminFilterConfig.java
</code></pre>
<h3 id="删除目录接口、分页功能开发"><a href="#删除目录接口、分页功能开发" class="headerlink" title="删除目录接口、分页功能开发"></a>删除目录接口、分页功能开发</h3><pre><code class="java">@RequestBody用来接收http post请求的body，前端传入序列化好的json数据，后端可以解析为json对象（Content-Type需要指定为 application/json）。
@RequestParam用来接收请求url?后面的参数，或者Content-Type为multipart/form-data、application/x-www-form-urlencoded时的http body数据。
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CategoryController.java
     @ApiOperation(&quot;后台删除目录&quot;)
    @PostMapping(&quot;admin/category/delete&quot;)
    @ResponseBody //没有在接口里做权限校验
    //49.编写delete接口  再去CategoryServiceImpl.java 写delete方法
    public ApiRestResponse deleteCategory(@RequestParam Integer id) &#123;
        categoryService.delete(id);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//49.写delete方法     @Override快速更新service
    @Override
    public void delete(Integer id)&#123;
        Category categoryOld = categoryMapper.selectByPrimaryKey(id);
        //查不到记录，无法删除，删除失败
        if (categoryOld == null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
        int count = categoryMapper.deleteByPrimaryKey(id);
        if (count == 0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CategoryController.java
 //50.写后台查询商品分类列表的接口
    @ApiOperation(&quot;后台目录列表&quot;)
    @PostMapping(&quot;admin/category/list&quot;)
    @ResponseBody //没有在接口里做权限校验
    public ApiRestResponse listCategoryForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        //51.去CategoryServiceImpl编写该接口的实现类
        PageInfo pageInfo = categoryService.listForAdmin(pageNum, pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/CategoryVO.java
package com.imooc.mall.model.vo;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class CategoryVO &#123;
    private Integer id;
    private String name;
    private Integer type;
    private Integer parentId;
    private Integer orderNum;
    private Date createTime;
    private Date updateTime;
    private List&lt;CategoryVO&gt; childCategory = new ArrayList&lt;&gt;();
&#125;Setter+Getter
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//51.创建vo[转换过后反应给前端的一个类]  pageInfo里面蕴藏着一个List&lt;Category&gt;
    @Override
    public PageInfo listForAdmin(Integer pageNum, Integer pageSize)&#123;
        //把分页的功能包裹在List后 而不是直接返回
        //52.引入分页查询的pom 续写分页代码
        PageHelper.startPage(pageNum,pageSize,&quot;type,order_num&quot;);
        //53.写一个查询的mapper新的sql语句 CategoryMapper.java =&gt; List&lt;Category&gt; selectList();
        //54.返回Categorycontroller补全代码
        List&lt;Category&gt; categoryList = categoryMapper.selectList();
        PageInfo pageInfo = new PageInfo(categoryList);
        return pageInfo;
    &#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;!--  52.引入分页的依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.13&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="用户分类列表接口开发"><a href="#用户分类列表接口开发" class="headerlink" title="用户分类列表接口开发"></a>用户分类列表接口开发</h3><pre><code class="java">com/imooc/mall/controller/CategoryController.java
//54.用户分类列表接口开发 去Impl补写实现类
    @ApiOperation(&quot;前台目录列表&quot;)
    @GetMapping(&quot;category/list&quot;)
    @ResponseBody
    public ApiRestResponse listCategoryForCustomer()&#123;
        List&lt;CategoryVO&gt; categoryVOS = categoryService.listCategoryForCustomer();
        return ApiRestResponse.success(categoryVOS);
    &#125;

============================================
目录列表(給用户看)：127.0.0.1:8083/category/list
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//54.用户分类列表接口开发
    @Override
    public List&lt;CategoryVO&gt; listCategoryForCustomer()&#123;
        ArrayList&lt;CategoryVO&gt; categoryVOList = new ArrayList&lt;&gt;();
        recursivelyFindCategories(categoryVOList, 0);
        //55.去Mapper.java 和 Mapper.xml写方法
        return categoryVOList;
    &#125;

    private void recursivelyFindCategories(List&lt;CategoryVO&gt; categoryVOList, Integer parentId)&#123;
        //递归获取所有子类别并组合 合成一个&quot;目录树&quot;
        List&lt;Category&gt; categoryList = categoryMapper.selectCategoriesByParentId(parentId);
        if (!CollectionUtils.isEmpty(categoryList))&#123;
            //空 或 有无元素   itli
            for (int i = 0; i &lt; categoryList.size(); i++) &#123;
                Category category =  categoryList.get(i);
                CategoryVO categoryVO = new CategoryVO();
                //拷贝链接  比原来的多一个childCategory这个字段未被赋值
                BeanUtils.copyProperties(category, categoryVO);
                categoryVOList.add(categoryVO);
                //拿到childCategory字段并赋值 再从上面return categoryVOList;
                recursivelyFindCategories(categoryVO.getChildCategory(), categoryVO.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/CategoryMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Category;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CategoryMapper &#123;
    int deleteByPrimaryKey(Integer id);
    int insert(Category record);
    int insertSelective(Category record);
    Category selectByPrimaryKey(Integer id);
    int updateByPrimaryKeySelective(Category record);
    int updateByPrimaryKey(Category record);
    Category selectByName(String name);
    List&lt;Category&gt; selectList();
    List&lt;Category&gt; selectCategoriesByParentId(Integer parentId);
&#125;
</code></pre>
<pre><code class="java">mappers/CategoryMapper.xml
&lt;mapper&gt;
 &lt;select id=&quot;selectList&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_category
  &lt;/select&gt;
  &lt;select id=&quot;selectCategoriesByParentId&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;int&quot;&gt;
    select &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_category
    where parent_id = #&#123;parentId&#125;
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="利用Redis缓存加速响应-目录变化频繁-访问量大的-增加效率"><a href="#利用Redis缓存加速响应-目录变化频繁-访问量大的-增加效率" class="headerlink" title="利用Redis缓存加速响应 [目录变化频繁(访问量大的) 增加效率]"></a>利用Redis缓存加速响应 [目录变化频繁(访问量大的) 增加效率]</h3><pre><code class="xml">pom.xml
&lt;!--    55.导入Redis的pom文件    --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">56.增加一个@EnableCaching注解让idea知道你想打开缓存功能
com/imooc/mall/MallApplication.java
package com.imooc.mall;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;)
@EnableSwagger2
@EnableCaching
//56.增加注解 并去想用的前面加注解 @Cacheable(value = &quot;listCategoryForCustomer&quot;)
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>import org.springframework.cache.annotation.Cacheable; [对的]<br><del>import springfox.documentation.annotations.Cacheable;</del> [错的]</p>
</blockquote>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//这里要格外注意 不要导错包 不然运行不了redis 里面的keys会没有键值对
// import org.springframework.cache.annotation.Cacheable; [对的]
// import springfox.documentation.annotations.Cacheable; [错的]
 //54.用户分类列表接口开发
    @Override //56.在下方加想用Redis的注解  
  //57.创建一个对于缓存的配置类com/imooc/mall/config/CachingConfig.java
    @Cacheable(value = &quot;listCategoryForCustomer&quot;)
    public List&lt;CategoryVO&gt; listCategoryForCustomer()&#123;
        ArrayList&lt;CategoryVO&gt; categoryVOList = new ArrayList&lt;&gt;();
        recursivelyFindCategories(categoryVOList, 0);
        //55.去Mapper.java 和 Mapper.xml写方法
        return categoryVOList;
    &#125;

    private void recursivelyFindCategories(List&lt;CategoryVO&gt; categoryVOList, Integer parentId)&#123;
        //递归获取所有子类别并组合 合成一个&quot;目录树&quot;
        List&lt;Category&gt; categoryList = categoryMapper.selectCategoriesByParentId(parentId);
        if (!CollectionUtils.isEmpty(categoryList))&#123;
            //空 或 有无元素   itli
            for (int i = 0; i &lt; categoryList.size(); i++) &#123;
                Category category =  categoryList.get(i);
                CategoryVO categoryVO = new CategoryVO();
                //拷贝链接  比原来的多一个childCategory这个字段未被赋值
                BeanUtils.copyProperties(category, categoryVO);
                categoryVOList.add(categoryVO);
                //拿到childCategory字段并赋值 再从上面return categoryVOList;
                recursivelyFindCategories(categoryVO.getChildCategory(), categoryVO.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/CachingConfig.java
package com.imooc.mall.config;

import org.springframework.context.annotation.Bean;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.RedisConnectionFactory;

import java.time.Duration;

/**
 * 57.缓存的配置类 想要运行成功保存序列化 要去弄个序列化接口com/imooc/mall/model/vo/CategoryVO.java
 */
@Configuration
@EnableCaching
public class CachingConfig &#123;
    @Bean
    public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory) &#123;

        RedisCacheWriter redisCacheWriter = RedisCacheWriter
                .lockingRedisCacheWriter(connectionFactory);
        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
        cacheConfiguration = cacheConfiguration.entryTtl(Duration.ofSeconds(30));

        RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter,
                cacheConfiguration);
        return redisCacheManager;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/CategoryVO.java
public class CategoryVO implements Serializable &#123;
     private Integer id;
    private String name;
    private Integer type;
    private Integer parentId;
    private Integer orderNum;
    private Date createTime;
    private Date updateTime;
    private List&lt;CategoryVO&gt; childCategory = new ArrayList&lt;&gt;();
&#125;Setter+Getter
</code></pre>
<h3 id="Idea调试技巧"><a href="#Idea调试技巧" class="headerlink" title="Idea调试技巧"></a>Idea调试技巧</h3><ul>
<li>断点统一开关</li>
<li>条件断点</li>
<li>单步调试<ul>
<li>step into 会进入方法内部</li>
<li>step out 跳出方法</li>
</ul>
</li>
<li>表达式求值 [Evaluate Expression]</li>
</ul>
<h3 id="总结商品分类模块"><a href="#总结商品分类模块" class="headerlink" title="总结商品分类模块"></a>总结商品分类模块</h3><ul>
<li>重难点：参数校验、Swagger[API文档自动]、统一鉴权[Filter过滤器]、Redis整合[Springboot整合]、调试功能</li>
<li>常见错误：参数手动校验、<span style = "color:red"><strong>项目没用Redis缓存</strong></span>、不善用调试</li>
</ul>
<h1 id="商品模块介绍"><a href="#商品模块介绍" class="headerlink" title="商品模块介绍"></a>商品模块介绍</h1><h6 id="演示、数据表设计、接口设计"><a href="#演示、数据表设计、接口设计" class="headerlink" title="演示、数据表设计、接口设计"></a>演示、数据表设计、接口设计</h6><h3 id="新增商品功能开发"><a href="#新增商品功能开发" class="headerlink" title="新增商品功能开发"></a>新增商品功能开发</h3><pre><code class="java">com\imooc\mall\controller\ProductAdminController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import org.springframework.stereotype.Controller;

/**
 * 58.后台商品管理Controller  pojo的product复制一份到request变成AddProductReq
   59.需要ProductService.java
 */
@Controller
public class ProductAdminController &#123;
    @Autowired
    ProductService productService;
    @PostMapping(&quot;admin/product/add&quot;)
    public ApiRestResponse addProduct(@Valid @RequestBody AddProductReq addProductReq)&#123;
    //61.补全代码  目前图片上传还未开发成功
        productService.add(addProductReq);
        return ApiRestResponse.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/request/AddProductReq.java
package com.imooc.mall.model.request;

import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;

public class AddProductReq &#123;
    @NotNull(message = &quot;商品名称不能为null&quot;)
    private String name;
    @NotNull(message = &quot;商品图片不能为null&quot;)
    private String image;

    private String detail;
    @NotNull(message = &quot;商品分类不能为null&quot;)
    private Integer categoryId;
    @NotNull(message = &quot;商品价格不能为null&quot;)
    @Min(value = 1, message = &quot;价格不能为null&quot;)
    private Integer price;

    @NotNull(message = &quot;商品库存不能为null&quot;)
    @Max(value = 10000, message = &quot;库存不能大于10000&quot;)
    private Integer stock;

    private Integer status;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/mall/service/ProductService.java
package com.imooc.mall.service;

import com.imooc.mall.model.request.AddProductReq;

/**
 * 59.商品Service 再创建一个实现类ProductServiceImpl
 */
public interface ProductService &#123;

    void add(AddProductReq addProductReq);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.ProductMapper;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.AddProductReq;
import com.imooc.mall.service.ProductService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 59.商品服务实现类
 */
@Service
public class ProductServiceImpl implements ProductService &#123;
    @Autowired
    ProductMapper productMapper;//60.ProductMapper SQL通过名字查找product是否存在 151行
    @Override
    public void add(AddProductReq addProductReq)&#123;
        Product product = new Product();
        BeanUtils.copyProperties(addProductReq, product);//赋值
        //61.商品重名情况  返回ProductAdminController补全代码  
        //62.图片上传接口 ProductAdminController
        Product productOld = productMapper.selectByName(addProductReq.getName());
        if (productOld != null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
        int count = productMapper.insertSelective(product);
        if (count == 0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.CREATE_FAILED);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><ul>
<li>文件名UUID</li>
<li>通用唯一识别码(Universally Unique Identifier)</li>
<li>防止重名、防止爬图</li>
<li>生成规则：日期和时间、<strong>MAC地址、HashCode、随机数</strong></li>
</ul>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
//62.图片上传接口
    @PostMapping(&quot;admin/upload/file&quot;)
    public  ApiRestResponse upload(HttpServletRequest httpServletRequest, @RequestParam(&quot;file&quot;) MultipartFile file)&#123;
        String fileName = file.getOriginalFilename();
        String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));//用文件后面的名字
        //生成文件名称UUID
        UUID uuid = UUID.randomUUID();
        String newFileName = uuid.toString() + suffixName;
        //创建文件 放在常量类中 Constant.java
        //63.application.properties配置file.upload.dir
//        new File()
        File fileDirectory = new File(Constant.FILE_UPLOAD_DIR);
        File destFile = new File(Constant.FILE_UPLOAD_DIR + newFileName);
        if (!fileDirectory.exists())&#123;
            if (!fileDirectory.mkdir())&#123;//新建文件夹
                throw new ImoocMallException(ImoocMallExceptionEnum.MKDIR_FAILED);
            &#125;
        &#125;
        try &#123;
            file.transferTo(destFile); //传进来的写到空的方法中去
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
        try &#123;
            return ApiRestResponse.success(getHost(new URI(httpServletRequest.getRequestURL()+&quot;&quot;))+&quot;/images/&quot;+newFileName); //生成的路径IP和端口号
        &#125; catch (URISyntaxException e) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.UPLOAD_FAILED);
        &#125;
    &#125;
    private URI getHost(URI uri)&#123;
        URI effectiveURI;
        try &#123;
            effectiveURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(),null,null,null);
        &#125; catch (URISyntaxException e) &#123;
            effectiveURI = null; //如果新建失败 就返回回去
        &#125;
        return effectiveURI;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    public static String FILE_UPLOAD_DIR;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    NEED_ADMIN(10009,&quot;无管理员权限&quot;),
    NAME_NOT_NULL(10010,&quot;参数不能为空&quot;),
    PARA_NOT_NULL(10011,&quot;参数不能为空&quot;),
    CREATE_FAILED(10012,&quot;新增失败&quot;),
    REQUEST_PARAM_ERROR(10013,&quot;参数错误&quot;),
    DELETE_FAILED(10014,&quot;删除失败&quot;),
    MKDIR_FAILED(10015,&quot;文件夹创建失败&quot;),
    UPLOAD_FAILED(10015,&quot;图片上传失败&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
&#125;
</code></pre>
<h3 id="资源映射开发"><a href="#资源映射开发" class="headerlink" title="资源映射开发"></a>资源映射开发</h3><blockquote>
<p>此时从postman中创建一个上传图片的接口<br>127.0.0.1:8083&#x2F;admin&#x2F;upload&#x2F;file<br>选择Body→form-data<br>此时上传图片会报错 {<br>  “status”: 20000,<br>  “msg”: “系统异常”,<br>  “data”: null<br>}</p>
</blockquote>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
@Component //让spring帮注入value
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
    public static String FILE_UPLOAD_DIR;
    //64.为了解决上传图片系统异常报错 注入失败的原因是上方是static普通变量 set方法把静态变量赋值
    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    public void setFileUploadDir(String fileUploadDir)&#123;
        FILE_UPLOAD_DIR = fileUploadDir;
    &#125;//65.打开ImoocMallWebMvcConfig 加一个映射规则
&#125;
</code></pre>
<h3 id="自定义静态资源映射目录"><a href="#自定义静态资源映射目录" class="headerlink" title="自定义静态资源映射目录"></a>自定义静态资源映射目录</h3><ul>
<li>上传图片后回显</li>
<li>配置SpringBootWebMvcConfig</li>
<li>静态资源到本地目录的映射</li>
<li>演示打开图片</li>
</ul>
<pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
package com.imooc.mall.config;

import com.imooc.mall.common.Constant;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
 * 44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;
    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + Constant.FILE_UPLOAD_DIR);
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="更新-UpdateProductReq-和新增-AddProductReq-商品"><a href="#更新-UpdateProductReq-和新增-AddProductReq-商品" class="headerlink" title="更新(UpdateProductReq)和新增(AddProductReq)商品"></a>更新(UpdateProductReq)和新增(AddProductReq)商品</h3><ul>
<li>合并写法不可取</li>
<li>业务逻辑清晰、独立</li>
</ul>
<pre><code class="java">com/imooc/mall/model/request/UpdateProductReq.java
public class UpdateProductReq &#123;
    @NotNull
    private Integer id; 
    private String name;
    private String image;
    private String detail;
    private Integer categoryId;
    @Min(value = 1, message = &quot;价格不能为null&quot;)
    private Integer price;

    @Max(value = 10000, message = &quot;库存不能大于10000&quot;)
    private Integer stock;

    private Integer status;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
package com.imooc.mall.config;

import com.imooc.mall.common.Constant;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
 * 44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;
    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
        //65.增加一个registry  66.新增接口继续开发 ProductAdminController
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + Constant.FILE_UPLOAD_DIR);
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
 //66. 接口 复制一个request中的AddProductReq 之后回来补全代码
    @ApiOperation(&quot;后台更新商品&quot;)
    @PostMapping(&quot;/admin/product/update&quot;)
    public ApiRestResponse updateProduct(@Valid @RequestBody UpdateProductReq updateProductReq)&#123;
        Product product = new Product();
        BeanUtils.copyProperties(updateProductReq, product);
        //67.进入ProductServiceImpl编写接口实现类
        productService.update(product);
        return ApiRestResponse.success();
    &#125;
    //68. 搞一个删除的接口 同理也在ProductServiceImpl中写实现类 之后回来补全代码
    @ApiOperation(&quot;后台删除商品&quot;)
    @PostMapping(&quot;/admin/product/delete&quot;)
    public ApiRestResponse deleteProduct(@RequestParam Integer id)&#123;
        productService.delete(id);
        return ApiRestResponse.success();
    &#125;com/imooc/mall/controller/ProductAdminController.java
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
//67.写updateProduct实现类 @Override自动导入
    @Override
    public void update(Product updateProduct) &#123;
        Product productOld = productMapper.selectByName(updateProduct.getName());
        //同名且不同id，不能继续修改
        if (productOld != null &amp;&amp; productOld.getId().equals(updateProduct.getId())) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
        int count = productMapper.updateByPrimaryKeySelective(updateProduct);
        if (count == 0) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;
    &#125;

    //68.删除实现类  @Override自动导入
    @Override
    public void delete(Integer id) &#123;
        Product productOld = productMapper.selectByPrimaryKey(id);
        //查不到该记录，无法删除
        if (productOld == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
        int count = productMapper.deleteByPrimaryKey(id);
        if (count == 0) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
    &#125;
</code></pre>
<h3 id="批量上下架"><a href="#批量上下架" class="headerlink" title="批量上下架"></a>批量上下架</h3><ul>
<li>MyBatis遍历List</li>
<li>where语句拼接</li>
</ul>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
//69. 批量上下架接口 同理也在ProductServiceImpl中写实现类 Napper中增加批量上下架的SQL
    // 之后回来补全代码
    @ApiOperation(&quot;后台批量上下架接口&quot;)
    @PostMapping(&quot;/admin/product/batchUpdateSellStatus&quot;)
    public ApiRestResponse batchUpdateSellStatus(@RequestParam Integer[] ids, @RequestParam Integer sellStatus)&#123;
        productService.batchUpdateSellStatus(ids,sellStatus);
        return ApiRestResponse.success();
    &#125;
=====================================================
127.0.0.1:8083//admin/product/batchUpdateSellStatus?ids=2,3&amp;sellStatus=0
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
//69.去ProductAdminController增加batchUpdateSellStatus接口
    @Override
    public void batchUpdateSellStatus(Integer[] ids, Integer sellStatus)&#123;
        productMapper.batchUpdateSellStatus(ids, sellStatus);
    return null;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/ProductMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Product;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Product record);

    int insertSelective(Product record);

    Product selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Product record);

    int updateByPrimaryKey(Product record);

    Product selectByName(String name);
    int batchUpdateSellStatus(@Param(&quot;ids&quot;) Integer[] ids, @Param(&quot;sellStatus&quot;) Integer sellStatus);

&#125;
</code></pre>
<pre><code class="java">mappers/ProductMapper.xml
  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_product
    where name = #&#123;name,jdbcType = VARCHAR&#125;
  &lt;/select&gt;
  &lt;update id=&quot;batchUpdateSellStatus&quot;&gt;
    update imooc_mall_product
    set status=#&#123;sellStatus&#125;
    where id in
    &lt;foreach collection=&quot;ids&quot; close=&quot;)&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt;
      #&#123;id&#125;
    &lt;/foreach&gt;
  &lt;/update&gt;
</code></pre>
<h3 id="后台商品列表、商品详情接口"><a href="#后台商品列表、商品详情接口" class="headerlink" title="后台商品列表、商品详情接口"></a>后台商品列表、商品详情接口</h3><pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
 //70.后台商品列表接口
    @Override
    public PageInfo listForAdmin(Integer pageNum, Integer pageSize)&#123;
        PageHelper.startPage(pageNum, pageSize); //在mapper里写查询sql
        List&lt;Product&gt; products = productMapper.selectListForAdmin();
        PageInfo pageInfo = new PageInfo(products);
        return pageInfo;
    &#125;
    //72.商品详情接口开发 再去ProductController调用
    @Override
    public Product detail(Integer id)&#123;
        Product product = productMapper.selectByPrimaryKey(id);
        return product;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
 //70.后台商品列表接口 同理也在ProductServiceImpl中写实现类 Napper中增加批量上下架的SQL 补全代码
    //71.开发与前台商品ProductController.java
    @ApiOperation(&quot;后台商品列表接口&quot;)
    @PostMapping(&quot;/admin/product/list&quot;)
    public ApiRestResponse list(@RequestParam Integer[] pageNum, @RequestParam Integer pageSize)&#123;
        PageInfo pageInfo = productService.batchUpdateSellStatus(pageNum,pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.service.ProductService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 71.前台商品Controller 72新增detail接口 ProductServiceImpl.java
 */
@RestController
public class ProductController &#123;
    @Autowired
    ProductService productService;

    @ApiOperation(&quot;商品详情&quot;)
    @GetMapping(&quot;product/detail&quot;)
    public ApiRestResponse detail(@RequestParam Integer id)&#123;
        Product product = productService.detail(id);
        return ApiRestResponse.success(product);
    &#125;
&#125;
</code></pre>
<h3 id="前台商品列表接口part1"><a href="#前台商品列表接口part1" class="headerlink" title="前台商品列表接口part1"></a>前台商品列表接口part1</h3><h5 id="商品列表：搜索功能"><a href="#商品列表：搜索功能" class="headerlink" title="商品列表：搜索功能"></a>商品列表：搜索功能</h5><p>入参判空 → 加%通配符 → like关键字</p>
<h5 id="对于查询目录的in处理"><a href="#对于查询目录的in处理" class="headerlink" title="对于查询目录的in处理"></a>对于查询目录的in处理</h5><ul>
<li>目录处理：如果查某个目录下的商品，不仅是需要查出来该目录的，还需要查出来子目录的所有商品</li>
<li>所以这里要拿到某一个目录Id下的所有子目录id的List</li>
</ul>
<h5 id="前台：商品列表"><a href="#前台：商品列表" class="headerlink" title="前台：商品列表"></a>前台：商品列表</h5><ul>
<li>排序功能</li>
<li>MyBatis PageHelper</li>
<li>枚举：order by [自定义]</li>
</ul>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
//72.商品详情接口开发 再去ProductController调用
    @Override
    public Product detail(Integer id)&#123;
        Product product = productMapper.selectByPrimaryKey(id);
        return product;
    &#125;
    //73.完成实现类
    @Override
    public PageInfo list(ProductListReq productListReq)&#123;
        //复杂查询就构建一个querry对象 ProductListQuery.java
        ProductListQuery productListQuery = new ProductListQuery();
        //☆☆搜索处理☆☆  拼接且转换成字符串去数据库查找
        if (!StringUtils.isEmpty(productListReq.getKeyword()))&#123;
            String keyword = new StringBuilder().append(&quot;%&quot;).append(productListReq.getKeyword()).append(&quot;%&quot;).toString();
            productListQuery.setKeyword(keyword);
        &#125;
        //☆☆目录处理☆☆：如果查某个目录下的商品，不仅是需要查出该目录下的，还要把所有子目录的所有商品都查出来，所以要拿到一个目录id的List
        if (productListReq.getCategoryId() != null)&#123;
            //要拿到子目录 引用CategoryService   CategoryVO原本是给前台目录用的 需要重构一下 不是所有目录而是指定目录
            //改动代码 CategoryServiceImpl.java中的listCategoryForCustomer 传入的参数是Integer parentId
            //productListReq获取了所有根节点的list  因为点开List&lt;CategoryVO&gt;里面包括一个  private List&lt;CategoryVO&gt;递归结构
            List&lt;CategoryVO&gt; categoryVOList = categoryService.listCategoryForCustomer(productListReq.getCategoryId());
            ArrayList&lt;Integer&gt; categoryIds = new ArrayList&lt;&gt;(); //拿过来之后存储的list
            categoryIds.add(productListReq.getCategoryId());
            getCategoryIds(categoryVOList,categoryIds);
            productListQuery.setCategoryIds(categoryIds);
        &#125;
        //74.排序能力 错误:前端传什么就 就传到sql中排序  这样是不安全的 要提前处理好
        //☆☆排序处理☆☆：去Constant定义支持的排序模式和手段
        String orderBy = productListReq.getOrderBy();
        if (Constant.ProductListOrderBy.PRICE_ASC_DESC.contains(orderBy)) &#123;
            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize(), orderBy);
        &#125;else &#123;//前端不一定包含数据的话就不排序了
            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize());
        &#125;//75.去写Mapper 最后回到ProductController写调用
        List&lt;Product&gt; productList = productMapper.selectList(productListQuery);
        PageInfo pageInfo = new PageInfo(productList);
        return pageInfo;
    &#125;
    //74.写一个方法拿到所有的id 拿到参数之后往哪里存放
    private void getCategoryIds(List&lt;CategoryVO&gt;categoryVOList, ArrayList&lt;Integer&gt; categoryIds)&#123;
        for (int i = 0; i &lt; categoryVOList.size(); i++) &#123;
            CategoryVO categoryVO =  categoryVOList.get(i);
            if (categoryVO != null)&#123;
                categoryIds.add(categoryVO.getId());
                //递归子节点 子子节点
                getCategoryIds(categoryVO.getChildCategory(), categoryIds); //去上面调用方法 传入对象
            &#125;
            
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/query/ProductListQuery.java
package com.imooc.mall.model.query;

import java.util.List;

/**
 * 查询商品列表的Query
 */
public class ProductListQuery &#123;
    private String keyword;
    private List&lt;Integer&gt; categoryIds;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/ProductMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.query.ProductListQuery;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductMapper &#123;
    List&lt;Product&gt; selectListForAdmin(); //给前台用户用的
    List&lt;Product&gt; selectList(@Param(&quot;ids&quot;)ProductListQuery query); //给后台用户用的 Type是一个类

&#125;
</code></pre>
<pre><code class="java">mappers/ProductMapper.xml
 &lt;select id=&quot;selectList&quot; resultMap=&quot;BaseResultMap&quot;
          parameterType=&quot;com.imooc.mall.model.query.ProductListQuery&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_product
    &lt;where&gt;
      &lt;if test=&quot;query.keyword != null&quot;&gt;
        and name like #&#123;query.keyword&#125;
      &lt;/if&gt;
      &lt;if test=&quot;query.categoryIds != null&quot;&gt;
        and category_id in
        &lt;foreach collection=&quot;query.categoryIds&quot; close=&quot;)&quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt;
          #&#123;item&#125;
        &lt;/foreach&gt;
      &lt;/if&gt;
      and status = 1
    &lt;/where&gt;
    order by update_time desc
  &lt;/select&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/ProductMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.query.ProductListQuery;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Product record);

    int insertSelective(Product record);

    Product selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Product record);

    int updateByPrimaryKey(Product record);

    Product selectByName(String name);
    int batchUpdateSellStatus(@Param(&quot;ids&quot;) Integer[] ids, @Param(&quot;sellStatus&quot;) Integer sellStatus);

    List&lt;Product&gt; selectListForAdmin(); //给前台用户用的

    List&lt;Product&gt; selectList(@Param(&quot;query&quot;)ProductListQuery query); //给后台用户用的 Type是一个类

&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductController.java
package com.imooc.mall.controller;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.ProductListReq;
import com.imooc.mall.service.ProductService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 71.前台商品Controller 72新增detail接口 ProductServiceImpl.java
 */
@RestController
public class ProductController &#123;
    @Autowired
    ProductService productService;

    @ApiOperation(&quot;商品详情&quot;)
    @GetMapping(&quot;product/detail&quot;)
    public ApiRestResponse detail(@RequestParam Integer id)&#123;
        Product product = productService.detail(id);
        return ApiRestResponse.success(product);
    &#125;
    //73.开发前台商品列表 开一个ProductListReq.java 去ProductServiceImpl
    @ApiOperation(&quot;商品详情&quot;)
    @GetMapping(&quot;product/list&quot;)
    public ApiRestResponse list(ProductListReq productListReq)&#123;
        PageInfo list = productService.list(productListReq);
        return ApiRestResponse.success(list);
    &#125;
&#125;
</code></pre>
<h3 id="总结商品模块"><a href="#总结商品模块" class="headerlink" title="总结商品模块"></a>总结商品模块</h3><ul>
<li>重难点：<strong>商品的搜索</strong>[<u>like</u>]、<strong>排序</strong>[<u>枚举+自定义</u>]、<strong>目录查询</strong>[<u>所有目录id都查到  再用查询列表方式</u>]</li>
<li>常见错误：更新和新增放在同一个接口、排序字段不用枚举</li>
</ul>
<h3 id="购物车模块介绍"><a href="#购物车模块介绍" class="headerlink" title="购物车模块介绍"></a>购物车模块介绍</h3><h5 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h5><ul>
<li>添加商品到购物车 → 商品是否在售、是否有库存 <ul>
<li>→[否] 提示用户</li>
<li>→[是] 该商品之前就在购物车里<ul>
<li>→[否] 添加新商品</li>
<li>→[是] 原有基础上添加数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">com/imooc/mall/controller/CartController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * 76.购物车Controller  77.用一个通用UserFilter逻辑
 */
@Controller
@RequestMapping(&quot;/cart&quot;)
public class CartController &#123;//因为放在url中 要加数据绑定 通过HttpSession获取用户信息太麻烦 用一个通用filter逻辑
    @PostMapping(&quot;/add&quot;)
    public ApiRestResponse add(@RequestParam Integer productId, @RequestParam Integer count)&#123;
        return null;
    &#125;
&#125;
========================================================
127.0.0.1:8083/cart/add?productId=22&amp;count=1
</code></pre>
<pre><code class="java">com/imooc/mall/filter/UserFilter.java
package com.imooc.mall.filter;

import com.imooc.mall.common.Constant;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.PrintWriter;

/**
 *
 * 77.用户过滤器 希望把用户信息currentUser保存下来
 */
public class UserFilter implements Filter &#123;
    public static User currentUser;
    @Autowired
    UserService userService;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        //对身份进行校验 用session获取当前的用户
        HttpServletRequest request = (HttpServletRequest)servletRequest;
        HttpSession session = request.getSession();
        currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) servletResponse).getWriter();
            out.write(&quot;&#123;\n&quot; //用户未登录
                    + &quot;    \&quot;status\&quot;: 10007,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            out.flush();
            out.close();
            return;
        &#125;
        //78.续写过滤器链条 写好后对用户链条进行config配置 UserFilterConfig.java
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;

    @Override
    public void destroy() &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/UserFilterConfig.java
package com.imooc.mall.config;

import com.imooc.mall.filter.UserFilter;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 78.对调用接口时对哪个类进行拦截 过滤器的配置 79创建cartService
 */
@Configuration
public class UserFilterConfig &#123;
    @Bean
    public UserFilter userFilter()&#123;
        return new UserFilter();
    &#125;
    @Bean(name = &quot;userFilterConf&quot;)
    public FilterRegistrationBean adminFilterConfig()&#123;
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
        filterRegistrationBean.setFilter(userFilter());
        //下面的是校验与拦截
        filterRegistrationBean.addUrlPatterns(&quot;/cart/*&quot;); //CartController.java
        filterRegistrationBean.addUrlPatterns(&quot;/order/*&quot;);
        filterRegistrationBean.setName(&quot;userFilterConf&quot;);
        return filterRegistrationBean;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CartServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.CategoryMapper;
import com.imooc.mall.model.dao.ProductMapper;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.vo.CartVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 80.购物车Service实现类 其中List&lt;&gt;中间是需要包括 商品id 图片 名字 商品选中 数量信息
 * 81.创建一个VO增加那些属性放在&lt;&gt;中 是返回给前端组合后的对象
 */
@Service
public class CartServiceImpl &#123;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CategoryMapper categoryMapper;

    public List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count) &#123;
        validProduct(productId, count);

    &#125;

    private void validProduct(Integer productId, Integer count) &#123;
        Product product = productMapper.selectByPrimaryKey(productId);
        //判断商品是否存在，商品是否上架
        if (product == null || product.getStatus().equals(Constant.SaleStatus.NOT_SALE)) &#123;
            //82. 1是上架 1不明确要形成代码让顾客知道 Constant.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_SALE);
        &#125;
        //判断商品库存 如果要买的比库存多 就买不了
        if (count &gt; product.getStock()) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
    //83.创建商品上下架的状态 创建CartMapper[Cart selectCartByUserIdAndProductId] 写sql 
    //84再去CartServiceImpl
    public interface SaleStatus&#123;
        int NOT_SALE = 0; //商品下架状态
        int SALE = 1; //商品上架状态
    &#125;
</code></pre>
<pre><code class="java">@Service
public class CartServiceImpl implements CartService &#123;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CategoryMapper categoryMapper;
    @Autowired
    CartMapper cartMapper;
@Override
    public List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count) &#123;
        validProduct(productId, count);
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        //84.补全代码
        if (cart==null)&#123;
            //这个商品之前不在购物车里，需要新增一个记录
            cart = new Cart();
            cart.setProductId(productId);
            cart.setUserId(userId);
            cart.setQuantity(count);
            cart.setSelected(Constant.Cart.CHECKED);
            cartMapper.insertSelective(cart);
        &#125;else &#123;
            //这个商品已经在购物车里了，数量相加
            count = cart.getQuantity() + count;
            Cart cartNew = new Cart();
            cartNew.setQuantity(count);
            cartNew.setId(cart.getId());
            cartNew.setProductId(cart.getProductId());
            cartNew.setUserId(cart.getUserId());
            //无论是否想买都选中
            cartNew.setSelected(Constant.Cart.CHECKED);
            cartMapper.updateByPrimaryKeySelective(cartNew);
        &#125;
        //85.去CartController补全代码逻辑 返回购物车列表哦~ 86.CartMapper.java
        return null;
    &#125;

    private void validProduct(Integer productId, Integer count) &#123;
        Product product = productMapper.selectByPrimaryKey(productId);
        //判断商品是否存在，商品是否上架
        if (product == null || product.getStatus().equals(Constant.SaleStatus.NOT_SALE)) &#123;
            //82. 1是上架 1不明确要形成代码让顾客知道 Constant.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_SALE);
        &#125;
        //判断商品库存 如果要买的比库存多 就买不了
        if (count &gt; product.getStock()) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/CartMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Cart;
import com.imooc.mall.model.vo.CartVO;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Repository
public interface CartMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Cart record);

    int insertSelective(Cart record);

    Cart selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Cart record);

    int updateByPrimaryKey(Cart record);

    //86.选中列表的方法 传入的参数是userId
    List&lt;CartVO&gt; selectList(@Param(&quot;userId&quot;) Integer userId);
    Cart selectCartByUserIdAndProductId(@Param(&quot;userId&quot;) Integer userId, @Param(&quot;productId&quot;)Integer productId);
&#125;
</code></pre>
<pre><code class="xml">mappers/CartMapper.xml
 &lt;select id=&quot;selectList&quot; resultType=&quot;com.imooc.mall.model.vo.CartVO&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    select
    c.id as id,
    p.id as productId,
    c.user_id as userId,
    c.quantity as quantity,
    c.selected as selected,
    p.price as price,
    p.name as productName,
    p.image as productImage
    from imooc_mall_cart c
    left join imooc_mall_product p on p.id = c.product_id
    where c.user_id = #&#123;userId&#125;
    and p.status = 1
  &lt;/select&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CartController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.filter.UserFilter;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.service.CartService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * 76.购物车Controller  77.用一个通用User_filter逻辑
 */
@RestController //404的错误① 返回的json格式 要用RestController
@RequestMapping(&quot;/cart&quot;)
public class CartController &#123;//因为放在url中 要加数据绑定 通过HttpSession获取用户信息太麻烦 用一个通用filter逻辑
    @Autowired
    CartService cartService;
    @PostMapping(&quot;/list&quot;)
    @ApiOperation(&quot;购物车列表&quot;)
    public ApiRestResponse list()&#123;
        //86.去写service的list接口 CartMapper中写选中列表的方法
        //内部获取用户Id,防止横向越权
        List&lt;CartVO&gt; cartList = cartService.list(UserFilter.currentUser.getId());
        return ApiRestResponse.success();
    &#125;

    @PostMapping(&quot;/add&quot;)
    @ApiOperation(&quot;添加商品到购物车&quot;)
    public ApiRestResponse add(@RequestParam Integer productId, @RequestParam Integer count)&#123;
        //85.补全完逻辑代码 87在下面补全代码 List&lt;CartVO&gt; cartVOList =
        List&lt;CartVO&gt; cartVOList = cartService.add(UserFilter.currentUser.getId(), productId, count);
        return ApiRestResponse.success(cartVOList);
    &#125;
&#125;
</code></pre>
<h3 id="更新、删除购物车接口"><a href="#更新、删除购物车接口" class="headerlink" title="更新、删除购物车接口"></a>更新、删除购物车接口</h3><pre><code class="java">com/imooc/mall/controller/CartController.java
@PostMapping(&quot;/update&quot;)
    @ApiOperation(&quot;更新购物车&quot;)
    public ApiRestResponse update(@RequestParam Integer productId, @RequestParam Integer count)&#123;
        //86.去service层中写更新方法 CartServiceImpl.java
        List&lt;CartVO&gt; cartVOList = cartService.update(UserFilter.currentUser.getId(), productId, count);
        return ApiRestResponse.success(cartVOList);
    &#125;

    @PostMapping(&quot;/delete&quot;)
    @ApiOperation(&quot;删除保护购物车&quot;)
    public ApiRestResponse delete(@RequestParam Integer productId)&#123;
        //87.删除保护购物车方法
        //不能传入userId, cartId, 否则可以删除别人的购物车
        List&lt;CartVO&gt; cartVOList = cartService.delete(UserFilter.currentUser.getId(), productId);
        return ApiRestResponse.success(cartVOList);
    &#125;
=====================================================================
127.0.0.1:8083/cart/delete?productId=22
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CartServiceImpl.java
 @Override
    public List&lt;CartVO&gt; update(Integer userId, Integer productId, Integer count)&#123;
        //86.去service层中写更新方法
        validProduct(productId, count);
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        if (cart==null)&#123;
            //这个商品之前不在购物车里，无法更新
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;else &#123;
            //这个商品已经在购物车里了，则更新数量
            Cart cartNew = new Cart();
            cartNew.setQuantity(count);
            cartNew.setId(cart.getId());
            cartNew.setProductId(cart.getProductId());
            cartNew.setUserId(cart.getUserId());
            //无论是否想买都选中
            cartNew.setSelected(Constant.Cart.CHECKED);
            cartMapper.updateByPrimaryKeySelective(cartNew);
        &#125;
        return this.list(userId);
    &#125;

    @Override
    public List&lt;CartVO&gt; delete(Integer userId, Integer productId)&#123;
        //86.去service层中写更新方法
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        if (cart==null)&#123;
            //这个商品之前不在购物车里，无法更新
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;else &#123;
            //这个商品已经在购物车里了，则可以删除
            cartMapper.deleteByPrimaryKey(cart.getId());
        &#125;
        return this.list(userId);
    &#125;
======================================================================
127.0.0.1:8083/cart/update?productId=22&amp;count=1
</code></pre>
<pre><code class="java">com/imooc/mall/service/CartService.java
package com.imooc.mall.service;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.model.request.AddCategoryReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.model.vo.CategoryVO;

import java.util.List;

/**
 * 79.购物车service 增加CartServiceImpl
 */
public interface CartService &#123;

    //87.补全list实现类
    List&lt;CartVO&gt; list(Integer userId);

    List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; update(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; delete(Integer userId, Integer productId);
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/624114484">浅谈@RequestParam、@RequestBody、@PathVariable - 知乎 (zhihu.com)</a></p>
<h3 id="选中购物车相关接口"><a href="#选中购物车相关接口" class="headerlink" title="选中购物车相关接口"></a>选中购物车相关接口</h3><pre><code class="java">com/imooc/mall/controller/CartController.java
 @PostMapping(&quot;/select&quot;)
    @ApiOperation(&quot;选择/不选择购物车的某商品&quot;)
    public ApiRestResponse select(@RequestParam Integer productId, @RequestParam Integer selected)&#123;
        //88.选/不选购物车某商品
        //不能传入userId, cartId, 否则可以删除别人的购物车
        List&lt;CartVO&gt; cartVOList = cartService.selectOrNot(UserFilter.currentUser.getId(), productId,selected);
        return ApiRestResponse.success(cartVOList);
    &#125;

    @PostMapping(&quot;/selectAll&quot;)
    @ApiOperation(&quot;全选择/全不选择购物车的某商品&quot;)
    public ApiRestResponse selectAll(@RequestParam Integer selected)&#123;
        //89.全选/全不选购物车某商品
        //不能传入userId, cartId, 否则可以删除别人的购物车
////90.订单模块接口编写 91创建OrderController.java  OrderService.java  OrderServiceImpl.java
        List&lt;CartVO&gt; cartVOList = cartService.selectAllOrNot(UserFilter.currentUser.getId(), selected);
        return ApiRestResponse.success(cartVOList);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CartServiceImpl.java
    @Override
    public List&lt;CartVO&gt; selectOrNot(Integer userId, Integer productId, Integer selected)&#123;
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        if (cart==null)&#123;
            //88.这个商品之前不在购物车里，无法选择/不选中
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;else &#123;
            //这个商品已经在购物车里了，则可以选中/不选中
            cartMapper.selectOrNot(userId, productId, selected);
        &#125;//返回购物车列表
        return this.list(userId);
    &#125;

    @Override
    public List&lt;CartVO&gt; selectAllOrNot(Integer userId, Integer selected)&#123;
        //89.这里填null是对mapper中的sql进行等于null判断的语句 改变选中状态
        cartMapper.selectOrNot(userId, null, selected);
        return this.list(userId);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/CartService.java
package com.imooc.mall.service;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.model.request.AddCategoryReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.model.vo.CategoryVO;

import java.util.List;

/**
 * 79.购物车service 增加CartServiceImpl
 */
public interface CartService &#123;

    //87.补全list实现类
    List&lt;CartVO&gt; list(Integer userId);

    List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; update(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; delete(Integer userId, Integer productId);

    List&lt;CartVO&gt; selectOrNot(Integer userId, Integer productId, Integer selected);

    List&lt;CartVO&gt; selectAllOrNot(Integer userId, Integer selected);
&#125;
</code></pre>
<h3 id="总结购物车模块"><a href="#总结购物车模块" class="headerlink" title="总结购物车模块"></a>总结购物车模块</h3><ul>
<li><h5 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h5><ul>
<li>MyBatis返回非标准对象、后期计算单样商品的总价 [数据库无法直接查到]</li>
<li>添加商品到购物车时，根据是否已经存在该商品，有不同逻辑</li>
</ul>
</li>
<li><p>常见错误：不做越权判断 [不允许前端传入Id]</p>
</li>
</ul>
<h3 id="创建订单接口-主流程框架搭建"><a href="#创建订单接口-主流程框架搭建" class="headerlink" title="创建订单接口 - 主流程框架搭建"></a>创建订单接口 - 主流程框架搭建</h3><ul>
<li>登录 → 浏览商品 → 加入购物车 → 下单 <ul>
<li>​                                                            → 取消订单</li>
<li>​                                                            → 扫码支付 → 发货 → 收获 → 订单完结</li>
</ul>
</li>
</ul>
<h3 id="生成订单-——-用户下单"><a href="#生成订单-——-用户下单" class="headerlink" title="生成订单 —— 用户下单"></a>生成订单 —— 用户下单</h3><ul>
<li>入参</li>
<li>从购物车中查找已经勾选的商品</li>
<li>判断商品是否正在售卖中</li>
<li>判断库存，保证不超卖，扣库存</li>
<li>数据库事务(实操演示效果)</li>
<li>删除购物车中对应的商品</li>
<li>生成订单</li>
<li>订单号生成规则</li>
<li>循环保存每个商品到order_item表</li>
<li>进入Coding阶段</li>
</ul>
<pre><code class="java">com/imooc/mall/controller/OrderController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

/**
 * 91.订单Controller 新建一个根据pojo的Order → CreateOrderReq 新建一个OrderService
 */
@RestController
public class OrderController &#123;
    @Autowired
    OrderService orderService;

    @PostMapping(&quot;order/create&quot;)
    public ApiRestResponse create(@RequestBody CreateOrderReq createOrderReq)&#123;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.filter.UserFilter;
import com.imooc.mall.model.dao.CartMapper;
import com.imooc.mall.model.dao.CategoryMapper;
import com.imooc.mall.model.dao.ProductMapper;
import com.imooc.mall.model.pojo.Cart;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.service.CartService;
import com.imooc.mall.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * 91.★★ 订单Service实现类 ★★
 */
@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    CartService cartService;

    public String create(CreateOrderReq createOrderReq) &#123;
        //拿到用户ID
        Integer userId = UserFilter.currentUser.getId();
        //从购物车查找已经勾选的商品 CartVO里面包含着任何信息
        List&lt;CartVO&gt; cartVOList = cartService.list(userId);
        //勾选的单独拿出来
        ArrayList&lt;CartVO&gt; cartVOListTemp = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO = cartVOList.get(i);
            if (cartVO.getSelected().equals(Constant.Cart.CHECKED)) &#123;
                cartVOListTemp.add(cartVO);
            &#125;
        &#125;
        cartVOList = cartVOListTemp;
        //如果购物车已勾选的为空,报错
        if (CollectionUtils.isEmpty(cartVOList))&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.CART_EMPTY);
        &#125;
    &#125;
    //判断商品是否存在、上下架状态、库存
    //把购物车对象转换为订单item对象
    //扣库存
    //把购物车中的已勾选商品删除
    //生成订单
    //生成订单号,有独立的规则
    //循环保存每个商品的order_item表
    //把结果返回
&#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
package com.imooc.mall.exception;

/**
 * 异常枚举
 */
//13.编写异常枚举 注意类是enum噢  14返回ApiRestResponse
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    NEED_ADMIN(10009,&quot;无管理员权限&quot;),
    NAME_NOT_NULL(10010,&quot;参数不能为空&quot;),
    CREATE_FAILED(10011,&quot;新增失败&quot;),
    REQUEST_PARAM_ERROR(10012,&quot;参数错误&quot;),
    DELETE_FAILED(10013,&quot;删除失败&quot;),
    MKDIR_FAILED(10014,&quot;文件夹创建失败&quot;),
    UPLOAD_FAILED(10015,&quot;图片上传失败&quot;),
    NOT_SALE(10016,&quot;商品状态不可售&quot;),
    NOT_ENOUGH(10017,&quot;商品库存不足&quot;),
    CART_EMPTY(10018, &quot;购物车已勾选的商品为空&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);


    //异常码
    Integer code;
    //异常信息
    String msg;

    ImoocMallExceptionEnum(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<h3 id="创建订单-——-对象转换与扣库存"><a href="#创建订单-——-对象转换与扣库存" class="headerlink" title="创建订单 —— 对象转换与扣库存"></a>创建订单 —— 对象转换与扣库存</h3><pre><code class="java">com/imooc/mall/controller/OrderController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

/**
 * 91.订单Controller 新建一个根据pojo的Order → CreateOrderReq 新建一个OrderService
 */
@RestController
public class OrderController &#123;
    @Autowired
    OrderService orderService;

    @PostMapping(&quot;order/create&quot;)
    @ApiOperation(&quot;创建订单&quot;)
    public ApiRestResponse create(@RequestBody CreateOrderReq createOrderReq)&#123;
        //95.调用orderService
        String orderNo = orderService.create(createOrderReq);
        return ApiRestResponse.success(orderNo);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.filter.UserFilter;
import com.imooc.mall.model.dao.*;
import com.imooc.mall.model.pojo.Order;
import com.imooc.mall.model.pojo.OrderItem;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.service.CartService;
import com.imooc.mall.service.OrderService;
import com.imooc.mall.util.OrderCodeFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * 91.★★ 订单Service实现类 ★★
 */
@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    CartService cartService;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CartMapper cartMapper;
    @Autowired
    OrderMapper orderMapper;
    @Autowired
    OrderItemMapper orderItemMapper;
    @Override
    public String create(CreateOrderReq createOrderReq) &#123;
        //拿到用户ID
        Integer userId = UserFilter.currentUser.getId();
        //从购物车查找已经勾选的商品 CartVO里面包含着任何信息
        List&lt;CartVO&gt; cartVOList = cartService.list(userId);
        //勾选的单独拿出来
        ArrayList&lt;CartVO&gt; cartVOListTemp = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO = cartVOList.get(i);
            if (cartVO.getSelected().equals(Constant.Cart.CHECKED)) &#123;
                cartVOListTemp.add(cartVO);
            &#125;
        &#125;
        cartVOList = cartVOListTemp;
        //如果购物车已勾选的为空,报错
        if (CollectionUtils.isEmpty(cartVOList))&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.CART_EMPTY);
        &#125;
        //判断商品是否存在、上下架状态、库存
        validSaleStatusAndStock(cartVOList);
        //把购物车对象转换为订单item对象
        List&lt;OrderItem&gt; orderItemList = cartVOListToOrderItemList(cartVOList);
        //扣库存
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem =  orderItemList.get(i);
            Product product = productMapper.selectByPrimaryKey(orderItem.getProductId());
            int stock = product.getStock() - orderItem.getQuantity();
            if (stock &lt; 0)&#123;
                throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
            &#125;
            product.setStock(stock);
            productMapper.updateByPrimaryKeySelective(product);
        &#125;
        //把购物车中的已勾选商品删除
        cleanCart(cartVOList);
        //生成订单
        Order order = new Order();
        //93.创建一个Util/OrderCodeFactory
        //生成订单号,有独立的规则
        String orderNo = OrderCodeFactory.getOrderCode(Long.valueOf(userId));
        order.setOrderNo(orderNo);
        order.setUserId(userId);
        order.setTotalPrice(totalPrice(orderItemList));
        order.setReceiverName(createOrderReq.getReceiverName());
        order.setReceiverMobile(createOrderReq.getReceiverMobile());
        order.setReceiverAddress(createOrderReq.getReceiverAddress());
        order.setOrderStatus(Constant.OrderStatusEnum.NOT_PAID.getCode()); //94.去Constant定义订单状态
        //循环保存每个商品的order_item表
        order.setPostage(0);
        order.setPaymentType(1);
        //插入到Order表
        orderMapper.insertSelective(order);
        //循环保存每个商品到order_item表
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem =  orderItemList.get(i);
            orderItem.setOrderNo(order.getOrderNo());
            orderItemMapper.insertSelective(orderItem);
        &#125;
        //把结果返回
        return orderNo;
        //95.回到Controller调用
    &#125;
//92.生成相似代码并改造
    private void validSaleStatusAndStock(List&lt;CartVO&gt; cartVOList) &#123;
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO =  cartVOList.get(i);
            Product product = productMapper.selectByPrimaryKey(cartVO.getProductId());
            //判断商品是否存在，商品是否上架
            if (product == null || product.getStatus().equals(Constant.SaleStatus.NOT_SALE)) &#123;
                //82. 1是上架 1不明确要形成代码让顾客知道 Constant.java
                throw new ImoocMallException(ImoocMallExceptionEnum.NOT_SALE);
            &#125;
            //判断商品库存 如果要买的比库存多 就买不了
            if (cartVO.getQuantity() &gt; product.getStock()) &#123;
                throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
            &#125;
        &#125;
    &#125;
    private List&lt;OrderItem&gt; cartVOListToOrderItemList(List&lt;CartVO&gt; cartVOList) &#123;
        List&lt;OrderItem&gt; orderItemList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO =  cartVOList.get(i);
            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(cartVO.getProductId());
            //记录商品快照信息
            orderItem.setProductName(cartVO.getProductName());
            orderItem.setProductImg(cartVO.getProductImage());
            orderItem.setUnitPrice(cartVO.getPrice());
            orderItem.setQuantity(cartVO.getQuantity());
            orderItem.setTotalPrice(cartVO.getTotalPrice());
            orderItemList.add(orderItem);
        &#125;
        return orderItemList;
    &#125;
    private void cleanCart(List&lt;CartVO&gt; cartVOList)&#123;
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO =  cartVOList.get(i);
            cartMapper.deleteByPrimaryKey(cartVO.getId());

        &#125;
    &#125;
    private Integer totalPrice(List&lt;OrderItem&gt; orderItemList)&#123;
        Integer totalPrice = 0;
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem =  orderItemList.get(i);
            totalPrice += orderItem.getTotalPrice();
        &#125;
        return totalPrice;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/util/OrderCodeFactory.java
package com.imooc.mall.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Random;

/**
 * 描述：     生成订单No工具类
 */
public class OrderCodeFactory &#123;

    /**
     * 订单类别头
     */
    private static final String ORDER_CODE = &quot;1&quot;;
    /**
     * 随机编码
     */
    private static final int[] r = new int[]&#123;7, 9, 6, 2, 8, 1, 3, 0, 5, 4&#125;;
    /**
     * 用户id和随机数总长度
     */
    private static final int maxLength = 5;

    /**
     * 更具id进行加密+加随机数组成固定长度编码
     */
    private static String toCode(Long id) &#123;
        String idStr = id.toString();
        StringBuilder idSb = new StringBuilder();
        for (int i = idStr.length() - 1; i &gt;= 0; i--) &#123;
            idSb.append(r[idStr.charAt(i) - &#39;0&#39;]);
        &#125;
        return idSb.append(getRandom(maxLength - idStr.length())).toString();
    &#125;

    /**
     * 生成时间戳
     */
    private static String getDateTime() &#123;
        DateFormat sdf = new SimpleDateFormat(&quot;HHmmss&quot;);
        return sdf.format(new Date());
    &#125;

    /**
     * 生成固定长度随机码
     *
     * @param n 长度
     */
    private static long getRandom(long n) &#123;
        long min = 1, max = 9;
        for (int i = 1; i &lt; n; i++) &#123;
            min *= 10;
            max *= 10;
        &#125;
        long rangeLong = (((long) (new Random().nextDouble() * (max - min)))) + min;
        return rangeLong;
    &#125;

    /**
     * 生成不带类别标头的编码
     */
    private static synchronized String getCode(Long userId) &#123;
        userId = userId == null ? 10000 : userId;
        return getDateTime() + toCode(userId);
    &#125;

    /**
     * 生成订单单号编码
     */
    public static String getOrderCode(Long userId) &#123;
        return ORDER_CODE + getCode(userId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

import com.google.common.collect.Sets;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Set;


/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
@Component //让spring帮注入value
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
    public static String FILE_UPLOAD_DIR;
    //64.为了解决上传图片系统异常报错 注入失败的原因是上方是static普通变量 set方法把静态变量赋值
    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    public void setFileUploadDir(String fileUploadDir)&#123;
        FILE_UPLOAD_DIR = fileUploadDir;
    &#125;//65.打开ImoocMallWebMvcConfig 加一个映射规则

    //74.排序处理 去Constant定义支持的排序模式和手段
    public interface ProductListOrderBy&#123;
        Set&lt;String&gt; PRICE_ASC_DESC = Sets.newHashSet(&quot;price desc&quot;,&quot;price asc&quot;);
    &#125;
    //83.创建商品上下架的状态 创建CartMapper[Cart selectCartByUserIdAndProductId] 写sql 84再去CartServiceImpl
    public interface SaleStatus&#123;
        int NOT_SALE = 0; //商品下架状态
        int SALE = 1; //商品上架状态
    &#125;
    public interface Cart&#123;
        int UN_CHECKED = 0; //购物车未选中状态
        int CHECKED = 1; //购物车选中状态
    &#125;
    public enum OrderStatusEnum&#123;
        CANCELED(0, &quot;用户已取消&quot;),
        NOT_PAID(10, &quot;未付款&quot;),
        PAID(20, &quot;已付款&quot;),
        DELIVERED(30, &quot;已发货&quot;),
        ;

        private String value;
        private int code;
        //94.去Constant定义订单状态
        OrderStatusEnum(int code,String value)&#123;
            this.value = value;
            this.code = code;
        &#125;
        public static OrderStatusEnum codeOf(int code)&#123;
            for (OrderStatusEnum orderStatusEnum : values())&#123;
                if (orderStatusEnum.getCode() == code)&#123;
                    return orderStatusEnum;
                &#125;
            &#125;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ENUM);
        &#125;

        public String getValue() &#123;
            return value;
        &#125;

        public void setValue(String value) &#123;
            this.value = value;
        &#125;

        public int getCode() &#123;
            return code;
        &#125;

        public void setCode(int code) &#123;
            this.code = code;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="添加数据库事务"><a href="#添加数据库事务" class="headerlink" title="添加数据库事务"></a>添加数据库事务</h3><pre><code class="java">//95.写数据库事务代码 @Transactional (要么全对全要 要么全不要)
    @Transactional(rollbackFor = Exception.class)
    @Override
    public String create(CreateOrderReq createOrderReq) &#123;
     ......
    &#125;
</code></pre>
<h3 id="订单详情"><a href="#订单详情" class="headerlink" title="订单详情"></a>订单详情</h3><pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
/* 95.继续实现Service实现类 拷贝一个Order成OrderVo 新增两个属性
        private String orderStatusName;
        private List&lt;OrderItemVo&gt; orderItemVoList;
        因为没有&lt;OrderItemVo&gt;要根据需求去创建
        拷贝OrderItem成OrderItemVO 更改属性
        之后回来补写代码
     */
    public OrderVO detail(String orderNo)&#123;

    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/OrderItemVO.java
public class OrderItemVO &#123;
    private Integer id;

    private String orderNo;

    private Integer productId;

    private String productName;

    private String productImg;

    private Integer unitPrice;

    private Integer quantity;

    private Integer totalPrice;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/OrderVO.java
public class OrderVO &#123;
    private Integer id;

    private String orderNo;

    private Integer userId;

    private Integer totalPrice;

    private String receiverName;

    private String receiverMobile;

    private String receiverAddress;

    private Integer orderStatus;

    private Integer postage;

    private Integer paymentType;

    private Date deliveryTime;

    private Date payTime;

    private Date endTime;

    private Date createTime;

    private Date updateTime;
</code></pre>
<h5 id="订单状态"><a href="#订单状态" class="headerlink" title="订单状态"></a>订单状态</h5><ul>
<li>0 用户已取消</li>
<li>10 未付款(下单后的初始状态)</li>
<li>20 已付款</li>
<li>30 已发货</li>
<li>40 交易完成</li>
</ul>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 /* 95.继续实现Service实现类 拷贝一个Order成OrderVo 新增两个属性
        private String orderStatusName;
        private List&lt;OrderItemVo&gt; orderItemVoList;
        因为没有&lt;OrderItemVo&gt;要根据需求去创建
        拷贝OrderItem成OrderItemVO 更改属性
        之后回来补写代码
     */
   @Override
    public OrderVO detail(String orderNo)&#123;
        //96.去创建mapper的方法后回来补写代码 97写订单controller
        Order order = orderMapper.selectByOrderNo(orderNo);
        //订单不存在,则报错
        if (order == null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //订单存在,需要判断所属
        Integer userId = UserFilter.currentUser.getId();
        if (!order.getUserId().equals(userId)) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_YOUR_ORDER);
        &#125;
        OrderVO orderVO = getOrderVo(order);
        return orderVO;
    &#125;

    private OrderVO getOrderVo(Order order) &#123;
        OrderVO orderVO = new OrderVO();
        BeanUtils.copyProperties(order,orderVO);
        //获取订单对应的orderItemVOList
        List&lt;OrderItem&gt; orderItemList = orderItemMapper.selectByOrderNo(order.getOrderNo());
        //OrderItem和OrderItem相比少了几个字段
        List&lt;OrderItemVO&gt; orderItemVOList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem = orderItemList.get(i);
            OrderItemVO orderItemVO = new OrderItemVO();
            BeanUtils.copyProperties(orderItem, orderItemVO);
            orderItemVOList.add(orderItemVO);
        &#125;
        orderVO.setOrderItemVOList(orderItemVOList);
        //com/imooc/mall/common/Constant.java的列举枚举
        orderVO.setOrderStatusName(Constant.OrderStatusEnum.codeOf(orderVO.getOrderStatus()).getValue());
        return orderVO;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/OrderMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Order;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Order record);

    int insertSelective(Order record);

    Order selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Order record);

    int updateByPrimaryKey(Order record);

    Order selectByOrderNo(String orderNo);
&#125;

=====================================================
 &lt;select id=&quot;selectByOrderNo&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.String&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_order
    where order_no = #&#123;orderNo&#125;
  &lt;/select&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/OrderController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.model.vo.OrderVO;
import com.imooc.mall.service.OrderService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * 91.订单Controller 新建一个根据pojo的Order → CreateOrderReq 新建一个OrderService
 */
@RestController
public class OrderController &#123;
    @Autowired
    OrderService orderService;

    @PostMapping(&quot;order/create&quot;)
    @ApiOperation(&quot;创建订单&quot;)
    public ApiRestResponse create(@RequestBody CreateOrderReq createOrderReq)&#123;
        //95.调用orderService
        String orderNo = orderService.create(createOrderReq);
        return ApiRestResponse.success(orderNo);
    &#125;

    @GetMapping(&quot;order/detail&quot;)
    @ApiOperation(&quot;前台订单详情&quot;)
    public ApiRestResponse detail(@RequestParam String orderNo)&#123;
        //95.调用orderService  Service层具体实现
        OrderVO orderVO = orderService.detail(orderNo);
        return ApiRestResponse.success(orderVO);
    &#125;
&#125;
==========================================
生成订单详情 GET:127.0.0.1:8083/order/detail?orderNo=100233359639
</code></pre>
<h3 id="订单列表"><a href="#订单列表" class="headerlink" title="订单列表"></a>订单列表</h3><pre><code class="java">com/imooc/mall/controller/OrderController.java
//97.写一个订单列表controller
    @GetMapping(&quot;order/list&quot;)
    @ApiOperation(&quot;前台订单列表&quot;)
    public ApiRestResponse list(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        //95.调用list   Service  Service层具体实现
        PageInfo pageInfo = orderService.listForCustomer(pageNum, pageSize);
        return  ApiRestResponse.success(pageInfo);
    &#125;
===============================================
订单列表：GET:127.0.0.1:8083/order/list?pageNum=1&amp;pageSize=10
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
  //97.前台订单实现类 搞个OrderMapper中的selectForCustomer
    @Override
    public PageInfo listForCustomer(Integer pageNum, Integer pageSize)&#123;
        Integer userId = UserFilter.currentUser.getId();
        PageHelper.startPage(pageNum, pageSize);
        List&lt;Order&gt; orderList = orderMapper.selectForCustomer(userId);
        List&lt;OrderVO&gt; orderVOList = orderListToOrderVOList(orderList);
        //新建一个pageinfo返回 方便前端查看
        PageInfo pageInfo = new PageInfo&lt;&gt;(orderList);
        pageInfo.setList(orderVOList);
        return pageInfo;
    &#125;

    private List&lt;OrderVO&gt; orderListToOrderVOList(List&lt;Order&gt; orderList) &#123;
        List&lt;OrderVO&gt; orderVOList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; orderList.size(); i++) &#123;
            Order order =  orderList.get(i);
            OrderVO orderVO = getOrderVo(order);
            orderVOList.add(orderVO);
        &#125;
        return  orderVOList;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/OrderMapper.java
 List&lt;Order&gt; selectForCustomer(Integer userId);
===============================================
mappers/OrderMapper.xml
  &lt;select id=&quot;selectForCustomer&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;integer&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_order
    where user_id = #&#123;userId&#125;
    order by create_time desc
  &lt;/select&gt;
</code></pre>
<h3 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h3><pre><code class="java">com/imooc/mall/controller/OrderController.java
//98.写一个订单取消controller
    @PostMapping(&quot;order/cancel&quot;)
    @ApiOperation(&quot;前台取消订单&quot;)
    public ApiRestResponse cancel(@RequestParam String orderNo)&#123;
        orderService.cancel(orderNo);
        return  ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
//98.写一个订单取消实现类
    @Override
    public void cancel(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //验证用户身份
        //订单存在,需要判断所属
        Integer userId = UserFilter.currentUser.getId();
        if (!order.getUserId().equals(userId)) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_YOUR_ORDER);
        &#125;
        //没有付款才可以取消
        if (order.getOrderStatus().equals(Constant.OrderStatusEnum.NOT_PAID.getCode())) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.CANCELED.getCode());
            order.setEndTime(new Date());
            //更新状态
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
</code></pre>
<h3 id="二维码接口开发"><a href="#二维码接口开发" class="headerlink" title="二维码接口开发"></a>二维码接口开发</h3><p><a target="_blank" rel="noopener" href="https://tool.oschina.net/qr?type=2">在线生成 QR Code (oschina.net)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42456466/article/details/91869955">Springboot 上传图片到项目路径下不能访问，需要重启_springboot能上传图片到win11中但无法访问图片-CSDN博客</a></p>
<pre><code class="java">com/imooc/mall/controller/OrderController.java
//99.生成支付二维码
    @GetMapping(&quot;order/qrcode&quot;)
    @ApiOperation(&quot;前台取消订单&quot;)
    public ApiRestResponse qrcode(@RequestParam String orderNo)&#123;
        orderService.cancel(orderNo);
        return  ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 //99.生成支付二维码 pom.xml生成新的二维码依赖 util新建一个QRCodeGenerator类
       @Override
    public String qrcode(String orderNo) &#123;
        //得到请求相关的信息
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();//不能直接拿到内网的信息 要经过多层转发才可以
        //去application.properties配置一下可以访问的ip  去上面String ip
        String address = ip + &quot;:&quot; + request.getLocalPort();//拼接一下 这下生成的是整个地址
        String payUrl = &quot;http://&quot; + address + &quot;/pay?orderNo=&quot; + orderNo;
        System.out.println(address);
        System.out.println(payUrl);
        try &#123;
            QRCodeGenerator.generateQRCodeImage(payUrl, 350, 350, Constant.FILE_UPLOAD_DIR + orderNo + &quot;.png&quot;);
        &#125; catch (WriterException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
        //这个图片可以通过这个url访问到
        String pngAddress = &quot;http://&quot; + address + &quot;/images/&quot; + orderNo + &quot;.png&quot;;
        return pngAddress;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/util/QRCodeGenerator.java
package com.imooc.mall.util;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;

import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;

/**
 * 99.生成二维码工具
 */
public class QRCodeGenerator &#123;
    public static void generateQRCodeImage(String text, int width, int height, String filePath) throws WriterException, IOException &#123;
        QRCodeWriter qrCodeWriter = new QRCodeWriter();
        BitMatrix bitMatrix = qrCodeWriter.encode(text, BarcodeFormat.QR_CODE, width, height);
        Path path = FileSystems.getDefault().getPath(filePath);
        MatrixToImageWriter.writeToPath(bitMatrix,&quot;PNG&quot;,path);
    &#125;

    public static void main(String[] args) &#123;
        try &#123;
            generateQRCodeImage(&quot;PANCHUNYAO&quot;, 350,350,&quot;/Users/Pluminary/Desktop/idea_Space/mall_file_upload/QRTest.png&quot;);
        &#125; catch (WriterException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">application.properties
file.upload.dir=/Users/Pluminary/Desktop/idea_Space/mall_file_upload/
file.upload.ip=127.0.0.1
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
/**
 * 91.★★ 订单Service实现类 ★★
 */
@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    CartService cartService;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CartMapper cartMapper;
    @Autowired
    OrderMapper orderMapper;
    @Autowired
    OrderItemMapper orderItemMapper;
    @Value(&quot;$&#123;file.upload.ip&#125;&quot;)
    String ip;
............
&#125;
</code></pre>
<h3 id="后台订单列表接口"><a href="#后台订单列表接口" class="headerlink" title="后台订单列表接口"></a>后台订单列表接口</h3><pre><code class="java">com/imooc/mall/controller/OrderAdminController.java
package com.imooc.mall.controller;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.service.OrderService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 100.订单后台管理Controller
 */
@RestController
public class OrderAdminController &#123;
    @Autowired
    OrderService orderService;

    @GetMapping(&quot;admin/order/list&quot;)
    @ApiOperation(&quot;管理员订单列表&quot;)
    public ApiRestResponse listForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        PageInfo pageInfo = orderService.listForAdmin(pageNum, pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 //100.实现类
    @Override
    public PageInfo listForAdmin(Integer pageNum, Integer pageSize) &#123;//想看到所有订单
        PageHelper.startPage(pageNum, pageSize);
        List&lt;Order&gt; orderList = orderMapper.selectAllForAdmin();
        List&lt;OrderVO&gt; orderVOList = orderListToOrderVOList(orderList);
        //新建一个pageinfo返回 方便前端查看
        PageInfo pageInfo = new PageInfo&lt;&gt;(orderList);
        pageInfo.setList(orderVOList);
        return pageInfo;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/OrderMapper.java
List&lt;Order&gt; selectAllForAdmin();
===========================================
mappers/OrderMapper.xml 
&lt;select id=&quot;selectAllForAdmin&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;integer&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_order
    order by create_time desc
  &lt;/select&gt;
</code></pre>
<h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><h6 id="根据订单号生成支付二维码-→-扫码支付-→-访问支付URL-完成支付"><a href="#根据订单号生成支付二维码-→-扫码支付-→-访问支付URL-完成支付" class="headerlink" title="根据订单号生成支付二维码 → 扫码支付 → 访问支付URL, 完成支付"></a>根据订单号生成支付二维码 → 扫码支付 → 访问支付URL, 完成支付</h6><pre><code class="java">com/imooc/mall/controller/OrderController.java
 //101.支付接口
    @GetMapping(&quot;pay&quot;)
    @ApiOperation(&quot;支付接口&quot;)
    public ApiRestResponse pay(@RequestParam String orderNo)&#123;
        orderService.pay(orderNo);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
//101.支付
    @Override
    public void pay(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //支付前的判断 未付款才可以付款
        if (order.getOrderStatus() == Constant.OrderStatusEnum.NOT_PAID.getCode()) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.PAID.getCode());
            order.setPayTime(new Date());
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
</code></pre>
<h3 id="完结订单"><a href="#完结订单" class="headerlink" title="完结订单"></a>完结订单</h3><pre><code class="java">com/imooc/mall/controller/OrderAdminController.java
package com.imooc.mall.controller;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.service.OrderService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 100.订单后台管理Controller
 */
@RestController
public class OrderAdminController &#123;
    @Autowired
    OrderService orderService;

    @GetMapping(&quot;admin/order/list&quot;)
    @ApiOperation(&quot;管理员订单列表&quot;)
    public ApiRestResponse listForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        PageInfo pageInfo = orderService.listForAdmin(pageNum, pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;

    /**
     * 102.发货。订单状态流程：0用户已取消，10未付款，20已付款，30已发货，40交易完成
     */
    @GetMapping(&quot;admin/order/delivered&quot;)
    @ApiOperation(&quot;管理员发货&quot;)
    public ApiRestResponse delivered(@RequestParam String orderNo)&#123;
        orderService.deliver(orderNo);
        return ApiRestResponse.success();
    &#125;

    /**
     * 103.完结订单。订单状态流程：0用户已取消，10未付款，20已付款，30已发货，40交易完成
     * 管理员和用户都可以调用
     */
    @GetMapping(&quot;order/finish&quot;)
    @ApiOperation(&quot;完结订单&quot;)
    public ApiRestResponse finish(@RequestParam String orderNo)&#123;
        orderService.finish(orderNo);
        return ApiRestResponse.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 //102.管理订单实现类开发 发货
    @Override
    public void deliver(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //支付前的判断 判断已付款的
        if (order.getOrderStatus() == Constant.OrderStatusEnum.PAID.getCode()) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.DELIVERED.getCode());
            order.setDeliveryTime(new Date());
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
    //103.完结订单
    @Override
    public void finish(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //有可能管理员调用 有可能用户调用 如果是普通用户, 要去校验一下订单所属
        if (!userService.checkAdminRole(UserFilter.currentUser) &amp;&amp; !order.getUserId().equals(UserFilter.currentUser.getId())) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_YOUR_ORDER);
        &#125;
        //支付前的判断 判断已付款的 //发货后可以完结订单
        if (order.getOrderStatus() == Constant.OrderStatusEnum.DELIVERED.getCode()) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.FINISHED.getCode());
            order.setEndTime(new Date());
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
</code></pre>
<h3 id="全流程测试"><a href="#全流程测试" class="headerlink" title="全流程测试"></a>全流程测试</h3><ul>
<li>Postman实操</li>
<li>登录 → 浏览商品 → 加入购物车 → 下单 <ul>
<li>​                                                            → 取消订单</li>
<li>​                                                            → 扫码支付 → 发货 → 收获 → 订单完结</li>
</ul>
</li>
</ul>
<h5 id="总结订单模块"><a href="#总结订单模块" class="headerlink" title="总结订单模块"></a>总结订单模块</h5><ul>
<li><p>重难点</p>
<ul>
<li>VO的封装、裁剪</li>
<li>一个订单内包括多个商品</li>
<li>订单状态流转</li>
<li>二维码生成</li>
</ul>
</li>
<li><p>常见错误：把POJO返回到前端</p>
</li>
</ul>
<h1 id="上线前准备工作"><a href="#上线前准备工作" class="headerlink" title="上线前准备工作"></a>上线前准备工作</h1><h3 id="阿里云部署"><a href="#阿里云部署" class="headerlink" title="阿里云部署"></a>阿里云部署</h3><p>把每个 com&#x2F;imooc&#x2F;mall&#x2F;model&#x2F;request&#x2F;… 类都加上**toString()**方法 方便调试<br><strong>后台、前台、获取类的行为</strong> 的目录列表都是 <strong>Get</strong>Mapping</p>
<h3 id="前端准备工作"><a href="#前端准备工作" class="headerlink" title="前端准备工作"></a>前端准备工作</h3><h6 id="把static里的前端文件导入项目中"><a href="#把static里的前端文件导入项目中" class="headerlink" title="把static里的前端文件导入项目中"></a>把static里的前端文件导入项目中</h6><pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
//104.ImoocMallWebMvcConfig.java 根据路由配置相关文件 以admin开头的文件会被路由到下面的Locations
package com.imooc.mall.config;

import com.imooc.mall.common.Constant;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
 * 44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;
    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
        //104.根据路由配置相关文件 以admin开头的文件会被路由到下面的Locations
        registry.addResourceHandler(&quot;/admin/**&quot;).addResourceLocations(&quot;classpath:/static/admin&quot;);
        //65.增加一个registry  66.新增接口继续开发 ProductAdminController
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + Constant.FILE_UPLOAD_DIR);
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="部署云服务器"><a href="#部署云服务器" class="headerlink" title="部署云服务器"></a>部署云服务器</h3><ul>
<li>阿里云简介</li>
<li>选择云服务器并购买</li>
<li>环境配置</li>
<li>Spring Boot部署[包括maven打包 sql文件也要上传]</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/region/cn-hangzhou">云服务器管理控制台 (aliyun.com)</a></p>
<blockquote>
<p>免费试用三个月<br>账号: root<br>密码: panchunyao123!</p>
</blockquote>
<pre><code class="java">复制服务器的公网ip：47.98.225.105
cmd本地电脑 → ssh root@47.98.225.105
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_57581439/article/details/124928451">在阿里云购买Linux服务器，配置宝塔环境，全图文，最最详细图解，保姆级教学_阿里云服务器怎么直接买宝塔-CSDN博客</a></p>
<blockquote>
<h2 id="【宝塔安装jdk1-8-yum安装-】"><a href="#【宝塔安装jdk1-8-yum安装-】" class="headerlink" title="【宝塔安装jdk1.8(yum安装)】"></a><strong>【宝塔安装jdk1.8(yum安装)】</strong></h2><p>1、检索检索1.8的列表</p>
<pre><code class="none">yum list java-1.8*
</code></pre>
<p>2、安装1.8.0的所有文件</p>
<pre><code class="none">yum install java-1.8.0-openjdk* -y
</code></pre>
<p>3、使用命令检查是否安装成功</p>
<pre><code class="none">java -version
</code></pre>
</blockquote>
<p>登录宝塔 → 绑定宝塔 → 下载软件<br>宝塔服务器[<a target="_blank" rel="noopener" href="http://47.98.225.105:22003/]">http://47.98.225.105:22003/]</a></p>
<pre><code class="sql">☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ 宝塔BaoTa ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
========================面板账户登录信息=========================
 外网面板地址: http://47.98.225.105:22003/1259ebfa
 内网面板地址: http://172.24.91.49:22003/1259ebfa
 username: grltvl7d
 password: 46303f93


======================== mysql-5.7 ===========================
root密码成功修改为: Panchunyao123![mysql-8.0]

[root@iZbp1dssknxftmjczbtpndZ ~]# mysql -uroot -pPanchunyao123!
mysql&gt; create database imooc_mall;
mysql&gt; use imooc_mall;
Database changed
导入sql文件:imooc_mall_online.sql
从本机将其上传到服务器在cmd中运行:
scp /Users/Pluminary/Desktop/imooc_mall_online.sql root@47.98.225.105:22003:/root
输入服务器密码:panchunyao123!

回到服务器端输入：
mysql&gt; use imooc_mall
Database changed
mysql&gt; source /root/imooc_mall_online.sql
mysql&gt; show tables;
+-----------------------+
| Tables_in_imooc_mall  |
+-----------------------+
| imooc_mall_cart       |
| imooc_mall_category   |
| imooc_mall_order      |
| imooc_mall_order_item |
| imooc_mall_product    |
| imooc_mall_user       |
+-----------------------+
#为数据库赋予权限！！！
mysql&gt; grant all privileges on imooc_mall.* to &#39;root&#39;@&#39;127.0.0.1&#39; identified by &#39;Panchunyao123!&#39;;
--------------------------------------------------------------
MySql8.0
CREATE USER &#39;root&#39;@&#39;47.98.225.105&#39; IDENTIFIED BY &#39;Panchunyao123!&#39;;
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;47.98.225.105&#39; WITH GRANT OPTION;
--------------------------------------------------------------
mysql&gt; quit
Bye
[root@iZbp1dssknxftmjczbtpndZ ~]# mysql -uroot -pPanchunyao123! -h127.0.0.1
去云服务器 安全组 访问规则 入方向 手动添加一个 目的:8081/8081 源:0.0.0.0/0
==============================================================
</code></pre>
<p>整理文件上传到服务器 先**Build → Rebuild Project **<br>打包 <strong>Maven → Lifecycle → clean[之前的内容删除 不容易出错] → package[打包操作]</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_62488212/article/details/132412209">spring打包报错：Java Runtime (class file version 55.0), class file versions up to 52.0_there was an error in the forked process org&#x2F;testn-CSDN博客</a></p>
<pre><code class="sql">[INFO] Building jar: C:\Users\Pluminary\Desktop\idea_Space\mall\target\mall-0.0.1-SNAPSHOT.jar
在本机cmd中运行把导好的包发送給服务器
C:\Users\Pluminary&gt;scp C:\Users\Pluminary\Desktop\idea_Space\mall\target\mall-0.0.1-SNAPSHOT.jar root@c:/root
#rm -rf images/ 删除images文件夹
新建一个文件夹
[root@iZbp1dssknxftmjczbtpndZ ~]# pwd
[root@iZbp1dssknxftmjczbtpndZ ~]# mkdir image

图片上传到服务器中[图片尽量在没有根目录空格的文件夹下 比如Spring Boot 中间有空格]
C:\Users\Pluminary&gt;scp C:/Users/Pluminary/Desktop/images/. root@47.98.225.105:/root/images/

在Xshell7中阿里云服务器
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
images  imooc_mall_online.sql  install.sh  mall-0.0.1-SNAPSHOT.jar

每一次部署之前要把当前的java停止掉
[root@iZbp1dssknxftmjczbtpndZ images]# lsof -i:8081
[root@iZbp1dssknxftmjczbtpndZ images]# kill -9 12345 //按照PID杀死端口号
-bash: kill: (12345) - No such process

部署到云服务器 [/root/null 2&gt;&amp;1 &amp;]将日志输出到哪里 这里是丢弃的意思
[root@iZbp1dssknxftmjczbtpndZ ~]# nohup java -jar -Dserver.port=8081 -Dspring.profiles.active=prod /root/mall-0.0.1-SNAPSHOT.jar &gt; /root/null 2&gt;&amp;1 &amp;
[1] 18656
如果没有别名就一个本来的application.properties
[root@iZbp1dssknxftmjczbtpndZ ~]# nohup java -jar -Dserver.port=8081 /root/mall-0.0.1-SNAPSHOT.jar &gt; /root/null 2&gt;&amp;1 &amp;


 #代表当前程序的进程号
[root@iZbp1dssknxftmjczbtpndZ ~]# lsof -i:8081   //查询端口号
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
java    18656 root   19u  IPv6 195648      0t0  TCP *:tproxy (LISTEN)

============================================================================

若打不开请检查网页报错 寻找传入的application.prod.properties的 
spring.datasource.url地址和spring.datasource.username &amp;&amp; password数据库用户和密码

查看服务器的端口: mysql&gt; show global variables like &#39;port&#39;;

阿里云控制台:
https://ecs.console.aliyun.com/server/i-bp1dssknxftmjczbtpnd/detail?regionId=cn-hangzhou

如何查看linux服务器安装了tomcat：
rpm -qa|grep tomcat

宝塔安装目录: $cd /www/server/.....
[root@iZbp1dssknxftmjczbtpndZ data]# cd /www/server/tomcat/bin
#找到文件后启动tomcat
[root@iZbp1dssknxftmjczbtpndZ bin]# ./startup.sh
#看进程，如果返回一大串东西，说明tomcat启动成功。
[root@iZbp1dssknxftmjczbtpndZ ~]# ps -ef|grep tomcat

运行SpringBoot: 
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
Desktop  images  imooc_mall_online.sql  install.sh  logs  mall-0.0.1-SNAPSHOT.jar  null
[root@iZbp1dssknxftmjczbtpndZ ~]# java -jar mall-0.0.1-SNAPSHOT.jar 

===============================================
当把SpringBoot项目的jar包部署到linux服务器中，启动SpringBoot项目，却无法正常访问，这是怎么回事呢？
主要的原因是端口号被Linux的firewall防火墙拦截掉了
解决办法：
1、查询已开启的端口列表：firewall-cmd --list-ports 
不出意外的话，是啥也没有，这也表示，所有端口都未放行，当然springboot项目的80端口也被拦截掉了
2、firewall-cmd --zone=public --add-port=1-12345/tcp --permanent
将端口1~12345全都开启
3、重启防火墙
service firewalld restart
4、重新运行springboot项目
5、成功访问
===============================================
</code></pre>
<blockquote>
<p>server.port&#x3D;8083<br>spring.datasource.name&#x3D;imooc_mall_datasource<br>spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;47.98.225.105&#x2F;imooc_mall?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;autoReconnect&#x3D;true&amp;useSSL&#x3D;true&amp;allowPublicKeyRetrieval&#x3D;true&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai<br>spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver<br>spring.datasource.username&#x3D;root<br>spring.datasource.password&#x3D;Panchunyao123!<br>mybatis.mapper-locations&#x3D;classpath:mappers&#x2F;*.xml<br>spring.redis.host&#x3D;localhost<br>spring.redis.port&#x3D;6379<br>spring.redis.password&#x3D;<br>file.upload.dir&#x3D;&#x2F;root&#x2F;images&#x2F;<br>file.upload.ip&#x3D;47.98.225.105<br>icode&#x3D;ABCDE</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46070108/article/details/116495116">SpringBoot上传图片，图片不能及时显示问题_springboot项目上传照片到uoload 不会实时更新-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42456466/article/details/91869955">Springboot 上传图片到项目路径下不能访问，需要重启_springboot能上传图片到win11中但无法访问图片-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/124680688">关于springboot项目图片上传到本地，必须重启之后才能访问的解决方案_springboot上传图片需要重启-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/rqz__/article/details/130304492">关于IDEA2022开启热部署没有compiler.automake.allow.when.app.running的解决方案-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37954460/article/details/125842857">Linux部署SpringBoot项目无法访问问题_linux springboot项目启动外面不能访问-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/terry711/article/details/106226298/">linux服务器部署SpringBoot项目并查看项目运行日志_linux 怎么实时查看springboot 日志-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://class.imooc.com/course/qadetail/269346">线上发布报数据库没有连接成功，麻烦帮忙看…-慕课网 (imooc.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63693805/article/details/132626318">linux安装mysql 8 数据库（保姆级）_linux安装mysql8-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52885524/article/details/127076560">慕慕生鲜详细步骤全部打通(从无到上线)-CSDN博客</a></p>
<p>mysql8.0密码&#x3D;&gt; root &amp; Panchunyao123!</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/02/28/后端/SpringBoot入门及电商项目[SpringBoot_MyBatis.generator_Swagger2_Redis_Postman_RESTful_AOP_UUID_QRCode_Linux_Aliyun]/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/01/18/后端/SSM开发社交网站[Freemarker+Spring+SpringMVC+Mybatis(Plus)构成SSM+Bootstrap+Art-Template+Kaptcha+SpringTask+wangEditor]/">
        <h2>
            SSM开发社交网站[Freemarker+Spring+SpringMVC+Mybatis(Plus)构成SSM+Bootstrap+Art-Template+Kaptcha+SpringTask+wangEditor]
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/18
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="慕课书评网学习内容"><a href="#慕课书评网学习内容" class="headerlink" title="慕课书评网学习内容"></a><span style ="color:red">慕课书评网学习内容</span></h1><p><span style ="color:blue"><strong>SSM</strong> &#x3D;&gt; <span style ="color:red"><strong>S</strong></span>pring &#x2F; <span style ="color:red"><strong>S</strong></span>pring MVC &#x2F; <span style ="color:red"><strong>M</strong></span>yBatis</span></p>
<ul>
<li>讲解Spring&#x2F;Spring MVC&#x2F;MyBatis(SSM)整合配置过程</li>
<li>讲解<span style ="color:red"><strong>MyBatis-Plus</strong></span>敏捷开发插件的用法</li>
<li>开发Java Web应用”慕课书评网”</li>
</ul>
<h3 id="主要知识点"><a href="#主要知识点" class="headerlink" title="主要知识点"></a>主要知识点</h3><ul>
<li>SSM整合配置</li>
<li>MyBatis-Plus配置与应用</li>
<li>Kaptcha验证码组件使用</li>
<li>富文本编辑器wangEditor</li>
<li>Spring Task任务调度</li>
<li>基于阿里云实现短信验证</li>
<li>基于腾讯云的滑块验证码实现前置的人机登录检查</li>
</ul>
<h4 id="工程结构与开发规约-复习知识点"><a href="#工程结构与开发规约-复习知识点" class="headerlink" title="工程结构与开发规约 [复习知识点]"></a>工程结构与开发规约 [<span style = "color:red">复习知识点</span>]</h4><h5 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h5><pre><code class="java">mgallery - eclipse工程项目
 /src - java源代码目录
 /WebContent - Web资源目录
 /css - css文件目录
 /js - js文件目录
 /image - 图片资源目录
 /upload - 上传文件目录
 /WEB-INF   //jsp数据来自controller 不允许在web中直接访问 要从控制器跳转
   /jsp - jsp页面目录
   /lib - jar文件目录
   /classes - 编译后的class目录
   /web.xml web描述符文件
</code></pre>
<h5 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h5><pre><code class="java">com.imooc.mgallery //逆命名法
    /controller - 存放Servlet控制器类 //承上启下接收参数 调用逻辑 返回处理结果
    /service - 存放处理逻辑类model[伪数据库] //完成业务逻辑 service与dao进行传递调用
    /dao - Data Access Object 数据访问对象类 数据读写的java类 数据来自xml文件
    /entity - 存放实体类 JavaBean java中的简单对象
    /utils - 通用工具类 底层通用的工具类或方法
</code></pre>
<h3 id="什么是整合"><a href="#什么是整合" class="headerlink" title="什么是整合"></a>什么是整合</h3><ul>
<li>通过Spring IoC容器管理第三方框架对象, 让多框架形成整体</li>
<li><span style ="color:blue"><strong>SSM</strong> &#x3D;&gt; <span style ="color:red"><strong>S</strong></span>pring &#x2F; <span style ="color:red"><strong>S</strong></span>pring MVC &#x2F; <span style ="color:red"><strong>M</strong></span>yBatis</span>是业内最主流的框架搭配<ul>
<li>Spring MVC提供了控制器 基于Spring的Web交互的能力</li>
<li>Spring是对应用程序的对象进行创建和管理</li>
<li>MyBatis是完成了与底层数据库实现增删改查的操作</li>
</ul>
</li>
<li>SSM配置与使用是所有Java工程师必须掌握的技能</li>
</ul>
<h3 id="SSM整合三阶段"><a href="#SSM整合三阶段" class="headerlink" title="SSM整合三阶段"></a>SSM整合三阶段</h3><ul>
<li><span style ="color:red"><strong>Spring与Spring MVC环境配置</strong></span></li>
<li><span style ="color:red"><strong>Spring与MyBatis的整合配置</strong></span></li>
<li><span style ="color:red"><strong>整合其他组件: 声明式事务&#x2F;日志&#x2F;任务调度&#x2F;…</strong></span></li>
</ul>
<h3 id="Spring与Spring-MVC环境配置"><a href="#Spring与Spring-MVC环境配置" class="headerlink" title=" Spring与Spring MVC环境配置"></a><span style ="color:purple"> <strong>Spring与Spring MVC环境配置</strong></span></h3><ul>
<li>依赖Spring-WebMVC</li>
<li>配置DispatcherServlet</li>
<li>启用Spring MVC注解模式</li>
<li>配置请求与相应字符集</li>
<li>配置FreeMarker模板引擎</li>
<li>配置JSON序列化组件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/958385c851d8c4239be83aec9c90132408b1f53b/data/reader%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.png"></p>
<p>编写pom.xml  引入导入的依赖jar包<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fittec/article/details/118942425?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-118942425-blog-120412354.235%5Ev40%5Epc_relevant_anti_vip&spm=1001.2101.3001.4242.2&utm_relevant_index=4">IntelliJ IDEA 2021 自动下载pom文件中的依赖_pom中的自定义插件下载-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67401055/article/details/123938800?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123938800-blog-108093107.235%5Ev40%5Epc_relevant_anti_vip&spm=1001.2101.3001.4242.1&utm_relevant_index=3">idea编译Java项目的部分java文件并且生成class文件_idea将java文件编译成class-CSDN博客</a></p>
<blockquote>
<p>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★<br>设置resource和source<br>方法：点击文件右键-&gt;<strong>make direction as</strong></p>
<p>需要运行和引用的java文件设置为source文件，将配置文件(xml)等设置为resource文件<br>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-reader&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
&lt;!--1.Maven依赖Spring-webmvc 第二步web.xml--&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--    Freemarker --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.30&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--   Jackson依赖包  --&gt;
        &lt;dependency&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">WEB-INF/web.xml    init-param变量 这个是放在servlet里面的，只有此servlet可以访问
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
&lt;!--    2.配置DispatcherServlet 第三步applicationContext.xml--&gt;
 &lt;!--    DispatcherServlet是Spring MVC是最核心的对象
         DispatcherServlet用于拦截http请求        --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;!--自动加载applicationContext--&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
&lt;!--        启动时初始化 servlet--&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt; &lt;!--与上面保持一致--&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;!-- 4.解决中文乱码问题  只会对Post请求生效 Get只需要修改tomcat的server.xml(8.0以上是自动的) 72行增加URIEncoding=&quot;UTF-8&quot; 第五步application--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt; &lt;!--初始化参数--&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;
       xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/task
            http://www.springframework.org/schema/task/spring-task.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
&lt;!-- 3.Spring框架启用SpringMVC注解模式 第四步web.xml--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
&lt;!-- 真正开启SpringMVC注解 --&gt;
&lt;!-- https://blog.csdn.net/u011066470/article/details/112438252 --&gt;
&lt;!-- &lt;mvc:annotation-driven&gt; Spring MVC用来提供Controller请求转发，json自动转换等功能。，默认会帮我们注册默认处理请求，参数和返回值的类 --&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
&lt;!-- 解决相应里的中文输出 --&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                        &lt;!-- 6.JSON(Jackson)序列化输出配置   --&gt;
                        &lt;value&gt;application/json;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
&lt;!-- 诸如css/图片/js静态资源排除在外 使得SpringMVC对url处理效率加大   --&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;!-- 5.配置Freemarker模板引擎 脚本存放地址 Bean定义可以具有零个或多个属性。属性元素对应于bean类公开的JavaBean setter方法。 Spring支持原语，对相同或相关工厂中的其他bean的引用，列表，映射和属性。 --&gt;
    &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;
&lt;!--        对于本身的参数配置  --&gt;
        &lt;property name=&quot;freemarkerSettings&quot;&gt;
            &lt;props&gt;
&lt;!--        默认的编码类型 UTF-8 freemarker读取指定ftl文件时采用此字符集--&gt;
                &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;!--    使用何种模板引擎 创建的后缀名 --&gt;
    &lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="html">WEB-INF/ftl/test.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
测试页面！！
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/imooc/controller/TestController.java
package com.imooc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import java.util.HashMap;
import java.util.Map;

@Controller
public class TestController &#123;
    @GetMapping(&quot;/test/t1&quot;)
    public ModelAndView test1()&#123;
        return new ModelAndView(&quot;/test&quot;);
    &#125;
    @GetMapping(&quot;test/t2&quot;)
    @ResponseBody
    public Map test2()&#123;
        Map result = new HashMap();
        result.put(&quot;test&quot;,&quot;测试文本&quot;);
        return result;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a2272062968/article/details/120404192">IDEA Web项目out&#x2F;classes目录没有编译的class类文件 - IDEA环境下创建Maven WebApp_out中没有class文件夹-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/31486d18fb2b0875fc03efc01fd1d1b5939a6c84/data/idea%E4%B8%ADout%E7%9A%84WEB-INF%E7%83%AD%E9%83%A8%E7%BD%B2%E7%A9%B6%E6%9E%81%E6%96%B9%E6%B3%95.jpg"></p>
<h3 id="Spring与MyBatis整合配置"><a href="#Spring与MyBatis整合配置" class="headerlink" title=" Spring与MyBatis整合配置"></a><span style ="color:purple"> <strong>Spring与MyBatis整合配置</strong></span></h3><p>MyBatisUtils封装初始化代码 如果自己new了对象就不会享受spring的福利待遇</p>
<ul>
<li>依赖mybatis-spring及驱动</li>
<li>配置数据源与连接池</li>
<li>配置SqlSessionFactory</li>
<li>配置Mapper扫描器</li>
<li>创建mybatis-config.xml</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;!-- 5.配置Freemarker模板引擎 脚本存放地址 第六步见pom.xml mybatis依赖 --&gt;
    &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;
&lt;!--        对于本身的参数配置  --&gt;
        &lt;property name=&quot;freemarkerSettings&quot;&gt;
            &lt;props&gt;
&lt;!--        默认的编码类型 UTF-8 freemarker读取指定ftl文件时采用此字符集--&gt;
                &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;!--    使用何种模板引擎 创建的后缀名   --&gt;
    &lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    7. MyBatis与Spring的整合配置   --&gt;
      &lt;!--②.配置数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/imooc_reader?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;initialSize&quot; value=&quot;5&quot;/&gt;
        &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt;
    &lt;/bean&gt;
&lt;!--8. SqlSessionFactoryBean用于根据配置信息创建SqlSessionFactory,不再需要我们自己编码创建--&gt;
    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;!--    存储sql语句的mapper.xml文件 存储在哪个目录中 去创建mapper接口--&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;/&gt;
&lt;!-- 10.  MyBatis配置文件地址 去创建一个xml  --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
&lt;!--  9. 配置Mapper扫描器 下一步9TestMapper --&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
&lt;!--  这样初始化mybatis时 会对所有mapper接口进行扫描 --&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.imooc.reader.mapper&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;!--  6. Mybatis整合步骤：①引入依赖 第七步看applicationContext.xml--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.4&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--        MyBatis与Spring整合组件 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.14&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/TestMapper.java
package com.imooc.reader.mapper;
//接口作用Mybatis通过接口自动生成实现类
public interface TestMapper &#123;
// 系统中接口很多不是所有的都对应mapper 9.application.xml
    public void insert();
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
&lt;!--        驼峰命名转换 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="整合其他组件"><a href="#整合其他组件" class="headerlink" title="整合其他组件"></a><span style ="color:purple"><strong>整合其他组件</strong></span></h3><ul>
<li>配置logback日志输出</li>
<li>声明式事务配置</li>
<li>整合JUnit单元测试</li>
</ul>
<pre><code class="xml">pom.xml
&lt;!--   11. 单元测试依赖 mappers加入test.xml mapper扫描接口后生成对应实现类 12test.xml--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
&lt;!--  15导入依赖 scope打包时不会放进去 tomcat自带 但是测试时不用tomcat所以要加--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
&lt;!--   16加入日志依赖 logback日志组件 17创建logback.xml--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="xml">mappers/test.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.TestMapper&quot;&gt;
&lt;!--   12. 与接口对应的完整类路径  ↓用于对应数据新增 对应TestMapper.java接口  13TestService --&gt;
    &lt;insert id=&quot;insert&quot;&gt;
        insert into test(content) values(&#39;测试内容&#39;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/TestService.java
package com.imooc.reader.service;

import com.imooc.reader.mapper.TestMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

@Service
public class TestService &#123;
// 13.运行时注入生成的对象 自动生成Test 选中上面的类 Code generate 14TestServiceTest.java
    @Resource
    private TestMapper testMapper;
//      @Transactional 要么全部完成 要么什么也不做
    @Transactional
    public void batchImport()&#123;
        for (int i = 0; i &lt; 5; i++) &#123;
//            if (i==3) &#123;
//                throw new RuntimeException(&quot;预期外异常&quot;);
//            &#125;
            testMapper.insert();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/TestServiceTest.java
package com.imooc.reader.service;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

import static org.junit.Assert.*;

//14. 运行时自动初始IoC容器 + 说明配置文件在什么地方完成初始化 15依赖javaservlet pom.xml
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class TestServiceTest &#123;
    @Resource
    private TestService testService;

    @Test
    public void batchImport() &#123;
        testService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">logback.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;
&lt;!--           17.       小时分钟秒   日志级别  线程名   说明何类何方法  对应日志消息+换行--&gt;
&lt;!--            18转至声明式事务 applicationContext上面的文件头加些配置信息 再去下面写--&gt;
            &lt;pattern&gt;%d&#123;HH:mm:ss&#125; %-5level [%thread] %logger&#123;30&#125; - %msg%n&lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
&lt;!--    输出级别   --&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--    18.声明式事务配置 控制事务的打开 提交 回滚 ↓--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    与之对应的注解模式！ 再去TestService.java添加  @Transactional --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<pre><code class="java">@RunWith作用
@RunWith 就是一个运行器
@RunWith(JUnit4.class) 就是指用JUnit4来运行
@RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境
@RunWith(Suite.class) 的话就是一套测试集合，
@ContextConfiguration Spring整合JUnit4测试时，使用注解引入多个配置文件
单个文件
@ContextConfiguration(Locations=“classpath：applicationContext.xml”)
@ContextConfiguration(classes = SimpleConfiguration.class)

多个文件时，可用&#123;&#125;
@ContextConfiguration(locations = &#123; “classpath:spring1.xml”, “classpath:spring2.xml” &#125;)
</code></pre>
<h3 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h3><p><a target="_blank" rel="noopener" href="https://baomidou.com/">MyBatis-Plus (baomidou.com)</a></p>
<ul>
<li>MyBatis-Plus(简称MP)是一个MyBatis的增强工具</li>
<li>自动实现Mapper CRUD操作, 极致提高数据库开发效率</li>
<li>MP在MyBatis的基础上只做增强不做改变</li>
</ul>
<h3 id="MyBatis-Plus整合三部曲"><a href="#MyBatis-Plus整合三部曲" class="headerlink" title="MyBatis-Plus整合三部曲"></a>MyBatis-Plus整合三部曲</h3><ul>
<li>pom引入mybatis-plus依赖</li>
<li>Spring XML更改配置SqlSessionFactory实现类</li>
<li>mybatis-config.xml增加MP分页插件</li>
</ul>
<h3 id="MyBatis-Plus开发三部曲"><a href="#MyBatis-Plus开发三部曲" class="headerlink" title="MyBatis-Plus开发三部曲"></a>MyBatis-Plus开发三部曲</h3><ul>
<li><p>创建实体类, <code>@TableName/ @Tableld/ @TableField</code>实现映射</p>
</li>
<li><p>创建Mapper接口继承BaseMapper, 创建Mapper XML</p>
</li>
<li><p>开发时注入Mapper对象, 通过内置API实现CRUD操作</p>
</li>
</ul>
<h3 id="MyBatis-Plus核心注解"><a href="#MyBatis-Plus核心注解" class="headerlink" title="MyBatis-Plus核心注解"></a>MyBatis-Plus核心注解</h3><ul>
<li><code>@TableName</code> - 将实体类与表名映射</li>
<li><code>@Tableld</code> - 说明对应属性是表的主键</li>
<li><code>@TableField</code> - 设置属性与列名的对应关系</li>
</ul>
<h3 id="BaseMapper接口核心API"><a href="#BaseMapper接口核心API" class="headerlink" title="BaseMapper接口核心API"></a>BaseMapper接口核心API</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>insert</strong>(entity)</td>
<td>数据新增,自动生成insert sql, 根据@Tableld决定注解生成方式</td>
</tr>
<tr>
<td><strong>updateById</strong>(entity)</td>
<td>根据主键更新对应对象, 自动生成update sql</td>
</tr>
<tr>
<td><strong>deleteById</strong>(id)</td>
<td>根据主键删除数据, 自动更新delete sql</td>
</tr>
<tr>
<td><strong>selectById</strong>(id)</td>
<td>按主键查询对应的实体对象</td>
</tr>
<tr>
<td>selectList(queryWrapper)</td>
<td>根据查询生成器(QueryWrapper)的条件自动生成sql查询返回List集合</td>
</tr>
<tr>
<td>selectPage(page,queryWrapper)</td>
<td>分页查询方法, 自动生成分页limit子句, 返回IPage分页对象</td>
</tr>
</tbody></table>
<pre><code class="xml">pom.xml
&lt;!--   19 整合Mybatis-plus依赖  修改application中65行   --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;
            &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml  【替换之前的sessionFactory】
&lt;!--  19. 原生Mybatis与Spring整合  自动实现接口的增删改查  20增加plus底层的分页查询插件 mybatis-config.xml--&gt;
&lt;!--    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;--&gt;
    &lt;bean id=&quot;sessionFactory&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;!--    存储sql语句的mapper.xml文件 存储在哪个目录中 去创建mapper接口--&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;/&gt;
&lt;!-- 10.  MyBatis配置文件地址 去创建一个xml  第十一步pom加单元测试依赖--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
&lt;!--  9. 配置Mapper扫描器  --&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
&lt;!--  这样初始化mybatis时 会对所有mapper接口进行扫描 --&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.imooc.reader.mapper&quot;/&gt;
&lt;/bean&gt;
&lt;!--    18.声明式事务配置 控制事务的打开 提交 回滚 ↓--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    与之对应的注解模式！ 再去TestService.java添加  @Transactional --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
&lt;!--        驼峰命名转换 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;plugins&gt;
&lt;!--  20.配置Mybatis-Plus分页查询     21创entity/Test.java--&gt;
        &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt;&lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/entity/Test.java
// 21 Mybatis-plus运用   22mapper中TestMapper
@TableName(&quot;test&quot;) //说明实体对应哪一张表
public class Test &#123;
    @TableId(type = IdType.AUTO) //数据自增
    @TableField(&quot;id&quot;) //说明属性对应哪个字段
    private Integer id;
    //如果字段名与属性名相同或者符合驼峰命名转换规则 则TableField可以省略
    @TableField(&quot;content&quot;)
    private String content;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/TestMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Test;
//22.为了和BaseMapper里的insert()区别开 这个改名成insertSample
//接口作用Mybatis通过接口自动生成实现类 23.MyBatisPlusTest.java
public interface TestMapper extends BaseMapper&lt;Test&gt; &#123;
// 系统中接口很多不是所有的都对应mapper 9.application.xml
    public void insertSample();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/MyBatisPlusTest.java
package com.imooc.reader;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Test;
import org.junit.runner.RunWith;
import com.imooc.reader.mapper.TestMapper;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.List;

//23.利用插件调用增删改查  24以Bootstrap开发前端index.ftl
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class MyBatisPlusTest &#123;
    @Resource
    private TestMapper testMapper;

    //增
    @org.junit.Test //直接进行调用 与注解重名 故此加包名
    public void testInsert() &#123;
        Test test = new Test();
        test.setContent(&quot;MyBatis Plus测试&quot;);
        //在接口中 com/imooc/reader/mapper/TestMapper.java
        testMapper.insert(test);
    &#125;

    //改
    @org.junit.Test
    public void testUpdate() &#123;
        Test test = testMapper.selectById(30);//按id号查询
        test.setContent(&quot;MyBatis Plus测试1&quot;);
        testMapper.updateById(test);
    &#125;

    //删
    @org.junit.Test
    public void testDelete() &#123;
        testMapper.deleteById(30);
    &#125;

    //查
    @org.junit.Test
    public void testSelect() &#123;
        //传入特殊包装对象
        QueryWrapper&lt;Test&gt; queryWrapper = new QueryWrapper&lt;Test&gt;();
//        queryWrapper.eq(&quot;id&quot;, 31); //eq是等值比较 若写多行语句则sql语言用and连接
        queryWrapper.gt(&quot;id&quot;, 5);//选择范围 查询大于5的数据
        List&lt;Test&gt; list = testMapper.selectList(queryWrapper);//返回获取7号数据的集合
        System.out.println(list.get(0));
    &#125;
&#125;
</code></pre>
<img src="https://raw.githubusercontent.com/P-luminary/images/06dcc63a2b2136dc8423f58abfc719549d2fe9ab/data/for%E7%9A%84%E4%BC%98%E5%8C%96%E6%B5%81.jpg" style="zoom: 80%;" />

<h3 id="基于SSM开发慕课书评网"><a href="#基于SSM开发慕课书评网" class="headerlink" title="基于SSM开发慕课书评网"></a>基于SSM开发慕课书评网</h3><p>导入训练素材的<code>imooc-reader.sql</code></p>
<h5 id="Bootstrap入门介绍-优秀的前端UI框架"><a href="#Bootstrap入门介绍-优秀的前端UI框架" class="headerlink" title="Bootstrap入门介绍 [优秀的前端UI框架]"></a>Bootstrap入门介绍 [优秀的前端UI框架]</h5><ul>
<li>Bootstrap是全球最受欢迎的前端组件库, 由推特(TWitter)开源</li>
<li>Bootstrap用于开发<strong>响应式布局</strong>、移动设备优先的WEB项目</li>
<li>Bootstrap提供完整的HTML、CSS和JS开发工具集</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bootcss.com/">Bootstrap中文网 (bootcss.com)</a></p>
<h3 id="显示图书类别-全部-前端-后端-测试-产品"><a href="#显示图书类别-全部-前端-后端-测试-产品" class="headerlink" title="显示图书类别 [全部 | 前端 | 后端 | 测试 | 产品]"></a>显示图书类别 [<strong>全部</strong> | 前端 | 后端 | 测试 | 产品]</h3><pre><code class="html">index.ftl [只写入顺序关键信息 在这里插入素材中的index.html并更名]
&lt;#--在这块进行动态数据编写 24.创建entity/Category分类实体--&gt;
        &lt;div class=&quot;col-8 mt-2&quot;&gt;
            &lt;span data-category=&quot;-1&quot; style=&quot;cursor: pointer&quot; class=&quot;highlight  font-weight-bold category&quot;&gt;全部&lt;/span&gt;
            |
&lt;#--     31.对页面进行动态的数据导入       --&gt;
            &lt;#list categoryList as category&gt;
                &lt;a style=&quot;cursor: pointer&quot; data-category=&quot;$&#123;category.categoryId&#125;&quot; class=&quot;text-black-50 font-weight-bold category&quot;&gt;$&#123;category.categoryName&#125;&lt;/a&gt;
&lt;#--                取消最后一个的竖线--&gt;
                &lt;#if category_has_next&gt;|&lt;/#if&gt;
            &lt;/#list&gt;
        &lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/entity/Category.java
// 24.图书分类实体 25mapper创建一个CategoryMapper
public class Category &#123;
    @TableId(type = IdType.AUTO)
    private Long categoryId;
// 已自动配置好了驼峰命名法 可以忽略
// @TableField(&quot;category_name&quot;)
    private String categoryName;
&#125;Getter + Setter + 重写toString
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/CategoryMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Category;
//25.BaseMapper自动提供了增删改查的功能 泛型指向Category
// 图书分类Mapper接口 26在mappers中创建一个category.xml
public interface CategoryMapper extends BaseMapper&lt;Category&gt; &#123;

&#125;
</code></pre>
<pre><code class="xml">mappers/category.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.CategoryMapper&quot;&gt;
&lt;!-- 26.如何使用呢？ 27创建一个service/CategoryService接口--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/CategoryService.java
package com.imooc.reader.service;
//27.有了service的接口 28就要有实现实现类存放包CategoryServiceImpl

import com.imooc.reader.entity.Category;
import java.util.List;

public interface CategoryService &#123;
    public List&lt;Category&gt; selectAll();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/CategoryServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Category;
import com.imooc.reader.mapper.CategoryMapper;
import com.imooc.reader.service.CategoryService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.List;

//28.向接口编程的规则,注入写好的CategoryMapper接口 设置Transactional事务传播
//默认所有方法是不使用事务的 查询较多的方法不使用事务 写入方法较多下写入事务
//29生成测试类 code-generate-Test  com/imooc/reader/service/impl/CategoryServiceImplTest.java
@Service(&quot;categoryService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class CategoryServiceImpl implements CategoryService &#123;
    @Resource
    private CategoryMapper categoryMapper;
    /**
     * 查询所有图书分类
     * @return 图书分类List
     */
    @Override
    public List&lt;Category&gt; selectAll() &#123;
        //查询列表 返回多个数据 插入条件构造器[查询所有]
        List&lt;Category&gt; list = categoryMapper.selectList(new QueryWrapper&lt;Category&gt;());
        return list;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/CategoryServiceImplTest.java[Test]
package com.imooc.reader.service.impl;

import com.imooc.reader.entity.Category;
import com.imooc.reader.mapper.CategoryMapper;
import com.imooc.reader.service.CategoryService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

import java.util.List;

import static org.junit.Assert.*;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class CategoryServiceImplTest &#123;
    @Resource
    //29.保证属性和刚才的 @Service(&quot;categoryService&quot;)一致 重写Category的tostring方法重新运行selectAll
    //30进入controller开发环节 新建url与方法绑定的BookController.java
    private CategoryService categoryService;
    @Test
    public void selectAll() &#123;
        List&lt;Category&gt; list = categoryService.selectAll();
        System.out.println(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
package com.imooc.reader.controller;

import com.imooc.reader.entity.Category;
import com.imooc.reader.service.CategoryService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.annotation.Resource;
import java.util.List;

//30.显示之前写好的index.ftl
@Controller
public class BookController &#123;
    //传入模板数据 分类信息
    @Resource
    private CategoryService categoryService;
    //showIndex与url绑定  31继续向前推进因为index.ftl所有数据都是静态写死的
    //31要对每一个分类进行读取 List标签&lt;#list&gt;读取 转至index.ftl 64行
    /**
     * 显示首页
     * @return
     */
    @GetMapping(&quot;/&quot;)
    public ModelAndView showIndex()&#123;
        ModelAndView mav = new ModelAndView(&quot;index&quot;);
        List&lt;Category&gt; categoryList = categoryService.selectAll();//拿到列表
        //结果放入其中 属性名,值
        mav.addObject(&quot;categoryList&quot;,categoryList);
        return mav;
    &#125;
&#125;

----------------------------------------------------------
index.ftl
&lt;#-- 31.对页面进行动态的数据导入 32创建全新实体类Book --&gt;
            &lt;#list categoryList as category&gt;
                &lt;a style=&quot;cursor: pointer&quot; data-category=&quot;$&#123;category.categoryId&#125;&quot; class=&quot;text-black-50 font-weight-bold category&quot;&gt;$&#123;category.categoryName&#125;&lt;/a&gt;
&lt;#--   取消最后一个的竖线 --&gt;
                &lt;#if category_has_next&gt;|&lt;/#if&gt;
            &lt;/#list&gt;
        &lt;/div&gt;
</code></pre>
<h3 id="实现图书分页查询"><a href="#实现图书分页查询" class="headerlink" title="实现图书分页查询"></a>实现图书分页查询</h3><pre><code class="java">com/imooc/reader/entity/Book.java
// 32.创建完Book实体类  33去创建全新的BookMapper接口[mapper中]
@TableName(&quot;book&quot;)
public class Book &#123;
    @TableId(type = IdType.AUTO)
    private Long bookId;
    private String bookName;
    private String subTitle;
    private String author;
    private String cover;
    private String description;
    private Long categoryId;
    private Float evaluationScore;
    private Integer evaluationQuantity;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/BookMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Book;
//33.创建完Book接口  34与之对应的创建book.xml文件
public interface BookMapper extends BaseMapper&lt;Book&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">mappers/book.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.BookMapper&quot;&gt;
&lt;!--33.完成底层与数据交互代码 34完成分页处理 是在Service中完成的创建BookService完成分页对象查询--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
package com.imooc.reader.service;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
//图书服务
public interface BookService &#123;
    //34.泛型&lt;Book&gt; 说明查询出来的每一行数据都是一个Book对象
    // 瞄准BookService快速生成实现类Alt+Enter =&gt; Implement interface
    //35编写com.imooc.reader.service.impl.BookServiceImpl
    public IPage&lt;Book&gt; paging(Integer page, Integer rows);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.imooc.reader.entity.Book;
import com.imooc.reader.mapper.BookMapper;
import com.imooc.reader.service.BookService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

//35. 实现分类代码编写  36生成测试用例 Code generate Test =&gt; BookServiceImplTest
@Service(&quot;bookService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class BookServiceImpl implements BookService &#123;
    @Resource
    private BookMapper bookMapper;
    /**
     * 分页查询图书
     * @param page 页号
     * @param rows 每页记录数
     * @return 分页对象
     */
    public IPage&lt;Book&gt; paging(Integer page, Integer rows) &#123;
        Page&lt;Book&gt; p = new Page&lt;Book&gt;(page,rows);
        QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;Book&gt;();
        IPage&lt;Book&gt; pageObject = bookMapper.selectPage(p, queryWrapper);//传入两个参数: page对象哪一页数据  每页记录数[条件构造器]
        return pageObject;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImplTest.java[Test]
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
import com.imooc.reader.service.BookService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

import java.util.List;

import static org.junit.Assert.*;
//36.测试分页的代码编写  37去BookController新加一个方法
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class BookServiceImplTest &#123;
    @Resource
    private BookService bookService;
    @Test
    public void paging() &#123;
        //查询每页十条
        IPage&lt;Book&gt; pageObject = bookService.paging(1,10);
        //获取当前页数据
        List&lt;Book&gt; records = pageObject.getRecords();
        for (Book b:records)&#123;
            System.out.println(b.getBookId() + &quot;:&quot; + b.getBookName());
        &#125;
        System.out.println(&quot;总页数：&quot; + pageObject.getPages());
        System.out.println(&quot;总记录数：&quot; + pageObject.getTotal());
    &#125;
&#125;
</code></pre>
<h3 id="Ajax动态加载图书信息"><a href="#Ajax动态加载图书信息" class="headerlink" title="Ajax动态加载图书信息"></a>Ajax动态加载图书信息</h3><pre><code class="java">com/imooc/reader/controller/BookController.java
//37.编写一个page方法 上面加个@Resource 绑定一个Ajax @GetMapping
    //http://localhost/books 非常长的JSON序列化结果  38index.ftl 83行
    /**  
     * 分页查询图书列表
     * @param p 页号
     * @return 分页对象
     */
package com.imooc.controller;

import com.imooc.reader.entity.Book;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.service.BookService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.annotation.Resource;

@Controller
public class BookController &#123;
    @Resource
    private BookService bookService;
    
    @GetMapping(&quot;/books&quot;)
    @ResponseBody //具体数据来自客户端传入
    public IPage&lt;Book&gt; selectBook(Long categoryId, String order, Integer p) &#123;
        if (p == null) &#123;
            p = 1;
        &#125;
        IPage&lt;Book&gt; pageObject = bookService.paging(categoryId, order, p, 10);
        return pageObject;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gybshen/article/details/79990533">img标签src引用网络图片，响应403的解决方法_img src引用其他网站图片-CSDN博客</a></p>
<pre><code class="java">index.ftl
  &lt;#--    38.编写Json序列化格式并追加到当前网页 上方以导入Art-Template模板引擎 39将&lt;div id=&quot;bookList&quot;&gt;下面的代码裁切放到上面 http://localhost/ --&gt;
    &lt;script&gt;
        $(function () &#123;
            $.ajax(&#123;
                url: &quot;/books&quot;,
                data : &#123;p:1&#125;,
                type : &quot;get&quot;,
                dataType : &quot;json&quot;,
                success: function(json)&#123;
                    console.info(json);
                    var list = json.records;//获取当前分页数据
                    for (var i = 0; i &lt; list.length; i++) &#123;
                        var book = json.records[i];
                        //动态将数据组合成html
                        var html = &quot;&lt;li&gt;&quot; + book.bookName + &quot;&lt;/li&gt;&quot;;
                        //jquery的id选择器选中div对象 追加
                        $(&quot;#bookList&quot;).append(html);
                    &#125;
                &#125;
            &#125;)
        &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="Art-Template-腾讯JS模板引擎"><a href="#Art-Template-腾讯JS模板引擎" class="headerlink" title="Art - Template 腾讯JS模板引擎"></a>Art - Template 腾讯JS模板引擎</h3><p><a target="_blank" rel="noopener" href="https://aui.github.io/art-template/zh-cn/index.html">art-template (aui.github.io)</a></p>
<p>整段HTML模板化 静态文本不变化 动态的数据用响应表达式进行提取</p>
<p>两组大括号进行数据提取</p>
<pre><code class="java">index.ftl
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/bootstrap/bootstrap.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/raty/lib/jquery.raty.css&quot;&gt;
    &lt;script src=&quot;./resources/jquery.3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./resources/bootstrap/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./resources/art-template.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./resources/raty/lib/jquery.raty.js&quot;&gt;&lt;/script&gt;
-------------------------------------------------------------------------------------
&lt;#--39.type=&quot;text/html&quot;说明当前script块中包含的内容是一段一段的html浏览器不会作为javascript进行解析--&gt;
&lt;#-- ★ ★ ★ id是模板名字 两组大括号进行提取数据 ★ ★ ★ 使用模板引擎简化产生html过程--&gt;
&lt;#--    40去修改下方script代码导入的形式--&gt;
    &lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt;
        &lt;a href=&quot;/book/&#123;&#123;bookId&#125;&#125;&quot; style=&quot;color: inherit&quot;&gt;
            &lt;div class=&quot;row mt-2 book&quot;&gt;
                &lt;div class=&quot;col-4 mb-2 pr-2&quot;&gt;
                    &lt;img class=&quot;img-fluid&quot; src=&quot;&#123;&#123;cover&#125;&#125;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-8  mb-2 pl-0&quot;&gt;
                    &lt;h5 class=&quot;text-truncate&quot;&gt;&#123;&#123;bookName&#125;&#125;&lt;/h5&gt;

                    &lt;div class=&quot;mb-2 bg-light small  p-2 w-100 text-truncate&quot;&gt;&#123;&#123;author&#125;&#125;&lt;/div&gt;


                    &lt;div class=&quot;mb-2 w-100&quot;&gt;&#123;&#123;subTitle&#125;&#125;&lt;/div&gt;

                    &lt;p&gt;
                        &lt;span class=&quot;stars&quot; data-score=&quot;&#123;&#123;evaluationScore&#125;&#125;&quot; title=&quot;gorgeous&quot;&gt;&lt;/span&gt;
&lt;#--                        &lt;img alt=&quot;1&quot; 加入了星型组件免去这些操作 --&gt;
&lt;#--                             src=&quot;./resources/raty/lib/images/star-on.png&quot;--&gt;
&lt;#--                             title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img alt=&quot;2&quot;--&gt;
&lt;#--                                                         src=&quot;./resources/raty/lib/images/star-on.png&quot;--&gt;
&lt;#--                                                         title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img--&gt;
&lt;#--                                alt=&quot;3&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img--&gt;
&lt;#--                                alt=&quot;4&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img--&gt;
&lt;#--                                alt=&quot;5&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&lt;input--&gt;
&lt;#--                                name=&quot;score&quot; type=&quot;hidden&quot; value=&quot;&#123;&#123;evaluationScore&#125;&#125;&quot; readonly=&quot;&quot;&gt;&lt;/span&gt;--&gt;
                        &lt;span class=&quot;mt-2 ml-2&quot;&gt;&#123;&#123;evaluationScore&#125;&#125;&lt;/span&gt;
                        &lt;span class=&quot;mt-2 ml-2&quot;&gt;&#123;&#123;evaluationQuantity&#125;&#125;人已评&lt;/span&gt;
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/a&gt;
    &lt;/script&gt;

&lt;#--    38.编写Json序列化格式并追加到当前网页 上方以导入Art-Template[js]模板引擎 39将&lt;div id=&quot;bookList&quot;&gt;下面的代码裁切放到上面--&gt;
        &lt;script&gt;
&lt;#-- 41.引入星星图片 和 评价方法 上面的script运用简便写法 42下面 $(&quot;.stars&quot;)将星星的span标签选中 raty转换成可视的星星组件--&gt;
            $.fn.raty.defaults.path = &quot;./resources/raty/lib/images&quot;
            $(function () &#123;
                $.ajax(&#123;
                    url: &quot;/books&quot;,
                    data : &#123;p:1&#125;,
                    type : &quot;get&quot;,
                    dataType : &quot;json&quot;,
                    success: function(json)&#123;
                        console.info(json);
                        var list = json.records;//获取当前分页数据
                        for (var i = 0; i &lt; list.length; i++) &#123;
                            var book = json.records[i];
                            // 动态将数据组合成html
                            // var html = &quot;&lt;li&gt;&quot; + book.bookName + &quot;&lt;/li&gt;&quot;;
                            // 40.替换导入数据形式 (传入模板id,传入数据) 将数据结合tpl模板,生成html
                            // 41当评分降低的时候顺带着星星的亮度降低 raty星型评分组件 上面已准备好raty css js引入
                            // 41在上面几行引入星型评分的script方法
                            var html = template(&quot;tpl&quot;, book);
                            console.info(html);
                            //jquery的id选择器选中div对象 追加
                            $(&quot;#bookList&quot;).append(html);
                        &#125;
                        //42.显示星型评价组件 只读并不能修改
                        $(&quot;.stars&quot;).raty(&#123;readonly:true&#125;);
                    &#125;
                &#125;)
            &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="实现图书列表分页查询"><a href="#实现图书列表分页查询" class="headerlink" title="实现图书列表分页查询"></a>实现图书列表分页查询</h3><pre><code class="java">index.ftl
// 43.用于绑定加载更多按钮单击事件 44下面的设置页面的逻辑及处理
        $(function () &#123;
            $(&quot;#btnMore&quot;).click(function ()&#123;
                loadMore();
            &#125;)
        &#125;)
</code></pre>
<pre><code class="java">&lt;script&gt;
&lt;#-- 41.引入星星图片 和 评价方法 上面的script运用简便写法 42下面 $(&quot;.stars&quot;)将星星的span标签选中 raty转换成可视的星星组件(被注释)--&gt;
        $.fn.raty.defaults.path = &quot;./resources/raty/lib/images&quot;
        // 45.对两次Ajax的代码进行重构与梳理(定义一个loadMore()方法将下面的裁切进来底下写进递归)
        // isReset参数设置true,代表从第一页开始查询,否则按nextPage查询后续页
        // 对下面那个data: &#123;p: 1&#125;, 进行重构 ↓↓↓↓ isReset 下面代码已经被注释但未完全删除
        // loadMore()加载更多数据
        function loadMore(isReset)&#123;
            if (isReset == true)&#123;
                $(&quot;#nextPage&quot;).val(1);
            &#125;
            var nextPage = $(&quot;#nextPage&quot;).val();
            $.ajax(&#123;
                url: &quot;/books&quot;,
                //nextPage为2可以加载第二页
                data: &#123;p: nextPage&#125;,
                type: &quot;get&quot;,
                dataType: &quot;json&quot;,
                success: function (json) &#123;
                    console.info(json);
                    var list = json.records;//获取当前分页数据
                    for (var i = 0; i &lt; list.length; i++) &#123;
                        var book = json.records[i];
                        var html = template(&quot;tpl&quot;, book);
                        console.info(html);
                        //jquery的id选择器选中div对象 追加
                        $(&quot;#bookList&quot;).append(html);
                    &#125;
                    $(&quot;.stars&quot;).raty(&#123;readonly: true&#125;);
                    // 44.如果当前页小于总页数 下面利用val设置隐藏域的值
                    // 可能将按照字符串处理 结果是31而不是4 要强制转换
                    // 若有后续数据的话 最后几行的divNoMore需要隐藏起来
                    // 45对两次的Ajax代码进行重构与梳理 上面找到第一个script
                    if (json.current &lt; json.pages)&#123;
                        $(&quot;#nextPage&quot;).val(parseInt(json.current + 1));
                        $(&quot;#btnMore&quot;).show();
                        $(&quot;#divNoMore&quot;).hide();
                    &#125;else &#123;
                        $(&quot;#btnMore&quot;).hide();
                        $(&quot;#divNoMore&quot;).show();
                    &#125;
                &#125;
            &#125;)
        &#125;
     
        $(function () &#123;
            loadMore(true);
        &#125;)

        // 43.用于绑定加载更多按钮单击事件 44上面的设置页面的逻辑及处理
        $(function () &#123;
            $(&quot;#btnMore&quot;).click(function ()&#123;
                loadMore();
            &#125;)
        &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="实现图书多条件动态查询"><a href="#实现图书多条件动态查询" class="headerlink" title="实现图书多条件动态查询"></a>实现图书多条件动态查询</h3><pre><code class="java">index.ftl
// 43.用于绑定加载更多按钮单击事件 44上面的设置页面的逻辑及处理
        $(function()&#123;
            $(&quot;#btnMore&quot;).click(function()&#123;
                loadMore();
            &#125;)
            //46 增加点击的显示控件
            $(&quot;.category&quot;).click(function () &#123;
                $(&quot;.category&quot;).removeClass(&quot;highlight&quot;); //移除高亮
                $(&quot;.category&quot;).addClass(&quot;text-black-50&quot;);//增添灰色
                $(this).addClass(&quot;highlight&quot;);//增加高亮
                //49添加数量与热度 ↓点击的超链接 在下面也要添加order
                var categoryId = $(this).data(&quot;category&quot;); //214行定义了data-category
                $(&quot;#categoryId&quot;).val(categoryId);
                loadMore(true); //每次点完要重新查询
            &#125;)//在排序处显示控件 47点击 全部|前端|后端 产生数据联动BookService上

            $(&quot;.order&quot;).click(function()&#123;
                $(&quot;.order&quot;).removeClass(&quot;highlight&quot;); //移除高亮
                $(&quot;.order&quot;).addClass(&quot;text-black-50&quot;);//增添灰色
                $(this).addClass(&quot;highlight&quot;);//增加高亮
                //~49.提取设置到隐藏域中 发送请求到Ajax服务器上最上面 50var categoryId
                var order = $(this).data(&quot;order&quot;);
                $(&quot;#order&quot;).val(order); //点击不同隐藏域时为其赋值
                loadMore(true);
            &#125;)
        &#125;)
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
package com.imooc.reader.service;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
//图书服务
public interface BookService &#123;
    //34.泛型&lt;Book&gt; 说明查询出来的每一行数据都是一个Book对象
    // 瞄准BookService快速生成实现类Alt+Enter =&gt; Implement interface
    //35编写com.imooc.reader.service.impl.BookServiceImpl

    /**
     * 分页查询图书
     * @param categoryId 分类编号
     * @param order 排序方式
     * @param page 页号
     * @param rows 每页记录数
     * @return 分页对象
     */
//    47增加两个变量且在BookServiceImpl中也对应增加上
    public IPage&lt;Book&gt; paging(Long categoryId, String order, Integer page, Integer rows);
&#125;
</code></pre>
<pre><code class="java">package com.imooc.reader.service.impl.BookServiceImpl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.imooc.reader.entity.Book;
import com.imooc.reader.mapper.BookMapper;
import com.imooc.reader.service.BookService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

//35. 实现分类代码编写  36生成测试用例 Code generate Test =&gt; BookServiceImplTest
@Service(&quot;bookService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class BookServiceImpl implements BookService &#123;
    @Resource
    private BookMapper bookMapper;

    /**
     * 分页查询图书
     *
     * @param categoryId 分类编号
     * @param order      排序方式
     * @param page       页号
     * @param rows       每页记录数
     * @return 分页对象
     */
    public IPage&lt;Book&gt; paging(Long categoryId, String order, Integer page, Integer rows) &#123;
        Page&lt;Book&gt; p = new Page&lt;Book&gt;(page, rows);
        QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;Book&gt;();
        //47.编写匹配条件 48去BookController更改调用参数
        if (categoryId != null &amp;&amp; categoryId != -1) &#123;//代表传入了有效分类编号
            queryWrapper.eq(&quot;category_id&quot;, categoryId);//查询的where子句
        &#125;
        if (order != null) &#123;
            if (order.equals(&quot;quantity&quot;)) &#123; //前台必须传入↓ 评价人数排序
                queryWrapper.orderByDesc(&quot;evaluation_quantity&quot;);//降序排序
            &#125; else if (order.equals(&quot;score&quot;)) &#123;
                queryWrapper.orderByDesc(&quot;evaluation_score&quot;);//评分降序
            &#125;
        &#125;
        IPage&lt;Book&gt; pageObject = bookMapper.selectPage(p, queryWrapper);//传入两个参数: page对象哪一页数据  每页记录数[条件构造器]
        return pageObject;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
package com.imooc.reader.controller;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
import com.imooc.reader.entity.Category;
import com.imooc.reader.service.BookService;
import com.imooc.reader.service.CategoryService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import javax.annotation.Resource;
import java.util.List;

//30.显示之前写好的index.ftl
@Controller
public class BookController &#123;
    //传入模板数据 分类信息
    @Resource
    private CategoryService categoryService;
    @Resource
    private BookService bookService;
    //showIndex与url绑定  31继续向前推进因为index.ftl所有数据都是静态写死的
    //31要对每一个分类进行读取 List标签&lt;#list&gt;读取 转至index.ftl 64行

    /**
     * 显示首页
     *
     * @return
     */
    @GetMapping(&quot;/&quot;)
    public ModelAndView showIndex() &#123;
        ModelAndView mav = new ModelAndView(&quot;index&quot;);
        List&lt;Category&gt; categoryList = categoryService.selectAll();//拿到列表
        //结果放入其中 属性名,值
        mav.addObject(&quot;categoryList&quot;, categoryList);
        return mav;
    &#125;
//37.编写一个page方法 上面加个@Resource 绑定一个Ajax @GetMapping
    //http://localhost/books 非常长的JSON序列化结果  38index.ftl 40行

    /**
     * 分页查询图书列表
     *
     * @param p 页号
     * @return 分页对象
     */
    //48.更改调用参数 更改BookServiceImplTest.java调用参数 49回到index.ftl 增加function第二个
    @GetMapping(&quot;/books&quot;)
    @ResponseBody //具体数据来自客户端传入
    public IPage&lt;Book&gt; selectBook(Long categoryId, String order, Integer p) &#123;
        if (p == null) &#123;
            p = 1;
        &#125;
        IPage&lt;Book&gt; pageObject = bookService.paging(categoryId, order, p, 10);
        return pageObject;
    &#125;
&#125;
</code></pre>
<pre><code class="java">index.ftl
&lt;script&gt;
        &lt;#-- 41.引入星星图片 和 评价方法 上面的script运用简便写法 42下面 $(&quot;.stars&quot;)将星星的span标签选中 raty转换成可视的星星组件(被注释)--&gt;
        $.fn.raty.defaults.path = &quot;./resources/raty/lib/images&quot;
        // 45.对两次Ajax的代码进行重构与梳理(定义一个loadMore()方法将下面的裁切进来底下写进递归)
        // isReset参数设置true,代表从第一页开始查询,否则按nextPage查询后续页
        // 对下面那个data: &#123;p: 1&#125;, 进行重构 ↓↓↓↓ isReset 下面代码已经被注释但未完全删除
        // loadMore()加载更多数据 46下方整理点击时的高亮显示 [全部]
        function loadMore(isReset)&#123;
            if(isReset == true)&#123;
                $(&quot;#bookList&quot;).html(&quot;&quot;);
                $(&quot;#nextPage&quot;).val(1);
            &#125;
            // 50.让Ajax获取数据在下方data填写 下方$(&quot;.category和.order&quot;)都要重新调用递归
            // 细节清空再显示 上方$(&quot;#bookList&quot;).html(&quot;&quot;);
            var nextPage = $(&quot;#nextPage&quot;).val();
            var categoryId= $(&quot;#categoryId&quot;).val();
            var order = $(&quot;#order&quot;).val();
            //接下来就是发送数据时 组织成参数发送服务器
            $.ajax(&#123;
                url : &quot;/books&quot; ,
                //nextPage为2可以加载第二页  ↓字符串：变量
                data : &#123;p:nextPage,&quot;categoryId&quot;:categoryId , &quot;order&quot;:order&#125;,
                type : &quot;get&quot; ,
                dataType : &quot;json&quot; ,
                success : function(json)&#123;
                    console.info(json);
                    var list = json.records;
                    for(var i = 0 ; i &lt; list.length ; i++)&#123;
                        var book = json.records[i];
                        // var html = &quot;&lt;li&gt;&quot; + book.bookName + &quot;&lt;/li&gt;&quot;;
                        //将数据结合tpl模板,生成html
                        var html = template(&quot;tpl&quot; , book);
                        console.info(html);
                        //jquery的id选择器选中div对象 追加
                        $(&quot;#bookList&quot;).append(html);
                    &#125;
                    $(&quot;.stars&quot;).raty(&#123;readOnly:true&#125;);
                    // 44.如果当前页小于总页数 下面利用val设置隐藏域的值
                    // 可能将按照字符串处理 结果是31而不是4 要强制转换
                    // 若有后续数据的话 最后几行的divNoMore需要隐藏起来
                    // 45对两次的Ajax代码进行重构与梳理 上面找到第一个script
                    if(json.current &lt; json.pages)&#123;
                        $(&quot;#nextPage&quot;).val(parseInt(json.current) + 1);
                        $(&quot;#btnMore&quot;).show();
                        $(&quot;#divNoMore&quot;).hide();
                    &#125;else&#123;
                        $(&quot;#btnMore&quot;).hide();
                        $(&quot;#divNoMore&quot;).show();
                    &#125;
                &#125;
            &#125;)
        &#125;
</code></pre>
<h3 id="图书详情页-读取图书信息"><a href="#图书详情页-读取图书信息" class="headerlink" title="图书详情页-读取图书信息"></a>图书详情页-读取图书信息</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gybshen/article/details/79990533">img标签src引用网络图片，响应403的解决方法_img src引用其他网站图片-CSDN博客</a></p>
<pre><code class="java">com/imooc/reader/service/BookService.java
public IPage&lt;Book&gt; paging(Long categoryId, String order, Integer page, Integer rows);
    /**
     * 根据图书编号查询图书对象
     * @param bookId 图书编号
     * @return 图书对象
     */
    //51.增加一个查询书籍的接口 再去BookServiceImpl中实现
    public Book selectById(Long bookId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
 //51实现后再向上推进 BookController
    @Override
    public Book selectById(Long bookId) &#123;
        Book book = bookMapper.selectById(bookId);
        return book;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
//51.进行页面的绑定 获取读书编号 52把所有ftl相对路径改成绝对路径 ./前面的.删掉
    //加上了./就是  localhost/book/......   删掉就是 localhost/......
    //52更改detail.ftl将静态页面改成动态页面
    @GetMapping(&quot;/book/&#123;id&#125;&quot;) //↓ 路径变量 和 上面的保持一致
    public ModelAndView showDetail(@PathVariable(&quot;id&quot;) Long id)&#123;
        Book book = bookService.selectById(id);
        ModelAndView mav = new ModelAndView(&quot;/detail&quot;);
        mav.addObject(&quot;book&quot;, book);
        return mav;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
&lt;#-- 52.更改detail.ftl将静态页面改成动态页面 &lt;title&gt; 还有下面图书细节 --&gt;
&lt;#--  53.来源于数据底层的description描述字段   54显示动态评论列表 数据库有evaluation表 创建一个entity/Evaluation--&gt;

    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt; &lt;#--防止网页图片加载不出来--&gt;
    &lt;title&gt;$&#123;book.bookName&#125;&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/bootstrap/bootstrap.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/raty/lib/jquery.raty.css&quot;&gt;
    &lt;script src=&quot;/resources/jquery.3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/resources/bootstrap/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/resources/art-template.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/resources/raty/lib/jquery.raty.js&quot;&gt;&lt;/script&gt;

-------------------------------------------------------------------
&lt;div class=&quot;row p-2 description&quot;&gt;
        &lt;#-- 53.来源于数据底层的description描述字段     --&gt;
        $&#123;book.description&#125;
    &lt;/div&gt;
</code></pre>
<h3 id="图书详情页-显示评论列表"><a href="#图书详情页-显示评论列表" class="headerlink" title="图书详情页-显示评论列表"></a>图书详情页-显示评论列表</h3><pre><code class="java">com/imooc/reader/entity/Member.java
//59.创建Member实体后完成MemberMapper接口
@TableName(&quot;member&quot;)
public class Member &#123;
    @TableId(type = IdType.AUTO)
    private Long memberId;
    private String username;
    private String password;
    private Integer salt;
    private String nickname;
    private Date createTime;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/reader/entity/Evaluation.java
package com.imooc.reader.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.util.Date;
//54.创造了评论相关的底层entity 55定义一个EvaluationMapper.java接口
//再定义一个 evaluation.xml  再service上创建一个新的接口EvaluationService.java
@TableName(&quot;evaluation&quot;)
public class Evaluation &#123;
//  id是主键
    @TableId(type= IdType.AUTO)
    private Long evaluationId;
    private Long bookId;
    private String content;
    private Integer score;
    private Long memberId;
    private Date createTime;
    private Integer enjoy;
    private String state;
    private String disableReason;
    private Date disableTime;
    @TableField(exist = false) //58.说明book属性没有对应字段,不会参与到sql自动生成
    private Book book; //Book的关联字段 加注解不存在 不会参与sql语句自动生成中 59创建会员entity对象Member实体
    @TableField(exist = false)
    private Member member; //59.获取集合后查询每个评论的信息 EvaluationServiceImpl中
&#125;Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/EvaluationMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Evaluation;
//55
public interface EvaluationMapper extends BaseMapper&lt;Evaluation&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">mappers/evaluation.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.EvaluationMapper&quot;&gt;
&lt;!--55--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/EvaluationService.java
package com.imooc.reader.service;

import com.imooc.reader.entity.Evaluation;

import java.util.List;
//55.再创建一个它的实现类 Alt+回车 com/imooc/reader/service/impl/EvaluationServiceImpl.java
public interface EvaluationService&#123;
    /**
     * 按图书编号查询有效短评
     * @param bookId 图书编号
     * @return 评论列表
     */
    public List&lt;Evaluation&gt; selectByBookId(Long bookId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/EvaluationServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Book;
import com.imooc.reader.entity.Evaluation;
import com.imooc.reader.entity.Member;
import com.imooc.reader.mapper.BookMapper;
import com.imooc.reader.mapper.EvaluationMapper;
import com.imooc.reader.mapper.MemberMapper;
import com.imooc.reader.service.EvaluationService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.List;
//55.按图书编号查询有效短评   56BookController得到对应的图书编号以后 基于service查询对应短评信息
@Service(&quot;evluationService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class EvaluationServiceImpl implements EvaluationService &#123;
    @Resource
    private EvaluationMapper evaluationMapper;
    //59
    @Resource
    private MemberMapper memberMapper;
    @Resource
    private BookMapper bookMapper;
    /**
     * 按图书编号查询有效短评
     * @param bookId 图书编号
     * @return
     */
    @Override
    public List&lt;Evaluation&gt; selectByBookId(Long bookId) &#123;
        Book book = bookMapper.selectById(bookId); //59根据参数查询book对象
        QueryWrapper&lt;Evaluation&gt; queryWrapper = new QueryWrapper&lt;Evaluation&gt;();
        queryWrapper.eq(&quot;book_id&quot;, bookId);
        queryWrapper.eq(&quot;state&quot;,&quot;enable&quot;);
        queryWrapper.orderByDesc(&quot;create_time&quot;);
        List&lt;Evaluation&gt; evaluationList = evaluationMapper.selectList(queryWrapper);
        //59.查询每个评论的信息
        for(Evaluation eva:evaluationList)&#123;
            Member member = memberMapper.selectById(eva.getMemberId());//59获得会员对象要使用接口咯
            eva.setMember(member);
            eva.setBook(book);//59循环的时候为每一个Evaluation设置一个book对象 60回到detail.ftl
        &#125;
        return evaluationList;
    &#125;
&#125;
</code></pre>
<pre><code class="java">detail.ftl
 &lt;div class=&quot;alert alert-primary w-100 mt-2&quot; role=&quot;alert&quot;&gt;短评
        &lt;button type=&quot;button&quot; id=&quot;btnEvaluation&quot; class=&quot;btn btn-success btn-sm text-white float-right&quot;
                style=&quot;margin-top: -3px;&quot;&gt;
            写短评
        &lt;/button&gt;
    &lt;/div&gt;
    &lt;div class=&quot;reply pl-2 pr-2&quot;&gt;
&lt;#--  57.对短评进行动态页面的整合与梳理 进行循环遍历  58注意下面的慕粉-126对应着数据库的会员表 再重来一遍 Evaluation--&gt;
        &lt;#list evaluationList as evaluation&gt;
            &lt;div&gt;
                &lt;div&gt;
                    &lt;span class=&quot;pt-1 small text-black-50 mr-2&quot;&gt;$&#123;evaluation.createTime?string(&#39;MM-dd&#39;)&#125;&lt;/span&gt;
&lt;#--   60.修改 慕粉-126 变为动态的--&gt;
                    &lt;span class=&quot;mr-2 small pt-1&quot;&gt;$&#123;evaluation.member.nickname&#125;&lt;/span&gt;
                    &lt;span class=&quot;stars mr-2&quot; data-score=&quot;$&#123;evaluation.score&#125;&quot;&gt;&lt;/span&gt;

                    &lt;button type=&quot;button&quot; data-evaluation-id=&quot;$&#123;evaluation.evaluationId&#125;&quot;
                            class=&quot;btn btn-success btn-sm text-white float-right&quot; style=&quot;margin-top: -3px;&quot;&gt;
                        &lt;img style=&quot;width: 24px;margin-top: -5px;&quot; class=&quot;mr-1&quot;
                             src=&quot;https://img3.doubanio.com/f/talion/7a0756b3b6e67b59ea88653bc0cfa14f61ff219d/pics/card/ic_like_gray.svg&quot;/&gt;
                        &lt;span&gt;$&#123;evaluation.enjoy&#125;&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;

                &lt;div class=&quot;row mt-2 small mb-3&quot;&gt;
                    $&#123;evaluation.content&#125;
                &lt;/div&gt;
                &lt;hr/&gt;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;
</code></pre>
<h3 id="会员注册与登录"><a href="#会员注册与登录" class="headerlink" title="会员注册与登录"></a>会员注册与登录</h3><h5 id="Kaptcha验证码的配置与使用"><a href="#Kaptcha验证码的配置与使用" class="headerlink" title="Kaptcha验证码的配置与使用"></a>Kaptcha验证码的配置与使用</h5><ul>
<li>Kaptcha 是谷歌开源的可高度配置的使用验证码生成工具</li>
<li>通过 Kaptcha 可阻拦大多数机器人脚本操作</li>
<li>Kaptcha 典型应用于注册、登录、重要信息提交等用户交互</li>
</ul>
<h5 id="Kaptcha-使用步骤"><a href="#Kaptcha-使用步骤" class="headerlink" title="Kaptcha 使用步骤"></a>Kaptcha 使用步骤</h5><ul>
<li>Kaptcha 配置验证码生成参数</li>
<li>开发 KaptchaController 生成验证码图片</li>
<li>将前台输入验证码与session保存的验证码进行比对</li>
</ul>
<pre><code class="xml">pom.xml
&lt;!--   61.增加Kaptcha验证码组件依赖 applicationContext增加一个bean  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;
            &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;
            &lt;version&gt;2.3.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--  61.配置Kaptcha 的bean  62创造KaptchaController.java--&gt;
    &lt;bean id=&quot;KaptchaProducer&quot; class=&quot;com.google.code.kaptcha.impl.DefaultKaptcha&quot;&gt;
        &lt;property name=&quot;config&quot;&gt;
            &lt;bean class=&quot;com.google.code.kaptcha.util.Config&quot;&gt;
                &lt;constructor-arg&gt;
                    &lt;props&gt;
                        &lt;!-- 验证码图片不生成边框 --&gt;
                        &lt;prop key=&quot;kaptcha.border&quot;&gt;no&lt;/prop&gt;
                        &lt;!-- 验证码图片宽度为120像素  --&gt;
                        &lt;prop key=&quot;kaptcha.image.width&quot;&gt;120&lt;/prop&gt;
                        &lt;!-- 验证码图片字体颜色为蓝色  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.color&quot;&gt;blue&lt;/prop&gt;
                        &lt;!-- 每个字符最大占用40像素  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.size&quot;&gt;40&lt;/prop&gt;
                        &lt;!-- 验证码包含4个字符  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.char.length&quot;&gt;4&lt;/prop&gt;
                    &lt;/props&gt;
                &lt;/constructor-arg&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/KaptchaController.java
package com.imooc.reader.controller;

import com.google.code.kaptcha.Producer;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import javax.annotation.Resource;
import javax.imageio.ImageIO;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.image.BufferedImage;
import java.io.IOException;
//62.完成图片的随机生成与控制台的输出相同 63将原型里的 注册页 复制到项目工程register.ftl
@Controller
public class KaptchaController &#123;
    @Resource
    private Producer kaptchaProducer;
//    Ioc动态注入 因为验证码组件设计的时候没有考虑过SpringMVC的集成 要使用原生的请求与响应
    @GetMapping(&quot;/verify_code&quot;)
    public void createVerifyCode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        //响应立即过期
        response.setDateHeader(&quot;Expires&quot;,0);
        //不存储 不缓存任何图片数据
        response.setHeader(&quot;Cache-Control&quot;,&quot;no-store,no-cache,must-revalidate&quot;);
        response.setHeader(&quot;Cache-Control&quot;,&quot;post-check=0,pre-check=0&quot;);
        response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);
        response.setContentType(&quot;image/png&quot;);
        //生成验证码字符文本
        String verifyCode = kaptchaProducer.createText();
        request.getSession().setAttribute(&quot;kaptchaVerifyCode&quot;,verifyCode);
        System.out.println( request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;));
        BufferedImage image = kaptchaProducer.createImage(verifyCode);//创建验证码图片 二进制图片
        //二进制用getOutputStream() 字符用getWritter()
        ServletOutputStream out = response.getOutputStream();
        ImageIO.write(image,&quot;png&quot;,out);//输出图片流
        out.flush(); //立即输出
        out.close(); //关闭输出流

    &#125;
&#125;
</code></pre>
<h3 id="Kaptcha验证码的使用与对比-运用到前端"><a href="#Kaptcha验证码的使用与对比-运用到前端" class="headerlink" title="Kaptcha验证码的使用与对比 [运用到前端]"></a>Kaptcha验证码的使用与对比 [运用到前端]</h3><pre><code class="java">register.ftl
&lt;div class=&quot;col-4 p-0 pl-2 pt-0&quot;&gt;
   &lt;!-- 63.验证码图片 src要显示从服务器后台动态生成的验证码 KaptchaController生成的url粘贴在这里 64弄一个MemberController--&gt;
   &lt;img id=&quot;imgVerifyCode&quot; src=&quot;/verify_code&quot;
   style=&quot;width: 120px;height:50px;cursor: pointer&quot;&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
package com.imooc.reader.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

//64.嵌入验证码 65编写单机验证码刷新register.ftl中的function reloadVerifyCode()
@Controller
public class MemberController &#123;
    @GetMapping(&quot;/register.html&quot;)
    public ModelAndView showRegister() &#123;
        return new ModelAndView(&quot;/register&quot;);
    &#125;
    //67. 验证码匹配比对 request拿到对象  68编写会员服务MemberService.java
    @PostMapping(&quot;/registe&quot;)
    @ResponseBody
    public Map registe(String vc, String username, String password, String nickname, HttpServletRequest request)&#123;
        //接收kaptchaController.java中的request.getSession().setAttribute响应
        //正确验证码
        String verityCode  = (String)request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;);
        //验证码比对  后面的是大小写对比
        Map result = new HashMap();
        if (vc == null || verityCode == null || !vc.equalsIgnoreCase(verityCode))&#123;
            result.put(&quot;code&quot;,&quot;VC01&quot;);
            result.put(&quot;msg&quot;,&quot;验证码错误&quot;);
        &#125;else &#123;
            result.put(&quot;code&quot;,&quot;0&quot;);
            result.put(&quot;msg&quot;,&quot;success&quot;);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<pre><code class="java">register.ftl
&lt;script&gt;
    //控制错误信息的显示与隐藏
    function showTips(isShow, css, text) &#123;
        if (isShow) &#123;
            $(&quot;#tips&quot;).removeClass(&quot;d-none&quot;)
            $(&quot;#tips&quot;).hide();
            $(&quot;#tips&quot;).addClass(css);
            $(&quot;#tips&quot;).text(text);
            $(&quot;#tips&quot;).fadeIn(200);
        &#125; else &#123;
            $(&quot;#tips&quot;).text(&quot;&quot;);
            $(&quot;#tips&quot;).fadeOut(200);
            $(&quot;#tips&quot;).removeClass();
            $(&quot;#tips&quot;).addClass(&quot;alert&quot;)
        &#125;
    &#125;
    //65.重新发送请求,刷新验证码 66验证码与后台绑定[比对校验]
    function reloadVerifyCode()&#123;
        //请在这里实现刷新验证码 ts timestamp是时间戳 增加时间戳取消缓存
        $(&quot;#imgVerifyCode&quot;).attr(&quot;src&quot;,&quot;/verify_code?ts=&quot; + new Date().getTime())
    &#125;
    
    //点击验证码图片刷新验证码
    $(&quot;#imgVerifyCode&quot;).click(function () &#123;
        reloadVerifyCode();
    &#125;);
    
    // 66.点击提交按钮,向/registe发起ajax请求
    //提交请求包含四个参数
    //vc:前台输入验证码  username:用户名 password:密码 nickname:昵称
    $(&quot;#btnSubmit&quot;).click(function () &#123;
        //表单校验
        var username = $.trim($(&quot;#username&quot;).val());
        var regex = /^.&#123;6,10&#125;$/;
        if (!regex.test(username)) &#123;
            showTips(true, &quot;alert-danger&quot;, &quot;用户名请输入正确格式（6-10位）&quot;);
            return;
        &#125; else &#123;
            showTips(false);
        &#125;

        var password = $.trim($(&quot;#password&quot;).val());

        if (!regex.test(password)) &#123;
            showTips(true, &quot;alert-danger&quot;, &quot;密码请输入正确格式（6-10位）&quot;);
            return;
        &#125; else &#123;
            showTips(false);
        &#125;

        $btnReg = $(this);

        $btnReg.text(&quot;正在处理...&quot;);
        $btnReg.attr(&quot;disabled&quot;, &quot;disabled&quot;);
        
        //66.发送ajax请求 67编写MemberController.java实现url
        $.ajax(&#123;
            url: &quot;/registe&quot;,
            type: &quot;post&quot;,
            dataType: &quot;json&quot;,
            data: $(&quot;#frmLogin&quot;).serialize(),
            success: function (data) &#123;
                //结果处理,根据服务器返回code判断服务器处理状态
                //服务器要求返回JSON格式:
                //&#123;&quot;code&quot;:&quot;0&quot;,&quot;msg&quot;:&quot;处理消息&quot;&#125;
                console.info(&quot;服务器响应:&quot; , data);
                if (data.code == &quot;0&quot;) &#123;
                    //显示注册成功对话框
                    $(&quot;#exampleModalCenter&quot;).modal(&#123;&#125;);
                    $(&quot;#exampleModalCenter&quot;).modal(&quot;show&quot;);
                &#125; else &#123;
                    //服务器校验异常,提示错误信息
                    showTips(true, &quot;alert-danger&quot;, data.msg);
                    reloadVerifyCode();
                    $btnReg.text(&quot;注    册&quot;);
                    $btnReg.removeAttr(&quot;disabled&quot;);
                &#125;
            &#125;
        &#125;);
        return false;
    &#125;);
&lt;/script&gt;
============================
67在上面MemberController.java
</code></pre>
<h3 id="实现会员注册功能"><a href="#实现会员注册功能" class="headerlink" title="实现会员注册功能"></a>实现会员注册功能</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mask_boys/article/details/118273990">500 (Internal Server Error)_谷歌浏览器 internal server error-CSDN博客</a></p>
<pre><code class="java">com/imooc/reader/service/MemberService.java
package com.imooc.reader.service;

import com.imooc.reader.entity.Member;
//68.创建一个实现类MemberServiceImpl.java[Alt + Enter]
public interface MemberService &#123;
    /**
     * 会员注册,创建新会员
     * @param username
     * @param password
     * @param nickname
     * @return
     */
    public Member createMember(String username, String password, String nickname);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/exception.java
package com.imooc.reader.service.exception;

/**
 * 68.业务逻辑异常 回到MemberServiceImpl编写用户名异常 69返回MemberServiceImpl
 */
public class BussinessException extends RuntimeException&#123;
    private String code;
    private String msg;

    //构造方法
    public BussinessException(String code, String msg) &#123;
        super(msg); //继承自运行时异常
        this.code = code;
        this.msg = msg;
    &#125;

    public String getCode() &#123;
        return code;
    &#125;

    public void setCode(String code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/utils/MD5Utils.java
package com.imooc.reader.utils;

import org.apache.commons.codec.digest.DigestUtils;
//70.生成MD5方法 返回MemberServiceImpl编写随机数
public class MD5Utils &#123;
    public static String md5Digest(String source, Integer salt)&#123;
        char[] ca = source.toCharArray();//获取字符数组
        for (int i = 0; i &lt; ca.length; i++) &#123;
            ca[i] = (char) (ca[i] + salt);
        &#125;
        String target = new String(ca);
        String md5 = DigestUtils.md5Hex(target);
        return md5;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Member;
import com.imooc.reader.mapper.MemberMapper;
import com.imooc.reader.service.exception.BussinessException;
import com.imooc.reader.service.MemberService;
import com.imooc.reader.utils.MD5Utils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
import java.util.List;
import java.util.Random;

//68.完成与会员的交互[写操作居多] 完成运行异常service/BussinessException.java
@Service(&quot;memberService&quot;)
@Transactional
public class MemberServiceImpl implements MemberService &#123;
    @Resource
    private MemberMapper memberMapper;

    /**
     * 会员注册,创建新会员
     *
     * @param username 用户名
     * @param password 密码
     * @param nickname 昵称
     * @return 新会员对象
     */
    public Member createMember(String username, String password, String nickname) &#123;
        QueryWrapper&lt;Member&gt; queryWrapper = new QueryWrapper&lt;Member&gt;();
        queryWrapper.eq(&quot;username&quot;, username);
        List&lt;Member&gt; memberList = memberMapper.selectList(queryWrapper);
        //判断用户名是否已存在 68定义一个异常BussinessException.java
        //69.续写异常  70增加加密组件pom.xml
        if (memberList.size() &gt; 0) &#123;
            throw new BussinessException(&quot;M01&quot;, &quot;用户名已存在&quot;);
        &#125;
        Member member = new Member();
        member.setUsername(username);
        member.setNickname(nickname);
        //70. 随机数md5  71生成测试用例MemberServiceImplTest
        int salt = new Random().nextInt(1000)+1000; //盐值
        String md5 = MD5Utils.md5Digest(password, salt);
        member.setPassword(md5);
        member.setSalt(salt);
        member.setCreateTime(new Date()); //创建时间
        memberMapper.insert(member);
        return member;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImplTest.java
package com.imooc.reader.service.impl;

import com.imooc.reader.service.MemberService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

//71.生成测试用例 72MemberController后续的工作
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class MemberServiceImplTest &#123;
    @Resource
    private MemberService memberService;
    @Test
    public void createMember() &#123;
        memberService.createMember(&quot;s123457&quot;, &quot;123456&quot;, &quot;测试&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
package com.imooc.reader.controller;

import com.imooc.reader.service.exception.BussinessException;
import com.imooc.reader.service.MemberService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

//64.嵌入验证码 65编写单机验证码刷新register.ftl中的function reloadVerifyCode()
@Controller
public class MemberController &#123;
    //72后续工作 进行注入
    @Resource
    private MemberService memberService;

    @GetMapping(&quot;/register.html&quot;)
    public ModelAndView showRegister() &#123;
        return new ModelAndView(&quot;/register&quot;);
    &#125;

    //67. 验证码匹配比对 request拿到对象  68编写会员服务MemberService.java
    @PostMapping(&quot;/registe&quot;)
    @ResponseBody
    public Map registe(String vc, String username, String password, String nickname, HttpServletRequest request) &#123;
        //接收kaptchaController.java中的request.getSession().setAttribute响应
        //正确验证码
        String verityCode = (String) request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;);
        //验证码比对  后面的是大小写对比
        Map result = new HashMap();
        if (vc == null || verityCode == null || !vc.equalsIgnoreCase(verityCode)) &#123;
            result.put(&quot;code&quot;, &quot;VC01&quot;);
            result.put(&quot;msg&quot;, &quot;验证码错误&quot;);
        &#125; else &#123;
            //72.调用过程  73将登录页复制进去 74MemberServiceImpl
            try &#123;
                memberService.createMember(username, password, nickname);
                result.put(&quot;code&quot;, &quot;0&quot;);
                result.put(&quot;msg&quot;, &quot;success&quot;);
            &#125; catch (BussinessException ex) &#123;
                ex.printStackTrace();
                result.put(&quot;code&quot;, ex.getCode());
                result.put(&quot;msg&quot;, ex.getMsg());
            &#125;
        &#125;
        return result;
    &#125;
&#125;
http://localhost/register.html
</code></pre>
<h3 id="实现会员登录功能"><a href="#实现会员登录功能" class="headerlink" title="实现会员登录功能"></a>实现会员登录功能</h3><pre><code class="java"> com/imooc/reader/service/impl/MemberServiceImpl.java
 /**
     * 登陆检查
     * @param username 用户名
     * @param password 密码
     * @return 登录对象
     */
    //74.登录方法的接口实现 校验密码 75再续方法 MemberController.java
    public Member checkLogin(String username, String password) &#123;
        QueryWrapper&lt;Member&gt; queryWrapper = new QueryWrapper&lt;Member&gt;();
        queryWrapper.eq(&quot;username&quot;, username);
        Member member = memberMapper.selectOne(queryWrapper);
        if (member == null)&#123;
            throw new BussinessException(&quot;M02&quot;, &quot;用户不存在&quot;);
        &#125;//校验密码
        String md5 = MD5Utils.md5Digest(password, member.getSalt());
        if (!md5.equals(member.getPassword()))&#123;
            throw new BussinessException(&quot;M03&quot;, &quot;输入密码有误&quot;);
        &#125;
        return member;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
// 75.HttpSession session 登录校验后会将这个会员信息存放到session中
    // 76登录校验成功以后会返回一个member对象 存放在session中
    @PostMapping(&quot;/check_login&quot;) //前台url
    @ResponseBody
    public Map checkLogin(String username, String password, String vc, HttpSession session)&#123;
        //正确验证码                     ↓为了得到session对象
        String verityCode = (String)session.getAttribute(&quot;kaptchaVerifyCode&quot;);
        //验证码比对  后面的是大小写对比
        Map result = new HashMap();
        if (vc == null || verityCode == null || !vc.equalsIgnoreCase(verityCode)) &#123;
            result.put(&quot;code&quot;, &quot;VC01&quot;);
            result.put(&quot;msg&quot;, &quot;验证码错误&quot;);
        &#125;else &#123;
            try &#123;//处理成功
                Member member = memberService.checkLogin(username, password);
                //76.member存放在session中  77去index.ftl下方登录块改造
                session.setAttribute(&quot;loginMember&quot;,member);
                result.put(&quot;code&quot;, &quot;0&quot;);
                result.put(&quot;msg&quot;, &quot;success&quot;);
            &#125; catch (BussinessException ex) &#123; //处理失败
                ex.printStackTrace();
                result.put(&quot;code&quot;, ex.getCode());
                result.put(&quot;msg&quot;, ex.getMsg());
            &#125;
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">index.ftl 
&lt;#--   77.将获取到的member的session数据替换成登录右上角的动态数据--&gt;
  &lt;#--  两个问号代表前面的属性是存在的情况下输出其中的html --&gt;
&lt;#-- 78新增entity/MemberReadState.java会员阅读状态 --&gt;
        &lt;#if loginMember??&gt;
            &lt;h6 class=&quot;mt-1&quot;&gt;
                &lt;img style=&quot;width: 2rem;margin-top: -5px&quot; class=&quot;mr-1&quot; src=&quot;./images/user_icon.png&quot;&gt;$&#123;loginMember.nickname&#125;
            &lt;/h6&gt;
            &lt;#else&gt; &lt;#--上面是已登录 下面是未登录--&gt;
                &lt;a href=&quot;/login.html&quot; class=&quot;btn btn-light btn-sm&quot;&gt;
                    &lt;img style=&quot;width: 2rem;margin-top: -5px&quot; class=&quot;mr-1&quot; src=&quot;./images/user_icon.png&quot;&gt;登录
                &lt;/a&gt;
        &lt;/#if&gt;
</code></pre>
<h3 id="获取会员阅读状态"><a href="#获取会员阅读状态" class="headerlink" title="获取会员阅读状态"></a>获取会员阅读状态</h3><h5 id="实现会员交互功能"><a href="#实现会员交互功能" class="headerlink" title="实现会员交互功能"></a>实现会员交互功能</h5><ul>
<li>想看&#x2F;看过的阅读状态变更</li>
<li>为图书写短评</li>
<li>为喜欢的短评点赞</li>
</ul>
<pre><code class="java">com/imooc/reader/entity/MemberReadState.java
package com.imooc.reader.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;

import java.util.Date;

/**
 * 会员阅读状态实体
 */
//78.搞实体 再去创MemberReadStateMapper.java接口
public class MemberReadState &#123;
    @TableId(type = IdType.AUTO)
    private Long rsId;
    private Long bookId;
    private Long memberId;
    private Integer readState;
    private Date createTime;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/MemberReadStateMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.MemberReadState;

//78接口创完 再去搞个Member_Read_State.xml
public interface MemberReadStateMapper extends BaseMapper&lt;MemberReadState&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">mappers/member_read_state.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.MemberReadStateMapper&quot;&gt;
&lt;!--  78. 去MemberService 阅读状态--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/MemberService.java 
//78.获取阅读状态 再去实现这个方法

    /**
     * 获取阅读状态
     *
     * @param memberId 会员编号
     * @param bookId   图书编号
     * @return 阅读状态对象
     */
    public MemberReadState selectMemberReadState(Long memberId, Long bookId);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
 //78.新增方法实现那个方法 再去上方进行方法注入 79根据会员编号进行查询BookController

    /**
     * 获取阅读状态
     * @param memberId 会员编号
     * @param bookId 图书编号
     * @return 阅读状态对象
     */
    public MemberReadState selectMemberReadState(Long memberId, Long bookId)&#123;
        QueryWrapper&lt;MemberReadState&gt; queryWrapper = new QueryWrapper();
        queryWrapper.eq(&quot;book_id&quot;, bookId);
        queryWrapper.eq(&quot;member_id&quot;, memberId);
        MemberReadState memberReadState = memberReadStateMapper.selectOne(queryWrapper);
        return memberReadState;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
//51.进行页面的绑定 获取读书编号 52把所有ftl相对路径改成绝对路径 ./前面的.删掉
    //加上了./就是  localhost/book/......   删掉就是 localhost/......
    //52更改detail.ftl将静态页面改成动态页面
    @GetMapping(&quot;/book/&#123;id&#125;&quot;) //↓ 路径变量 和 上面的保持一致
    //79.新增一个参数 获取当前用户登录信息
    public ModelAndView showDetail(@PathVariable(&quot;id&quot;) Long id, HttpSession session) &#123;
        Book book = bookService.selectById(id);
        //56.写完并放入 mav.addObject 57得到了对象就要去detail.ftl渲染循环遍历[写短评下方的div]
        List&lt;Evaluation&gt; evaluationList = evaluationService.selectByBookId(id);
        //79.将之前设置的用户信息拿出来 两种情况 ①会员没登录就null ②会员登录了member对象存在了 注入memberService
        Member member = (Member)session.getAttribute(&quot;loginMember&quot;);
        ModelAndView mav = new ModelAndView(&quot;/detail&quot;);
        if (member != null) &#123; //获取会员阅读状态    会员编号 图书编号  80 detail.ftl想看[1]与看过[2] 页面上方找script块
            MemberReadState memberReadState = memberService.selectMemberReadState(member.getMemberId(), id);
            mav.addObject(&quot;memberReadState&quot;, memberReadState);

        &#125;
        mav.addObject(&quot;book&quot;, book);
        mav.addObject(&quot;evaluationList&quot;, evaluationList);
        return mav;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
 &lt;script&gt;
        $.fn.raty.defaults.path = &#39;/resources/raty/lib/images&#39;;
        $(function () &#123;
            $(&quot;.stars&quot;).raty(&#123;readOnly: true&#125;);
        &#125;)
       // 80 想看与看过 freemark脚本 如果它存在(想看/看过) 81产生对应的状态数据 MemberService
        $(function () &#123;
            &lt;#if memberReadState ??&gt;
            // 重选阅读状态回填
            $(&quot;*[data-read-state=&#39;$&#123;memberReadState.readState&#125;&#39;]&quot;).addClass(&quot;highlight&quot;);
            &lt;/#if&gt;
            &lt;#if !loginMember ??&gt;
                $(&quot;*[data-read-state]&quot;).click(function () &#123;
                    // 利用jquery选择div的对话框函数 显示需要登录
                    $(&quot;#exampleModalCenter&quot;).modal(&quot;show&quot;);
                &#125;)
            &lt;/#if&gt;
        &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="更新会员阅读状态"><a href="#更新会员阅读状态" class="headerlink" title="更新会员阅读状态"></a>更新会员阅读状态</h3><pre><code class="java">com/imooc/reader/service/MemberService.java
 /**
     * 更新阅读状态
     * @param memberId 会员编号
     * @param bookId 图书编号
     * @param readState 阅读状态
     * @return 阅读对象状态
     */         //81定义方法 MemberServiceImpl实现状态
    public MemberReadState updateMemberReadState(Long memberId, Long bookId, Integer readState);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
/**
 * 更新阅读状态
 * @param memberId 会员编号
 * @param bookId 图书编号
 * @param readState 阅读状态
 * @return 阅读对象状态
 */
//81.编写阅读状态代码 编写完打开MemberController
public MemberReadState updateMemberReadState(Long memberId, Long bookId, Integer readState)&#123;
    QueryWrapper&lt;MemberReadState&gt; queryWrapper = new QueryWrapper&lt;MemberReadState&gt;();
    queryWrapper.eq(&quot;book_id&quot;, bookId);
    queryWrapper.eq(&quot;member_id&quot;, memberId);
    MemberReadState memberReadState = memberReadStateMapper.selectOne(queryWrapper);
    //空的代表没有点过按钮 数据是空的
        //无则新增,有则更新
        if(memberReadState == null)&#123;
            memberReadState = new MemberReadState();
            memberReadState.setMemberId(memberId);
            memberReadState.setBookId(bookId);
            memberReadState.setReadState(readState);
            memberReadState.setCreateTime(new Date());
            memberReadStateMapper.insert(memberReadState);
        &#125;else&#123;
            memberReadState.setReadState(readState);
            memberReadStateMapper.updateById(memberReadState);
        &#125;

        return memberReadState;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
//81. 完成更新状态的事务  82去完成detail.ftl后面的loginMember存在的代码
    @PostMapping(&quot;/update_read_state&quot;)
    @ResponseBody
    public Map updateReadState(Long memberId, Long bookId, Integer readState)&#123;
        Map result = new HashMap();
        try &#123;
            memberService.updateMemberReadState(memberId, bookId, readState);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
//82 完成登录状态
            &lt;#if loginMember ??&gt;
            /**
             * 更新会员阅读状态
             */
            $(&quot;*[data-read-state]&quot;).click(function () &#123;
                //会员阅读状态
                var readState = $(this).data(&quot;read-state&quot;);
                //发送请求
                $.post(&quot;/update_read_state&quot;, &#123;
                    memberId: $&#123;loginMember.memberId&#125;,
                    bookId: $&#123;book.bookId&#125;,
                    readState: readState
                &#125;, function (json) &#123;
                    if (json.code == &quot;0&quot;) &#123; //服务器处理成功
                        $(&quot;*[data-read-state]&quot;).removeClass(&quot;highlight&quot;);//高亮的清除
                        $(&quot;*[data-read-state=&#39;&quot; + readState + &quot;&#39;]&quot;).addClass(&quot;highlight&quot;);//状态值放入其中
                    &#125;
                &#125;, &quot;json&quot;)
            &#125;);
            &lt;/#if&gt;
</code></pre>
<h3 id="实现写短评功能"><a href="#实现写短评功能" class="headerlink" title="实现写短评功能"></a>实现写短评功能</h3><pre><code class="java">detail.ftl
 //83.短评功能  下面短评联动现象
            $(&quot;#btnEvaluation&quot;).click(function () &#123;
                // 选中id＝score的标签 转换为星型组件
                $(&quot;#score&quot;).raty(&#123;&#125;);
                $(&quot;#dlgEvaluation&quot;).modal(&quot;show&quot;);//显示短评对话框
            &#125;)
---------------------------------------------------------------
&lt;!-- Modal --&gt;
&lt;div class=&quot;modal-content&quot;&gt;
            &lt;div class=&quot;modal-body&quot;&gt;
&lt;#-- 83. 短评联动   84 MemberService.java 短评实现代码 --&gt;
                &lt;h6&gt;为$&#123;book.bookName&#125;写短评&lt;/h6&gt;
                &lt;form id=&quot;frmEvaluation&quot;&gt;
                    &lt;div class=&quot;input-group  mt-2 &quot;&gt;
                        &lt;span id=&quot;score&quot;&gt;&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;input-group  mt-2 &quot;&gt;
                        &lt;input type=&quot;text&quot; id=&quot;content&quot; name=&quot;content&quot; class=&quot;form-control p-4&quot;
                               placeholder=&quot;这里输入短评&quot;&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;
            &lt;div class=&quot;modal-footer&quot;&gt;
                &lt;button type=&quot;button&quot; id=&quot;btnSubmit&quot; class=&quot;btn btn-primary&quot;&gt;提交&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/MemberService.java
//84.短评代码!  MemberServiceImpl 组一个全新的对象
    public Evaluation evaluate(Long memberId, Long bookId, Integer score, String content);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
/**
     * 发布新的短评
     * @param memberId 会员编号
     * @param bookId 图书编号
     * @param score 评分
     * @param content 短评内容
     * @return
     */ // 84 完成评论信息的更新 85在MemberController编写与web交互功能
    public Evaluation evaluate(Long memberId, Long bookId, Integer score, String content) &#123;
        Evaluation evaluation = new Evaluation();
        evaluation.setMemberId(memberId);
        evaluation.setBookId(bookId);
        evaluation.setScore(score);
        evaluation.setContent(content);
        evaluation.setCreateTime(new Date());
        evaluation.setState(&quot;enable&quot;);
        evaluation.setEnjoy(0); //注入evaluationMapper 完成数据新增
        evaluationMapper.insert(evaluation);
        return evaluation;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
//85.与web交互功能 前台请求传入数据 86回到detail.ftl写
    @PostMapping(&quot;/evaluate&quot;)
    @ResponseBody
    public Map evaluate(Long memberId, Long bookId, Integer score, String content)&#123;
        Map result = new HashMap();
        try &#123;
//    Evaluation eva = memberService.evaluate(memberId, bookId, score, content);
            memberService.evaluate(memberId, bookId, score, content);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
//          result.put(&quot;evaluation&quot;, eva);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
//86.评论对话框提交数据  87完成点赞核心实现 MemberService
            $(&quot;#btnSubmit&quot;).click(function () &#123;
                var score = $(&quot;#score&quot;).raty(&quot;score&quot;);//获取评分
                var content = $(&quot;#content&quot;).val();
                if (score == 0 || $.trim(content) == &quot;&quot;)&#123; //没有进行选择 或 删除前后空格
                    return; //禁止提交方法中断
                &#125;
                $.post(&quot;/evaluate&quot;,&#123;
                    score : score,
                    bookId: $&#123;book.bookId&#125;,
                    memberId: $&#123;loginMember.memberId&#125;,
                    content: content
                &#125;,function (json) &#123;
                    if (json.code == &quot;0&quot;) &#123;//处理成功
                        window.location.reload();//列表进行刷新
                    &#125;
                &#125;,&quot;json&quot;)
            &#125;)
</code></pre>
<h3 id="完成会员短评点赞核心实现"><a href="#完成会员短评点赞核心实现" class="headerlink" title="完成会员短评点赞核心实现"></a>完成会员短评点赞核心实现</h3><pre><code class="java">com/imooc/reader/service/MemberService.java
 /**
     * 短评点赞
     * @param evaluationId 短评编号
     * @return 短评对象
     */
//    87完成点赞核心实现 MemberServiceImpl
    public Evaluation enjoy(Long evaluationId);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
// 87.短评点赞 自增+1 Membercontroller
    public Evaluation enjoy(Long evaluationId) &#123;
        Evaluation evaluation = evaluationMapper.selectById(evaluationId);
        evaluation.setEnjoy(evaluation.getEnjoy()+1);
        evaluationMapper.updateById(evaluation);
        return evaluation;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
 //87.实现controller 88让客户端页面发送ajax请求
    @PostMapping(&quot;/enjoy&quot;)
    @ResponseBody
    public Map evaluate(Long evaluationId) &#123;
        Map result = new HashMap();
        try &#123;
//    Evaluation eva = memberService.evaluate(memberId, bookId, score, content);
            Evaluation eva = memberService.enjoy(evaluationId);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
            result.put(&quot;evaluation&quot;, eva); //包含最新点赞数
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
// 88.评论点赞
            $(&quot;*[data-evaluation-id]&quot;).click(function()&#123;
                var evaluationId = $(this).data(&quot;evaluation-id&quot;);
                $.post(&quot;/enjoy&quot;,&#123;evaluationId:evaluationId&#125;,function(json)&#123;
                    if(json.code == &quot;0&quot;)&#123;
                        $(&quot;*[data-evaluation-id=&#39;&quot; + evaluationId + &quot;&#39;] span&quot;).text(json.evaluation.enjoy);
                    &#125;
                &#125;,&quot;json&quot;)
            &#125;)
</code></pre>
<h3 id="Spring-Task定时任务-eg-闹钟命令"><a href="#Spring-Task定时任务-eg-闹钟命令" class="headerlink" title="Spring Task定时任务 [eg:  闹钟命令]"></a>Spring Task定时任务 [eg:  闹钟命令]</h3><ul>
<li>Spting Task 是 Spring 3.0后推出的定时任务模块</li>
<li>Spring Task的职责是按周期后台自动执行任务</li>
<li>Spring Task可利用Cron表达式实现灵活的定时处理</li>
</ul>
<h5 id="Cron表达式实例"><a href="#Cron表达式实例" class="headerlink" title="Cron表达式实例"></a>Cron表达式实例</h5><table>
<thead>
<tr>
<th align="center">秒</th>
<th align="center">分</th>
<th align="center">小时</th>
<th align="center">日</th>
<th align="center">月</th>
<th align="center">星期</th>
<th align="center">年</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">0,30</td>
<td align="center">0-5</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">?</td>
<td align="center">2000</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">9-18</td>
<td align="center">?</td>
<td align="center">*</td>
<td align="center">WED</td>
<td align="center"></td>
</tr>
</tbody></table>
<h5 id="利用Spring-Task自动计算图书评分-所有图书评价信息重算"><a href="#利用Spring-Task自动计算图书评分-所有图书评价信息重算" class="headerlink" title="利用Spring-Task自动计算图书评分 [所有图书评价信息重算]"></a>利用Spring-Task自动计算图书评分 [所有图书评价信息重算]</h5><pre><code class="java">mappers/book.xml
&lt;!--    89.增加平均评分增加信息  增加接口BookMapper --&gt;
    &lt;update id=&quot;updateEvaluation&quot;&gt;
        update book b SET evaluation_score = (
            select ifnull(avg(score),0) from evaluation where book_id = b.book_id and state=&#39;enable&#39;
        ),evaluation_quantity = (
            select ifnull(count(*),0) from evaluation where book_id = b.book_id and state=&#39;enable&#39;
        )
    &lt;/update&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/BookMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Book;
//33.创建完Book接口  34与之对应的创建book.xml文件
//89. 更新图书评分  BookService去定义
public interface BookMapper extends BaseMapper&lt;Book&gt; &#123;
    /**
     * 更新图书评分/评价数量
     */
    public void updateEvaluation();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
 /**
     * 更新图书评分/评价数量
     */
    //89. 定义完去impl定义实现类
    public void updateEvaluation();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
/**
     * 更新图书评分/评价数量  Controller直接面向Service Service面向Mapper
     */
    //89. 更新操作需要声明式事务 开启  90applicationContext.xml开启task
    @Transactional
    public void updateEvaluation() &#123;
        bookMapper.updateEvaluation();
    &#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;!--  61.配置Kaptcha 的bean  62创造KaptchaController.java--&gt;
    &lt;bean id=&quot;KaptchaProducer&quot; class=&quot;com.google.code.kaptcha.impl.DefaultKaptcha&quot;&gt;
        &lt;property name=&quot;config&quot;&gt;
            &lt;bean class=&quot;com.google.code.kaptcha.util.Config&quot;&gt;
                &lt;constructor-arg&gt;
                    &lt;props&gt;
                        &lt;!-- 验证码图片不生成边框 --&gt;
                        &lt;prop key=&quot;kaptcha.border&quot;&gt;no&lt;/prop&gt;
                        &lt;!-- 验证码图片宽度为120像素  --&gt;
                        &lt;prop key=&quot;kaptcha.image.width&quot;&gt;120&lt;/prop&gt;
                        &lt;!-- 验证码图片字体颜色为蓝色  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.color&quot;&gt;blue&lt;/prop&gt;
                        &lt;!-- 每个字符最大占用40像素  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.size&quot;&gt;40&lt;/prop&gt;
                        &lt;!-- 验证码包含4个字符  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.char.length&quot;&gt;4&lt;/prop&gt;
                    &lt;/props&gt;
                &lt;/constructor-arg&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 90.开启Spring Task定时任务的注解模式 创建一个reader/task/ComputeTask.java--&gt;
    &lt;task:annotation-driven/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/task/ComputeTask.java
package com.imooc.reader.task;

import com.imooc.reader.service.BookService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

//90.组件注解 不确定是哪个类 但是会被扫描实例化和管理
@Component
public class ComputeTask &#123;
    @Resource
    private BookService bookService;
//  每分钟0秒时候 执行一次Cron表达式
    @Scheduled(cron = &quot;0 * * * * ?&quot;)
    public void updateEvaluation()&#123;
        bookService.updateEvaluation();
        System.out.println(&quot;已更新所有图书评分&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="后台管理功能-图书管理"><a href="#后台管理功能-图书管理" class="headerlink" title="后台管理功能-图书管理"></a>后台管理功能-图书管理</h3><h5 id="富文本编辑器wangEditor使用入门"><a href="#富文本编辑器wangEditor使用入门" class="headerlink" title="富文本编辑器wangEditor使用入门"></a>富文本编辑器<code>wangEditor</code>使用入门</h5><ul>
<li>基于Javascript与css开发的Web富文本编辑器</li>
</ul>
<pre><code class="java">test.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!-- 91.引入wangEditor  创建WEB-INF/ftl/management/book.ftl--&gt;
    &lt;script src=&quot;/resources/wangEditor.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
    &lt;button id=&quot;btnRead&quot;&gt;读取内容&lt;/button&gt;
    &lt;button id=&quot;btnWrite&quot;&gt;写入内容&lt;/button&gt;
&lt;/div&gt;
&lt;div id=&quot;divEditor&quot; style=&quot;width: 800px;height:600px&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var E = window.wangEditor;
    var editor = new E(&quot;#divEditor&quot;);//完成富文本编辑器初始化
    editor.create();//创建富文本编辑器,显示在页面上
    document.getElementById(&quot;btnRead&quot;).onclick = function()&#123;
        var content = editor.txt.html();//获取编辑器现有的html内容
        alert(content);
    &#125;
    document.getElementById(&quot;btnWrite&quot;).onclick = function()&#123;
        var content = &quot;&lt;li style=&#39;color:red&#39;&gt;我是&lt;b&gt;新内容&lt;/b&gt;&lt;/li&gt;&quot;;
        editor.txt.html(content);
    &#125;
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="实现图书管理功能"><a href="#实现图书管理功能" class="headerlink" title="实现图书管理功能"></a>实现图书管理功能</h3><h6 id="在训练素材中导入图书管理页"><a href="#在训练素材中导入图书管理页" class="headerlink" title="在训练素材中导入图书管理页"></a>在训练素材中导入图书管理页</h6><pre><code class="java">book.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;#-- 91.创建后台图书管理控制器com/imooc/reader/controller/management/MBookController.java   --&gt;
    &lt;title&gt;图书管理功能&lt;/title&gt;
    &lt;style&gt;
        #dlgBook&#123;
            padding: 10px
        &#125;
    &lt;/style&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;

    &lt;script src=&quot;/resources/wangEditor.min.js&quot;&gt;&lt;/script&gt;


    &lt;script type=&quot;text/html&quot; id=&quot;toolbar&quot;&gt;
        &lt;div class=&quot;layui-btn-container&quot;&gt;
            &lt;button class=&quot;layui-btn layui-btn-sm&quot; id=&quot;btnAdd&quot; onclick=&quot;showCreate()&quot;&gt;添加&lt;/button&gt;
        &lt;/div&gt;
    &lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;


&lt;div class=&quot;layui-container&quot;&gt;
    &lt;blockquote class=&quot;layui-elem-quote&quot;&gt;图书列表&lt;/blockquote&gt;
    &lt;!-- 数据表格 --&gt;
    &lt;table id=&quot;grdBook&quot; lay-filter=&quot;grdBook&quot;&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;!--表单内容--&gt;
&lt;div id=&quot;dialog&quot; style=&quot;padding: 10px;display: none&quot;&gt;
    &lt;form class=&quot;layui-form&quot; &gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 图书类别 --&gt;
            &lt;select id=&quot;categoryId&quot; name=&quot;categoryId&quot; lay-verify=&quot;required&quot; lay-filter=
            &quot;categoryId&quot;&gt;
                &lt;option value=&quot;&quot;&gt;&lt;/option&gt;
                &lt;option value=&quot;1&quot;&gt;前端&lt;/option&gt;
                &lt;option value=&quot;2&quot;&gt;后端&lt;/option&gt;
                &lt;option value=&quot;3&quot;&gt;测试&lt;/option&gt;
                &lt;option value=&quot;4&quot;&gt;产品&lt;/option&gt;
            &lt;/select&gt;

        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 书名 --&gt;
            &lt;input type=&quot;text&quot; id=&quot;bookName&quot; name=&quot;bookName&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入书名&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;


        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 子标题 --&gt;
            &lt;input type=&quot;text&quot; id=&quot;subTitle&quot; name=&quot;subTitle&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入子标题&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;

        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 作者 --&gt;
            &lt;input type=&quot;text&quot; id=&quot;author&quot; name=&quot;author&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入作者信息&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;

        &lt;div style=&quot;margin-top: 30px;font-size: 130%&quot;&gt;图书介绍(默认第一图将作为图书封面)&lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot; &gt;
            &lt;!-- wangEditor编辑器 --&gt;
            &lt;div id=&quot;editor&quot; style=&quot;width: 100%&quot;&gt;

            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 图书编号 --&gt;
        &lt;input id=&quot;bookId&quot; type=&quot;hidden&quot;&gt;
        &lt;!-- 当前表单操作类型,create代表新增 update代表修改 --&gt;
        &lt;input id=&quot;optype&quot;  type=&quot;hidden&quot;&gt;
        &lt;div class=&quot;layui-form-item&quot; style=&quot;text-align: center&quot;&gt;
            &lt;!-- 提交按钮 --&gt;
            &lt;button class=&quot;layui-btn&quot; lay-submit=&quot;&quot; lay-filter=&quot;btnSubmit&quot;&gt;立即提交&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;

    var table = layui.table; //table数据表格对象
    var $ = layui.$; //jQuery
    var editor = null; //wangEditor富文本编辑器对象
    //初始化图书列表
    table.render(&#123;
        elem: &#39;#grdBook&#39;  //指定div
        , id : &quot;bookList&quot; //数据表格id
        , toolbar: &quot;#toolbar&quot; //指定工具栏,包含新增添加
        , url: &quot;/management/book/list&quot; //数据接口
        , page: true //开启分页
        , cols: [[ //表头
            &#123;field: &#39;bookName&#39;, title: &#39;书名&#39;, width: &#39;300&#39;&#125;
            , &#123;field: &#39;subTitle&#39;, title: &#39;子标题&#39;, width: &#39;200&#39;&#125;
            , &#123;field: &#39;author&#39;, title: &#39;作者&#39;, width: &#39;200&#39;&#125;
            , &#123;type: &#39;space&#39;, title: &#39;操作&#39;, width: &#39;200&#39; , templet : function(d)&#123;
                    //为每一行表格数据生成&quot;修改&quot;与&quot;删除&quot;按钮,并附加data-id属性代表图书编号
                    return &quot;&lt;button class=&#39;layui-btn layui-btn-sm btn-update&#39;  data-id=&#39;&quot; + d.bookId + &quot;&#39; data-type=&#39;update&#39; onclick=&#39;showUpdate(this)&#39;&gt;修改&lt;/button&gt;&quot; +
                        &quot;&lt;button class=&#39;layui-btn layui-btn-sm btn-delete&#39;  data-id=&#39;&quot; + d.bookId + &quot;&#39;   onclick=&#39;showDelete(this)&#39;&gt;删除&lt;/button&gt;&quot;;
                &#125;
            &#125;
        ]]
    &#125;);
    //显示更新图书对话框
    //obj对应点击的&quot;修改&quot;按钮对象
    function showUpdate(obj)&#123;
        //弹出&quot;编辑图书&quot;对话框
        layui.layer.open(&#123;
            id: &quot;dlgBook&quot;, //指定div
            title: &quot;编辑图书&quot;, //标题
            type: 1, 
            content: $(&#39;#dialog&#39;).html(), //设置对话框内容,复制自dialog DIV
            area: [&#39;820px&#39;, &#39;730px&#39;], //设置对话框宽度高度
            resize: false //是否允许调整尺寸
        &#125;)

        var bookId = $(obj).data(&quot;id&quot;); //获取&quot;修改&quot;按钮附带的图书编号
        $(&quot;#dlgBook #bookId&quot;).val(bookId); //为表单隐藏域赋值,提交表单时用到

        editor = new wangEditor(&#39;#dlgBook #editor&#39;); //初始化富文本编辑器
        editor.customConfig.uploadImgServer = &#39;/management/book/upload&#39; //设置图片上传路径
        editor.customConfig.uploadFileName = &#39;img&#39;; //图片上传时的参数名
        editor.create(); //创建wangEditor
        $(&quot;#dlgBook #optype&quot;).val(&quot;update&quot;); //设置当前表单提交时提交至&quot;update&quot;更新地址

        //发送ajax请求,获取对应图书信息
        $.get(&quot;/management/book/id/&quot; + bookId , &#123;&#125; , function(json)&#123;
            //文本框回填已有数据
            $(&quot;#dlgBook #bookName&quot;).val(json.data.bookName);//书名
            $(&quot;#dlgBook #subTitle&quot;).val(json.data.subTitle); //子标题
            $(&quot;#dlgBook #author&quot;).val(json.data.author);//作者
            $(&quot;#dlgBook #categoryId&quot;).val(json.data.categoryId); //分类选项
            editor.txt.html(json.data.description); //设置图文内容
            layui.form.render();//重新渲染LayUI表单
        &#125; , &quot;json&quot;)



    &#125;
    //显示新增图书对话框
    function showCreate()&#123;
        //弹出&quot;新增图书&quot;对话框
        layui.layer.open(&#123;
            id: &quot;dlgBook&quot;,
            title: &quot;新增图书&quot;,
            type: 1,
            content: $(&#39;#dialog&#39;).html(),
            area: [&#39;820px&#39;, &#39;730px&#39;],
            resize: false
        &#125;)
        //初始化wangEditor
        editor = new wangEditor(&#39;#dlgBook #editor&#39;);
        editor.customConfig.uploadImgServer = &#39;/management/book/upload&#39;;//设置图片上传地址
        editor.customConfig.uploadFileName = &#39;img&#39;;//设置图片上传参数
        editor.create();//创建wangEditor

        layui.form.render(); //LayUI表单重新
        $(&quot;#dlgBook #optype&quot;).val(&quot;create&quot;);//设置当前表单提交时提交至&quot;create&quot;新增地址

    &#125;;

    //对话框表单提交
    layui.form.on(&#39;submit(btnSubmit)&#39;, function(data)&#123;
        //获取表单数据
        var formData = data.field;
        
        //判断是否包含至少一副图片,默认第一图作为封面显示
        var description = editor.txt.html();
        if(description.indexOf(&quot;img&quot;) == -1)&#123;
            layui.layer.msg(&#39;请放置一副图片作为封面&#39;);
            return false;
        &#125;
        //获取当前表单要提交的地址
        //如果是新增数据则提交至create
        //如果是更新数据则提交至update
        var optype = $(&quot;#dlgBook #optype&quot;).val();
        
        if(optype == &quot;update&quot;)&#123;
            //更新数据时,提交时需要附加图书编号
            formData.bookId=$(&quot;#dlgBook #bookId&quot;).val();
        &#125;
        //附加图书详细描述的图文html
        formData.description = description;
        //向服务器发送请求
        $.post(&quot;/management/book/&quot; + optype , formData , function(json)&#123;
            if(json.code==&quot;0&quot;)&#123;
                //处理成功,关闭对话框,刷新列表,提示操作成功
                layui.layer.closeAll();
                table.reload(&#39;bookList&#39;);
                layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
            &#125;else&#123;
                //处理失败,提示错误信息
                layui.layer.msg(json.msg);
            &#125;
        &#125; ,&quot;json&quot;)
        return false;
    &#125;);
    //删除图书
    function showDelete(obj)&#123;
        //获取当前点击的删除按钮中包含的图书编号
        var bookId = $(obj).data(&quot;id&quot;);
        //利用layui的询问对话框进行确认
        layui.layer.confirm(&#39;确定要执行删除操作吗?&#39;, &#123;icon: 3, title:&#39;提示&#39;&#125;, function(index)&#123;
                    
                //确认按钮后发送ajax请求,包含图书编号
                $.get(&quot;/management/book/delete/&quot; + bookId, &#123;&#125;, function (json) &#123;
                    if(json.code==&quot;0&quot;)&#123;
                        //删除成功刷新表格
                        table.reload(&#39;bookList&#39;);
                        //提示操作成功
                        layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
                        //关闭对话框
                        layui.layer.close(index);
                    &#125;else&#123;
                        //处理失败,提示错误信息
                        layui.layer.msg(json.msg);
                    &#125;
                &#125;, &quot;json&quot;);
            
        &#125;);

    &#125;

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
package com.imooc.reader.controller.management;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

//http://localhost/management/book/index.html
//91.后台管理系统 编写富文本编辑器的图片上传功能book.ftl已全实现
//editor.customConfig.uploadImgServer = &#39;/management/book/upload&#39;;//设置图片上传地址
//92提供文件上传地址的接口 pom.xml增加文件上传依赖 apache
@Controller
@RequestMapping(&quot;/management/book&quot;)
public class MBookController &#123;
    @GetMapping(&quot;/index.html&quot;)
    public ModelAndView showBook()&#123;
        return new ModelAndView(&quot;/management/book&quot;);
    &#125;

    /**
     * wangEditor文件上传
     * @param file 上传文件
     * @param request 原生请求对象
     * @return
     * @throws IOException
     */
    //93. 接收提交的文件 上传的文件保存到upload目录中 代码编写
    @PostMapping(&quot;/upload&quot;)
    @ResponseBody
    public Map upload(@RequestParam(&quot;img&quot;) MultipartFile file, HttpServletRequest request) throws IOException &#123;
        //得到上传目录
        String uploadPath = request.getServletContext().getResource(&quot;/&quot;).getPath() + &quot;/upload/&quot;;//在out里 运行时执行获取路径
        //文件名
        String fileName = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;).format(new Date());
        //原始文件扩展名
        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;));//最后一次获得点
        //保存文件到upload目录
        file.transferTo(new File(uploadPath + fileName + suffix));
        Map result = new HashMap();
        result.put(&quot;errno&quot;, 0);
        result.put(&quot;data&quot;, new String[]&#123;&quot;/upload/&quot; + fileName + suffix&#125;);
        return result;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;!-- 92.增加文件上传依赖 SpringMVC文件上传底层依赖 93去applicationContext.xml激活--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
            &lt;version&gt;1.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--  93.激活文件上传功能 回到MBookController--&gt;
    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
 /**
     * wangEditor文件上传
     * @param file 上传文件
     * @param request 原生请求对象
     * @return
     * @throws IOException
     */
    //93. 接收提交的文件 上传的文件保存到upload目录中 代码编写 94book.ftl对话框表单提交
    @PostMapping(&quot;/upload&quot;)
    @ResponseBody
    public Map upload(@RequestParam(&quot;img&quot;) MultipartFile file, HttpServletRequest request) throws IOException &#123;
        //得到上传目录
        String uploadPath = request.getServletContext().getResource(&quot;/&quot;).getPath() + &quot;/upload/&quot;;//在out里 运行时执行获取路径
        //文件名
        String fileName = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;).format(new Date());
        //原始文件扩展名
        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;));//最后一次获得点
        //保存文件到upload目录
        file.transferTo(new File(uploadPath + fileName + suffix));
        Map result = new HashMap();
        result.put(&quot;errno&quot;, 0);
        result.put(&quot;data&quot;, new String[]&#123;&quot;/upload/&quot; + fileName + suffix&#125;);
        return result;
    &#125;
</code></pre>
<h3 id="实现图书新增功能"><a href="#实现图书新增功能" class="headerlink" title="实现图书新增功能"></a>实现图书新增功能</h3><pre><code class="java">book.ftl
// 94.对话框表单提交 95增加全新方法声明BookService
    layui.form.on(&#39;submit(btnSubmit)&#39;, function(data)&#123;
        //获取表单数据
        var formData = data.field;
        
        //判断是否包含至少一副图片,默认第一图作为封面显示
        var description = editor.txt.html();
        if(description.indexOf(&quot;img&quot;) == -1)&#123;
            layui.layer.msg(&#39;请放置一副图片作为封面&#39;);
            return false;
        &#125;
        //获取当前表单要提交的地址
        //如果是新增数据则提交至create
        //如果是更新数据则提交至update
        var optype = $(&quot;#dlgBook #optype&quot;).val();
        
        if(optype == &quot;update&quot;)&#123;
            //更新数据时,提交时需要附加图书编号
            formData.bookId=$(&quot;#dlgBook #bookId&quot;).val();
        &#125;
        //附加图书详细描述的图文html
        formData.description = description;
        //向服务器发送请求
        $.post(&quot;/management/book/&quot; + optype , formData , function(json)&#123;
            if(json.code==&quot;0&quot;)&#123;
                //处理成功,关闭对话框,刷新列表,提示操作成功
                layui.layer.closeAll();
                table.reload(&#39;bookList&#39;);
                layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
            &#125;else&#123;
                //处理失败,提示错误信息
                layui.layer.msg(json.msg);
            &#125;
        &#125; ,&quot;json&quot;)
        return false;
    &#125;);
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
 //95.创建新的图书 BookServiceImpl
    public Book createBook(Book book);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
 //95.数据增加 MBookController
    @Transactional
    public Book createBook(Book book) &#123;
        bookMapper.insert(book);
        return book;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
//95.获取书籍数据
    @PostMapping(&quot;/create&quot;)
    @ResponseBody
    public Map createBook(Book book)&#123;
        Map result = new HashMap();
        try &#123;
            book.setEvaluationQuantity(0);
            book.setEvaluationScore(0f);
            Document doc = Jsoup.parse(book.getDescription()); //一个个片段被解析
            Element img = doc.select(&quot;img&quot;).first();//选中所有标签提取第一个 获取图书详情第一图的元素对象
            String cover = img.attr(&quot;src&quot;);//获取当前元素指定值
            book.setCover(cover); //95.来自于description描述的第一幅图
            //用html解析器jsoup.jorg从前台的描述里截取图片位置 96加入依赖
            bookService.createBook(book); //此处可以打点debug
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<h3 id="实现图书分页查询-显示图书列表"><a href="#实现图书分页查询-显示图书列表" class="headerlink" title="实现图书分页查询[显示图书列表]"></a>实现图书分页查询[显示图书列表]</h3><pre><code class="java">com/imooc/reader/controller/management/MBookController.java
 //96.设计列表显示加载 97回到book.ftl
    @GetMapping(&quot;/list&quot;)
    @ResponseBody
    public Map list(Integer page, Integer limit)&#123;
        if (page == null)&#123;
            page = 1;
        &#125;
        if (limit == null)&#123;
            limit = 10;
        &#125;
        IPage&lt;Book&gt; pageObject = bookService.paging(null, null, page, limit);//返回paging的分页对象
        Map result = new HashMap();
        result.put(&quot;code&quot;, &quot;0&quot;);
        result.put(&quot;msg&quot;, &quot;success&quot;);
        //layUI返回值必须要求写的
        result.put(&quot;data&quot;, pageObject.getRecords()); //当前页面数据
        result.put(&quot;count&quot;, pageObject.getTotal()); //未分页时记录总数
        return result;
    &#125;
</code></pre>
<h3 id="实现图书修改更新功能-原有数据调整-回填数据"><a href="#实现图书修改更新功能-原有数据调整-回填数据" class="headerlink" title="实现图书修改更新功能 [原有数据调整 回填数据]"></a>实现图书修改更新功能 [原有数据调整 回填数据]</h3><pre><code class="java">book.ftl
// 94.对话框表单提交 95增加全新方法声明BookService
    layui.form.on(&#39;submit(btnSubmit)&#39;, function(data)&#123;
        //获取表单数据
        var formData = data.field;
        
        //判断是否包含至少一副图片,默认第一图作为封面显示
        var description = editor.txt.html();
        if(description.indexOf(&quot;img&quot;) == -1)&#123;
            layui.layer.msg(&#39;请放置一副图片作为封面&#39;);
            return false;
        &#125;
        //获取当前表单要提交的地址
        //如果是新增数据则提交至create
        //如果是更新数据则提交至update
        var optype = $(&quot;#dlgBook #optype&quot;).val();
     // 97.从隐藏域拿数据   98 MBookController
        if(optype == &quot;update&quot;)&#123;
            //更新数据时,提交时需要附加图书编号
            formData.bookId=$(&quot;#dlgBook #bookId&quot;).val();
        &#125;
        //附加图书详细描述的图文html
        formData.description = description;
        //向服务器发送请求
        $.post(&quot;/management/book/&quot; + optype , formData , function(json)&#123;
            if(json.code==&quot;0&quot;)&#123;
                //处理成功,关闭对话框,刷新列表,提示操作成功
                layui.layer.closeAll();
                table.reload(&#39;bookList&#39;);
                layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
            &#125;else&#123;
                //处理失败,提示错误信息
                layui.layer.msg(json.msg);
            &#125;
        &#125; ,&quot;json&quot;)
        return false;
    &#125;);
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
//98 前台ajax发送的格式保持一致 /managemet/book/id/ + bookId
    @GetMapping(&quot;/id/&#123;id&#125;&quot;)
    @ResponseBody
    public Map selectById(@PathVariable(&quot;id&quot;) Long bookId) &#123;
        Book book = bookService.selectById(bookId);
        Map result = new HashMap();
        result.put(&quot;code&quot;, &quot;0&quot;);
        result.put(&quot;msg&quot;, &quot;success&quot;);
        result.put(&quot;data&quot;, book); //服务器返回json.data book.ftl132行
        return result;
        //99 点击修改后的确认提交 增添更新操作 BookService.java
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
/**
     * 更新图书
     * @param book 新图书数据
     * @return 更新后的数据
     */
    //99.创建新的更新 BookServiceImpl
    public Book updateBook(Book book);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
/**
     * 更新图书
     * @param book 新图书数据
     * @return 更新后的数据
     */
    //99.更新数据 100 MBookController
    @Transactional
    public Book updateBook(Book book) &#123;
        bookMapper.updateById(book);
        return null;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
    /**
     * 更新图书数据
     * @param book
     * @return
     */
    //100. 更新代码 不要轻易对Book book数据直接更新 根据传入的book编号把数据库记录查出来
//101 删除方法BookService
    @PostMapping(&quot;/update&quot;)
    @ResponseBody
    public Map updateBook(Book book)&#123;
        Map result = new HashMap();
        try &#123;
            Book rawBook = bookService.selectById(book.getBookId());
            //通过前台数据获取
            rawBook.setBookName(book.getBookName());
            rawBook.setSubTitle(book.getSubTitle());
            rawBook.setAuthor(book.getAuthor());
            rawBook.setCategoryId(book.getCategoryId());
            rawBook.setDescription(book.getDescription());
            Document doc = Jsoup.parse(book.getDescription());
            String cover = doc.select(&quot;img&quot;).first().attr(&quot;src&quot;);
            rawBook.setCover(cover);
            bookService.updateBook(rawBook);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode()); ///成功时
            result.put(&quot;msg&quot;, ex.getMsg());//失败时
        &#125;
        return result;
    &#125;
</code></pre>
<h3 id="实现图书删除功能"><a href="#实现图书删除功能" class="headerlink" title="实现图书删除功能"></a>实现图书删除功能</h3><p><a target="_blank" rel="noopener" href="http://localhost/management/book/index.html">http://localhost/management/book/index.html</a><br><a target="_blank" rel="noopener" href="http://localhost/">http://localhost/</a></p>
<pre><code class="java">com/imooc/reader/service/BookService.java
 //101.删除方法 BookServiceImpl
    public void deleteBook(Long book);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
//101.删除相关数据 上面增加memberReadStateMapper evaluationMapper
    //一次性三个表删除 有声明式事务不会删一半 102 MBookController.java
    /**
     * 删除图书及其数据
     * @param bookId 图书编号
     */
    @Transactional
    public void deleteBook(Long bookId) &#123;
        bookMapper.deleteById(bookId);//单独删除id效率太低 写个构造器
        QueryWrapper&lt;MemberReadState&gt; mrsQueryWrapper = new QueryWrapper&lt;MemberReadState&gt;();
        mrsQueryWrapper.eq(&quot;book_id&quot;, bookId);
        memberReadStateMapper.delete(mrsQueryWrapper);
        QueryWrapper&lt;Evaluation&gt; evaluationQueryWrapper = new QueryWrapper&lt;Evaluation&gt;();
        evaluationQueryWrapper.eq(&quot;book_id&quot;, bookId);
        evaluationMapper.delete(evaluationQueryWrapper);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
//102. 封装 以及 code输出  103加入后台首页=&gt;index.ftl 后增加ManagementController
    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)
    @ResponseBody
    public Map deleteBook(@PathVariable(&quot;id&quot;) Long bookId) &#123;
        Map result = new HashMap();
        try &#123;
            bookService.deleteBook(bookId);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode()); ///成功时
            result.put(&quot;msg&quot;, ex.getMsg());//失败时
        &#125;
        return result;
    &#125;
</code></pre>
<h5 id="增加后台框架"><a href="#增加后台框架" class="headerlink" title="增加后台框架"></a>增加后台框架</h5><p><a target="_blank" rel="noopener" href="http://localhost/management/index.html">慕课书评网数据管理系统</a></p>
<pre><code class="java">com/imooc/reader/controller/management/ManagementController.java
package com.imooc.reader.controller.management;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
//103.后台管理系统控制器 104 修改index.ftl的静态地址
/**
 * 后台管理系统控制器
 */
@Controller
@RequestMapping(&quot;/management&quot;) //功能启动后台所需
public class ManagementController &#123;
    @GetMapping(&quot;/index.html&quot;)
    public ModelAndView showIndex()&#123;
        return new ModelAndView(&quot;/management/index&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">index.ftl

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;慕课书评网数据管理系统&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课书评网数据管理系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    admin
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;/management/logout&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;


                    &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                        &lt;a href=&quot;javascript:void(0)&quot;&gt;数据管理&lt;/a&gt;
                        &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;xxx&quot;&gt;
&lt;#--       104.静态地址改为动态地址--&gt;
                            &lt;dd&gt;&lt;a href=&quot;/management/book/index.html&quot; target=&quot;ifmMain&quot;&gt;图书管理&lt;/a&gt;&lt;/dd&gt;
                            &lt;dd&gt;&lt;a href=&quot;短评管理.html&quot; target=&quot;ifmMain&quot;&gt;短评管理
                                &lt;/a&gt;&lt;/dd&gt;
                        &lt;/dl&gt;
                    &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot; src=&quot;/management/book/index.html&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;);
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/01/18/后端/SSM开发社交网站[Freemarker+Spring+SpringMVC+Mybatis(Plus)构成SSM+Bootstrap+Art-Template+Kaptcha+SpringTask+wangEditor]/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/01/16/软考/软件设计师刷题考点/">
        <h2>
            软件设计师刷题考点
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="计算机工作原理"><a href="#计算机工作原理" class="headerlink" title="计算机工作原理"></a>计算机工作原理</h2><p>@@ 如果”2x”的补码是”90H”, 那么x的真值是 <u><strong>-56</strong></u><br>90H 拆开根据8 4 2 1由十六进制转换为二进制：10010000；补码最高位为符号位, 1代表负号, 所以说明此数为<strong>负数</strong>，可以根据口诀直接得源码(注意符号位不变)：1111 0000 即 -112；故2X&#x3D;-112  X&#x3D;-56</p>
<p>@@ 计算机中CPU对其访问速度最快的是<u><strong>通用寄存器</strong></u><br>计算机系统中的CPU内部对通用寄存器的存取操作是速度最快的 其次是Cache 再次是内存 最慢的是作为外存的硬盘</p>
<p>@@ 属于CPU中算术逻辑单元的部位是**<u>加法器</u>**<br>控制单元部件：<strong>指</strong>令寄存器、<strong>程</strong>序计数器、地<strong>址</strong>寄存器、<strong>数</strong>据寄存器[紫橙子树]                                                                                                                                                                                                                                                                                                                                                                                                                                         加法器是算数逻辑运算单元的部件</p>
<p>@@ 在CPU中，常用来为ALU执行算数逻辑运算提供数据并暂存运算结果的寄存器是<strong>累加寄存器</strong>[是专门存放算术或逻辑运算的一个操作数和运算结果的寄存器(加 减 读出 移位)]</p>
<p>@@ 所谓定点数，就是表示数据时小数点的位置固定不变。<br>小数点的位置通常由两种约定方式：<br>①定点整数(纯整数, 小数点在最低有效数值位之后)<br>②定点小数(纯小数, 小数点在最高有效数值位之前)<br>当机器字长为n时, 定点数的补码和移码可表示$2^n$个数, 而其源码和反码只能表示$2^n-1$个数(0占用了两个编码), 所以定点数所能表示的数值范围比较小, 运算中很容易因结果超出范围而溢出<br>数的浮点表示的一般形式为：N&#x3D;F×$2^E$, 其中E称为阶码，F为尾数。<br>尾数部分F的位数越多↑，数的精度越高↑；指数部分E的位数越多↑，能表示的范围越大↑<br><strong>阶码</strong>通常为带符号的纯整数<br><strong>尾数</strong>为带符号的纯小数<br>在尾数用补码表示时，规格化浮点数应满足尾数最高数位与符号位不同<br>当<strong>1&#x2F;2 ≤ |F|＜ 1</strong>时，应有0.1xx…x形式；<br>当**-1 ≤ M ＜ -1&#x2F;2<strong>时，应有1.0xx…x形式<br>当</strong>M&#x3D;-1&#x2F;2**时，对于源码来说是规格化数，而对于补码来说不是规格化数</p>
<p>@@ <strong>寄存器</strong>既可以用来存放<u>数据</u>和<u>地址</u>，也可以存放<u>控制信息</u>或<u>CPU工作时的状态</u><br>在CPU中增加寄存器的数量，可以使CPU把执行程序时所需的数据尽可能地放在寄存器中，从而减少访问内存的次数，提高其运行速度</p>
<p>@@ 程序计数器(PC)用于存放<strong>下一条指令所在单元的地址</strong>的地方</p>
<p>@@ 计算机系统中采用补码来表示和运算数据，原因是采用补码可以<strong>简化计算机运算部件的设计</strong><br>使用补码表示数据时，可以将符号位和其他位统一处理，减法也可按加法来处理，从而简化运算部件的设计</p>
<p>@@ 为了使一个系统能检查和纠正一个差错，间码最小距离必须至少是3<br><strong>海明码</strong>是一种可以纠正一位差错的编码，是<u>利用奇偶性来检错和纠错的一种校验方法</u>；海明码的基本意思是給传输的数据增加r个校验位，从而增加两个合法消息的不同位的个数。海明码利用奇偶性进行<u>检错</u>和<u>纠错</u>；其码距最小为<u>2n+1</u> [海明校验码只有在代码中只存在一个错误的前提下，才能实现纠错 ]<br>**循环冗余校验码(CRC)**编码方法是在k位信息码后再拼接r位的校验码，形成长度位n位的编码，其特点是检错能力极强且开销小，用于<u>编码器</u>及<u>检测电路实现</u><br><strong>奇偶校验</strong>是由若干位有效信息，再加上1  一个二进制位(校验位)组成校验码；奇偶校验只能查错不能纠错，<u>只有奇数个数发生错误，才能发现错误</u>；若有奇数个数据位出错，则可以检测出该错误但无法纠正错误</p>
<p>@@ 冗余技术：<br>1.结构冗余，按其工作方法可以分位<strong>静态</strong>、<strong>动态</strong>和<strong>混合</strong>冗余<br>2.信息冗余，指的是为了<strong>检测</strong>或<strong>纠正</strong>信息在运算或传输中的错误另外附加的一部分信息<br>3.时间冗余，指的是以重复执行指令或程序来消除顺时错误带来的影响<br>4.冗余附件技术，指的是为实现上述冗余技术所需的资源和技术</p>
<p>@@ CPU依据<strong>指令周期的不同阶段</strong>来区分在内存中以二进制编码形式存放的指令和数据<br>指令周期是执行一条指令所需时间，一般由若干个机器周期组成，是从取指令、分析指令到执行完所需的全部时间</p>
<p>@@ 浮点数相加，对阶时，小数向大数看齐；对阶是通过较小数的尾数右移实现的。将小阶向大阶对齐，同时将尾数右移n位</p>
<p>@@ 在CPU的寄存器中，<strong>指令寄存器</strong>对用户是完全透明的</p>
<p>@@ 程序计数器是用于存放下一条指令所在单元的地址的地方</p>
<p>@@ 属于CPU中算数逻辑单元的部件是<strong>加法器</strong></p>
<p>@@ 高速缓存地址是为了高速缓存的读取和写入而使用的地址，在CPU和高速缓存之间进行数据传输时使用的；当CPU需要读取数据时，DMA控制器和中断CPU发出的数据地址是<strong>主存的物理地址</strong>[<u>中断向量</u>提供的是<strong>中断服务程序的入口地址</strong>]；硬盘的扇区地址是用于访问硬盘上指定扇区的地址，并不直接与CPU进行数据交互；虚拟地址，是指在操作系统中使用的地址，它需要通过地址映射和页表等机制转换为物理地址才能被CPU使用</p>
<p>@@ <strong>相联存储器</strong>是指<u>按内容访问</u>的存储器<br>按<strong>构成存储器</strong>的材料：磁存储器、半导体存储器、光存储器<br>按存储器的<strong>工作方式</strong>：读写存储器、只读存储器<br>按<strong>访问</strong>方式：按地址访问的存储器、按内容访问的存储器<br>按**[寻]地址**访问的存储器：随机存储器、顺序存储器、直接存储器</p>
<p>@@ ±0编码相同的是<strong>补码和移码</strong></p>
<p>@@ 计算机感染特洛伊木马后的典型现象是<strong>有未知程序试图建立网络连接</strong></p>
<p>@@ 再微型计算机中，管理键盘最适合采用的1&#x2F;0控制方式是<strong>中断方式</strong></p>
<p>@@ 在移臂调度算法中，<strong>先来先服务</strong>和<strong>最短寻找时间优先</strong>(<u>根据当前磁臂到要请求访问磁道的距离，誰短满足誰的请求</u>)算法可能会随时改变移动臂的运动方向</p>
<p>@@ 计算机中，系统总线用于<strong>CPU、主存及外设部件</strong>连接</p>
<p>@@ 双核是指<strong>在一个CPU中集成两个运算核心以提高运算能力</strong></p>
<p>@@ 已知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>对B进行反编译，不能还原出源程序A</strong></p>
<p>@@ 在程序执行过程中，Cache与主存的地址映射是由<strong>硬件自动</strong>完成的</p>
<p>@@ 计算机系统的主存主要是由<strong>DRAM</strong>构成的。<br>随机访问存储器(<strong>RAM</strong>)有两类：静态的(SRAM) 和 动态的(DRAM)</p>
<p>@@ 存储系统采用Cache技术的主要目的是提高存储器的访问速度，因此是由<strong>硬件自动完成</strong>Cache与主存之间的操作</p>
<p>@@ 主存与Cache的地址映射方式中，<strong>全相联</strong>方式可以实现主存任意一块装入Cache中任意位置，只有装满才需要替换<br><strong>全相联地址映射：</strong>主存的任意一块可以映射到Cache中的<strong>任意</strong>一块<br><strong>直接相联映射：</strong>主存中一块只能映射到到Cache的一个<strong>特定</strong>的块中<br><strong>组相联的映射：</strong>各区中的某一块只能存入缓存的同组号的空间内，但组内各块地址之间则可以任意存放。即从<strong>主存</strong>的组到Cache的组之间采用直接映像方式，在两个对应的<strong>组内部</strong>采用全相联映像方式</p>
<p>@@ 常用的虚拟存储器由<strong>主存-赋存</strong>两级存储器构成<br>虚拟存储技术使辅助存储器和主存储器密切配合。虚拟存储器的地址称为虚地址或逻辑地址  </p>
<p>@@ 虚拟存储体系由<strong>主存-赋存</strong>两级存储器构成<br>一般计算机系统中主要由两种存储体系：<br><u><strong>Cache存储体系</strong></u>由<strong>Cache</strong>和<strong>主存储器</strong>构成，主要目的是提高存储器速度，对系统程序员以上均透明<br><u><strong>虚拟存储体系</strong></u>由主存储器和在线磁盘存储器等辅存构成，主要目的是扩大存储器容量，对应用程序员透明</p>
<p>@@ Cache的地址映像方式中，发生块冲突次数最小的是<strong>全相联映像</strong><br>Cache的地址映射方法主要有三种：全相联地址映射、直接相联地址映射、组相联地址映射<br>**全相联地址映射 **[意味着主存的任意一块可以映射到Cache中的任意一块，特点：块冲突概率低，Cache空间利用率高，但相联目录表容量大导致成本高、查表速度慢]<br><strong>直接映像方式</strong> [指主存的每一块只能映像到Cache的一个特定的块中，整个Cache地址与主存地址的低位部分完全相同，其特点是硬件简单，不需要相联存储器，访问速度快，Cache块冲突概率高，Cache控件利用率低]<br><strong>组相联映射</strong> [是上面两种方法的这种处理]</p>
<p>@@ 计算机采用分级存储体系的主要目的是为了解决<strong>存储容量、成本和速度之间的矛盾</strong>问题<br>高速缓存一般用SRAM[速度快,成本高]<br>内存一般用DRAM[集成度高,动态刷新]<br>外存一般用磁存储器[速度慢,容量大,价格便宜]</p>
<p>@@ Cache的设计思想是在合理成本下提高命中率</p>
<p>@@ <strong>并行总线</strong>适合<strong>近距离高速数据传输</strong>、<strong>串行总线</strong>适合<strong>长距离数据传输</strong><br>在单总线结构中，CPU与主存之间、CPU与I&#x2F;O设备之间、I&#x2F;O设备与主存之间、各种设备之间都通过系统总线交换信息。单总线结构的优点是控制简单方便，扩充方便</p>
<p>@@ 总线：数(数据总线) 控(控制总线) 地(地址总线) ISA EISA PCI MCA<br>SCSI是一种用于计算机和智能设备之间系统级接口的独立处理器标准</p>
<p>@@ 总线复用方式可以<strong>减少总线中信号线的数量</strong><br>总线式一组能为多个部件分时共享的信息传送线，用来连接多个部件并为之提供信息交换通路，通过<strong>总线复用方式</strong><u>可以减少总线中信号线的数量，以较少的信号线传输更多的消息</u></p>
<p>@@ 在计算机系统中采用总线结构，便于实现系统的积木化结构，同时可以<strong>减少总线中信号线的数量</strong> </p>
<p>@@ <strong><u>直接主存存取</u></strong>(<strong>DMA</strong>)[Direct Memory Access]控制方式是在<strong>主存与外设</strong>之间直接建立数据通路进行数据的交换处理</p>
<p>@@ 在I&#x2F;O设备与主机间进行数据传输时，CPU只需在开始和结束时作少量处理，而无需干预数据传送过程的是<strong>直接存储器存取 [DMA]<strong>方式。[直接内存存取(Direct Memory Access)方式的基本思想是通过</strong>硬件控制</strong>实现<u><strong>主存</strong></u>与**<u>I&#x2F;O设备</u>**间的直接数据传送，数据的传递过程由DMA控制器进行控制，不需要CPU的干预。在DMA方式下由CPU启动传送过程，即向设备发出”传送一块数据”的命令，在传送过程结束时，DMAC通过中断方式通知CPU进行一些后续处理工作]</p>
<p>@@ 在微机系统中，BIOS(基本输入输出系统)保存在<strong>主板上的ROM</strong>中 [BIOS是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从<strong>CMOS</strong>中读写系统设置的具体信息]</p>
<p>@@ 计算机运行过程中，遇到突发事件，要求CPU暂时停止正在运行的程序，转去为突发事件服务，服务完毕，再自动返回原程序继续执行，这个过程成为<strong>中断</strong>，其处理过程中保存现场的目的是<strong>返回去继续执行原程序</strong></p>
<p>@@ CPU是再<strong>一个总线周期</strong>结束时响应DMA请求的 [DMA请求的检测点设置在每个机器周期也即总线周期结束时执行，这样使得总线利用率最高]</p>
<p>@@ 计算机中CPU的中断响应时间指的是<strong>从发出中断请求到开始进入中断处理程序</strong>的时间</p>
<p>@@ 中断向量可提供<strong>中断服务程序的入口地址</strong>[为了提高响应中断的速度，通常把所有<u>中断服务<strong>程序的入口地址</strong></u>[称中断向量]汇聚为<strong>中断向量表</strong>]</p>
<p>@@ 为了便于实现多级中断嵌套，使用<strong>堆栈</strong>来保护断点和现场最有效 【<u>实现中断嵌套<strong>后进先出</strong>的栈来保护断点和现场最有效(当系统中有多个中断请求时，中断系统按优先级进行排队。若在处理低级中断过程中又有高级中断申请中断，则高级中断可以打断低级中断处理，转去处理高级中断，等处理完高级中断后再返回去处理原来的低级中断，称为<strong>中断嵌套</strong>)</u>】</p>
<p>@@ <strong>由I&#x2F;O设备提出的中断请求是可屏蔽中断，电源掉电是不可屏蔽中断</strong><br>可将中断分为两大类：<br><strong>不可屏蔽中断</strong>(非屏蔽中断) 和 <strong>可屏蔽中断</strong><br><strong>不可屏蔽中断源</strong>[断电]一旦提出请求，CPU必须无条件响应，而对<strong>可屏蔽中断源</strong>[打印机中断(处于等待请求响应)]的请求，CPU可以响应，也可以不响应。</p>
<p>@@ 计算机在一个指令周期过程中，为从内存读取指令操作码，首先要将**程序计数器(PC)**的内容送到地址总线上<br>CPU首先从程序计数器获得需要执行的指令地址，从内存(或高速缓存)读取到的指令则暂存在指令寄存器(IR)，然后进行分析和执行</p>
<p><strong>程序计数器</strong>是PC用于存放下一条指令所在单元的地址的地方<br><strong>指令寄存器</strong>是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一套指令<br><strong>地址寄存器</strong>用来保存当前CPU所访问的内存单元的地址<br><strong>指令译码器</strong>从内存中取出一条指令经数据总线送往指令寄存器中</p>
<p>@@ 对于只有单条指令的情况下，流水线方式与顺序执行时没有区别的。流水线的原理是在某一时刻可以让多个部件同时处理多条指令，避免各部件等待空闲，由此提高了各部件的利用率，也提高了系统的吞吐率</p>
<p>@@ 流水线的吞吐率是指单位时间流水线处理机输出的结果的数目，因此流水线的吞吐率为一个流水级时间的倒数，即最长流水级时间的倒数</p>
<p>@@ CPU执行算术运算或者逻辑运算时，常将源操作数和结果暂存在<strong>累加器(AC)<strong>中<br>CPU中常设置多个寄存器，其中，<u><strong>程序计数器</strong>的作用是保存<em>待读取</em> 指令在内存中的地址</u>，</strong>累加器(AC)<strong>是算数逻辑运算单位中用来<u><strong>暂存</strong>源操作数</u>和<u>计算结果的寄存器</u>，</strong>指令寄存器</strong>暂存从内存读取的指令，<strong>地址寄存器</strong>暂存要访问的内存单元的地址。</p>
<p>@@ <strong>VLIW</strong>(Very Long Instruction Word, 超长指令字) 一种非常长的指令组合，它把许多条指令连在一起，增加了运算的速度</p>
<p>@@ 在机器指令的地址字段中，直接指出操作数本身的寻址方式称为<strong>立即寻址</strong>[是一种特殊的寻址方式 指令中在操作码字段后面的部分不是通常意义的操作数，而是操作数本身，也就是说数据就包含在指令中，只要取出指令，也就是去除了可以立即使用的操作数]</p>
<p>@@ 若CPU要执行的指令为：MOV R1，#45(即将数值45传递到寄存器R1中)，则该指令中采用的寻址方式是<strong>寄存器寻址和立即寻址</strong> [45是立即数，R1是寄存器]<br><strong>立即寻址：</strong>操作数就包含在指令中<br><strong>直接寻址：</strong>操作数存放在内存单元中，指令中直接給处操作数所在内存单元的地址<br><strong>寄存器寻址：</strong>操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名<br><strong>寄存器间接寻址：</strong>操作数存放在内存单元中，操作数所在存储单元的地址在某个寄存器中<br><strong>间接寻址：</strong>指令中给出操作数地址的地址<br><strong>相对寻址：</strong>指令地址码给出的是一个偏移量可正可负，操作数地址等于本条指令的地址加上该偏移量<br><strong>变址寻址：</strong>操作数地址等于变址寄存器的内容加偏移量</p>
<p>@@ CISC(Complex Instruction Set Computer)是<strong>复杂指令系统计算机</strong>的简称 其基本思想是：<u>进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬件化，导致机器的指令系统越来越庞大而复杂。CISC计算机一般所含的指令数目至少300条以上</u><br>RISC(Reduced  Instruction Set Computer <strong>精简指令集计算机</strong>) 其基本思想是：<u>通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用<strong>硬布线</strong>控制逻辑优化编译程序。</u> 通常会比CISC配置更多的寄存器、RISC编译器的子程序库通常要比CISC编译器的子程序库大很多、RISC比CISC更加适合VLSI工艺的规整性要求。</p>
<p>@@ Flynn分类法基于信息流特征将计算机分成4类，其中<strong>MISD</strong>只有理论意义而无实例<br>Flynn主要根据指令流和数据流来分类：<br>① 单指令流单数据流机器(SISD)<br>② 单指令流多数据流机器(SIMD)<br>③ 多指令流单数据流机器(MISD)[<strong>M</strong>ulti <strong>I</strong>nstruction <strong>S</strong>ingle <strong>D</strong>ata] [采用多个指令流来处理单个数据流 在实际情况中，采用多指令流处理多数据流才是最有效的方法，因此MISD<strong>只是作为理论模型出现，没有投入实际应用</strong>]<br>④ 多指令流多数据流机器(MIMD)</p>
<p>@@ 取指令时间4Δt，分析时间为2Δt，执行时间为3Δt，按顺序方式从头到尾执行完600条指令所需时间为<strong>5400</strong>Δt，使用流水线从头到尾执行完600条指令所需的时间为<strong>2405</strong>Δt [未说流水线就普通乘法计算 流水线则按公式计算]<br>① 指令顺序执行时，每条指令需要(4Δt+2Δt+3Δt)&#x3D;9Δt     9Δt×600&#x3D;5400Δt<br>② (4Δt+2Δt+3Δt) + (600-1) × 4 &#x3D; 2405Δt</p>
<p>@@ 指令系统中采用不同寻址方式的目的是<strong>扩大寻址控件并提高编程灵活性</strong></p>
<p>@@ 计算机指令一般包括操作码和地址码两部分，为分析执行一条指令，其<strong>操作码和地址吗都应存入指令寄存器(IR)</strong> [程序被加载到内存后开始运行，当CPU执行一条指令时，<u><strong>先把它从内存器取到缓冲寄存器DR中，再送入IR暂存</strong></u>，指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所有功能。]</p>
<p>@@ CPU产生每条指令的操作信号并将操作信号送往相应的部件进行控制、CPU中的控制器决定计算机运行过程的自动化、指令译码器是CPU控制器中的部件<br>CPU是计算机的控制中心，主要由运算器、控制器、寄存器组、和内部总线等部件组成。<br><strong>控制器</strong>由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成</p>
<p>@@ 可靠度串并联：串联系统可靠度为R1×R2，并联系统可靠度为R1&#x2F;R2&#x3D;1-(1-R)</p>
<p>@@ 计算机系统的<strong>可靠性</strong>可以用**MTBF &#x2F; (1+MTBF)**来度量，其中MTBF为平衡失效间隔时间 [又称平均无敌故障时间] 是衡量一个产品(尤其是电器产品)的可靠性指标，单位为”小时”</p>
<p>@@ 软件产品的可靠性并不取决于<strong>软件产品的开发方式</strong> 而取决于<strong>潜在的错误数量和位置，软件产品的使用方式</strong>；软件可靠性指的是一个系统对于给定的时间间隔内，在给定条件下**<u>无失效运作的概率</u>**。</p>
<p>@@ <u>软件<strong>可靠性</strong></u>是指一个系统在给定时间间隔内和给定条件下<strong>无失败运行的概率</strong>，一个软件系统能够按照规格说明正确运行的概率。<u>软件<strong>可维护性</strong></u>是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源<strong>完成维护活动的概率</strong></p>
<p>@@ <strong>应用级网关</strong>防火墙是内部网和外部网的隔离点，它可对应用层的通信数据流进行监控和过滤。应用级网关可以工作在OSI七层模型上的任意一层，能够检查进出的数据包，通过网关复制传递数据，防止在受信任服务器和客户机与不受信任的主机之间直接建立联系。</p>
<p>@@ 用户A和B要进行安全通信，通信过程需确认双方身份和消息不可否认，A和B通信时使用<strong>数字证书</strong>来对用户的身份进行认证；使用<strong>数字签名</strong>确保消息不可否认</p>
<p>@@ <strong>震网</strong>病毒是一种破坏工业基础设施的恶意代码，利用系统漏洞攻击工业控制系统，是一种危害性极大的<strong>蠕虫病毒</strong>。<strong>蠕虫(Worm)<strong>是一个程序或程序序列。它利用网络进行复制和传播，传染途径是通过网络、移动存储设备和电子邮件。最初的蠕虫病毒定义是在DOS环境下，病毒发作时会在频幕上出现一条类似虫子的东西，胡乱吞吃屏幕上的字母并将其改正。常见的蠕虫病毒有：</strong>快乐时光、红色代码、爱虫病毒、熊猫烧香、Nimda病毒、爱丽兹病毒</strong>。<strong>CIH</strong>：系统病毒      <strong>X卧底</strong>：以木马形式传播目标为智能手机的病毒<br><strong>引导区病毒</strong>：破坏的是引导盘、文件目录<br><strong>宏病毒</strong>[<strong>Macro</strong>]：破坏的是OFFICE文件相关(病毒宏将自身复制至Word的通用Normal模板中)<br><strong>木马</strong>：一般强调控制操控 [<strong>冰河</strong>是木马软件，主要用于远程监控。冰河木马后经其他人多次改写形成多种变种，并被用于入侵其他用户的计算机木马程序]</p>
<p>@@ Sniffer(<strong>嗅探器</strong>)是一种基于被动侦听原理的网络分析方式。使用这种技术方式可以监视网络的状态、数据流动情况以及网上传输的信息。它不是木马程序</p>
<p>@@ 属于DoS攻击的是<strong>SYN Flooding攻击</strong> [<u>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。</u>]<br>① <strong>特洛伊木马</strong>[Trojan]是附着在应用程序中或者单独存在的一些恶意程序，它可以利用网络远程控制网络的另一端的安装有服务端服务的主机，实现对被植入了木马程序的计算机的控制，或者窃取被植入了木马程序的计算机上的机密资料。<br>② <strong>拒绝服务攻击</strong>通过网络的内外部用户来发动攻击。内部用户可以通过长时间占用系统的内存、CPU处理时间使其他用户不能及时得到这些资源，而引起拒绝服务器攻击；外部黑客也可以通过占用网络连接使其他用户得不到网络服务   <strong>SYN Flooding攻击</strong>以多个随机的源主机地址向目的路由器发送SYN包，在收到目的路由器的SYN ACK后并不回应，于是目的路由器就为这些源主机建立大量的连接队列，由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致服务器崩溃。服务器要等待超时才能断开已分配的资源，所以SYN Flooding攻击是一种DOS攻击<br>③ <strong>端口欺骗攻击</strong>是采用端口扫描到系统漏洞从而实施攻击<br>④ <strong>IP欺骗攻击</strong>是产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份</p>
<p>@@ DES是<strong>共享密钥加密</strong>算法；常见的对称加密算法有：DES、三重DES、RC-5、IDEA、AES<br><u>共享密钥加密</u>指<u><strong>对称加密</strong></u>；<br><u>非共享密钥</u>加密指<u><strong>公开密钥加密</strong></u></p>
<p>@@ 计算机病毒的特征：<strong>隐蔽性、传染性、潜伏性、触发性、破坏性</strong></p>
<p>@@ MD5是<strong>摘要</strong>算法，对任意长度的输入计算得到的结果长度是<strong>128未散列值</strong></p>
<p>@@ 攻击者通过发送一个目的主机已经接受过的报文来达到攻击目的，这种攻击方式属于<strong>重放</strong>攻击<br>**重放攻击(Replay Attacks)**又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行</p>
<p>@@ kerberos系统中可通过在报文中加入<strong>时间戳</strong>来防止重放攻击。发送的数据包带时间戳的，服务器可以根据时间戳来判断是否为重放包，以此防止重放攻击</p>
<p>@@  防火墙最基本的功能就是控制在计算机网络中，不同信任程度区域间传送的数据流。防火墙对流经它的网络通信进行扫描，这样能够过滤掉一些攻击，以免其在目标计算机上被执行。防火墙还可也关闭不适用的端口，屏蔽内部细节。所有的访问都经过防火墙，防火墙就能记录下这些访问并做出日志记录，同时也能提供网络使用情况的统计数据</p>
<p>@@ 防火墙的性能及特点：<br>① <strong>工作层次：</strong>决定防火墙效率及安全的主要因素，<u><strong>工作层次越低，则工作效率越高，其安全性就越低</strong></u><br>② <strong>防火墙机制：</strong>采用代理机制，则防火墙具有内部信息隐藏的特点，相对而言，安全性越高，效率越低。如果采用<strong>过滤机制</strong>，则效率高，安全性却降低</p>
<p>@@ 包过滤防火墙和代理服务防火墙的叙述中正确的是<strong>包过滤技术对应用和用户是透明的</strong>。包过滤技术是一种基于网络层、传输层的安全技术，优点是简单实用，实现成本较低同时，<strong>包过滤操作对于应用层来说是透明的</strong>，使用此类防火墙时外部网络与内部网络之间不存在直接连接，即使防火墙发生了问题，外部网络也无法被保护的网络连接。</p>
<p>@@ 包过滤防火墙对数据包的过滤依据包括<strong>源IP地址、源端口号、目标IP地址、目标端口号</strong> 而不是<del>MAC地址</del></p>
<p>@@ 防火墙通常分为<strong>内网、外网、DMZ</strong>三个区域<br>按照<u>受保护程序</u>[安全级别]从高到低正确排列顺序依次为<strong>内网、DMZ、外网</strong>；<br>① 内网可以访问外网、内网可以访问DMZ<br>② 外网可以访问DMZ、外网不能访问内网<br>③ DMZ不能访问外网、DMZ不能访问内网</p>
<p>@@ 入侵检测技术包括<strong>专家系统、模型检测、简单匹配</strong> [<u>入侵检测</u>和<u>流量控制</u>属于网络安全措施]</p>
<p>@@ 这四种加密算法均能对明文进行加密。<br><strong>RSA</strong>是一种非对称加密算法，由于加密和解密的密钥不同，因此便于密钥管理和发放，同时用户或机构之间进行身份认证方面有较好的应用 [基于大数定律，通常用于对消息摘要进行签名(<strong>数字签名算法</strong>) 而IDEA和RC4适用于对数据传输加密]<br><strong>SHA-1</strong>是一种安全散列算法，常用于对接接收到的明文输入产生固定长度的输出，来确保明文在传输过程中不会被篡改<br><strong>MD5</strong>是一种使用最为广泛的报文摘要算法(<strong>摘要算法</strong>)<br><strong>RC5</strong>是一种用于对明文进行加密的算法，在加密速度和强度上均较为合适，适用于大量明文进行加密并传输</p>
<p>@@ 假定用户A、B分别为I1和I2两个CA处取得了各自的证书，下面<strong>I1、I2互换公钥</strong>是A、B互信的必要条件</p>
<p>@@ <strong>MIME</strong>是一个互联网标准，<u>扩展了电子邮件标准</u>，使其能够支持，与安全无关。<br><strong>SSL</strong>和<strong>HTTPS</strong>涉及到<u>邮件传输过程的安全</u><br><strong>PGP</strong>是一套用于信息加密、验证的应用程序，可用于<u>加密电子邮件内容</u></p>
<p>@@ 数字签名用于通信的A、B双方，使得A向B发送签名的消息P，提供以下服务：<br>① B可以验证消息P确实是来源于A<br>② A不能否认发送过消息P<br>③ B不能便在或修改消息P<br>数字签名首先需要生成消息摘要，使用非对称加密算法以及私钥对摘要进行加密。接收方使用发送方的公钥对消息摘要进行验证。</p>
<p>@@ 用户B收到用户A带数字签名的消息M，为了验证M的真实性，<span style = "color : red">首先需要从CA获取用户A的数字证书，并利用<strong>CA的公钥</strong>验证该证书的<strong>真伪</strong></span>，然后利用<strong>A的公钥</strong>验证M的真实性 [<u>验证证书的真伪需要用CA的公钥验证CA的签名，验证M的真实性需要用用户A的公钥验证用户A的签名</u>]</p>
<p>@@ <span style = "color : red">从认证中心CA获取用户B的数字证书，该证书用<strong>CA的私钥</strong>作<strong>数字签名</strong></span>：<u>从用户B的数字证书中可以获得B的公钥</u> 【<strong>CA公钥→合法性、CA签名→真伪、CA私钥→数字签名</strong>】</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/030ab484289fb8237b38a9a6a073451c201af8c5/data/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></p>
<p>@@ 公钥体系中，<strong>私钥用于<u>解密和签名</u>，公钥用于<u>加密和认证</u></strong></p>
<p>@@ 某网站向CA申请了数字证书，用户通过<strong>CA的签名</strong>来验证网站的<strong>真伪</strong>，通过使用<strong>CA的公钥</strong>来确定该网站的<strong>合法性</strong></p>
<p>@@ <strong>设置防雷击</strong>属于物理线路安全措施、<strong>入侵检测, 流量控制</strong>属于网络安全措施、<strong>漏洞发现于补丁管理</strong>属于系统安全措施</p>
<p>@@ <strong>网络攻击</strong>有<strong>主动攻击</strong>和<strong>被动攻击</strong>两类，主动攻击是指通过一系列方法主动向被攻击对象试试破坏的一种攻击方式，<strong>主动攻击</strong>有：<u>重放攻击、IP地址欺骗、拒绝服务</u>。<strong>流量分析攻击</strong>[被动攻击]是通过持续检测现有网络中的流量变化或者变化趋势，而得到相应信息的一种被动攻击方式</p>
<p>@@ 端口443明确用于<strong>HTTPS服务</strong>，因此是HTTPS（加密）流量的标准端口。 它也称为HTTPS端口443，因此所有受保护的事务都是使用端口443进行的。 您可能会惊讶地发现，几乎95％的安全站点都使用端口443进行安全传输。80端口是<strong>HTTP超文本传输协议</strong>。</p>
<table>
<thead>
<tr>
<th align="center">Proto</th>
<th align="center">Local Address</th>
<th align="center">Foreign Address</th>
<th align="center">State</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2011</td>
<td align="center">202.100.112.12:443</td>
<td align="center">ESTABLISHED</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2052</td>
<td align="center">128.105.129.30:80</td>
<td align="center">ESTABLISHED</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2038</td>
<td align="center">100.29.200.110:110</td>
<td align="center">TIME_WAIT</td>
</tr>
</tbody></table>
<p>① 其中已经与主机202.100.112.12的443端口建立连接，由于443端口主要用于HTTPS服务，是提供加密和通过安全端口传输的另一种HTTP协议，是建立了<strong>安全连接</strong>。<br>② 其中已经与主机128.105.129.30的80端口建立了普通连接。<br>③ 其中与主机100.29.200.110的110端口正在等待建立连接</p>
<p>@@ <strong>SSH</strong>(Secure Shell)是<strong>终端设备</strong>与<strong>远程站点</strong>之间建立安全连接的协议，是专为远程登录会话和其他网络服务提供安全性的协议，利用SSH协议可以有效防止远程管理过程中的信息泄露问题，SSH最初是UNIX上的程序</p>
<p>@@ <strong>机房安全</strong>属于物理安全、<strong>入侵检测</strong>属于网络安全、<strong>漏洞补丁管理</strong>属于系统安全、<strong>数据库安全</strong>属于应用安全</p>
<p>@@ 网络系统中，通常把<strong>Web服务器</strong>置于DMZ区 [DMZ是为了<u>解决安装防火墙后外部网络不能访问内部网络服务器的问题</u>，而设立的一个非安全系统与安全系统之间的缓冲区。这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，在这个小网络区域内可以防止一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛]</p>
<p>@@ 拒绝服务攻击即攻击者想办法让目标机器停止提供服务，这是黑客常用的攻击手段之一，其实对网络带宽进行的消耗性攻击只是拒绝服务攻击的一小部分，只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于<strong>拒绝服务攻击</strong>。攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是<u><strong>迫使服务器的缓冲区满</strong></u>，不接收新的请求。二是<u><strong>使用IP欺骗</strong></u>，迫使服务器把合法用户的连接复位，影响合法用户的连接</p>
<p>@@ PKI体制中，保证数字证书不被篡改的方法是<strong>用CA的私钥对数字证书签名</strong>[防伪造,不可抵赖]</p>
<p>@@ <strong>ECC、DSA、RSA</strong>属于公开密钥加密算法     <strong>DES</strong>属于<strong>私钥加密体制</strong></p>
<p>@@ 利用<strong>报文摘要算法</strong>生成报文主要的目的是<strong>防止发送的报文被篡改</strong> [报文摘要是用来保证数据完整性的，传输的数据一旦被修改，摘要就不同了，只要对比两次摘要就可以确定数据是否被修改过]</p>
<p>@@ <strong>TLS</strong>是安全传输层协议的简称，用于在两个通信应用程序之间提供保密性和数据完整性<br><strong>SSL</strong>是安全套接层协议的简称，是一种为网络通信提供安全和数据完整性的协议，它与TLS非常相似，它们都是在<u>传输层</u>对网络连接进行加密<br><strong>PGP</strong>是基于RSA公钥加密体系的邮件加密软件，用它可以对邮件保密以防止非授权者阅读<br><strong>HTTPS</strong>即安全版的<strong>HTTP</strong>(超文本传输协议)，它是在HTTP下加入SSL层，HTTPS的安全基础就是SSL<br><strong>IPSec</strong>是<u>网络层</u>的安全协议，它通过使用加密的安全服务来确保在网络上进行保密而安全的通讯</p>
<p>@@ 在Windows系统中，默认权限最低的用户组是<strong>everyone</strong><br>用户组默认权限由高到低的顺序是<strong>administrators &gt; power users &gt; users &gt; everyone</strong></p>
<p>@@ IIS6.0支持的身份验证安全机制有[<u>.NET Passport身份验证、集成Windows身份验证、摘要式身份验证、基本身份验证</u>]安全级别最高的验证方法是<strong>集成Windows身份验证</strong></p>
<p>@@ 利用<strong>漏洞扫描系统</strong>可以获取某FTP服务器中是否存在可写目录的信息 [通过与目标主机TCP&#x2F;IP端口建立连接并请求某些服务(TELNET、FTP)，记录目标主机的应答，搜索目标主机相关信息，从而发现目标主机某些内在的安全弱点]</p>
<p>@@ FTP服务器的控制端口为<strong>21</strong>，上传文件时的端口为<strong>20</strong></p>
<p>@@ 防范网络监听最有效的方法是<strong>数据加密</strong></p>
<p>@@ “三网合一”的三网是指<strong>电信网、广播电视网、互联网</strong></p>
<h2 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h2><p>@@ <strong>LISP</strong>是一种通用高级计算机程序语言、<strong>C</strong>是命令式过程式语言、<strong>Java</strong>面向对象语言、<strong>C#<strong>结构化程序设计语言、</strong>Java,Python,JavaScript</strong>都是解释型程序设计语言[其中python[弱类型语言]和javascript是<u>脚本语言</u>(主要采用<strong>解释方式实现</strong>)]<br>强&#x2F;弱类型指的是语言类型系统的类型检查的严格程度。弱类型相对于强类型来说类型检查<strong>更不严格</strong>, 比如<u>允许变量类型的隐式转换，允许强制类型转换</u>等</p>
<p>@@ <strong><u>语法制导翻译</u><strong>是一种</strong>静态语义分析</strong>方法。程序设计语言的语义分为<strong>静态语义</strong>和<strong>动态语义</strong>，其中静态语义分析方法是语法制导翻译，其基本思想是将语言结构的语义以属性的形式赋予代表此结构的文法符号，而属性的计算以语义规则的形式赋予文法的产生式。</p>
<p>@@ 常用的函数参数传递方式有<strong>传值</strong>与<strong>传引用</strong>两种；<strong>在传引用方式下，修改形参实质上改变了实参的值</strong>。[<u>在<strong>传值</strong>调用方式下，是将实参的值传递给形参，该传递是单方向的，结束调用后不会再将形参的值传递給实参</u>。<u>在<strong>引用</strong>调用方式下，实质上是将实参的地址传递給形参，借助指针的间接访问数据方式下(或者将形参看作是实参的别名)，在被调用函数中对形参的修改实质上是对实参的修改。</u>]</p>
<p>@@ 在<strong>值调用</strong>方式下是将参数的值传給形参。在<strong>引用调用</strong>方式下是将实参的地址传递给形参                 </p>
<p>@@ 在<strong>传值调用</strong>方式下，实参可以是变量，也可以是常数和表达式<br>在<strong>引用调用</strong>方式下，可以是实现形参和实参间双向传递数据的效果          </p>
<p>@@ 传地址方式下，<u>将<strong>实参</strong>的地址传給<strong>形参</strong></u>，因此，实参必须有地址                                                                       </p>
<p>@@ 函数中print(x)执行后输出的值为<strong>40</strong></p>
<pre><code class="C">main()&#123;                      f(int x, int &amp;a)&#123;
  int x = 5;                    x = x * x - 1;
  f(x+1,x);                        a = x + a;
  print(x);                        return;
&#125;                               &#125;
</code></pre>
<p>@@ 函数中return(a-x)执行后输出的值为<strong>33</strong><br><img src="https://raw.githubusercontent.com/P-luminary/images/92ef1aa18e2abcd24f114fb254939f65a6933028/data/%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92%E5%9C%B0%E5%9D%80.png" style="zoom:50%;" /></p>
<p>@@ 编译器对高级语言源程序的处理过程：<br><u>源程序 → 词法分析 → 语法分析 → 语义分析 → 中间代码生成 → 代码优化 → 目标代码生成 → 目标代码</u>；<br>其中<strong>中间代码生成和代码优化</strong>并不是每个编译器都必需的，与编译器相比，解释器<strong>参与运行控制，程序执行的速度慢</strong></p>
<p><strong>词法分析</strong>：根据语言的词法规则，对源程序进行逐个字符地描述，从中识别出一个个单词符号，针对词汇的检查<br><strong>语法分析</strong>：在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位；<br><strong>语义分析</strong>：分析各语法结构的含义，检查源程序是否包含语义错误，主要针对句子含义的检查；</p>
<p>@@ <strong>语法分析阶段</strong>的输入是<strong>记号流</strong>，若程序中的符号不匹配，则会在<strong>语法分析阶段</strong>检查出错误<br><strong>记号流</strong>：词法分析的输出是记号流，也就是语法分析的输入。<br><strong>源程序</strong>：词法分析的任务是把源程序的字符串转换成单词符号序列<br><strong>分析树</strong>：如果没有语法错误，语法分析后就能正常的构造出语法树</p>
<p>@@ <strong>语法错误</strong>是指语言结构上的使用错误，是指编译时所发现的程序错误，如<strong>单词拼写错误、标点符号错误、表达式中缺少操作数、符号不匹配</strong>等有关语言结构上的错误 [<u>语法分析阶段可以发现程序中所有的语法错误、但是不能在语义分析阶段发现程序中的所有语义错误(循环越界)</u>]</p>
<p>@@ 若程序在运行时陷入死循环，则情况属于<strong>动态的语义错误</strong>；在编译过程中，进行类型分析和检查是<strong>语义分析</strong>阶段的一个主要工作。**<u>死循环，零除数，其他逻辑错误</u><strong>是属于</strong>动态语义错误<strong>。语义检查时不检查动态语义，因此</strong><u>编译正确的程序不包含语法错误</u>**</p>
<p>@@ 高级程序设计语言不依赖具体的<strong>机器硬件</strong>；程序中局部变量的值在运行时<u>可以改变</u>，局部函数只能在函数内部使用，其作用域是从定义位置起至函数体或复合语句体结束位置。</p>
<p>@@ 在编写C&#x2F;C++时，若表达式中引用的变量从定义到使用始终没有赋值，则该变量中的值表现为一个<strong>随机数</strong>，这样对表达式的求值结果就是不确定的了。故[可以通过编译并运行，但运行结果不一定是期望的结果]</p>
<p>@@ 关于高级程序设计语言翻译的叙述中正确的是<strong>目标代码生成阶段的工作与目标机器的体系结构密切相关</strong></p>
<p>@@ 变量与常量：<strong>变量具有类型属性，常量则没有</strong> [<u>常量在程序运行过程中不能修改</u>]</p>
<p>@@ 可视化程序设计是以”<strong>所见即所得</strong>“的编程思想为原创，力图实现编程工作的可视化，即随时可以看到结果，程序与结果的调整同步。可视化程序设计仅通过直观的操作方式即可完成界面的设计工作[其基于面向对象的思想，引入了控件的概念和事件驱动；程序开发遵循步骤：即<u>先进行界面的绘制工作，再基于事件编写程序代码，以响应鼠标、键盘的各种动作</u>]。可视化程序设计最大的有点是设计人员可以不用编写或只需要编写很少程序代码，就能完成应用程序的设计，极大提高设计人员的工作效率</p>
<p>@@ PHP不是标记语言，PHP，全称 Hypertext Preprocessor ，中文翻译“超文本预处理器”。是在 服务器 端执行的 脚本语言 ，尤其适用于 Web 开发并可嵌入 HTML 中。 </p>
<p>@@ 创建指向邮箱地址的连接**<code>&lt;a href = &quot;mailto:test@test.com&quot;&gt; test@test.com &lt;/a&gt;</code>** 使用**<code>&lt;mailto&gt;</code>**标签定义一个指向电子邮件地址的超级链接</p>
<p>@@ <strong>指针变量</strong>可以是全局变量也可以是局部变量 </p>
<p>@@ 若一个程序语言可以提供链表的定义和运算，则其运算时的<strong>数据空间必须采用堆存储分配策略</strong></p>
<p>@@ <strong>动态语言</strong>是指程序在运行时可以改变其结构，例如新的函数可以被引进、已有的函数可以被删除等，在结构上的变化。动态语言的类型检查是在运行时进行的。优点是方便阅读，不需要写非常多的与类型相关的代码；缺点是不方便调试，命名不规范时会读不懂、不利于理解。事实上脚本语言都是动态语言，而动态语言都是解释型语言，不管它们是否是面向对象的语言 ；C语言属于<strong>静态语言</strong>，其所有成分可在编译时确定</p>
<p>@@ HTML<code>&lt;body&gt;</code>元素中，<strong>vlink</strong>属性用于定义超链接被鼠标点击后所显示的颜色<br><strong>alink</strong>：用于设置正在被击中的链接的颜色<br><strong>vlink</strong>：用于设置已使用的链接的颜色<br><strong>bgcolor</strong>：用于设置文档整体背景颜色<br><strong>background</strong>：用于设置背景图片的URL</p>
<p>@@ XML文档语法规范中：<strong>标记之间不可以交叉嵌套</strong></p>
<p>@@ <strong>动态</strong>绑定是指在运行时把过程调用和响应调用所需要执行的代码加以结合。<strong>运行时结合</strong>是<strong>动态绑定</strong>、<strong>编译时结合</strong>是<strong>静态绑定</strong></p>
<p>@@ 汇编程序的功能是将用<strong>汇编语言</strong>写的源程序翻译成机器指令程序。汇编程序的基本工作包括将一条可执行汇编语句转换成对应的机器指令；处理源程序中出现的伪指令。由于汇编指令中形成操作数指令的部分可能出现后面才会定义的符号，所以汇编程序一般需要两次扫描源程序才能完成翻译过程</p>
<p>@@ 对高级语言源程序进行编译或解释处理的过程中，需要不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入<strong>符号表</strong> [这些信息一般以表格形式存储于系统中]</p>
<p>@@ 将高级语言源程序翻译称目标程序的是<strong>编译程序</strong></p>
<p>@@ 将高级语言源程序翻译为可在计算机上执行的形式有多种不同的方式，其中<strong>编译方式生成逻辑上与源程序等价的目标程序，解释方式不生成</strong>[为源程序中变量所分配的存储单元的地址属于<strong>逻辑地址</strong>]<br>编译语言是一种以编译器来实现的编程语言，它不像直译语言一样，由解释器将代码一句一句运行，而是以编译器，先将代码编译为机器码，再加以运行。将某一种程序设计语言写的程序翻译成等价的另一种语言的程序的程序，称为编译程序</p>
<p>@@ 将高级语言源程序通过编译或解释方式进行翻译时，可以先生成与源程序等价的某种中间代码。<strong>后缀式和三地址码是常用的中间代码</strong>。[不同高级程序语言可以产生同一种中间代码]<br><strong>中间代码</strong>的作用是<u>可使程序的结构再逻辑上更为简单明确</u>(<strong>有利于进行与机器无关的优化处理，优化一般建立在对程序的控制流和数据流分析的基础之上, 与机器无关</strong>)，特别是可以使目标代码的优化比较容易实现。中间代码由很多形式，常见的由**<u>逆波兰记号(后缀式)、四元式、三元式(三地址码)、语法树</u><strong>，它们的共同特点是与具体的机器无关，不依赖于具体的计算机。</strong>中间代码**是源程序的一种内部表示，称中间语言。<u>中间代码不依赖于具体的机器、使用中间代码可提高编译程序的可移植性、中间代码可以用树或图表示</u></p>
<p>@@ 编译程序不参加与用户程序的运行控制，而解释程序则参与。编译程序(编译器)则是将源程序翻译成目标语言程序，然后再计算机上运行目的程序。再解释方式下。翻译源程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。</p>
<p>@@ 编译和解释是实现高级程序设计语言翻译的两种基本形式，<u><strong>在编译方式下，必须进行词法、语法和语义分析，然后再产生源程序的目标代码</strong></u></p>
<p>@@ 对高级语言源程序进行编译的过程可分为多个阶段，分配寄存器的工作再<strong>目标代码生成</strong>阶段进行。[<strong>目标代码生成</strong>是编译器工作的最后一个阶段，这一阶段的任务是把中间代码变换成特定机器上的绝对指令代码、了重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密切相关，因此在目标代码生成阶段分配寄存器。]</p>
<p>@@ 汇编程序输入的是用汇编语法书写的源程序，输出的是用机器语言表示的目标程序[<u>汇编语言源程序中的指令语句将被翻译成机器代码</u>、<u>汇编程序以汇编语言源程序为输入，以机器语言表示的目标程序为输出</u>、<u>汇编语言的指令语句必须具有操作码字段，可以没有操作数字段</u>]</p>
<p>@@ 编译过程中，对高级语言程序语句的翻译主要考虑声明语句和可执行语句。对声明语句，主要是将所需要的信息正确地填入合理组织的<strong>符号表</strong>中；对可执行语句，则是<strong>翻译成中间代码或目标代码</strong></p>
<p>@@ <strong>编译</strong>和<strong>解释</strong>是语言处理的两种基本方式：<br><strong>编译过程</strong>包括(词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成等阶段)，以及**<u>符号表管理</u><strong>和</strong><u>出错处理模块</u>**<br><strong>解释过程</strong>在词法、语法和语义分析方面与编译程序的工作原理基本相同，但是在运行用户程序时，它直接执行<strong>源程序或源程序的内部形式</strong><br>这两种语言处理程序的根本区别：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程；而在解释方式下，解释程序和源程序(某种等价表示)要参与到程序的运行过程中，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序，而编译器则需要将源程序翻译成独立的目标程序</p>
<p>@@ <strong>移进—归约</strong>分析法是编译程序(解释程序)对高级语言源程序进行语法分析的一种方法，属于<strong>自下而上</strong>的语法分析方法<br><strong>递归下降分析法、预测分析法</strong> → 是<u><strong>自上而下</strong></u>分析法<br><strong>移进-归约分析法</strong> → 是**<u>自下而上</u>**分析法</p>
<p>@@ 已知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>对B进行反编译，不能还原出源程序A</strong><br>编译是将高级语言源程序翻译成机器语言程序，<u>反编译是编译的逆过程</u>，<u><strong>反编译</strong>通常不能把可执行文件还原成高级语言源程序，只能转换成功能上等价的汇编程序</u></p>
<p>@@ 对于表达式<code>a or ((c&lt;d) and b)</code>，当<strong>a为true</strong>时可进行<strong>短路计算</strong>，最后计算的是or，对 <strong>或运算</strong> ，只要有一个真则结果为真，此题当a为true时，可进行短路计算，直接得到后面的结果</p>
<p>@@ 文法分为4种类型，程序设计语言的大多数语法现象可用<strong>乔姆斯基</strong>的<strong>上下文无关文法</strong>描述</p>
<p>@@ 在仅由字符a、b构成的所有字符串种，其中<u>以b结尾的<strong>字符串集合</strong></u>可用正则表达式为<br>$(b|ab)^<em>b$表示的<strong>字符串集合</strong>为<code>&#123;b,bb,abb,bbb,abab,bbbb,abbb,babb,...&#125;</code><u>除了以b结尾, 还要求每个a后面至少有1个b</u> 不符合题意只要有b结尾的！！<br>$(a|b)^</em>b$ 表示的<strong>字符串集合</strong><code>&#123;b,ab,bb,aab,abb,bab,bbb,aaab,aabb,abab,abbb,baab,babb,bbab,...&#125;</code></p>
<p>@@ 表达式采用逆波兰式表示时，利用<strong>栈</strong>进行求值<br>后缀式(逆波兰式)表达方式把运算符写在运算对象后面，**把a+b写成ab+**，所以也称为后缀式。借助栈可以方便地对后缀式进行求职。</p>
<p>@@ 与算术表达式**(a+(b-c))*d**对应的树是  求值运算处理顺序是：先进行b-c，然后与a相加，最后再与d相乘[中序遍历二叉树即可得出]</p>
<p>@@ 算数表达式**(a-b)<em>(c+d)<strong>的后缀式是</strong>ab-cd+**</em>  后缀式(逆波兰式)</p>
<p>@@ 算术表达式<em>*a+(b-C)*d**的后缀式是</em><em>abc-d</em>+** 利用逆波兰式，但是要把得到的步骤式子当成整体<br>原式&#x3D;<code>a+bC-*d</code> &#x3D;<code>a+bC-d*</code>&#x3D;<code>abC-d*+</code>  其中的着重点在于把bC-变成一个整体<strong>bC- * d</strong>再用逆波兰式 <strong>bC-d</strong>*<br>算术表达式**(a-b)<em>c+d<strong>的后缀式是</strong>ab-c</em>d+**</p>
<p>@@ 逻辑表达式<code>&quot;a^bvc^(bvx&gt;0)&quot;</code> 的后缀式是**<code>ab^cbx0&gt;v^v</code>**<br>此题有大坑   <code>^是&quot;与&quot;门的意思、v是异&quot;或&quot;门的意思</code>；<br><u>逻辑与运算</u>的优先级高于<u>逻辑或运算</u><br>“<strong>逻辑与运算</strong>“ 表达式 “<code>x^y</code>“的短路求值逻辑是：若x为假，则可知”<code>x^y</code>“的值为假，无需再对y求值。因此只有在x为真时继续对y求值<br>“<strong>逻辑或运算</strong>“ 表达式 “<code>xvy</code>“的短路求值逻辑是：若x为真，则可知”<code>xvy</code>“的值为真，无需再对y求值。因此只有在x为假时继续对y求值<br>对于逻辑表达式<code>&quot;a^bvc^(bvx&gt;0)&quot;</code>，从运算符的优先级方面考虑需先对”<code>a^b</code>“求值。然后对”<code>c^(b^x&gt;0)</code>“求值，最后进行对<code>&quot;v&quot;</code>运算，因此后缀式是**<code>ab^cbx0&gt;v^v</code>**</p>
<p>@@ 递归下降分析方法是一种<strong>自上而下的语法分析</strong><br>程序式设计语言的绝大多数语法规则可以采用<strong>上下文无关文法</strong>进行描述。语法分析方法有多种，根据产生语法树的方向，可分为<u><span style = "color:red"><strong>自底向上</strong></span>[算符优先分析法、LR分析法]</u>     <u><strong><span style = "color:red">自顶向下</span></strong>[递归下降分析法、预测分析法]</u>两类。</p>
<p>@@ 对于大多数通用程序设计语言，用<strong>上下文无关文法</strong>描述其语法即可<br>文法分成四种类型：0型、1型、2型、3型。<br><strong>0型文法</strong>也称为短语文法，其能力相当于图灵机，任何0型语言都是递归可枚举的；反之，递归可枚举集也必定是一个0型语言<br><strong>1型文法</strong>也称为上下文有关文法，这种文法意味着对非终结符的替换必须考虑上下文<br><strong>2型文法</strong>也称为上下文无关文法，非终结符的替换无需考虑上下文【通用程序设计语言绝大多数使用上下文无关文法(此文法拥有足够强的表达能力来表示大多数程序设计语言的语法)】<br><strong>3型文法</strong>等价于正规式，因此也被称为正规文法或线性文法。</p>
<p>@@ 在c&#x2F;c++程序种，整型变量a的值为0且应用在表达式”c&#x3D;b&#x2F;a”种，则最可能发生的情形是<strong>运行时产生异常</strong><br>c&#x3D;b&#x2F;a符合c&#x2F;c++语言的语法逻辑，编译时不会报错，运行时，代入a的值，发生错误</p>
<p>@@ 对高级语言源程序进行编译过程中，有限自动机(NFA或DFA)是进行<strong>词法分析</strong>的适当工具<br>词法分析的任务是把构成源程序的字符串转换成单词符号序列。有限自动机是一种识别装置的抽象概念，它能准确地识别正规集。有限自动机分为两类：<strong>确定的有限自动机(DFA)<strong>和</strong>不确定的有限自动机(NFA)</strong></p>
<p>@@ L&#x3D;{$a^n$$b^n$|n&gt;&#x3D;1}<strong>不能用正规式表示，也不能通过有限自动机识别</strong>[此字符串的特点是a的个数与b的个数相同，且所有的a都在b之前]，因为该集合不是正规集，不能用正规式表示。而语言**L&#x3D;{$a^m$$b^n$|m≥0, n≥1}**的正规式表达式式<code>a*bb*</code>  因为在此集合中表示，若干个a之后跟若干个b，a可以不出现，b至少出现1次。</p>
<p>@@ 包含8个成员的开发小组的沟通路径最多有<strong>28</strong>条 [任意小组成员之间均可能有沟通路径，则可用完全连通图来对开发小组的沟通路径建模，最多的沟通路径为<strong>完全连通图的边数</strong>，即n个成员的开发小组的沟通路径是<strong>n(n-1)&#x2F;2</strong>，因此8个成员的开发小组沟通路径最多有28条]</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/cbacb3bb4e0bb351d573b25f7a61a12cfdcddc4a/data/%E7%A1%AE%E5%AE%9E_%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A9%E6%9C%BA.png" style="zoom: 67%;" />

<p>@@ 一个文法的语言是从文法能产生的句子的集合。<u><strong>一个文法产生的句子是从文法开始符号发出推导出的所有终结符号串</strong></u></p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>@@ 从减少成本和缩短研发周期考虑，要求<strong>嵌入式操作系统</strong>能运行在不同的<strong>微处理器平台</strong>上，能针对硬件变化进行结构与功能上的配置。该要求体现了嵌入式操作系统的<strong>可定制性</strong><br><strong>嵌入式操作系统的特点：</strong><br>① <strong>微型化：</strong>从性能和成本角度考虑，希望占用的资源和系统代码量少<br>② <strong>可定制：</strong>从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的<strong>微处理器平台</strong>上，能针对硬件变化进行结构与功能上的配置，以满足不同应用的需求<br>③ <strong>实时性：</strong>嵌入式操作性系统主要应用于过程控制、数据采集、传输通信、多媒体信息及关键要害领域需要迅速响应的场合，所以对实时性要求较高<br>④ <strong>可靠性：</strong>系统构建、模块和体系结构必须达到应有的可靠性，对关键要害应用还要提供容错和防故障措施<br>⑤ <strong>可移植性：</strong>为了提高系统的易移植性，通常采用<strong>硬件抽象层</strong>和<strong>板级支撑包</strong>的底层设计技术</p>
<p>@@ 在Linux中，要更改一个文件的权限设置可使用<strong>chmod</strong>命令，修改文件夹名可使用<strong>modify</strong>命令<br>Linux中只有一个根目录，用”&#x2F;“表示</p>
<p>@@ 计算机系统由<strong>硬件</strong>和<strong>软件</strong>两部分组成，通常把未配置软件的计算机称为裸机。操作系统目的是为了填充人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。从用户角度看，当计算机配置了操作系统后，用户不再直接使用计算机系统硬件，而是使用操作系统所提供的命令和服务去操纵计算机，操作系统已称为现代计算机系统中必不可少的最重要的系统软件，因此<strong>操作系统</strong>是<strong>用户</strong>与<strong>计算机之间</strong>的<u>接口</u><br><img src="https://raw.githubusercontent.com/P-luminary/images/9f871f12e0e525d3f04ed912fcaa537b19f5203a/data/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%9C%B0%E4%BD%8D.jpg" style="zoom:50%;" /></p>
<p>@@ 实时操作系统主要用于<strong>实时要求的过程控制</strong>等领域，实时系统对于来自外部的事件必须在<strong>被操控对象规定的事件内做出及时响应并对其进行处理</strong>。<br><strong>实时操作系统</strong>与<strong>分时操作系统</strong>的第一点区别就是：<br>① 交互性强弱不同，<u>分时系统</u>交互型强，<u>实时系统</u>交互型弱，但可靠性要求高<br>② 响应事件的敏感性强，对随机发生的外部事件必须在被控制对象规定的时间做出及时响应并对其进行处理<br>③ 系统的设计目的不同，<u>分时系统</u>是设计称一个多用方的通用系统，交互能力强；而<u>实时系统</u>大多数都是专用系统。</p>
<p>@@ <strong>嵌入式系统初始化</strong>过程分为3个主要环节，按照<u>自底向上</u>，<u>从硬件到软件</u>的次序依次为：<u><strong>片级初始化</strong>、<strong>板级初始化</strong>、<strong>系统级初始化</strong></u>。系统初始化主要任务是<strong>以软件初始化为主，主要进行操作系统的初始化</strong><br><strong>片级初始化：</strong><u>片级初始化完成嵌入式微处理器的初始化</u>，包括设置嵌入式微处理器的核心寄存器和控制寄存器、嵌入式微处理器核心工作模式和嵌入式微处理器的局部总线模式等。片级初始化把嵌入式微处理器从上电时的默认状态逐步设置成系统所要求的工作状态。这是一个纯硬件的初始化过程。<br><strong>板级初始化：</strong><u>板级初始化完成嵌入式微处理器以外的其他硬件设备的初始化</u>。另外，还需设置某些软件的数据结构和参数，为随后的系统级初始化和应用程序的运行建立硬件和软件环境。这是一个同时包含软硬件两部分在内的初始化过程。<br><strong>系统初始化：</strong><u>系统初始化过程以软件初始化为主，主要进行操作系统的初始化</u>。BSP将对嵌入式微处理器的控制权转交给嵌入式操作系统，由操作系统完成余下的初始化操作，包含加载和初始化与硬件无关的设备驱动程序，建立系统内存区，加载并初始化其他系统软件模块，如网络系统、文件系统等。最后，操作系统创建应用程序环境，并将控制权交给应用程序的入口。</p>
<p>@@ 设计操作系统时不需要考虑的问题是<strong>语言编译器的设计实现</strong><br>操作系统有两个重要作用：<br>① 通过资源管理提高计算机系统的效率，<strong>操作系统</strong>是计算机的资源管理者，它含有对系统软&#x2F;硬件资源实施管理的一组程序<br>② 改善人机界面，向用户提供有好的工作环境</p>
<p>@@ <strong>磁盘格式化</strong>是指把一张空白的盘划分称一个个小区域并编号，以供计算机存储和读取数据，格式化是一种纯物理操作，实在磁盘的所有数据区上写0的操作过程，同时对硬盘介质做一致性检测，并且标记出不可读和坏的扇区。由于大部分硬盘在出厂时已经格式化过，所以有在硬盘介质产生错误时才需要进行格式化。<br><strong>磁盘分区</strong>是将磁盘划分成一块块的存储区域。在传统的磁盘管理中，将一个硬盘分为两大类分区：主分区和扩展分区。主分区是能够安装操作系统、能够进行计算机启动的分区，这样的分区可以直接格式化，然后安装系统，直接存放文件。<br>磁盘里的文件都是按存储时间先后来排列的，理论上文件之间都是紧凑排列而没有空隙的。但是，用户常常会对文件进行修改，而且新增加的内容并不是直接加到原文件的位置的，而是放在磁盘存储空间的最末尾，系统会在这两段之间加上联系标识。当有多个文件被修改后，磁盘里就会有很多不连续的文件。一旦文件被删除，所占用的不连 续空间就会空着，并不会被自动填满，而且，新保存的文件也不会放在这些地方，这些 空着的磁盘空间，就被称作”磁盘碎片”。因此，硬盘的每个分区里都会有碎片。碎片太多，其他的不连续文件相应也多，系统在执行文件操作时就会因反复寻找联系标识，工作效率大大降低，直接的反映就是感觉慢。磁盘清理将删除计算机上所有不需要的文件（这些文件由用户或系统进行确认）。<br><strong>磁盘碎片整理</strong>就是通过系统软件或者专业的磁盘碎片整理软件对电脑磁盘在长期使用过程中产生的碎片和凌乱文件重新整理，释放出更多的磁盘空间，可提高电脑的整体性能和运行速度。</p>
<p>@@ 在WinXP操作系统中，用户利用”<strong>磁盘管理</strong>“程序可以对磁盘进行初始化、创建卷，<strong>可以选择使用FAT、FAT32或NTFS文件系统格式化券</strong>，通常将<code>&quot;C:\Windows\myprogram.exe&quot;</code>文件设置成<strong>只读</strong>和<strong>隐藏</strong>属性，以便控制用户对该文件的访问。这一级安全管理称之为<strong>文件级</strong>安全管理。<br>文件级安全管理是通过系统管理员或文件组对文件设置来控制用户对文件的访问。用户对文件的访问，将由用户<strong>访问权、目录访问权、文件属性</strong>三者的权限所确定。</p>
<p>@@ 假设磁盘臂位于15号柱面上，进程的请求序列如下表表示，如果采用<strong>最短移臂调度算法</strong>，那么系统的响应序列应为<strong>⑤①②④③⑥</strong></p>
<table>
<thead>
<tr>
<th>请求序列</th>
<th>柱面号</th>
<th>磁头号</th>
<th>扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>①</td>
<td>12</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>②</td>
<td>19</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>③</td>
<td>23</td>
<td>9</td>
<td>6</td>
</tr>
<tr>
<td>④</td>
<td>19</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>⑤</td>
<td>12</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>⑥</td>
<td>28</td>
<td>3</td>
<td>10</td>
</tr>
</tbody></table>
<p><strong>最短移臂调度算法</strong>，即有限响应距离比较近磁道的申请<br>1.当磁头位于15号柱面 (柱面号即磁道编号)，请求序列分别位于12号柱面(①⑤)、19号柱面(②④)、23号柱面(③)、28号柱面(⑥)<br>2.距离15号柱面最近的应该是12号柱面(①⑤)，优先响应(①⑤)，次序不限；</p>
<p>@@ P(Pass)(通过)消耗一个信号量  V(释放)发送一个信号量<br>V(S1)唤醒P(S1)：<strong>收银员进程操作</strong>只有等待着<strong>购书者</strong>拿出去前台后才能触发</p>
<p>@@ PV操作是操作系统提供的具有特定功能的原语，利用PV操作可以<strong>实现资源的互斥使用</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37063785/article/details/88802580">软考必考题型之PV操作_pv操作中p和v各代表什么-CSDN博客</a></p>
<p>@@ 某计算机系统中互斥资源R的可用数为8，系统中有3个进程P1、P2和P3竞争R，且每个进程都需要i个R，该系统可能会发生死锁的最小i值为：<strong>4</strong><br>本题对于R资源可用数为8，分配到3个进程中，为了让最后的i值最小，所以每个进程尽量平均分配，可以得到3、3、2的分配情况，此时如果假设i的取值为3，则必定不会发生死锁，当i&gt;3时系统会产生死锁，此时取整，即最小i值为4</p>
<p>@@ 常用的进程控制块的组织方式有<strong>链接方式</strong>和<strong>索引方式</strong>：<br>采用<span style ="color:red"><strong><u>链接方式</u></strong></span>是把具有同一状态的PCB，用其中的链接字链接成一个队列。这样可以形成<strong>就绪队列</strong>、若干个<strong>阻塞队列</strong>和<strong>空白队列</strong>等。其中的就绪队列常按进程优先级的高低排列，把优先级高的进程的PCB排在队列前面。此外，也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I&#x2F;O操作完成的队列和等待分配内存的队列等。<br>采用<span style ="color:red"><strong><u>索引方式</u></strong></span>是系统根据所有进程的状态<u><strong>建立若干索引表</strong></u>。例如，<strong>就绪索引表、阻塞索引表</strong>，并把各索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。<br><img src="https://raw.githubusercontent.com/P-luminary/images/dddb1b1a79e0de02dd213d846e7b7c8045a9dc70/data/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97.jpg"  /></p>
<p>@@ 某系统中有3个并发进程竞争资源R，每个进程都需要5个R，那么至少有<u><strong>13</strong>个R</u>，才能保证系统不会发生死锁。[<u>每个进程所需资源数-1，再相加，就是发生死锁的临界资源数</u>]<br><code>3(5-1)+1&lt;=y</code> 所以y＝13个</p>
<pre><code class="java">某系统有n个进程，每个进程需要x个同类资源，系统不会产生死锁的最少资源是多少？
★ 设：最少资源数位y个，满足如下表达式即可：★
n(x-1)+1&lt;=y
每个进程需要x个资源，初始时給每个进程x-1个资源，最后再給一个格外的资源，每当一个进程运行完后马上释放其占有的资源，其它进程可以申请资源继续运行
</code></pre>
<p>@@ 某系统中仅有5个并发进程竞争某类资源，且都需要3个该类资源，那么至少有<strong>11</strong>个该类资源，才能保证系统不会发生死锁。5×(3-1)+1&#x3D;11</p>
<p>@@ 某计算机系统页面大小为4k，进程的页面变换表如下。若进程的逻辑地址为2D16H。该地址经过变换后，其物理地址应为<strong>4D16H</strong></p>
<table>
<thead>
<tr>
<th align="center">页号</th>
<th align="center">物理块号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>4</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>根据题意，页面大小为4k，逻辑地址2D16H所在<strong>页号为2</strong>，页内地址为D16H，查看表后可知<strong>物理块号为4</strong>，该地址i过变换后，其物理地址应为物理块号4拼接上页内地址D16H，即十六进制4D16H</p>
<p>@@ <em>让我们来看一下这道13年上半年的软设选择题：</em><span style = "color:red"> <strong>图(a)中<u>B</u>；</strong></span><br><img src="https://raw.githubusercontent.com/P-luminary/images/be02605405d236b87be94947a28e00f477fd4bdf/data/%E9%98%BB%E5%A1%9E%E8%8A%82%E7%82%B9%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%8A%82%E7%82%B9.jpg"></p>
<p><span style = "color:red"><strong>图(b)中<u>C</u></strong></span><br>A. P1、P2、P3都是非阻塞节点，该图可以化简，是非死锁的<br>B. P1、P2、P3都是阻塞节点，该图不可以化简，是死锁的<br><span style = "color:red">C. P2是阻塞节点，P1、P3是非阻塞节点，该图可以化简，是非死锁的</span><br>D. P1、P2是非阻塞节点，P3是阻塞节点，该图不可以化简，是死锁的</p>
<pre><code class="java">★ 如何看进程资源图呢？
P:进程    R:一类资源     R中的圆圈数：该类资源有几个
★ 字母箭头都是啥意思？
R→P(R指向P)：分配一份R类资源給进程P
P→R(P指向R)：进程P申请一份R类资源
★ 判断一个进程节点是否堵塞？
读图时，先看资源分配R→P，再看资源申请P→R
【注意】
读图时，不要将同时存在R→P、P→R双向箭头的情况理解成：
P先申请一个资源，R再分配一个资源给P！

可能存在的情况：
① R中所有资源分配出去了(R→P)，而此时还有进程P向R申请资源(P→R)
此时申请资源R的进程P：成为阻塞节点
② R中所有资源没有全部都分配出去了(R→P)，而此时还有进程P向R申请资源(P→R)
此时申请资源R的进程P：成为非阻塞节点

★ 判断一个进程资源图是否是死锁的？
如果所有节点都是阻塞的———此进程图不可以化简，是死锁的
如果有节点不是阻塞的————此进程图可以花间，是非死锁的
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
</code></pre>
<h6 id="图a"><a href="#图a" class="headerlink" title="图a"></a>图a</h6><pre><code class="java">R1一共有2个资源，给P1、P2各分配一个，已经无可分配资源
此时P2还向R1申请1个资源，因为没有资源可以申请了，所以P2会阻塞；

同理，R2一共有3个资源，给P1分配1个、P2分配2个，已经无可分配资源
此时P1还向R2申请1个资源，因为没有资源可以申请了，所以P1也会阻塞；

因为P1、P2节点都阻塞了，所以此图无法化简，是死锁的
</code></pre>
<h6 id="图b"><a href="#图b" class="headerlink" title="图b"></a>图b</h6><pre><code class="java">R1一共有2个资源，给P1、P3各分配一个，已经无可分配资源
此时P2还向R1申请1个资源，因为没有资源可以申请了，所以P2会阻塞；

R2一共有3个资源，给P2、P3各分配一个，还剩1个可分配资源
此时P1向R2申请1个资源，因为还有可分配资源，所以P1不会阻塞；
（此时P3也向R2申请1个资源，同理P3也不会阻塞）
【这里要特别注意：P1、P3虽然同时都在申请剩下的1个资源，但是并不意味着这个资源申请已经被响应了，从而造成死锁的现象】
--------------------------------------------------------------------------
R1出去两个资源，R1资源数为0，此时P2申请R1资源，P2阻塞。R2总资源数3，出去2个资源。P1,P3申请R2资源，P1,P3非阻塞。[R2资源有3个，已分配2个，P3申请1个R2资源可以得到满足，故进程P3可以进行完毕释放其占有的资源。这样可以使得P1、P3都变成非阻塞节点，得到所需资源进行完毕，因此，该进程资源图是可以化简的]
</code></pre>
<p>@@ 在支持多线程的操作系统中，假设进程P创建了若干个线程，那么<strong>该进程中某线程的栈指针</strong>是不能被这些线程共享的。<u>在同一进程中的各个线程都可以共享进程所拥有的资源</u>，如访问进程地址空间中的每一个虚地址；访问进程所拥有的已打开文件、定时器、信号量机构等，但是<u>不能共享进程中某线程的栈指针</u> </p>
<p>@@ 假设系统采用PV操作实现进程同步与互斥。若n个进程<strong>共享两台打印机</strong>，那么信号量S的取值范围为 <strong>-(n-2) ~ 2</strong>。信号量初值等于资源数量，即为2，由于同时最多有2个进程访问打印机，其余进程必须处理等待状态，故S的最小值为 <strong>-(n-2)</strong> </p>
<pre><code class="java">·每个进程开始的时候执行P操作(信号量减一操作)，结束的时候执行V操作(信号量加一操作)。P作挂起阻塞，V为激活唤醒。信号量的原则是从左到右，从上到下。
·假设系统采用PV操作实现进程同步与互斥，若n个进程共享两台打印机，那么信号量S的取值范围为-(n-2)~2。两台打印机，所以最多等待状态的进程数就是(n-2)，
★★如果没有进程申请打印机，打印机的信号量就是2★★
信号量的值小于0，表示没有可用的资源，其绝对值表示阻塞队列中等待该资源的进程数。

·同步信号量，值为可用资源的个数。信号量的值小于0，则线程进行等待；信号量的值大于0，表示值为可用资源的个数。初始值为0。
·互斥信号量，只有两个值：0和1。0表示资源被占用，线程等待；1表示资源没有被占用，线程可以进入。初始值为1。
</code></pre>
<p>@@ 假设系统中有n个进程<strong>共享3台扫描仪</strong>，并采用PV操作实现进程同步与互斥。若系统信号量S的当前值为-1，**<u>进程P1、P2又分别执行了一次P(S)操作</u><strong>，那么信号量S的值应为___。<br>[<strong>当有进程运行时</strong>,其他进程访问信号量,信号量就会减1。S&#x3D;-1-2]<br>[当进程执行P(S)操作时，它试图将信号量S的值减去1。因此，如果</strong><u>进程P1和P2都执行了一次P(S)操作</u>**，并且信号量S的初始值为-1，那么它们会尝试将S的值减去1两次，结果是S的值变为-3。这是因为当信号量S的值为-1时，两个进程都尝试将其减去1，每次减去1后，S的值分别变为-2和-3。所以最终S的值为-3]</p>
<p>@@ 假设系统采用PV操作实现进程同步与互斥，若有n个进程共享一台扫描仪，那么当信号量S的值为-3时，表示系统中有<strong>3</strong>个进程等待使用扫描仪<br>[信号量不用减1是因为<strong>本题并没有进程运行</strong>]</p>
<p>@@ 假设某分时系统采用简单时间片轮转法，当系统中的用户数为n、时间片为q时，系统对每个用户的相应时间T&#x3D;(n*q) [<u>在分时系统中是将把CPU的时间分成很短的时间片轮流地分配給各个终端用户</u>]</p>
<p>@@ 如果系统采用信箱通信方式，当进程调用Send原语被设置为”等信箱”状态时，其原因是<strong>指定的信箱中存满了信件</strong>；因为Send原语是发送原语，如果系统采用信箱通信方式，那么当进程调用Send原语被设置成”<strong>等信箱</strong>“状态时，意味着指定的信箱存满了信件，无可用空间</p>
<p>@@ <span style = "color:red"><strong>绝对路径</strong>从根目录\开始</span>，本题book2.doc的绝对路径为 <code>\MyDrivers\user2\</code><br><span style = "color:blue"><strong>相对路径</strong>从当前目录下一级开始</span>，本题book2.doc的相对路径为 <code>user2\</code></p>
<p>@@ 直接索引即索引直接指向物理块，可用表示逻辑块号范围：0-4号<br>一级索引即索引节点指向的物理块用来存放地址项，可用表示256个地址项，即256个物理块<br>二级索引即索引节点指向的物理块，存放的是一级索引的地址块地址。一共有256个地址块用来存放以及索引</p>
<p>@@ 某文件系统采用多级索引结构。若磁盘块的大小为1k字节，每个块号占3字节，那么采用二级索引时的文件最大长度为<strong>116281</strong>k字节 。<br>磁盘块的大小为1KB，每个块号需占3B，因此一个磁盘物理块可存放1024&#x2F;3&#x3D;341个块号(取整)<br>采用一级索引时的文件最大长度为：341×1024&#x2F;1024&#x3D;341KB<br>采用二级索引时的文件最大长度为：341×341×1024&#x2F;1024&#x3D;116281KB</p>
<p>@@ 若系统正在将<strong>系统目录</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。<br>影响文件系统可靠性因素之一是文件系统的一致性问题。<u>很多文件系统是先<strong>读取磁盘块到主存</strong>，在主存进行修改，修改完毕再写回磁盘。</u> <strong>一致性检查</strong>包括 <u>块的一致性检查</u> 和 <u>文件的一致性检查</u></p>
<p>@@ 双击”xxx.jpg”文件名时，系统会自动通过建立的<strong>文件关联</strong>来决定使用什么程序打开该图像文件</p>
<h6 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h6><p>@@ 若系统正在将<strong>目录</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。很多文件系统是先读取磁盘块到主存，在主存进行修改，修改完毕再写回磁盘。</p>
<p>@@ 若某计算机系统的I&#x2F;O接口与主存采用统一编址，则输入输出操作是通过<strong>访存</strong>指令来完成的。<br>常用的I&#x2F;O接口编制方法有两种：<br>一是<strong>内存单元统一编址</strong>[将I&#x2F;O接口中有关的寄存器或存储部件看作存储器单元，与主存中的存储单元统一编址。内存地址和接口地址统一在一个公共的地址空间里，<u>对I&#x2F;O接口的访问就如同对主存单元的访问一样，可以用访问内存单元的指令访问I&#x2F;O接口</u>]<br>二是<strong>单独编址</strong>[通过设置单独的I&#x2F;O地址空间，为接口中的有关寄存器或存储部件分配地址码，需要设置专门的I&#x2F;O指令进行访问。这种编址方式的优点是不占用主存的地址空间，访问主存的指令和访问接口的指令不同。]</p>
<p>@@ I&#x2F;O设备管理软件一般分为4个层次。具体层次从上往下分别是**<u>用户级I&#x2F;O层、设备无关I&#x2F;O层、设备驱动程序、中断处理程序、硬件</u>** [用户五官射中硬件]</p>
<table>
<thead>
<tr>
<th>用户级I&#x2F;O层：发出I&#x2F;O调用</th>
</tr>
</thead>
<tbody><tr>
<td>设备无关I&#x2F;O层：设备名解析、阻塞进程、分配缓冲区</td>
</tr>
<tr>
<td>设备驱动程序：设置寄存器、检查设备状态</td>
</tr>
<tr>
<td>中断处理程序：I&#x2F;O完成后唤醒设备驱动程序</td>
</tr>
<tr>
<td>硬件：完成具体的I&#x2F;O操作</td>
</tr>
</tbody></table>
<p>@@ DMA工作方式下，在<strong>主存与外设</strong>之间建立了直接的数据链路</p>
<p>@@ 计算机运行过程中，cpu需要与外设进行数据交换。采用**<u>中断方式和DMA方式</u><strong>控制技术时，CPU与外设可并行工作。</strong>程序查询<strong>和</strong>中断方式<strong>都需要CPU来执行程序指令进行数据的输入和输出，DMA方式则不同，这是<u>一种不经过CPU而</strong>直接从内存存取数据**的数据交换模式</u>。[DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传达，数据传达完毕再把信息反馈给CPU即可]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0ab1d3a552633777cd974d25748160cc91ad68a5/data/%E7%A3%81%E7%9B%98CT%E9%A2%98.jpg"></p>
<p>@@ 某磁盘有100个磁道，磁头从一个磁道移至另一个磁道需要6ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均距离为10个磁道，每块的旋转延迟时间及传输时间分别为100ms和20ms，则读取一个100块的文件需要<strong>18000</strong>ms。[访问一个数据块的时间应为寻道时间加旋转延迟时间及传输时间之和。根据题意，每块的旋转延迟时间及传输时间共需120ms，磁头从一个磁道移至另一个磁道需要6ms，但逻辑上相邻数据块的平均距离为10个磁道，即读完一个数据块到下一个数据块寻道时间需要60ms。通过上述分析，本题访问一个数据块的时间T&#x3D;120ms+60ms&#x3D;180ms，而读取一个100块的文件共需要18000ms。]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a5957207201dabc57750a4659ee50c53b8017761/data/%E7%A3%81%E7%9B%98%E8%87%82%E8%86%80%E5%93%8D%E5%BA%94%E5%BA%8F%E5%88%97%E9%A2%98.png"></p>
<p>@@ 假设某磁盘的每个磁道划分成9个物理块，每块存放1个逻辑记录。逻辑记录R0,RI,…,R8存放在同一个磁道上，记录的安排顺序如下表所示：如果磁盘的旋转速度为27ms／周，磁头当前处在RO的开始处。若系统顺序处理这些记录，使用单缓冲区，每个记录处理时间为3ms，则处理这9个记录的最长时间为<strong>246ms</strong>：若对信息存储进行优化分布后，处理9个记录的最少时间为<strong>54ms</strong> 。</p>
<table>
<thead>
<tr>
<th align="center">物理块</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑记录</td>
<td align="center">R0</td>
<td align="center">R1</td>
<td align="center">R2</td>
<td align="center">R3</td>
<td align="center">R4</td>
<td align="center">R5</td>
<td align="center">R6</td>
<td align="center">R7</td>
<td align="center">R8</td>
</tr>
</tbody></table>
<p>[因为系统使用的是单缓冲区，且顺序处理9个记录，每个记录处理时间为3ms，加上读写时间，总的时间就超过3ms了。而磁盘旋转一圈的时间为27ms，也就是说，当系统读取第0个记录后，正在处理的过程中，磁盘已经旋过了第1个记录。那么，要读取第1个记录，就需要磁盘再次旋转到第1个记录（即磁盘旋转1圈后，27+3&#x3D;30ms)。同理，要读取第2个记录时，也需要等30ms。这样，要读取后面8个记录，需要8x30&#x3D;240ms，同时加上处理第0个记录的时间（3ms）和处理第8个记录的时间（3ms)，共需246ms。] [对于第二种情况，若对信息进行分布优化的结果如下所示：从上表可以看出，当读出记录RI并处理结束后，磁头刚好转至R2记录的开始处，立即就可以读出并处理，因此处理9个记录的总时间为：<u>9X (3ms （读记录）+3ms （处理记录）)&#x3D;9X6ms&#x3D;54ms</u>]</p>
<p>@@ 在移臂调度算法中，<strong>先来先服务和最短寻找时间优先</strong>算法可能会随时改变移动臂的运动方向</p>
<p>@@ 概要设计文档的内容包括<strong>系统构架、模块划分、系统接口、数据设计</strong>四个方面</p>
<p>@@ 三层C&#x2F;S体系结构由逻辑上互相分离的**<u>表示层、业务层、数据层</u><strong>构成。其中</strong>表示层<strong>向客户提供数据，</strong>业务层<strong>实施业务相关数据规划，</strong>数据层**定义数据访问表中。</p>
<p>@@ 对软件过程的考虑：<u>在整体上按照<strong>瀑布模型</strong>的流程实施项目开发</u>，以方便对项目的管理；但在软件的实际创建中，则将软件系统按照功能分为许多增量构件，并以构件为单位逐个地创建与交付，直到全部增量构件创建完毕，并都被集成到系统之中交付用户使用。</p>
<table>
<thead>
<tr>
<th align="left">模型</th>
<th align="left">详情信息</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>增量</strong>模型</td>
<td align="left">又称渐增模型，也称为有计划的产品改进模型，从一组给定的需求开始，通过构造一系列可执行中间版本来实施开发活动。第一个版本纳入一部分需求，下一个版本纳入更多的需求，直到系统完成。每个中间版本都需要执行必需的过程、活动和任务。增量模型是 [<u>瀑布模型+原型</u>] 进化模型的综合<br />[增量模型具有非常显著的优越性，但增量模型对软件设计有更高的技术要求，特别是对软件体系结构，要求它具有很好的开放性与稳定性，能够顺利地实现构件的集成；<strong>不必等到整个系统开发完成就可以使用</strong>、<strong>可以使用较早的增量构件作为原型</strong>、<strong>优先级最高的服务先交付</strong>, 这样<u>最重要的服务接收最多的测试</u>。<span style = "color:red">其<strong>难点</strong>是<u>如何进行模块的划分</u></span>。]<br />融合了瀑布模型的基本成分和原型实现迭代的特征，该模型随着日程时间的进展而交错的线性序列。<br />增量式开发的<strong>主要优点包括</strong>：<br/>1．由于能够在较短的时间内向用户提交一些有用的工作产品，因此能够解决用户的一些急用功能。<br/>2．由于每次只提交用户部分功能，用户有较充分的时间学习和适应新的产品。<br/>3．对系统的可维护性是一个极大的提高，因为整个系统是由一个个构件集成在一起的，当需求变更时只变更部分部件，而不必影响整个系统。<br/><strong>主要缺点包括</strong>：<br/>1．由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。<br/>2．在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。<br/>3．增量包之间存在相交的情况且未很好处理</td>
</tr>
<tr>
<td align="left"><strong>瀑布</strong>模型</td>
<td align="left">将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段的过程。将软件生存周期各个活动规定为线性顺序链接的若干阶段的模型[<u>计划、分析、设计、编程、测试、维护</u>]。规定了由前至后，相互衔接的固定次序，如同瀑布流水，逐级下落。是一种理想的开发模式，但<span style = "color:red"><u><strong>缺乏</strong>灵活性，无法解决软件需求不明确或不准确的问题；不适用于开发初期对软件需求缺乏准确全面认识的情况</u></span>；<span style = "color:blue"><strong>优点</strong>：可强迫开发人员采用规范的方法；严格规定了各阶段必须提交的文档；要求每个阶段结束后，都要进行严格的审核。</span></td>
</tr>
<tr>
<td align="left"><strong>原型</strong>模式</td>
<td align="left">开发人员<u>快速地构造整个系统</u>或者<u>系统的一部分以理解或澄清问题</u>。增量模型是把软件产品作为一系列的增量构件来设计、编码、集成和测试，每个构件由多个相互作用的模块组成，并且能够完成特定的功能；并非所有的需求在系统开发之前都能准确地说明和定义。<span style = "color:blue">采用了动态定义需求的方法。适用于需求不明确的开发环境</span>；可以有效地捕获系统需求</td>
</tr>
<tr>
<td align="left"><strong>喷泉</strong>模型</td>
<td align="left">喷泉模型是典型的面向对象生命周期模型，在开发过程中<strong>以用户需求为动力</strong>，以对象为驱动，适合于面向对象的开发方法；<span style = "color:blue">喷泉模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性；模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统</span>；”喷泉”一词本身体现了迭代和无间隙特性。<strong>迭代意味着模型中的开发活动常常需要重复多次</strong>，在迭代过程中不断地完善软件系统；无间隙是指在开发活动之间不存在明显的边界。</td>
</tr>
<tr>
<td align="left"><strong>螺旋</strong>模型</td>
<td align="left">将开发活动和风险管理结合起来，以减小风险。将<u>瀑布模型</u>与<u>快速原型模型</u>结合起来，还增加了风险分析；螺旋模型包含了四个方面的活动：制订计划、风险分析、实施工程、客户评估，<span style = "color:blue">螺旋模型适用于<strong>复杂的大型软件</strong></span>；</td>
</tr>
</tbody></table>
<p>@@ 若用户<u>需求<strong>不清晰</strong></u>且经常发生变化，但<u>系统规模不太大且不太复杂</u>，则最适宜采用<strong>原型化</strong>开发方法<br>对于<u>数据处理领域不太复杂的软件，若系统规模不太大且不太复杂，需求变化也不大</u>，则最适宜采用<strong>结构化</strong>开发方法</p>
<p>@@ 软件工程的基本要素包括<strong>方法、工具、过程</strong></p>
<p>@@ 在<strong>概要</strong>设计阶段选择适当的解决方案，将系统分解为若干个子系统，建立整个系统的体系结构。<br>软件设计的任务是基于需求分析的结果建立各种设计模型，给出问题的解决方案。<br><strong>从工程管理的角度，可以将软件设计分为两个阶段：</strong><u>概要设计阶段</u>和<u>详细设计阶段</u>。<br><strong>概要设计阶段</strong>进行软件体系结构的设计、数据设计和接口设计；<br><strong>详细设计阶段</strong>进行数据结构和算法的设计。面向对象设计方法中，概要设计阶段进行体系结构设计、初步的类设计&#x2F;数据设计、结构设计：详细设计阶段进行构件设计。结构化设计和面向对象设计是两种不同的设计方法，结构化设计根据系统的数据流图进行设计，模块体现为函数、过程及子程序：面向对象设计基于面向对象的基本概念进行，模块体现为类、对象和构件等。</p>
<p>@@ “软件产品必须能够在3秒内对用户请求作出响应”属于软件需求中的<strong>非功能需求</strong>。<br>软件需求是软件系统必须完成的事以及必须具备的品质。软件需求包括<strong>功能需求、非功能需求和设计约束</strong>三个方面的内容。功能需求是所开发的软件必须具备什么样的功能：非功能需求是指产品必须具备的属性或品质，如可靠性、性能、响应时间和扩展性等等；设计约束通常对解决方案的一些约束说明。”软件产品必须能够在3秒内对用户请求作出响应”主要表述软件的响应时间，属于非功能需求</p>
<p>@@ 软件复杂性度量是软件度量的一个重要分支。参数有很多主要包括：<br>①<strong>规模</strong>。即指令数或者源程序行数；②<strong>难度</strong>。通常由程序中出现的操作数所决定的量来表示；<br>③<strong>结构</strong>。通常用与程序结构有关的度量来表示；④<strong>智能度</strong>。即算法的难易程度</p>
<p>@@ 基于构件的软件开发，主要强调在构建软件系统时复用已有的软件”构件”，在检索到可以使用的构件后，需要针对新系统的需求对构件进行<strong>合格性检验、适应性修改</strong>，然后集成到新系统中</p>
<p>@@ 程序的三种基本控制结构式<strong>顺序、选择和重复</strong></p>
<p>@@ 软件工程每一个阶段结束前，应该着重对可维护性进行复审。在系统设计阶段的复审期间，应该从<strong>容易修改、模块化和功能独立的目的</strong>出发，评价软件的结构和过程。可维护性式所有软件都具有的基本特点，必须在开发阶段保证软件具有可维护性的特点。</p>
<p>@@ I&#x2F;O软件隐藏了I&#x2F;O操作实现的细节。I&#x2F;O软件向用户提供的式逻辑接口。I&#x2F;O软件将硬件与较高层次的软件隔离开来，而最高层软件向硬件提供一个友好的、清晰的、统一的接口，方便用户使用。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/软考" style=color:#ffa2c4>
                软考
            </a>
        </span>
        
    </div>

    <a href="/2024/01/16/软考/软件设计师刷题考点/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        

        <span class="current">
            2
        </span>

        
        <span>
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
            
            <a href="/page/4">
                <span class="page-num">
                    4
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/12">
                <span class="page-num">
                    12
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/3/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>