
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2024/01/15/后端/SpringMVC[Mapping,中文乱码,Restful及跨域,JSON序列化,非简单请求,拦截器]/">
        <h2>
            SpringMVC[Mapping,中文乱码,Restful及跨域,JSON序列化,非简单请求,拦截器]
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring MVC入门</td>
<td>Spring MVC开发流程与环境配置</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>接收Web数据</td>
<td>Spring MVC参数接收与数据绑定</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>URL Mapping</td>
<td>讲解URL绑定过程</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>中文乱码问题</td>
<td>解决请求与相应中文乱码</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>拦截器</td>
<td>Spring MVC拦截器的使用</td>
<td>★★★</td>
</tr>
</tbody></table>
<h1 id="Restful开发风格-主流"><a href="#Restful开发风格-主流" class="headerlink" title="Restful开发风格 [主流]"></a>Restful开发风格 [主流]</h1><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Restful风格介绍</td>
<td>介绍Restful开发规范</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Restful开发实战</td>
<td>实例讲解Restful在Spring MVC中的实现</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>JSON序列化</td>
<td>通过相应输出数据</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Restful的跨域问题</td>
<td>分析跨域问题的来源与解决办法</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h3 id="Spring-MVC-Model-View-Controller-中介"><a href="#Spring-MVC-Model-View-Controller-中介" class="headerlink" title="Spring MVC[Model+View+Controller(中介)]"></a>Spring MVC[<u>Model+View+Controller(中介)</u>]</h3><p>比servlet方便许多 简化web程序的开发</p>
<ul>
<li>Spring MVC是Spring体系的轻量级Web MVC框架</li>
<li>Spring MVC的核心<strong>Controller</strong>控制器，用于处理请求，产生相应</li>
<li>Spring MVC基于Spring IOC容器运行，所有对象被IoC管理</li>
</ul>
<h6 id="学习向导"><a href="#学习向导" class="headerlink" title="学习向导"></a>学习向导</h6><ul>
<li>Spring MVC入门</li>
<li>Spring MVC数据绑定</li>
<li>Restful 开发风格</li>
<li>Spring MVC拦截器</li>
</ul>
<h3 id="Spring-MVC环境配置"><a href="#Spring-MVC环境配置" class="headerlink" title="Spring MVC环境配置"></a>Spring MVC环境配置</h3><h5 id="IDEA环境下创建Maven-WebApp"><a href="#IDEA环境下创建Maven-WebApp" class="headerlink" title="IDEA环境下创建Maven WebApp"></a>IDEA环境下创建Maven WebApp</h5><p>Project Structure 点加号 添加Web 右侧Path是Web描述符所存储的路径<br><code>C:\Users\Pluminary\Desktop\SpringMVC\src\main\webapp\WEB-INF\web.xml</code><br>Deployment descriptor version &#x3D;&gt; 3.1<br>下面的 Web Resource Directory【用于目录存储页面】<br><code>C:\Users\Pluminary\Desktop\SpringMVC\src\main\webapp</code><br>再次点下方的Create Artifact<br>右上角Type：<br><strong>Web Application: Exploded 目录方式运行</strong><br>Web Application: Archive 打包成war包运行<br>配置Tomcat Server &#x3D;&gt; Deployment 添加当前工程 SpringMVC:Web exploded<br>下面的Application context: 设置为 <strong>&#x2F;</strong>    只访问localhost即可<br>Server选项框里的 On ‘Update’ action: 把Restart server 改成 Update classes and resources【热部署】<br>当页面源代码发生变化时 不需要重启 </p>
<ul>
<li>Maven依赖Spring-WebMVC</li>
<li>web.xml配置DispatcherServlet</li>
<li>配置applicationContext的mvc标记</li>
<li>开发Controller控制器</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;first-springmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.28&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
&lt;!--    DispatchServlet 对所有请求进行拦截  --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
&lt;!--        DispatcherServlet是Spring MVC是最核心的对象
            DispatcherServlet用于拦截http请求
            并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理
--&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;!--        在Web应用启动时自动创建Spring IoC容器,并初始化DispatcherServlet --&gt;
&lt;!--        applicationContext.xml 初始化参数 启动时候加载--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
&lt;!--        &quot;/&quot; 所有请求都要拦截--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
&lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
   及子包中拥有以下注解的对象：
       @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
       @Service     ...Service类上 业务逻辑类
       @Controller 描述SpringMVC的控制器类
       @Component  无法确定的类型种类
   --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
&lt;!--    启用Spring MVC的注解开发模式--&gt;
    &lt;mvc:annotation-driven/&gt;
&lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/TestController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TestController &#123;
//  将当前的方法绑定某个get方式请求的url  //localhost/t
    @GetMapping(&quot;/t&quot;)
//  直接向响应输出字符串数据,不跳转页面
    @ResponseBody
    public String test()&#123;
        return &quot;SUCCESS&quot;;
    &#125;
&#125;
</code></pre>
<p>添加依赖jar包进入项目工程 配置tomcat服务<code>Run/Debug Configurations</code> 中的 <code>Deployment</code> 点一下小铅笔修改 将右侧的Avaliable Elements中的依赖包全部put进入<br><code>404bug 配置都正常无误 寻找一下项目工程里的out/artifacts/WEB-INF/web.xml</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4e2dcf96e18f478fddb9049b2544a008edd8f706/data/SpringMVC%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"></p>
<h3 id="Spring-MVC数据绑定"><a href="#Spring-MVC数据绑定" class="headerlink" title="Spring MVC数据绑定"></a>Spring MVC数据绑定</h3><h5 id="URL-Mapping-URL映射"><a href="#URL-Mapping-URL映射" class="headerlink" title="URL Mapping(URL映射)"></a>URL Mapping(URL映射)</h5><ul>
<li>URL Mapping指将URL与Controller方法绑定</li>
<li>通过将URL与方法绑定，SpringMVC便可通过Tomcat对外暴露服务</li>
</ul>
<h5 id="URL-Mapping注解"><a href="#URL-Mapping注解" class="headerlink" title="URL Mapping注解"></a>URL Mapping注解</h5><ul>
<li>@RequestMapping - 通用绑定  &#x2F;&#x2F;<u>在全局用则是通用请求映射访问前缀 若在方法上则不区分get&#x2F;post请求</u></li>
<li>@GetMapping - 绑定Get请求</li>
<li>@PostMapping - 绑定Post请求</li>
</ul>
<p><code>@GetMapping(&quot;/g&quot;)   ======   @RequestMapping(value=&quot;/g&quot;,method=RequestMethod.GET)</code></p>
<pre><code class="java">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;first-springmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
    &lt;!--    DispatchServlet 对所有请求进行拦截  --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        DispatcherServlet是Spring MVC是最核心的对象
                    DispatcherServlet用于拦截http请求
                    并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理
        --&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--        在Web应用启动时自动创建Spring IoC容器,并初始化DispatcherServlet --&gt;
        &lt;!--        applicationContext.xml 初始化参数 启动时候加载--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        &quot;/&quot; 所有请求都要拦截--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
       及子包中拥有以下注解的对象：
           @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
           @Service     ...Service类上 业务逻辑类
           @Controller 描述SpringMVC的控制器类
           @Component  无法确定的类型种类
       --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--    启用Spring MVC的注解开发模式--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/TestController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TestController &#123;
    @GetMapping(&quot;/t&quot;) //localhost/t
    @ResponseBody //直接向响应输出字符串数据,不跳转页面
    public String test()&#123;
        return &quot;Hello Spring MVC&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping (&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
    @GetMapping(&quot;/g&quot;)
    @ResponseBody
    public String getMapping()&#123;
        return &quot;This is get method&quot;;
    &#125;
//  直接访问会出错 post请求如何访问 用进行html表单提交
    @PostMapping(&quot;/p&quot;)
    @ResponseBody
    public String postMapping()&#123;
        return &quot;This is post method&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Controller方法参数接收请求参数"><a href="#Controller方法参数接收请求参数" class="headerlink" title="Controller方法参数接收请求参数"></a>Controller方法参数接收请求参数</h3><h5 id="接收请求参数的常用做法"><a href="#接收请求参数的常用做法" class="headerlink" title="接收请求参数的常用做法"></a>接收请求参数的常用做法</h5><ul>
<li><h6 id="使用Controller方法参数接收"><a href="#使用Controller方法参数接收" class="headerlink" title="使用Controller方法参数接收"></a>使用Controller方法参数接收</h6></li>
</ul>
<pre><code class="java">&lt;form action=&quot;/m1&quot; method=&quot;post&quot;&gt;
    &lt;input name=&quot;username&quot;/&gt;
    &lt;input name=&quot;password&quot;/&gt;
&lt;/form&gt;
----------------------------------------------------
@PostMapping(&quot;/m1&quot;)
@ResponseBody
public String post(String username, Long password)&#123;
    return username + &quot;:&quot; + password;
&#125;
</code></pre>
<p>特殊的注解<code>@RequestParam(&quot;&quot;)</code> 接收特殊自定义的参数</p>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequestMapping(&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
    @GetMapping(&quot;/g&quot;)
    @ResponseBody
    public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName) &#123;
        System.out.println(&quot;managerName:&quot;+managerName);
        return &quot;This is get method&quot;;
    &#125;

    //    直接访问会出错 post请求如何访问 用进行html表单提交
    @PostMapping(&quot;/p&quot;)
    @ResponseBody
    public String postMapping(String username, String password) &#123;
        System.out.println(username + &quot;:&quot; + password);
        return &quot;This is post method&quot;;
    &#125;
&#125;

=========================
网页中输入 http://localhost/um/g?manager_name=lily
控制台返回 managerName:lily
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><h6 id="使用Java-Bean接收数据"><a href="#使用Java-Bean接收数据" class="headerlink" title="使用Java Bean接收数据"></a>使用Java Bean接收数据</h6></li>
</ul>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​         用<strong>实体对象</strong><code>User</code>进行接收多个对象的创建和注入以及类型转换 [一次性完成]</p>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
@PostMapping(&quot;/p1&quot;)
    @ResponseBody //只要拥有User属性和参数 就可以一起赋值
    public String postMapping1(User user, String username)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;This is post method&quot;;
    &#125;
</code></pre>
<pre><code class="java">User.java
//标准的java bean
public class User &#123;
    private String username;
    private Long password;
&#125; Setter + Getter
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30254749/article/details/123139736">踩坑记录：IDEA web项目out artifacts文件夹只包含WEB-INF_out artifacts无法生成test.html-CSDN博客</a></p>
<h3 id="综合训练：学员调查问卷"><a href="#综合训练：学员调查问卷" class="headerlink" title="综合训练：学员调查问卷"></a>综合训练：学员调查问卷</h3><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ul>
<li>利用数组或者List接收请求中的复合数据</li>
<li>利用@RequestParam为参数设置默认值</li>
<li>使用Map对象接收请求参数及注意事项</li>
</ul>
<h5 id="URI绝对路径与相对路径"><a href="#URI绝对路径与相对路径" class="headerlink" title="URI绝对路径与相对路径"></a>URI绝对路径与相对路径</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/7faa031203ba69b146426bd6c3fa7431902da258/data/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%841.jpg"></p>
<h5 id="相对地址的应用案例"><a href="#相对地址的应用案例" class="headerlink" title="相对地址的应用案例"></a>相对地址的应用案例</h5><ul>
<li><code>&lt;form action=&quot;./apply&quot; method=&quot;post&quot;</code></li>
<li>页面地址：<a target="_blank" rel="noopener" href="http://localhost:8080/[%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84]/form.html">http://localhost:8080/[上下文路径]/form.html</a></li>
<li>提交地址：<a target="_blank" rel="noopener" href="http://localhost:8080/[%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84]/apply">http://localhost:8080/[上下文路径]/apply</a></li>
</ul>
<pre><code class="html">src/main/webapp/form.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;学员调查问卷&lt;/title&gt;
    &lt;style&gt;
        .container &#123;
            position: absolute;
            border: 1px solid #cccccc;
            left: 50%;
            top: 50%;
            width: 400px;
            height: 300px;
            margin-left: -200px;
            margin-top: -150px;
            box-sizing: border-box;
            padding: 10px;
        &#125;
        h2&#123;
            margin: 10px 0px;
            text-align: center;
        &#125;
        h3&#123;
            margin: 10px  0px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;h2&gt;学员调查问卷&lt;/h2&gt;
        &lt;form action=&quot;./apply&quot; method=&quot;post&quot;&gt;
        &lt;h3&gt;您的姓名&lt;/h3&gt;
        &lt;input name=&quot;name&quot; class=&quot;text&quot;  style=&quot;width: 150px&quot;&gt;
        &lt;h3&gt;您正在学习的技术方向&lt;/h3&gt;
        &lt;select name=&quot;course&quot; style=&quot;width: 150px&quot;&gt;
            &lt;option value=&quot;java&quot;&gt;Java&lt;/option&gt;
            &lt;option value=&quot;h5&quot;&gt;HTML5&lt;/option&gt;
            &lt;option value=&quot;python&quot;&gt;Python&lt;/option&gt;
            &lt;option value=&quot;php&quot;&gt;PHP&lt;/option&gt;
        &lt;/select&gt;
        &lt;div&gt;
&lt;!--复选框用数组 或 ArrayList接收--&gt;
            &lt;h3&gt;您的学习目的：&lt;/h3&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他
        &lt;/div&gt;
        &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt;
        &lt;/div&gt;
        &lt;/form&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果要接收复合数据 直接用数组接收是最简单的 但使用起来并不轻松<br>可以使用List来接收 但是前方记得要有<code>@RequestParam</code><br>更加高级的可以封装成一个对象 用List接收复合数据<br>Map只能接收单个数据 接收复合数据的时候会造成数据丢失</p>
<pre><code class="java">com/imooc/springmvc/controller/FormController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.Form;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.List;
import java.util.Map;

@Controller
public class FormController &#123;
//    @PostMapping(&quot;/apply&quot;)  ★★★第一次尝试★★★
    @ResponseBody
//    如果在请求中不包含默认值 =&gt; 取别名  默认值机制：ANON匿名
    public String apply(@RequestParam(value = &quot;n&quot;, defaultValue = &quot;ANON&quot;) String name, String course, Integer[] purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

//    @PostMapping(&quot;/apply&quot;)  ★★★第二次尝试★★★
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(String name, String course, @RequestParam List&lt;Integer&gt; purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

    @PostMapping(&quot;/apply&quot;)  
    //★★★★★ 推荐使用 ★★★★★
    // 实体类+List 极大简化表单工作量  
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(Form form)&#123;
        return &quot;SUCCESS&quot;;
    &#125;
    //不推荐直接使用Map导入数据 因为复合数据[数组数据]会丢失
&#125;
</code></pre>
<pre><code class="java">com/imooc/springmvc/entity/Form.java
public class Form &#123;
    private String name;
    private String course;
    private List&lt;Integer&gt; purpose;
&#125;Setter + Getter
</code></pre>
<h3 id="关联对象赋值"><a href="#关联对象赋值" class="headerlink" title="关联对象赋值"></a>关联对象赋值</h3><h5 id="复杂内容表单"><a href="#复杂内容表单" class="headerlink" title="复杂内容表单"></a>复杂内容表单</h5><pre><code class="html">用户名: &lt;input name=&quot;username&quot;&gt;
密码：&lt;input name=&quot;password&quot;&gt;
--------------------------------
姓名：&lt;input name=&quot;name&quot;&gt;
身份证号：&lt;input name=&quot;idno&quot;&gt;
过期时间：&lt;input name=&quot;expire&quot;&gt;
</code></pre>
<h6 id="面向对象设计-【关联对象赋值】"><a href="#面向对象设计-【关联对象赋值】" class="headerlink" title="面向对象设计 【关联对象赋值】"></a>面向对象设计 【关联对象赋值】</h6><pre><code class="java">public class User&#123;
    private String username;
    private String password;
    private IDcard idcard = new IDCard();
    //Getter + Setter
&#125;
★★ 关联上IDcard ★★
public class IDcard&#123;
    private String name;
    private String idno;
    private Date expire;
    //Getter + Setter
&#125;
</code></pre>
<pre><code class="html">用户名: &lt;input name=&quot;username&quot;&gt;
密码：&lt;input name=&quot;password&quot;&gt;
--------------------------------
姓名：&lt;input name=&quot;idcard.name&quot;&gt;
身份证号：&lt;input name=&quot;idcard.idno&quot;&gt;
过期时间：&lt;input name=&quot;idcard.expire&quot;&gt;
</code></pre>
<pre><code class="html">src/main/webapp/form.html
 &lt;div&gt;
            &lt;h3&gt;您的学习目的：&lt;/h3&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他
        &lt;/div&gt;
            &lt;h3&gt;收货人&lt;/h3&gt;
&lt;!--  private Delivery delivery = new Delivery() --&gt;
            &lt;input name=&quot;delivery.name&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt;
            &lt;h3&gt;联系电话&lt;/h3&gt;
            &lt;input name=&quot;delivery.mobile&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt;
            &lt;h3&gt;收货地址&lt;/h3&gt;
            &lt;input name=&quot;delivery.address&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt;

        &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt;
        &lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/entity/Form.java
public class Form &#123;
    private String name;
    private String course;
    private List&lt;Integer&gt; purpose;
    private Delivery delivery = new Delivery();
&#125; Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/springmvc/entity/Delivery.java
public class Delivery &#123;
    private String name;
    private String address;
    private String mobile;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/FormController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.Form;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.List;
import java.util.Map;

@Controller
public class FormController &#123;
//    @PostMapping(&quot;/apply&quot;)  第一次尝试
    @ResponseBody
//    如果在请求中不包含默认值 =&gt; 取别名  默认值机制：ANON匿名
    public String apply(@RequestParam(value = &quot;n&quot;, defaultValue = &quot;ANON&quot;) String name, String course, Integer[] purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

//    @PostMapping(&quot;/apply&quot;)  第二次尝试
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(String name, String course, @RequestParam List&lt;Integer&gt; purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

//    @PostMapping(&quot;/apply&quot;) 第三次尝试[这个可以 但有更好]
    // 实体类+List 极大简化表单工作量
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(Form form)&#123;
        return &quot;SUCCESS&quot;;
    &#125;

    @PostMapping(&quot;/apply&quot;)
    @ResponseBody
    public String applyDelivery(Form form)&#123;
        System.out.println(form.getDelivery().getName());
        return &quot;SUCCESS&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="日期类型转换"><a href="#日期类型转换" class="headerlink" title="日期类型转换"></a>日期类型转换</h3><p>①注解方法</p>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
@Controller
@RequestMapping(&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
@PostMapping(&quot;/p1&quot;)
    @ResponseBody
    public String postMapping1(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;This is post method&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;createTime&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<hr>
<p>②实体对象接收数据</p>
<pre><code class="java">com/imooc/springmvc/entity/User.java
//标准的java bean
public class User &#123;
    private String username;
    private Long password;
// SpringMVC会自动按照这个类型进行转换
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private Date createTime;
&#125; Getter + Setter
</code></pre>
<hr>
<p>③自定义转换器：全局的默认时间转换器</p>
<pre><code class="java">com/imooc/springmvc/converter/MyDateConverter.java
package com.imooc.springmvc.converter;

import org.springframework.core.convert.converter.Converter;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class MyDateConverter implements Converter&lt;String, Date&gt; &#123;
    public Date convert(String s) &#123; //转换工作
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            Date d = sdf.parse(s);
            return d;
        &#125; catch (ParseException e) &#123;
            return null;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
       及子包中拥有以下注解的对象：
           @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
           @Service     ...Service类上 业务逻辑类
           @Controller 描述SpringMVC的控制器类
           @Component  无法确定的类型种类
       --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--    启用Spring MVC的注解开发模式 让底下的转换类生效--&gt;
    &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;
    &lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--    通知SpringMVC有哪些转换类--&gt;
    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;!--    这是转换类定义的地方--&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;com.imooc.springmvc.converter.MyDateConverter&quot;/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h3><h5 id="Web应用的中文乱码由来"><a href="#Web应用的中文乱码由来" class="headerlink" title="Web应用的中文乱码由来"></a>Web应用的中文乱码由来</h5><ul>
<li>Tomcat默认使用字符集ISO-8859-1，属于西欧字符集</li>
<li>解决乱码的核心思路是将ISO-8859-1转换为UTF-8</li>
<li>Controller中请求与响应都需要设置UTF-8字符集</li>
</ul>
<h5 id="中文乱码的配置"><a href="#中文乱码的配置" class="headerlink" title="中文乱码的配置"></a>中文乱码的配置</h5><ul>
<li>Get请求乱码 - server.xml增加URIEncoding属性</li>
</ul>
<p>去Tomcat-conf文件中寻找server.xml进行增加</p>
<pre><code class="java"> &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot;
               URIEncoding=&quot;UTF-8&quot;
               maxParameterCount=&quot;1000&quot;
               /&gt;

===============================================
http://localhost/um/g?manager_name=丽丽
控制台：managerName:丽丽
</code></pre>
<ul>
<li>Post请求乱码 - web.xml配置CharacterEncodingFilter</li>
</ul>
<pre><code class="java">http://localhost/
输入:
张三  123456 2001-03-02
随后点击提交
控制台：??????:123456
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/web.xml
&lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<pre><code class="java">http://localhost/
输入:
张三  123456 2001-03-02
随后点击提交
控制台：张三:123456
</code></pre>
<ul>
<li>Response相应乱码 - Spring配置StringHttpMessageConverter</li>
</ul>
<h3 id="解决响应中的中文乱码"><a href="#解决响应中的中文乱码" class="headerlink" title="解决响应中的中文乱码"></a>解决响应中的中文乱码</h3><pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.User;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.Date;

@Controller
@RequestMapping(&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
    @GetMapping(&quot;/g&quot;)
    @ResponseBody
    public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName) &#123;
        System.out.println(&quot;managerName:&quot;+managerName);
        return &quot;This is get method&quot;;
    &#125;

    //    直接访问会出错 post请求如何访问 用进行html表单提交
    @PostMapping(&quot;/p&quot;)
    @ResponseBody
    public String postMapping(String username, Long password) &#123;
        System.out.println(username + &quot;:&quot; + password);
        return &quot;This is post method&quot;;
    &#125;

//    @PostMapping(&quot;/p1&quot;)
    @ResponseBody
    public String postMapping1(User user)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;This is post method&quot;;
    &#125;

    @PostMapping(&quot;/p1&quot;)
    @ResponseBody
    public String postMapping1(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;这是Post响应&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">User.java
//标准的java bean
public class User &#123;
    private String username;
    private Long password;
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private Date createTime;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/springmvc/converter/MyDateConverter.java
package com.imooc.springmvc.converter;

import org.springframework.core.convert.converter.Converter;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class MyDateConverter implements Converter&lt;String, Date&gt; &#123;
    public Date convert(String s) &#123; //转换工作
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            Date d = sdf.parse(s);
            return d;
        &#125; catch (ParseException e) &#123;
            return null;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;createTime&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
       及子包中拥有以下注解的对象：
           @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
           @Service    ...Service类上 业务逻辑类
           @Controller 描述SpringMVC的控制器类
           @Component  无法确定的类型种类
       --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--    启用Spring MVC的注解开发模式 让底下的转换类生效--&gt;
    &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;
&lt;!--        设置消息转换器--&gt;

        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
&lt;!--                转换什么呢？--&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
&lt;!--  在servlet中是直接  response.setContentType(&quot;text/html;charset=utf-8&quot;)  --&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;

    &lt;/mvc:annotation-driven&gt;
    &lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--    通知SpringMVC有哪些转换类--&gt;
    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;!--    这是转换类定义的地方--&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;com.imooc.springmvc.converter.MyDateConverter&quot;/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
    &lt;!--    DispatchServlet 对所有请求进行拦截  --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        DispatcherServlet是Spring MVC是最核心的对象
                    DispatcherServlet用于拦截http请求
                    并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理
        --&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--        在Web应用启动时自动创建Spring IoC容器,并初始化DispatcherServlet --&gt;
        &lt;!--        applicationContext.xml 初始化参数 启动时候加载--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        &quot;/&quot; 所有请求都要拦截--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="响应中产生结果-ModelAndView-x3D-gt-MVC高效解耦理念"><a href="#响应中产生结果-ModelAndView-x3D-gt-MVC高效解耦理念" class="headerlink" title="响应中产生结果 [ModelAndView &#x3D;&gt; MVC高效解耦理念]"></a>响应中产生结果 [<span style = "color:red">ModelAndView</span> &#x3D;&gt; MVC高效解耦理念]</h3><ul>
<li><p>@ResponseBody - 产生响应文本</p>
<ul>
<li>@ResponseBody直接产生响应体数据, 过程不涉及任何视图</li>
<li>@ResponseBody可产生标准字符串&#x2F;JSON&#x2F;XML等格式数据</li>
<li>@ResponseBody被StringHttpMessageConverter所影响</li>
</ul>
</li>
<li><p>ModelAndView - 利用模板引擎渲染输出</p>
<ul>
<li>ModelAndView对象是指”模型(数据)与视图(界面)”对象</li>
<li>通过ModelAndView可将包含数据对象与模板引擎进行绑定</li>
<li>SpringMVC中默认的View是JSP, 也可以配置其他模板引擎</li>
</ul>
</li>
</ul>
<blockquote>
<p>提问：为什么不直接访问view.jsp 而是绕了一个圈子还是同样的效果<br>回答：因为jsp页面是写死的如何将页面和数据绑定在一起呢？先通过访问&#x2F;um&#x2F;view这个controller让其方法中产生数据, 之后再将这个数据通过modelandview对象绑定到页面中才可以做到</p>
<p>从请求传来一个用户编号把数据查询出来得到一个user用户对象 然后再view.jsp中把刚刚查询的对象进行显示[动态的]</p>
</blockquote>
<h6 id="高效解耦"><a href="#高效解耦" class="headerlink" title="高效解耦"></a>高效解耦</h6><pre><code class="java">后端：com/imooc/springmvc/controller/URLMappingController.java
// http://localhost/um/view?userId=1 数据动态查询产生
    @GetMapping(&quot;/view&quot;)
    public ModelAndView showView(Integer userId)&#123;
        ModelAndView mav = new ModelAndView(&quot;/view.jsp&quot;);
        User user = new User();
        if (userId == 1)&#123;
            user.setUsername(&quot;lily&quot;);
        &#125;else if (userId == 2)&#123;
            user.setUsername(&quot;smith&quot;);
        &#125;
    //  在当前请求中增加一个对象 数据绑定view.jsp
        mav.addObject(&quot;u&quot;, user);
        return mav;
    &#125;
</code></pre>
<pre><code class="jsp">前端：src/main/webapp/view.jsp
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;I&#39;m view page&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Username:$&#123;u.username&#125;&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="ModelAndView-重定向"><a href="#ModelAndView-重定向" class="headerlink" title="ModelAndView [重定向]"></a><span style = "color:red">ModelAndView</span> [重定向]</h2><h6 id="SpringMVC若跳转页面需要使用此对象进行数据绑定"><a href="#SpringMVC若跳转页面需要使用此对象进行数据绑定" class="headerlink" title="[SpringMVC若跳转页面需要使用此对象进行数据绑定]"></a>[SpringMVC若跳转页面需要使用此对象进行数据绑定]</h6><ul>
<li>mav.addObject()方法设置的属性默认存放在当前请求中</li>
<li>默认ModelAndView使用请求转发(forward)至页面</li>
<li><strong>重定向</strong>使用 new ModelAndView(“<strong>redirect:</strong>&#x2F;index.jsp”) 新请求</li>
</ul>
<p>页面重定向使用时机：内部的controller处理逻辑和跳转页面之间没有直接关系时可以用”redirect:&#x2F;view.jsp”</p>
<pre><code class="java">ModelAndView mav = new ModelAndView(&quot;redirect:/view.jsp&quot;);
直接访问到了jsp  http://localhost/view.jsp

访问：http://localhost/um/view?userId=1
建立一个 没有斜杠的相对路径 src/main/webapp/um/view.jsp
com/imooc/springmvc/controller/URLMappingController.java
 // http://localhost/um/view?userId=1 数据动态查询产生
    @GetMapping(&quot;/view&quot;)
    public ModelAndView showView(Integer userId)&#123;
//        ModelAndView mav = new ModelAndView(&quot;redirect:/view.jsp&quot;);
        ModelAndView mav = new ModelAndView();
        mav.setViewName(&quot;view.jsp&quot;);
//        没有斜杠是代表相对路径 相对于@RequestMapping(&quot;/um&quot;)地址
//        mav.setViewName(&quot;view.jsp&quot;);

        User user = new User();
        if (userId == 1)&#123;
            user.setUsername(&quot;lily&quot;);
        &#125;else if (userId == 2)&#123;
            user.setUsername(&quot;smith&quot;);
        &#125;
//      在当前请求中增加一个对象 数据绑定view.jsp
        mav.addObject(&quot;u&quot;, user);
        return mav;
    &#125;
</code></pre>
<h5 id="String与ModelMap实现ModelAndView类似功能-工作中的小技巧"><a href="#String与ModelMap实现ModelAndView类似功能-工作中的小技巧" class="headerlink" title="String与ModelMap实现ModelAndView类似功能  [工作中的小技巧]"></a>String与ModelMap实现ModelAndView类似功能  [工作中的小技巧]</h5><pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
//   String 与 ModelMap[为模型数据] 返回字符串
//    Controller方法返回String的情况
//    1.方法被@ResponseBody描述, 则SpringMVC直接响应Spring字符串本身
//    2.方法不存在@ResponseBody, 则SpringMVC处理String指代的视图(页面)
// 这里的String是直接代替了@ResponseBody - 产生响应文本
    public String showView1(Integer userId, ModelMap modelMap)&#123;
        String view = &quot;/um/view.jsp&quot;;
        User user = new User();
        if (userId == 1)&#123;
            user.setUsername(&quot;lily&quot;);
        &#125;else if (userId == 2)&#123;
            user.setUsername(&quot;smith&quot;);
        &#125;
        modelMap.addAttribute(&quot;u&quot;, user);
        return view;
    &#125;
</code></pre>
<h3 id="SpringMVC整合Freemarker-项目：first-springmvc"><a href="#SpringMVC整合Freemarker-项目：first-springmvc" class="headerlink" title="SpringMVC整合Freemarker [项目：first-springmvc]"></a>SpringMVC整合Freemarker [项目：first-springmvc]</h3><h5 id="①-pom-xml引入依赖"><a href="#①-pom-xml引入依赖" class="headerlink" title="① pom.xml引入依赖"></a>① pom.xml引入依赖</h5><pre><code class="xml">要随时导入包 tomcat → Edit configuration → Deployment → Artifacts 将右侧包put in
&lt;dependency&gt;
  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
  &lt;version&gt;2.3.28&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
  &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="②-启用Freemarker模板引擎"><a href="#②-启用Freemarker模板引擎" class="headerlink" title="② 启用Freemarker模板引擎"></a>② 启用Freemarker模板引擎</h5><pre><code class="xml">applicationContext.xml
&lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
   &lt;!-- 设置响应输出，并解决中文乱码 --&gt; 
&lt;!-- 渲染完成后向客户端浏览器响应式 响应体中使用的字符集编码 --&gt;
   &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;&gt;&lt;/property&gt;
   &lt;!-- 指定Freemarker模板文件扩展名 --&gt;
   &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="③-本身配置Freemarker参数"><a href="#③-本身配置Freemarker参数" class="headerlink" title="③ 本身配置Freemarker参数"></a>③ 本身配置Freemarker参数</h5><pre><code class="xml">&lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
&lt;!-- 设置模板保存的目录 tomcat无法直接解析freemarker模板引擎 所以新增/WEB-INF/ftl --&gt;
   &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;
   &lt;!-- 其他模板引擎设置 --&gt;
   &lt;property name=&quot;freemarkerSettings&quot;&gt;
     &lt;props&gt;
         &lt;!-- 设置Freemarker脚本与数据渲染时使用的字符集 --&gt;
         &lt;!-- 模板与数据绑定渲染的过程中使用的字符集编码 --&gt;
         &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;
     &lt;/props&gt; 
   &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/ftl/test.ftl
&lt;h1&gt;$&#123;u.username&#125;&lt;/h1&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/FreemarkerController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
// http://localhost/fm/test  显示 andy
@Controller
@RequestMapping(&quot;/fm&quot;)
public class FreemarkerController &#123;
    @GetMapping(&quot;/test&quot;)
    public ModelAndView showTest()&#123;
//        因为之前配置所有配置扩展名是.ftl 所以下面不用写
        ModelAndView mav = new ModelAndView(&quot;/test&quot;);
        User user = new User();
        user.setUsername(&quot;andy&quot;);
        mav.addObject(&quot;u&quot;,user);
        return mav;
    &#125;
&#125;
=====================================================
// http://localhost/fm/test  显示 andy
</code></pre>
<h1 id="RESTful开发风格"><a href="#RESTful开发风格" class="headerlink" title="RESTful开发风格"></a>RESTful开发风格</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzvar/article/details/118164133">RESTful 风格（详细介绍 + 案例实现）_c# restful风格接口-CSDN博客</a></p>
<h3 id="REST与RESTful"><a href="#REST与RESTful" class="headerlink" title="REST与RESTful"></a>REST与RESTful</h3><ul>
<li>REST- 表现层状态转换, 资源在网络中以某种表现形式进行状态转移</li>
<li>RESTful是基于REST理念的一套开发风格, 是具体的开发规则</li>
</ul>
<h3 id="RESTful开发规范"><a href="#RESTful开发规范" class="headerlink" title="RESTful开发规范"></a>RESTful开发规范</h3><p>URL中所有的都是名词 请求都有不同的含义  返回的数据是JSON或者XML格式 </p>
<ul>
<li>使用URL作为用户交互入口</li>
<li>明确的语义规范(GET, POST, PUT, DELETE)</li>
<li>只返回数据(JSON, XML)不包含任何展现</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/13679a67b4eec21f54b5f30a53b45aafaf3fbebc/data/RESTful%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC.jpg" style="zoom: 67%;" />

<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@RestController</td>
<td>由 @Controller + @ResponseBody组成（返回 JSON 数据格式）</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到控制器处理方法的形参中</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>注解用于请求地址的解析，是最常用的一种注解</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>查询请求</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>添加请求</td>
</tr>
<tr>
<td>@PutMapping</td>
<td>更新请求</td>
</tr>
<tr>
<td>@DeleteMapping</td>
<td>删除请求</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）</td>
</tr>
</tbody></table>
<h3 id="RESTful命名要求"><a href="#RESTful命名要求" class="headerlink" title="RESTful命名要求"></a>RESTful命名要求</h3><table>
<thead>
<tr>
<th>URI</th>
<th>说明</th>
<th>修改建议</th>
</tr>
</thead>
<tbody><tr>
<td>GET &#x2F;articles?au&#x3D;lily</td>
<td><span style = "color:green">正确用法</span></td>
<td></td>
</tr>
<tr>
<td>GET &#x2F;a&#x2F;1</td>
<td><span style = "color:red">URI必须具有语义</span></td>
<td>GET &#x2F;student&#x2F;1</td>
</tr>
<tr>
<td>POST &#x2F;createArticle&#x2F;1</td>
<td><span style = "color:red">URI必须使用名词</span></td>
<td>POST &#x2F;article&#x2F;1</td>
</tr>
<tr>
<td>GET &#x2F;articles&#x2F;author&#x2F;1</td>
<td><span style = "color:red">URI扁平化, 不超两级</span></td>
<td>GET &#x2F;articles&#x2F;author?id&#x3D;1</td>
</tr>
<tr>
<td>DELETE&#x2F;articles&#x2F;1</td>
<td><span style = "color:red">URI名词区分单复数</span></td>
<td>GET &#x2F;articles?au&#x3D;lily<br />DELETE &#x2F;article&#x2F;1</td>
</tr>
</tbody></table>
<img src="https://raw.githubusercontent.com/P-luminary/images/1cd2b6c624167b8007e3b67c15b03d631b2d1e92/data/%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F%20URI%20%E5%92%8C%20RESTful%20%E9%A3%8E%E6%A0%BC%E5%AF%B9%E6%AF%94.jpg"  />

<h3 id="开发第一个RESTful应用"><a href="#开发第一个RESTful应用" class="headerlink" title="开发第一个RESTful应用"></a>开发第一个RESTful应用</h3><p><strong>404究极报错</strong><br>项目生成文件out&#x2F;artifacts&#x2F;XXX&#x2F;WEB-INF中没有导入lib包<br>没有将下面的web文件里的web.xml手动复制进去</p>
<pre><code class="xml">pom.xml 
写完pom.xml后记得在tomcat配置中的Deployment中加入依赖包
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;restful&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.restful&quot;/&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                        &lt;value&gt;application/json;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">web/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
package com.imooc.restful.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping(&quot;/restful&quot;)
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    @ResponseBody
    public String doGetRequest()&#123;
//  双引号中如果包括双引号 要用转义字符 \&quot;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;
&#125;

=======================================================
http://localhost/restful/request
&#123;&quot;message&quot;:&quot;返回查询结果&quot;&#125;
</code></pre>
<h3 id="实现RESTful实验室"><a href="#实现RESTful实验室" class="headerlink" title="实现RESTful实验室"></a>实现RESTful实验室</h3><pre><code class="java">com/imooc/restful/controller/RestfulController.java
package com.imooc.restful.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequestMapping(&quot;/restful&quot;)
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    @ResponseBody
    public String doGetRequest()&#123;
//  双引号中如果包括双引号 要用转义字符 \&quot;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;
    @PostMapping(&quot;/request&quot;)
    @ResponseBody
    public String doPostRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;&#125;&quot;;
    &#125;
    @PutMapping (&quot;/request&quot;)
    @ResponseBody
    public String doPutRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;
    @DeleteMapping(&quot;/request&quot;)
    @ResponseBody
    public String doDeleteRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据删除成功\&quot;&#125;&quot;;
    &#125;
&#125;
===========================
http://localhost/client.html
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.restful&quot;/&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                        &lt;!--只要响应产生就会使用utf-8字符集--&gt;
                        &lt;value&gt;application/json;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;restful&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="html">web/client.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        $(function () &#123;
            $(&quot;#btnGet&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;get&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
        $(function () &#123;
            $(&quot;#btnPost&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;post&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
        $(function () &#123;
            $(&quot;#btnPut&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;put&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
        $(function () &#123;
            $(&quot;#btnDelete&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;delete&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;发送Get请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPost&quot; value=&quot;发送Post请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPut&quot; value=&quot;发送Put请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnDelete&quot; value=&quot;发送Delete请求&quot;&gt;
    &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="RestController注解与路径变量"><a href="#RestController注解与路径变量" class="headerlink" title="RestController注解与路径变量"></a>RestController注解与路径变量</h3><p>在post请求中通过client.html利用Ajax动态注入了一个rid到RestfulController.java<br>代替了所有的@ResponseBody 默认向请求台进行输出</p>
<pre><code class="java">@Controller： 用于标识一个类是Spring MVC中的控制器，类似于标准的@Controller 注解。它告诉Spring框架该类是一个控制器，可以处理HTTP请求。

@ResponseBody： 用于将方法的返回值直接作为HTTP响应的主体（Body）内容。这意味着不会进行视图解析，而是直接将返回的对象（通常是JSON或XML）写入HTTP响应

因此，@RestController 的作用是将一个控制器类标记为RESTful风格的控制器，其中的每个方法都被视为返回数据，而不是视图。这样就不需要在每个方法上都添加 @ResponseBody 注解，因为该注解已经包含在 @RestController 中。
</code></pre>
<pre><code class="java">client.html
 $(function()&#123;
            $(&quot;#btnPost&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/request/100&quot;,
                    type : &quot;post&quot; ,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                   $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
    
package com.imooc.restful.controller;
import org.springframework.web.bind.annotation.*;
@RestController
@RequestMapping(&quot;/restful&quot;)
//@CrossOrigin(origins = &#123;&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;&#125;)
//@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600)
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doGetRequest() &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;

    // POST /article/1
    // POST /restful/request/100
    @PostMapping(&quot;/request/&#123;rid&#125;&quot;)
    //@ResponseBody
    public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId) &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;,\&quot;id\&quot;:&quot; + requestId + &quot;&#125;&quot;;
    &#125;

    @PutMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doPutRequest() &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;

    @DeleteMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doDeleteRequest() &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据删除成功\&quot;&#125;&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="简单请求与非简单请求"><a href="#简单请求与非简单请求" class="headerlink" title="简单请求与非简单请求"></a>简单请求与非简单请求</h3><ul>
<li>简单请求是指标准结构的HTTP请求, 对应GET&#x2F;POST请求</li>
<li>非简单请求是复杂要求的HTTP请求, 指PUT&#x2F;DELETE、扩展标准请求</li>
<li>两者最大区别是非简单请求发送前需要发送<strong>预检请求</strong> [看看能不能进行处理 可以才实际处理 预先处理不符合的数据挡在外面]</li>
</ul>
<pre><code class="xml">web.xml
&lt;!--    对put和delete请求进行支持--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.FormContentFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<pre><code class="java">web/client.html
$(function()&#123;
            $(&quot;#btnPost&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/request/100&quot;,
                    type : &quot;post&quot; ,
                    data : &quot;name=lily&amp;age=23&quot;,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id);
                    &#125;
                &#125;)
            &#125;);
        &#125;)

        $(function()&#123;
            $(&quot;#btnPut&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/request&quot;,
                    type : &quot;put&quot; ,
                    data : &quot;name=lily&amp;age=23&quot;,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
 // POST /article/1
    // POST /restful/request/100
    @PostMapping(&quot;/request/&#123;rid&#125;&quot;)
    //@ResponseBody
    public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;,\&quot;id\&quot;:&quot; + requestId + &quot;&#125;&quot;;
    &#125;

    @PutMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doPutRequest(Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;
====================
lily:23
</code></pre>
<p>创建一个Person用来插入数据 并打印在控制台</p>
<pre><code class="java">com/imooc/restful/entity/Person.java
public class Person &#123;
    private String name;
    private Integer age;
&#125;Getter + Setter
</code></pre>
<h3 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h3><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
一定要使用2.9以后的版本 之前的版本有严重的安全风险
</code></pre>
<pre><code class="java">http://localhost/restful/person?id=1
@GetMapping(&quot;/person&quot;)
//不返回String 返回JSON序列化的对象
    public Person findByPersonId(Integer id)&#123;
        Person p = new Person();
        if (id==1)&#123;
            p.setName(&quot;lily&quot;);
            p.setAge(23);
        &#125; else if (id==2) &#123;
            p.setName(&quot;smith&quot;);
            p.setAge(22);
        &#125;
        return p;
    &#125;
============================================
&#123;
    &quot;name&quot;: &quot;lily&quot;,
    &quot;age&quot;: 23
&#125;



http://localhost/restful/persons
@GetMapping(&quot;/persons&quot;)
    public List&lt;Person&gt; findPersons()&#123;
        List list = new ArrayList();
        Person p1 = new Person();
        p1.setName(&quot;lily&quot;);
        p1.setAge(23);
        list.add(p1);

        Person p2 = new Person();
        p2.setName(&quot;smith&quot;);
        p2.setAge(22);
        list.add(p2);
        
        return list;
    &#125;
=============================================
[
    &#123;
        &quot;name&quot;: &quot;lily&quot;,
        &quot;age&quot;: 23
    &#125;,
    &#123;
        &quot;name&quot;: &quot;smith&quot;,
        &quot;age&quot;: 22
    &#125;
]
</code></pre>
<p>服务器返回json数组</p>
<pre><code class="html">client.html
$(function()&#123;
            $(&quot;#btnPersons&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/persons&quot;,
                    type : &quot;get&quot; ,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        console.info(json);
                        for (var i=0; i&lt;json.length; i++)&#123;
                            var p = json[i];
                            $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;&lt;/h2&gt;&quot;)
                        &#125;
                    &#125;
                &#125;)
            &#125;);
        &#125;)

    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;发送Get请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPost&quot; value=&quot;发送Post请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPut&quot; value=&quot;发送Put请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnDelete&quot; value=&quot;发送Delete请求&quot;&gt;
    &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt;
    &lt;hr/&gt;
    &lt;!-- 点击btnPersons按钮时发送Ajax请求[上面有操作代码] 将所有人员信息追加到div中--&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPersons&quot; value=&quot;查询所有人员&quot;&gt;
    &lt;div id=&quot;divPersons&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
@GetMapping(&quot;/persons&quot;)
    public List&lt;Person&gt; findPersons()&#123;
        List list = new ArrayList();
        Person p1 = new Person();
        p1.setName(&quot;lily&quot;);
        p1.setAge(23);
        list.add(p1);

        Person p2 = new Person();
        p2.setName(&quot;smith&quot;);
        p2.setAge(22);
        list.add(p2);

        return list;
    &#125;

===============================================
http://localhost/client.html
点击查询所有人员
=&gt; 
lily-23
smith-22
</code></pre>
<p>增加时间！</p>
<pre><code class="java">Person.java
public class Person &#123;
    private String name;
    private Integer age;
// 记得用日期的格式化输出
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)
    private Date birthday;
&#125;Getter + Setter
</code></pre>
<pre><code class="html">client.html
$(function()&#123;
            $(&quot;#btnPersons&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/persons&quot;,
                    type : &quot;get&quot; ,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        console.info(json);
                        for (var i=0; i&lt;json.length; i++)&#123;
                            var p = json[i];
                            $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;-&quot; + p.birthday+ &quot;&lt;/h2&gt;&quot;)
                        &#125;
                    &#125;
                &#125;)
            &#125;);
        &#125;)

===================================
lily-23-2024-01-17 09:09:28
smith-22-2024-01-17 09:09:28
</code></pre>
<h3 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h3><ul>
<li>同源策略阻止从一个域加载的脚本去获取另一个域上的资源</li>
<li>只要<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>有任何一个不同，都被当做是不同的域</li>
<li>浏览器Console看到<strong>Access-Control-Allow-Origin</strong>就代表了跨域了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/161c64c96177be1c274357912c48055b196806cd/data/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%A4%BA%E4%BE%8B.jpg"></p>
<h3 id="HTML中允许跨域的标签"><a href="#HTML中允许跨域的标签" class="headerlink" title="HTML中允许跨域的标签"></a>HTML中允许跨域的标签</h3><ul>
<li>&lt; img &gt; - 显示远程图片</li>
<li>&lt; script &gt; - 加载远程JS</li>
<li>&lt; link &gt; - 加载远程CSS</li>
</ul>
<h3 id="CORS跨域资源访问"><a href="#CORS跨域资源访问" class="headerlink" title="CORS跨域资源访问"></a>CORS跨域资源访问</h3><ul>
<li>CORS是一种机制, 使用额外的HTTP头通知浏览器可以访问其他域</li>
<li>URL响应头包含 <strong>Access-Control-</strong>* 指明请求允许跨域</li>
</ul>
<h3 id="Spring-MVC解决跨域访问"><a href="#Spring-MVC解决跨域访问" class="headerlink" title="Spring MVC解决跨域访问"></a>Spring MVC解决跨域访问</h3><ul>
<li><strong>@CrossOrigin - Controller</strong>跨域注解</li>
<li>&lt; mvc:cors &gt; - Spring MVC全局跨域配置</li>
</ul>
<pre><code class="java">RestfulController.java [代码第四行]
@RestController
@RequestMapping(&quot;/restful&quot;)
//@CrossOrigin(origins = &#123;&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;&#125;)
//@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600) 所有端口都会访问发送请求
//maxAge = 3600 一小时时间后发送预检请求  之内的就发送实际请求 【非简单请求】
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doGetRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;

    // POST /article/1
    // POST /restful/request/100
    @PostMapping(&quot;/request/&#123;rid&#125;&quot;)
    //@ResponseBody
    public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;,\&quot;id\&quot;:&quot; + requestId + &quot;&#125;&quot;;
    &#125;

    @PutMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doPutRequest(Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;

    @DeleteMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doDeleteRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据删除成功\&quot;&#125;&quot;;
    &#125;

    @GetMapping(&quot;/person&quot;)
    public Person findByPersonId(Integer id)&#123;
        Person p = new Person();
        if (id==1)&#123;
            p.setName(&quot;lily&quot;);
            p.setAge(23);
        &#125; else if (id==2) &#123;
            p.setName(&quot;smith&quot;);
            p.setAge(22);
        &#125;
        return p;
    &#125;

    @GetMapping(&quot;/persons&quot;)
    public List&lt;Person&gt; findPersons()&#123;
        List list = new ArrayList();
        Person p1 = new Person();
        p1.setName(&quot;lily&quot;);
        p1.setAge(23);
        p1.setBirthday(new Date());
        list.add(p1);

        Person p2 = new Person();
        p2.setName(&quot;smith&quot;);
        p2.setAge(22);
        p2.setBirthday(new Date());
        list.add(p2);
        return list;
    &#125;
&#125;
</code></pre>
<h3 id="CORS全局配置"><a href="#CORS全局配置" class="headerlink" title="CORS全局配置"></a>CORS全局配置</h3><pre><code class="xml">&lt;mvc:cors&gt;
    &lt;mvc:mapping path=&quot;/restful/**&quot;
        allowed-origins=&quot;http://localhost:8080,http://www.imooc.com&quot;
        max-age=&quot;3600&quot;/&gt;
&lt;/mvc:cors&gt;
</code></pre>
<h3 id="SpringMVC拦截器-高级组件"><a href="#SpringMVC拦截器-高级组件" class="headerlink" title="SpringMVC拦截器 [高级组件]"></a>SpringMVC拦截器 [高级组件]</h3><h5 id="拦截器-Interceptor"><a href="#拦截器-Interceptor" class="headerlink" title="拦截器-Interceptor"></a>拦截器-Interceptor</h5><ul>
<li>拦截器(Interceptor)用于对URL请求进行前置&#x2F;后置过滤</li>
<li>Interceptor与Filter用途相似, 但实现方式不同</li>
<li>Interceptor底层基于Spring AOP面向切面编程实现[类似于<strong>环绕通知</strong>]</li>
</ul>
<h5 id="拦截器开发流程"><a href="#拦截器开发流程" class="headerlink" title="拦截器开发流程"></a>拦截器开发流程</h5><ul>
<li>Maven依赖servlet-api</li>
<li>实现HandlerInterceptor接口</li>
<li>applicationContext配置过滤地址</li>
</ul>
<h5 id="HandlerInterceptor接口"><a href="#HandlerInterceptor接口" class="headerlink" title="HandlerInterceptor接口"></a>HandlerInterceptor接口</h5><ul>
<li><strong>preHandle</strong> - 前置执行处理</li>
<li><strong>postHandle</strong> - 目标资源已被Spring MVC框架处理 没产生响应文本</li>
<li><strong>afterCompletion</strong> - 相应文本已经产生</li>
</ul>
<pre><code class="xml">pom.xml
     &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
&lt;!-- 只有在开发编译才会引用 打包最终使用的时候会排除在外 因为 servlet-api与tomcat-api冲突  --&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/interceptor/MyInterceptor.java
package com.imooc.restful.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyInterceptor implements HandlerInterceptor &#123;
//    Code -&gt; Implement Methods

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;准备执行&quot;);
        return true;
    &#125;

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;目标处理成功&quot;);
    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;响应内容已产生&quot;);
    &#125;
//  随后去applicationContext.xml配置
&#125;

=============================================================
/准备执行
/目标处理成功
/响应内容已产生
/准备执行
/目标处理成功
/响应内容已产生
/准备执行
/目标处理成功
/响应内容已产生
    
http://localhost/restful/persons
/restful/persons准备执行
/restful/persons目标处理成功
/restful/persons响应内容已产生
    
http://localhost/client.html
/client.html准备执行
/client.html目标处理成功
/client.html响应内容已产生
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
&lt;!--  哪些[所有]地址进行拦截 下面加个bean是哪个类进行处理[送到这个类中处理]--&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt;
            &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<h3 id="拦截器使用细则"><a href="#拦截器使用细则" class="headerlink" title="拦截器使用细则"></a>拦截器使用细则</h3><pre><code class="xml">applicationContext.xml
&lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
&lt;!--            哪些[所有]地址进行拦截 下面加个bean是哪个类进行处理[送到这个java中处理]--&gt;
       &lt;!-- &lt;mvc:mapping path=&quot;/**&quot;/&gt; --&gt;
            &lt;mvc:mapping path=&quot;/restful/**&quot;/&gt;
            &lt;mvc:mapping path=&quot;/webapi/**&quot;/&gt;
&lt;!--            以下是不需要拦截 排除在外的--&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt;
&lt;!--   创建一个resources  规范静态文件目录 一次性都排除在外--&gt;
            &lt;mvc:exclude-mapping path=&quot;/rescources/**&quot;/&gt;

            &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e1dbff67f8b3f8c785e7ca12d62741c295469782/data/%E5%A4%9AInterceptor%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg"></p>
<pre><code class="java">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;准备执行&quot;);
        return true;
    &#125;
通过preHandle的返回值可以做很多事情
对某一个url进行前置检查 对请求放行 如果不符合要求 直接在拦截器中返回相应
return true; 请求依次向后发送
return false; 请求被阻挡
</code></pre>
<h3 id="开发”用户流量”拦截器"><a href="#开发”用户流量”拦截器" class="headerlink" title="开发”用户流量”拦截器"></a>开发”用户流量”拦截器</h3><pre><code class="xml">pom.xml [引入新的依赖后一定要去Tomcat导入新的依赖包]
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">logback.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;[%thread] %d %level %logger&#123;10&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;accessHistoryLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;d:/logs/history.%d.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;[%thread] %d %level %logger&#123;10&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
    &lt;/root&gt;
    &lt;logger name=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot;
            level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;accessHistoryLog&quot;/&gt;
    &lt;/logger&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/interceptor/AccessHistoryInterceptor.java
package com.imooc.restful.interceptor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class AccessHistoryInterceptor implements HandlerInterceptor &#123;
    private Logger logger = LoggerFactory.getLogger(AccessHistoryInterceptor.class);
//    前置处理

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        StringBuilder log = new StringBuilder();
        log.append(request.getRemoteAddr());
        log.append(&quot;|&quot;);
        log.append(request.getRequestURL());
        log.append(&quot;|&quot;);
        log.append(request.getHeader(&quot;user-agent&quot;));
        logger.info(log.toString());
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/restful/interceptor/MyInterceptor.java
package com.imooc.restful.interceptor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyInterceptor implements HandlerInterceptor &#123;
//    Code -&gt; Implement Methods

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(request.getRequestURL() + &quot;-准备执行&quot;);
//        response.getWriter().print(&quot;[]&quot;);
        return true;
    &#125;

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(request.getRequestURL() + &quot;-目标处理成功&quot;);
    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(request.getRequestURL() + &quot;-响应内容已产生&quot;);
    &#125;
&#125;

==============================================================
http://localhost/client.html
[http-nio-80-exec-1] 2024-01-18 10:43:54,739 DEBUG o.s.w.s.DispatcherServlet - GET &quot;/login.html&quot;, parameters=&#123;&#125;
[http-nio-80-exec-1] 2024-01-18 10:43:54,750 DEBUG o.s.w.s.h.SimpleUrlHandlerMapping - Mapped to org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler@5c0e8bb9
[http-nio-80-exec-1] 2024-01-18 10:43:54,758 DEBUG o.s.w.s.DispatcherServlet - Completed 404 NOT_FOUND
[http-nio-80-exec-2] 2024-01-18 10:44:00,495 DEBUG o.s.w.s.DispatcherServlet - GET &quot;/restful/request&quot;, parameters=&#123;&#125;
[http-nio-80-exec-2] 2024-01-18 10:44:00,502 DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to public java.lang.String com.imooc.restful.controller.RestfulController.doGetRequest()
http://localhost/restful/request-准备执行
[http-nio-80-exec-2] 2024-01-18 10:44:00,539 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Using &#39;application/json;charset=utf-8&#39;, given [application/json, text/javascript, */*;q=0.01] and supported [text/html;charset=utf-8, application/json;charset=utf-8, text/plain, */*, application/json, application/*+json]
[http-nio-80-exec-2] 2024-01-18 10:44:00,539 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Writing [&quot;&#123;&quot;message&quot;:&quot;返回查询结果&quot;&#125;&quot;]
http://localhost/restful/request-目标处理成功
http://localhost/restful/request-响应内容已产生
[http-nio-80-exec-2] 2024-01-18 10:44:00,580 DEBUG o.s.w.s.DispatcherServlet - Completed 200 OK
[http-nio-80-exec-5] 2024-01-18 10:44:08,194 DEBUG o.s.w.s.DispatcherServlet - GET &quot;/restful/persons&quot;, parameters=&#123;&#125;
[http-nio-80-exec-5] 2024-01-18 10:44:08,195 DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to public java.util.List&lt;com.imooc.restful.entity.Person&gt; com.imooc.restful.controller.RestfulController.findPersons()
http://localhost/restful/persons-准备执行
RestfulController.findPersons() - return list
[http-nio-80-exec-5] 2024-01-18 10:44:08,211 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Using &#39;application/json&#39;, given [application/json, text/javascript, */*;q=0.01] and supported [application/json, application/*+json]
[http-nio-80-exec-5] 2024-01-18 10:44:08,211 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Writing [[com.imooc.restful.entity.Person@619c4d80, com.imooc.restful.entity.Person@71459fb]]
http://localhost/restful/persons-目标处理成功
http://localhost/restful/persons-响应内容已产生
===================================================================
D:\logs\history.2024-01-18
[http-nio-80-exec-1] 2024-01-18 10:43:54,755 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/login.html|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-2] 2024-01-18 10:44:00,502 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-5] 2024-01-18 10:44:08,195 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/persons|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-3] 2024-01-18 10:44:10,137 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request/100|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-4] 2024-01-18 10:44:10,935 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-6] 2024-01-18 10:44:11,481 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt;
            &lt;bean class=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<h3 id="Spring-MVC处理流程"><a href="#Spring-MVC处理流程" class="headerlink" title="Spring MVC处理流程"></a>Spring MVC处理流程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/42e2897ef9dc2075cb7c71f43c2a2e54e11ffea7/data/SpringMVC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/01/15/后端/SpringMVC[Mapping,中文乱码,Restful及跨域,JSON序列化,非简单请求,拦截器]/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/12/09/后端/Spring(切点表达式,通知,AOP,CGLib代理,Spring JdbcTemplate,事务)/">
        <h2>
            Spring
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/12/9
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><img src="https://raw.githubusercontent.com/P-luminary/images/8fdafeebf37a6ccf8de24be3ce4d857524f07204/data/Spring%E6%A8%A1%E5%9D%97.png" style="zoom: 200%;" />

<h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring框架介绍</td>
<td>Spring IoC、DI和AOP等核心概念</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Spring IoC容器</td>
<td>Spring实例化与管理对象</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>集合对象注入</td>
<td>注入List、Set、Map集合对象</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>底层原理</td>
<td>Spring Bean的生命周期</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>注解与Java Config</td>
<td>Spring注解分类和常用注解应用</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h6 id="不修改源代码的程序扩展"><a href="#不修改源代码的程序扩展" class="headerlink" title="不修改源代码的程序扩展"></a>不修改源代码的程序扩展</h6><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>理解AOP及名词</td>
<td>Spring AOP开发与配置流程</td>
<td>★★★★★★(面试)</td>
</tr>
<tr>
<td>五种通知类型</td>
<td>Spring五种通知类型与应用场景</td>
<td>★★★</td>
</tr>
<tr>
<td>切点表达式</td>
<td>PointCut切点表达式的语法规则及应用</td>
<td>★★</td>
</tr>
<tr>
<td>代理模式</td>
<td>JDK动态代理和CGLib代理的执行过程</td>
<td>★★★★★★(面试)</td>
</tr>
</tbody></table>
<h3 id="Spring-JDBC与声明式事务"><a href="#Spring-JDBC与声明式事务" class="headerlink" title="Spring JDBC与声明式事务"></a>Spring JDBC与声明式事务</h3><p>JDBC的扩展</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring JDBC</td>
<td>Spring JDBC的环境配置</td>
<td>★★★★</td>
</tr>
<tr>
<td>RestTemplate</td>
<td>基于RestTemplate实现SQL处理</td>
<td>★★★</td>
</tr>
<tr>
<td>配置声明式事务</td>
<td>声明式事务的配置过程</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>事务传播行为介绍</td>
<td>讲解常用事务传播行为的用途</td>
<td>★★★</td>
</tr>
<tr>
<td>声明式事务注解形式</td>
<td>基于注解使用声明式事务</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h1 id="★★★★★★-Spring-★★★★★★"><a href="#★★★★★★-Spring-★★★★★★" class="headerlink" title="★★★★★★  Spring  ★★★★★★"></a><span style = "color:red">★★★★★★  Spring  ★★★★★★</span></h1><p>IoC容器负责<strong>实例化</strong>，<strong>配置</strong>和<strong>组装</strong>对象。 IoC容器从XML文件获取信息并相应地工作。</p>
<p>IoC容器执行的主要任务是:</p>
<ul>
<li>实例化应用程序类</li>
<li>配置对象</li>
<li>组装对象之间的依赖关系</li>
</ul>
<p>有两种类型的IoC容器</p>
<ul>
<li><code>BeanFactory</code></li>
<li><code>ApplicationContext</code></li>
</ul>
<h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><h6 id="对象的控制权交给第三方进行管理-中间人"><a href="#对象的控制权交给第三方进行管理-中间人" class="headerlink" title="对象的控制权交给第三方进行管理(中间人)"></a>对象的控制权交给第三方进行管理(中间人)</h6><ul>
<li>IoC控制反转，全称Inverse of Control，是一种设计理念</li>
<li>由代理人来创建与管理对象，消费者通过代理人来获取对象</li>
<li>IoC的目的是降低对象之间直接耦合[更好适合对象之间的变化]</li>
<li>加入<strong>IoC容器</strong>将对象统一管理，让对象关联变为弱耦合</li>
</ul>
<p><strong>顾客</strong> ←(快递) <strong>果商冷冻仓库</strong> (批发)→ <strong>苹果</strong></p>
<h3 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h3><ul>
<li>IoC是设计理念，是现代程序设计遵循的标准，是宏观目标</li>
<li>DI(Dependency Injection)是具体技术实现，是微观实现</li>
<li>DI在Java中利用<strong>反射</strong>技术实现对象注入(Injection) [不同语言运用不同技术]</li>
</ul>
<h3 id="Spring含义"><a href="#Spring含义" class="headerlink" title="Spring含义"></a>Spring含义</h3><ul>
<li>Spring可以从广义和狭义两个角度看待</li>
<li>广义的Spring是指Spring生态系统</li>
<li>狭义的Spring是指Spring框架(Spring Framework)</li>
</ul>
<h5 id="广义的Spring生态体系"><a href="#广义的Spring生态体系" class="headerlink" title="广义的Spring生态体系"></a>广义的Spring生态体系</h5><ul>
<li>分布式微服务 SpringCloud</li>
<li>Reactive相应服务</li>
<li>Web apps 是 SpringMVC 中的</li>
<li>Serverless 无服务器内容</li>
<li>Event Driven 和 Batch</li>
<li>Spring Framework     Spring Boot     Spring Cloud     Spring Cloud Data Flow…</li>
</ul>
<h5 id="狭义的Spring框架"><a href="#狭义的Spring框架" class="headerlink" title="狭义的Spring框架"></a>狭义的Spring框架</h5><ul>
<li>Spring框架是企业开发复杂性的<strong>一站式</strong>解决方案</li>
<li>Spring框架的核心是<strong>IoC容器</strong>与<strong>AOP面向切面编程</strong></li>
<li>Spring IoC负责创建与管理系统对象，并在此基础上扩展功能(不修改源代码)</li>
</ul>
<h5 id="传统开发方式"><a href="#传统开发方式" class="headerlink" title="传统开发方式"></a>传统开发方式</h5><ul>
<li>对象直接引用导致对象硬性关联，程序难以扩展维护 new B new A</li>
</ul>
<h5 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h5><ul>
<li><p>IoC容器是Spring生态的地基，用于统一创建于管理对象依赖</p>
<p><strong>使用者</strong>直接<strong>提取</strong>Spring IoC容器中的已经将<strong>依赖</strong>ObjectB<strong>注入</strong>到ObjectA 直接提取A</p>
</li>
</ul>
<h5 id="Spring-IoC容器职责-宏观理念"><a href="#Spring-IoC容器职责-宏观理念" class="headerlink" title="Spring IoC容器职责 [宏观理念]"></a>Spring IoC容器职责 [宏观理念]</h5><ul>
<li>对象的控制权交由<strong>第三方</strong>统一管理 <u>(IoC控制反转)</u></li>
<li>利用Java<strong>反射</strong>技术实现<strong>运行时</strong>对象创建与关联 <u>(DI依赖注入)</u> [<strong>技术实现</strong>]</li>
<li>基于配置提高应用程序的可维护性与扩展性</li>
</ul>
<h3 id="Spring-IoC初体验"><a href="#Spring-IoC初体验" class="headerlink" title="Spring IoC初体验"></a>Spring IoC初体验</h3><h6 id="三个小孩吃三种不同的苹果"><a href="#三个小孩吃三种不同的苹果" class="headerlink" title="三个小孩吃三种不同的苹果"></a>三个小孩吃三种不同的苹果</h6><h5 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h5><p><strong>Apple.java</strong></p>
<pre><code class="java">public class Apple &#123;
    private String title;
    private String color;
    private String origin;
    Construct(空+满) Getter+Setter
&#125;
</code></pre>
<p><strong>Child.java</strong></p>
<pre><code class="java">public class Child &#123;
    private String name;
    private Apple apple;
    Construct(空+满) Getter+Setter
    public void eat()&#123;
        System.out.println(name + &quot;吃到了&quot; + apple.getOrigin() + &quot;种植的&quot; + apple.getTitle());
    &#125;
&#125;
</code></pre>
<p><strong>Application.java</strong></p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;

public class Application &#123;
    public static void main(String[] args) &#123;
        Apple apple1 = new Apple(&quot;红富士&quot;, &quot;红色&quot;, &quot;欧洲&quot;);
        Apple apple2 = new Apple(&quot;青苹果&quot;, &quot;绿色&quot;, &quot;中亚&quot;);
        Apple apple3 = new Apple(&quot;红富士&quot;, &quot;红色&quot;, &quot;欧洲&quot;);
        Child lily = new Child(&quot;莉莉&quot;,apple1);
        Child andy = new Child(&quot;安迪&quot;,apple2);
        Child luna = new Child(&quot;露娜&quot;,apple3);
        lily.eat();
        andy.eat();
        luna.eat();
    &#125;
&#125;
</code></pre>
<h5 id="Spring-IoC方式代码-不修改源代码-不用new-引入容器让对象统一管理"><a href="#Spring-IoC方式代码-不修改源代码-不用new-引入容器让对象统一管理" class="headerlink" title="Spring IoC方式代码[不修改源代码 不用new 引入容器让对象统一管理]"></a><span style = "color:red">Spring IoC方式代码</span>[不修改源代码 不用new 引入容器让对象统一管理]</h5><p><strong>pom.xml</strong></p>
<pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<p><strong>applicationContext.xml</strong> [静态信息可以放其中]  **<code>属性</code>**元素的 <u><strong>ref</strong> 属性用于定义另一个bean的引用。</u></p>
<pre><code class="java">SpringIoC核心配置文件 右键resources创建 所有对象的创建以及关联的设置都是在applicationContext.xml这里进行
Spring.io -&gt; Project -&gt; Spring Framework -&gt; LEARN -&gt; Reference Doc. -&gt;  Core

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt; 
并且加入配置Spring[出现在提示页面]

------------------------  更新一次  ------------------------
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;!--    在IoC容器启动时，自动由Spring实例化Apple对象，取名sweetApple放入到容器中  --&gt;
     &lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
            &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;sourApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;绿色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;softApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;沙果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中国&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;黄色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;rdApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;蛇果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;美国&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;lily&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;andy&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;安迪&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sourApple&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;luna&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;露娜&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;rdApple&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>SpringApplication.java</strong></p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        System.out.println(sweetApple.getTitle());
        //从IoC容器中提取beanId=lily的对象
        Child lily = context.getBean(&quot;lily&quot;, Child.class);
        lily.eat();
        Child andy = context.getBean(&quot;andy&quot;, Child.class);
        andy.eat();
        Child luna = context.getBean(&quot;luna&quot;, Child.class);
        luna.eat();
    &#125;
&#125;
————————————————————————————————————————————————————————————————————————————————————
红富士
莉莉吃到了欧洲种植的红富士
安迪吃到了中亚种植的青苹果
露娜吃到了美国种植的蛇果
</code></pre>
<p>利用IoC容器有利于对象与对象之间的<strong>解耦</strong>   springIoC大大提高了程序的维护与延展</p>
<h3 id="XML管理对象-Bean"><a href="#XML管理对象-Bean" class="headerlink" title="XML管理对象(Bean)"></a>XML管理对象(Bean)</h3><ul>
<li>基于XML配置Bean</li>
</ul>
<pre><code class="java">上述的吃苹果例题就是基于xml配置Bean
</code></pre>
<ul>
<li>基于注解配置Bean</li>
<li>基于Java代码配置Bean(java .config)</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
            &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
所有都要用bean标签 SpringIoC实例化以后在容器的唯一编号: id=&quot;sweetAppele&quot; SpringIoC就知道创建IoC容器时实例化一个Apple对象同时bean id=&quot;...&quot;
</code></pre>
<h5 id="XML方式创建IoC容器"><a href="#XML方式创建IoC容器" class="headerlink" title="XML方式创建IoC容器"></a>XML方式创建IoC容器</h5><pre><code class="xml">//创建IoC容器并根据配置文件创建对象
ApplicationContext context = new 
ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
</code></pre>
<h3 id="实例化Bean的三种方式"><a href="#实例化Bean的三种方式" class="headerlink" title="实例化Bean的三种方式"></a>实例化Bean的三种方式</h3><ul>
<li><span style = "color:red">基于构造方法对象实例化</span> (90%以上)</li>
</ul>
<h6 id="利用构造方法参数名实例化-推荐"><a href="#利用构造方法参数名实例化-推荐" class="headerlink" title="利用构造方法参数名实例化 [推荐]"></a>利用构造方法<span style = "color:red">参数名</span>实例化 [推荐]</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- 没有constructor-arg则代表调用默认构造方法实例化 --&gt;
  &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士&quot;/&gt;
  &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;           
  &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;     
&lt;/bean&gt;
</code></pre>
<p>Apple.java</p>
<pre><code class="java">public class Apple &#123;
    private String title;
    private String color;
    private String origin;

    public Apple() &#123;
        System.out.println(&quot;Apple对象已创建,&quot; + this);
    &#125;

    public Apple(String title, String color, String origin) &#123;
        System.out.println(&quot;通过带参构造方法创建对象&quot; + this);
        this.title = title;
        this.color = color;
        this.origin = origin;
    &#125;
    ......
</code></pre>
<p>SpringApplication.java</p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
___________________________________________________________________________
Apple对象已创建,com.imooc.spring.ioc.entity.Apple@39fb3ab6
通过带参构造方法创建对象com.imooc.spring.ioc.entity.Apple@1a968a59
</code></pre>
<h6 id="利用构造方法参数位置实例化"><a href="#利用构造方法参数位置实例化" class="headerlink" title="利用构造方法参数位置实例化"></a>利用构造方法<span style = "color:red">参数位置</span>实例化</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
  &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt;
  &lt;constructor-arg index=&quot;1&quot; value=&quot;欧洲&quot;/&gt;
  &lt;constructor-arg index=&quot;2&quot; value=&quot;红色&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li><h3 id="基于静态工厂实例化-在IoC容器之外通过程序组织对象"><a href="#基于静态工厂实例化-在IoC容器之外通过程序组织对象" class="headerlink" title="基于静态工厂实例化 (在IoC容器之外通过程序组织对象)"></a>基于静态工厂实例化 (在IoC容器之外通过程序组织对象)</h3></li>
</ul>
<pre><code class="java">AppleStaticFactory.java
package com.imooc.spring.ioc.factory;

import com.imooc.spring.ioc.entity.Apple;

public class AppleStaticFactory &#123;
    public static Apple createSweetApple()&#123; //静态工厂 用于创建对象的方法是静态的
        Apple apple = new Apple();
        apple.setTitle(&quot;红富士&quot;);
        apple.setOrigin(&quot;欧洲&quot;);
        apple.setColor(&quot;红色&quot;);
        return apple;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--利用静态工厂获取对象--&gt;
    &lt;bean id=&quot;apple4&quot; class=&quot;com.imooc.spring.ioc.factory.AppleStaticFactory&quot;
          factory-method=&quot;createSweetApple&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<hr>
<pre><code class="java">&lt;bean id=&quot;a&quot; class=&quot;com.nhooo.A&quot; factory-method=&quot;getA&quot;&gt;&lt;/bean&gt;
</code></pre>
<pre><code class="java">A.java
package com.nhooo;
public class A &#123;
private static final A obj=new A();
private A()&#123;System.out.println(&quot;private constructor&quot;);&#125;
public static A getA()&#123;
    System.out.println(&quot;factory method &quot;);
    return obj;
&#125;
public void msg()&#123;
    System.out.println(&quot;hello user&quot;);
&#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
&lt;bean id=&quot;a&quot; class=&quot;com.nhooo.A&quot; factory-method=&quot;getA&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">Test.java
package org.sssit;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test &#123;
public static void main(String[] args) &#123;
    ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    A a=(A)context.getBean(&quot;a&quot;);
    a.msg();
&#125;
&#125;
=============================================================
private constructor
factory method
hello user
</code></pre>
<ul>
<li><h3 id="基于工厂实例方法实例化"><a href="#基于工厂实例方法实例化" class="headerlink" title="基于工厂实例方法实例化"></a>基于工厂实例方法实例化</h3></li>
</ul>
<pre><code class="java">AppleFactoryInstance.java
package com.imooc.spring.ioc.factory;

import com.imooc.spring.ioc.entity.Apple;

/**
 * 工厂实例方法创建对象是指IoC容器对工厂类进行实例化并调用对应的实例方法创建对象的过程
 */
public class AppleFactoryInstance &#123;
    public Apple createSweetApple()&#123; //静态工厂 用于创建对象的方法是静态的
        Apple apple = new Apple();
        apple.setTitle(&quot;红富士&quot;);
        apple.setOrigin(&quot;欧洲&quot;);
        apple.setColor(&quot;红色&quot;);
        return apple;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--利用工厂实例方法获取对象--&gt;
    &lt;bean id=&quot;factoryInstance&quot; class=&quot;com.imooc.spring.ioc.factory.AppleFactoryInstance&quot;/&gt;
    &lt;bean id=&quot;apple5&quot; factory-bean=&quot;factoryInstance&quot; factory-method=&quot;createSweetApple&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="从IoC容器获取bean"><a href="#从IoC容器获取bean" class="headerlink" title="从IoC容器获取bean"></a>从IoC容器获取bean</h3><pre><code class="java">Apple sweetApple = context.getBean(&quot;sweetApple&quot;,Apple.class); 【推荐】
                    或者
Apple sweetApple = (Apple)context.getBean(&quot;sweetApple&quot;);
-------------------------------------------------------------
System.out.println(sweetApple.getTitle());
</code></pre>
<pre><code class="java">public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Apple apple4 = context.getBean(&quot;apple4&quot;, Apple.class); 【推荐】
        System.out.println(apple4.getTitle());
        
        Apple apple3 = (Apple)context.getBean(&quot;apple3&quot;);
        System.out.println(apple3.getTitle());
    &#125;
&#125;
</code></pre>
<h5 id="id与name属性相同点"><a href="#id与name属性相同点" class="headerlink" title="id与name属性相同点"></a>id与name属性相同点</h5><ul>
<li>bean id 与 name 都是设置对象在IoC容器中唯一标识</li>
</ul>
<pre><code class="java">&lt;bean id=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;bean name=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
</code></pre>
<ul>
<li>两者在同一个配置文件中都不允许出现重复</li>
<li>两者允许在多个配置文件中出现重复，新对象覆盖旧对象</li>
<li><span style = "color:red"><strong>id要求更为严格，一次只能定义一个对象标识</strong></span> 【推荐】</li>
<li><span style = "color:red"><strong>name更为宽松，一次允许定义多个对象标识</strong></span> </li>
<li>tips: id与name的命名要求有意义，按驼峰命名书写</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;bean id=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt;
        &lt;constructor-arg index=&quot;1&quot; value=&quot;欧洲&quot;/&gt;
        &lt;constructor-arg index=&quot;2&quot; value=&quot;红色&quot;/&gt;
        &lt;constructor-arg index=&quot;3&quot; value=&quot;19.8&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">applicationContext-1.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
 &lt;bean id=&quot;apple2&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
        &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士2号&quot;/&gt;
        &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
        &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;);
        Apple apple2 = context.getBean(&quot;apple2&quot;,Apple.class);
        System.out.println(apple2.getTitle());
        Apple apple3 = context.getBean(&quot;apple3&quot;,Apple.class);
        System.out.println(apple3.getTitle());
    &#125;
&#125;
______________________________________________________________________
红富士2号
红富士
</code></pre>
<blockquote>
<p>&lt; bean name &#x3D; “apple2, apple7”  class&#x3D;”com.imooc.spring.ioc.entity.Apple” &gt;<br>如果使用name(不使用id)可以在后面增加标识名<br>在没有id与name的bean默认使用类名全称作为bean标识<br>&lt; bean class&#x3D;”com.imooc.spring.ioc.entity.Apple” &gt; </p>
</blockquote>
<h3 id="路径匹配表达式"><a href="#路径匹配表达式" class="headerlink" title="路径匹配表达式"></a>路径匹配表达式</h3><h5 id="加载单个配置文件"><a href="#加载单个配置文件" class="headerlink" title="加载单个配置文件"></a>加载单个配置文件</h5><pre><code class="java">//创建IoC容器并根据配置文件创建对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
</code></pre>
<h5 id="加载多配置文件"><a href="#加载多配置文件" class="headerlink" title="加载多配置文件"></a>加载多配置文件</h5><pre><code class="java">String[] configLocations = new String[]&#123;&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;&#125;;
ApplicationContext context = new ClassPathXmlApplicationContext(configLocations);
</code></pre>
<h5 id="路径表达式-config-xml-x3D-ApplicationContext-xml"><a href="#路径表达式-config-xml-x3D-ApplicationContext-xml" class="headerlink" title="路径表达式 (config.xml &#x3D; ApplicationContext.xml)"></a>路径表达式 (config.xml &#x3D; ApplicationContext.xml)</h5><table>
<thead>
<tr>
<th>表达式实例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:config.xml</td>
<td>扫描classpath根路径(不包含jar)的config.xml</td>
</tr>
<tr>
<td>classpath:com&#x2F;imooc&#x2F;config.xml</td>
<td>扫描classpath下(不包含jar)com.imooc包中的config.xml</td>
</tr>
<tr>
<td>classpath*:com&#x2F;imooc&#x2F;config.xml</td>
<td>扫描classpath下(<strong>包含jar</strong>)com.imooc包中的config.xml</td>
</tr>
<tr>
<td>classpath:config-*.xml</td>
<td>扫描classpath根路径下所有以config-开头的XML文件</td>
</tr>
<tr>
<td>classpath:com&#x2F;**&#x2F;config.xml</td>
<td>扫描com包下(包含任何子包)的config.xml</td>
</tr>
<tr>
<td>file:c:&#x2F;config.xml</td>
<td>扫描c盘根路径config.xml</td>
</tr>
</tbody></table>
<h3 id="对象依赖注入"><a href="#对象依赖注入" class="headerlink" title="对象依赖注入"></a>对象依赖注入</h3><ul>
<li>依赖注入是指运行时将容器内对象利用<strong>反射</strong>赋給其他对象的操作</li>
<li><span style = "color:red"><strong>基于setter方法注入对象</strong></span></li>
</ul>
<h6 id="利用setter实现静态数值注入"><a href="#利用setter实现静态数值注入" class="headerlink" title="利用setter实现静态数值注入"></a>利用setter实现静态数值注入</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- IoC容器自动利用反射机制运行时调用setXXX方法为属性赋值 --&gt;
    &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt;
    &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt;
    &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
    &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h6 id="利用setter实现对象注入-【核心操作-ref-x3D-””】"><a href="#利用setter实现对象注入-【核心操作-ref-x3D-””】" class="headerlink" title="利用setter实现对象注入 【核心操作 ref&#x3D;””】"></a>利用setter实现对象注入 【<u>核心操作 ref&#x3D;””</u>】</h6><p>**<code>属性</code>**元素的 <u><strong>ref</strong> 属性用于定义另一个bean的引用。</u></p>
<pre><code class="java">&lt;bean id=&quot;lily&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
    &lt;!-- 利用ref注入依赖对象 --&gt;
    &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="java">Child.java   #创建好的apple对象赋予給参数进入setApple
public void setApple(Apple apple) &#123;
     System.out.println(&quot;注入的Apple对象：&quot; + apple);
     this.apple = apple;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        System.out.println(sweetApple.getTitle());
    &#125;
&#125;
</code></pre>
<h3 id="体验依赖注入的优势-高效解耦"><a href="#体验依赖注入的优势-高效解耦" class="headerlink" title="体验依赖注入的优势 (高效解耦)"></a>体验依赖注入的优势 (高效解耦)</h3><pre><code class="xml">applicatioinContext-dao.xml    #用于数据库的增删改查
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookDao&quot; class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoImpl&quot;&gt;
//如果更改了数据库类型 只需要重新创建一个java实现接口BookDao的insert 之后只需更改class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoOracleImpl&quot;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">applicatioinContext-service.xml 
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookService&quot; class=&quot;com.imooc.spring.ioc.bookshop.service.BookService&quot;&gt;
&lt;!--        id=bookDao     --&gt;
       &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">BookDao.java
package com.imooc.spring.ioc.bookshop.dao;

public interface BookDao &#123;
    public void insert();
&#125;
</code></pre>
<pre><code class="java">BookDaoImpl.java
package com.imooc.spring.ioc.bookshop.dao;

public class BookDaoImpl implements BookDao&#123;
    @Override
    public void insert() &#123;
        System.out.println(&quot;向mysql book表插入数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">BookService.java
package com.imooc.spring.ioc.bookshop.service;

import com.imooc.spring.ioc.bookshop.dao.BookDao;

public class BookService &#123;
    private BookDao bookDao; //接口将在ioc启动的时候动态注入
    public void purchase()&#123;
        System.out.println(&quot;正在执行图书采购业务方法&quot;);
        bookDao.insert();
    &#125;
    public BookDao getBookDao()&#123;
        return bookDao;
    &#125;
    public void setBookDao(BookDao bookDao)&#123;
        this.bookDao = bookDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">BookShopApplication.java
package com.imooc.spring.ioc.bookshop;

import com.imooc.spring.ioc.bookshop.service.BookService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class BookShopApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-*.xml&quot;);
        BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class);
        bookService.purchase();
    &#125;
&#125;
</code></pre>
<h3 id="利用构造方法实现对象依赖注入"><a href="#利用构造方法实现对象依赖注入" class="headerlink" title="利用构造方法实现对象依赖注入"></a>利用构造方法实现对象依赖注入</h3><h5 id="对象依赖注入-1"><a href="#对象依赖注入-1" class="headerlink" title="对象依赖注入"></a>对象依赖注入</h5><ul>
<li>依赖注入是指运行时将容器内对象利用<strong>反射</strong>赋給其他对象的操作</li>
<li><span style="color:red"><strong>基于setter方法注入对象</strong></span></li>
<li>基于构造方法注入对象</li>
</ul>
<pre><code class="java">【com.imooc.spring.ioc.entity】
Child.java + Apple.java 

Apple.java中可以加一个
public void apple()&#123;
        System.out.println(origin+&quot;国家&quot; +color+&quot;的&quot;+title+&quot;食物&quot;);
    &#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.Apple.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;/&gt;
        &lt;property name=&quot;color&quot; value=&quot;绿色&quot;/&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;lily&quot; class=&quot;com.imooc.Apple.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">package com.imooc.Apple;

import com.imooc.Apple.entity.Apple;
import com.imooc.Apple.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-*.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        Child lily = context.getBean(&quot;lily&quot;, Child.class);
        // 添加打印语句，检查属性是否正确注入
        System.out.println(&quot;lily&#39;s name: &quot; + lily.getName());
        System.out.println(&quot;lily&#39;s apple origin: &quot; + lily.getApple().getOrigin());
        System.out.println(&quot;lily&#39;s apple title: &quot; + lily.getApple().getTitle());
        System.out.println(&quot;====================================&quot;);
//        System.out.println(sweetApple.getTitle()+sweetApple.getColor()+sweetApple.getOrigin());
        lily.eat();
        sweetApple.apple();
    &#125;
&#125;
</code></pre>
<h3 id="注入集合对象-1"><a href="#注入集合对象-1" class="headerlink" title="注入集合对象_1"></a>注入集合对象_1</h3><h5 id="注入List-允许重复数据"><a href="#注入List-允许重复数据" class="headerlink" title="注入List [允许重复数据]"></a>注入List [允许重复数据]</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someList&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;具体值&lt;/value&gt;
        &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt;
    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Set-不允许重复数据-自动去除重复"><a href="#注入Set-不允许重复数据-自动去除重复" class="headerlink" title="注入Set  [不允许重复数据 自动去除重复]"></a>注入Set  [不允许重复数据 自动去除重复]</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someSet&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;具体值&lt;/value&gt;
      &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt;
    &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Map"><a href="#注入Map" class="headerlink" title="注入Map"></a>注入Map</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someMap&quot;&gt;
    &lt;Map&gt;
        &lt;entry key=&quot;k1&quot; value=&quot;v1&quot;&gt;&lt;/entry&gt; #静态数值
      &lt;entry key=&quot;k2&quot; value-ref=&quot;beanId&quot;&gt;&lt;/entry&gt; #对象引用
    &lt;/Map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Properties"><a href="#注入Properties" class="headerlink" title="注入Properties"></a>注入Properties</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someProperties&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt;
      &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt;
    &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="公司资产配置清单-小案例"><a href="#公司资产配置清单-小案例" class="headerlink" title="公司资产配置清单[小案例]"></a>公司资产配置清单[小案例]</h3><p><strong>constructor-arg：通过 构造函数注入 。</strong></p>
<p><strong>property：通过 setter对应的方法注入</strong> 。</p>
<pre><code class="java">Company.java
package com.imooc.spring.ioc.entity;

import java.util.List;
import java.util.Map;
import java.util.Properties;

public class Company &#123;
    private List&lt;String&gt; rooms;
    private Map&lt;String,Computer&gt; computers; //每一条数据保存的都是Computer型
    private Properties info;//键值对的写

    @Override
    public String toString() &#123;
        return &quot;Company&#123;&quot; +
                &quot;rooms=&quot; + rooms +
                &quot;, computers=&quot; + computers +
                &quot;, info=&quot; + info +
                &#39;&#125;&#39;;
    &#125;
    + Getter Setter
&#125;
</code></pre>
<pre><code class="java">Computer.java
public class Computer &#123;
    private String brand;
    private String type;
    private String sn;
    private Float price;
    constructor(空+满)+Getter Setter
&#125;
</code></pre>
<p>如何在ioc容器创建后自动的实例化Company对象并且填充信息呢?<br>所有的工作都在<code>applicationContext.xml</code>中进行的</p>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;list&gt; //【允许重复】
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Company;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Company company = context.getBean(&quot;company&quot;, Company.class);
        System.out.println(company);
    &#125;
&#125;
------------------------------------------------------------
Company&#123;rooms=[2001-总裁办, 2003-总经理办公室, 2010-研发部会议室], computers=null, info=null&#125;

Process finished with exit code 0
------------------------------------------------------------
下方xml更新后的显示数据：
Company&#123;rooms=[2001-总裁办, 2003-总经理办公室, 2010-研发部会议室], computers=&#123;dev-88172=Computer&#123;brand=&#39;联想&#39;, type=&#39;台式机&#39;, sn=&#39;8389283012&#39;, price=3085.0&#125;, dev-88173=Computer&#123;brand=&#39;联想&#39;, type=&#39;台式机&#39;, sn=&#39;8389283012&#39;, price=3085.0&#125;&#125;, info=&#123;phone=010-12345678, address=北京市朝阳区XX路XX大厦, website=https://p-luminary.github.io&#125;&#125;
https://p-luminary.github.io

Process finished with exit code 0
</code></pre>
<p>list的底层是ArrayList<br>Set的底层是LinkedHashSet [双向有序列表]<br>Map的底层是LinkedHashMap [双向列表 提取也是存放顺序]</p>
<pre><code class="xml">applicationContext.xml [更新一次]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;c1&quot; class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name=&quot;computers&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;dev-88172&quot; value-ref=&quot;c1&quot;/&gt; &lt;!-- 对象引用c1在上方 --&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;

或者【简便方法】↓
</code></pre>
<pre><code class="xml">applicationContext.xml 更新二次【新增简便方法】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;c1&quot; class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;【方法一】
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        
        &lt;property name=&quot;computers&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;dev-88172&quot; value-ref=&quot;c1&quot;/&gt; &lt;!-- 对象引用c1在上方 --&gt;
                &lt;entry key=&quot;dev-88173&quot;&gt;【方法二 (推荐)】
                    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
                        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
                        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
                        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
                        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;phone&quot;&gt;010-12345678&lt;/prop&gt;
                &lt;prop key=&quot;address&quot;&gt;北京市朝阳区XX路XX大厦&lt;/prop&gt;
                &lt;prop key=&quot;website&quot;&gt;https://p-luminary.github.io&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/43856e9419b6b12dba03ffb97458b89e4dd7ec1e/data/constructor%E4%B8%8Eproperty%E5%8C%BA%E5%88%AB.jpg"></p>
<h3 id="查看容器内对象-【-getBeanDefinitionNames-】"><a href="#查看容器内对象-【-getBeanDefinitionNames-】" class="headerlink" title="查看容器内对象 【.getBeanDefinitionNames()】"></a>查看容器内对象 【.getBeanDefinitionNames()】</h3><pre><code class="java">多个同类型的bean会自动增加编号 #1  #2
    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;微星&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3000&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;华硕&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;9023283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;5600&quot;/&gt;
    &lt;/bean&gt;

//获取容器内所有beanId数组       
        String[] beanNames = context.getBeanDefinitionNames();
        for (String beanName:beanNames)&#123;
            System.out.println(beanName); //c1 company ...&lt;bean id=&quot;...&quot;&gt;
             System.out.println(&quot;类型：&quot; + context.getBean(beanName).getClass().getName());
            System.out.println(&quot;内容：&quot; + context.getBean(beanName).toString());
        &#125;
        Computer computer = context.getBean(&quot;com.imooc.spring.ioc.entity.Computer&quot;, Computer.class);
        System.out.println(computer.getBrand());
        Computer computer1 = context.getBean(&quot;com.imooc.spring.ioc.entity.Computer#1&quot;, Computer.class);
        System.out.println(computer1.getBrand());
</code></pre>
<h3 id="bean-scope属性"><a href="#bean-scope属性" class="headerlink" title="bean scope属性"></a>bean scope属性</h3><ul>
<li>bean scope属性用于决定对象何时被创建与作用范围</li>
<li>bean scope配置将影响容器内对象的数量</li>
<li>bean scope默认值singleton(单例), 指全局共享同一个对象实例</li>
</ul>
<h5 id="scope用法"><a href="#scope用法" class="headerlink" title="scope用法"></a>scope用法</h5><pre><code class="java">&lt;bean id=&quot;bookDao&quot;
    class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoOracleImpl&quot;
    scope=&quot;prototype&quot;/&gt;
</code></pre>
<h5 id="bean-scope属性清单"><a href="#bean-scope属性清单" class="headerlink" title="bean scope属性清单"></a>bean scope属性清单</h5><table>
<thead>
<tr>
<th>scope属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span style = "color:red">singleton</span></td>
<td><span style = "color:red">单例(默认值),每一个容器有且只有唯一的实例,实例被全局共享</span></td>
</tr>
<tr>
<td><span style = "color:red">prototype</span></td>
<td><span style = "color:red">多例,每次使用时都是创建一个实例</span></td>
</tr>
<tr>
<td>request</td>
<td>web环境下,每一个独立请求存在唯一实例</td>
</tr>
<tr>
<td>session</td>
<td>web环境下,每一个session存在有唯一实例</td>
</tr>
<tr>
<td>application</td>
<td>web环境下,ServletContext存在唯一实例</td>
</tr>
<tr>
<td>websocket</td>
<td>每一次WebSocket连接中存在唯一实例</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/59d168487d0ef9aa2a23cf8057d454e1d3f26fc9/data/singleton%E4%B8%8Eprototype%E6%AF%94%E8%BE%83%E5%9B%BE.png"></p>
<h5 id="singleton与prototype对比"><a href="#singleton与prototype对比" class="headerlink" title="singleton与prototype对比"></a>singleton与prototype对比</h5><table>
<thead>
<tr>
<th></th>
<th>singleton</th>
<th>prototype</th>
</tr>
</thead>
<tbody><tr>
<td>对象数量</td>
<td>全局唯一</td>
<td>存在多个</td>
</tr>
<tr>
<td>实例化时机</td>
<td>IoC容器启动时</td>
<td>getBean() 或 对象注入时</td>
</tr>
<tr>
<td>线程安全问题</td>
<td>存在</td>
<td>不存在</td>
</tr>
<tr>
<td>执行效率</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
    public UserDao()&#123;
        System.out.println(&quot;UserDao已创建: &quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    public UserDao userDao;

    public UserService() &#123;
        System.out.println(&quot;UserService已创建: &quot; + this);
    &#125;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        System.out.println(&quot;调用setUserDao: &quot; + userDao);
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
   &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java 【单例】

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserDao userDao = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao1 = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao2 = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao3 = context.getBean(&quot;userDao&quot;, UserDao.class);
    &#125;
&#125;

applicationContext.xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; &gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

================================================================
输出：
UserService已创建: com.imooc.spring.ioc.service.UserService@3dd3bcd
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@7c16905e
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@7c16905e
    
Process finished with exit code 0
</code></pre>
<pre><code class="java">SpringApplication.java 【多例】
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        System.out.println(&quot;IoC容器已初始化&quot;);
        UserService userService1 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService2 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService3 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService4 = context.getBean(&quot;userService&quot;, UserService.class);
    &#125;
&#125;

applicationContext.xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

================================================================
输出:
IoC容器已初始化
UserService已创建: com.imooc.spring.ioc.service.UserService@5c7fa833
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@4dfa3a9d
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@4dfa3a9d
UserService已创建: com.imooc.spring.ioc.service.UserService@4b952a2d
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@3159c4b8
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@3159c4b8
UserService已创建: com.imooc.spring.ioc.service.UserService@73846619
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@4bec1f0c
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@4bec1f0c
UserService已创建: com.imooc.spring.ioc.service.UserService@29ca901e
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@5649fd9b
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@5649fd9b

Process finished with exit code 0
</code></pre>
<p><span style = "color : red">一般来说dao类 service类 control类都是单例 因为单例安全根源是运行时发生不断的变化 如果在真正环境中一般不会重新设置那些类，在运行中都是恒定不变的。所以推荐用单例默认<code>singleton</code></span></p>
<h3 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/cbffd1149ca0b5b1b860325d72941880b7ca7fc4/data/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg"></p>
<pre><code class="java">Order.java
package com.imooc.spring.ioc.entity;

public class Order &#123;
    private Float price;
    private Integer quantity;
    private Float total;

    public Order() &#123;
        System.out.println(&quot;创建Order对象&quot; + this);
    &#125;

    public void init()&#123;
        System.out.println(&quot;执行init()方法&quot;);
        total = price * quantity;
    &#125;
    public void pay()&#123;
        System.out.println(&quot;订单金额为：&quot; + total);
    &#125;

    public Float getPrice() &#123;
        return price;
    &#125;

    public void setPrice(Float price) &#123;
        System.out.println(&quot;设置price：&quot; + price);
        this.price = price;
    &#125;

    public Integer getQuantity() &#123;
        return quantity;
    &#125;

    public void setQuantity(Integer quantity) &#123;
        System.out.println(&quot;设置quantity：&quot; + quantity);
        this.quantity = quantity;
    &#125;

    public Float getTotal() &#123;
        return total;
    &#125;

    public void setTotal(Float total) &#123;
        this.total = total;
    &#125;

    public void destroy()&#123;
        System.out.println(&quot;释放与订单对象相关的资源&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;order1&quot; class=&quot;com.imooc.spring.ioc.entity.Order&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;
        &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
        &lt;property name=&quot;quantity&quot; value=&quot;1000&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        System.out.println(&quot;======IoC容器已初始化======&quot;);
        Order order1 = context.getBean(&quot;order1&quot;,Order.class);
        order1.pay();
        ((ClassPathXmlApplicationContext)context).registerShutdownHook(); //销毁容器 自动调用bean中设置的destory方法
    &#125;
&#125;

==========================================
创建Order对象com.imooc.spring.ioc.entity.Order@153f5a29
设置price：19.8
设置quantity：1000
执行init()方法
======IoC容器已初始化======
订单金额为：19800.0
释放与订单对象相关的资源

Process finished with exit code 0
</code></pre>
<h3 id="实现极简IoC容器-利用反射机制完成对象的创建和注入"><a href="#实现极简IoC容器-利用反射机制完成对象的创建和注入" class="headerlink" title="实现极简IoC容器 [利用反射机制完成对象的创建和注入]"></a>实现极简IoC容器 [利用反射机制完成对象的创建和注入]</h3><pre><code class="java">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

&lt;!--        Dom4j是Java的XML解析组件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.dom4j&lt;/groupId&gt;
            &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--        jaxen是Xpath表达式解释器--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jaxen&lt;/groupId&gt;
            &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
            &lt;version&gt;1.1.6&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">Apple.java
public class Apple &#123;
    private String title;
    private String color;
    private String origin;
&#125; + Getter Setter
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans&gt;
    &lt;bean id = &quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.context.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt; //这里的title是在setter中 public void setTitle(String title)&#123;this.title=title;&#125;
        &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt;
        &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">ApplicationContext.java[接口]
package com.imooc.spring.ioc.context;

public interface ApplicationContext &#123;
    public Object getBean(String beanId);
&#125;
</code></pre>
<pre><code class="java">ClassPathXmlApplicationContext.java
package com.imooc.spring.ioc.context;

import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;

import java.io.File;
import java.lang.reflect.Method;
import java.net.URLDecoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClassPathXmlApplicationContext implements ApplicationContext&#123;
    private Map iocContainer = new HashMap();
    public ClassPathXmlApplicationContext()&#123;
        try &#123;
            String filePath = this.getClass().getResource(&quot;/applicationContext.xml&quot;).getPath();
            filePath = new URLDecoder().decode(filePath,&quot;UTF-8&quot;);
            SAXReader reader = new SAXReader();
            Document document = reader.read(new File(filePath));
            List&lt;Node&gt; beans = document.getRootElement().selectNodes(&quot;bean&quot;);//得到节点的集合
            for (Node node:beans)&#123;
                Element ele = (Element) node;
                String id = ele.attributeValue(&quot;id&quot;);
                String className = ele.attributeValue(&quot;class&quot;);
                Class c = Class.forName(className);//加载指定类
                Object obj = c.newInstance();
                List&lt;Node&gt; properties = ele.selectNodes(&quot;property&quot;);
                for (Node p:properties)&#123;
                    Element property = (Element) p;
                    String propName = property.attributeValue(&quot;name&quot;);
                    String propValue= property.attributeValue(&quot;value&quot;);
//基于property完成注入是通过Setter的set方法，set方法命名的格式为setTitle 属性名第一个字母有个大写
                    String setMethodName = &quot;set&quot; + propName.substring(0,1).toUpperCase()+propName.substring(1);
                    System.out.println(&quot;准备执行&quot; + setMethodName + &quot;方法注入数据&quot;);
                    Method setMethod = c.getMethod(setMethodName, String.class);
                    setMethod.invoke(obj, propValue); //执行哪个对象的实例方法
                &#125;
                iocContainer.put(id,obj); //赋予了bean id
            &#125;
            System.out.println(iocContainer);
            System.out.println(&quot;IoC容器初始化完毕&quot;);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    @Override
    public Object getBean(String beanId) &#123;
        return iocContainer.get(beanId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Application.java
package com.imooc.spring.ioc.context;

public class Application &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext();
        Apple apple = (Apple) context.getBean(&quot;sweetApple&quot;);
        System.out.println(apple);
    &#125;
&#125;

=================================================
准备执行setTitle方法注入数据
准备执行setColor方法注入数据
准备执行setOrigin方法注入数据
&#123;sweetApple=com.imooc.spring.ioc.context.Apple@484b61fc&#125;
IoC容器初始化完毕
com.imooc.spring.ioc.context.Apple@484b61fc

Process finished with exit code 0
</code></pre>
<h3 id="四种组件类型注解"><a href="#四种组件类型注解" class="headerlink" title="四种组件类型注解"></a>四种组件类型注解</h3><h5 id="基于注解配置IoC容器"><a href="#基于注解配置IoC容器" class="headerlink" title="基于注解配置IoC容器"></a>基于注解配置IoC容器</h5><h6 id="基于注解的优势"><a href="#基于注解的优势" class="headerlink" title="基于注解的优势"></a>基于注解的优势</h6><ul>
<li>摆脱繁琐的XML形式的bean与依赖注入配置</li>
<li>基于”声明式”的原则,更适合轻量级的现代企业应用</li>
<li>让代码可读性变得更好,研发人员拥有更好的开发体验</li>
</ul>
<h5 id="三类注解"><a href="#三类注解" class="headerlink" title="三类注解"></a><span style = "color:red">三类注解</span></h5><ul>
<li>四种组件类型注解-声明当前类的功能与职责</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化</td>
</tr>
<tr>
<td><strong>@Controller</strong></td>
<td>语义注解,说明当前类是MVC应用中的控制器类</td>
</tr>
<tr>
<td><strong>@Service</strong></td>
<td>语义注解,说明当前类是Service业务服务类</td>
</tr>
<tr>
<td><strong>@Repository</strong></td>
<td>语义注解,说明当前类用于业务持久层,通常描述对应Dao类</td>
</tr>
</tbody></table>
<p>   <strong>开启组件扫描</strong></p>
<pre><code class="xml">XML配置开启组件扫描,才能使用注解
&lt;context:component-scan base-package=&quot;com.imooc&quot;&gt;
   &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;com.imooc.exl.*&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre>
<ul>
<li>自动装配注解-根据属性特征自动注入对象</li>
<li>元数据注解-更细化的辅助IoC容器管理对象的注解</li>
</ul>
<h3 id="基于注解初始化IoC容器"><a href="#基于注解初始化IoC容器" class="headerlink" title="基于注解初始化IoC容器"></a>基于注解初始化IoC容器</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config">Core Technologies (spring.io)</a></p>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
&lt;!--
    在IoC容器初始化时自动扫描四种组件类型注解并完成实例化
    @Repository
    @Service
    @Controller
    @Component
--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt; //设置基准的包名去扫描

&lt;/beans&gt;
</code></pre>
<pre><code class="java">controller/UserController.java
package com.imooc.spring.ioc.controller;

import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
&#125;
</code></pre>
<pre><code class="java">dao/UserDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.stereotype.Repository;

//组件类型解释默认beanId为类名首字母小写
//组件类型解释默认beanId为类名首字母小写
//beanId = userDao
@Repository
public class UserDao &#123;

&#125;
</code></pre>
<pre><code class="java">service/UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.stereotype.Service;

@Service
public class UserService &#123;

&#125;
</code></pre>
<pre><code class="java">utils/StringUtils.java
package com.imooc.spring.ioc.utils;

import org.springframework.stereotype.Component;

@Component
public class StringUtils &#123;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123; //这些bean在容器中是单例，在初始化的时候创建对象
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;
==============================================================
//组件类型解释默认beanId为类名首字母小写
userController:com.imooc.spring.ioc.controller.UserController@4f51b3e0
userDao:com.imooc.spring.ioc.dao.UserDao@4b9e255
userService:com.imooc.spring.ioc.service.UserService@5e57643e
stringUtils:com.imooc.spring.ioc.utils.StringUtils@133e16fd
    
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@51b279c9
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@1ad282e0
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@7f416310
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@1cab0bfb
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@5e955596

Process finished with exit code 0
</code></pre>
<h3 id="自动装配与Autowired注解"><a href="#自动装配与Autowired注解" class="headerlink" title="自动装配与Autowired注解"></a>自动装配与Autowired注解</h3><h5 id="两类自动装配注解-Primary-如果有两个写此注解作为主要"><a href="#两类自动装配注解-Primary-如果有两个写此注解作为主要" class="headerlink" title="两类自动装配注解  [@Primary 如果有两个写此注解作为主要]"></a>两类自动装配注解  [@Primary 如果有两个写此注解作为主要]</h5><table>
<thead>
<tr>
<th>分类</th>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>按类型装配</td>
<td>@Autowired</td>
<td>按容器内对象类型动态注入属性,由Spring机构提供</td>
</tr>
<tr>
<td></td>
<td>@Inject</td>
<td>基于JSR-330标准,其他同@Autowired,但不支持required属性</td>
</tr>
<tr>
<td>按名称装配</td>
<td>@Named</td>
<td>与@Inject配合使用,JSR-330规范,按属性名自动装配属性</td>
</tr>
<tr>
<td></td>
<td><span style = "color:red">@Resource</span></td>
<td><span style = "color:red">基于JSR-250规范,优先按名称，再按类型智能匹配</span></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>这是默认的自动装配模式，意味着默认情况下没有自动装配</td>
</tr>
<tr>
<td>byName</td>
<td>byName模式根据bean的名称注入对象依赖项。在这种情况属性名称和bean名称必须相同，它在内部调用setter方法</td>
</tr>
<tr>
<td>byType</td>
<td>byType模式根据类型注入对象依赖项，因此属性名称和bean名称可以不同，它在内部调用setter方法</td>
</tr>
<tr>
<td>constructor</td>
<td>构造函数模式通过调用类的构造函数来注入依赖项。它会调用具有大量参数的构造函数。</td>
</tr>
<tr>
<td>autodetect</td>
<td>从Spring 3开始不推荐使用</td>
</tr>
</tbody></table>
<h5 id="无法确认注入哪个bean-解决方案【UserDao-与-UserOracleDao】"><a href="#无法确认注入哪个bean-解决方案【UserDao-与-UserOracleDao】" class="headerlink" title="无法确认注入哪个bean 解决方案【UserDao 与 UserOracleDao】"></a>无法确认注入哪个bean 解决方案【UserDao 与 UserOracleDao】</h5><pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;

//组件类型解释默认beanId为类名首字母小写
//beanId = userDao
@Repository
public class UserDao implements IUserDao&#123;
    public UserDao()&#123;
        System.out.println(&quot;正在创建UseDao：&quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserOracleDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;
@Repository
@Primary
public class UserOracleDao implements IUserDao&#123;

    public UserOracleDao()&#123;
        System.out.println(&quot;正在创建UserOracleDao：&quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">IUserDao.java [接口]
package com.imooc.spring.ioc.dao;

public interface IUserDao &#123;
&#125;
</code></pre>
<pre><code class="java">DepartmentService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

@Service
public class DepartmentService &#123;
    /**
     * 1. @Resource设置name属性,则按name在IoC容器中将bean注入
     * 2. @Resource未设置name属性
     *  2.1 以属性名作为bean name在IoC容器中匹配bean，如有匹配则注入
     *  2.2 按属性名未匹配，则按类型进行匹配，同 @Autowired 需要加入 @Primary解决类型冲突
     *  使用建议: 在使用 @Resource对象时推荐设置name或保证属性名与bean名称一致
     */
    /*方法2.2.1
    @Resource(name = &quot;userOracleDao&quot;)
    private IUserDao udao;*/

    //方法2.2.2
    @Resource
    private IUserDao userOracleDao;
    public void joinDepartment()&#123;
        System.out.println(userOracleDao);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService &#123;
    //@Autowired
    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值
    //不再执行set方法
    private IUserDao udao;

    public UserService() &#123;
        System.out.println(&quot;正在构建UserService&quot; + this);
    &#125;

    public IUserDao getUdao() &#123;
        return udao;
    &#125;

    @Autowired
    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入
    public void setUdao(UserDao udao) &#123;
        System.out.println(&quot;setUdao: &quot; + udao);
        this.udao = udao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java 
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import com.imooc.spring.ioc.service.DepartmentService;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        System.out.println(userService.getUdao());
        DepartmentService departmentService = context.getBean(&quot;departmentService&quot;, DepartmentService.class);
        departmentService.joinDepartment();
    &#125;
&#125;
</code></pre>
<h3 id="元数据注解"><a href="#元数据注解" class="headerlink" title="元数据注解"></a>元数据注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Primary</td>
<td>按类型装配时出现多个相同类型对象,拥有此注解对象优先被注入</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>描述方法,相当于XML中init-method配置的注解版本</td>
</tr>
<tr>
<td>@PreDestory</td>
<td>描述方法,相当于XML中destory-method配置的注解版本</td>
</tr>
<tr>
<td>@Scope</td>
<td>设置对象的scope属性  &#x2F;&#x2F;@Scope(“prototype”)设置多例</td>
</tr>
<tr>
<td>@Value</td>
<td>为属性注入静态数据</td>
</tr>
</tbody></table>
<pre><code class="java">applicationContext.xml 【新增第11行】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
&lt;!--    加载指定路径下的properties文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&gt;
&lt;!--
    在IoC容器初始化时自动扫描四种组件类型注解并完成实例化
    @Repository
    @Service
    @Controller
    @Component
--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">config.properties [这里属于动态注入噢~]
  metaData=imooc.com
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;

@Service
@(&quot;prototype&quot;) //设置多例 与XML中bean scope完全相同
public class UserService &#123;
    @Value(&quot;$&#123;metaData&#125;&quot;)
    private String metaData; //对此数据的动态注入

    //@Autowired
    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值
    //不再执行set方法
    public UserService() &#123;
        System.out.println(&quot;正在构建UserService&quot; + this);
    &#125;

    @PostConstruct //XML中bean init-method完全相同
    public void init()&#123;
        System.out.println(&quot;初始化UserService对象,metaData=&quot; + metaData);
    &#125;
    private IUserDao udao;


    public IUserDao getUdao() &#123;
        return udao;
    &#125;

    @Autowired
    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入
    public void setUdao(UserDao udao) &#123;
        System.out.println(&quot;setUdao: &quot; + udao);
        this.udao = udao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import com.imooc.spring.ioc.service.DepartmentService;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        System.out.println(userService.getUdao());
    &#125;
&#125;
</code></pre>
<h3 id="基于Java-Config配置IoC容器"><a href="#基于Java-Config配置IoC容器" class="headerlink" title="基于Java Config配置IoC容器"></a>基于Java Config配置IoC容器</h3><ul>
<li>完全摆脱XML的束缚, 使用独立Java类管理对象与依赖</li>
<li>注解配置相对分散, 利用Java Config可对配置集中管理</li>
<li>可以在编译时进行依赖检查, 不容易出错</li>
</ul>
<h5 id="Java-Config核心注解【敏捷开发-小型项目】-而XML是大型团队项目"><a href="#Java-Config核心注解【敏捷开发-小型项目】-而XML是大型团队项目" class="headerlink" title="Java Config核心注解【敏捷开发 小型项目】 而XML是大型团队项目"></a>Java Config核心注解【敏捷开发 小型项目】 而XML是大型团队项目</h5><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Configuration</strong></td>
<td>描述类, 说明当前类是Java Config配置类, 完全替代XML文件</td>
</tr>
<tr>
<td>@<strong>Bean</strong></td>
<td>描述方法, 方法返回对象将被IoC容器管理, beanId默认为方法名</td>
</tr>
<tr>
<td>@ImportResource</td>
<td>描述类, 加载静态文件, 可使用@Value注解获取</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>描述类, 同XML的 &lt; context:compoment-scan &gt;标签</td>
</tr>
</tbody></table>
<pre><code class="java">UserController.java
package com.imooc.spring.ioc.controller;

import com.imooc.spring.ioc.service.UserService;
import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
    private UserService userService;

    public UserService getUserService() &#123;
        return userService;
    &#125;

    public void setUserService(UserService userService) &#123;
        this.userService = userService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    private UserDao userDao;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">Config.java [作为配置文件]
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.controller.UserController;
import com.imooc.spring.ioc.dao.UserDao;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //当前是个配置类,用于代替applicationContext.xml
public class Config &#123;
    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名
    public UserDao userDao()&#123;
        UserDao userDao = new UserDao();
        return userDao;
    &#125;
    @Bean
    public UserService userService()&#123;
        UserService userService = new UserService();
        return userService;
    &#125;
    @Bean
    public UserController userController()&#123;
        UserController userController = new UserController();
        return userController;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //基于Java Config配置IoC容器的初始化
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123;
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;
=======================================================
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@4f9a3314
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@3b2c72c2
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@491666ad
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@176d53b2
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@971d0d8
config:com.imooc.Config.Config$$EnhancerBySpringCGLIB$$c932e406@51931956
userDao:com.imooc.Config.UserDao@2b4a2ec7
userService:com.imooc.Config.UserService@564718df
userController:com.imooc.Config.UserController@51b7e5df
</code></pre>
<h3 id="JavaConfig-对象依赖注入"><a href="#JavaConfig-对象依赖注入" class="headerlink" title="JavaConfig-对象依赖注入"></a>JavaConfig-对象依赖注入</h3><p>Config的括号增加参数</p>
<pre><code class="java">Config.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.controller.UserController;
import com.imooc.spring.ioc.dao.UserDao;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //当前是个配置类,用于代替applicationContext.xml
@ComponentScan(basePackages = &quot;com.imooc&quot;) //扫描其他的组件类 因为其他人也会写
public class Config &#123;
    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名
    public UserDao userDao()&#123;
        UserDao userDao = new UserDao();
        System.out.println(&quot;已创建&quot;+userDao);
        return userDao;
    &#125;
    @Bean
    //先按name尝试注入,name不存在则按类型注入 冲突则@Primary
    public UserService userService(UserDao userDao)&#123;
        UserService userService = new UserService();
        System.out.println(&quot;已创建&quot;+userService);
        userService.setUserDao(userDao);
        System.out.println(&quot;调用setUserDao:&quot; + userDao);
        return userService;
    &#125;
    @Bean //&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot;&gt;
    public UserController userController(UserService userService)&#123;
        UserController userController = new UserController();
        System.out.println(&quot;已创建&quot; + userController);
        userController.setUserService(userService);
        System.out.println(&quot;调用setUserService:&quot;+userService);
        return userController;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //基于Java Config配置IoC容器的初始化
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        System.out.println(&quot;=============================&quot;);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123;
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;

=================================================================
已创建com.imooc.spring.ioc.dao.UserDao@10b48321
已创建com.imooc.spring.ioc.service.UserService@473b46c3
调用setUserDao:com.imooc.spring.ioc.dao.UserDao@10b48321
已创建com.imooc.spring.ioc.controller.UserController@797badd3
调用setUserService:com.imooc.spring.ioc.service.UserService@473b46c3
=============================
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@44a664f2
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@7f9fcf7f
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@2357d90a
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@6328d34a
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@145eaa29
config:com.imooc.spring.ioc.Config$$EnhancerBySpringCGLIB$$8a99aa4c@15bb6bea
userDao:com.imooc.spring.ioc.dao.UserDao@10b48321
userService:com.imooc.spring.ioc.service.UserService@473b46c3
userController:com.imooc.spring.ioc.controller.UserController@797badd3

Process finished with exit code 0
</code></pre>
<pre><code class="java">如果突然想增加一个注入employeeDao
UserService.java 先增加一个私有的名字 再getter+setter
去Conifg.java 括号里新增
public UserService userService(UserDao userDao, EmployeeDao employeeDao)&#123;
        UserService userService = new UserService();
        System.out.println(&quot;已创建&quot;+userService);
        userService.setUserDao(userDao);
        System.out.println(&quot;调用setUserDao:&quot; + userDao);
        userService.setEmployeeDao(employeeDao);
        return userService;
    &#125;
</code></pre>
<h3 id="Spring-Test测试模块"><a href="#Spring-Test测试模块" class="headerlink" title="Spring Test测试模块"></a>Spring Test测试模块</h3><ul>
<li>Spring Test是Spring中用于测试的模块</li>
<li>Spring Test对JUnit单元测试框架有良好的整合</li>
<li>通过Spring Test可在Junit单元测试时自动初始化IoC容器</li>
</ul>
<h5 id="Spring与JUnit4整合过程"><a href="#Spring与JUnit4整合过程" class="headerlink" title="Spring与JUnit4整合过程"></a>Spring与JUnit4整合过程</h5><ul>
<li>Maven工程依赖spring-test</li>
<li>利用 <strong>@RunWith</strong> 与 <strong>@ContextConfiguration</strong>描述测试用例类</li>
<li>测试用例类从容器获取对象完成测试用例的执行</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
        &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    private UserDao userDao;
    public void createUser()&#123;
        System.out.println(&quot;调用创建用户业务代码&quot;);
        userDao.insert();
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot;&gt;

    &lt;/bean&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringTestor.java
import com.imooc.spring.ioc.service.UserService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

//将Junit4的执行权交给Spring Test,在测试用例执行前自动初始化IoC容器
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class SpringTestor &#123;
    @Resource
    private UserService userService;

    @Test
    public void testUserService()&#123;
        userService.createUser();
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<h3 id="介绍AOP"><a href="#介绍AOP" class="headerlink" title="介绍AOP"></a>介绍AOP</h3><p><strong>Aspect Oriented Programming</strong>(AOP)从某种意义上说是对OOP的补充，因为它还提供了模块化的功能。但是模块化的关键单元是方面而不是类。</p>
<h5 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h5><ul>
<li>介绍Spring AOP与相关概念名词</li>
<li>Spring AOP开发与配置流程</li>
<li>Spring 五种通知类型与应用场景</li>
</ul>
<h5 id="Spring中的可插拔组件技术-类似于插件"><a href="#Spring中的可插拔组件技术-类似于插件" class="headerlink" title="Spring中的可插拔组件技术 [类似于插件]"></a>Spring中的可插拔组件技术 [类似于插件]</h5><p>应用程序执行前检测的作用</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/63abc993304f86f346667a404430e2ad28f989cb/data/Spring%E4%B8%AD%E7%9A%84%E5%8F%AF%E6%8F%92%E6%8B%94%E7%BB%84%E4%BB%B6%E6%8A%80%E6%9C%AF.jpg"></p>
<h5 id="Spring-AOP-在不修改源码的情况下对程序进行扩展"><a href="#Spring-AOP-在不修改源码的情况下对程序进行扩展" class="headerlink" title="Spring AOP [在不修改源码的情况下对程序进行扩展]"></a>Spring AOP [在不修改源码的情况下对程序进行扩展]</h5><p>[IDEA创建项目出现Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45429409/article/details/118068484?ops_request_misc=%7B%22request_id%22:%22170678007016800227455895%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=170678007016800227455895&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118068484-null-null.142%5Ev99%5Epc_search_result_base9&amp;utm_term=Cannot">https://blog.csdn.net/weixin_45429409/article/details/118068484?ops_request_misc=%7B%22request%5Fid%22%3A%22170678007016800227455895%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170678007016800227455895&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118068484-null-null.142^v99^pc_search_result_base9&amp;utm_term=Cannot</a> resolve plugin org.apache.maven.plugins%3Amaven-site-plugin%3A3.3&amp;spm&#x3D;1018.2226.3001.4187)</p>
<ul>
<li>Spring AOP - Aspect Oriented Programming 面向切面编程</li>
<li>AOP的做法是将通用、与业务无关的功能抽象封装为切面类</li>
<li>切面可配置在<strong>目标方法</strong>的执行前、后运行，真正做到即插即用</li>
</ul>
<p>运行前进行拦截在运行前打印时间 再运行代码；没有IoC就没有AOP；写完扩展之后要再applicationContext.xml中新增&lt; aop:config &gt;…来认可切面</p>
<pre><code class="java">aop/dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

/**
 * 员工表Dao
 */
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
---------------------------------------------
aop/dao/UserDao.java
package com.imooc.spring.aop.dao;

/**
 * 用户表Dao
 */
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
---------------------------------------------
aop/service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;

import java.util.Date;

/**
 * 员工服务
 */
public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
---------------------------------------------
aop/service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;

/**
 * 用户服务
 */
public class UserService &#123;
    private UserDao userDao;

    public void createUser()&#123;
        if(1==1)&#123;
            throw new RuntimeException(&quot;用户已存在&quot;);
        &#125;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
---------------------------------------------
aop/aspect/MethodAspect
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.JoinPoint;

import java.text.SimpleDateFormat;
import java.util.Date;

//切面类
public class MethodAspect &#123;
    //切面方法,用于扩展额外功能
    //JoinPoint 连接点,通过连接点可以获取目标类/方法的信息
    public void printExecutionTime(JoinPoint joinPoint)&#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        String now = sdf.format(new Date());
        String className = joinPoint.getTarget().getClass().getName();//获取类→获取目标类的名称
        String methodName = joinPoint.getSignature().getName();//获取目标方法名称
        System.out.println(&quot;----&gt;&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName);
        Object[] args = joinPoint.getArgs();
        System.out.println(&quot;----&gt;参数个数:&quot; + args.length);
        for(Object arg:args)&#123;
            System.out.println(&quot;----&gt;参数:&quot; + arg);
        &#125;
    &#125;

    public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123;
        System.out.println(&quot;&lt;----返回后通知:&quot; + ret);
    &#125;
    public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123;
        System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage());
    &#125;
    public void doAfter(JoinPoint joinPoint)&#123;
        System.out.println(&quot;&lt;----触发后置通知&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser(); //模拟创建新用户过程
        userService.generateRandomPassword(&quot;MD5&quot;, 16);
    &#125;
&#125;
====================================================================
----&gt;2024-02-01 18:09:38 050:com.imooc.AOP.UserService.createUser
----&gt;参数个数:0
执行创建用户业务逻辑
新增用户数据
&lt;----返回后通知:null
&lt;----触发后置通知
----&gt;2024-02-01 18:09:38 058:com.imooc.AOP.UserService.generateRandomPassword
----&gt;参数个数:2
----&gt;参数:MD5
----&gt;参数:16
按MD5方式生成16位随机密码
&lt;----返回后通知:PzZo3Fzqe!r4$
&lt;----触发后置通知
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
        &lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!--关联一下--&gt;
            &lt;!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt;
            &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; throwing=&quot;th&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;aop&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--aspectjweaver是Spring AOP的底层依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="Spring-AOP-与-AspectJ的关系-实现类与方法的匹配"><a href="#Spring-AOP-与-AspectJ的关系-实现类与方法的匹配" class="headerlink" title="Spring AOP 与 AspectJ的关系 [实现类与方法的匹配]"></a>Spring AOP 与 <u>AspectJ</u>的关系 [实现类与方法的匹配]</h3><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15949848/6813110">Spring【SpringAOP（通知类型、切点表达式 、多切面配置 、注解配置AOP、原生Spring实现AOP）】(六)-全面详解（学习总结—从入门到深化）_童小纯呀的技术博客_51CTO博客</a></p>
<ul>
<li>Eclips AspectJ 是一种基于Java平台的面向切面编程的语言</li>
<li>Spring AOP使用AspectJWeaver实现类与方法匹配</li>
<li><strong>Spring AOP利用<u>代理模式</u>实现对象运行时功能扩展</strong></li>
</ul>
<h5 id="几个关键概念"><a href="#几个关键概念" class="headerlink" title="几个关键概念"></a>几个关键概念</h5><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Aspect</td>
<td>切面,具体的可插拔组件功能类,通常一个切面只能实现一个通用功能</td>
</tr>
<tr>
<td>Target Class&#x2F;Method</td>
<td>目标类、目标方法,指真正要执行与业务相关的方法</td>
</tr>
<tr>
<td><strong>PointCut</strong></td>
<td>切入点,<strong>使用execution表达式</strong>说明切面要作用再系统的哪些类上</td>
</tr>
<tr>
<td><strong>JoinPoint</strong></td>
<td>连接点,切面运行过程中是包含了目标类&#x2F;方法元数据的对象</td>
</tr>
<tr>
<td>Advice</td>
<td>通知,说明具体的切面的执行时机,Spring包含了不中不同类型通知</td>
</tr>
</tbody></table>
<blockquote>
<p>JoinPoint 连接点,通过连接点可以获取目标类&#x2F;方法的信息<br>public void printExecutionTime(JoinPoint joinPoint){}</p>
</blockquote>
<p><span style = "color:red"><strong>Spring AspectJ AOP实现提供了许多注释：</strong></span></p>
<p><strong>@Aspect</strong> 将该类声明为方面。<br><strong>@Pointcut</strong> 声明切入点表达式。</p>
<p>用于创建建议的注释如下:</p>
<p><strong>@Before</strong> 声明before建议。在调用实际方法之前将其应用。<br><strong>@After</strong> 声明after建议。在调用实际方法之后并返回结果之前应用。<br><strong>@AfterReturning</strong> 声明返回建议之后。在调用实际方法之后并返回结果之前应用。但是您可以在建议中获得结果值。<br><strong>@Around</strong> 声明环绕建议。它在调用实际方法之前和之后应用。<br><strong>@AfterThrowing</strong> 声明了throws建议。如果实际方法引发异常，则应用此方法。</p>
<h5 id="AOP配置过程"><a href="#AOP配置过程" class="headerlink" title="AOP配置过程"></a>AOP配置过程</h5><ul>
<li>依赖AspectJ</li>
<li>实现切面类&#x2F;方法</li>
<li>配置Aspect Bean</li>
<li>定义PointCut</li>
<li>配置Advice  &#x2F;&#x2F;before通知(Advice)</li>
</ul>
<h3 id="JoinPoint核心方法"><a href="#JoinPoint核心方法" class="headerlink" title="JoinPoint核心方法"></a>JoinPoint核心方法</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object getTarget()</td>
<td>获取IoC容器内目标对象</td>
</tr>
<tr>
<td>Signature getSignature()</td>
<td>获取目标方法</td>
</tr>
<tr>
<td>Object[] getArgs()</td>
<td>获取目标方法<strong>参数</strong></td>
</tr>
</tbody></table>
<pre><code class="java">//很多线上的项目需要跟踪调试却不知道输入的参数是什么 就可以增加切片
public void printExecutionTime(JoinPoint joinPoint)&#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        String now = sdf.format(new Date());
        String className = joinPoint.getTarget().getClass().getName();//获取类→获取目标类的名称
        String methodName = joinPoint.getSignature().getName();//获取目标方法名称
        System.out.println(&quot;----&gt;&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName);
        Object[] args = joinPoint.getArgs(); //传入目标方法的实际参数
        System.out.println(&quot;----&gt;参数个数:&quot; + args.length);
        for(Object arg:args)&#123;
            System.out.println(&quot;----&gt;参数:&quot; + arg);
        &#125;
    &#125;
</code></pre>
<h3 id="PointCut切点表达式-pointcut"><a href="#PointCut切点表达式-pointcut" class="headerlink" title="PointCut切点表达式 [@pointcut]"></a>PointCut切点表达式 [@pointcut]</h3><p>注释用于定义切入点。我们也可以通过名称引用切入点表达式</p>
<pre><code class="java">@Pointcut(&quot;execution(* Operation.*(..))&quot;)
private void doSomething() &#123;&#125;

//它将应用于所有公共方法
@Pointcut(&quot;execution(public * * (..))&quot;)

//它将应用于Operation类的所有公共方法
@Pointcut(&quot;execution(public Operation.*(..))&quot;)

//它将应用于Operation类的所有方法
@Pointcut(&quot;execution(* Operation.*(..))&quot;)

//它将应用于Employee类的所有公共设置方法
@Pointcut(&quot;execution(public Employee.set*(..))&quot;)

//它将应用于所有返回int值的Operation类方法
@Pointcut(&quot;execution(int Operation.*(..))&quot;)
</code></pre>
<blockquote>
<p>​                   public void com.imooc.service.UserService.createUser(形参1,形参2,..)<br>  ​                    ↑         ↑             ↑                 ↑                 ↑                   ↑                  ↑</p>
<p>execution(public   *     com.imooc       ..                 *       .           *       (          ..          ))<br>*通配符                            ..包通配符[包括所有后代查找]                            (..)参数通配符</p>
<p>第一项public可以默认</p>
</blockquote>
<pre><code class="xml">&lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;/aop:config&gt;

---------------------------------------------------------------------------------
切点表达式训练
&lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
</code></pre>
<h3 id="五种通知类型"><a href="#五种通知类型" class="headerlink" title="五种通知类型"></a>五种通知类型</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Before Advice</td>
<td>前置通知,目标方法运行前执行</td>
</tr>
<tr>
<td>After Returning Advice</td>
<td>返回后通知,目标方法返回数值后执行</td>
</tr>
<tr>
<td>After Throwing Advice</td>
<td>异常通知,目标方法抛出异常后执行</td>
</tr>
<tr>
<td>After Advice</td>
<td>后置通知,目标方法运行后执行</td>
</tr>
<tr>
<td><span style = " color : red"><strong>Around Advice</strong></span></td>
<td><span style = "color:red"><strong>最强大通知,自定通知执行时机,可决定目标方法是否运行</strong></span></td>
</tr>
</tbody></table>
<pre><code class="java">@Around(&quot;execution(* com.imooc..*Service.*(..))&quot;) 【通知 切面表达式】
    // @Before()   @After()   @AfterThrowing   @AfterReturning
    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
</code></pre>
<p><span style = " color : red"><strong>用于创建建议的注释如下：</strong></span></p>
<p><strong>@Before</strong> 声明before建议。在调用实际方法之前将其应用。<br><strong>@After</strong> 声明after建议。在调用实际方法之后并返回结果之前应用。<br><strong>@AfterReturning</strong> 声明返回建议之后。在调用实际方法之后并返回结果之前应用。但是您可以在建议中获得结果值。<br><strong>@Around</strong> 声明环绕建议。它在调用实际方法之前和之后应用。<br><strong>@AfterThrowing</strong> 声明了throws建议。如果实际方法引发异常，则应用此方法。</p>
<p><span style = " color : red"><strong>让我们看看用于定义建议的xml元素：</strong></span><br><a target="_blank" rel="noopener" href="https://www.cainiaoplus.com/spring/spring-aop-aspectj-xml-configuration-example.html">Spring AOP AspectJ Xml配置示例 - Spring教程 - 菜鸟教程 (cainiaoplus.com)</a><br>**<code>aop: before </code>**在调用实际的业务逻辑方法之前应用。<br>**<code>aop: after </code>**在调用实际的业务逻辑方法之后应用。<br>**<code>aop: 返回后</code>**在调用实际的业务逻辑方法后应用。可用于拦截通知中的返回值。<br>**<code>aop: around </code>**在调用实际的业务逻辑方法之前和之后都将应用。<br>**<code>aop: 投掷后</code>**如果实际的业务逻辑方法抛出异常，则将其应用。</p>
<h5 id="特殊的“通知”-引介增强"><a href="#特殊的“通知”-引介增强" class="headerlink" title="特殊的“通知” - 引介增强"></a>特殊的“通知” - 引介增强</h5><ul>
<li>引介增强是对类的增强,而非方法</li>
<li>引介增强允许再运行时为目标类增加新属性或方法</li>
<li>引介增强允许再运行时改变类的行为,让类随运行环境动态变更</li>
</ul>
<pre><code class="java">MethodAspect.java
    public void doAfter(JoinPoint joinPoint)&#123;
        System.out.println(&quot;&lt;----触发后置通知&quot;);
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
</code></pre>
<pre><code class="java">MethodAspect.java
     public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123;
        System.out.println(&quot;&lt;----返回后通知:&quot; + ret);
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    
</code></pre>
<pre><code class="java">MethodAspect.java
public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123;
        System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage());
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;

打印顺序根据applicationContext.xml代码排列顺序一致
</code></pre>
<pre><code class="xml">applicationContext.xml [最终]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
        &lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!--关联一下--&gt;
            &lt;!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt;
            &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; throwing=&quot;th&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser(); //模拟创建新用户过程
        userService.generateRandomPassword(&quot;MD5&quot;, 15);
    &#125;
&#125;
===========================================================
----&gt;2024-01-12 13:40:56 885:com.imooc.spring.aop.service.UserService.createUser
----&gt;参数个数:0
&lt;----异常通知:用户已存在
&lt;----触发后置通知
Exception in thread &quot;main&quot; java.lang.RuntimeException: 用户已存在
    
</code></pre>
<hr>
<hr>
<h5 id="Before示例"><a href="#Before示例" class="headerlink" title="@Before示例"></a>@Before示例</h5><p>在实际业务逻辑方法之前应用AspectJ Before Advice。您可以在此处执行任何操作，例如转换，身份验证等。</p>
<p>创建一个包含实际业务逻辑的类</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg method invoked&quot;);&#125;
    public int m()&#123;System.out.println(&quot;m method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>现在，创建包含在建议之前的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation&#123;
    //它将应用于Operation类的所有方法。
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void k()&#123;&#125;//pointcut name
    
    @Before(&quot;k()&quot;)//在before通知上应用切入点
    public void myadvice(JoinPoint jp)//it is advice (before advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;
</code></pre>
<p>现在创建定义bean的applicationContext.xml文件</p>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/aop 
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
    &lt;bean id=&quot;trackMyBean&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
    &lt;bean class=&quot;org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>现在，让我们称为实际方法</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling msg...&quot;);
        e.msg();
        System.out.println(&quot;calling m...&quot;);
        e.m();
        System.out.println(&quot;calling k...&quot;);
        e.k();
    &#125;
&#125;

===========================================================================
calling msg...
additional concern
msg() method invoked
calling m...
additional concern
m() method invoked
calling k...
additional concern
k() method invoked
</code></pre>
<h5 id="apo-before示例"><a href="#apo-before示例" class="headerlink" title="apo:before示例"></a>apo:before示例</h5><p>在实际业务逻辑方法之前应用”先行AspectJ建议”。您可以在此处执行任何操作，例如转换，身份验证等。<br>创建一个包含实际业务逻辑的类</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg method invoked&quot;);&#125;
    public int m()&#123;System.out.println(&quot;m method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>现在，创建包含在建议之前的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
public class TrackOperation&#123;
    public void myadvice(JoinPoint jp)//it is advice
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;
</code></pre>
<p>现在创建定义bean的applicationContext.xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;
&lt;aop:aspectj-autoproxy /&gt;
&lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
&lt;bean id=&quot;trackAspect&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
        
&lt;aop:config&gt;
  &lt;aop:aspect id=&quot;myaspect&quot; ref=&quot;trackAspect&quot; &gt;
     &lt;!-- @Before --&gt;
     &lt;aop:pointcut id=&quot;pointCutBefore&quot;    expression=&quot;execution(* com.nhooo.Operation.*(..))&quot; /&gt;
     &lt;aop:before method=&quot;myadvice&quot; pointcut-ref=&quot;pointCutBefore&quot; /&gt;
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
    
&lt;/beans&gt;
</code></pre>
<p>现在，让我们称为实际方法</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling msg...&quot;);
        e.msg();
        System.out.println(&quot;calling m...&quot;);
        e.m();
        System.out.println(&quot;calling k...&quot;);
        e.k();
    &#125;
&#125;

===================================================================
calling msg...
additional concern
msg() method invoked
calling m...
additional concern
m() method invoked
calling k...
additional concern
k() method invoked
</code></pre>
<p>如您所见，在调用msg()，m()和k()方法之前，还会打印出其他问题。</p>
<hr>
<hr>
<h5 id="After示例"><a href="#After示例" class="headerlink" title="@After示例"></a>@After示例</h5><p>在调用实际的业务逻辑方法之后，应用了after建议之后的AspectJ。它可以用来维护日志，安全性，通知等。<br>在这里，我们假设 <strong>Operation.java</strong> ， <strong>applicationContext.xml</strong> 和 <strong>Test.java</strong> 文件与@Before示例中给出的文件相同。</p>
<pre><code class="java">TrackOperation.Java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation&#123;
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void k()&#123;&#125;//pointcut name
    
    @After(&quot;k()&quot;)//applying pointcut on after advice
    public void myadvice(JoinPoint jp)//it is advice (after advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;

===============================================================
calling msg...
msg() method invoked
additional concern
calling m...
m() method invoked
additional concern
calling k...
k() method invoked
additional concern
</code></pre>
<h5 id="aop-after示例"><a href="#aop-after示例" class="headerlink" title="aop:after示例"></a>aop:after示例</h5><p>在调用实际的业务逻辑方法之后，应用了通知之后的AspectJ。它可用于维护日志，安全性，通知等。<br>在这里，我们假设 **<code>Operation.java </code>**， **<code>TrackOperation.java </code>**和 **<code>Test.java </code>**文件与aop:before 中的示例相同。<br>现在创建定义bean的applicationContext.xml文件。</p>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;
&lt;aop:aspectj-autoproxy /&gt;
&lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
&lt;bean id=&quot;trackAspect&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
        
&lt;aop:config&gt;
  &lt;aop:aspect id=&quot;myaspect&quot; ref=&quot;trackAspect&quot; &gt;
     &lt;!-- @After --&gt;
     &lt;aop:pointcut id=&quot;pointCutAfter&quot;    expression=&quot;execution(* com.nhooo.Operation.*(..))&quot; /&gt;
     &lt;aop:after method=&quot;myadvice&quot; pointcut-ref=&quot;pointCutAfter&quot; /&gt;
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<blockquote>
<pre><code class="java">calling msg...
msg() method invoked
additional concern
calling m...
m() method invoked
additional concern
calling k...
k() method invoked
additional concern
</code></pre>
<p>您可以看到在调用msg()，m()和k()方法之后，还会出现其他问题。</p>
</blockquote>
<hr>
<hr>
<h5 id="AfterReturning示例"><a href="#AfterReturning示例" class="headerlink" title="@AfterReturning示例"></a>@AfterReturning示例</h5><p>通过在<strong>返回建议后</strong>使用，我们可以在建议中获得结果。创建包含以下内容的类业务逻辑。</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public int m()&#123;System.out.println(&quot;m() method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k() method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>创建返回建议后包含的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
@Aspect
public class TrackOperation&#123;
    @AfterReturning(pointcut = &quot;execution(* Operation.*(..))&quot;, returning= &quot;result&quot;)
    
    public void myadvice(JoinPoint jp,Object result)  //it is advice (after returning advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
        System.out.println(&quot;Result in advice: &quot;+result);
        System.out.println(&quot;end of after returning advice...&quot;);
    &#125;
&#125;
</code></pre>
<p>文件: applicationContext.xml    与@Before建议示例中给出的</p>
<p>文件: Test.java   现在创建调用实际方法的Test类。</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling m...&quot;);
        System.out.println(e.m());
        System.out.println(&quot;calling k...&quot;);
        System.out.println(e.k());
    &#125;
&#125;
================================================================
calling m...
m() method invoked
additional concern
Method Signature: int com.nhooo.Operation.m()
Result in advice: 2
end of after returning advice...
2
calling k...
k() method invoked
additional concern
Method Signature: int com.nhooo.Operation.k()
Result in advice: 3
end of after returning advice...
3
</code></pre>
<h3 id="环绕通知-public-Object-check-ProceedingJoinPoint-pjp"><a href="#环绕通知-public-Object-check-ProceedingJoinPoint-pjp" class="headerlink" title="环绕通知 [public Object check(ProceedingJoinPoint pjp)]"></a>环绕通知 [public Object check(ProceedingJoinPoint pjp)]</h3><h5 id="利用AOP进行方法性能筛查-筛查哪个实现时间长-可以进行代码优化"><a href="#利用AOP进行方法性能筛查-筛查哪个实现时间长-可以进行代码优化" class="headerlink" title="利用AOP进行方法性能筛查 [筛查哪个实现时间长 可以进行代码优化]"></a>利用AOP进行方法性能筛查 [筛查哪个实现时间长 可以进行代码优化]</h5><pre><code class="java">dao/UserDao.java
package com.imooc.spring.aop.dao;

/**
 * 用户表Dao
 */
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;

---------------------------------
dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

/**
 * 员工表Dao
 */
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;

/**
 * 员工服务
 */
public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;

---------------------------------
service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;

/**
 * 用户服务
 */
public class UserService &#123;
    private UserDao userDao;

    public void createUser()&#123;
        try &#123;
            Thread.sleep(3000); //沉睡 为了触发环绕通知
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">aspect/MethodChecker.java
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.ProceedingJoinPoint;

import java.text.SimpleDateFormat;
import java.util.Date;

public class MethodChecker &#123;
    ////ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
    public Object check(ProceedingJoinPoint pjp) throws Throwable &#123;
        try &#123;
            long startTime = new Date().getTime();//方法执行前
            Object ret = pjp.proceed();//执行目标方法
            long endTime = new Date().getTime();//
            long duration = endTime - startTime; //方法执行后 执行时长
            if(duration &gt;= 1000)&#123;//认为执行太慢了 打印信息
                String className = pjp.getTarget().getClass().getName();
                String methodName = pjp.getSignature().getName();
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
                String now = sdf.format(new Date());
                System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;);
            &#125;
            return ret;//方法返回
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;Exception message:&quot; + throwable.getMessage());
            throw throwable;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;methodChecker&quot; class=&quot;com.imooc.spring.aop.aspect.MethodChecker&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt; &lt;!--所有类进行拦截--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;aop:aspect ref=&quot;methodChecker&quot;&gt;
            &lt;!--环绕通知--&gt;
            &lt;aop:around method=&quot;check&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;

pom.xml
&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser();
    &#125;
&#125;

==============================================================
执行员工入职业务逻辑
新增用户数据
=======2024-01-12 13:52:41 475:com.imooc.spring.aop.service.UserService.createUser(3010ms)======

Process finished with exit code 0
</code></pre>
<hr>
<hr>
<h3 id="Around示例"><a href="#Around示例" class="headerlink" title="@Around示例"></a>@Around示例</h3><p>围绕通知的AspectJ在调用实际的业务逻辑方法之前和之后都得到应用。在这里，我们是假设  <strong>applicationContext.xml</strong> 文件与@Before示例中给出的文件相同。创建一个包含实际业务逻辑的类。</p>
<pre><code class="java">Operation.java
package com.nhooo;
public class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg() is invoked&quot;);&#125;
    public void display()&#123;System.out.println(&quot;display() is invoked&quot;);&#125;
&#125;
</code></pre>
<p>创建包含围绕建议的方面类。您需要在advice方法中传递  <strong>PreceedingJoinPoint</strong> 引用，以便我们可以通过调用proce来进行请求()方法。文件: TrackOperation.java</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation
&#123;
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void abcPointcut()&#123;&#125;
    
    @Around(&quot;abcPointcut()&quot;)
    public Object myadvice(ProceedingJoinPoint pjp) throws Throwable 
    &#123;
        System.out.println(&quot;Additional Concern Before calling actual method&quot;);
        Object obj=pjp.proceed();
        System.out.println(&quot;Additional Concern After calling actual method&quot;);
        return obj;
    &#125;
&#125;
</code></pre>
<p>现在创建调用实际方法的Test类。</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new classPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation op = (Operation) context.getBean(&quot;opBean&quot;);
        op.msg();
        op.display();
    &#125;
&#125;

================================================================
Additional Concern Before calling actual method
msg() is invoked
Additional Concern After calling actual method
Additional Concern Before calling actual method
display() is invoked
Additional Concern After calling actual method
</code></pre>
<h3 id="基于注解配置Spring-AOP"><a href="#基于注解配置Spring-AOP" class="headerlink" title="基于注解配置Spring AOP"></a>基于注解配置Spring AOP</h3><pre><code class="java">aspect/MethodChecher.java
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

import java.text.SimpleDateFormat;
import java.util.Date;
@Component //标记当前类为组件
@Aspect //说明当前类是切面类
public class MethodChecker &#123;
    //环绕通知,参数为PointCut切点表达式
    @Around(&quot;execution(* com.imooc..*Service.*(..))&quot;)
    // @Before()   @After()   @AfterThrowing   @AfterReturning
    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
    public Object check(ProceedingJoinPoint pjp) throws Throwable &#123;
        try &#123;
            long startTime = new Date().getTime();
            Object ret = pjp.proceed();//执行目标方法
            long endTime = new Date().getTime();
            long duration = endTime - startTime; //执行时长
            if(duration &gt;= 1000)&#123;
                String className = pjp.getTarget().getClass().getName();
                String methodName = pjp.getSignature().getName();
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
                String now = sdf.format(new Date());
                System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;);
            &#125;
            return ret;
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;Exception message:&quot; + throwable.getMessage());
            throw throwable;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dao/UserDao
package com.imooc.spring.aop.dao;

import org.springframework.stereotype.Repository;

/**
 * 用户表Dao
 */
@Repository
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
----------------------------------------------
dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

import org.springframework.stereotype.Repository;

/**
 * 员工表Dao
 */
@Repository
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 用户服务
 */
@Service
public class UserService &#123;
    @Resource
    private UserDao userDao;

    public void createUser()&#123;
        try &#123;
            Thread.sleep(3000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
---------------------------------------------------------
service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 员工服务
 */
@Service
public class EmployeeService &#123;
    @Resource
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser();
    &#125;
&#125;
========================================================================
执行员工入职业务逻辑
新增用户数据
=======2024-01-12 17:06:18 669:com.imooc.spring.aop.service.UserService.createUser(3015ms)======

Process finished with exit code 0
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!--初始化IoC容器--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
  ★  &lt;!--启用Spring AOP注解模式--&gt; ★
    &lt;aop:aspectj-autoproxy/&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="增加了是说明这个类是需要被IoC实例化的"><a href="#增加了是说明这个类是需要被IoC实例化的" class="headerlink" title="增加了是说明这个类是需要被IoC实例化的"></a>增加了是说明这个类是需要被IoC实例化的</h6><ul>
<li>四种组件类型注解-声明当前类的功能与职责 【回忆上面的知识点】</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化</td>
</tr>
<tr>
<td><strong>@Controller</strong></td>
<td>语义注解,说明当前类是MVC应用中的控制器类</td>
</tr>
<tr>
<td><strong>@Service</strong></td>
<td>语义注解,说明当前类是Service业务服务类</td>
</tr>
<tr>
<td><strong>@Repository</strong></td>
<td>语义注解,说明当前类用于业务持久层,通常描述对应Dao类</td>
</tr>
</tbody></table>
<h3 id="Spring-AOP实现原理"><a href="#Spring-AOP实现原理" class="headerlink" title="Spring AOP实现原理"></a>Spring AOP实现原理</h3><h6 id="★★★★★-面试-Spring-AOP-底层的实现原理-★★★★★★"><a href="#★★★★★-面试-Spring-AOP-底层的实现原理-★★★★★★" class="headerlink" title="★★★★★ 面试 Spring AOP 底层的实现原理 ★★★★★★"></a><span style = "color:red">★★★★★ 面试 Spring AOP 底层的实现原理 ★★★★★★</span></h6><ul>
<li><span style = "color:blue">Spring基于<strong>代理模式</strong>实现功能动态扩展，包含两种形式：</span><ul>
<li><strong><span style = "color:blue">目标类拥有接口，通过JDK动态代理实现功能扩展 来实现目标类的代理从而实现扩展</span></strong></li>
<li><strong><span style = "color:blue">目标类没有接口，通过CGLib组件实现功能扩展 通过继承的方式实现扩展</span></strong></li>
</ul>
</li>
</ul>
<h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><ul>
<li>代理模式通过代理对象对原对象的实现功能扩展</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1d5a848e492cf6e991719bfdc5cbbd31ef8a31fb/data/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png"></p>
<p>基于UserService接口实现代理类 同时持有与之对应的具体实现</p>
<h6 id="静态代理-每一个具体的委托类都要手动创造一个代理类"><a href="#静态代理-每一个具体的委托类都要手动创造一个代理类" class="headerlink" title="静态代理 [每一个具体的委托类都要手动创造一个代理类]"></a>静态代理 [每一个具体的委托类都要手动创造一个代理类]</h6><pre><code class="java">aop/service/UserService [接口]
package com.imooc.spring.aop.service;

public interface UserService &#123;
    public void createUser();
&#125;
-------------------------------------
aop/service/UserServiceImpl.java
package com.imooc.spring.aop.service;

public class UserServiceImpl implements UserService&#123;
    public void createUser() &#123;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
    &#125;
&#125;
-------------------------------------
aop/service/UserServiceProxy.java [代理]
package com.imooc.spring.aop.service;

import java.text.SimpleDateFormat;
import java.util.Date;
//静态代理是指必须手动创建代理类的代理模式使用方式
public class UserServiceProxy implements UserService&#123;
    //持有委托类的对象
    private UserService userService;
    public UserServiceProxy(UserService userService)&#123;
        this.userService = userService;
    &#125;

    public void createUser() &#123;
        System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;);
        userService.createUser();
    &#125;
&#125;
-------------------------------------
aop/service/UserServiceProxy1.java [代理1]
package com.imooc.spring.aop.service;

public class UserServiceProxy1 implements UserService&#123;
    private UserService userService ;
    public UserServiceProxy1(UserService userService)&#123;
        this.userService = userService;
    &#125;

    public void createUser() &#123;
        userService.createUser();
        System.out.println(&quot;========后置扩展功能======&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import com.imooc.spring.aop.service.UserServiceImpl;
import com.imooc.spring.aop.service.UserServiceProxy;
import com.imooc.spring.aop.service.UserServiceProxy1;

public class Application &#123;
    public static void main(String[] args) &#123; //类似于二房东
        UserService userService = new UserServiceProxy1(new UserServiceProxy(new UserServiceImpl()));
        userService.createUser();
    &#125;
&#125;
</code></pre>
<h3 id="AOP底层逻辑—JDK动态代理"><a href="#AOP底层逻辑—JDK动态代理" class="headerlink" title="AOP底层逻辑—JDK动态代理"></a>AOP底层逻辑—JDK动态代理</h3><pre><code class="java">aop/service.UserService.java [接口]
package com.imooc.spring.aop.service;

public interface UserService &#123;
    public void createUser();
&#125;


-------------------------------------
aop/service.EmployeeService.java [接口]
package com.imooc.spring.aop.service;

public interface EmployeeService &#123;
    public void createEmployee();
&#125;
</code></pre>
<pre><code class="java">aop/service.EmployeeServiceImpl.java
package com.imooc.spring.aop.service;

public class EmployeeServiceImpl implements EmployeeService &#123;
    public void createEmployee() &#123;
        System.out.println(&quot;执行创建员工业务逻辑&quot;);
    &#125;
&#125;
--------------------------------------
aop/service.UserServiceImpl.java
package com.imooc.spring.aop.service;

public class UserServiceImpl implements UserService&#123;
    public void createUser() &#123;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">ProxyInvocationHandler.java
package com.imooc.spring.aop.service;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * InvocationHandler是JDK提供的反射类,用于在JDK动态代理中对目标方法进行增强
 * InvocationHandler实现类与切面类的环绕通知类似
 */
public class ProxyInvocationHandler implements InvocationHandler &#123;
    private Object target;//目标对象
    private ProxyInvocationHandler(Object target)&#123;
        this.target = target;
    &#125;
    /**
     * 在invoke()方法对目标方法进行增强 反射method方法的时候遇见过invoke
     * @param proxy 代理类对象
     * @param method 目标方法对象
     * @param args 目标方法实参
     * @return 目标方法运行后返回值
     * @throws Throwable 目标方法抛出的异常
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;);
        Object ret = method.invoke(target, args);//调用目标方法,ProceedingJoinPoint.proceed()
        return ret;
    &#125;

    public static void main(String[] args) &#123;
        UserService userService = new UserServiceImpl();
        ProxyInvocationHandler invocationHandler = new ProxyInvocationHandler(userService);
        //动态创建代理类
        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),
                userService.getClass().getInterfaces(),
                invocationHandler);
        userServiceProxy.createUser();

        //动态代理,必须实现接口才可以运行
        EmployeeService employeeService = new EmployeeServiceImpl();
        EmployeeService employeeServiceProxy = (EmployeeService)Proxy.newProxyInstance(employeeService.getClass().getClassLoader(),
                employeeService.getClass().getInterfaces(),
                new ProxyInvocationHandler(employeeService));
        employeeServiceProxy.createEmployee();
    &#125;
&#125;

=======================================================

=====2024-01-12 19:52:34 179=========
执行创建用户业务逻辑
=====2024-01-12 19:52:34 181=========
执行创建员工业务逻辑

Process finished with exit code 0
</code></pre>
<img src="https://raw.githubusercontent.com/P-luminary/images/7942f4deaa97d742e38e14b1326c7064e1a28f50/data/AOP%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E2%80%94JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png"  />





<h3 id="AOP底层逻辑—CGLib实现代理类"><a href="#AOP底层逻辑—CGLib实现代理类" class="headerlink" title="AOP底层逻辑—CGLib实现代理类"></a>AOP底层逻辑—CGLib实现代理类</h3><ul>
<li>CGLib是运行时字节码增强技术</li>
<li>Spring AOP扩展无接口类使用CGLib</li>
<li>AOP会运行时生成目标继承类字节码的方式进行行为扩展</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7aa4a34eb72920c28d071577e2c074f4cf266e1a/data/AOP%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E2%80%94CGLib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB.jpg"></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/107a911bbe025f10f9f6629b01583a222956ca9f/data/CGLib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB%20%E6%95%88%E6%9E%9C%E5%9B%BE.jpg" style="zoom:80%;" />



<h3 id="Spring-JDBC与事务管理"><a href="#Spring-JDBC与事务管理" class="headerlink" title="Spring JDBC与事务管理"></a>Spring JDBC与事务管理</h3><h5 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h5><ul>
<li>Spring JDBC是Spring框架用于处理关系型数据库的模块</li>
<li>Spring JDBC对JDBC API进行封装，极大简化开发工作量</li>
<li>JdbcTemplate是Spring JDBC核心类, 提供数据CRUD方法</li>
</ul>
<h5 id="为什么有了Mybatis还需要Spring-JDBC？"><a href="#为什么有了Mybatis还需要Spring-JDBC？" class="headerlink" title="为什么有了Mybatis还需要Spring JDBC？"></a>为什么有了Mybatis还需要Spring JDBC？</h5><p>因为这两者面向的对象是不一样的<br><strong>mybatis 封装程度</strong>高适合中小企业敏捷开发, 快速完成与数据库交互的工作, 封装程度高 执行效率低【慢】<br>Spring JDBC只是对原始的JDBC的API进行了简单封装 大厂使用【轻量级】可二次封装</p>
<h3 id="Spring-JDBC的使用步骤"><a href="#Spring-JDBC的使用步骤" class="headerlink" title="Spring JDBC的使用步骤"></a>Spring JDBC的使用步骤</h3><ul>
<li><p>Maven工程引入依赖<code>spring-jdbc</code></p>
</li>
<li><p>applicationContext.xml配置<code>DataSource</code>数据源 [<u>用于指向连接哪数据库的哪种服务器 账号密码都是啥</u>]</p>
</li>
<li><p>在Dao注入<code>JdbcTemplate</code>对象, 实现数据CRUD</p>
</li>
</ul>
<h2 id="JdbcTemplate类"><a href="#JdbcTemplate类" class="headerlink" title="JdbcTemplate类"></a>JdbcTemplate类</h2><h6 id="Spring-JdbcTemplate类的方法"><a href="#Spring-JdbcTemplate类的方法" class="headerlink" title="Spring JdbcTemplate类的方法"></a>Spring JdbcTemplate类的方法</h6><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int update(String query)</td>
<td>用于插入，更新和删除记录。</td>
</tr>
<tr>
<td>public int update(String query，Object … args)</td>
<td>用于通过使用给定参数的PreparedStatement插入，更新和删除记录。</td>
</tr>
<tr>
<td>public void execute(String query)</td>
<td>用于执行DDL查询。</td>
</tr>
<tr>
<td>public T execute(String sql, PreparedStatementCallback action)</td>
<td>通过使用PreparedStatement回调执行查询。</td>
</tr>
<tr>
<td>public T query(String sql, ResultSetExtractor rse)</td>
<td>用于使用ResultSetExtractor获取记录。</td>
</tr>
<tr>
<td>public List query(String sql, RowMapper rse)</td>
<td>用于使用RowMapper获取记录。</td>
</tr>
</tbody></table>
<h3 id="JdbcTemplate实现增删改查"><a href="#JdbcTemplate实现增删改查" class="headerlink" title="JdbcTemplate实现增删改查"></a>JdbcTemplate实现增删改查</h3><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml [SpringIoC基础配置文件]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 数据源设置：使用哪种服务器 哪种数据源 账号密码是什么 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API 让IoC容器初始化的时候自动实例化jdbcTemplate 实例化的过程中要将设置好的数据源dataSource注入到jdbcTemplate属性中 此时就完成了实例化--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
&lt;!--    为Dao注入JdbcTemplate对象 --&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/entity/Employee.java
public class Employee &#123;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &quot;, hiredate=&quot; + hiredate +
                &#39;&#125;&#39;;
    &#125;
&#125; +Setter Getter
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

public class EmployeeDao &#123;
/*    依赖与jdbcTemplate 要持有其
* &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
* */
    private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.jdbc;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        EmployeeDao employeeDao = context.getBean(&quot;employeeDao&quot;, EmployeeDao.class);
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);

    &#125;
&#125;

=======================================================
Employee&#123;eno=3308, ename=&#39;张三&#39;, salary=6000.0, dname=&#39;研发部&#39;, hiredate=2011-05-08 00:00:00.0&#125;

Process finished with exit code 0
</code></pre>
<h3 id="JdbcTemplate的数据查询方法"><a href="#JdbcTemplate的数据查询方法" class="headerlink" title="JdbcTemplate的数据查询方法"></a>JdbcTemplate的数据查询方法</h3><pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

public class EmployeeDao &#123;
/*    依赖与jdbcTemplate 要持有其
* &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
* */
    private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        //查询单条数据 转换成对象
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;
    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据                             sql  对应的参数数组  转换的Mapper对象
        //多条记录 每一条记录转换为一个实体对象 放入List集合中进行返回
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;yan&#39;fa&#39;bu&quot;));
    &#125;
&#125;
================================================================
[Employee&#123;eno=3308, ename=&#39;张三&#39;, salary=6000.0, dname=&#39;研发部&#39;, hiredate=2011-05-08 00:00:00.0&#125;, Employee&#123;eno=3420, ename=&#39;李四&#39;, salary=8700.0, dname=&#39;研发部&#39;, hiredate=2006-11-11 00:00:00.0&#125;]


Process finished with exit code 0
</code></pre>
<pre><code class="java">★★ 新增 ★★
在没有对应的实体类情况下也可以得到相应的结果 结果被封装成为了Map对象
EmployeeDao.java
//    按列表返回每一条按Map对象列表返回
    public List findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno, salary as a from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;


JdbcTemplateTestor.java
@Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;
================================================================
[&#123;empno=3308, a=6000.0&#125;, &#123;empno=3420, a=8700.0&#125;]

Process finished with exit code 0
</code></pre>
<pre><code class="java">总结  [★★★★ queryForObject query queryForList ★★★★]
 private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        // ★★查询单条数据 转换成对象 ★★
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        // ★★查询复合数据★★                      sql  对应的参数数组  转换的Mapper对象
        // ★★多条记录 每一条记录转换为一个实体对象★★ 放入List集合中进行返回
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

//    按列表返回每一条按Map对象列表返回
//特殊情况：无法进行实体类的映射则可用直接用queryForList特殊返回Map 来完成对应数据的封装
    public List findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno, salary as a from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

</code></pre>
<h3 id="JdbcTemplate实现增删改查-1"><a href="#JdbcTemplate实现增删改查-1" class="headerlink" title="JdbcTemplate实现增删改查"></a>JdbcTemplate实现增删改查</h3><pre><code class="java">★★ 增 ★★
EmployeeDao.java
public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        jdbcTemplate.update(sql,new Object[]&#123;
                employee.getEno(), employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate()
        &#125;);
    &#125;

JdbcTemplateTestor.java
@Test
    public void testinsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;


★★ 更新 ★★
EmployeeDao.java
public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename=?, salary=?, dname=?, hiredate=? WHERE eno=?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

JdbcTemplateTestor.java
@Test
    public void testUpdate() &#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;
=========================================================
本次更新1条数据

Process finished with exit code 0


★★ 删除 ★★
EmployeeDao.java
public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno=?&quot;;
        int update = jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
        return update;
    &#125;

JdbcTemplateTestor.java
@Test
    public void testDelete() &#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;
=========================================================
本次删除1条数据
</code></pre>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>事务式以一种可靠、一致的方法，访问和操作数据库的程序单元</li>
<li>说人话：要么把事情做完，要么什么都不做，不要做一半</li>
<li>事务依赖于数据库实现，MySQL通过<strong>事务区</strong>作为数据缓冲地带</li>
</ul>
<h3 id="编程式事务-手动控制啥时候提交-啥时候回滚"><a href="#编程式事务-手动控制啥时候提交-啥时候回滚" class="headerlink" title="编程式事务 [手动控制啥时候提交 啥时候回滚]"></a>编程式事务 [手动控制啥时候提交 啥时候回滚]</h3><ul>
<li>编程式事务是指通过代码手动提交回滚事务的事务控制方法</li>
<li>SpringJDBC通过TransactionManager事务管理器实现事务控制</li>
<li>事务管理器提供commit&#x2F;rollback方法进行事务提交与回滚</li>
</ul>
<blockquote>
<p>S1需求：公司来了10名新员工 批量导入员工表中 (要么什么都不做，要么把事情做完) 【类似银行存钱】</p>
</blockquote>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void bathImport()&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;



applicationContext.xml
&lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

    

JdbcTemplateTestor.java
@Resource
    private EmployeeService employeeService;
@Test
    public void testBatchImport()&#123;
        employeeService.bathImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

此方法是一条一条的增加写入sql操作
09:47:33.565 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
09:47:33.565 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)]
09:47:33.567 [main] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Fetching JDBC Connection from DataSource
09:47:33.567 [main] DEBUG org.springframework.jdbc.datasource.DriverManagerDataSource - Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true]
09:47:33.684 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state &#39;22007&#39;, error code &#39;1292&#39;, message [Incorrect date value: &#39;2024-01-14 09:47:33.564&#39; for column &#39;hiredate&#39; at row 1]
09:47:33.690 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
09:47:33.690 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)]
09:47:33.690 [main] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Fetching JDBC Connection from DataSource
09:47:33.690 [main] DEBUG org.springframework.jdbc.datasource.DriverManagerDataSource - Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true]
09:47:33.695 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state &#39;22007&#39;, error code &#39;1292&#39;, message [Incorrect date value: &#39;2024-01-14 09:47:33.69&#39; for column &#39;hiredate&#39; at row 1]
09:47:33.695 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
</code></pre>
<hr>
<hr>
<h3 id="编程式事务-2-放入事务区统一管理"><a href="#编程式事务-2-放入事务区统一管理" class="headerlink" title="编程式事务-2 [放入事务区统一管理]"></a>编程式事务-2 [放入事务区统一管理]</h3><pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private DataSourceTransactionManager transactionManager;
    public void bathImport()&#123;
        //定义了事务默认的标准配置
        TransactionDefinition definition = new DefaultTransactionDefinition();
        //开始一个事务 放在事务区中统一进行管理
        TransactionStatus status = transactionManager.getTransaction(definition);

        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                if (i==3)&#123;
                    throw new RuntimeException(&quot;意料之外的异常&quot;);
                &#125;
                Employee employee = new Employee();
                employee.setEno(8010 + i);
                employee.setEname(&quot;员工&quot; + i);
                employee.setSalary(4000f);
                employee.setDname(&quot;市场部&quot;);
                employee.setHiredate(new Date());
                employeeDao.insert(employee);
            &#125;
            //提交事务
            transactionManager.commit(status);
        &#125; catch (Exception e) &#123;
            //回滚事务
            transactionManager.rollback(status);
            e.printStackTrace();
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public DataSourceTransactionManager getTransactionManager() &#123;
        return transactionManager;
    &#125;

    public void setTransactionManager(DataSourceTransactionManager transactionManager) &#123;
        this.transactionManager = transactionManager;
    &#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 数据源设置：使用哪种服务器 哪种数据源 账号密码是什么 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
        &lt;!--    为Dao注入JdbcTemplate对象 --&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
&lt;!--     将属性进行注入 要添加其getter setter--&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    事务管理器 数据源  [整体提交以及回滚] 需要控制的类中注入bean id=&quot;transactionManager&quot; --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById() &#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname() &#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname() &#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testinsert() &#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void testUpdate() &#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testDelete() &#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.bathImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;
&#125;

========================================================
都是在一个数据库连接里操作的
10:01:16.165 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Initiating transaction rollback
10:01:16.165 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Rolling back JDBC transaction on Connection [com.mysql.cj.jdbc.ConnectionImpl@c88a337]
10:01:16.166 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Releasing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c88a337] after transaction
java.lang.RuntimeException: 意料之外的异常
    at com.imooc.spring.jdbc.service.EmployeeService.bathImport(EmployeeService.java:24)
    at JdbcTemplateTestor.testBatchImport(JdbcTemplateTestor.java:63)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
</code></pre>
<p>★★★ 编程式事务 ★★★<br>优点：容易理解 编程快<br>缺点：容易受到人为因素影响 结果致命</p>
<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><ul>
<li>声明式事务指在<strong>不修改源代码</strong>情况下通过配置形式自动实现事务控制, 声明式事务本质就是AOP环绕通知</li>
<li>当目标方法执行成功时, 自动提交事务</li>
<li>当目标方法抛出运行异常时, 自动事务回滚</li>
</ul>
<h5 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h5><ul>
<li>配置TransactionManager事务管理器</li>
<li>配置事务通知与事务属性</li>
<li>为事务通知绑定PointCut切点</li>
</ul>
<blockquote>
<p>需求：在不修改原始代码的情况下 配置Service里面的声明式事务</p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--    1-3具体含义：当我们目标方法是imooc包下Service 且方法名为batchImport的时候 则认为当前方法需要使用事务--&gt;
&lt;!--    利用transactionManager来完成对事务的提交以及回滚--&gt;

    &lt;!-- 1.事务管理器,用于创建事务/提交/回滚 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--2.事务通知配置,决定哪些方法使用事务,哪些方法不使用事务 advice是通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
 &lt;!-- ★★★★ 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用  propagation是事务传播行为★★★★--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 不支持事务--&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--3. 定义声明式事务的作用范围--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">EmployeeService.java
vpackage com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private BatchService batchService;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            //注意噢 这里是被注释的
//            if(i==3)&#123;
//                throw new RuntimeException(&quot;意料之外的异常&quot;);
//            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">EmployeeDao.java 未改变
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>
<h3 id="事务传播行为【面试】"><a href="#事务传播行为【面试】" class="headerlink" title="事务传播行为【面试】"></a>事务传播行为【面试】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/dfcdce285d42fc77d69cb614b61e298b10a7252a/data/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E4%B8%83%E7%A7%8D%E7%B1%BB%E5%9E%8B.jpg"></p>
<ul>
<li>事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式</li>
<li><code>XML:&lt;tx:method name=&quot;...&quot; propagation=&quot;REQUIRED&quot;/&gt;</code></li>
<li>注解: <code>@Transactional(propagation=Propagation.REQUIRED)</code></li>
</ul>
<blockquote>
<p>加个BatchService 然后在EmployeeService加一个private BatchService batchService;(getter + setter)  再次插入一个public void startImportJob()<br>进行applicationContext.xml的bean注入<br><bean id="batchService" class="com.imooc.spring.jdbc.service.BatchService"><br>    <property name="employeeDao" ref="employeeDao"/><br></bean></p>
<bean id="employeeService" class="com.imooc.spring.jdbc.service.EmployeeService">
    <property name="employeeDao" ref="employeeDao"/>
    <property name="batchService" ref="batchService"/>
</bean>

<p>会被声明式事务范围包裹噢<br>&lt;aop:pointcut id&#x3D;”pointcut” expression&#x3D;”execution(* com.imooc..*Service.*(..))”&#x2F;&gt;</p>
<pre><code class="java">applicationContext.xml
加入 importJob1 importJob2
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 --&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;

            &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
</code></pre>
<p>补充public void startImportJob()</p>
<pre><code class="java">public void startImportJob()&#123;
    //会有关联行为 若2失败则无法导入 1也会回滚
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

//方法： REQUIRES_NEW 不同方法运行在不同事务中 
//事务1开始 事务1挂起事务2开始 事务2提交 事务1恢复 事务1挂起事务3开始 事务3提交事务1恢复 事务1提交
          &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
上面的分这写
</code></pre>
</blockquote>
<pre><code class="java">com/imooc/spring/jdbc/service/BatchService.java
package com.imooc.spring.jdbc.service;
 
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;
public class BatchService &#123;

    private EmployeeDao employeeDao;

    public void importJob1()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;研发部员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;研发部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void importJob2()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(9000 + i);
            employee.setEname(&quot;市场部员工&quot; + i);
            employee.setSalary(4500f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private BatchService batchService;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
//            if(i==3)&#123;
//                throw new RuntimeException(&quot;意料之外的异常&quot;);
//            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void startImportJob()&#123;
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
public class EmployeeDao &#123;
    private JdbcTemplate jdbcTemplate;

    public Employee findById(Integer eno)&#123;
        String sql = &quot;select * from employee where eno = ?&quot;;
        //查询单条数据
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public List&lt;Map&lt;String, Object&gt;&gt; findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno , salary as s from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

    public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        //利用update方法实现数据写入操作
        jdbcTemplate.update(sql,new Object[]&#123;
           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()
        &#125;);
    &#125;

    public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

    public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno = ?&quot;;
        return jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
    &#125;


    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!-- 数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
        &lt;!--为Dao注入JdbcTemplate对象--&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
        &lt;property name=&quot;batchService&quot; ref=&quot;batchService&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;batchService&quot; class=&quot;com.imooc.spring.jdbc.service.BatchService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    1-3具体含义：当我们目标方法是imooc包下Service 且方法名为batchImport的时候 则认为当前方法需要使用事务--&gt;
&lt;!--    利用transactionManager来完成对事务的提交以及回滚--&gt;

    &lt;!-- 1.事务管理器,用于创建事务/提交/回滚 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--2.事务通知配置,决定哪些方法使用事务,哪些方法不使用事务 advice是通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 --&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;

            &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--3. 定义声明式事务的作用范围--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">jdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="注解配置声明式事务"><a href="#注解配置声明式事务" class="headerlink" title="注解配置声明式事务"></a>注解配置声明式事务</h3><pre><code class="java">//声明式事务核心注解
//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED
@Transactional(propagation = Propagation.REQUIRED) //不写也默认
写在类上就是所有 
写在方法就是单独方法运用
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
@Repository
public class EmployeeDao &#123;
    @Resource
    private JdbcTemplate jdbcTemplate;

    public Employee findById(Integer eno)&#123;
        String sql = &quot;select * from employee where eno = ?&quot;;
        //查询单条数据
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public List&lt;Map&lt;String, Object&gt;&gt; findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno , salary as s from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

    public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        //利用update方法实现数据写入操作
        jdbcTemplate.update(sql,new Object[]&#123;
           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()
        &#125;);
    &#125;

    public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

    public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno = ?&quot;;
        return jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
    &#125;


    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/entity/Employee.java
public class Employee &#123;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;
&#125; getter+setter
     @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &quot;, hiredate=&quot; + hiredate +
                &#39;&#125;&#39;;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/BatchService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.sun.xml.internal.ws.developer.Serialization;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
@Service
//不需要使用事务 只读操作
@Transactional(propagation = Propagation.NOT_SUPPORTED,readOnly = true)
public class BatchService &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void importJob1()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;研发部员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;研发部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void importJob2()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(9000 + i);
            employee.setEname(&quot;市场部员工&quot; + i);
            employee.setSalary(4500f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
@Service
//声明式事务核心注解
//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED
@Transactional(propagation = Propagation.REQUIRED) //不写也默认
public class EmployeeService &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private BatchService batchService;

    @Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true)
    public Employee findById(Integer eno)&#123;
        return employeeDao.findById(eno);
    &#125;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            if(i==3)&#123;
                throw new RuntimeException(&quot;意料之外的异常&quot;);
            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void startImportJob()&#123;
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
    &lt;!--数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--JdbcTemplate--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- 启用注解形式声明式事务 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">test/java/JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/12/09/后端/Spring(切点表达式,通知,AOP,CGLib代理,Spring JdbcTemplate,事务)/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/11/19/英语/四级作文-新/">
        <h2>
            四级作文(新)
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/11/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="作文评分原则"><a href="#作文评分原则" class="headerlink" title="作文评分原则"></a>作文评分原则</h3><h6 id="内容：50-结构：10-语言：40"><a href="#内容：50-结构：10-语言：40" class="headerlink" title="内容：50%    结构：10%    语言：40%"></a>内容：50%    结构：10%    语言：40%</h6><ol>
<li>充实文章的内容：七种方法</li>
<li>固定文章的结构：总分总</li>
<li>丰富文章的语言：读范文；讲句型；躲错误；备模板</li>
</ol>
<h1 id="特点一：内容充实"><a href="#特点一：内容充实" class="headerlink" title="特点一：内容充实"></a><span style = "color:orange">特点一：内容充实</span></h1><h6 id="expert-testimony-专家证言法"><a href="#expert-testimony-专家证言法" class="headerlink" title="expert testimony 专家证言法"></a><span style = "color:blue">expert testimony 专家证言法</span></h6><p><strong>declare</strong> 宣称,声称 (替代think)<br><strong>claim</strong> (替代think)<br><del>exclaim 大叫(shout , yell)</del></p>
<p><strong>① It is plain common sense from those authoritative research that…</strong><br><strong>② Based on their findings, the experts claim that…</strong></p>
<h6 id="statistics-统计数据法"><a href="#statistics-统计数据法" class="headerlink" title="statistics 统计数据法"></a><span style = "color:blue">statistics 统计数据法</span></h6><p>reduce<br>dramatically</p>
<p><strong>① According to a recent survey, thousands of people has found 80% of respondents claimed that…</strong></p>
<h6 id="example-举例子-文章字不够举例子来凑-2个"><a href="#example-举例子-文章字不够举例子来凑-2个" class="headerlink" title="example 举例子 (文章字不够举例子来凑) (2个)"></a><span style = "color:red">example 举例子</span> (文章字不够举例子来凑) (2个)</h6><p>deal with &#x3D; cope with &#x3D; dispose of (解决)<br>efficiently(有效地) &#x2F; effective(有效率的)<br><strong>concentrate on</strong> &#x3D; pay attention to &#x3D; <strong>absorb in</strong> &#x3D; dedicate to &#x3D; indulge in &#x3D; focus on</p>
<p><strong>① Taking a look around, we can find the following examples in our daily lives.</strong><br><strong>② A good case in point is that…</strong><br><strong>③ As an illustration, we may take …as an example.</strong><br><strong>④ A typical example of this is that…</strong><br><u>A typical example of this is that</u> in most families, there is only one child who is loved by not only patents, but also grandparents.</p>
<h6 id="personal-experience-个人经历"><a href="#personal-experience-个人经历" class="headerlink" title="personal experience 个人经历"></a><span style = "color:blue">personal experience 个人经历</span></h6><h6 id="Logic-amp-Reasoning-逻辑推理"><a href="#Logic-amp-Reasoning-逻辑推理" class="headerlink" title="Logic &amp; Reasoning 逻辑推理"></a><span style = "color:blue">Logic &amp; Reasoning 逻辑推理</span></h6><p>​    <strong>分析原因段</strong> (一般都是第二段)<br>​    ① 三个原因 + 一个例子<br>​    ② 两个原因 + 两个例子</p>
<p>​    <strong>解决问题段</strong><br>​    deal with &#x3D; cope with &#x3D; dispose of (解决)</p>
<p>​    ① <strong>国家</strong>政府角度谈 (权威)<br>​    ② 全<strong>社会</strong>人民角度谈 (广泛)<br>​    ③ 就我<strong>个人</strong>而言 (个人)</p>
<h6 id="known-facts-常识法"><a href="#known-facts-常识法" class="headerlink" title="known facts 常识法"></a><span style = "color:blue">known facts 常识法</span></h6><p>consider&#x2F;considerate(adj)<br>consideration(共同的名词词性)[考虑&#x2F;]<br>take sth. into consideration</p>
<p><strong>① It is truism that…</strong><br><strong>② It comes to light that…</strong></p>
<h6 id="analogy-类比-目标A-但是去说B最后与A关联"><a href="#analogy-类比-目标A-但是去说B最后与A关联" class="headerlink" title="analogy 类比(目标A 但是去说B最后与A关联)"></a><span style = "color:blue">analogy 类比</span>(目标A 但是去说B最后与A关联)</h6><p>tend(照顾,倾向于)  extend(延伸,口)    pretend(假装)    intend(打算) &#x3D; mean to do</p>
<h3 id="第二部分：四级写作的出题方式"><a href="#第二部分：四级写作的出题方式" class="headerlink" title="第二部分：四级写作的出题方式"></a>第二部分：四级写作的出题方式</h3><h4 id="一-提纲式作文"><a href="#一-提纲式作文" class="headerlink" title="(一) 提纲式作文"></a>(一) 提纲式作文</h4><p>… on the topic Will <strong>E-books replaced traditional books</strong>? You should write at 150 words following the outline given below in Chinese:<br>① 随着信息技术的发展, 电子图书越来越多<br>② 有人认为电子图书会取代传统图书<br>③ 我的看法</p>
<h4 id="二-图表作文-x2F-漫画式作文"><a href="#二-图表作文-x2F-漫画式作文" class="headerlink" title="(二) 图表作文&#x2F;漫画式作文"></a>(二) 图表作文&#x2F;漫画式作文</h4><h4 id="三-应用文"><a href="#三-应用文" class="headerlink" title="(三) 应用文"></a>(三) 应用文</h4><p>… to write <strong>a letter to a company declining a job offer</strong>.<br>① 对公司提供职位标识感激<br>② 有人认为电子图书会取代传统图书<br>③ 我的看法</p>
<h4 id="四-记叙文"><a href="#四-记叙文" class="headerlink" title="(四) 记叙文"></a>(四) 记叙文</h4><p>… to write a composition on the topic “<strong>The most unforgettable person I ever know.</strong>“</p>
<hr>
<h3 id="第三部分：四级的三段论"><a href="#第三部分：四级的三段论" class="headerlink" title="第三部分：四级的三段论"></a>第三部分：四级的三段论</h3><h4 id="一-现象描述型"><a href="#一-现象描述型" class="headerlink" title="(一) 现象描述型"></a>(一) 现象描述型</h4><p>第一段：描述现象，引出话题<br>第二段：阐述正反观点<br>第三段：观点结论</p>
<h4 id="二-问题解决型"><a href="#二-问题解决型" class="headerlink" title="(二) 问题解决型"></a>(二) 问题解决型</h4><p>第一段：问题描述<br>第二段：解决问题的原因<br>第三段：解决问题的措施</p>
<h4 id="三-对比观点型"><a href="#三-对比观点型" class="headerlink" title="(三) 对比观点型"></a>(三) 对比观点型</h4><p>第一段：正方观点 + 理由<br>第二段：反方观点 + 理由<br>第三段：观点结论</p>
<h4 id="四-应用文-每段的第一个句子要成为主题句出现-三个主题句"><a href="#四-应用文-每段的第一个句子要成为主题句出现-三个主题句" class="headerlink" title="(四) 应用文 (每段的第一个句子要成为主题句出现 三个主题句)"></a>(四) 应用文 (每段的第一个句子要成为主题句出现 三个主题句)</h4><p>第一段：写信目的<br>第二段：写信内容<br>第三段：结束语</p>
<h4 id="五-引语类"><a href="#五-引语类" class="headerlink" title="(五) 引语类"></a>(五) 引语类</h4><p>第一段：引语含义<br>第二段：观点阐述<br>第三段：观点结论</p>
<h4 id="六-漫画-x2F-图表作文"><a href="#六-漫画-x2F-图表作文" class="headerlink" title="(六) 漫画&#x2F;图表作文"></a>(六) 漫画&#x2F;图表作文</h4><p>第一段：描述漫画&#x2F;图表内容<br>第二段：分析原因&#x2F;观点阐述 (可单独 可融合)<br>第三段：展望未来&#x2F;解决问题</p>
<h4 id="七-记叙文"><a href="#七-记叙文" class="headerlink" title="(七) 记叙文"></a>(七) 记叙文</h4><p>第一段：描述概况<br>第二段：描述事件经过细节<br>第三段：得出结论</p>
<hr>
<h3 id="第四部分：四级写作评分实例-阅读范文"><a href="#第四部分：四级写作评分实例-阅读范文" class="headerlink" title="第四部分：四级写作评分实例(阅读范文)"></a>第四部分：四级写作评分实例(阅读范文)</h3><p>… on the topic <strong>Should one expect a reward when doing a good deed ?</strong><br>① 有人做好事期望得到回报<br>② 有人认为应该像雷锋那样做好事不图回报<br>③ 我的观点<br><span style = " color : red">每当写完一个句子 就问问自己后面能写原因吗**(原因状语从句)**</span></p>
<p>​                                            Should one expect a reward when doing a good deed<br>​    <span style = " color : blue"><strong>Different people hold different view about</strong></span> whether or not one should expect a reward when doing a good deed. <span style = " color : blue"><strong>Some argue<span style = "color:red">(替代think)</span> that people should be given</strong></span> a certain reward for their good deed, <span style = " color : blue">because they believe<span style = "color:red">(替代think)</span> the saying</span> “No pain, no gains”. <span style = " color : blue"><strong>In addition<span style = "color:red">(替代and)</span>, they maintain<span style = "color:red">(替代think)</span> that in some sense</strong></span> rewards can <span style = " color : blue">stimulate<span style = "color:red">(代替encourage)</span> people’s enthusiasm to do</span> good deeds.</p>
<h5 id="①-argue可以替代think的"><a href="#①-argue可以替代think的" class="headerlink" title="① argue可以替代think的"></a><span style = " color : red">① argue</span>可以替代think的</h5><h6 id="单词：assume，deem，reckon，maintain"><a href="#单词：assume，deem，reckon，maintain" class="headerlink" title="单词：assume，deem，reckon，maintain"></a>单词：assume，deem，reckon，maintain</h6><h6 id="短语："><a href="#短语：" class="headerlink" title="短语："></a>短语：</h6><p>​    (1) hold the opinion&#x2F; belief&#x2F; point that…<br>​    (2) harbor the idea that…<br>​    (3) take the attitude that…<br>​    (4) be firmly&#x2F; fully convinced that…</p>
<h6 id="句子："><a href="#句子：" class="headerlink" title="句子："></a>句子：</h6><p>​    (1) It is widely shared that…<br>​    (2) It is universally acknowledged</p>
<p><span style = " color : red"><strong>argue</strong></span>的扩展<br><strong>I think</strong><br>&#x3D; to my knowledge<br>&#x3D; from my personal perspective<br>&#x3D; from my point of view<br>&#x3D; from my angle</p>
<p>所有的介词或介词短语后面都要加 名词&#x2F;名词短语。只有连词后面才可以加句子</p>
<p><span style = " color : red">**② because of **</span>+ 短语 (because of your help)<br>on account of、due to、thanks to、by virtue of、in light of、<br>be responsible for</p>
<p><span style = " color : red">③ because</span> + 句子 (because you help me)<br>in that、for the reason that、on the ground that、seeing that、<strong>considering that</strong></p>
<p><span style = " color : red"><strong>④ 动词短语</strong></span></p>
<ul>
<li>(1) 前<strong>因</strong>后<strong>果</strong> “导致”    <ul>
<li>contribute to</li>
<li>lead to</li>
<li>result in</li>
</ul>
</li>
</ul>
<p>例句：Eating too much fat can ___ heart disease.</p>
<ul>
<li>(2) 前<strong>果</strong>后<strong>因</strong> “归因于”<ul>
<li>attribute to</li>
<li>result from</li>
<li>credit to (credit hour学时  credit card信用卡)</li>
</ul>
</li>
</ul>
<p>例句：The accident <strong>resulted from</strong> the driver’s carelessness.<br>例句：The driver’s carelessness **resulted in **the accident.</p>
<ul>
<li>(3) 混合<strong>因果</strong> (誰前誰后都可以)<ul>
<li>be bound up with<br>(<u>be bound to do sth</u>    The cars are bound to be disused[可<u>+原因状语从句</u>].)</li>
<li>be associated with<br>(association 协会&#x2F;团队)</li>
</ul>
</li>
</ul>
<p>例句：Cancer <strong>is bound up with</strong> smoking.<br>例句：Smoking <strong>is bound up with</strong> cancer.</p>
<p>​    <span style = " color : blue"><strong>However, others have different viewpoint.</strong></span> They regard LeiFeng as a model, <strong>who</strong>(定语从句)) always helps others without ever expecting any reward. <span style = " color : blue"><strong>They assume that</strong></span> doing a good deed <span style = " color : blue"><strong>should be based on</strong></span> people’s individual consciousness of responsibility, <span style = " color : blue"><strong>and hence<span style = "color:red">(结果从句)</span> little<span style = "color:red">(不…)</span> significance should be attached to</strong></span> monetary reward. <span style = " color : blue"><strong>In addition</strong></span>, one can enjoy the happiness and peace through <strong>what</strong>(宾语从句) he had done, they think, <strong>which</strong>(定语从句) is the best return.</p>
<p>​    <span style = " color : blue"><strong>Personally, I prefer the latter(former) opinion.</strong></span> <span style = " color : blue"><strong>It is imperative for us to</strong></span>(对…来说做…是) conduct good deeds without expecting any reward. <span style = " color : blue"><strong>For one thing, the authorities should make laws and regulations to encourage people to do<span style = "color:red">(法律法规)</span></strong></span> good deeds. <span style = " color : blue"><strong>For another, people’s awareness should be cultivated that</strong></span> conducing good deeds <span style = " color : blue"><strong>is extremely<span style = "color:red">(very)</span> meaningful to our lives. It should be universally acknowledged that</strong></span> we do good deeds for enjoyment, self-fulfillment and spiritual enhancement, not for the rewards.</p>
<h1 id="第二部分：语言丰富"><a href="#第二部分：语言丰富" class="headerlink" title="第二部分：语言丰富"></a><span style = "color:orange">第二部分：语言丰富</span></h1><h4 id="一、长句-短句错落有致-3-4"><a href="#一、长句-短句错落有致-3-4" class="headerlink" title="一、长句|短句错落有致 (3-4)"></a>一、长句|短句错落有致 (3-4)</h4><h4 id="二、主动-被动适当穿插-2-3"><a href="#二、主动-被动适当穿插-2-3" class="headerlink" title="二、主动|被动适当穿插 (2-3)"></a>二、主动|被动适当穿插 (2-3)</h4><h4 id="三、比较结构巧妙使用-1-2"><a href="#三、比较结构巧妙使用-1-2" class="headerlink" title="三、比较结构巧妙使用 (1-2)"></a>三、比较结构巧妙使用 (1-2)</h4><h4 id="四、强调倒装恰当运用-1-1"><a href="#四、强调倒装恰当运用-1-1" class="headerlink" title="四、强调倒装恰当运用 (1-1)"></a>四、强调倒装恰当运用 (1-1)</h4><h4 id="五、句和句间衔接紧密"><a href="#五、句和句间衔接紧密" class="headerlink" title="五、句和句间衔接紧密"></a>五、句和句间衔接紧密</h4><hr>
<h6 id="一、短句"><a href="#一、短句" class="headerlink" title="一、短句"></a>一、短句</h6><ul>
<li>类型1：<strong>主语 + 谓语</strong> (I seen)</li>
<li>类型2：<strong>主语 + 谓语 + 宾语</strong> (主体+动词+对象)</li>
<li>类型3：<strong>主语 + 系动词 + 表语</strong>  (主体+系动词(be_感官)(动词分支)+对象)</li>
<li>类型4：<strong>主语 + 谓语 + 双宾语</strong> (主体+动词+对象+对象)(<strong>都可以改被动就是双宾否则就是宾补</strong>)</li>
<li>类型5：<strong>主语 + 谓语 + 宾语 + 宾补</strong> (主体+动词+对象+对宾语的补充说明)</li>
</ul>
<p><span style = "color:red">只有<strong>名词、形容词、副词</strong>才可以变成句子(名词性从句、形容词性从句[<strong>定语从句</strong>]、副词性从句[<strong>状语从句</strong>])</span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/bd258af508752dfcfab1c2bbb18dd828579f1338/data/%E4%BB%8E%E5%8F%A5%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.png"></p>
<h6 id="长句"><a href="#长句" class="headerlink" title="长句"></a>长句</h6><h4 id="1-定语从句"><a href="#1-定语从句" class="headerlink" title="(1) 定语从句"></a><strong>(1) 定语从句</strong></h4><p>① This is <strong>the present</strong> <u>that</u> <em>he gave me for my birthday</em>. (什么样的present)<br>② <strong>The person</strong> <u>who</u> <em>broke the window</em> must pay for it.<br>③ <strong>Mr.Lee</strong>(<u>whom</u>) <em>you want to see</em> has come.<br>④ <strong>The girl</strong> <u>whose</u> <em>mother is ill is staying</em> at home today.<br>⑤ A dictionary is <strong>a book</strong> <u>which</u> <em>gives the meaning of words.</em></p>
<p>任何一个<strong>主语</strong>后面都可以加一个<strong>定语从句</strong>对<u>主语</u>进行修饰<br>任何一个<strong>宾语</strong>后面都可以加一个<strong>定语从句</strong>对<u>宾语&#x2F;双宾</u>进行修饰<br>每当造完一个短句子都要时刻提醒自己能不能加<strong>定语从句</strong> [<strong>人</strong>用who whom  <strong>物</strong>用which  that都可以用]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/236d7eb4836934e7fff851ca296af067241d7378/data/%E4%BB%8E%E5%8F%A5%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F2.jpg"></p>
<h4 id="2-状语从句-与含义相关-两句话粘一起-本质是连词-连接句子"><a href="#2-状语从句-与含义相关-两句话粘一起-本质是连词-连接句子" class="headerlink" title="(2) 状语从句 (与含义相关 两句话粘一起) (本质是连词[连接句子])"></a>(2) 状语从句 (与含义相关 两句话粘一起) (本质是连词[连接句子])</h4><p><span style = "color : red"><strong>时间</strong>，<strong>地点</strong>是一对儿</span>；<br><span style = "color : red"><strong>原因</strong>，<strong>结果</strong>为一家；</span><br><span style = "color : red"><strong>条件</strong>，<strong>目的</strong>有虚拟；</span>(一般不用)<br><span style = "color : red">我<strong>比较</strong>喜欢<strong>让步</strong>的<strong>方式</strong></span><br>人,物 + 定 (想一想能不能加！)<br>句子 + 原因结果时间</p>
<h5 id="1-时间状语从句-造完句问自己能产生时间吗"><a href="#1-时间状语从句-造完句问自己能产生时间吗" class="headerlink" title="1) 时间状语从句 (造完句问自己能产生时间吗)"></a>1) 时间状语从句 (造完句问自己能产生时间吗)</h5><p><strong>定语从句</strong>是内战 <strong>状语从句</strong>是侵略战争(拉一个句子来)(寻找句子之间的逻辑关系)<br><strong>When</strong> I arrived home, I had a little rest.<br>He sang <strong>as</strong> he danced.<br>You will grow wiser <strong>as</strong> you grow older.</p>
<h5 id="2-条件状语从句：-真实条件句和虚拟条件句"><a href="#2-条件状语从句：-真实条件句和虚拟条件句" class="headerlink" title="2) 条件状语从句：(真实条件句和虚拟条件句)"></a>2) 条件状语从句：(真实条件句和虚拟条件句)</h5><p>You will fail <strong>unless</strong> you study hard.<br>You will not fail <strong>if</strong> you study hard.<br>You may go there, <strong>as long as</strong> you keep quite.<br>I shall give you the book <strong>on condition that</strong> you return it tomorrow.<br>I will go <strong>provided that</strong> you go too.</p>
<h5 id="3-让步状语从句"><a href="#3-让步状语从句" class="headerlink" title="3) 让步状语从句"></a>3) 让步状语从句</h5><p><strong>Though&#x2F;Although</strong> it is raining, they are still running outside.<br>Child <strong>though</strong> he was, he knew what was the right thing to do.<br>Tired <strong>as</strong> he is, he goes on with his work.<br><strong>Despite&#x2F;In spite of</strong> wanting to see him again, she refused to reply to his letter.</p>
<h5 id="4-原因状语从句-强调句-找主谓宾-关联连接-任何一句话都可能变成"><a href="#4-原因状语从句-强调句-找主谓宾-关联连接-任何一句话都可能变成" class="headerlink" title="4) 原因状语从句(+强调句) [找主谓宾 关联连接] (任何一句话都可能变成)"></a>4) 原因状语从句(+强调句) [找主谓宾 关联连接] (任何一句话都可能变成)</h5><p><strong>It is because she is too inexperienced that</strong> she does know how to deal with the situation<br><strong>As&#x2F;Since</strong> you are not very well[主谓宾], you had better have a rest.[主谓宾]<br>&#x3D; It is Since you are not very well that you had better have a rest</p>
<p>It must have rained last night[主谓宾], <strong>for</strong> the ground is wet now.[主系表]<br>&#x3D; It is because&#x2F;for the ground is wet now that It must have rained last night</p>
<h5 id="5-目的状语从句-怎么怎么滴…-为了…-以防…"><a href="#5-目的状语从句-怎么怎么滴…-为了…-以防…" class="headerlink" title="5) 目的状语从句 (怎么怎么滴…  为了…  以防…)"></a>5) 目的状语从句 (怎么怎么滴…  为了…  以防…)</h5><p>You must speak louder <strong>so that&#x2F;in order that</strong> you can be heard by all.<br>He wrote the name down <strong>for fear that</strong> he should forget it.<br>Better take more clothes <strong>in case</strong> the weather be cold.</p>
<h6 id="注意：lest-in-case-for-fear-that所引导的状语从句中，动词可以用虚拟语气，形式为-should-动词原形-条件，目的有虚拟"><a href="#注意：lest-in-case-for-fear-that所引导的状语从句中，动词可以用虚拟语气，形式为-should-动词原形-条件，目的有虚拟" class="headerlink" title="注意：lest, in case, for fear that所引导的状语从句中，动词可以用虚拟语气，形式为 should + 动词原形 (条件，目的有虚拟)"></a>注意：<u>lest, in case, for fear that</u>所引导的状语从句中，动词可以用虚拟语气，形式为 should + 动词原形 (<span style = "color : red"><strong>条件</strong>，<strong>目的</strong>有虚拟)</span></h6><p>People must 关注 the P, lest it should be more and more 严重</p>
<h5 id="6-结果状语从句"><a href="#6-结果状语从句" class="headerlink" title="6) 结果状语从句"></a>6) 结果状语从句</h5><h6 id="引导结果状语从句的连词有：so-that-so…that-such…that"><a href="#引导结果状语从句的连词有：so-that-so…that-such…that" class="headerlink" title="引导结果状语从句的连词有：so that, so…that, such…that"></a>引导结果状语从句的连词有：so that, so…that, such…that</h6><p>He is <strong>so</strong> young <strong>that</strong> he can not go to school.<br>He is <strong>such</strong> a young boy <strong>that</strong> he can not go to school.</p>
<h6 id="补充常用句型"><a href="#补充常用句型" class="headerlink" title="补充常用句型"></a>补充常用句型</h6><p><strong>① so + 形容词&#x2F;副词 + that从句</strong><br>② so + 形容词 + a&#x2F;an + 单数可数名词 + that从句<br>③ such + a&#x2F;an + 形容词 + 单数可数名词 + that从句<br>④ such + 形容词 + 复数可数名词&#x2F;不可数名词 + that从句</p>
<h5 id="7-比较状语从句"><a href="#7-比较状语从句" class="headerlink" title="7) 比较状语从句"></a>7) 比较状语从句</h5><h6 id="引导比较状语从句的连词有：as…as-than-not-so…as-the-more…the-more等"><a href="#引导比较状语从句的连词有：as…as-than-not-so…as-the-more…the-more等" class="headerlink" title="引导比较状语从句的连词有：as…as, than, not so…as, the more…the more等"></a>引导比较状语从句的连词有：as…as, than, not so…as, the more…the more等</h6><p>He speaks English as fluently as his brother(does).<br>I can’t jump so&#x2F;as high as he(does).</p>
<h5 id="8-地点状语从句"><a href="#8-地点状语从句" class="headerlink" title="8) 地点状语从句"></a>8) 地点状语从句</h5><h6 id="引导地点状语从句的连词有：where-wherever以及-where构成的复合词等"><a href="#引导地点状语从句的连词有：where-wherever以及-where构成的复合词等" class="headerlink" title="引导地点状语从句的连词有：where, wherever以及 where构成的复合词等"></a>引导地点状语从句的连词有：where, wherever以及 where构成的复合词等</h6><p>① She found her calculator where she lost it.<br>② Wherever I am, I will miss you.<br>③ I happened to see your dictionary lie where I used it last time.<br>④ I happened to see your dictionary lie in the lab where I used it last time.</p>
<h5 id="9-方式状语从句"><a href="#9-方式状语从句" class="headerlink" title="9) 方式状语从句"></a>9) 方式状语从句</h5><p>① Just do as you are told.<br>② The workers went on working as if nothing had happened.</p>
<h4 id="3-名词性从句"><a href="#3-名词性从句" class="headerlink" title="(3) 名词性从句"></a>(3) 名词性从句</h4><h5 id="1-主语从句"><a href="#1-主语从句" class="headerlink" title="1) 主语从句"></a>1) 主语从句</h5><p>① That <u>she</u> had <u>won</u> <u>the first place</u>(主谓宾) <u>made us</u> very <u>happy</u>(主谓宾宾).<br><u><strong>五之一</strong>完整的主谓宾</u> (原因,结果,目的,条件) <u><strong>五之一</strong>完整的主谓宾</u><br>【五之一＋连词+五之一】<br>主语比较长的时候避免头重脚轻 可以用It做形式主语<br>&#x3D; It made us very happy that she had won the first place.</p>
<p>② Which team will win the match<br>&#x3D; It is still unknown which team will win the match is still unknown.<br><u><strong>五之一</strong>完整的主谓宾</u> 但是这是主语从句 所以主语就变成了一个句子<br><u>people protect the environment(主谓宾做主语)</u> is important要用连词连接一起<br>&#x3D; It is important that people protect the environment.(It可做形式主语但不是必须)</p>
<h6 id="补充：用it作形式主语的that-从句"><a href="#补充：用it作形式主语的that-从句" class="headerlink" title="补充：用it作形式主语的that-从句"></a>补充：用it作形式主语的that-从句</h6><h6 id="1-It-be-形容词-that从句"><a href="#1-It-be-形容词-that从句" class="headerlink" title="1. It + be + 形容词 + that从句"></a>1. It + be + 形容词 + that从句</h6><p>① It is necessary that… 有必要…<br>② It is important that… 重要的是…<br>③ It is obvious that… 很明显</p>
<h6 id="2-It-be-ed分词-that-从句"><a href="#2-It-be-ed分词-that-从句" class="headerlink" title="2. It + be + -ed分词 + that-从句"></a>2. It + be + -ed分词 + that-从句</h6><p>① It is believed that… 人们相信…<br>② It is known to all that… 纵所周知<br>③ It has been decided that… 已决定</p>
<h6 id="3-It-be-名词-that-从句"><a href="#3-It-be-名词-that-从句" class="headerlink" title="3. It + be + 名词 + that-从句"></a>3. It + be + 名词 + that-从句</h6><p>① It is common knowledge that…  …是常识<br>② It is a surprise that… 令人惊奇的是…<br>③ It is a fact that… 事实是</p>
<p>每当写完一个人能不能在人后面加定语从句<br>每当写完一个物能不能在物后面加定语从句<br>每当写完一个句子想一想在后面能不能加原因&#x2F;结果&#x2F;时间状语从句<br>写主语的时候想一想能不能把一个句子当主语</p>
<h5 id="2-宾语从句"><a href="#2-宾语从句" class="headerlink" title="2) 宾语从句"></a>2) 宾语从句</h5><h5 id="3-表语从句"><a href="#3-表语从句" class="headerlink" title="3) 表语从句"></a>3) 表语从句</h5><h5 id="4-同位语从句"><a href="#4-同位语从句" class="headerlink" title="4) 同位语从句"></a>4) 同位语从句</h5><h3 id="语言丰富方式二：主动被动适当穿插"><a href="#语言丰富方式二：主动被动适当穿插" class="headerlink" title="语言丰富方式二：主动被动适当穿插"></a>语言丰富方式二：主动被动适当穿插</h3><h5 id="1-被动语态的构成"><a href="#1-被动语态的构成" class="headerlink" title="1.被动语态的构成"></a>1.被动语态的构成</h5><p>**<span style = "color : red">① 一般现在时</span>**：am&#x2F;is&#x2F;are + done<br>**<span style = "color : red">② 一般过去时</span>**：was&#x2F;were + done<br>**<span style = "color : red">③ 一般将来时</span>**：will&#x2F;shall&#x2F;be going to be + done<br><strong>④ 过去将来时</strong>：would&#x2F;should&#x2F;be going to be + done<br><strong>⑤ 现在进行时</strong>：am&#x2F;is&#x2F;are being + done<br><strong>⑥ 过去进行时</strong>：was&#x2F;were being + done<br><strong>⑦ 过去完成时</strong>：had been + done</p>
<h5 id="2-被动语态的用法-至少3个"><a href="#2-被动语态的用法-至少3个" class="headerlink" title="2.被动语态的用法(至少3个)"></a>2.被动语态的用法(至少3个)</h5><h6 id="1-不知道或没有必要说明动作的执行者是誰-句子没主语"><a href="#1-不知道或没有必要说明动作的执行者是誰-句子没主语" class="headerlink" title="1) 不知道或没有必要说明动作的执行者是誰 (句子没主语)"></a>1) 不知道或没有必要说明动作的执行者是誰 (句子没主语)</h6><p>① Some new computers were stolen last night.<br>② This book was published in 1981.</p>
<h6 id="2-强调动作的承受者"><a href="#2-强调动作的承受者" class="headerlink" title="2) 强调动作的承受者"></a>2) 强调动作的承受者</h6><p>① Eight hours per day for sleep must be guaranteed.</p>
<h6 id="3-主动语态变被动语态的方法"><a href="#3-主动语态变被动语态的方法" class="headerlink" title="3) 主动语态变被动语态的方法"></a>3) 主动语态变被动语态的方法</h6><p><span style = "color : red">① 把主动语态的<strong>宾语</strong>变为被动语态的<strong>主语</strong></span><br><span style = "color : red">② 把谓语变成被动结构 (<strong>be+过去分词</strong>) [被动形式]</span><br><span style = "color : red">③ 把主动语态中的<strong>主语</strong><u>放在</u>介词<u><strong>by</strong>之后</u>作<strong>宾语</strong>, 将主格改为宾格</span></p>
<p>Ⅰ. All the people laughed at him.[一般过去时]<br>      He was laughed at by all the people.</p>
<p>Ⅱ. They make</p>
<h6 id="4-含有情态动词的被动语态：”情态动词-be-done”"><a href="#4-含有情态动词的被动语态：”情态动词-be-done”" class="headerlink" title="4) 含有情态动词的被动语态：”情态动词 + be + done”"></a>4) 含有情态动词的被动语态：”情态动词 + be + done”</h6><p>Ⅰ. We can repair this watch in two days.<br>      This watch can be repaired in two days.<br>Ⅱ. We must finish this work soon.<br>      This work must be done soon.</p>
<h6 id="5-主动语态变被动语态需要注意的几个问题"><a href="#5-主动语态变被动语态需要注意的几个问题" class="headerlink" title="5) 主动语态变被动语态需要注意的几个问题"></a>5) 主动语态变被动语态需要注意的几个问题</h6><p><strong>① 时态保持一致</strong><br>    Ⅰ. I have repaired my computer. [现在完成时]<br>         My computer has been repaired.</p>
<p><strong>② 被动语态不能丢掉动词短语的介词或副词</strong><br>    Ⅰ. His best friend often <strong>looks after</strong> him.<br>          He is often <strong>looked after</strong> by his best friend.</p>
<p><strong>③ 若双宾语(一个人一个物),将其中一个宾语变为被动句的主语,另一个宾语不变</strong><br>     make&#x2F;buy&#x2F;get用<strong>for</strong>； give&#x2F;send&#x2F;lend&#x2F;take用<strong>to</strong><br>    Ⅰ. Vivian gave <strong>me</strong> a book<br>          <strong>I</strong> was given <strong>a book</strong> by Vivian.<br>         <strong>A book</strong> was given to me by Vivian.<br>双宾： make&#x2F;buy&#x2F;get用<strong>for</strong>； give&#x2F;send&#x2F;lend&#x2F;take用<strong>to</strong><br>一定是一个人一个物<br><span style = "color : blue">如果先都说人 无论主动被动<strong>都没有介词</strong></span><br>I’ll give you the child</p>
<p><span style = "color : blue">如果先都说物    无论主动被动<strong>都有介词</strong></span><br>I am writing to your child</p>
<p><strong>④ 若复合宾语，将主动句的宾语变成被动句的主语，宾补不变</strong><br>    Ⅰ. <strong>They</strong> call <strong>him</strong> Louis.<br>          <strong>He</strong> is called Louis.</p>
<p><strong>⑤ “动词+宾语+宾语补足语”</strong>, 将宾语变为被动结构中的主语, 其余不动<br>    Ⅰ. Someone <strong>caught</strong> <strong><u>the boy</u></strong> <strong>smoking a cigarette</strong>.<br>          <strong>The boy</strong> was caught smoking a cigarette.</p>
<p><strong>⑥ It is said that+从句及类似句型</strong> 【据说…   人们…】</p>
<p>​    “It + be + 过去分词 + that从句” <strong>或</strong> “主语 + be + 过去分词 + to do sth”</p>
<pre><code class="java">被动句型(不会改被动就直接套用)
① It is said that... 据说
② It is reported that... 据报道
③ It is believed that... 大家相信
④ It is hoped that... 大家希望
⑤ It is well known that... 众所周知
⑥ It is thought that... 大家认为
⑦ It is suggested that... 据建议
</code></pre>
<h3 id="语言丰富方式三：比较结构巧妙使用"><a href="#语言丰富方式三：比较结构巧妙使用" class="headerlink" title="语言丰富方式三：比较结构巧妙使用"></a>语言丰富方式三：比较结构巧妙使用</h3><h5 id="1-同级比较"><a href="#1-同级比较" class="headerlink" title="1.同级比较"></a>1.同级比较</h5><h6 id="①-as…as-出现形容词副词-the-same-as-the-identical-with-与…一样"><a href="#①-as…as-出现形容词副词-the-same-as-the-identical-with-与…一样" class="headerlink" title="① as…as(出现形容词副词); the same as; the identical with;  与…一样"></a>① as…as(出现形容词副词); the same as; the identical with;  与…一样</h6><p>She has written <u>as many essays as</u> her brother.</p>
<h6 id="②-no-more…-than-或-not…any-more-than-和…一样不-A是不…-B也不…"><a href="#②-no-more…-than-或-not…any-more-than-和…一样不-A是不…-B也不…" class="headerlink" title="② no more… than 或 not…any more than;  和…一样不 (A是不… B也不…)"></a>② no more… than 或 not…any more than;  和…一样不 (A是不… B也不…)</h6><p>the more…the more句型【越来越…       越… 越…】</p>
<p>The heart is <u>no more intelligent than</u> the stomach, for they are both controlled by the brain.</p>
<h5 id="2-表最高程度"><a href="#2-表最高程度" class="headerlink" title="2.表最高程度"></a>2.表最高程度</h5><h6 id="①-no-名词-more…than；-没有什么比…更…-莫过于"><a href="#①-no-名词-more…than；-没有什么比…更…-莫过于" class="headerlink" title="① no + 名词 + more…than；  没有什么比…更…;  莫过于"></a>① no + 名词 + more…than；  没有什么比…更…;  莫过于</h6><p><u><strong>No</strong></u> tool is <u><strong>more <strong>powerful</u> for understanding the natural world <u><strong>than</strong> the scientific method.</u> 【<u>拉长 添加</strong>状语</strong> 定语</u>】</p>
<h6 id="②-more…than-anyone-和人比-x2F-anything-和物比-else；-比其他任何…都…、没有比…更…"><a href="#②-more…than-anyone-和人比-x2F-anything-和物比-else；-比其他任何…都…、没有比…更…" class="headerlink" title="② more…than + anyone(和人比)&#x2F;anything(和物比) else； 比其他任何…都…、没有比…更…"></a>② more…than + anyone(和人比)&#x2F;anything(和物比) else； 比其他任何…都…、没有比…更…</h6><p>He did <u>more</u> work this morning <u>than anyone else.</u></p>
<h5 id="3-表示倍数-【as、of、than】"><a href="#3-表示倍数-【as、of、than】" class="headerlink" title="3. 表示倍数 【as、of、than】"></a>3. 表示倍数 【as、of、than】</h5><p><strong>as</strong>…只能跟adj&#x2F;adv        <strong>of</strong>…只能跟n        <strong>than</strong>…只能跟比较级</p>
<h6 id="①-倍数-as-形容词或副词-as"><a href="#①-倍数-as-形容词或副词-as" class="headerlink" title="① 倍数 + as + 形容词或副词 + as"></a>① 倍数 + as + 形容词或副词 + as</h6><p>An ordinary subway train, approaching the station, can be <u>twice as loud as</u> the loudest jet.</p>
<h6 id="②-倍数-名词-of"><a href="#②-倍数-名词-of" class="headerlink" title="② 倍数 + 名词 + of"></a>② 倍数 + 名词 + of</h6><p>The bridge is <u>three times the length of</u> that one.</p>
<h6 id="③-倍数-比较级-than"><a href="#③-倍数-比较级-than" class="headerlink" title="③ 倍数 + 比较级 + than"></a>③ 倍数 + 比较级 + than</h6><p>This hole is <u>three times deeper than</u> that one.</p>
<h5 id="4-more-than"><a href="#4-more-than" class="headerlink" title="4. more than"></a>4. more than</h5><h6 id="①-more-than-动词或名词：”不仅仅是-不只是”"><a href="#①-more-than-动词或名词：”不仅仅是-不只是”" class="headerlink" title="① more than + 动词或名词：”不仅仅是, 不只是”"></a>① more than + 动词或名词：”不仅仅是, 不只是”</h6><p>They may teach very well, and more than earn their salaries, but most of them make little…</p>
<h6 id="②-more-than-形容词：非常-代替not-only、very、over"><a href="#②-more-than-形容词：非常-代替not-only、very、over" class="headerlink" title="② more than + 形容词：非常 (代替not only、very、over)"></a>② more than + 形容词：非常 (代替not only、very、over)</h6><p>The USA remains <u>more than capable</u> of holding down.</p>
<h3 id="语言丰富方式四：强调倒装恰当使用"><a href="#语言丰富方式四：强调倒装恰当使用" class="headerlink" title="语言丰富方式四：强调倒装恰当使用"></a>语言丰富方式四：强调倒装恰当使用</h3><h4 id="一-强调句：It-is-x2F-was-被强调的部分-that-句子的其他部分"><a href="#一-强调句：It-is-x2F-was-被强调的部分-that-句子的其他部分" class="headerlink" title="(一) 强调句：It is&#x2F;was + 被强调的部分 + that + 句子的其他部分"></a>(一) 强调句：It is&#x2F;was + 被强调的部分 + that + 句子的其他部分</h4><p>(<strong>谓语以外的任何成分</strong>都可以放在被强调部分当中进行强调)</p>
<h6 id="改写句子①"><a href="#改写句子①" class="headerlink" title="改写句子①"></a>改写句子①</h6><p><u>Wester health-care system</u> <strong>are spending</strong> <u>huge sums of money</u> <u>on the surgical treatment of the disease</u>.( 可以改成三个强调句)<br>① It is <strong>Wester health-care system</strong> that are spending huge sums of money on the surgical treatment of the disease.<br>② It is <strong>huge sums of money</strong> that Western health-care system are spending on the surgical treatment of the disease.<br>③ It is **on the surgical treatment of the disease ** that Western health-care system are spending huge sums of money.</p>
<h6 id="改写句子②"><a href="#改写句子②" class="headerlink" title="改写句子②"></a>改写句子②</h6><p><u>Ann Peters’ husband</u> <strong>rushed</strong> <u>her</u> <u>to a nearby hospital</u> <u>last night.</u><br>① It was <strong>Ann Peters’ husband</strong> that(who) rushed her to nearby hospital last night.<br>② It was <strong>her</strong> that(who) Ann Peters’ husband rushed her to nearby hospital last night.<br>③ It was <strong>to a nearby hospital</strong> that Ann Peters’ husband rushed her last night.<br>④ It was <strong>last night</strong> that Ann Peters’ husband rushed her to a nearby hospital.<br><strong>提示1：</strong><br>1.叙述的是现在或者将来：“It is … that … ”<br>2.叙述的是过去：”It was … that …”</p>
<p><strong>提示2：</strong></p>
<h6 id="强调动词的时候-没有强调句子谓语的强调句，但又其通常的强调手段：do-x2F-does-x2F-did-动词原形"><a href="#强调动词的时候-没有强调句子谓语的强调句，但又其通常的强调手段：do-x2F-does-x2F-did-动词原形" class="headerlink" title="强调动词的时候 没有强调句子谓语的强调句，但又其通常的强调手段：do &#x2F; does &#x2F; did + 动词原形"></a>强调动词的时候 没有强调句子谓语的强调句，但又其通常的强调手段：do &#x2F; does &#x2F; did + 动词原形</h6><p>I <strong>do</strong> believe that he is an honest man.<br>They <strong>did</strong> go to see you yesterday, but failed to meet you.</p>
<h4 id="二-倒装：-主谓-→-谓主-3个被动-定语-原因状语-强调句-倒装-only时间状语-so…that"><a href="#二-倒装：-主谓-→-谓主-3个被动-定语-原因状语-强调句-倒装-only时间状语-so…that" class="headerlink" title="(二) 倒装：(主谓 → 谓主) ( 3个被动 定语 原因状语 强调句 倒装[only时间状语  so…that])"></a>(二) 倒装：(主谓 → 谓主) ( 3个被动 定语 原因状语 强调句 倒装[only时间状语  so…that])</h4><p>① 指将谓语的一部分(如助动词或情态)至主语之前<br>② 如果句子的谓语没有助动词或情态动词，需加助动词do, does或did, 将其置于主语之前</p>
<h6 id="全部倒装"><a href="#全部倒装" class="headerlink" title="全部倒装"></a>全部倒装</h6><p>要把<strong>所有的谓语</strong>都拿到主语前面 和其他成分无关</p>
<h6 id="部分倒装"><a href="#部分倒装" class="headerlink" title="部分倒装"></a>部分倒装</h6><p>要把<strong>谓语的一部分</strong>拿到主语前面<br>助动词+动词        情态动词+动词</p>
<h6 id="1-only句首"><a href="#1-only句首" class="headerlink" title="1. only句首"></a>1. only句首</h6><p>① <strong>Only in this way can you learn</strong>(介词短语) English well.<br>② <strong>Only after being asked three times</strong>(非谓语动词) did he come to the meeting.<br>③ <span style = "color:red"><strong>Only when he is seriously ill</strong>(从句)</span> does he ever stay in bed.<br>Only when 大学生… do they 意识到…</p>
<h6 id="2-句首为否定意义的词语"><a href="#2-句首为否定意义的词语" class="headerlink" title="2. 句首为否定意义的词语"></a>2. 句首为否定意义的词语</h6><h6 id="如：no-never-seldom-little-hardly-at-no-time-in-no-way-not-until…等"><a href="#如：no-never-seldom-little-hardly-at-no-time-in-no-way-not-until…等" class="headerlink" title="如：no, never, seldom, little, hardly, at no time, in no way, not until…等"></a>如：no, never, seldom, little, hardly, at no time, in no way, not until…等</h6><p>① Never have I seen such a performance.<br>② Nowhere will you find the answer to this question.<br>③ Not until the child fell asleep did the mother leave the room.</p>
<h6 id="3-so…that-句型中的so位于句首时，需倒装"><a href="#3-so…that-句型中的so位于句首时，需倒装" class="headerlink" title="3. so…that 句型中的so位于句首时，需倒装"></a>3. so…that 句型中的so位于句首时，需倒装</h6><p>   he was so frightened that he did not dare to move an inch.<br>&#x3D;<strong>So</strong> frightened <strong>was he</strong> that he did not dare to move an inch.</p>
<h6 id="4-在虚拟语气中-可将if省略-采取部分倒装"><a href="#4-在虚拟语气中-可将if省略-采取部分倒装" class="headerlink" title="4. 在虚拟语气中, 可将if省略, 采取部分倒装"></a>4. 在虚拟语气中, 可将if省略, 采取部分倒装</h6><p>Were I you, I would try it again</p>
<h5 id="3个被动-定语-原因状语-强调句-倒装-写作必须拥有的"><a href="#3个被动-定语-原因状语-强调句-倒装-写作必须拥有的" class="headerlink" title="3个被动 定语 原因状语 强调句 倒装 写作必须拥有的"></a><span style = "color:red">3个被动 定语 原因状语 强调句 倒装 写作必须拥有的</span></h5><h3 id="八种万能功能段-三八大盖"><a href="#八种万能功能段-三八大盖" class="headerlink" title="八种万能功能段 (三八大盖)"></a>八种万能功能段 (三八大盖)</h3><h6 id="现象-x2F-问题描述功能段"><a href="#现象-x2F-问题描述功能段" class="headerlink" title="现象&#x2F;问题描述功能段"></a><span style = "color:blue">现象&#x2F;问题描述功能段</span></h6><p><strong>①</strong> In recent years, … is becoming increasingly popular&#x2F;prevalent at an amazing rate.<br>近年来, …越来越流行(现象)<br><strong>②</strong> <span style = "color:red">Along with the advance of the society more and more problems are brought to our attention, one of which is that…</span><br>随着社会的不断发展，出现了越来越多的问题引起我们的注意                                                                                                                                                                                  ，其中之一便是…</p>
<h6 id="原因分析功能段-总原因的阐述"><a href="#原因分析功能段-总原因的阐述" class="headerlink" title="原因分析功能段 (总原因的阐述)"></a><span style = "color:blue">原因分析功能段 (总原因的阐述)</span></h6><p>① <span style = "color:red">A number of factors might <u>contribute to</u>&#x2F;<u>account for</u> the phenomenon&#x2F;problem.</span><br>许多因素可能是造成这种现象&#x2F;问题的原因。<br>② The reasons for … mainly lie in the following two aspects.<br>原因…主要表现在以下两个方面。<br>(<strong>分原因阐述&#x3D;&gt;原因数量决定</strong>)<br>① <span style = "color:red">One of the most common factor is that…</span><br>② Another contributing cause is…<br>③ Perhaps the primary reason is that…<br>④ But the fundamental element is that…</p>
<h6 id="观点阐述功能段"><a href="#观点阐述功能段" class="headerlink" title="观点阐述功能段"></a><span style = "color:blue">观点阐述功能段</span></h6><p><strong>观点主题句</strong><br>① <span style = "color:red">People have (take,adopt,assume) different attitudes towards.</span><br>② People have different opinions on this problem.</p>
<p><strong>观点</strong><br>① <span style = "color:red">According to a survey, some people are in favor of the idea of doing… They point out the fact that(+支持…的第一个原因) they also argue that… (+支持…的另一个原因)</span></p>
<h6 id="观点结论功能段"><a href="#观点结论功能段" class="headerlink" title="观点结论功能段"></a><span style = "color:blue">观点结论功能段</span></h6><p>① <span style = "color:red">From what has been discussed above, we may safely draw the conclusion that…</span><br>根据以上讨论，我们可以得出下面的结论</p>
<h6 id="解决问题功能段"><a href="#解决问题功能段" class="headerlink" title="解决问题功能段"></a><span style = "color:blue">解决问题功能段</span></h6><p><strong>措施主题句</strong><br>① ___ has been playing an increasingly important role in our day-to-day life, which has brought us a lot of benefits but has created some serious problems as well.<br>…在日常生活中发挥着越来越重要的作用, 它给我们带来了很多好处</p>
<p><strong>分措施</strong><br>① <strong>First and foremost</strong>, government should establish some regulations to…<br>② <strong>What’s more</strong>, people should get ready to…<br>③ <strong>After all</strong>, it is necessary to advocate the whole society to…</p>
<p><strong>解决问题总结句</strong><br>① In summary, if we continue to ignore the above-mentioned issue, more problems will crop up.<br>总之，如果我们继续忽略上述问题，会有更多问题出现<br>② From my point of view, college students should … when it comes to … What’s more, we should always bear in mind that…<br>我认为, … 大学生应该自己…此外, 我们应牢记…</p>
<h6 id="未来展望功能段"><a href="#未来展望功能段" class="headerlink" title="未来展望功能段"></a><span style = "color:blue">未来展望功能段</span></h6><p>① It can directly promote the rapid progress of … , and eventually brings …<br>它可以直接促进…还可也用来…</p>
<h6 id="漫画-x2F-图表描述功能段"><a href="#漫画-x2F-图表描述功能段" class="headerlink" title="漫画&#x2F;图表描述功能段"></a><span style = "color:blue">漫画&#x2F;图表描述功能段</span></h6><p>① It  can be easily seen from the picture(chart&#x2F;line&#x2F;graph) that… The picture is intended to inform us of the bad effects of college student’s…<br>从图片中很容易可以看到, …这幅画是在告诉我们 … 有着不好的影响<br>② <span style = "color:red">According to the <u>figure&#x2F;number&#x2F;statistics</u> in the <u>chart&#x2F; bar graph&#x2F;line</u>, it can be seen that…</span></p>
<h6 id="引语解释功能段"><a href="#引语解释功能段" class="headerlink" title="引语解释功能段"></a><span style = "color:blue">引语解释功能段</span></h6><p>① <span style = "color:red">There is such a saying … This saying <strong>not only</strong> emphasizes the importance of… <strong>but also</strong> indicates that…</span><br>有这样一句名言：….这句话不仅强调了…的重要性，而且指出…</p>
<h5 id="附加：举例子"><a href="#附加：举例子" class="headerlink" title="附加：举例子"></a>附加：举例子</h5><p>① There may be no better example than the following one.</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#1bccbc>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2023/11/19/英语/四级作文-新/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/11/15/后端/Linux,Redis,Jedis/">
        <h2>
            Linux,Redis,Jedis
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/11/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Linux基础入门"><a href="#Linux基础入门" class="headerlink" title="Linux基础入门"></a>Linux基础入门</h1><h3 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h3><ul>
<li><h6 id="介绍Linux与CentOS"><a href="#介绍Linux与CentOS" class="headerlink" title="介绍Linux与CentOS"></a>介绍Linux与CentOS</h6></li>
<li><h6 id="讲解Linux基础"><a href="#讲解Linux基础" class="headerlink" title="讲解Linux基础"></a>讲解Linux基础</h6></li>
<li><h6 id="Linux文本工具与命令"><a href="#Linux文本工具与命令" class="headerlink" title="Linux文本工具与命令"></a>Linux文本工具与命令</h6></li>
<li><h6 id="yum应用安装与卸载"><a href="#yum应用安装与卸载" class="headerlink" title="yum应用安装与卸载"></a>yum应用安装与卸载</h6></li>
<li><h6 id="CentOS的权限与系统安全"><a href="#CentOS的权限与系统安全" class="headerlink" title="CentOS的权限与系统安全"></a>CentOS的权限与系统安全</h6></li>
<li><h6 id="部署OA项目至Linux服务器"><a href="#部署OA项目至Linux服务器" class="headerlink" title="部署OA项目至Linux服务器"></a>部署OA项目至Linux服务器</h6></li>
</ul>
<h3 id="主流操作系统"><a href="#主流操作系统" class="headerlink" title="主流操作系统"></a>主流操作系统</h3><p>不同领域的主流操作系统，主要分为以下这么几类： 桌面操作系统、服务器操作系统、移动设备操作系统、嵌入式操作系统。接下来，这几个领域中，代表性的操作系统是那些?</p>
<p>1). 桌面操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td>用户数量最多</td>
</tr>
<tr>
<td>MacOS</td>
<td>操作体验好，办公人士首选</td>
</tr>
<tr>
<td>Linux</td>
<td>用户数量少(桌面操作系统,Linux使用较少)</td>
</tr>
</tbody></table>
<p>2). 服务器操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Unix</td>
<td>安全、稳定、付费</td>
</tr>
<tr>
<td>Linux</td>
<td>安全、稳定、免费、占有率高</td>
</tr>
<tr>
<td>Windows Server</td>
<td>付费、占有率低</td>
</tr>
</tbody></table>
<p>3). 移动设备操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Android</td>
<td>基于 Linux 、开源，主要用于智能手机、平板电脑和智能电视</td>
</tr>
<tr>
<td>IOS</td>
<td>苹果公司开发、不开源，用于苹果公司的产品，例如：iPhone、 iPad</td>
</tr>
</tbody></table>
<p>4). 嵌入式操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>机顶盒、路由器、交换机</td>
</tr>
</tbody></table>
<h3 id="2-2-Linux系统版本"><a href="#2-2-Linux系统版本" class="headerlink" title="2.2 Linux系统版本"></a>2.2 Linux系统版本</h3><p>Linux系统的版本分为两种，分别是： 内核版 和 发行版。</p>
<p><strong>1). 内核版</strong></p>
<ul>
<li><p>由Linus Torvalds及其团队开发、维护</p>
</li>
<li><p>免费、开源</p>
</li>
<li><p>负责控制硬件</p>
</li>
</ul>
<p><strong>2). 发行版</strong></p>
<ul>
<li><p>基于Linux内核版进行扩展</p>
</li>
<li><p>由各个Linux厂商开发、维护</p>
</li>
<li><p>有收费版本和免费版本</p>
</li>
</ul>
<p>我们使用Linux操作系统，实际上选择的是Linux的发行版本。在linux系统中，有各种各样的发行版本，具体如下： </p>
<table>
<thead>
<tr>
<th>发行版本</th>
<th>Logo</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu</td>
<td><img src="assets/image-20210809001838861.png" alt="image-20210809001838861" style="zoom:50%;" /></td>
<td>以桌面应用为主</td>
</tr>
<tr>
<td>RedHat</td>
<td><img src="assets/image-20210809001731378.png" alt="image-20210809001731378" style="zoom:50%;" /></td>
<td>应用最广泛、收费</td>
</tr>
<tr>
<td><strong>CentOS</strong></td>
<td><img src="assets/image-20210809001741238.png" alt="image-20210809001741238" style="zoom:50%;" /></td>
<td>RedHat的社区版、免费</td>
</tr>
<tr>
<td>openSUSE</td>
<td><img src="assets/image-20210809001750999.png" alt="image-20210809001750999" style="zoom:50%;" /></td>
<td>对个人完全免费、图形界面华丽</td>
</tr>
<tr>
<td>Fedora</td>
<td><img src="assets/image-20210809001800676.png" alt="image-20210809001800676" style="zoom:50%;" /></td>
<td>功能完备、快速更新、免费</td>
</tr>
<tr>
<td>红旗Linux</td>
<td><img src="assets/image-20210809001814942.png" alt="image-20210809001814942" style="zoom:50%;" /></td>
<td>北京中科红旗软件技术有限公司开发</td>
</tr>
</tbody></table>
<p>除了上述罗列出来的发行版，还有很多Linux发行版，这里，我们就不再一一列举了。</p>
<h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><ul>
<li>操作系统(<strong>O</strong>perating <strong>S</strong>ystem)是应用程序运行的基础支撑环境</li>
<li>操作系统作用是管理和控制计算机系统的硬件与软件资源</li>
<li>Intel x86架构上常见的操作系统：Windows、Linux、Unix…</li>
</ul>
<h3 id="Linux操作系统-1"><a href="#Linux操作系统-1" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h3><ul>
<li>Linux是开源的基于Inter x86架构的类Unix多用户操作系统</li>
<li>支持多任务、多用户、多CPU</li>
<li>高效而灵活</li>
<li>兼容任意x86架构计算机</li>
<li>强大易用的系统命令</li>
<li>完整的应用软件生态</li>
</ul>
<h3 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h3><ul>
<li>Linux系统内核(kernel)提供了Linux操作系统的核心功能</li>
<li>不同开发商在内核基础上扩展封装，形成了不同发行版本</li>
<li>常见发行版：Red Hat Linux、CentOS、Ubuntu、SUSE…</li>
</ul>
<h3 id="Linux发行版选择建议"><a href="#Linux发行版选择建议" class="headerlink" title="Linux发行版选择建议"></a>Linux发行版选择建议</h3><ul>
<li>桌面系统：Ubuntu</li>
<li>服务器操作系统：**CentOS(免费)**、Red Hat Linux(收费)</li>
<li>特定需求：Debian(稳定性)、Fedoras(新特性)、麒麟Linux(国产)</li>
</ul>
<h3 id="CentOS-社区企业操作系统"><a href="#CentOS-社区企业操作系统" class="headerlink" title="CentOS - 社区企业操作系统"></a>CentOS - 社区企业操作系统</h3><ul>
<li>基于<strong>R</strong>ed <strong>H</strong>at <strong>E</strong>nterprice <strong>L</strong>inux的开源企业级Linux发行版本</li>
<li>各版本CentOS都会获得十年的支持，与RHEL保持同步更新</li>
<li>CentOS采用社区支持，同步修正了RHEL许多BUG</li>
</ul>
<h3 id="CentOS版本选择"><a href="#CentOS版本选择" class="headerlink" title="CentOS版本选择"></a>CentOS版本选择</h3><ul>
<li>CentOS 5&#x2F;6：历史淘汰版本</li>
<li><strong>CentOS 7：主流版本，成熟稳定，大多数服务器的首先版本</strong></li>
<li>CentOS 8：全新版本，全新内核，存在漏洞隐患</li>
</ul>
<h3 id="安装CentOS-7-7"><a href="#安装CentOS-7-7" class="headerlink" title="安装CentOS 7.7"></a>安装CentOS 7.7</h3><p>vmware.com&#x2F;cn.html</p>
<p>VMware-workstation-full-14.1.2-8497320.exe<br>[链接： <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1EbuhZ4D4kh_NcRJqTA-vhQ">https://pan.baidu.com/s/1EbuhZ4D4kh_NcRJqTA-vhQ</a><br>密码：oq37]</p>
<p>mirrors.aliyun.com&#x2F;centos&#x2F;7.7.1908&#x2F;isos&#x2F;x86_64&#x2F; 下载 Everything-1908.iso<br>[<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/centos-vault/centos/7.7.1908/isos/x86_64/">centos-vault-centos-7.7.1908-isos-x86_64安装包下载_开源镜像站-阿里云 (aliyun.com)</a>]</p>
<p>VM典型 镜像Iso 存储地址放在最快的硬盘 将虚拟磁盘存储为单个文件 自定义(内存2GB 处理器2核  虚拟化 Intel VT-x)</p>
<h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>根目录&#x2F; 下各个目录的作用及含义说明:  </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>目录</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>&#x2F;bin</td>
<td>存放二进制可执行文件</td>
</tr>
<tr>
<td>2</td>
<td>&#x2F;boot</td>
<td>存放系统引导时使用的各种文件</td>
</tr>
<tr>
<td>3</td>
<td>&#x2F;dev</td>
<td>存放设备文件</td>
</tr>
<tr>
<td>4</td>
<td><strong>&#x2F;etc</strong></td>
<td>存放系统配置文件</td>
</tr>
<tr>
<td>5</td>
<td><strong>&#x2F;home</strong></td>
<td>存放系统用户的文件</td>
</tr>
<tr>
<td>6</td>
<td>&#x2F;lib</td>
<td>存放程序运行所需的共享库和内核模块</td>
</tr>
<tr>
<td>7</td>
<td>&#x2F;opt</td>
<td>额外安装的可选应用程序包所放置的位置</td>
</tr>
<tr>
<td>8</td>
<td><strong>&#x2F;root</strong></td>
<td>超级用户目录</td>
</tr>
<tr>
<td>9</td>
<td>&#x2F;sbin</td>
<td>存放二进制可执行文件，只有root用户才能访问</td>
</tr>
<tr>
<td>10</td>
<td>&#x2F;tmp</td>
<td>存放临时文件</td>
</tr>
<tr>
<td>11</td>
<td><strong>&#x2F;usr</strong></td>
<td>存放系统应用程序</td>
</tr>
<tr>
<td>12</td>
<td>&#x2F;var</td>
<td>存放运行时需要改变数据的文件，例如日志文件</td>
</tr>
</tbody></table>
<h3 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h3><h6 id="命令-参数选项-文件或路径"><a href="#命令-参数选项-文件或路径" class="headerlink" title="命令 [参数选项] [文件或路径]"></a>命令 [参数选项] [文件或路径]</h6><h5 id="Linux文件操作核心命令"><a href="#Linux文件操作核心命令" class="headerlink" title="Linux文件操作核心命令"></a>Linux文件操作核心命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>pwd</td>
<td>查看当前目录</td>
</tr>
<tr>
<td><strong>ls</strong>、ll(详细列表)</td>
<td>显示目录内容</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录</td>
</tr>
<tr>
<td><strong>cp</strong></td>
<td>复制文件与目录</td>
</tr>
<tr>
<td><strong>mv</strong></td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件或目录</td>
</tr>
<tr>
<td>find</td>
<td>查找目录或文件</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43585157/article/details/106992907">Xshell连接虚拟机详细教程-CSDN博客</a></p>
<pre><code class="java">按下Tab可以自动提示
输入su 密码root 进入root最高权限

cd ..                 返回上级目录
cd ./local             ./代表当前目录
cd local            到当前目录    

mkdir ./imooc
mkdir -p ./imooc/sample/demo       -p是连续创建多级目录

mkdir -p ./imooc1/sample1
mkdir -p -v./imooc1/sample1     -v是显示执行过程
mkdir -p -v./imooc1/sample1/demo1
=
mkdir -pv ./imooc1/sample1
    
cp Xftp-7.0.014lp.exe ./imooc/sample/demo 文件复制到指定目录
cp -r imooc/sample/demo imooc1/sample1/demo1 复制整个文件夹

cd imooc/sample/demo
mv Xftp-7.0.014lp.exe xftp.exe 重命名
ls

mv xftp.exe /imooc1/sample1/demo1 移动到其他目录
mv demo imooc1/sample1/demo1 移动文件夹到其他目录

cd game/share
rm -r music  y y y    依次删除文件夹中的文件
rm -f music 强制直接删除, 不经过询问
rm -rf music 强制迭代删除            【不要轻易使用】
【ex】 rm -rf / imooc/sample/demo 中间不小心加了空格 就把/后面的整个都删除了

find / -name *.exe 按指定的格式去搜索文件
cd ..
[root@imooc home] find / -name *
</code></pre>
<h3 id="vim文本编辑器"><a href="#vim文本编辑器" class="headerlink" title="vim文本编辑器"></a>vim文本编辑器</h3><h6 id="远程在线文本编辑器"><a href="#远程在线文本编辑器" class="headerlink" title="远程在线文本编辑器"></a>远程在线文本编辑器</h6><ul>
<li>vi是linux重要的文字编辑工具，vim是增强版</li>
<li>vim用于在远程环境下用命令形式对文本进行在线编辑</li>
<li>用法格式：<strong>vim [选项] [文件]</strong></li>
</ul>
<h3 id="vim三种模式"><a href="#vim三种模式" class="headerlink" title="vim三种模式"></a>vim三种模式</h3><ul>
<li>普通模式：默认模式，文本只读，不可编辑</li>
<li>编辑模式：编辑文本模式，普通模式按i键进入，ESC键退出</li>
<li>命令模式：执行保存、搜索、退出等操作</li>
</ul>
<h3 id="vim重要快捷键"><a href="#vim重要快捷键" class="headerlink" title="vim重要快捷键"></a>vim重要快捷键</h3><p>按<strong>i</strong>进入编辑模式</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>delete或x</td>
<td>删除单个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>&#x2F;str</td>
<td>全文查找str字符串，n下一个，N前一个</td>
</tr>
<tr>
<td>:% s&#x2F;old&#x2F;new&#x2F;g</td>
<td>替换文件内所有old字符串为new</td>
</tr>
<tr>
<td>u</td>
<td>撤销最近一次操作</td>
</tr>
<tr>
<td>:wq或者**:wq!**</td>
<td><strong>退出并保存</strong>，只读文件要格外加！</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出放弃保存</td>
</tr>
</tbody></table>
<pre><code class="java">vim server.xml         修改文件
按i进入编辑模式
Home跳转行首
End跳转行尾
Esc退出编辑模式

命令只允许在普通模式下运行
/8080                     查找端口(高亮显示)
查找到后按n是查找下一个 按N是查找上一个
u  撤销最近一次操作
:% s/8080/8900/g        进行端口的全局替换
:% s/&quot;80&quot;/8900/g         想要把80改成8900 且不影响其他数值[把引号也加入其中]
</code></pre>
<h3 id="Linux文本工具"><a href="#Linux文本工具" class="headerlink" title="Linux文本工具"></a>Linux文本工具</h3><h5 id="常用文本工具"><a href="#常用文本工具" class="headerlink" title="常用文本工具"></a>常用文本工具</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>echo</td>
<td>屏幕打印与文本输出 后面要加引号”hello”</td>
</tr>
<tr>
<td>cat</td>
<td>合并文件或查看文件内容</td>
</tr>
<tr>
<td>tail</td>
<td>显示文件内容尾部</td>
</tr>
<tr>
<td>grep</td>
<td>文本过滤工具</td>
</tr>
</tbody></table>
<pre><code class="java">echo &quot;hello&quot; &gt; hello.txt 将左侧命令的结果重写到右侧文件
vim hello.txt
:q        退出

echo &quot;hello&quot; &gt;&gt; hello.txt 内容的追加

cat hello.txt 直接打印到控制台
cat -n hello.txt  -n是在每一行前加行号
cat -nE hello.txt  结尾的时候显示结束符$

echo &quot;hello&quot; &gt; hello.txt
cat hello.txt  =&gt; hello
echo &quot;my name is lili&quot; &gt; myname.txt
cat hello.txt myname.txt &gt;&gt; full.txt    合并文件内容为新的文件    
vim full.txt
echo 和 cat 在实际开发中 打印日志 最后用cat拼接日志

cat &gt; test.txt &lt;&lt; EOF   在当前的输入环境中产生输入流 输入的全输入到test.txt 输入流结束字符串是EOF
&gt; Welcome to imooc.com
&gt; I like linux
&gt; bye!
&gt; EOF

tail处理日志很方便 bug日志
tail full.txt =&gt; hello       my name is lili
tail -n 1 full.txt =&gt; my name is lili   &quot;1&quot;代表显示文本最后一行
tail -f full.txt      对文件进行监听 一旦产生变化就输出控制台【适合用在服务器】
ctrl + c 退出

#cat test.txt
=&gt; welcome to imooc.com
=&gt; I like linux
=&gt; bye!
#grep l test.txt
we&quot;l&quot;come to imooc.com
I &quot;l&quot;ike &quot;l&quot;inux

#grep l test.txt &gt; out.txt            符合条件的可以输出到out.txt文件中
#grep -v l test.txt                    -v 挑选出不包含l的test.txt文件
#grep i...c test.txt                &quot;.&quot;代表匹配任意字符

#ll | grep .txt                     通道特殊使用方法：筛选出后缀是.txt的 
前面ll命令输出的结果会作为后面gerp命令的依据   通过|进行分割 

#ll | grep -E &quot;log[0-9]&#123;1,5&#125;.txt&quot;    通道特殊使用方法：扩展正则表达式
-rw-r--r--. 1 root root 3 12月 23 13:10 log1.txt
-rw-r--r--. 1 root root 3 12月 23 13:10 log2.txt
-rw-r--r--. 1 root root 3 12月 23 13:10 log3.txt
</code></pre>
<h3 id="文件打包-文件组织-与压缩-磁盘节省"><a href="#文件打包-文件组织-与压缩-磁盘节省" class="headerlink" title="文件打包[文件组织]与压缩[磁盘节省]"></a>文件打包<del>[文件组织]</del>与压缩<del>[磁盘节省]</del></h3><h5 id="Linux压缩程序-gzip"><a href="#Linux压缩程序-gzip" class="headerlink" title="Linux压缩程序-gzip"></a>Linux压缩程序-gzip</h5><ul>
<li>gzip是Linux系统的文件压缩程序</li>
<li>gzip压缩包文件扩展名 <strong>.gz</strong></li>
<li>大流量的网站默认都在使用 <strong>gzip</strong> 进行数据压缩传输</li>
</ul>
<h5 id="tar打包与压缩"><a href="#tar打包与压缩" class="headerlink" title="tar打包与压缩"></a>tar打包与压缩</h5><ul>
<li>tar是linux系统将多个文件打包和压缩的工具</li>
<li>tar本质的打包软件，扩展名是 **.tar **</li>
<li>tar可结合gzip或其他压缩工具实现打包压缩，扩展名 <strong>.tar.gz</strong></li>
<li><strong>压缩命令：</strong><code>tar zcvf tomcat.tar.gz game/src</code></li>
<li><strong>解压缩命令：</strong><code>tar zxvf tomcat.tar.gz -C game/src</code></li>
</ul>
<h3 id="tar常用可选项"><a href="#tar常用可选项" class="headerlink" title="tar常用可选项"></a>tar常用可选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>通过gzip压缩或解压</td>
</tr>
<tr>
<td>c</td>
<td>创建新的tar.gz文件</td>
</tr>
<tr>
<td>v</td>
<td>显示执行过程</td>
</tr>
<tr>
<td>f</td>
<td>指定压缩文件名称</td>
</tr>
<tr>
<td>x</td>
<td>解压缩tar.gz文件</td>
</tr>
<tr>
<td>-C</td>
<td>指定解压缩目录</td>
</tr>
</tbody></table>
<h3 id="安装与卸载应用程序"><a href="#安装与卸载应用程序" class="headerlink" title="安装与卸载应用程序"></a>安装与卸载应用程序</h3><h5 id="为CentOS安装应用程序"><a href="#为CentOS安装应用程序" class="headerlink" title="为CentOS安装应用程序"></a>为CentOS安装应用程序</h5><ul>
<li><span style = "color:red">在CentOS中安装第三方应用程序包含<strong>两种方式</strong>：</span><ul>
<li>rpm: Red Hat 软件包管理器, 相当于应用程序安装文件的执行者</li>
<li><strong><u>编译安装</u><strong>：用户自己从网站下载程序</strong>源码</strong>进行<strong>编译安装</strong></li>
</ul>
</li>
</ul>
<h3 id="yum与rpm的关系"><a href="#yum与rpm的关系" class="headerlink" title="yum与rpm的关系"></a>yum与rpm的关系</h3><ul>
<li>rpm安装过程中, 需要用户自己解决依赖问题</li>
<li>yum通过引入软件仓库，联网下载rpm包及依赖，并依次自动安装</li>
<li>yum是rpm的前端程序，其目的就是简化rpm的安装过程</li>
</ul>
<h5 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h5><ul>
<li>yum search 应用名                  #在仓库中查询是否存在指定应用</li>
<li>yum instal -y 应用名                #全自动下载安装应用及依赖</li>
<li>yum info 应用名                       #查看应用详细信息</li>
<li>yum list installed 应用名         #查看已安装的应用程序</li>
<li>rpm -ql 应用名                          #查看安装后输出的文件清单</li>
<li>yum remove -y 应用名            #全自动卸载指定应用</li>
</ul>
<h5 id="①-利用yum安装tree"><a href="#①-利用yum安装tree" class="headerlink" title="① 利用yum安装tree"></a>① 利用yum安装tree</h5><pre><code class="java">yum search tree
yum install tree.x86_64 安装tree
yum install -y tree.x86_64 遇到所有的默认y进行安装
tree -d 或 tree                查看文件树型结构
which tree                     查看刚刚tree安装的目录
rpm -ql tree.x86_64         查看刚刚tree安装了哪些文件
yum list installed          查看已经安装的应用
yum list installed *tree*   查看已安装的应用其中有tree的
    
yum remove tree.x86_64  卸载程序
</code></pre>
<h5 id="②-利用编译方式安装应用程序"><a href="#②-利用编译方式安装应用程序" class="headerlink" title="② 利用编译方式安装应用程序"></a>② 利用编译方式安装应用程序</h5><ul>
<li>如yum仓库未提供rpm，往往需要采用编译安装方式</li>
<li>编译安装是指从应用网站下载源码后，对源码进行编译后使用</li>
<li>编译命令：**make #**使用对应编译器对源码编译生成可执行文件</li>
</ul>
<h6 id="yum与编译安装的比较"><a href="#yum与编译安装的比较" class="headerlink" title="yum与编译安装的比较"></a>yum与编译安装的比较</h6><table>
<thead>
<tr>
<th></th>
<th>yum安装</th>
<th>编译安装</th>
</tr>
</thead>
<tbody><tr>
<td>兼容性</td>
<td>差，每种发行版都要准备</td>
<td>好，全平台适用</td>
</tr>
<tr>
<td>复杂度</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>安装速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>来源</td>
<td>应用仓库</td>
<td>官网下载</td>
</tr>
<tr>
<td>应用场景</td>
<td>日常系统软件</td>
<td>开源软件，最新版本</td>
</tr>
</tbody></table>
<h3 id="编译安装Redis-非关系型数据库"><a href="#编译安装Redis-非关系型数据库" class="headerlink" title="编译安装Redis[非关系型数据库]"></a>编译安装Redis<del>[非关系型数据库]</del></h3><pre><code class="java"># make
# yum install -y gcc
# cd ..
# clear
# rm -rf ./redis-4.0.14
# tar zxvf redis-4.0.14.tar,gz
# cd redis-4.0.14/
# clear
# make

[root@imooc redis-4.0.14]# ./src/redis-server redis.conf
</code></pre>
<h3 id="Linux系统管理命令"><a href="#Linux系统管理命令" class="headerlink" title="Linux系统管理命令"></a>Linux系统管理命令</h3><h5 id="使用-ifconfig-查看网卡ip"><a href="#使用-ifconfig-查看网卡ip" class="headerlink" title="使用 ifconfig 查看网卡ip"></a>使用 <code>ifconfig</code> 查看网卡ip</h5><h4 id="netstat-查看网络端口号"><a href="#netstat-查看网络端口号" class="headerlink" title="netstat 查看网络端口号"></a><code>netstat</code> 查看网络端口号</h4><ul>
<li><p><strong>netstat -tulpn</strong> 或者 <strong>netstat -ano</strong></p>
<ul>
<li><p><strong>netstat</strong> 常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>t</td>
<td>显示tcp传输协议的连接状况</td>
</tr>
<tr>
<td>u</td>
<td>显示udp传输协议的连接状况</td>
</tr>
<tr>
<td>l</td>
<td>显示处于监听状态的网络连接</td>
</tr>
<tr>
<td>p</td>
<td>显示应用PID和程序名称</td>
</tr>
<tr>
<td>n</td>
<td>显示ip地址</td>
</tr>
<tr>
<td>a</td>
<td>显示所有连接</td>
</tr>
<tr>
<td>o</td>
<td>显示计时器</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="查看进程-amp-杀掉进程"><a href="#查看进程-amp-杀掉进程" class="headerlink" title="查看进程 &amp; 杀掉进程"></a>查看进程 &amp; 杀掉进程</h4><ul>
<li><strong>ps -ef</strong><br><code># ps -ef | grep vim</code>     ‘|’代表通道</li>
<li>**kill -9 PID ** 专门按照pid杀死指定进程(强制删除)</li>
</ul>
<pre><code class="java">#ps -ef | grep redis
#netstart -tulpn | grep 6379
</code></pre>
<h3 id="应用服务化"><a href="#应用服务化" class="headerlink" title="应用服务化"></a>应用服务化</h3><ul>
<li>应用服务化是指让应用程序以服务方式在系统后台运行</li>
<li>Linux系统对服务化应用进行统一管理</li>
<li>服务管理命令：<strong>systemctl</strong></li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>启动服务</td>
</tr>
<tr>
<td>stop</td>
<td>停止服务</td>
</tr>
<tr>
<td>restart</td>
<td>重启服务</td>
</tr>
<tr>
<td>enable</td>
<td>设置开机启动</td>
</tr>
<tr>
<td>disable</td>
<td>禁止开机启动</td>
</tr>
<tr>
<td>status</td>
<td>查看服务状态</td>
</tr>
<tr>
<td>daemon-reload</td>
<td>重载服务配置文件</td>
</tr>
<tr>
<td>list-unit-files</td>
<td>列出所有服务</td>
</tr>
</tbody></table>
<pre><code class="java">启动redis
./src/redis-server redis.conf  进入到redis安装目录下执行
ctrl + z 
#ps -ef | grep redis

#find / -name *.pid

cd.. cd.. cd.. 
cd usr/lib/systemd/system 
#pwd
=&gt;/usr/lib/systemd/system 
#vim redis.service 按i进入编写模式
=&gt;
&lt;==========================================================================&gt;
[Unit]
Description=Redis
After=syslog.target network.target remote-fs.target nss-lookup.target

[Service]
Type=forking                    #描述服务类型：后台运行
PIDFile=/run/redis_6379.pid     #指向刚刚继承编号的pid
ExecStart=/usr/local/redis-4.0.14/src/redis-server /usr/local/redis-4.0.14/redis.conf                                 #服务启动时使用什么命令 调用redis-server
ExecStop=/bin/kill -s QUIT $MAINPID 
                                #对指定的命令关闭 $后自动带入pidfile  -s quit是按正常流程关闭
PrivateTmp=true
            
[Install]
WantedBy=multi-user.target         #将radis分配到multi-user.target服务组上[随系统自动启动]
&lt;==========================================================================&gt;
[root@imooc system]#systemctl daemon-reload   对所有redis进行重载

[root@imooc system]#ps -ef | grep redis  
[root@imooc system]#kill -s QUIT #杀死所有redis进程测试能否实现自启动
[root@imooc system]#systemctl start redis
[root@imooc system]#systemctl status redis

https://www.cnblogs.com/niway/p/15346572.html

[root@imooc system]#systemctl stop redis  #停止服务
[root@imooc system]#systemctl enable redis #随着系统启动
[root@imooc system]#systemctl list-unit-files #查看系统中每一个服务命令
[root@imooc system]#systemctl list-unit-files | grep enabled #查看自启动的命令

[root@imooc system]#shutdown -r now   #断开连接
</code></pre>
<h3 id="Linux用户与权限"><a href="#Linux用户与权限" class="headerlink" title="Linux用户与权限"></a>Linux用户与权限</h3><h5 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h5><ul>
<li>Linux是多用户多任务系统，包含两个概念：<strong>用户</strong>与<strong>用户组</strong></li>
<li>用户与账户是同一概念，用于登录系统与区分资源权限</li>
<li>用户让系统变的更安全，同时也保护了用户的个人数字资产</li>
</ul>
<h5 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h5><ul>
<li>用户组就是将用户分组，隶属用户自动拥有组权限</li>
<li>一个用户可隶属于多个组，用户可任意切换当前组</li>
<li>用户组的出现让用户权限管理变更轻松</li>
</ul>
<h5 id="用户与用户组的常用命令"><a href="#用户与用户组的常用命令" class="headerlink" title="用户与用户组的常用命令"></a>用户与用户组的常用命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>useradd</td>
<td>创建新用户</td>
</tr>
<tr>
<td>passwd</td>
<td>修改密码</td>
</tr>
<tr>
<td>usermod</td>
<td>修改用户信息&#x2F;分配组 (覆盖原组)</td>
</tr>
<tr>
<td>groupadd</td>
<td>创建新的用户组</td>
</tr>
<tr>
<td><strong>chown</strong></td>
<td>更改文件的属主或属组</td>
</tr>
<tr>
<td><strong>chmod</strong></td>
<td>更改文件的访问权限</td>
</tr>
<tr>
<td>newgrp</td>
<td>切换用户当前组</td>
</tr>
</tbody></table>
<h3 id="项目内部文件权限管理实践"><a href="#项目内部文件权限管理实践" class="headerlink" title="项目内部文件权限管理实践"></a>项目内部文件权限管理实践</h3><pre><code class="java">3员工(2个程序员 1个测试员)
[root@imooc imooc]# adduser d1
[root@imooc imooc]# adduser d2
[root@imooc imooc]# adduser t1
[root@imooc imooc]# passwd d1 =&gt; shuangyu1
[root@imooc imooc]# passwd d2 =&gt; shuangyu2
[root@imooc imooc]# passwd t1 =&gt; shuangyu3
[root@imooc imooc]# groupadd developer
[root@imooc imooc]# groupadd testor
[root@imooc imooc]# usermod -g developer d1
[root@imooc imooc]# usermod -g developer d2
[root@imooc imooc]# usermod -g testor t1
在上方点击打开 并且复制3个Centos7 分别改用户名(d1 d2 t1)和密码(shuangyu1/2/3) 
[root@imooc imooc]# cd
[root@imooc ~]# cd /usr/local/share
[root@imooc share]# mkdir dev-document
[root@imooc share]# ll
drwxr-xr-x.  2 root root  28 11月 15 18:37 applications
drwxr-xr-x.  2 root root   6 12月  3 20:36 dev-document
drwxr-xr-x.  2 root root   6 4月  11 2018 info
drwxr-xr-x. 21 root root 243 11月 15 18:25 man
【前方的drwxr-xr-x 含义见图】

[root@imooc share]# chown d1:developer dev-document  更改对应目录文件的属主(由超级管理员交給研发组) d1可以对developer拥有完整的操作权限 developer以外的用户有读取执行权 其他用户 只有执行权
drwxr-xr-x.  2 root root       28 11月 15 18:37 applications
drwxr-xr-x.  2 d1   developer   6 12月  3 20:36 dev-document
drwxr-xr-x.  2 root root        6 4月  11 2018 info
drwxr-xr-x. 21 root root      243 11月 15 18:25 man

[root@imooc share]# chmod 750 dev-document/ 其他用户不允许任何权限
[root@imooc share]# ll
总用量 0
drwxr-xr-x.  2 root root       28 11月 15 18:37 applications
drwxr-x---.  2 d1   developer   6 12月  3 20:36 dev-document
drwxr-xr-x.  2 root root        6 4月  11 2018 info
drwxr-xr-x. 21 root root      243 11月 15 18:25 man

返回到Centos 7 - t1
[t1@imooc ~]$ cd /usr/local/share/dev-document/
-bash: cd: /usr/local/share/dev-document/: 权限不够
返回到Centos 7 - d2
[d2@imooc ~]$ cd /usr/local/share
[d2@imooc share]$ mv dev-document/ doc
mv: 无法将&quot;dev-document/&quot; 移动至&quot;doc&quot;: 权限不够


上方的chmod 750 的意思是 对应下方的表 第一个7是第一个rwx相加之和4+2+1
====================chmod命令====================
★ chmod 750：组用户可读写，其他用户不允许访问 ★        
★ chmod 777：所有用户拥有完整权限 ★
★ chmod 700：只有属主拥有完整权限 ★
====================++++++++====================
d1弄个文档整个公司的所有人都可以使用
[d1@imooc ~]$ cd /usr/local/share/dev-document/
[d1@imooc dev-document]$ vim code.md
[d1@imooc dev-document]$ ll
-rw-r--r--. 1 d1 developer 13 12月  3 20:59 code.md
第一个是d则是文件夹 -则是文件 属主可以对文件读写。组仅仅可以读取。其他人仅仅可以读取
[d1@imooc dev-document]$ chmod 770 code.md
[d1@imooc dev-document]$ ll
总用量 4
-rwxrwx---. 1 d1 developer 13 12月  3 20:59 code.md
d2即可读写
[d2@imooc dev-document]$ vim code.md

如何让d1同时拥有两个组
[root@imooc share]# usermod -G developer,testor d1
[root@imooc share]# groups d1
d1: developer testor

将当前组切换到新的用户组上
[d1@imooc ~]$ newgrp testor
[d1@imooc ~]$ groups
d1：testor developer
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ee7e298b43a3cdebf4f9be2ae0e3f72592adee2/data/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%BB%A3%E7%A0%81%E8%A1%A8.png"></p>
<h3 id="sudo获取超级管理员权限"><a href="#sudo获取超级管理员权限" class="headerlink" title="sudo获取超级管理员权限"></a>sudo获取超级管理员权限</h3><ul>
<li>sudo可以让普通用户拥有超级管理员的执行权限</li>
<li>普通用户要经过超级管理员授权才能使用</li>
<li>授权命令：visudo</li>
</ul>
<pre><code class="java">在root端输入 visudo 并且输入100gg 快速定位到100行
[root@imooc ~]#visudo
## The COMMANDS section may have other options added to it.
##
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
d1        ALL=(ALL)        ALL     #按i进入编辑模式且增加此行
        ↑：ALL任意电脑可以连接    后ALL可以切换其他用户执行命令   后后ALL允许哪些命令
ESC退出模式后输入
[root@imooc imooc]# visudo -c
/etc/sudoers：解析正确


[d1@imooc ~]$ useradd d3    #目前还没有权限
useradd: Permission denied.
useradd：无法锁定 /etc/passwd，请稍后再试。
[d1@imooc ~]$ sudo useradd d3     #以d1的身份給d3一个超级管理员的权限
我们信任您已经从系统管理员那里了解了日常注意事项。
总结起来无外乎这三点：

    #1) 尊重别人的隐私。
    #2) 输入前要先考虑(后果和风险)。
    #3) 权力越大，责任越大。

[sudo] d1 的密码：=》 shuangyu1
[d1@imooc ~]$ sudo passwd d3 
更改用户 d3 的密码 =》 shuangyu33

回到主Centos 7
[root@imooc ~]#visudo
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
d1      ALL=(ALL)       NOPASSWD:ALL
NOPASSWD:ALL意味着做任何命令之前不用输入密码

[d1@imooc ~]$ sudo useradd d4
[d1@imooc ~]$                     #直接不需要输入密码了
</code></pre>
<h3 id="CentOS7防火墙firewall"><a href="#CentOS7防火墙firewall" class="headerlink" title="CentOS7防火墙firewall"></a>CentOS7防火墙firewall</h3><h5 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h5><ul>
<li>防火墙是借助硬件和软件对内外部网络环境的保护措施</li>
<li>CentOS 7基于firewall实现应用层防火墙，CentOS6基于iptables</li>
<li>firewall-cmd是firewall的核心命令</li>
</ul>
<h5 id="对外开放Tomcat"><a href="#对外开放Tomcat" class="headerlink" title="对外开放Tomcat"></a>对外开放Tomcat</h5><pre><code class="java">把apache-tomcat.tar.gz放入/usr/local中 
[root@imooc local]# tar zxvf apache-tomcat-9.0.34.tar.gz
[root@imooc local]# ll
[root@imooc local]# cd apache-tomcat-9.0.34/
[root@imooc apache-tomcat-9.0.34]# cd bin
[root@imooc bin]# ./startup.sh
[root@imooc bin]# ./startup.sh
Using CATALINA_BASE:   /usr/local/apache-tomcat-9.0.34
Using CATALINA_HOME:   /usr/local/apache-tomcat-9.0.34
Using CATALINA_TMPDIR: /usr/local/apache-tomcat-9.0.34/temp
Using JRE_HOME:        /usr
Using CLASSPATH:       /usr/local/apache-tomcat-9.0.34/bin/bootstrap.jar:/usr/local/apache-tomcat-9.0.34/bin/tomcat-juli.jar
Tomcat started.
[root@imooc bin]# netstat -tulpn|grep 8080  #查看端口是否开启
tcp6    0    0 :::8080        :::*         LISTEN      4302/java  
在虚拟机内部去fox浏览器搜索 localhost:8080  就会看到可爱的绿色小猫咪
    
若想在计算机中访问端口 192.168.170.129:8080 则需要关闭虚拟机的防火墙
[root@imooc bin]# firewall-cmd --state   #查看防火墙状态
running
[root@imooc bin]# firewall-cmd --list-ports #查看防火墙放行的端口(空代表无任何放行端口)
[root@imooc bin]# firewall-cmd --zone=public --permanent --add-port=8080/tcp
#### zone防火墙定义的规则区域、产生永久变更、增加端口8080、tcp形式
[root@imooc bin]# firewall-cmd --reload  #进行配置重载

若不需要开放8080端口则需要
[root@imooc bin]# firewall-cmd --zone=public --permanent --remove-port=8080/tcp
[root@imooc bin]# firewall-cmd --reload  #进行配置重载

[root@imooc bin]# firewall-cmd --zone=public --permanent --add-port=8000-9000/tcp 
###放行区域端口
[root@imooc bin]# firewall-cmd --reload  #进行配置重载
</code></pre>
<h3 id="Bash-Shell"><a href="#Bash-Shell" class="headerlink" title="Bash Shell"></a>Bash Shell</h3><ul>
<li>Shell是一个用c语言编写的脚本解释器，是用户通过代码操作Linux的桥梁</li>
<li>Shell脚本描述要执行的任务，完成系列复杂操作，文件通常以**.sh**后缀</li>
<li>Shell脚本通过Shell解释器执行，按解释器分类分为多种类型</li>
</ul>
<h3 id="Linux-Shell分类"><a href="#Linux-Shell分类" class="headerlink" title="Linux Shell分类"></a>Linux Shell分类</h3><table>
<thead>
<tr>
<th>Shell种类</th>
<th>Shell解释器</th>
</tr>
</thead>
<tbody><tr>
<td>Bourne Shell</td>
<td>&#x2F;usr&#x2F;bin&#x2F;sh 或 &#x2F;bin&#x2F;sh</td>
</tr>
<tr>
<td><strong>Boourne Again Shell</strong></td>
<td><strong>&#x2F;bin&#x2F;bash(默认)</strong></td>
</tr>
<tr>
<td>C Shell</td>
<td>&#x2F;usr&#x2F;bin&#x2F;csh</td>
</tr>
<tr>
<td>K Shell</td>
<td>&#x2F;usr&#x2F;bin&#x2F;ksh</td>
</tr>
<tr>
<td>Shell for Root</td>
<td>&#x2F;sbin&#x2F;sh</td>
</tr>
</tbody></table>
<h5 id="一键发布Tomcat应用程序"><a href="#一键发布Tomcat应用程序" class="headerlink" title="一键发布Tomcat应用程序"></a>一键发布Tomcat应用程序</h5><pre><code class="java">编写shall脚本
[root@imooc local]# vim deploy_tomcat.sh
======================================================================
echo &quot;准备下载Tomcat9&quot;
wget https://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.34/bin/apache-tomcat-9.0.34.tar.gz
echo &quot;正在解压缩Tomcat9&quot;
tar zxf apache-tomcat-9.0.34.tar,gz
echo &quot;防火墙开放8080端口&quot;
firewall-cmd --zone=public --permanent --add-port=8080/tcp
firewall-cmd --reload
echo &quot;启动Tomcat&quot;
cd ./apache-tomcat-9.0.34/bin
./startup.sh
======================================================================
[root@imooc local]# ./deploy_tomcat.sh        开启文件
</code></pre>
<h3 id="综合训练：Linux部署慕课网办公OA"><a href="#综合训练：Linux部署慕课网办公OA" class="headerlink" title="综合训练：Linux部署慕课网办公OA"></a>综合训练：Linux部署慕课网办公OA</h3><h5 id="部署架构：Chrome-Tomcat-Web服务器-MySQL服务器-【中间通过网络通信】"><a href="#部署架构：Chrome-Tomcat-Web服务器-MySQL服务器-【中间通过网络通信】" class="headerlink" title="部署架构：Chrome + Tomcat Web服务器 + MySQL服务器 【中间通过网络通信】"></a>部署架构：Chrome + Tomcat Web服务器 + MySQL服务器 【中间通过网络通信】</h5><pre><code class="java">重新安装CentOS 7-DB【最小值安装】
[root@localhost ~]# yum install -y net-tools
CentOS 7-DB        ifconfig ==》 192.168.170.131    账户：centos-db 密码：panchunyao123
CentOS 7-WEB    ifconfig ==》 192.168.170.133    账户：centos-web 密码：panchunyao123
DB按照MySQL
WEB按照Tomcat
</code></pre>
<h3 id="CentOS安装MySQL-8"><a href="#CentOS安装MySQL-8" class="headerlink" title="CentOS安装MySQL 8"></a>CentOS安装MySQL 8</h3><pre><code class="java">查找有没有mysql安装包
[centos-db@localhost ~]$ yum search mysql-community
去官网找到Linux版的 右键复制链接地址
[root@localhost ~]# wget https://dev.mysql.com/get/mysql80-community-release-el7-11.noarch.rpm
bash: wget: command not found
卧槽 wegt不存在，那就按装wget
[root@localhost ~]# yum install -y wget
[root@localhost mysql]# ll
total 16
-rw-r--r--. 1 root root 14064 Oct 24 07:44 mysql80-community-release-el7-11.noarch.rpm

[root@localhost mysql]# yum localinstall -y mysql80-community-release-el7- 11.noarch.rpm     #自动安装mysql源
[root@localhost mysql]# yum search mysql-comm #此时查找一下就会出现大量mysql组件
[root@localhost mysql]# yum install -y mysql-community-server #安装mysql&#123;在欧美很慢&#125;
ctrl+c 停止安装
[root@localhost mysql]# cd /var/cache/yum/x86_64/7/mysql80-community/packages/
#yum下载的缓存路径 在网上下载好后Linux版的MySQL后 进入

[root@localhost mysql80-community]  /var/cache/yum/x86_64/7/mysql80-community
用命令更改文件夹权限：chmod 777 test01（需要赋予权限的文件夹）
之后将解压缩的MySQL拖进去

注意：如果直接下载 yum localinstall mysql80-community-release-el7- 11.noarch.rpm  的话会有很多依赖不会被自动下载，最保准的就是去网上下载Linux版本的MySQL再利用Xftp拖进去

[root@localhost package]# yum install -y mysql-community-server 【最快最省事 自动下载&amp;安装依赖】
[root@localhost package]# systemctl start mysqld
[root@localhost package]# netstat -tulpn
tcp6    0    0    :::3306        :::*        LISTEM        21850/mysqld
[root@localhost package]# systemctl status mysqld     #查看myql启动状态
[root@localhost package]# systemctl enable mysqld     #设置开机自启动
</code></pre>
<h3 id="初始化MySQL-CentOS-7-DB"><a href="#初始化MySQL-CentOS-7-DB" class="headerlink" title="初始化MySQL[CentOS 7-DB]"></a>初始化MySQL[CentOS 7-DB]</h3><pre><code class="java">查看mysql日志寻找mysql密码
[root@localhost package]# vi /var/log/mysqld.log
root@localhost: Y,#)foTQ,7js
[root@localhost package]# mysql -uroot -p
修改密码！
mysql&gt; alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;Panchunyao123!&#39;
mysql&gt; use mysql
mysql&gt; select host,user from user;
mysql&gt; update user set host=&#39;%&#39; where user=&#39;root&#39;; #任意设备都可使用%连接到mysql服务器
host: %            user: root
mysql&gt; flush privileges; #使修改的权限数据生效
mysql&gt; exit

下一步是放行防火墙3306端口
[root@localhost package]# firewall-cmd --zone=public --permanent --add-port=3306/tcp
[root@localhost package]# firewall-cmd --reload

去电脑端的Navicat Premium 连接新数据库
MySQL-新建连接
连接名：centos-db
主机：192.168.170.131
端口：3306
用户名：root
密码：Panchunyao123！

新建数据库 imooc-oa  utf8mb4 执行sql文件 imooc-oa.sql
</code></pre>
<h3 id="部署配置Web应用服务器"><a href="#部署配置Web应用服务器" class="headerlink" title="部署配置Web应用服务器"></a>部署配置Web应用服务器</h3><pre><code class="java">CentOS 7-DB        ifconfig ==》 192.168.170.131    账户：centos-db 密码：panchunyao123
CentOS 7-WEB    ifconfig ==》 192.168.170.133    账户：centos-web 密码：panchunyao123
</code></pre>
<pre><code class="java">[root@localhost ~]# yum search jdk  #查看仓库中包含哪些jdk
[root@localhost ~]# yum install -y java-1.8.0-openjdk    #安装jdk以及所有依赖
[root@localhost ~]# java -version
[root@localhost ~]# which java      #查看安装到哪个地方
/bin/java
安装tomcat
[root@localhost ~]# cd /usr
用命令更改文件夹权限：chmod 777 local
[root@localhost usr]# cd local
打开Xftp将apache-tomcat-9.0.34.tar.gz 传入到local内
[root@localhost local]# tar zxf apache-tomcat-9.0.34.tar.gz     #对压缩包进行解压
将素材资料里的imooc_oa.war拖入Xftp的local中 之后进行解压
[root@localhost local]# tar zxf imooc_oa.war 
需要将imooc_oa复制到tomcat9的webapps下才可生效
[root@localhost local]# mv imooc_oa ./apache-tomcat-9.0.34/webapps/
[root@localhost local]# cd apache-tomcat-9.0.34/webapps/
[root@localhost webapps]# vim ./imooc_oa/WEB-INF/classes/mybatis-config.xml
#远程对服务器配置连接数据库服务器
-bash: vim: 未找到命令 需要先安装vim
[root@localhost webapps]# yum install -y vim-common
[root@localhost webapps]# yum install -y vim-enhanced  #再安装一个增强的vim包
[root@localhost webapps]# vim ./imooc_oa/WEB-INF/classes/mybatis-config.xml
输入/root 进行全文查找 修改&lt;property 中的value=&quot;jdbc:mysql:...&quot; loacalhost改为自己网络ip：192.168.170.131
再修改一下下面的password：  Panchunyao123！
:wq
[root@localhost webapps]# cd ..
[root@localhost apache-tomcat-9.0.34]# vim ./conf/server.xml
/8080 搜索 &lt;Connector port=&quot;80&quot; 只保留80端口
/Host&gt; 找到最下面 在上面一行加入
&lt;Context path=&quot;/&quot; docaBacs=&quot;imooc_oa&quot;/&gt; #将imooc_oa目录映射到根路径&quot;/&quot;
:wq

之后启动tomcat
[root@localhost apache-tomcat-9.0.34]# ./bin/startup.sh
[root@localhost apache-tomcat-9.0.34]# netstat -tulpn  #查看进程
tcp6        0        0 :::80        :::*        LISTEN        20303/java

用防火墙将80端口对外进行暴露
[root@localhost apache-tomcat-9.0.34]# firewall-cmd --zone=public --permanent --add-port=80/tcp
[root@localhost apache-tomcat-9.0.34]# firewall-cmd --reload  #重载

回到电脑浏览器输入：http://192.168.170.133/login.html

数据库安全【根据3306端口可以查到数据库根源】：对指定IP端口进行放行
[root@localhost ~]# firewall-cmd --zone=public --permanent --remove-port=3306/tcp
[root@localhost ~]# firewall-cmd --reload  #重载
[root@localhost ~]# firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.170.133&quot; port protocol=&quot;tcp&quot; port=&quot;3306&quot; accept &quot;    #-rich-rule防火墙内部规则强大的定义表达式
[root@localhost ~]# firewall-cmd --reload  #重载
[root@localhost apache-tomcat-9.0.34]# ./bin/shutdown.sh
[root@localhost apache-tomcat-9.0.34]# ./bin/startup.sh
</code></pre>
<hr>
<hr>
<h1 id="Redis-内存-非常快-数据库、非关系型数据库"><a href="#Redis-内存-非常快-数据库、非关系型数据库" class="headerlink" title="Redis (内存[非常快]数据库、非关系型数据库)"></a>Redis (内存<del>[非常快]</del>数据库、非关系型数据库)</h1><ul>
<li>Redis是<strong>Key-Value型</strong>NoSQL数据库</li>
<li><strong>Redis</strong>将数据<strong>存储在内存(RAM)中</strong>，同时也能<strong>持久化到磁盘</strong></li>
<li>Redis常用于缓存，利用内存的高效提高程序的处理速度</li>
</ul>
<h5 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h5><ul>
<li>速度快</li>
<li>广泛的语言支持</li>
<li>持久化</li>
<li>多种数据结构</li>
<li>主从复制(多台Redis可以保持数据同步)</li>
<li>分布式与高可用(7×24小时服务 淘宝&#x2F;京东) 全国各地多个主机 降低网络传输时间</li>
</ul>
<h3 id="Redis的安装与启动"><a href="#Redis的安装与启动" class="headerlink" title="Redis的安装与启动"></a>Redis的安装与启动</h3><ul>
<li>在Linux系统中安装redis (<a target="_blank" rel="noopener" href="http://redis.io/download">http://redis.io/download</a>)</li>
</ul>
<pre><code class="java">$ wegt http://download.redis.io/releases/redis-5.0.2.tar.gz
$ tar xzf redis-5.0.2.tar.gz
$ cd redis-5.0.2
$ make
</code></pre>
<pre><code class="java">[root@imooc imooc]# cd /usr/local
[root@imooc local]# ll
[root@imooc local]# mkdir redis
[root@imooc local]# ll
[root@imooc local]# cd redic
[root@imooc redic]# yum install gcc
[root@imooc redic]# wegt http://download.redis.io/releases/redis-5.0.2.tar.gz
[root@imooc redis]# tar xzf redis-5.0.2.tar.gz
[root@imooc redis]# cd redis-5.0.2
[root@imooc redis-5.0.2]# make
Hint: It&#39;s a good idea to run &#39;make test&#39; ;)   安装成功
[root@imooc redis-5.0.2]# ll  #找redis.conf
总用量 240
-rw-rw-r--.  1 root root 85327 11月 22 2018 00-RELEASENOTES
-rw-rw-r--.  1 root root    53 11月 22 2018 BUGS
-rw-rw-r--.  1 root root  1894 11月 22 2018 CONTRIBUTING
-rw-rw-r--.  1 root root  1487 11月 22 2018 COPYING
drwxrwxr-x.  6 root root   192 12月  5 11:47 deps
-rw-rw-r--.  1 root root    11 11月 22 2018 INSTALL
-rw-rw-r--.  1 root root   151 11月 22 2018 Makefile
-rw-rw-r--.  1 root root  4223 11月 22 2018 MANIFESTO
-rw-rw-r--.  1 root root 20555 11月 22 2018 README.md
-rw-rw-r--.  1 root root 62155 11月 22 2018 redis.conf
-rwxrwxr-x.  1 root root   275 11月 22 2018 runtest
-rwxrwxr-x.  1 root root   280 11月 22 2018 runtest-cluster
-rwxrwxr-x.  1 root root   281 11月 22 2018 runtest-sentinel
-rw-rw-r--.  1 root root  9710 11月 22 2018 sentinel.conf
drwxrwxr-x.  3 root root  8192 12月  5 11:49 src
drwxrwxr-x. 10 root root   167 11月 22 2018 tests
drwxrwxr-x.  8 root root  4096 11月 22 2018 utils
[root@imooc redis-5.0.2]# cd src
[root@imooc src]# ll     #找redis- server启动目录

[root@imooc src]#cd ..
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf
</code></pre>
<pre><code class="java">若端口被占用

找到redis-server的进程，然后杀死对应的进程，然后重新启动redis

&gt;&gt;&gt; ps -ef | grep -i redis
root      3585 19590  0 10:36 pts/20   00:00:00 redis-server *:6379
user      3684  3663  0 10:38 pts/21   00:00:00 grep --color=auto -i redis
进程3585是redis的服务，

kill -9 3585
</code></pre>
<ul>
<li>在Windows系统安装Redis</li>
</ul>
<pre><code class="java">https://github.com/microsoftarchive/redis/releases 下载后解压
打开cmd
C:\Users\Pluminary&gt;d:
D:\&gt;cd Redis-x64-3.0.504
D:\Redis-x64-3.0.504&gt;dir
D:\Redis-x64-3.0.504&gt;redis-server redis.windows.conf
                _._
           _.-``__ &#39;&#39;-._
      _.-``    `.  `_.  &#39;&#39;-._           Redis 3.0.504 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ &#39;&#39;-._
 (    &#39;      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|&#39;` _.-&#39;|     Port: 6379
 |    `-._   `._    /     _.-&#39;    |     PID: 22828
  `-._    `-._  `-./  _.-&#39;    _.-&#39;
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
 |    `-._`-._        _.-&#39;_.-&#39;    |           http://redis.io
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
 |    `-._`-._        _.-&#39;_.-&#39;    |
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
      `-._    `-.__.-&#39;    _.-&#39;
          `-._        _.-&#39;
              `-.__.-&#39;
</code></pre>
<h3 id="Redis的常用基本配置"><a href="#Redis的常用基本配置" class="headerlink" title="Redis的常用基本配置"></a>Redis的常用基本配置</h3><table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">daemonize</td>
<td align="center">daemonize yes</td>
<td align="center">是否启用后台运行, 默认no</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">port 6379</td>
<td align="center">设置端口号, 默认6379</td>
</tr>
<tr>
<td align="center">logfile</td>
<td align="center">logfile 日志文件</td>
<td align="center">设置日志文件</td>
</tr>
<tr>
<td align="center">databases</td>
<td align="center">databases 255</td>
<td align="center">设置redis数据库总量</td>
</tr>
<tr>
<td align="center">dir</td>
<td align="center">dir 数据文件目录</td>
<td align="center">设置数据文件存储目录</td>
</tr>
<tr>
<td align="center">requirepass</td>
<td align="center">requirepass 12345</td>
<td align="center">设置使用密码</td>
</tr>
</tbody></table>
<h5 id="守护进程方式启动Redis"><a href="#守护进程方式启动Redis" class="headerlink" title="守护进程方式启动Redis"></a>守护进程方式启动Redis</h5><pre><code class="java">[root@imooc ~]# cd /usr/local/redis/redis-5.0.2/
[root@imooc redis-5.0.2]# vim redis.conf    #打开后台启动
136行 daemonize no 改成 daemonize yes
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf
关闭终端打开全新终端
[root@imooc ~]# netstat -tulpn
tcp        0        0        127.0.0.1:6379 ...     6338/./src/redis-se

如果关闭
kill -9 6338
</code></pre>
<h5 id="redis使用"><a href="#redis使用" class="headerlink" title="redis使用"></a>redis使用</h5><pre><code class="java">[root@imooc redis-5.0.2]# ./src/redis-cli    #执行redis内置指令
127.0.0.1:6379&gt; ping        #启动成功
PONG
127.0.0.1:6379&gt; exit        #退出
[root@imooc redis-5.0.2]# ./src/redis-cli shutdown  #更加安全的关闭redis

报错(添加log文件 将redis命令行的结果打印到log中)
https://blog.csdn.net/qq_46127735/article/details/113933690


为了保护安全将port从6379改为6380
[root@imooc redis-5.0.2]# vim redis.conf
/port 寻找92行
port 6380
[root@imooc redis-5.0.2]# ./src/redis-cli -p 6380
127.0.0.1:6380&gt; select 0        #当前使用第几号数据库
127.0.0.1:6380&gt; select 15
[root@imooc redis-5.0.2]# vim redis.conf
在186行 可以改变数据连接数量
databases 15→255
    
[root@imooc redis-5.0.2]# vim redis.conf
507行注释去掉 此行是输入密码
requirepass panchunyao123
再次登录就 
127.0.0.1:6380&gt; auth panchunyao123

redis中有一个dump.rdb 全量备份 同时备份到磁盘中
</code></pre>
<h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">select</td>
<td align="center">select 0</td>
<td align="center">选择0号数据库</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">set name lily</td>
<td align="center">设置key&#x3D;name, value&#x3D;lily</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">get hello</td>
<td align="center">获得key&#x3D;hello结果</td>
</tr>
<tr>
<td align="center">keys</td>
<td align="center">keys he*</td>
<td align="center">根据Pattern表达查询符合条件的key</td>
</tr>
<tr>
<td align="center">dbsize</td>
<td align="center">dbsize</td>
<td align="center">返回key的总数</td>
</tr>
<tr>
<td align="center">exists</td>
<td align="center">exists a</td>
<td align="center">检查key&#x3D;a是否存在</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">del a</td>
<td align="center">删除key&#x3D;a的数据</td>
</tr>
<tr>
<td align="center">expire</td>
<td align="center">expire hello 20</td>
<td align="center">设置key&#x3D;hello 20秒后过期</td>
</tr>
<tr>
<td align="center">ttl</td>
<td align="center">ttl hello</td>
<td align="center">查看key&#x3D;a的过期剩余时间</td>
</tr>
</tbody></table>
<pre><code class="java">[root@imooc redis-5.0.2]# ./src/redids-cli -p 6380   #重新连接到端口
127.0.0.1:6380&gt; select 10
127.0.0.1:6380[10]&gt; set name lily   #十号数据库中增加key=name value=lily
127.0.0.1:6380[10]&gt; get name  =&gt; &quot;lily&quot;
127.0.0.1:6380[10]&gt; select 9
127.0.0.1:6380[9]&gt; get name =&gt;(nil)
127.0.0.1:6380[9]&gt; set name kitty
127.0.0.1:6380[9]&gt; get name =&gt;&quot;kitty&quot;
127.0.0.1:6380[9]&gt; keys *  #列举表达式能匹配的所有key
127.0.0.1:6380[9]&gt; set sex male
127.0.0.1:6380[9]&gt; keys *
127.0.0.1:6380[9]&gt; keys n* #模糊匹配表达式
127.0.0.1:6380[9]&gt; dbsize  #显示当前数据库的总量 =&gt; 2个 =&gt; &quot;name&quot;  &quot;sex&quot;
127.0.0.1:6380[9]&gt; del sex #删除 =&gt; 1 返回0则不存在
127.0.0.1:6380[9]&gt; expire name 30   #生效开始之后30秒存活时间
127.0.0.1:6380[9]&gt; ttl name #查看存活时间 时间一到自动清除     keys*中无name数据
</code></pre>
<h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a><span style = "color:red">Redis数据类型</span></h3><ul>
<li><h5 id="String-字符串类型-String最大512mb-建议单个kv不超过100kb"><a href="#String-字符串类型-String最大512mb-建议单个kv不超过100kb" class="headerlink" title="String - 字符串类型 (String最大512mb 建议单个kv不超过100kb)"></a>String - 字符串类型 (<u>String最大512mb 建议单个kv不超过100kb</u>)</h5></li>
</ul>
<table>
<thead>
<tr>
<th align="center">键</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">Lily</td>
</tr>
<tr>
<td align="center">counter</td>
<td align="center">3321</td>
</tr>
<tr>
<td align="center">sn</td>
<td align="center">7361-7749</td>
</tr>
</tbody></table>
<h6 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h6><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get</td>
<td align="center">get hello</td>
<td align="center">获取key&#x3D;hello结果</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">set hello world</td>
<td align="center">设置key&#x3D;hello, value&#x3D;hello</td>
</tr>
<tr>
<td align="center">mset mget</td>
<td align="center">mset hello world java best<br />mget hello java</td>
<td align="center">一次性设置或者获取多个值</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">del hello</td>
<td align="center">删除key&#x3D;hello</td>
</tr>
<tr>
<td align="center">incr&#x2F;decr</td>
<td align="center">incr count<br/>decr count</td>
<td align="center">key值自增&#x2F;自减1</td>
</tr>
<tr>
<td align="center">incrby&#x2F;decrby</td>
<td align="center">incrby count 99<br/>decrby count 99</td>
<td align="center">自增自减指定步长</td>
</tr>
</tbody></table>
<pre><code class="java">127.0.0.1:6380[9]&gt; select 10 
127.0.0.1:6380[10]&gt; set name lily
127.0.0.1:6380[10]&gt; set sex 18
127.0.0.1:6380[10]&gt; set birthday 1998-03-11
127.0.0.1:6380[10]&gt; keys *
1) &quot;birthday&quot;  2)&quot;name&quot;  3)&quot;sex&quot;
127.0.0.1:6380[10]&gt; mset name1 kitty sex1 20 birthday1 2001-03-02 #一次性设置多个键值对
127.0.0.1:6380[10]&gt; mget name sex birthday  #一次性提取多个
127.0.0.1:6380[10]&gt; clear  #当前屏幕清空
127.0.0.1:6380[10]&gt; incr age  #将指定的数字自增+1
127.0.0.1:6380[10]&gt; set age 20
127.0.0.1:6380[10]&gt; keys age =&gt; &quot;age&quot;
127.0.0.1:6380[10]&gt; get age =&gt; &quot;20&quot;
127.0.0.1:6380[10]&gt; incr age =&gt; (integer) 22 #不可以自增字符串噢
127.0.0.1:6380[10]&gt; decrby age 3 #对指定的key自减 =&gt; 20-3=17
127.0.0.1:6380[10]&gt; del age #删除某个key
</code></pre>
<ul>
<li><h5 id="Hash-Hash类型"><a href="#Hash-Hash类型" class="headerlink" title="Hash - Hash类型"></a>Hash - Hash类型</h5></li>
</ul>
<h5 id="Hash类型用于存储结构化数据"><a href="#Hash类型用于存储结构化数据" class="headerlink" title="Hash类型用于存储结构化数据"></a>Hash类型用于存储结构化数据</h5><p>↓↓↓ ↓↓↓ key &#x3D; <strong>emp:1</strong> ↓↓↓ ↓↓↓ 在value中又产生一个键值对[下面全是单个的emp:1的key值]</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">smith</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>age</strong></td>
<td align="center">35</td>
</tr>
<tr>
<td align="center"><strong>birthday</strong></td>
<td align="center">2001-02-02</td>
</tr>
<tr>
<td align="center"><strong>height</strong></td>
<td align="center">178</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hget</td>
<td align="center">hget emp:1 age</td>
<td align="center">获取hash中key&#x3D;age的值</td>
</tr>
<tr>
<td align="center">hset</td>
<td align="center">hset emp:1 age 23</td>
<td align="center">设置hash中age&#x3D;23</td>
</tr>
<tr>
<td align="center">hmset<br />hmget<br />hgetall<br /></td>
<td align="center">hmset emp:1 age 30 name kaka<br />hmget emp:1 age name<br />hgetall emp:1<br /></td>
<td align="center">设置hash多个值<br />获取hash多个值<br />获取hash所有值<br /></td>
</tr>
<tr>
<td align="center">hdel</td>
<td align="center">hdel emp:1 age</td>
<td align="center">删除emp:1的age</td>
</tr>
<tr>
<td align="center">hexists</td>
<td align="center">hexists emp:1 name</td>
<td align="center">检查是否存在</td>
</tr>
<tr>
<td align="center">hlen</td>
<td align="center">hlen emp:1</td>
<td align="center">获取指定长度</td>
</tr>
</tbody></table>
<pre><code class="java">127.0.0.1:6380[1]&gt; hset emp:1 name zhangsan       #设置某个hash值
127.0.0.1:6380[1]&gt; hset emp:1 age 35
127.0.0.1:6380[1]&gt; hset emp:1 birthday 2001-02-02
127.0.0.1:6380[1]&gt; hset emp:1 height 178
127.0.0.1:6380[1]&gt; keys * =&gt; &quot;emp:1&quot;
127.0.0.1:6380[1]&gt; hget emp:1 name    #获取指定hash值 =&gt;&quot;zhangsan&quot;
127.0.0.1:6380[1]&gt; hget emp:1 age =&gt; &quot;35&quot;
127.0.0.1:6380[1]&gt; hgetall emp:1 #提取所有的数据 

127.0.0.1:6380[1]&gt; hmset emp:2 name lisa age 23 birthday 1990-05-03 height 165
127.0.0.1:6380[1]&gt; hgetall emp:2
127.0.0.1:6380[1]&gt; del emp:2     #删除整个对象
127.0.0.1:6380[1]&gt; hlen emp:1 =&gt; (integer) 4     #代表在emp:1中有4个属性
127.0.0.1:6380[1]&gt; hgetall emp:1 
127.0.0.1:6380[1]&gt; hexists emp:1 name  #判断属性是否存在 是则返回1
</code></pre>
<ul>
<li><h5 id="List-列表类型"><a href="#List-列表类型" class="headerlink" title="List - 列表类型"></a>List - 列表类型</h5><ul>
<li>List列表就是一系列字符串的”数组”, 按插入顺序排序</li>
<li>List列表最大长度为2的32次方-1, 可以包含40亿个元素</li>
</ul>
<h6 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h6><ul>
<li><strong>rpush listkey c b a</strong> - 右侧插入 <u>先c后b最后a</u></li>
<li><strong>lpush listkey f e d</strong> - 左侧插入 <u>先f后e最后d</u>         <em>d e f c b a</em></li>
<li><strong>rpop listkey</strong> - 右侧弹出          <em>d e f c b</em></li>
<li><strong>lpop listkey</strong> -左侧弹出             <em>e f c b</em></li>
</ul>
</li>
</ul>
<pre><code class="java">127.0.0.1:6380[1]&gt; rpush list c =&gt;(integer) 1
127.0.0.1:6380[1]&gt; lrange list 0 -1  #输出指定列表起始到结束范围内的所有元素 [开始 末尾]
127.0.0.1:6380[1]&gt; rpush list b a =&gt;(integer) 3
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;c&quot; &quot;b&quot; &quot;a&quot;
127.0.0.1:6380[1]&gt; lpush list f      #在左侧插入
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;f&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot;
127.0.0.1:6380[1]&gt; lpush list b a
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;a&quot; &quot;b&quot; &quot;f&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot;
127.0.0.1:6380[1]&gt; rpop list =&gt; &quot;a&quot;
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;a&quot; &quot;b&quot; &quot;f&quot; &quot;c&quot; &quot;b&quot;
127.0.0.1:6380[1]&gt; lpop list =&gt; &quot;b&quot; &quot;f&quot; &quot;c&quot; &quot;b&quot;
</code></pre>
<ul>
<li><h5 id="Set-集合类型-Zset-有序集合类型"><a href="#Set-集合类型-Zset-有序集合类型" class="headerlink" title="Set - 集合类型      Zset - 有序集合类型"></a>Set - 集合类型      Zset - 有序集合类型</h5><ul>
<li>Set集合是字符串的无序集合, 集合成员是唯一的</li>
<li>Zset集合是字符串的有序集合, 集合成员是唯一的</li>
</ul>
</li>
</ul>
<pre><code class="java">Set集合
127.0.0.1:6380[1]&gt; sadd set1 a =&gt; 1
127.0.0.1:6380[1]&gt; keys * =&gt; &quot;set1&quot; &quot;emp:1&quot; &quot;list&quot;
127.0.0.1:6380[1]&gt; sadd set1 b =&gt; &quot;b&quot;
127.0.0.1:6380[1]&gt; sadd set1 c =&gt; &quot;c&quot;
127.0.0.1:6380[1]&gt; sadd set1 d =&gt; &quot;d&quot;
127.0.0.1:6380[1]&gt; sadd set1 e =&gt; &quot;e&quot;
127.0.0.1:6380[1]&gt; sadd set1 f =&gt; &quot;f&quot;
127.0.0.1:6380[1]&gt; smembers set1 =&gt; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;e&quot;  #字母顺序打乱 乱序

127.0.0.1:6380[1]&gt; sadd set2 d     #创建一个set2与set1有重叠
127.0.0.1:6380[1]&gt; sadd set2 e
127.0.0.1:6380[1]&gt; sadd set2 f
127.0.0.1:6380[1]&gt; sadd set2 h
127.0.0.1:6380[1]&gt; sadd set2 g
127.0.0.1:6380[1]&gt; smembers set2 =&gt; &quot;d&quot; &quot;h&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot;
127.0.0.1:6380[1]&gt; sinter set1 set2 =&gt;     &quot;d&quot; &quot;f&quot; &quot;e&quot;     #取其中的交集
127.0.0.1:6380[1]&gt; sunion set1 set2 =&gt;     &quot;d&quot; &quot;g&quot; &quot;b&quot; &quot;c&quot; &quot;h&quot; &quot;f&quot; &quot;e&quot; &quot;a&quot;    #取其中的并集[取并集并去除重复元素]
127.0.0.1:6380[1]&gt; sdiff set1 set2 #寻找叉集(在set1有 在set2中没有[两个部分交集排除在外])
=&gt; &quot;a&quot; &quot;c&quot; &quot;b&quot;
127.0.0.1:6380[1]&gt; sdiff set2 set1 =&gt; &quot;h&quot; &quot;g&quot;
</code></pre>
<pre><code class="java">Zset集合
127.0.0.1:6380[1]&gt; zadd zset1 100 a =&gt;1
127.0.0.1:6380[1]&gt; zadd zset1 101 b =&gt; 1
127.0.0.1:6380[1]&gt; zrange zset1 0 -1 =&gt; &quot;a&quot; &quot;b&quot; #按照顺序排序
127.0.0.1:6380[1]&gt; zadd zset1 99 c =&gt; 1  
127.0.0.1:6380[1]&gt; zrange zset1 0 -1 =&gt; &quot;c&quot; &quot;a&quot; &quot;b&quot; #按照分数升序排列
127.0.0.1:6380[1]&gt; zadd zset1 102 d
127.0.0.1:6380[1]&gt; zadd zset1 103 e
127.0.0.1:6380[1]&gt; zadd zset1 104 f
127.0.0.1:6380[1]&gt; zrange zset1 0 -1 withscores #升序打印分数
127.0.0.1:6380[1]&gt; zrangebyscore zset1 100 103 #符合score从100-103的名字
</code></pre>
<h3 id="Java客户端-Jedis"><a href="#Java客户端-Jedis" class="headerlink" title="Java客户端-Jedis"></a>Java客户端-Jedis</h3><ul>
<li>Jedis是Java语言开发的Redis客户端工具包</li>
<li>Jedis只是对Redis命令的封装, 掌握Redis命令便可轻易上手</li>
</ul>
<h6 id="允许远程访问需要改文件"><a href="#允许远程访问需要改文件" class="headerlink" title="允许远程访问需要改文件"></a>允许远程访问需要改文件</h6><pre><code class="java">[root@imooc ~]# cd /usr/local/redis/redis-5.0.2/
[root@imooc redis-5.0.2]# vim redis.conf
第88行 protected-mode yes 将yes设置为no
第69行 bind 127.0.0.1 改为 bind 0.0.0.0     #四个0代表所有ip主机都可以访问进来【真正开发时要用特定的ip号】
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf
[root@imooc redis-5.0.2]# netstat -tulpn | grep redis
[root@imooc redis-5.0.2]# firewall-cmd --zone=public --add-port=6379/tcp --permanent
[root@imooc redis-5.0.2]# firewall-cmd --reload
[root@imooc redis-5.0.2]# ifconfig =&gt; IP地址: 192.168.170.135

[root@imooc redis-5.0.2]# ./src/redis-cli -p 6379
</code></pre>
<p>报错连接超时：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41830655/article/details/106114663">Java远程连接Redis时出现: java.net.SocketTimeoutException: connect timed out的解决办法-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zinbin/article/details/109336852">Java连接Redis connection timed out 报错的解决方法_caused by: io.netty.channel.abstractchannel$annota-CSDN博客</a></p>
<pre><code class="java">systemctl start firewalld  #开启防火墙
systemctl enable firewalld.service  #开机自启动防火墙

systemctl stop firewalld.service #关闭防火墙
重启 Redis 服务端
ps -ef|grep redis    #查看 Redis 进程 
kill -s 9 进程号      #杀死 Redis 进程
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf 
</code></pre>
<pre><code class="java">package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.List;

public class JedisTestor &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            jedis.auth(&quot;root&quot;);
            jedis.select(2);
            System.out.println(&quot;Redis连接成功&quot;);
            //字符串
            jedis.set(&quot;sn&quot;, &quot;7781-9938&quot;);
            String sn = jedis.get(&quot;sn&quot;);
            System.out.println(sn);
            jedis.mset(new String[]&#123;&quot;title&quot;, &quot;婴幼儿奶粉&quot;, &quot;num&quot;, &quot;20&quot;&#125;);
            List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot;, &quot;title&quot;, &quot;num&quot;&#125;);
            System.out.println(goods);
            Long num = jedis.incr(&quot;num&quot;);
            System.out.println(num);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">pom.xml【两个jar:    jedis-2.9.0.jar        fastjson-1.2.62.jar】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Jedis_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;2.9.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">[root@imooc redis-5.0.2]# ./src/redis-cli
127.0.0.1:6379&gt; auth root
127.0.0.1:6379&gt; select 2
127.0.0.1:6379[2]&gt; keys * =&gt; &quot;sn&quot;
127.0.0.1:6379[2]&gt; get sn =&gt; &quot;7781-9938&quot;
【此处更换新的java代码再次插入 奶粉...】
------------------------------------------------------------------
jedis.mset(new String[]&#123;&quot;title&quot;, &quot;婴幼儿奶粉&quot;, &quot;num&quot;, &quot;20&quot;&#125;);
List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot;, &quot;title&quot;, &quot;num&quot;&#125;);
------------------------------------------------------------------
127.0.0.1:6379[2]&gt; keys * =&gt; &quot;sn&quot; &quot;num&quot; &quot;title&quot;
127.0.0.1:6379[2]&gt; get num =&gt; 21
127.0.0.1:6379[2]&gt; get title =&gt; \xe5\xa9\xb4\xe5\xb9\xbc\xe5...
</code></pre>
<h3 id="Jedis操作Hash类型"><a href="#Jedis操作Hash类型" class="headerlink" title="Jedis操作Hash类型"></a>Jedis操作Hash类型</h3><pre><code class="java">package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JedisTestor &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            jedis.auth(&quot;root&quot;);
            jedis.select(2);
            System.out.println(&quot;Redis连接成功&quot;);
            //字符串
            jedis.set(&quot;sn&quot;, &quot;7781-9938&quot;);
            String sn = jedis.get(&quot;sn&quot;);
            System.out.println(sn);
            jedis.mset(new String[]&#123;&quot;title&quot;, &quot;婴幼儿奶粉&quot;, &quot;num&quot;, &quot;20&quot;&#125;);
            List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot;, &quot;title&quot;, &quot;num&quot;&#125;);
            System.out.println(goods);
            Long num = jedis.incr(&quot;num&quot;);
            System.out.println(num);

            //Hash
            jedis.hset(&quot;student:3312&quot;, &quot;name&quot;, &quot;张晓明&quot;);
            String name = jedis.hget(&quot;student:3312&quot;, &quot;name&quot;);
            System.out.println(name);

            Map&lt;String,String&gt; studentMap = new HashMap();
            studentMap.put(&quot;name&quot;, &quot;李兰&quot;);
            studentMap.put(&quot;age&quot;, &quot;18&quot;); //所有数据类型都是String
            studentMap.put(&quot;id&quot;, &quot;3313&quot;);
            jedis.hmset(&quot;student:3313&quot;, studentMap);
            Map&lt;String,String&gt; smap = jedis.hgetAll(&quot;student:3313&quot;);
            System.out.println(smap);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;
&#125;

---------------------------------------------------------------
Redis连接成功
7781-9938
[7781-9938, 婴幼儿奶粉, 20]
21
张晓明
&#123;name=李兰, age=18, id=3313&#125;
</code></pre>
<pre><code class="java">127.0.0.1:6380[2]&gt; hgetall student:3313
</code></pre>
<h3 id="Jedis操作List类型"><a href="#Jedis操作List类型" class="headerlink" title="Jedis操作List类型"></a>Jedis操作List类型</h3><pre><code class="java">package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JedisTestor &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123; //List
            jedis.del(&quot;letter&quot;); //要先删除不然lpop、rpop的时候会追加数据
            jedis.rpush(&quot;letter&quot;, new String[]&#123;&quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;);
            jedis.lpush(&quot;letter&quot;, new String[]&#123;&quot;c&quot;, &quot;b&quot;, &quot;a&quot;&#125;);
            List&lt;String&gt; letter = jedis.lrange(&quot;letter&quot;, 0, -1);
            jedis.lpop(&quot;letter&quot;);
            jedis.rpop(&quot;letter&quot;);
            letter = jedis.lrange(&quot;letter&quot;, 0, -1);
            System.out.println(letter);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;
&#125;
----————--——----------------------------------------------------
[a, b, c, d, e, f] =&gt; [b, c, d, e]
</code></pre>
<h3 id="利用Jedis缓存数据-放在内存处理-速度快"><a href="#利用Jedis缓存数据-放在内存处理-速度快" class="headerlink" title="利用Jedis缓存数据 [放在内存处理 速度快]"></a>利用Jedis缓存数据 [放在内存处理 速度快]</h3><h6 id="缓存数据：资料不要太大-信息比较稳定更新次数较低"><a href="#缓存数据：资料不要太大-信息比较稳定更新次数较低" class="headerlink" title="缓存数据：资料不要太大 信息比较稳定更新次数较低"></a>缓存数据：资料不要太大 信息比较稳定更新次数较低</h6><pre><code class="java">Goods.java
public class Goods &#123;
    private Integer goodsId;
    private String goodsName;
    private String description;
    private Float price;
    Getter + Setter + Constructor[空+全]
&#125;
</code></pre>
<pre><code class="java">CacheSample.java
package com.imooc.jedis;

import com.alibaba.fastjson.JSON;
import redis.clients.jedis.Jedis;

import java.util.ArrayList;
import java.util.List;

public class CacheSample &#123;
    public CacheSample()&#123; //数据初始化
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            List&lt;Goods&gt; goodsList = new ArrayList();
            goodsList.add(new Goods(8818,&quot;红富士苹果&quot;,&quot;&quot;,3.5f));
            goodsList.add(new Goods(8819,&quot;赣南脐橙&quot;,&quot;&quot;,5f));
            goodsList.add(new Goods(8820,&quot;进口香蕉&quot;,&quot;&quot;,2f));
            //javabean序列化为json字符串保存到java里
            jedis.auth(&quot;root&quot;);
            jedis.select(3);
            for (Goods goods : goodsList)&#123;
                String json = JSON.toJSONString(goods);
                System.out.println(json);
                String key = &quot;goods:&quot; + goods.getGoodsId();
                jedis.set(key, json); //key + value[序列化为json]
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new CacheSample();
    &#125;
&#125;
________________________________________________________________
&#123;&quot;description&quot;:&quot;&quot;,&quot;goodsId&quot;:8818,&quot;goodsName&quot;:&quot;红富士苹果&quot;,&quot;price&quot;:3.5&#125;
&#123;&quot;description&quot;:&quot;&quot;,&quot;goodsId&quot;:8819,&quot;goodsName&quot;:&quot;赣南脐橙&quot;,&quot;price&quot;:5.0&#125;
&#123;&quot;description&quot;:&quot;&quot;,&quot;goodsId&quot;:8820,&quot;goodsName&quot;:&quot;进口香蕉&quot;,&quot;price&quot;:2.0&#125;
________________________________________________________________
127.0.0.1:6379[3]&gt; keys *
127.0.0.1:6379[3]&gt; &quot;goods:8820&quot; &quot;goods:8819&quot; &quot;goods:8818&quot;
127.0.0.1:6379[3]&gt; get goods:8820
</code></pre>
<hr>
<h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h6><pre><code class="java">CacheSample.java
package com.imooc.jedis;

import com.alibaba.fastjson.JSON;
import redis.clients.jedis.Jedis;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class CacheSample &#123;
    public CacheSample()&#123; //数据初始化
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            List&lt;Goods&gt; goodsList = new ArrayList();
            goodsList.add(new Goods(8818,&quot;红富士苹果&quot;,&quot;&quot;,3.5f));
            goodsList.add(new Goods(8819,&quot;赣南脐橙&quot;,&quot;&quot;,5f));
            goodsList.add(new Goods(8820,&quot;进口香蕉&quot;,&quot;&quot;,2f));
            //javabean序列化为json字符串保存到java里
            jedis.auth(&quot;root&quot;);
            jedis.select(3);
            for (Goods goods : goodsList)&#123;
                String json = JSON.toJSONString(goods);
                System.out.println(json);
                String key = &quot;goods:&quot; + goods.getGoodsId();
                jedis.set(key, json); //key + value[序列化为json]
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new CacheSample();
        System.out.println(&quot;请输入要查询的商品编号:&quot;);
        String goodsId = new Scanner(System.in).next();
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;);
        jedis.auth(&quot;root&quot;);
        jedis.select(3);
        String key = &quot;goods:&quot; + goodsId;
        if (jedis.exists(key))&#123;
            String json = jedis.get(key);
            System.out.println(json);
            //由json转回到java对象
            Goods g = JSON.parseObject(json, Goods.class);
            System.out.println(g.getGoodsName());
            System.out.println(g.getPrice());
        &#125;else&#123;
            System.out.println(&quot;您输入的商品编号不存在，请重新输入!&quot;);
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/11/15/后端/Linux,Redis,Jedis/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/11/07/后端/MyBatis实现OA系统项目实战/">
        <h2>
            MyBatis实现OA系统项目实战
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/11/7
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="慕课网办公OA平台"><a href="#慕课网办公OA平台" class="headerlink" title="慕课网办公OA平台"></a>慕课网办公OA平台</h3><h5 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h5><ul>
<li>需求说明与环境准备</li>
<li>开发基于RBAC的访问控制模块</li>
<li>开发多级请假审批流程</li>
</ul>
<h3 id="办公自动化OA系统"><a href="#办公自动化OA系统" class="headerlink" title="办公自动化OA系统"></a>办公自动化OA系统</h3><ul>
<li>办公自动化系统(Office Automation)是替代传统办公的解决方案</li>
<li>OA系统是利用软件技术构建的单位内部办公平台，用于辅助办公</li>
<li>利用OA系统可将办公数据数字化，可扩大提高办公流程执行效率</li>
</ul>
<h3 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h3><ul>
<li>慕课网办公OA系统要求采用多用户B&#x2F;S架构设计开发</li>
<li>HR为每一位员工分配系统账户，员工用此账户登录系统</li>
<li>公司采用分级定岗，从1-8依次提升，不同岗位薪资水平不同<ul>
<li>6级(含)以下员工为<strong>业务岗</strong>，对应人员执行公司业务事宜</li>
<li>7-8级为<strong>管理岗</strong>，其中<u>7级为部门经理</u>，<u>8级为总经理</u></li>
<li>业务岗与管理岗员工可用系统功能不同，要求允许灵活配置</li>
</ul>
</li>
</ul>
<h3 id="请假流程"><a href="#请假流程" class="headerlink" title="请假流程"></a>请假流程</h3><ul>
<li>公司所有员工都可以使用”请假申请”功能申请休假</li>
<li>请假时间少于72小时，部门经理审批后直接通过</li>
<li>请假时间大于72小时，部门经理审批后还需总经理进行审批</li>
<li>部门经理只允许批准本部门员工申请</li>
<li>部门经理请假需直接由总经理审批</li>
<li>总经理提起请假申请，系统自动批准通过</li>
</ul>
<h3 id="搭建基础架构"><a href="#搭建基础架构" class="headerlink" title="搭建基础架构"></a>搭建基础架构</h3><h5 id="框架-amp-组件"><a href="#框架-amp-组件" class="headerlink" title="框架&amp;组件"></a>框架&amp;组件</h5><ul>
<li>MySQL 8</li>
<li>Mybatis 3.5</li>
<li>Alibaba Druid</li>
<li>Servlet 3.1</li>
<li>Freemarker 2.3</li>
<li>LayUl 2.5</li>
</ul>
<h5 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h5><pre><code class="java">imooc-oa  eclipse工程项目
 /src - java源代码目录
 /WebContent - Web资源目录
 /css - css文件目录
 /js - js文件目录
 /image - 图片资源目录
 /upload - 上传文件目录
 /WEB-INF   //jsp数据来自controller 不允许在web中直接访问 要从控制器跳转
   /jsp - jsp页面目录
   /lib - jar文件目录
   /classes - 编译后的class目录
   /web.xml web描述符文件
</code></pre>
<h5 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h5><pre><code class="java">com.imooc-oa //逆命名法
    /controller - 存放Servlet控制器类 //承上启下接收参数 调用逻辑 返回处理结果
    /service - 存放处理逻辑类model[伪数据库] //完成业务逻辑 service与dao进行传递调用
    /dao - Data Access Object 数据访问对象类 数据读写的java类 数据来自xml文件
    /entity - 存放实体类 JavaBean java中的简单对象
    /utils - 通用工具类 底层通用的工具类或方法
</code></pre>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><img src="https://raw.githubusercontent.com/P-luminary/images/1f7a3c8c83e3c7c1743888e25207d2ff4d0b116d/data/OA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE.png" style="zoom: 67%;" />

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_58642210/article/details/123806612">Mybatis复习_resources.getresourceasreader的读取路径-CSDN博客</a></p>
<h6 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-oa&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;!--Mybatis 框架--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--MySQL 8 JDBC驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.19&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Druid数据库连接池--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.14&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Junit4单元测试框架--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;!--只参与Maven Test,不进行发布--&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--Logback日志输出组件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Freemarker依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.29&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--servlet-api--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;!--依赖只参与编译测试,不进行发布--&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
&lt;!--用Maven时必打的代码--&gt;
                &lt;!--利用Maven编译插件将编译级别提高至1.8,解决lambda表达式错误--&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;!--maven-compiler-plugin是Maven自带的编译插件--&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.3&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;!--检查源码采用1.8规则,默认为1.5--&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;!--按1.8规则生成字节码--&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
&lt;/project&gt;
</code></pre>
<h6 id="配置数据库连接池"><a href="#配置数据库连接池" class="headerlink" title="配置数据库连接池"></a>配置数据库连接池</h6><pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;environments default=&quot;dev&quot;&gt;
        &lt;!--开发环境配置--&gt;
        &lt;environment id=&quot;dev&quot;&gt;
            &lt;!--事务管理器采用JDBC方式--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--利用Mybatis自带连接池管理连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;!--MyBatis与Druid的整合--&gt;
                &lt;!--JDBC连接属性--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/imooc-oa?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="开发Mybatis"><a href="#开发Mybatis" class="headerlink" title="开发Mybatis"></a>开发Mybatis</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_58642210/article/details/123806612">Mybatis复习_resources.getresourceasreader的读取路径-CSDN博客</a></p>
<pre><code class="xml">test.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;test&quot;&gt;
    &lt;select id=&quot;sample&quot; resultType=&quot;string&quot;&gt;
        select &#39;success&#39;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">util-MybatisUtils.java
package util;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.Reader;
import java.util.function.Function;

public class MybatisUtils &#123;
    //利用static(静态)属于类不属于对象,且全局唯一
    private static SqlSessionFactory sqlSessionFactory = null;
    //利用静态块在初始化类时实例化sqlSessionFactory
    static&#123;
        Reader reader = null;
        try&#123;
            reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
        &#125;catch(IOException e)&#123;
            //初始化错误时,通过抛出异常ExceptionInInitializerError通知调用者
            throw new ExceptionInInitializerError(e);
        &#125;
    &#125;

    /**
     * 执行SELECT查询SQL
     * @param func 要执行查询语句的代码块
     * @return 查询结果
     */
    //用于数据的查询[极大的简化查询] mybatis执行SQL时一定要有mapper的xml
    public static Object executeQuery(Function&lt;SqlSession,Object&gt; func)&#123; //函数式接口
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try&#123;//具体查询交给Function实现 查询前完成连接的打开和关闭
            Object obj = func.apply(sqlSession);
            return obj;
        &#125;finally &#123;
            sqlSession.close(); //最后一步释放连接资源
        &#125;
    &#125;

    /**
     * 执行INSERT/UPDATE/DELETE写操作SQL
     * @param func 要执行的写操作代码块
     * @return 写操作后返回的结果
     */
    public static Object executeUpdate(Function&lt;SqlSession,Object&gt; func)&#123; //函数式接口
        SqlSession sqlSession = sqlSessionFactory.openSession(false);
        try&#123;//具体查询交给Function实现 查询前完成连接的打开和关闭
            Object obj = func.apply(sqlSession);
            sqlSession.commit();
            return obj;
        &#125;catch (RuntimeException e)&#123;
            sqlSession.rollback();
            throw e;
        &#125;finally &#123;
            sqlSession.close(); //最后一步释放连接资源
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">MybatisUtilsTestor.java
import org.apache.ibatis.session.SqlSession;
import org.junit.Test;
import util.MybatisUtils;

public class MybatisUtilsTestor &#123;
//    @Test
//    public void testcase1()&#123;
//        String result = (String)MybatisUtils.executeQuery(sqlSession -&gt; &#123;
//            String out = (String)sqlSession.selectOne(&quot;test.sample&quot;);
//            return out; //out会被retrun obj接收 返回Object
//        &#125;);
//        System.out.println(result);
//    &#125;
    @Test
    public void testcase2()&#123;
        String result = (String) MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectOne(&quot;test.sample&quot;));
        System.out.println(result);
    &#125;
&#125;
</code></pre>
<h3 id="MyBatis整合Druid连接池-自定义连接池"><a href="#MyBatis整合Druid连接池-自定义连接池" class="headerlink" title="MyBatis整合Druid连接池 (自定义连接池)"></a>MyBatis整合Druid连接池 (自定义连接池)</h3><pre><code class="xml">重新整合mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;environments default=&quot;dev&quot;&gt;
        &lt;!--开发环境配置--&gt;
        &lt;environment id=&quot;dev&quot;&gt;
            &lt;!--事务管理器采用JDBC方式--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--利用Mybatis自带连接池管理连接--&gt;
&lt;!--            &lt;dataSource type=&quot;POOLED&quot;&gt;--&gt;
            &lt;dataSource type=&quot;com.imooc.oa.datasource.DruidDataSourceFactory&quot;&gt;
            &lt;!--MyBatis与Druid的整合--&gt;
                &lt;!--JDBC连接属性--&gt;
                &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/imooc-oa?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
                &lt;!--连接池初始连接数--&gt;
                &lt;property name=&quot;initialSize&quot; value=&quot;10&quot;/&gt;
                &lt;!--连接池最大连接数--&gt;
                &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com.imooc.oa.datasource.DruidDataSourceFactory
package com.imooc.oa.datasource;

import com.alibaba.druid.pool.DruidDataSource;
import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;

import javax.sql.DataSource;
import java.sql.SQLException;

public class DruidDataSourceFactory extends UnpooledDataSourceFactory &#123;
    public DruidDataSourceFactory()&#123; //1.创造空的数据源对象
        // 2.调用setProperties读取xml对dataSource属性源进行设置
        this.dataSource = new DruidDataSource(); //表达数据源信息
    &#125;
    //3.数据源需要额外设置要重写
    @Override
    public DataSource getDataSource() &#123; //获取已经初始化的连接池进行返回
        try &#123;
            ((DruidDataSource)this.dataSource).init(); //初始化Druid数据源
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125;
        return this.dataSource;
    &#125;
&#125;
</code></pre>
<h6 id="Ctrl-Shift-N-文件查找对话框"><a href="#Ctrl-Shift-N-文件查找对话框" class="headerlink" title="Ctrl + Shift + N 文件查找对话框"></a>Ctrl + Shift + N 文件查找对话框</h6><h3 id="整合Freemarker"><a href="#整合Freemarker" class="headerlink" title="整合Freemarker"></a>整合Freemarker</h3><pre><code class="xml">pom.xml
    &lt;!--Freemarker依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.29&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--servlet-api--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;!--依赖只参与编译测试,不进行发布--&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="ftl">web-WEB-INF-ftl-test.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;$&#123;result&#125;&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="xml">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;freemaker&lt;/servlet-name&gt;
        &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;!--        定义模板的存储路径--&gt;
            &lt;param-name&gt;TemplatePath&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
&lt;!-- default_encoding用于设置读取ftl文件时采用的字符集,进而避免中文乱码的产生--&gt;
            &lt;param-name&gt;default_encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;freemaker&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="java">TestServlet.java
package com.imooc.oa.test;

import com.imooc.oa.util.MybatisUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = &quot;TestServlet&quot;, urlPatterns = &quot;/test&quot;)
public class TestServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String result = (String)MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectOne(&quot;test.sample&quot;));
        req.setAttribute(&quot;result&quot;,result);
        req.getRequestDispatcher(&quot;/test.ftl&quot;).forward(req,resp);
    &#125;
&#125;
</code></pre>
<h3 id="RBAC-Role-Based-Access-Control-介绍"><a href="#RBAC-Role-Based-Access-Control-介绍" class="headerlink" title="RBAC(Role-Based Access Control)介绍"></a>RBAC(Role-Based Access Control)介绍</h3><ul>
<li><p>基于**<u>角色权限控制</u>**(<strong>RBAC</strong>)是面向企业安全策略的访问控制方式</p>
</li>
<li><p>RBAC核心思想是将控制访问的资源与角色(Role)进行绑定</p>
</li>
<li><p>系统的用户(User)与角色(Role)再进行绑定, 用户便拥有对应权限</p>
</li>
</ul>
<h6 id="一般主键cno或id都要设定字段类型为-BigInt"><a href="#一般主键cno或id都要设定字段类型为-BigInt" class="headerlink" title="一般主键cno或id都要设定字段类型为 BigInt"></a>一般主键cno或id都要设定字段类型为 BigInt</h6><h5 id="imooc-oa-sql"><a href="#imooc-oa-sql" class="headerlink" title="imooc-oa.sql"></a>imooc-oa.sql</h5><h2 id="实现用户登录"><a href="#实现用户登录" class="headerlink" title="实现用户登录"></a>实现用户登录</h2><h4 id="基于LayUI开发登录页"><a href="#基于LayUI开发登录页" class="headerlink" title="基于LayUI开发登录页"></a>基于LayUI开发登录页</h4><h4 id="LayUI前端框架"><a href="#LayUI前端框架" class="headerlink" title="LayUI前端框架"></a>LayUI前端框架</h4><p><a target="_blank" rel="noopener" href="https://www.layuiweb.com/">Layui - 经典开源模块化前端 UI 框架（官网文档镜像站） (layuiweb.com)</a></p>
<pre><code class="html">login.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui-main/src/css/layui.css&quot;&gt;
    &lt;style&gt;
        body &#123;
            background-color: #f2f2f2;
        &#125;

        .oa-container &#123;
            /*background-color: white;*/
            position: absolute;
            width: 400px;
            height: 350px;
            top: 50%;
            left: 50%;
            padding: 20px;
            margin-left: -200px;
            margin-top: -175px;
        &#125;
        #username,#password&#123;
            /*text-align: center;*/
            /*font-size: 24px;*/
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;oa-container&quot;&gt;
    &lt;h1 style=&quot;text-align: center; margin-bottom: 20px&quot;&gt;办公OA系统&lt;/h1&gt;
    &lt;form class=&quot;layui-form&quot;&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;button class=&quot;layui-btn layui-btn-fluid&quot; lay-submit lay-filter=&quot;login&quot;&gt;登录&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="实现用户登录-1"><a href="#实现用户登录-1" class="headerlink" title="实现用户登录-1"></a>实现用户登录-1</h3><pre><code class="java">com.imooc.oa.entity.User
package com.imooc.oa.entity;

public class User &#123;
    /*
    &lt;settings&gt;
        &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
     */
    private Long userId;
    private String username;
    private String password;
    private Long employeeId;
    Getter + Setter
&#125;
</code></pre>
<pre><code class="java">com.imooc.oa.dao.UserDao
package com.imooc.oa.dao;

import com.imooc.oa.entity.User;
import com.imooc.oa.util.MybatisUtils;

/**
 * 用户表
 */
public class UserDao &#123;
    /**
     * 按照用户名查询用户表
     * @param username 用户名
     * @return User对象包含对应的用户信息，null则代表对象不存在
     */
    public User selectByUsername(String username)&#123;
        User user = (User)MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectOne(&quot;usermapper.selectByUsername&quot;,username));
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">user.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;usermapper&quot;&gt;
    &lt;select id=&quot;selectByUsername&quot; parameterType=&quot;String&quot; resultType=&quot;com.imooc.oa.entity.User&quot;&gt;
        select * from sys_user where username = #&#123;value&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mappers&gt;
    &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt;
    &lt;mapper resource=&quot;mappers/user.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p><strong>Dao → Service</strong></p>
<h6 id="创建测试用例快捷键-Ctrl-Shift-T"><a href="#创建测试用例快捷键-Ctrl-Shift-T" class="headerlink" title="创建测试用例快捷键 Ctrl+Shift+T"></a>创建测试用例快捷键 Ctrl+Shift+T</h6><pre><code class="java">UserSerive.java
package com.imooc.oa.serive;

import com.imooc.oa.dao.UserDao;
import com.imooc.oa.entity.User;
import com.imooc.oa.serive.exception.BussinessException;

public class UserService &#123; //创建测试用例快捷键 Ctrl+Shift+T
    private UserDao userDao = new UserDao(); //实例化

    /**
     * 根据前台输入进行登录校验
     * @param username 前台输入的用户名
     * @param password 前台输入的密码
     * @return 校验通过后，包含对应用户数据的User实体类
     * @throws BussinessException L001-用户名不存在,L002-密码错误
     */ 
    public User checkLogin(String username, String password)&#123;
        User user = userDao.selectByUsername(username);
        if (user == null)&#123;
            //抛出用户不存在异常
            throw new BussinessException(&quot;L001&quot;, &quot;用户名不存在&quot;);
        &#125;
        if(!password.equals(user.getPassword()))&#123;
            throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;);
        &#125;
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">test/serive.UserServiceTest.java
package com.imooc.oa.serive;

import junit.framework.TestCase;
import org.junit.Test;

public class UserServiceTest extends TestCase &#123;
    private UserService userService = new UserService();

    @Test
    public void testCheckLogin1() &#123;
        userService.checkLogin(&quot;uu&quot;,&quot;1234&quot;);
    &#125;
    @Test
    public void testCheckLogin2() &#123;
        userService.checkLogin(&quot;m8&quot;,&quot;1234&quot;);
    &#125;
    @Test
    public void testCheckLogin3() &#123;
        userService.checkLogin(&quot;uu&quot;,&quot;test&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">serive.exception.BussinessException.java
package com.imooc.oa.serive.exception;

/**
 * 业务逻辑异常
 */
public class BussinessException extends RuntimeException&#123;
    private String code; //异常编码,异常的以为标识
    private String message; //异常的具体文本消息
    public BussinessException(String code, String msg)&#123;
        super(code + &quot;:&quot; + msg);
        this.code = code;
        this.message = msg;
    &#125;

    public String getCode() &#123;
        return code;
    &#125;

    public void setCode(String code) &#123;
        this.code = code;
    &#125;

    @Override
    public String getMessage() &#123;
        return message;
    &#125;

    public void setMessage(String message) &#123;
        this.message = message;
    &#125;
&#125;
</code></pre>
<h3 id="实现用户登录-2"><a href="#实现用户登录-2" class="headerlink" title="实现用户登录-2"></a>实现用户登录-2</h3><pre><code class="java">com.imooc.oa.controller.LoginServlet.java
package com.imooc.oa.controller;

import com.alibaba.fastjson.JSON;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.UserService;
import com.imooc.oa.service.exception.BussinessException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = &quot;LoginServlet&quot; ,urlPatterns = &quot;/check_login&quot;)
public class LoginServlet extends HttpServlet &#123;
    Logger logger = LoggerFactory.getLogger(LoginServlet.class);
    private UserService userService = new UserService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        //接收用户输入
        String username = request.getParameter(&quot;username&quot;);
        String password = request.getParameter(&quot;password&quot;);
        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        try &#123;
            //调用业务逻辑
            User user = userService.checkLogin(username, password);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;message&quot;, &quot;success&quot;);
        &#125;catch (BussinessException ex)&#123;
            logger.error(ex.getMessage() , ex);
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;message&quot;, ex.getMessage());
        &#125;catch (Exception ex)&#123;
            logger.error(ex.getMessage() , ex);
            result.put(&quot;code&quot;, ex.getClass().getSimpleName());
            result.put(&quot;message&quot;, ex.getMessage());
        &#125;
        //返回对应结果
        String json = JSON.toJSONString(result);
        response.getWriter().println(json);
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    &#125;
&#125;
</code></pre>
<h4 id="实现用户登录-3"><a href="#实现用户登录-3" class="headerlink" title="实现用户登录-3"></a>实现用户登录-3</h4><pre><code class="xml">pom.xml
&lt;dependency&gt;
   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
   &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
   &lt;version&gt;1.2.62&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="html">login.xml实现增添表单校验
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;慕课网办公OA系统&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
    &lt;style&gt;
        body&#123;
            background-color: #F2F2F2;
        &#125;
        .oa-container&#123;
            /*background-color: white;*/
            position: absolute;
            width: 400px;
            height: 350px;
            top: 50%;
            left: 50%;
            padding: 20px;
            margin-left: -200px;
            margin-top: -175px;
        &#125;
        #username,#password&#123;
            /*text-align: center;*/
            /*font-size: 24px;*/
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;oa-container&quot;&gt;
    &lt;h1 style=&quot;text-align: center;margin-bottom: 20px&quot;&gt;办公OA系统&lt;/h1&gt;
    &lt;form class=&quot;layui-form&quot;&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;input type=&quot;text&quot; id=&quot;username&quot; lay-verify=&quot;required&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; &gt;
        &lt;/div&gt;

        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;input type=&quot;password&quot; id=&quot;password&quot; lay-verify=&quot;required&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; &gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;button class=&quot;layui-btn layui-btn-fluid&quot; lay-submit lay-filter=&quot;login&quot;&gt;登录&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    // 表单提交事件 表单输入校验 在上面加 lay-verify=&quot;requrired&quot;
    layui.form.on(&quot;submit(login)&quot; , function(formdata)&#123;//data参数包含了当前表单的数据
        console.log(formdata);
        //发送ajax请求进行登录校验
        layui.$.ajax(&#123;
            url : &quot;/check_login&quot;,
            data : formdata.field, //提交表单数据
            type : &quot;post&quot;,
            dataType : &quot;json&quot; ,
            success : function(json)&#123;
                console.log(json);
                if(json.code == &quot;0&quot;)&#123; //登录校验成功 内置弹出层
                    layui.layer.msg(&quot;登录成功&quot;);
                &#125;else&#123;
                    layui.layer.msg(json.message);
                &#125;
            &#125;
        &#125;)
        return false;//submit提交事件返回true则表单提交,false则阻止表单提交
    &#125;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/html&gt;
</code></pre>
<h6 id="后面通过Ajax-浏览器后台-上面return-false-请求向服务器发起异步通信获取校验是否通过"><a href="#后面通过Ajax-浏览器后台-上面return-false-请求向服务器发起异步通信获取校验是否通过" class="headerlink" title="后面通过Ajax[浏览器后台(上面return false)]请求向服务器发起异步通信获取校验是否通过"></a>后面通过Ajax[浏览器后台(上面return false)]请求向服务器发起异步通信获取校验是否通过</h6><h3 id="分析后台首页布局与设计"><a href="#分析后台首页布局与设计" class="headerlink" title="分析后台首页布局与设计"></a>分析后台首页布局与设计</h3><pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课网办公OA系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    姓名[部门-职务]
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;
                &lt;!--父节点--&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;模块1&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;1&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                &lt;!--子节点--&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能1&lt;/a&gt;
                &lt;/dd&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能2&lt;/a&gt;
                &lt;/dd&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能3&lt;/a&gt;
                &lt;/dd&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;模块2&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;2&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能3&lt;/a&gt;
                &lt;/dd&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能4&lt;/a&gt;
                &lt;/dd&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能5&lt;/a&gt;
                &lt;/dd&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下 一开始先dl与dd对齐[程序维护方便]
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;)
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="动态显示功能菜单-1-【核心：rbac-xml】"><a href="#动态显示功能菜单-1-【核心：rbac-xml】" class="headerlink" title="动态显示功能菜单-1 【核心：rbac.xml】"></a>动态显示功能菜单-1 【<u>核心：rbac.xml</u>】</h3><p>通过用户找到角色sys_user 再通过角色找到节点sys_role_user 接下来通过节点编号sys_role_node去获取与之对应的节点其他信息(三表关联)</p>
<p>xml→Dao→UserService</p>
<pre><code class="xml">resources.mappers.rbac.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;rbacmapper&quot;&gt;
    &lt;select id=&quot;selectNodeByUserId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.Node&quot;&gt;
        select distinct n.*
        from
            sys_role_user ru, sys_role_node rn, sys_node n
        where
            ru.role_id = rn.role_id and user_id = #&#123;value&#125; and rn.node_id = n.node_id
        order by n.node_code
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt;
        &lt;mapper resource=&quot;mappers/user.xml&quot;/&gt;
        &lt;mapper resource=&quot;mappers/rbac.xml&quot;/&gt;
    &lt;/mappers&gt;
</code></pre>
<pre><code class="java">imooc.oa.dao.RbacDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Node;
import com.imooc.oa.util.MybatisUtils;

import java.util.List;

public class RbacDao &#123;
    public List&lt;Node&gt; selectNodeByUserId(Long userId)&#123;
        return (List)MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectList(&quot;rbacmapper.selectNodeByUserId&quot;, userId));
    &#125;
&#125;
</code></pre>
<pre><code class="java">service.UserService.java
package com.imooc.oa.service;

import com.imooc.oa.dao.RbacDao;
import com.imooc.oa.dao.UserDao;
import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.exception.BussinessException;

import java.util.List;

public class UserService &#123; //创建测试用例快捷键 Ctrl+Shift+T
    private UserDao userDao = new UserDao(); //实例化
    private RbacDao rbacDao = new RbacDao();

    /**
     * 根据前台输入进行登录校验
     * @param username 前台输入的用户名
     * @param password 前台输入的密码
     * @return 校验通过后,包含对应用户数据的User实体类
     * @throws BussinessException L001-用户名不存在,L002-密码错误
     */
    public User checkLogin(String username, String password)&#123;
        User user = userDao.selectByUsername(username);
        if (user == null)&#123;
            //抛出用户不存在异常
            throw new BussinessException(&quot;L001&quot;, &quot;用户名不存在&quot;);
        &#125;
        if(!password.equals(user.getPassword()))&#123;
            throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;);
        &#125;
        return user;
    &#125;
    public List&lt;Node&gt; selectNodeByUserId(Long userId)&#123;
        List&lt;Node&gt; nodeList = rbacDao.selectNodeByUserId(userId);
        return nodeList;
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserServiceTest.java
@Test
    public void selectNodeByUserId()&#123;
        List&lt;Node&gt; nodeList = userService.selectNodeByUserId(2l);
        System.out.println(nodeList);
    &#125;
</code></pre>
<pre><code class="java">Node.java
public class Node &#123;
    private Long nodeId;
    private Integer nodeType;
    private String nodeName;
    private String url;
    private Integer nodeCode;
    private Long parentId;
    Setter + Getter
&#125;
</code></pre>
<h3 id="动态显示功能菜单-2-不同用户登录不同功能"><a href="#动态显示功能菜单-2-不同用户登录不同功能" class="headerlink" title="动态显示功能菜单-2 (不同用户登录不同功能)"></a>动态显示功能菜单-2 (不同用户登录不同功能)</h3><pre><code class="java">修改LoginServlet.java
package com.imooc.oa.controller;

import com.alibaba.fastjson.JSON;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.UserService;
import com.imooc.oa.service.exception.BussinessException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = &quot;LoginServlet&quot; ,urlPatterns = &quot;/check_login&quot;)
public class LoginServlet extends HttpServlet &#123;
    Logger logger = LoggerFactory.getLogger(LoginServlet.class);
    private UserService userService = new UserService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        //接收用户输入
        String username = request.getParameter(&quot;username&quot;);
        String password = request.getParameter(&quot;password&quot;);
        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        try &#123;
            //调用业务逻辑 不能直接 request.setAttribute 选更大的对象
            User user = userService.checkLogin(username, password);
            HttpSession session = request.getSession();
            //session种存在用户信息 向session存入登录用户信息,属性名：login_user
            session.setAttribute(&quot;login_user&quot;, user);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;message&quot;, &quot;success&quot;);
            result.put(&quot;redirect_url&quot;, &quot;/index&quot;); //url登陆成功直接返回客户端
        &#125;catch (BussinessException ex)&#123;
            logger.error(ex.getMessage() , ex);
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;message&quot;, ex.getMessage());
        &#125;catch (Exception ex)&#123;
            logger.error(ex.getMessage() , ex);
            result.put(&quot;code&quot;, ex.getClass().getSimpleName());
            result.put(&quot;message&quot;, ex.getMessage());
        &#125;
        //返回对应结果
        String json = JSON.toJSONString(result);
        response.getWriter().println(json);
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">oa.controller.IndexServlet.java
package com.imooc.oa.controller;

import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.UserService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.List;
//接收数据传入
@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)
public class IndexServlet extends HttpServlet &#123;
    private UserService userService = new UserService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response)&#123;

    &#125;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute(&quot;login_user&quot;);
        List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId());
        request.setAttribute(&quot;node_list&quot;,nodeList);
        request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request, response);
    &#125;
&#125;
</code></pre>
<pre><code class="html">将index.html 变成 index.ftl并放在Web/WEB-INF/ftl/index.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课网办公OA系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    姓名[部门-职务]
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;
                &lt;#list node_list as node&gt;
                &lt;!--父节点--&gt;
                    &lt;#if node.nodeType == 1&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;$&#123;node.nodeId&#125;&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                    &lt;/#if&gt;
                    &lt;#if node.nodeType == 2&gt;
                &lt;!--子节点--&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                &lt;/dd&gt;
                    &lt;/#if&gt;
                &lt;/#list&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下 一开始先dl与dd对齐[程序维护方便]
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;)
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Xml配置下实现Mapper接口-登录用户所对应员工"><a href="#Xml配置下实现Mapper接口-登录用户所对应员工" class="headerlink" title="Xml配置下实现Mapper接口 (登录用户所对应员工)"></a>Xml配置下实现Mapper接口 (登录用户所对应员工)</h3><p>接口 xml mapper增加 employeeservice </p>
<p>index.ftl  indexServlet  改index.ftl</p>
<p>增加自动化部门 entity.Department  dao.创建接口DepartmentDao  mappers.department.xml  -config.xml注册     DepartmentSerive.java<br>IndexServlet.java   index.ftl</p>
<pre><code class="java">entity.Employee.java
public class Employee&#123;
    private Long employeeId;
    private String name;
    private Long departmentId;
    private String title;
    private Integer level;
    Getter+Setter
&#125;
</code></pre>
<pre><code class="java">dao.EmployeeDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Department;

public interface DepartmentDao &#123;
    public Department selectById(Long departmentId);
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mapper resource=&quot;mappers/employee.xml&quot;/&gt;

index.ftl
 &lt;!--右侧当前用户信息--&gt;
   &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
       &lt;li class=&quot;layui-nav-item&quot;&gt;
           &lt;a href=&quot;javascript:void(0)&quot;&gt;
               &lt;!--图标--&gt;
              &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
               &lt;/span&gt;
               &lt;!--用户信息--&gt;
                    $&#123;current_employee.name&#125;[$&#123;current_department.departmentName&#125;-$&#123;current_employee.title&#125;]
                &lt;/a&gt;
            &lt;/li&gt;
</code></pre>
<pre><code class="java">IndexServlet.java
package com.imooc.oa.controller;

import com.imooc.oa.entity.Department;
import com.imooc.oa.entity.Employee;
import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.DepartmentService;
import com.imooc.oa.service.EmployeeService;
import com.imooc.oa.service.UserService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.List;

@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)
public class IndexServlet extends HttpServlet &#123;
    private UserService userService = new UserService();
    private EmployeeService employeeService = new EmployeeService();
    private DepartmentService departmentService = new DepartmentService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response)&#123;

    &#125;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();
        //得到当前登录用户对象
        User user = (User) session.getAttribute(&quot;login_user&quot;);
        Employee employee = employeeService.selectById(user.getEmployeeId());
        //获取登录用户可用功能模块列表
        List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId());
        //获取员工对应的部门
        Department department = departmentService.selectById(employee.getDepartmentId());
        //放入请求属性 session生存时间长
        request.setAttribute(&quot;node_list&quot;,nodeList);
        session.setAttribute(&quot;current_employee&quot;,employee);
        session.setAttribute(&quot;current_department&quot;, department);
        //请求派发至ftl进行展现
        request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request, response);
    &#125;
&#125;
</code></pre>
<h6 id="增加自动化部门"><a href="#增加自动化部门" class="headerlink" title="增加自动化部门"></a>增加自动化部门</h6><pre><code class="java">entity.Department.java
public class Department &#123;
    private Long departmentId;
    private String departmentName;
    Getter+Setter
&#125;
</code></pre>
<pre><code class="java">dao.DepartmentDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Department;

public interface DepartmentDao &#123;
    public Department selectById(Long departmentId);
&#125;
</code></pre>
<pre><code class="xml">mapper.department.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace与包名类名一致--&gt;
&lt;mapper namespace=&quot;com.imooc.oa.dao.DepartmentDao&quot;&gt;
    &lt;!--id与方法名对应 parameterType与方法参数类型对应 resultType与方法返回类型对应--&gt;
    &lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.Department&quot;&gt;
        select * from adm_department where department_id = #&#123;value&#125;
    &lt;/select&gt;
&lt;/mapper&gt;

mybatis-config.xml
&lt;mapper resource=&quot;mappers/department.xml&quot;/&gt;
</code></pre>
<pre><code class="java">service.DepartmentServlet.java
package com.imooc.oa.service;

import com.imooc.oa.dao.DepartmentDao;
import com.imooc.oa.entity.Department;
import com.imooc.oa.util.MybatisUtils;

public class DepartmentService &#123;
    /**
     * 按编号得到部门对象
     * @param departmentId 部门编号
     * @return 部门对象,null代表部门不存在
     */
    public Department selectById(Long departmentId)&#123;
        return (Department) MybatisUtils.executeQuery(
                sqlSession -&gt; sqlSession.getMapper(DepartmentDao.class).selectById(departmentId));
    &#125;
&#125;
</code></pre>
<pre><code class="java">controller.indexServlet.java
package com.imooc.oa.controller;

import com.imooc.oa.entity.Department;
import com.imooc.oa.entity.Employee;
import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.DepartmentService;
import com.imooc.oa.service.EmployeeService;
import com.imooc.oa.service.UserService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.List;

@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)
public class IndexServlet extends HttpServlet &#123;
    private UserService userService = new UserService();
    private EmployeeService employeeService = new EmployeeService();
    private DepartmentService departmentService = new DepartmentService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response)&#123;

    &#125;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();
        //得到当前登录用户对象
        User user = (User) session.getAttribute(&quot;login_user&quot;);
        Employee employee = employeeService.selectById(user.getEmployeeId());
        //获取登录用户可用功能模块列表
        List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId());
        //获取员工对应的部门
        Department department = departmentService.selectById(employee.getDepartmentId());
        //放入请求属性 session生存时间长
        request.setAttribute(&quot;node_list&quot;,nodeList);
        session.setAttribute(&quot;current_employee&quot;,employee);
        session.setAttribute(&quot;current_department&quot;, department);
        //请求派发至ftl进行展现
        request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request, response);
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课网办公OA系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    $&#123;current_employee.name&#125;[$&#123;current_department.departmentName&#125;-$&#123;current_employee.title&#125;]
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;
                &lt;#list node_list as node&gt;
                &lt;!--父节点--&gt;
                    &lt;#if node.nodeType == 1&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;$&#123;node.nodeId&#125;&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                    &lt;/#if&gt;
                    &lt;#if node.nodeType == 2&gt;
                &lt;!--子节点--&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                &lt;/dd&gt;
                    &lt;/#if&gt;
                &lt;/#list&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下 一开始先dl与dd对齐[程序维护方便]
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;)
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="基于MD5算法对密码加密"><a href="#基于MD5算法对密码加密" class="headerlink" title="基于MD5算法对密码加密"></a>基于MD5算法对密码加密</h3><h5 id="MD5摘要算法"><a href="#MD5摘要算法" class="headerlink" title="MD5摘要算法"></a>MD5摘要算法</h5><ul>
<li>MD5信息摘要算法广泛使用的密码散列函数</li>
<li>MD5可以产生出一个128位的散列值用于唯一标识源数据</li>
<li>项目中通常使用MD5作为敏感数据的加密算法</li>
</ul>
<h5 id="MD5特点"><a href="#MD5特点" class="headerlink" title="MD5特点"></a>MD5特点</h5><ul>
<li>压缩性, MD5生成的摘要长度固定</li>
<li>抗修改, 源数据哪怕有一个字节变化, MD5也会有巨大差异</li>
<li>不可逆, 无法通过MD5反向推算源数据</li>
</ul>
<h5 id="Apache-Commons-Codec"><a href="#Apache-Commons-Codec" class="headerlink" title="Apache Commons Codec"></a>Apache Commons Codec</h5><ul>
<li>Commons-Codec是Apache提供的编码&#x2F;解码组件</li>
<li>通过Commons-Codec可以轻易生成源数据的MD5摘要</li>
<li>MD5摘要方法: <strong>String md5 &#x3D; DigestUtils.md5Hex</strong> (源数据)</li>
</ul>
<pre><code class="java">util.MD5Utils.java
package com.imooc.oa.util;

import org.apache.commons.codec.digest.DigestUtils;

public class MD5Utils &#123;
    public static String md5Digest(String source)&#123;
        return DigestUtils.md5Hex(source);
    &#125;
&#125;
</code></pre>
<h3 id="敏感数据加盐混淆"><a href="#敏感数据加盐混淆" class="headerlink" title="敏感数据加盐混淆"></a>敏感数据加盐混淆</h3><p> md5utilstest  userservice user</p>
<pre><code class="java">public class User &#123;
    /*
    &lt;settings&gt;
        &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
     */
    private Long userId;
    private String username;
    private String password;
    private Long employeeId;
    private Integer salt;
    Getter + Setter
&#125;
</code></pre>
<pre><code class="java">util.MD5Utils.java
package com.imooc.oa.util;

import org.apache.commons.codec.digest.DigestUtils;

public class MD5Utils &#123;
    /**
     * 对数据源加盐混淆后生成MD5摘要
     * @param source 源数据
     * @return MD5摘要
     */
    public static String md5Digest(String source)&#123;
        return DigestUtils.md5Hex(source);
    &#125;
    public static String md5Digest(String source, Integer salt)&#123;
        char[] ca = source.toCharArray(); //字符数组
        for (int i = 0; i &lt; ca.length; i++) &#123;
            ca[i] = (char)(ca[i] + salt);
        &#125;
        String target = new String(ca);
//        System.out.println(target);
        String md5 = DigestUtils.md5Hex(target);
        return md5;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(MD5Utils.md5Digest(&quot;test&quot;, 188));
    &#125;
&#125;
</code></pre>
<pre><code class="java">修改UserService.java 中的密码校验
package com.imooc.oa.service;

import com.imooc.oa.dao.RbacDao;
import com.imooc.oa.dao.UserDao;
import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.exception.BussinessException;
import com.imooc.oa.util.MD5Utils;

import java.util.List;

public class UserService &#123; //创建测试用例快捷键 Ctrl+Shift+T
    private UserDao userDao = new UserDao(); //实例化
    private RbacDao rbacDao = new RbacDao();

    /**
     * 根据前台输入进行登录校验
     * @param username 前台输入的用户名
     * @param password 前台输入的密码
     * @return 校验通过后,包含对应用户数据的User实体类
     * @throws BussinessException L001-用户名不存在,L002-密码错误
     */
    public User checkLogin(String username, String password)&#123;
        User user = userDao.selectByUsername(username);
        if (user == null)&#123;
            //抛出用户不存在异常
            throw new BussinessException(&quot;L001&quot;, &quot;用户名不存在&quot;);
        &#125;
        //对前台输入的密码加盐混淆后生成MD5,与保存在数据库中的MD5密码进行对比
        String md5 = MD5Utils.md5Digest(password, user.getSalt());
        if(!md5.equals(user.getPassword()))&#123;
            throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;);
        &#125;
        return user;
    &#125;
    public List&lt;Node&gt; selectNodeByUserId(Long userId)&#123;
        List&lt;Node&gt; nodeList = rbacDao.selectNodeByUserId(userId);
        return nodeList;
    &#125;
&#125;
</code></pre>
<h3 id="实现注销功能"><a href="#实现注销功能" class="headerlink" title="实现注销功能"></a>实现注销功能</h3><p>loginServlet保存着数据 indexservlet中的session保存着数据<br>清除session</p>
<pre><code class="java">oa.controller.LogoutServlet.java
package com.imooc.oa.controller;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = &quot;LogoutServlet&quot;, urlPatterns = &quot;/logout&quot;)
public class LogoutServlet extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        request.getSession().invalidate(); //会话注销
        response.sendRedirect(&quot;/login.html&quot;); //跳转回去
    &#125;
&#125;
</code></pre>
<pre><code class="xml">index.ftl
&lt;!--注销按钮--&gt;
&lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
</code></pre>
<h3 id="请假流程数据库设计"><a href="#请假流程数据库设计" class="headerlink" title="请假流程数据库设计"></a>请假流程数据库设计</h3><h6 id="开发多级审批流程"><a href="#开发多级审批流程" class="headerlink" title="开发多级审批流程"></a>开发多级审批流程</h6><ul>
<li>公司所有员工都可以使用”请假申请”功能申请休假</li>
<li>请假时间少于72小时，部门经理审批后直接通过</li>
<li>请假时间大于72小时，部门经理审批后还需总经理进行审批</li>
<li>部门经理只允许批准本部门员工申请</li>
<li>部门经理请假需直接由总经理审批</li>
<li>总经理提起请假申请，系统自动批准通过</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/87fb5232c47e90f94a7580b26bd204150433faf5/data/OA%E7%B3%BB%E7%BB%9F%E8%AF%B7%E5%81%87%E6%B5%81%E7%A8%8B.jpg"></p>
<h5 id="工作流程表设计"><a href="#工作流程表设计" class="headerlink" title="工作流程表设计"></a>工作流程表设计</h5><p><span style = "color:red"><strong>请假单表</strong>LeaveForm → <strong>审批任务流程表</strong>ProcessFlow → <strong>消息通知表</strong>Notice</span></p>
<h5 id="设计约束"><a href="#设计约束" class="headerlink" title="设计约束"></a>设计约束</h5><ul>
<li><p>每一个请假单对应一个审批流程</p>
</li>
<li><p>请假单创建后, 按业务规则生成部门经理、总经理审批任务</p>
</li>
<li><p>审批任务的经办人只能审批自己辖区内的请假申请(总裁办可以审批所有 软件只能审批软件)</p>
</li>
<li><p>所有审批任务”通过”, 代表请假已经批准</p>
</li>
<li><p>任意审批任务”驳回”操作, 其余审批任务取消, 请假申请驳回</p>
</li>
<li><p>请假流程中注意节点产生的操作都要生成对应的系统通知</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/324ce1f7aa2d127ed415e216b61742f0b1550c7d/data/OA%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8.jpg" style="zoom: 150%;" />



<h3 id="实现Dao与数据交互"><a href="#实现Dao与数据交互" class="headerlink" title="实现Dao与数据交互"></a>实现Dao与数据交互</h3><p>entity  数据新增接口dao(依靠Mybatis) 增加mapper 创造LeaveFormDaoTest<br>                                    ProcessFlowDao + Test mapper<br>                                    NoticeDao</p>
<pre><code class="java">entity.LeaveForm.java
public class LeaveForm &#123;
    private Long formId;
    private Long employeeId;
    private Integer formType;
    private Date startTime;
    private Date endTime;
    private String reason;
    private Date createTime;
    private String state;
    Getter + Setter
&#125;
</code></pre>
<pre><code class="java">dao.LeaveForm.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.LeaveForm;

public interface LeaveFormDao &#123;
    public void insert(LeaveForm form);
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mapper resource=&quot;mappers/leave_form.xml&quot;/&gt;
</code></pre>
<pre><code class="java">test.dao.LeaveFormDaoTest.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.LeaveForm;
import com.imooc.oa.util.MybatisUtils;
import junit.framework.TestCase;
import org.junit.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class LeaveFormDaoTest extends TestCase &#123;
    @Test
    public void testInsert()&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            LeaveFormDao dao = sqlSession.getMapper(LeaveFormDao.class);
            LeaveForm form = new LeaveForm();
            form.setEmployeeId(4L);//员工编号
            form.setFormType(1); //事假
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            Date startTime = null; //起始时间
            Date endTime = null; //结束时间
            try &#123;
                startTime = sdf.parse(&quot;2020-03-25 08:00:00&quot;);
                endTime = sdf.parse(&quot;2020-04-01 18:00:00&quot;);
            &#125; catch (ParseException e) &#123;
                throw new RuntimeException(e);
            &#125;
            form.setStartTime(startTime);
            form.setEndTime(endTime);
            form.setReason(&quot;回家探亲&quot;); //请假事由
            form.setCreateTime(new Date()); //创建时间
            form.setState(&quot;processing&quot;); //当前状态
            dao.insert(form);
            return null;
        &#125;);
    &#125;

&#125;
</code></pre>
<hr>
<pre><code class="java">entity.ProcessFlow.java
package com.imooc.oa.entity;

import java.util.Date;

public class ProcessFlow &#123;
    private Long processId;
    private Long formId;
    private Long operatorId;
    private String action;
    private String result;
    private String reason;
    private Date createTime;
    private Date auditTime;
    private Integer orderNo;
    private String state;
    private Integer isLast;
    Setter + Getter
&#125;
</code></pre>
<pre><code class="java">dao.ProcessFlowDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.ProcessFlow;

public interface ProcessFlowDao &#123;
    public void insert(ProcessFlow processFlow);
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mapper resource=&quot;mappers/process_flow.xml&quot;/&gt;
</code></pre>
<pre><code class="java">test.dao.ProcessFlowDaoTest.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.ProcessFlow;
import com.imooc.oa.util.MybatisUtils;
import junit.framework.TestCase;

import java.util.Date;

public class ProcessFlowDaoTest extends TestCase &#123;
    public void testInsert()&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            ProcessFlowDao dao = sqlSession.getMapper(ProcessFlowDao.class);
            ProcessFlow flow = new ProcessFlow();
            flow.setFormId(31L);
            flow.setOperatorId(21L);
            flow.setAction(&quot;audit&quot;);
            flow.setReason(&quot;approved&quot;);
            flow.setReason(&quot;同意&quot;);
            flow.setCreateTime(new Date());
            flow.setAuditTime(new Date());
            flow.setOrderNo(1);
            flow.setState(&quot;ready&quot;);
            flow.setIsLast(1);
            dao.insert(flow);
            return null;
        &#125;);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">entity.Notice.java
public class Notice &#123;
    private Long noticeId;
    private Long receiverId;
    private String content;
    private Date createTime;
    Getter + Setter
&#125;
</code></pre>
<pre><code class="java">dao.NoticeDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Notice;

public interface NoticeDao &#123;
    public void insert(Notice notice);
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mapper resource=&quot;mappers/notice.xml&quot;/&gt;
</code></pre>
<pre><code class="java">test.dao.NoticeDaoTest.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Notice;
import com.imooc.oa.util.MybatisUtils;
import junit.framework.TestCase;
import org.junit.Test;

import java.util.Date;

public class NoticeDaoTest extends TestCase &#123;
    @Test
    public void testInsert()&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            NoticeDao dao = sqlSession.getMapper(NoticeDao.class);
            Notice notice = new Notice();
            notice.setReceiverId(21L);
            notice.setContent(&quot;测试消息&quot;);
            notice.setCreateTime(new Date());
            dao.insert(notice);
            return null;
        &#125;);
    &#125;
&#125;
</code></pre>
<h3 id="实现请假申请业务逻辑-1"><a href="#实现请假申请业务逻辑-1" class="headerlink" title="实现请假申请业务逻辑-1"></a>实现请假申请业务逻辑-1</h3><p>LeaveFormService employee.xml{动态审批sql}</p>
<pre><code class="xml">employee.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace与包名类名一致--&gt;
&lt;mapper namespace=&quot;com.imooc.oa.dao.EmployeeDao&quot;&gt;
    &lt;!--id与方法名对应 parameterType与方法参数类型对应 resultType与方法返回类型对应--&gt;
    &lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.Employee&quot;&gt;
        select * from adm_employee where employee_id = #&#123;value&#125;
    &lt;/select&gt;
    &lt;select id=&quot;selectLeader&quot; parameterType=&quot;com.imooc.oa.entity.Employee&quot; resultType=&quot;com.imooc.oa.entity.Employee&quot;&gt;
        select * from adm_employee where
            &lt;if test=&quot;emp.level &amp;lt; 7&quot;&gt;
                level = 7 and department_id = #&#123;emp.departmentId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;emp.level == 7&quot;&gt;
                level = 8;
            &lt;/if&gt;
            &lt;if test=&quot;emp.level == 8&quot;&gt;
                employee_id = #&#123;emp.employeeId&#125;
            &lt;/if&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service.LeaveFormService.java (重要业务走向代码不放在程序中)
package com.imooc.oa.service;

import com.imooc.oa.dao.EmployeeDao;
import com.imooc.oa.dao.LeaveFormDao;
import com.imooc.oa.dao.ProcessFlowDao;
import com.imooc.oa.entity.Employee;
import com.imooc.oa.entity.LeaveForm;
import com.imooc.oa.entity.ProcessFlow;
import com.imooc.oa.util.MybatisUtils;

import java.util.Date;

/**
 * 请假单流程服务
 */
public class LeaveFormService &#123;
    /**
     * 创建请假单
     * @param form 前端输入的请假单数据
     * @return 持久化后的请假单对象
     */
    public LeaveForm createLeaveForm(LeaveForm form)&#123;
            LeaveForm savedForm = (LeaveForm) MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            //1.持久化form表单数据,8级以下员工表单状态位processing,8级(总经理)状态位approved
            EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);
            Employee employee = employeeDao.selectById(form.getEmployeeId());
            if (employee.getLevel() == 8)&#123;
                form.setState(&quot;approved&quot;);
            &#125;else &#123;
                form.setState(&quot;processing&quot;);
            &#125;
            LeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);
            leaveFormDao.insert(form);
            //2.增加第一条流程数据,说明表单已提交,状态位complete 初始化数据↓
            ProcessFlowDao processFlowDao = sqlSession.getMapper(ProcessFlowDao.class);
            ProcessFlow flow1 = new ProcessFlow();
            flow1.setFormId(form.getFormId());
            flow1.setOperatorId(employee.getEmployeeId());
            flow1.setAction(&quot;apply&quot;);
            flow1.setCreateTime(new Date());
            flow1.setOrderNo(1);
            flow1.setState(&quot;complete&quot;);
            flow1.setIsLast(0);
            processFlowDao.insert(flow1);
            //3.分情况创建其余流程数据 employee.xml(动态sql语句)
              //3.1 7级以下员工,生成部门经理审批任务,请假时间大于36小时(后期单独处理),还需生成总经理审批任务
            if (employee.getLevel() &lt; 7)&#123;
                //动态sql EmployeeDao
                Employee dmanage = employeeDao.selectLeader(employee);
                ProcessFlow flow2 = new ProcessFlow();
                flow2.setFormId(form.getFormId());
                flow2.setOperatorId(dmanage.getEmployeeId());
                flow2.setAction(&quot;audit&quot;);//审批任务
                flow2.setCreateTime(new Date());
                flow2.setOrderNo(2);
                flow2.setState(&quot;process&quot;);
                long diff = form.getEndTime().getTime() - form.getStartTime().getTime(); //毫秒数
                float hours = diff/(1000*60*60) * 1f;
                if (hours &gt;= BussinessConstants.MANAGER_AUDIT_HOURS)&#123;
                    flow2.setIsLast(0); //最后节点
                    processFlowDao.insert(flow2);
                    Employee manager = employeeDao.selectLeader(dmanage);//总经理
                    ProcessFlow flow3 = new ProcessFlow();
                    flow3.setFormId(form.getFormId());
                    flow3.setOperatorId(manager.getEmployeeId());
                    flow3.setAction(&quot;audit&quot;);
                    flow3.setCreateTime(new Date());
                    flow3.setState(&quot;ready&quot;);
                    flow3.setOrderNo(3);
                    flow3.setIsLast(1);
                    processFlowDao.insert(flow3);
                &#125;else &#123;//小于3天&#123;
                    flow2.setIsLast(1);
                    processFlowDao.insert(flow2);
                &#125;
            &#125; else if (employee.getLevel() == 7) &#123;//部门经理
                //3.2 7级员工,生成总经理审批任务
                Employee manager = employeeDao.selectLeader(employee);
                ProcessFlow flow = new ProcessFlow();
                flow.setFormId(form.getFormId());
                flow.setOperatorId(manager.getEmployeeId());
                flow.setAction(&quot;audit&quot;);
                flow.setCreateTime(new Date());
                flow.setState(&quot;process&quot;);
                flow.setOrderNo(2);
                flow.setIsLast(1);
                processFlowDao.insert(flow);
            &#125;else if (employee.getLevel() == 8)&#123;
                //3.3 8级员工,生成总经理审批任务,系统自动通过
                ProcessFlow flow = new ProcessFlow();
                flow.setFormId(form.getFormId());
                flow.setOperatorId(employee.getEmployeeId());
                flow.setAction(&quot;audit&quot;);
                flow.setResult(&quot;自动通过&quot;);
                flow.setCreateTime(new Date());
                flow.setAuditTime(new Date());
                flow.setState(&quot;complete&quot;);
                flow.setOrderNo(2);
                flow.setIsLast(1);
                processFlowDao.insert(flow);
            &#125;
            return form;
        &#125;);
        return savedForm;
    &#125;
&#125; 
</code></pre>
<pre><code class="java">service.BussinessConstants.java
package com.imooc.oa.service;

public class BussinessConstants &#123;
    public static final int MANAGER_AUDIT_HOURS = 36; //总经理请假审批时间阈值
&#125;
</code></pre>
<p>ctrl+shift+t 生成测试用例</p>
<pre><code class="java">Test.service.LeaveFormServiceTest.java
package com.imooc.oa.service;

import com.imooc.oa.entity.LeaveForm;
import org.junit.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import static org.junit.Assert.*;

public class LeaveFormServiceTest &#123;
    LeaveFormService leaveFormService = new LeaveFormService();

    /**
     * 市场部员工请假单(72小时以上)测试用例
     * @throws ParseException
     */
    @Test
    public void createLeaveForm1() throws ParseException &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHH&quot;);
        LeaveForm form = new LeaveForm();
        form.setEmployeeId(8l);
        form.setStartTime(sdf.parse(&quot;2020032608&quot;));
        form.setEndTime(sdf.parse(&quot;2020040118&quot;));
        form.setFormType(1); //事假
        form.setReason(&quot;市场部员工请假单(72小时以上)&quot;);
        form.setCreateTime(new Date());
        LeaveForm savedForm = leaveFormService.createLeaveForm(form);
        System.out.println(savedForm.getFormId());
    &#125;

    /**
     * 市场部员工请假单(72小时内)测试用例
     * @throws ParseException
     */
    @Test
    public void createLeaveForm2() throws ParseException &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHH&quot;);
        LeaveForm form = new LeaveForm();
        form.setEmployeeId(8l);
        form.setStartTime(sdf.parse(&quot;2020032608&quot;));
        form.setEndTime(sdf.parse(&quot;2020032718&quot;));
        form.setFormType(1);
        form.setReason(&quot;市场部员工请假单(72小时内)&quot;);
        form.setCreateTime(new Date());
        LeaveForm savedForm = leaveFormService.createLeaveForm(form);
        System.out.println(savedForm.getFormId());
    &#125;

    /**
     * 研发部部门经理请假单测试用例
     * @throws ParseException
     */
    @Test
    public void createLeaveForm3() throws ParseException &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHH&quot;);
        LeaveForm form = new LeaveForm();
        form.setEmployeeId(2l);
        form.setStartTime(sdf.parse(&quot;2020032608&quot;));
        form.setEndTime(sdf.parse(&quot;2020040118&quot;));
        form.setFormType(1);
        form.setReason(&quot;研发部部门经理请假单&quot;);
        form.setCreateTime(new Date());
        LeaveForm savedForm = leaveFormService.createLeaveForm(form);
        System.out.println(savedForm.getFormId());
    &#125;

    /**
     * 总经理请假单测试用例
     * @throws ParseException
     */
    @Test
    public void createLeaveForm4() throws ParseException &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHH&quot;);
        LeaveForm form = new LeaveForm();
        form.setEmployeeId(1l);
        form.setStartTime(sdf.parse(&quot;2020032608&quot;));
        form.setEndTime(sdf.parse(&quot;2020040118&quot;));
        form.setFormType(1);
        form.setReason(&quot;总经理请假单&quot;);
        form.setCreateTime(new Date());
        LeaveForm savedForm = leaveFormService.createLeaveForm(form);
        System.out.println(savedForm.getFormId());
    &#125;
&#125;
</code></pre>
<h3 id="实现请假申请控制"><a href="#实现请假申请控制" class="headerlink" title="实现请假申请控制"></a>实现请假申请控制</h3><h5 id="Servlet-前后端整体交互-底层"><a href="#Servlet-前后端整体交互-底层" class="headerlink" title="Servlet 前后端整体交互(底层)"></a>Servlet 前后端整体交互(底层)</h5><p>leaveformservlet</p>
<pre><code class="java">controller.LeaveFormServlet.java
package com.imooc.oa.controller;

import com.alibaba.fastjson.JSON;
import com.imooc.oa.entity.LeaveForm;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.LeaveFormService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = &quot;LeaveFormServlet&quot;, urlPatterns = &quot;/leave/*&quot;)
public class LeaveFormServlet extends HttpServlet &#123;
    private LeaveFormService leaveFormService = new LeaveFormService();
    private Logger logger = LoggerFactory.getLogger(LoggerFactory.class);
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException &#123;
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        // http://localhost/leave/create
        String uri = request.getRequestURI();
        String methodName = uri.substring(uri.lastIndexOf(&quot;/&quot;) + 1); //截取本身就包含斜杠
        if (methodName.equals(&quot;create&quot;))&#123;

        &#125;
    &#125;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException &#123;
        this.doPost(request,response);
    &#125;

    /**
     * 创建请假单
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    private void create(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute(&quot;login_user&quot;);
        String formType = request.getParameter(&quot;formType&quot;);
        String strStartTime = request.getParameter(&quot;startTime&quot;);
        String strEndTime = request.getParameter(&quot;endTime&quot;);
        String reason = request.getParameter(&quot;reason&quot;);
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-HH&quot;);
        Map result = new HashMap();
        try &#123;
            LeaveForm form = new LeaveForm();
            form.setEmployeeId(user.getEmployeeId());
            form.setStartTime(sdf.parse(strStartTime));
            form.setEndTime(sdf.parse(strEndTime));
            form.setFormType(Integer.parseInt(formType));
            form.setReason(reason);
            form.setCreateTime(new Date());
            //2.调用业务逻辑方法
            leaveFormService.createLeaveForm(form);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;message&quot;, &quot;success&quot;);
        &#125; catch (Exception e)&#123;
            logger.error(&quot;请假申请异常&quot;,e);
            result.put(&quot;code&quot;, e.getClass().getSimpleName());
            result.put(&quot;message&quot;, e.getMessage());
        &#125;
        //3.组织相应数据
        String json = JSON.toJSONString(result); //将result转换为字符串
        response.getWriter().println(json);
    &#125;
&#125;
</code></pre>
<h3 id="完整实现请假申请功能"><a href="#完整实现请假申请功能" class="headerlink" title="完整实现请假申请功能"></a>完整实现请假申请功能</h3><pre><code class="java">controller.ForwardServlet.java
package com.imooc.oa.controller;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 页面跳转Servlet
 */
@WebServlet(name=&quot;ForwardServlet&quot;, urlPatterns = &quot;/forward/*&quot;)
public class ForwardServlet extends HttpServlet &#123;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String uri = request.getRequestURI();
        /** 动态提取 把第一个/抛出外 再去寻找第一个‘/’
         * /forward/form
         * /forward/a/b/c/form
         */
        String subUri = uri.substring(1);
        String page = subUri.substring(subUri.indexOf(&quot;/&quot;));
        request.getRequestDispatcher(page + &quot;.ftl&quot;).forward(request,response); //扩展名 + web.xml映射路径
    &#125;
&#125;
</code></pre>
<pre><code class="html">form.html 变换为 form.ftl 放在ftl内

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;请假申请&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
    &lt;style&gt;
        /*表单容器*/
        .ns-container &#123;
            position: absolute;
            width: 500px;
            height: 450px;
            top: 150px;
            left: 50%;
            margin-left: -250px;
            padding: 20px;
            box-sizing: border-box;
            border: 1px solid #cccccc;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;layui-row&quot;&gt;
    &lt;blockquote class=&quot;layui-elem-quote&quot;&gt;
        &lt;h2&gt;请假申请&lt;/h2&gt;
    &lt;/blockquote&gt;
    &lt;table id=&quot;grdNoticeList&quot; lay-filter=&quot;grdNoticeList&quot;&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;ns-container&quot;&gt;
    &lt;h1 style=&quot;text-align: center;margin-bottom: 20px&quot;&gt;请假申请单&lt;/h1&gt;
    &lt;form class=&quot;layui-form&quot;&gt;
        &lt;!--基本信息--&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;部门&lt;/label&gt;
            &lt;div class=&quot;layui-input-block&quot;&gt;
                &lt;div class=&quot;layui-col-md12&quot; style=&quot;padding-top: 10px;&quot;&gt;
                    研发部
                &lt;/div&gt;

            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;申请人&lt;/label&gt;
            &lt;div class=&quot;layui-input-block&quot;&gt;
                &lt;div class=&quot;layui-col-md12&quot; style=&quot;padding-top: 10px;&quot;&gt;
                    $&#123;current_employee.name&#125;[$&#123;current_employee.title&#125;]
                &lt;/div&gt;

            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!--请假类型下拉框--&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;请假类别&lt;/label&gt;
            &lt;div class=&quot;layui-input-block layui-col-space5&quot;&gt;
                    &lt;select name=&quot;formType&quot; lay-verify=&quot;required&quot; lay-filter=&quot;cityCode&quot;&gt;
                        &lt;option value=&quot;1&quot;&gt;事假&lt;/option&gt;
                        &lt;option value=&quot;2&quot;&gt;病假&lt;/option&gt;
                        &lt;option value=&quot;3&quot;&gt;工伤假&lt;/option&gt;
                        &lt;option value=&quot;4&quot;&gt;婚嫁&lt;/option&gt;
                        &lt;option value=&quot;5&quot;&gt;产假&lt;/option&gt;
                        &lt;option value=&quot;6&quot;&gt;丧假&lt;/option&gt;
                    &lt;/select&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;!--请假时长日期选择框--&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;请假时长&lt;/label&gt;
            &lt;div class=&quot;layui-input-block layui-col-space5&quot;&gt;
                    &lt;input name=&quot;leaveRange&quot; type=&quot;text&quot; class=&quot;layui-input&quot; id=&quot;daterange&quot; placeholder=&quot; - &quot;&gt;
                    &lt;input id=&quot;startTime&quot; name=&quot;startTime&quot; type=&quot;hidden&quot;&gt;
                    &lt;input id=&quot;endTime&quot; name=&quot;endTime&quot; type=&quot;hidden&quot;&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!--请假事由--&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;请假事由&lt;/label&gt;
            &lt;div class=&quot;layui-input-block layui-col-space5&quot;&gt;
                    &lt;input name=&quot;reason&quot; type=&quot;text&quot;  lay-verify=&quot;required|mobile&quot; placeholder=&quot;&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!--提交按钮--&gt;
        &lt;div class=&quot;layui-form-item &quot; style=&quot;text-align: center&quot;&gt;
                &lt;button class=&quot;layui-btn&quot; type=&quot;button&quot; lay-submit lay-filter=&quot;sub&quot;&gt;立即申请&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;

&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;!--Sweetalert2对话框--&gt;
&lt;script src=&quot;/resources/sweetalert2.all.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
        var layDate = layui.laydate; //Layui日期选择框JS对象
        var layForm = layui.form; //layui表单对象
        var $ = layui.$; //jQuery对象
        //日期时间范围
        layDate.render(&#123;
            elem: &#39;#daterange&#39;  //daterange渲染成日期选择框
            ,type: &#39;datetime&#39;
            ,range: true
            ,format: &#39;yyyy年M月d日H时&#39;
            ,done: function(value, start, end)&#123;
                //选择日期后出发的时间,设置startTime与endTime隐藏域
                var startTime = start.year + &quot;-&quot; + start.month + &quot;-&quot; + start.date + &quot;-&quot; + start.hours;
                var endTime = end.year + &quot;-&quot; + end.month + &quot;-&quot; + end.date + &quot;-&quot; + end.hours;
                console.info(&quot;请假开始时间&quot;,startTime);
                $(&quot;#startTime&quot;).val(startTime);
                console.info(&quot;请假结束时间&quot;,endTime);
                $(&quot;#endTime&quot;).val(endTime);
            &#125;
        &#125;);

        //表单提交时间
        layForm.on(&#39;submit(sub)&#39;, function(data)&#123;
            console.info(&quot;向服务器提交的表单数据&quot;,data.field);
            $.post(&quot;/leave/create&quot;,data.field,function (json) &#123;
                console.info(&quot;服务器返回数值&quot;,json);
                if(json.code == &quot;0&quot;)&#123;
                    /*SweetAlert2确定对话框*/
                    swal(&#123;
                        type: &#39;success&#39;,
                        html: &quot;&lt;h2&gt;请假单已提交,等待上级审批&lt;/h2&gt;&quot;,
                        confirmButtonText: &quot;确定&quot;
                    &#125;).then(function (result) &#123;
                        window.location.href=&quot;/forward/notice&quot;;
                    &#125;);
                &#125;else&#123;
                    swal(&#123;
                        type: &#39;warning&#39;,
                        html: &quot;&lt;h2&gt;&quot; + json.message + &quot;&lt;/h2&gt;&quot;,
                        confirmButtonText: &quot;确定&quot;
                    &#125;);
                &#125;
            &#125;,&quot;json&quot;);
            return false;
        &#125;);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h5 id="把localhost-x2F-index-主页添加数据"><a href="#把localhost-x2F-index-主页添加数据" class="headerlink" title="把localhost&#x2F;index 主页添加数据"></a>把localhost&#x2F;index 主页添加数据</h5><pre><code class="html">index.ftl中的47行到50行
 &lt;!--子节点--&gt;
&lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt;
 &lt;a href=&quot;#&#123;node.url&#125;&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
&lt;/dd&gt;
</code></pre>
<h3 id="请假审批功能"><a href="#请假审批功能" class="headerlink" title="请假审批功能"></a>请假审批功能</h3><pre><code class="java">leave_form.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.oa.dao.LeaveFormDao&quot;&gt;
    &lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.oa.entity.LeaveForm&quot;
        useGeneratedKeys=&quot;true&quot; keyProperty=&quot;formId&quot; keyColumn=&quot;form_id&quot;&gt;
        INSERT INTO adm_leave_form( employee_id, form_type, start_time, end_time, reason, create_time, state)
        VALUES ( #&#123;employeeId&#125;, #&#123;formType&#125;, #&#123;startTime&#125;, #&#123;endTime&#125;, #&#123;reason&#125;, #&#123;createTime&#125;, #&#123;state&#125;)
    &lt;/insert&gt;
    &lt;select id=&quot;selectByParams&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;java.util.Map&quot;&gt;
        select f.* ,e.name , d.*
        from
          adm_leave_form f,adm_process_flow pf , adm_employee e , adm_department d
        where
          f.form_id = pf.form_id
          and f.employee_id = e.employee_id
          and e.department_id = d.department_id
          and pf.state = #&#123;pf_state&#125; and pf.operator_id = #&#123;pf_operator_id&#125;
    &lt;/select&gt;
&lt;!--    &lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.LeaveForm&quot;&gt;--&gt;
&lt;!--        select * from adm_leave_form where form_id = #&#123;value&#125;--&gt;
&lt;!--    &lt;/select&gt;--&gt;

&lt;!--    &lt;update id=&quot;update&quot; parameterType=&quot;com.imooc.oa.entity.LeaveForm&quot;&gt;--&gt;
&lt;!--        UPDATE adm_leave_form SET employee_id = #&#123;employeeId&#125; , form_type = #&#123;formType&#125;, start_time = #&#123;startTime&#125;, end_time = #&#123;endTime&#125;, reason = #&#123;reason&#125;, state = #&#123;state&#125; ,create_time = #&#123;createTime&#125; WHERE form_id = #&#123;formId&#125;--&gt;
&lt;!--    &lt;/update&gt;--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">dao.LeaveFormDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.LeaveForm;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Map;

public interface LeaveFormDao &#123;
    public void insert(LeaveForm form);
    public List&lt;Map&gt; selectByParams(@Param(&quot;pf_state&quot;) String pfState , @Param(&quot;pf_operator_id&quot;) Long operatorId);
&#125; 
</code></pre>
<pre><code class="java">Test
  @Test
    public void testSelectByParams()&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            LeaveFormDao dao = sqlSession.getMapper(LeaveFormDao.class);
            List&lt;Map&gt; list = dao.selectByParams(&quot;process&quot;, 21L);
            System.out.println(list);
            return list;
        &#125;);
    &#125;
</code></pre>
<pre><code class="java">controller.LeaveFormServlet.java
   /**
     * 查询需要审核的请假单列表
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    private void getLeaveFormList(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        User user = (User) request.getSession().getAttribute(&quot;login_user&quot;);
        List&lt;Map&gt; formList = leaveFormService.getLeaveFormList(&quot;process&quot;, user.getEmployeeId());
        Map result = new HashMap();
        result.put(&quot;code&quot;,&quot;0&quot;); //服务器处理成功
        result.put(&quot;msg&quot;,&quot;&quot;); //服务器返回具体处理消息
        result.put(&quot;count&quot;, formList.size()); //数据总数
        result.put(&quot;data&quot;, formList); //当前显示的对象页表
        String json = JSON.toJSONString(result);
        response.getWriter().println(json);
    &#125;
</code></pre>
<h3 id="实现待审批请假列表"><a href="#实现待审批请假列表" class="headerlink" title="实现待审批请假列表"></a>实现待审批请假列表</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
    &lt;title&gt;请假审批&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
    &lt;style&gt;
        .form-item&#123;
            padding: 10px;
        &#125;
        .form-item-value&#123;
            padding: 10px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;layui-row&quot;&gt;
    &lt;blockquote class=&quot;layui-elem-quote&quot;&gt;
        &lt;h1&gt;请假审批&lt;/h1&gt;
    &lt;/blockquote&gt;
    &lt;!--待审批列表--&gt;
    &lt;table id=&quot;grdFormList&quot; lay-filter=&quot;grdFormList&quot;&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;!--请假详情对话框--&gt;
&lt;div id=&quot;divDialog&quot; style=&quot;display: none;padding: 10px&quot;&gt;
    &lt;form class=&quot;layui-form&quot;&gt;

        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;div class=&quot;layui-row&quot;&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;部门&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs4 form-item-value&quot; id=&quot;dname&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;姓名&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs4 form-item-value&quot; id=&quot;name&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-row&quot;&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;起始时间&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs4 form-item-value&quot; id=&quot;startTime&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;结束时间&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs4 form-item-value&quot; id=&quot;endTime&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-row&quot;&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;请假原因&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs10 form-item-value&quot; id=&quot;reason&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;!--表单Id--&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;formId&quot; id=&quot;formId&quot;&gt;
            &lt;!--审批结果--&gt;
            &lt;select name=&quot;result&quot; lay-verfity=&quot;required&quot;&gt;
                &lt;option value=&quot;approved&quot;&gt;同意&lt;/option&gt;
                &lt;option value=&quot;refused&quot;&gt;驳回&lt;/option&gt;
            &lt;/select&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!--审批意见--&gt;
            &lt;input type=&quot;text&quot; name=&quot;reason&quot; placeholder=&quot;请输入审批意见&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;/&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;button class=&quot;layui-btn layui-btn-fluid &quot; lay-submit lay-filter=&quot;audit&quot;&gt;确认提交&lt;/button&gt;

        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;

&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/resources/sweetalert2.all.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var $ = layui.$;
    //将毫秒数转换为&quot;yyyy-MM-dd HH时&quot;字符串格式
    function formatDate(time)&#123;
        var newDate = new Date(time);
        return newDate.getFullYear() + &quot;-&quot; +
            (newDate.getMonth() + 1) + &quot;-&quot; + newDate.getDate()
            + &quot; &quot; + newDate.getHours() + &quot;时&quot;;
    &#125;
    // 将table渲染为数据表格
    layui.table.render(&#123;
        elem : &quot;#grdFormList&quot; , //选择器
        id : &quot;grdFormList&quot; , //id
        url : &quot;/leave/list&quot; , //ajax请求url
        page : false , //是否分页 true-是 false-否
        cols :[[ //列描述
            &#123;title : &quot;&quot; , width:70 , style : &quot;height:60px&quot; , type:&quot;numbers&quot;&#125;, // numbers代表序号列
            &#123;field : &quot;create_time&quot; , title : &quot;申请时间&quot; , width : 150 , templet: function (d) &#123;
                //templet代表对数据进行加工后再显示
                return formatDate(d.create_time)
            &#125;&#125;,
            &#123;field : &quot;form_type&quot; , title : &quot;类型&quot; , width : 100 , templet: function(d)&#123;
                switch (d.form_type) &#123;
                    case 1:
                        return &quot;事假&quot;;
                    case 2:
                        return &quot;病假&quot;;
                    case 3:
                        return &quot;工伤假&quot;;
                    case 4:
                        return &quot;婚假&quot;;
                    case 5:
                        return &quot;产假&quot;;
                    case 6:
                        return &quot;丧假&quot;;
                &#125;
            &#125;&#125;,
            &#123;field : &quot;department_name&quot; , title : &quot;部门&quot; , width : 100&#125;,
            &#123;field : &quot;name&quot; , title : &quot;员工&quot; , width : 100&#125;,
            &#123;field : &quot;start_time&quot; , title : &quot;起始时间&quot; , width : 150, templet: function (d) &#123;
                    return formatDate(d.start_time)
                &#125;&#125;,
            &#123;field : &quot;end_time&quot; , title : &quot;结束时间&quot; , width : 150 , templet: function (d) &#123;
                    return formatDate(d.end_time)
                &#125;&#125;,
            &#123;field : &quot;reason&quot; , title : &quot;请假原因&quot; , width : 350 &#125;,
            &#123;title : &quot;&quot; , width:150 ,type:&quot;space&quot; , templet : function(d)&#123;
                var strRec = JSON.stringify(d);
                console.info(&quot;请假单数据&quot;, d);
                console.info(&quot;请假单数据&quot;, strRec);
                //将请假单数据存放至data-laf属性中
                return &quot;&lt;button class=&#39;layui-btn layui-btn-danger layui-btn-sm btn-audit&#39; data-laf=&quot; + strRec + &quot; &gt;审批&lt;/button&gt;&quot;;
            &#125;&#125;
        ]]
    &#125;)

    // 绑定每一行的审批按钮
    $(document).on(&quot;click&quot; , &quot;.btn-audit&quot; , function()&#123;
        //初始化表单
        $(&quot;#divDialog form&quot;)[0].reset();
        $(&quot;#divDialog form form-item-value&quot;).text(&quot;&quot;);
        //获取当前点击按钮的请假单数据,回填至显示项 json对象 内置数据显示页面
        var laf = $(this).data(&quot;laf&quot;);
        $(&quot;#dname&quot;).text(laf.department_name);
        $(&quot;#name&quot;).text(laf.name);
        $(&quot;#startTime&quot;).text(formatDate(laf.start_time));
        $(&quot;#endTime&quot;).text(formatDate(laf.end_time));
        $(&quot;#reason&quot;).text(laf.reason);
        $(&quot;#formId&quot;).val(laf.form_id);
        //弹出layui对话框
        layui.layer.open(&#123;
            type : &quot;1&quot; , //页面层
            title : &quot;请假审批&quot; , //标题
            content : $(&quot;#divDialog&quot;) , //指定对话框容器对象
            area : [&quot;500px&quot; , &quot;400px&quot;] , //尺寸
            end : function()&#123; //销毁后触发事件
                $(&quot;#divDialog&quot;).hide();
            &#125;
        &#125;)
    &#125;)
    /**
     * 提交审批数据 本质:发送Ajax请求
     */
    layui.form.on(&quot;submit(audit)&quot; , function(data)&#123;
        $.ajax(&#123;
            url : &quot;/leave/audit&quot;, //审核URL
            data : data.field ,
            type : &quot;post&quot; ,
            dataType : &quot;json&quot; ,
            success: function (json) &#123;
                //关闭所有layui对话框
                layui.layer.closeAll();
                //显示处理结果
                if(json.code == &quot;0&quot;)&#123;
                    swal(&#123;
                        type: &#39;success&#39;,
                        html: &quot;&lt;h2&gt;请假已审批完毕&lt;/h2&gt;&quot;,
                        confirmButtonText: &quot;确定&quot;
                    &#125;).then(function (result) &#123;
                        window.location.href=&quot;/forward/notice&quot;;
                    &#125;);
                &#125;else&#123;
                    swal(&#123;
                        type: &#39;warning&#39;,
                        html: &quot;&lt;h2&gt;&quot; + json.message + &quot;&lt;/h2&gt;&quot;,
                        confirmButtonText: &quot;确定&quot;
                    &#125;);
                &#125;
            &#125;
        &#125;)
        return false;
    &#125;)

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="实现审批业务逻辑"><a href="#实现审批业务逻辑" class="headerlink" title="实现审批业务逻辑"></a>实现审批业务逻辑</h3><pre><code class="java">service.LeaveFormService.java
 public void audit(Long formId, Long operatorId, String result, String reason)&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            //1.无论同意/驳回, 当前任务状态变更为complete
            ProcessFlowDao processFlowDao = sqlSession.getMapper(ProcessFlowDao.class);
            List&lt;ProcessFlow&gt; flowList = processFlowDao.selectByFormId(formId);
            if (flowList.size() == 0)&#123;
                throw new BussinessException(&quot;PF001&quot;, &quot;无效的审批流程&quot;);//自定义错误抛出
            &#125;
            //获取当前任务ProcessFlow对象
            List&lt;ProcessFlow&gt; processList = flowList.stream().filter(p-&gt;p.getOperatorId() == operatorId &amp;&amp; p.getState().equals(&quot;process&quot;)).collect(Collectors.toList());
            ProcessFlow process = null;
            if (processList.size() == 0)&#123;
                throw new BussinessException(&quot;PF002&quot;, &quot;未找到待处理任务&quot;);
            &#125;else&#123;
                process = processList.get(0);
                process.setState(&quot;complete&quot;);
                process.setResult(result);
                process.setReason(reason);
                process.setAuditTime(new Date());
                processFlowDao.update(process);
            &#125;
            LeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);
            LeaveForm form = leaveFormDao.selectById(formId);
            //2.如果当前任务是最后一个节点,代表流程结束,更新请假单状态对应的approved/refused
            if (process.getIsLast() == 1)&#123;
                form.setState(result); // approved\refused
                leaveFormDao.update(form);
            &#125;else &#123;
                //readyList包含所有后续任务节点
                List&lt;ProcessFlow&gt; readyList = flowList.stream().filter(p-&gt;p.getState().equals(&quot;ready&quot;)).collect(Collectors.toList());
                //3.如果当前任务不是最后一个节点且审批通过,那下一个节点的状态从ready变为process
                if (result.equals(&quot;approved&quot;))&#123;
                    ProcessFlow readyProcess = readyList.get(0);
                    readyProcess.setState(&quot;process&quot;);
                    processFlowDao.update(readyProcess);
                &#125; else if (result.equals(&quot;refused&quot;)) &#123;
                    //4.如果当前任务不是最后一个切点且审核驳回,则后续所有任务状态变为cancel,请假单状态变为refused
                    for (ProcessFlow p : readyList)&#123;
                        p.setState(&quot;cancel&quot;);
                        processFlowDao.update(p);
                    &#125;
                    form.setState(&quot;refused&quot;);
                    leaveFormDao.update(form);
                &#125;
            &#125;
            return null;
        &#125;);
    &#125;
</code></pre>
<pre><code class="java">test.LeaveFormServiceTest.java (在数据库中增加新建查询 导入训练素材的 请假单审核测试数据.sql)
   /**
     * 请假3天以上,部门经理审批通过
     */
    @Test
    public void audit1()&#123;
        leaveFormService.audit(31l,2l,&quot;approved&quot;,&quot;祝早日康复&quot;);
    &#125;

    /**
     * 请假3天以上,部门经理审批驳回
     */
    @Test
    public void audit2()&#123;
        leaveFormService.audit(32l,2l,&quot;refused&quot;,&quot;工期紧张,请勿拖延&quot;);
    &#125;

    /**
     * 部门经理请假,总经理审批通过
     */
    @Test
    public void audit3()&#123;
        leaveFormService.audit(33l,1l,&quot;approved&quot;,&quot;同意&quot;);
    &#125;
</code></pre>
<h3 id="完整实现请假审批"><a href="#完整实现请假审批" class="headerlink" title="完整实现请假审批"></a>完整实现请假审批</h3><pre><code class="java">controller.LeaveFormServlet.java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123;
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        // http://localhost/leave/create
        String uri = request.getRequestURI();
        String methodName = uri.substring(uri.lastIndexOf(&quot;/&quot;) + 1); //截取本身就包含斜杠
        if (methodName.equals(&quot;create&quot;))&#123;
            this.create(request,response);
        &#125;else if (methodName.equals(&quot;list&quot;))&#123;
            this.getLeaveFormList(request,response);
        &#125; else if (methodName.equals(&quot;audit&quot;)) &#123;
            this.audit(request,response);
        &#125;
    &#125;
...
...
...
  /**
     * 处理审批操作
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    private void audit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String formId = request.getParameter(&quot;formId&quot;);
        String result = request.getParameter(&quot;result&quot;);
        String reason = request.getParameter(&quot;reason&quot;);
        User user = (User) request.getSession().getAttribute(&quot;login_user&quot;);
        Map mpResult = new HashMap();
        try &#123;
            leaveFormService.audit(Long.parseLong(formId), user.getEmployeeId(), result,reason);
            mpResult.put(&quot;code&quot;, &quot;0&quot;);
            mpResult.put(&quot;message&quot;, &quot;success&quot;);

        &#125; catch (Exception e) &#123;
            logger.error(&quot;请假单审核失败&quot;, e);
            mpResult.put(&quot;code&quot;, e.getClass().getSimpleName());
            mpResult.put(&quot;message&quot;, e.getMessage());
        &#125;
        String json = JSON.toJSONString(mpResult);
        response.getWriter().println(json);
    &#125;
</code></pre>
<h3 id="实现系统消息业务逻辑"><a href="#实现系统消息业务逻辑" class="headerlink" title="实现系统消息业务逻辑"></a>实现系统消息业务逻辑</h3><pre><code class="java">entity.Notice.java
    private Long noticeId;
    private Long receiverId;
    private String content;
    private Date createTime;
    public Notice()&#123;

    &#125;
    public Notice(Long receiverId, String content)&#123;
        this.receiverId = receiverId;
        this.content = content;
        this.createTime = new Date();
    &#125;
    Getter + Setter
</code></pre>
<pre><code class="java">service.LeaveFormService.java
package com.imooc.oa.service;

import com.imooc.oa.dao.EmployeeDao;
import com.imooc.oa.dao.LeaveFormDao;
import com.imooc.oa.dao.NoticeDao;
import com.imooc.oa.dao.ProcessFlowDao;
import com.imooc.oa.entity.Employee;
import com.imooc.oa.entity.LeaveForm;
import com.imooc.oa.entity.Notice;
import com.imooc.oa.entity.ProcessFlow;
import com.imooc.oa.service.exception.BussinessException;
import com.imooc.oa.util.MybatisUtils;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * 请假单流程服务
 */
public class LeaveFormService &#123;
    /**
     * 创建请假单
     * @param form 前端输入的请假单数据
     * @return 持久化后的请假单对象
     */
    public LeaveForm createLeaveForm(LeaveForm form)&#123;
            LeaveForm savedForm = (LeaveForm) MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            //1.持久化form表单数据,8级以下员工表单状态位processing,8级(总经理)状态位approved
            EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);
            Employee employee = employeeDao.selectById(form.getEmployeeId());
            if (employee.getLevel() == 8)&#123;
                form.setState(&quot;approved&quot;);
            &#125;else &#123;
                form.setState(&quot;processing&quot;);
            &#125;
            LeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);
            leaveFormDao.insert(form);
            //2.增加第一条流程数据,说明表单已提交,状态位complete 初始化数据↓
            ProcessFlowDao processFlowDao = sqlSession.getMapper(ProcessFlowDao.class);
            ProcessFlow flow1 = new ProcessFlow();
            flow1.setFormId(form.getFormId());
            flow1.setOperatorId(employee.getEmployeeId());
            flow1.setAction(&quot;apply&quot;);
            flow1.setCreateTime(new Date());
            flow1.setOrderNo(1);
            flow1.setState(&quot;complete&quot;);
            flow1.setIsLast(0);
            processFlowDao.insert(flow1);
            //3.分情况创建其余流程数据 employee.xml(动态sql语句)
                // 3.1 7级以下员工,生成部门经理审批任务,请假时间大于36小时(后期单独处理),还需生成总经理审批任务
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-HH时&quot;);
                NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);
            if (employee.getLevel() &lt; 7)&#123;
                //动态sql EmployeeDao
                Employee dmanager = employeeDao.selectLeader(employee);
                ProcessFlow flow2 = new ProcessFlow();
                flow2.setFormId(form.getFormId());
                flow2.setOperatorId(dmanager.getEmployeeId());
                flow2.setAction(&quot;audit&quot;);//审批任务
                flow2.setCreateTime(new Date());
                flow2.setOrderNo(2);
                flow2.setState(&quot;process&quot;);
                long diff = form.getEndTime().getTime() - form.getStartTime().getTime(); //毫秒数
                float hours = diff/(1000*60*60) * 1f;
                if (hours &gt;= BussinessConstants.MANAGER_AUDIT_HOURS)&#123;
                    flow2.setIsLast(0); //最后节点
                    processFlowDao.insert(flow2);
                    Employee manager = employeeDao.selectLeader(dmanager);//总经理
                    ProcessFlow flow3 = new ProcessFlow();
                    flow3.setFormId(form.getFormId());
                    flow3.setOperatorId(manager.getEmployeeId());
                    flow3.setAction(&quot;audit&quot;);
                    flow3.setCreateTime(new Date());
                    flow3.setState(&quot;ready&quot;);
                    flow3.setOrderNo(3);
                    flow3.setIsLast(1);
                    processFlowDao.insert(flow3);
                &#125;else &#123;//小于3天&#123;
                    flow2.setIsLast(1);
                    processFlowDao.insert(flow2);
                &#125;
                //请假单已提交消息
                String noticeContent = String.format(&quot;您的请假申请[%s-%s]已提交,请等待上级审批.&quot;
                        , sdf.format(form.getStartTime()), sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(employee.getEmployeeId(),noticeContent));
                //通知部门经理审批消息
                noticeContent = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot;,
                        employee.getTitle() , employee.getName() ,sdf.format(form.getStartTime()),sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(dmanager.getEmployeeId(),noticeContent));
            &#125; else if (employee.getLevel() == 7) &#123;//部门经理
                //3.2 7级员工,生成总经理审批任务
                Employee manager = employeeDao.selectLeader(employee);
                ProcessFlow flow = new ProcessFlow();
                flow.setFormId(form.getFormId());
                flow.setOperatorId(manager.getEmployeeId());
                flow.setAction(&quot;audit&quot;);
                flow.setCreateTime(new Date());
                flow.setState(&quot;process&quot;);
                flow.setOrderNo(2);
                flow.setIsLast(1);
                processFlowDao.insert(flow);
                //请假单已提交消息
                String noticeContent = String.format(&quot;您的请假申请[%s-%s]已提交,请等待上级审批.&quot;
                        , sdf.format(form.getStartTime()), sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(employee.getEmployeeId(),noticeContent));
                //通知总经理审批消息
                noticeContent = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot;,
                        employee.getTitle() , employee.getName() ,sdf.format(form.getStartTime()),sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(manager.getEmployeeId(),noticeContent));
            &#125;else if (employee.getLevel() == 8)&#123;
                //3.3 8级员工,生成总经理审批任务,系统自动通过
                ProcessFlow flow = new ProcessFlow();
                flow.setFormId(form.getFormId());
                flow.setOperatorId(employee.getEmployeeId());
                flow.setAction(&quot;audit&quot;);
                flow.setResult(&quot;自动通过&quot;);
                flow.setCreateTime(new Date());
                flow.setAuditTime(new Date());
                flow.setState(&quot;complete&quot;);
                flow.setOrderNo(2);
                flow.setIsLast(1);
                processFlowDao.insert(flow);
                String noticeContent = String.format(&quot;您的请假申请[%s-%s]系统已自动批准通过.&quot; ,
                        sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(employee.getEmployeeId(),noticeContent));
            &#125;
            return form;
        &#125;);
        return savedForm;
    &#125;
    /**
     * 获取指定任务状态及指定经办人对应的请假单列表
     * @param pfState ProcessFlow任务状态
     * @param operatorId 经办人编号
     * @return 请假单及相关数据列表
     */
    public List&lt;Map&gt; getLeaveFormList(String pfState, Long operatorId)&#123;
        return (List&lt;Map&gt;)MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            LeaveFormDao dao = sqlSession.getMapper(LeaveFormDao.class);
            List&lt;Map&gt; formList = dao.selectByParams(pfState, operatorId);
            return formList;
        &#125;);
    &#125;
    /**
     * 审核请假单
     * @param formId 表单编号
     * @param operatorId 经办人(当前登录员工)
     * @param result 审批结果
     * @param reason 审批意见
     */
    public void audit(Long formId, Long operatorId, String result, String reason)&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            //1.无论同意/驳回, 当前任务状态变更为complete
            ProcessFlowDao processFlowDao = sqlSession.getMapper(ProcessFlowDao.class);
            List&lt;ProcessFlow&gt; flowList = processFlowDao.selectByFormId(formId);
            if (flowList.size() == 0)&#123;
                throw new BussinessException(&quot;PF001&quot;, &quot;无效的审批流程&quot;);//自定义错误抛出
            &#125;
            //获取当前任务ProcessFlow对象
            List&lt;ProcessFlow&gt; processList = flowList.stream().filter(p-&gt;p.getOperatorId() == operatorId &amp;&amp; p.getState().equals(&quot;process&quot;)).collect(Collectors.toList());
            ProcessFlow process = null;
            if (processList.size() == 0)&#123;
                throw new BussinessException(&quot;PF002&quot;, &quot;未找到待处理任务&quot;);
            &#125;else&#123;
                process = processList.get(0);
                process.setState(&quot;complete&quot;);
                process.setResult(result);
                process.setReason(reason);
                process.setAuditTime(new Date());
                processFlowDao.update(process);
            &#125;
            LeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);
            LeaveForm form = leaveFormDao.selectById(formId);
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-HH时&quot;);
            EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);
            Employee employee = employeeDao.selectById(form.getEmployeeId());//表单提交人信息
            Employee operator = employeeDao.selectById(operatorId);//任务经办人信息
            NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);
            //2.如果当前任务是最后一个节点,代表流程结束,更新请假单状态对应的approved/refused
            if (process.getIsLast() == 1)&#123;
                form.setState(result); // approved\refused
                leaveFormDao.update(form);
                String strResult = null;
                if (result.equals(&quot;aproved&quot;))&#123;
                    strResult = &quot;批准&quot;;
                &#125; else if (result.equals(&quot;refused&quot;)) &#123;
                    strResult = &quot;驳回&quot;;
                &#125;
                String noticeContent = String.format(&quot;您的请假申请[%s-%s]%s%s已%s,审批意见:%s,审批流程已结束&quot;
                        sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()),
                        operator.getTitle(),operator.getName(), //批准\驳回
                        strResult,reason);//发给表单提交人的通知
                noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent));
            &#125;else &#123;
                //readyList包含所有后续任务节点
                List&lt;ProcessFlow&gt; readyList = flowList.stream().filter(p-&gt;p.getState().equals(&quot;ready&quot;)).collect(Collectors.toList());
                //3.如果当前任务不是最后一个节点且审批通过,那下一个节点的状态从ready变为process
                if (result.equals(&quot;approved&quot;))&#123;
                    ProcessFlow readyProcess = readyList.get(0);
                    readyProcess.setState(&quot;process&quot;);
                    processFlowDao.update(readyProcess);
                    //消息1: 通知表单提交人,部门经理已经审批通过,交由上级继续审批
                    String noticeContent1 = String.format(&quot;您的请假申请[%s-%s]%s%s已批准,审批意见:%s ,请继续等待上级审批&quot; ,
                            sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()),
                            operator.getTitle() , operator.getName(),reason);
                    noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1));

                    //消息2: 通知总经理有新的审批任务
                    String noticeContent2 = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot; ,
                            employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()));
                    noticeDao.insert(new Notice(readyProcess.getOperatorId(),noticeContent2));

                    //消息3: 通知部门经理(当前经办人),员工的申请单你已批准,交由上级继续审批
                    String noticeContent3 = String.format(&quot;%s-%s提起请假申请[%s-%s]您已批准,审批意见:%s,申请转至上级领导继续审批&quot; ,
                            employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), reason);
                    noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent3));
                &#125; else if(result.equals(&quot;refused&quot;)) &#123;
                    //4.如果当前任务不是最后一个节点且审批驳回,则后续所有任务状态变为cancel,请假单状态变为refused
                    for(ProcessFlow p:readyList)&#123;
                        p.setState(&quot;cancel&quot;);
                        processFlowDao.update(p);
                    &#125;
                    form.setState(&quot;refused&quot;);
                    leaveFormDao.update(form);
                    //消息1: 通知申请人表单已被驳回
                    String noticeContent1 = String.format(&quot;您的请假申请[%s-%s]%s%s已驳回,审批意见:%s,审批流程已结束&quot; ,
                            sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()),
                            operator.getTitle() , operator.getName(),reason);
                    noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1));

                    //消息2: 通知经办人表单&quot;您已驳回&quot;
                    String noticeContent2 = String.format(&quot;%s-%s提起请假申请[%s-%s]您已驳回,审批意见:%s,审批流程已结束&quot; ,
                            employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), reason);
                    noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent2));
                &#125;
            &#125;
            return null;
        &#125;);
</code></pre>
<h3 id="完整实现系统消息功能"><a href="#完整实现系统消息功能" class="headerlink" title="完整实现系统消息功能"></a>完整实现系统消息功能</h3><pre><code class="java">dao.NoticeDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Notice;

import java.util.List;

public interface NoticeDao &#123;
    public void insert(Notice notice);
    public List&lt;Notice&gt; selectByReceiverId(Long receiverId);
&#125;
</code></pre>
<pre><code class="java">service.NoticeService.java
package com.imooc.oa.service;

import com.imooc.oa.dao.NoticeDao;
import com.imooc.oa.entity.Notice;
import com.imooc.oa.util.MybatisUtils;

import java.util.List;

/**
 * 消息服务
 */
public class NoticeService &#123;
    /**
     * 查询指定员工的系统消息
     * @param receiverId
     * @return 最近100条消息列表
     */
    public List&lt;Notice&gt; getNoticeList(Long receiverId)&#123;
        return (List) MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);
            return noticeDao.selectByReceiverId(receiverId);
        &#125;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">controller.NoticeServlet.java
package com.imooc.oa.controller;

import com.alibaba.fastjson.JSON;
import com.imooc.oa.entity.Notice;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.NoticeService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@WebServlet(name = &quot;NoticeServlet&quot; , urlPatterns = &quot;/notice/list&quot;)
public class NoticeServlet extends HttpServlet &#123;
    private NoticeService noticeService = new NoticeService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        User user = (User)request.getSession().getAttribute(&quot;login_user&quot;);
        List&lt;Notice&gt; noticeList = noticeService.getNoticeList(user.getEmployeeId());
        Map result = new HashMap&lt;&gt;();
        result.put(&quot;code&quot;, &quot;0&quot;);
        result.put(&quot;msg&quot;, &quot;&quot;);
        result.put(&quot;count&quot;, noticeList.size());
        result.put(&quot;data&quot;, noticeList);
        String json = JSON.toJSONString(result);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        response.getWriter().println(json);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">resources.mappers.notice.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.oa.dao.NoticeDao&quot;&gt;
    &lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.oa.entity.Notice&quot;
            useGeneratedKeys=&quot;true&quot; keyProperty=&quot;noticeId&quot; keyColumn=&quot;notice_id&quot;&gt;
        INSERT INTO sys_notice( receiver_id, content, create_time) VALUES (#&#123;receiverId&#125;, #&#123;content&#125;, #&#123;createTime&#125;)
    &lt;/insert&gt;

    &lt;select id=&quot;selectByReceiverId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.Notice&quot;&gt;
        select * from sys_notice where receiver_id = #&#123;value&#125; order by create_time desc limit 0,100
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="html">index.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课网办公OA系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    $&#123;current_employee.name&#125;[$&#123;current_department.departmentName&#125;-$&#123;current_employee.title&#125;]
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;
                &lt;#list node_list as node&gt;
                &lt;!--父节点--&gt;
                    &lt;#if node.nodeType == 1&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;$&#123;node.nodeId&#125;&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                    &lt;/#if&gt;
                    &lt;#if node.nodeType == 2&gt;
                &lt;!--子节点--&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt;
                    &lt;a href=&quot;$&#123;node.url&#125;&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                &lt;/dd&gt;
                    &lt;/#if&gt;
                &lt;/#list&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; src=&quot;/forward/notice&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下 一开始先dl与dd对齐[程序维护方便]
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;)
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">notice.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;系统通知&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;layui-row&quot;&gt;
    &lt;blockquote class=&quot;layui-elem-quote&quot;&gt;
        &lt;h2&gt;系统通知&lt;/h2&gt;
    &lt;/blockquote&gt;
    &lt;table id=&quot;grdNoticeList&quot; lay-filter=&quot;grdNoticeList&quot;&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    layui.table.render(&#123;
        elem : &quot;#grdNoticeList&quot; ,
        id : &quot;grdNoticeList&quot; ,
        url : &quot;/notice/list&quot; ,
        page : false ,
        cols :[[
            &#123;field : &quot;&quot; , title : &quot;序号&quot; , width:&quot;10%&quot; , style : &quot;height:60px&quot; , type:&quot;numbers&quot;&#125;,
            &#123;field : &quot;create_time&quot; , title : &quot;通知时间&quot; , width : &quot;20%&quot; , templet: function (d) &#123;
                    var newDate = new Date(d.createTime);
                    return newDate.getFullYear() + &quot;-&quot; +
                        (newDate.getMonth() + 1) + &quot;-&quot; + newDate.getDate()
                        + &quot; &quot; + newDate.getHours() + &quot;:&quot; + newDate.getMinutes() + &quot;:&quot; + newDate.getSeconds();
                &#125;&#125;,
            &#123;field : &quot;content&quot; , title : &quot;通知内容&quot; , width : &quot;60%&quot;&#125;
        ]]
    &#125;)

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/11/07/后端/MyBatis实现OA系统项目实战/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/10/30/后端/MyBatis基础与进阶/">
        <h2>
            MyBatis基础与进阶
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/30
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="MyBatis-ORM-框架基础"><a href="#MyBatis-ORM-框架基础" class="headerlink" title="MyBatis[ORM]框架基础"></a>MyBatis[ORM]框架基础</h1><h3 id="软件开发中框架"><a href="#软件开发中框架" class="headerlink" title="软件开发中框架"></a>软件开发中框架</h3><ul>
<li>框架式可被应用开发者定制的应用骨架</li>
<li>框架是一种规则，保证开发者遵循相同的方式开发程序</li>
<li>框架提倡”不要重复造轮子”,对基础功能进行封装</li>
</ul>
<h3 id="框架的优点"><a href="#框架的优点" class="headerlink" title="框架的优点"></a>框架的优点</h3><ul>
<li>极大提高了开发效率</li>
<li>统一的编码规则，利于团队管理</li>
<li>灵活配置的应用，拥有更好的维护性</li>
</ul>
<h3 id="SSM开发框架"><a href="#SSM开发框架" class="headerlink" title="SSM开发框架"></a>SSM开发框架</h3><ul>
<li><strong>Spring</strong>对象容器框架(框架的框架) [提供底层对象的管理]</li>
<li><strong>SpringMVC</strong>替代servlet更有效的开发 [提供Web界面的交互]</li>
<li><strong>MyBatis</strong>简化数据库的开发 [数据库增删改查便捷操作]</li>
</ul>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><ul>
<li>MyBatis是优秀的<strong>持久</strong>层框架(将内存中的数据保存到数据库中 以防止重启后数据丢失)</li>
<li>MyBatis使用XML将SQL与程序解耦，便于维护[改代码 改xml更方便]</li>
<li>MyBatis是JDBC的延伸</li>
</ul>
<h3 id="MyBatis开发流程【推荐使用Maven】"><a href="#MyBatis开发流程【推荐使用Maven】" class="headerlink" title="MyBatis开发流程【推荐使用Maven】"></a>MyBatis开发流程【推荐使用Maven】</h3><ul>
<li>引入MyBatis依赖</li>
<li>创建核心配置文件</li>
<li>创建实体(<strong>Entity</strong>)类</li>
<li>创建<strong>Mapper</strong>映射文件</li>
<li>初始化SessionFactory(绘画工厂 读取配置文件 加载Mapper映射)</li>
<li>利用SqlSession对象操作数据</li>
</ul>
<h3 id="单元测试与JUnit4"><a href="#单元测试与JUnit4" class="headerlink" title="单元测试与JUnit4"></a>单元测试与JUnit4</h3><h5 id="单元测试-用于测试方法的方法"><a href="#单元测试-用于测试方法的方法" class="headerlink" title="单元测试(用于测试方法的方法)"></a>单元测试(用于测试方法的方法)</h5><ul>
<li>单元测试是指对软件中的最小可测试单元进行检查和验证</li>
<li>测试用例是指写一段代码对已有功能(方法)进行校验</li>
<li>JUnit4是Java中最著名的单元测试工具，主流IDE内置支持</li>
</ul>
<h3 id="JUnit4使用方法"><a href="#JUnit4使用方法" class="headerlink" title="JUnit4使用方法"></a>JUnit4使用方法</h3><ul>
<li>引入JUnit Jar包或增加Maven依赖</li>
<li>编写测试用例验证目标方法是否正确运行</li>
<li>在测试用例上增加**@Test**注解开始单元测试</li>
</ul>
<p>如果插件plug报错 点settings 找到 Build,Execution,Deployment → Build Tools → Maven 修改下面的三个地址到Maven</p>
<blockquote>
<p><strong>Maven home path</strong>:  D:&#x2F;apache-maven-3.9.5<br><strong>User settings files</strong>:  D:\apache-maven-3.9.5\conf\settings.xml<br><strong>Local repository</strong>:  D:\apache-maven-3.9.5\repository</p>
</blockquote>
<p><u>Maven工程有专门测试用例的 test包</u><br><strong>方法命名：在原方法前增加test前缀</strong>    <strong>Class命名：在原有命名后增加Test</strong></p>
<p><strong><span style = "color : red">快速生成类的测试用例</span></strong> &#x3D;&gt; 选中类 → Code → Generate → Test<br>按住Ctrl可以多选执行多个测试用例类<br>如果想运行所有测试用例类 工程上点右键 → Run ‘All Test’</p>
<pre><code class="java">Calculator.java
package org.example;

public class Calculator &#123;
    public int add(int a, int b)&#123;
        return a + b;
    &#125;
    public int substract(int a, int b)&#123;
        return a - b;
    &#125;
    public int multiply(int a, int b)&#123;
        return a * b;
    &#125;
    public float divide(int a, int b)&#123;
        if (b==0)&#123;
            throw new ArithmeticException(&quot;除数不能为0&quot;);
        &#125;
        return (a*1f) / b;
    &#125;
&#125;
</code></pre>
<pre><code class="java">CalculatorTest.java
import org.example.Calculator;
import org.junit.Test;

public class CalculatorTest &#123;
    private Calculator cal = new Calculator();
    @Test
    public void testAdd()&#123;
        int result = cal.add(1,2);
        System.out.println(result);
    &#125;
    @Test
    public void testSubstract()&#123;
        int result = cal.substract(1,2);
        System.out.println(result);
    &#125;
    @Test
    public void testMultiply()&#123;
        int result = cal.multiply(1,2);
        System.out.println(result);
    &#125;
    @Test
    public void testDivide()&#123;
        float result = cal.divide(1,2);
        System.out.println(result);
    &#125;
    @Test
    public void testDivide1()&#123;
        float result = cal.divide(1,0);
        System.out.println(result);
    &#125;
&#125;
</code></pre>
<h3 id="MyBatis环境配置"><a href="#MyBatis环境配置" class="headerlink" title="MyBatis环境配置"></a>MyBatis环境配置</h3><h5 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h5><ul>
<li>MyBatis采用XML格式配置数据库环境信息</li>
<li>MyBatis环境配置标签**&lt; environment &gt;**</li>
<li>environment包含数据库驱动、URL、用户名与密码</li>
</ul>
<pre><code class="xml">mybatis-config.xml
&lt;!--配置环境,不同的环境不同的id名字--&gt;
&lt;enviroment id=&quot;dev&quot;&gt;
    &lt;!--采用JDBC方式对数据库事务进行commit/rollback--&gt;
    &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
    &lt;!--采用连接池方式管理数据库连接--&gt;
    &lt;dataSource type=&quot;POOLED&quot;&gt;
        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/dataSource&gt;
&lt;/enviroment&gt;
</code></pre>
<pre><code class="xml">&lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;JUnit4_Maven&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;http://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>可以在右侧加载内置<strong>Database数据库</strong></p>
<pre><code class="xml">&lt;configuration&gt;
    &lt;environments default=&quot;&quot;&gt; 
        &lt;environment id=&quot;&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; 
            &lt;dataSource type=&quot;&quot;&gt;&lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;   &lt;!--环境配置标签--&gt;
    &lt;environments default=&quot;dev&quot;&gt; &lt;!--当环境默认数据源为dev时候使用运行的代码[不同id来切换]--&gt;
        &lt;environment id=&quot;dev&quot;&gt;  &lt;!--唯一标识--&gt;
            &lt;!--采用JDBC方式对数据库事务进行管理--&gt;
            &lt;transactionManager type=&quot;&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--采用连接池方式管理数据库连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTFF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><ul>
<li>SqlSessionFactory是MyBatis的核心对象</li>
<li>用于初始化MyBatis, 创建SqlSession对象</li>
<li>SqlSession对象提供了数据表CRUD对应方法</li>
<li>保证SqlSessionFactory在应用中全局唯一</li>
</ul>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;   &lt;!--环境配置标签--&gt;
    &lt;environments default=&quot;prd&quot;&gt; &lt;!--当环境默认数据源为dev时候使用运行的代码[不同id来切换]--&gt;
        &lt;environment id=&quot;dev&quot;&gt;  &lt;!--唯一标识--&gt;
            &lt;!--采用JDBC方式对数据库事务进行管理--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--采用连接池方式管理数据库连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
        &lt;environment id=&quot;prd&quot;&gt;
            &lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--采用连接池方式管理数据库连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.1.155:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">test-MyBatisTestor.java
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import java.io.IOException;
import java.io.Reader;
import java.sql.Connection;

//JUNIT单元测试类
public class MyBatisTestor &#123;
    @Test
    public void testSqlSessionFactory() throws IOException &#123;
        //利用Reader加载classpath下的mybatis-config.xml核心配置文件
        Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);//按照字符流读取
        //初始化SqlSessionFactory对象,同时解析mybatis-config.xml文件
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);//read解析上面的对象
        System.out.println(&quot;SessionFactory加载成功&quot;);
        SqlSession sqlSession = null;
        try&#123;
            //创建SqlSession对象,SqlSession是JDBC的扩展类,用于数据库交互
            sqlSession = sqlSessionFactory.openSession();
            //创建数据库连接(测试用)
            Connection connection = sqlSession.getConnection();
            System.out.println(connection);
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            if (sqlSession != null)&#123;
                //如果type=&quot;POOLED&quot;,代表使用连接池,close则是将连接回收到连接池中
                //如果type=&quot;UNPOOLED&quot;,代表直连,close则会调用Connection.close()方法关闭连接
                sqlSession.close();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="保证SqlSessionFactory在应用中全局唯一-创建一个工具类"><a href="#保证SqlSessionFactory在应用中全局唯一-创建一个工具类" class="headerlink" title="保证SqlSessionFactory在应用中全局唯一 [创建一个工具类]"></a>保证SqlSessionFactory在应用中全局唯一 [创建一个工具类]</h6><p>static块用于初始化静态对象</p>
<pre><code class="java">MyBatisUtils.java
package com.imooc.mybatis.utils;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.Reader;
//MaBatisUtils工具类,创建全局唯一的SqlSessionFactory对象
public class MyBatisUtils &#123;
    //利用static(静态)属于类不属于对象,且全局唯一
    private static SqlSessionFactory sqlSessionFactory = null;
    static&#123; //利用静态块在初始化类时实例化sqlSessionFactory
        //利用Reader加载classpath下的mybatis-config.xml核心配置文件
        Reader reader = null;//按照字符流读取
        try &#123;
            reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);
            //初始化SqlSessionFactory对象,同时解析mybatis-config.xml文件
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);//read解析上面的对象
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
            //初始化错误时,通过抛出异常ExceptionInInitializerError通知调用者
            throw new ExceptionInInitializerError(e);
        &#125;
    &#125;
    public static SqlSession openSession()&#123;
        return sqlSessionFactory.openSession();
    &#125;

    public static void closeSession(SqlSession session)&#123;
        if (session != null)&#123;
            session.close();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">MyBatisTestor.java
import com.imooc.mybatis.utils.MyBatisUtils;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import java.io.IOException;
import java.io.Reader;
import java.sql.Connection;

//JUNIT单元测试类
public class MyBatisTestor &#123;
    @Test
    public void testSqlSessionFactory() throws IOException &#123;
        //利用Reader加载classpath下的mybatis-config.xml核心配置文件
        Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);//按照字符流读取
        //初始化SqlSessionFactory对象,同时解析mybatis-config.xml文件
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);//read解析上面的对象
        System.out.println(&quot;SessionFactory加载成功&quot;);
        SqlSession sqlSession = null;
        try&#123;
            //创建SqlSession对象,SqlSession是JDBC的扩展类,用于数据库交互
            sqlSession = sqlSessionFactory.openSession();
            //创建数据库连接(测试用)
            Connection connection = sqlSession.getConnection();
            System.out.println(connection);
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            if (sqlSession != null)&#123;
                //如果type=&quot;POOLED&quot;,代表使用连接池,close则是将连接回收到连接池中
                //如果type=&quot;UNPOOLED&quot;,代表直连,close则会调用Connection.close()方法关闭连接
                sqlSession.close();
            &#125;
        &#125;
    &#125;
    @Test
    public void testMyBatisUtils() throws Exception&#123;
        SqlSession sqlSession = null;
        try&#123;
            sqlSession = MyBatisUtils.openSession();
            Connection connection = sqlSession.getConnection();
            System.out.println(connection);
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(sqlSession);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="MyBatis数据查询"><a href="#MyBatis数据查询" class="headerlink" title="MyBatis数据查询"></a>MyBatis数据查询</h3><h6 id="用测试类去测试代码"><a href="#用测试类去测试代码" class="headerlink" title="用测试类去测试代码"></a>用测试类去测试代码</h6><pre><code class="java">test-java-MyBatisTestor.java
import com.imooc.mybatis.MyBatisUtils;
import com.imooc.mybatis.entity.Goods;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import java.io.IOException;
import java.io.Reader;
import java.sql.Connection;
import java.util.List;

//JUNIT单元测试类
public class MyBatisTestor &#123;
    @Test
    public void testSqlSessionFactory() throws IOException &#123;
        //利用Reader加载classpath下的mybatis-config.xml核心配置文件
        Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);//按照字符流读取
        //初始化SqlSessionFactory对象,同时解析mybatis-config.xml文件
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);//read解析上面的对象
        System.out.println(&quot;SessionFactory加载成功&quot;);
        SqlSession sqlSession = null;
        try&#123;
            //创建SqlSession对象,SqlSession是JDBC的扩展类,用于数据库交互
            sqlSession = sqlSessionFactory.openSession();
            //创建数据库连接(测试用)
            Connection connection = sqlSession.getConnection();
            System.out.println(connection);
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            if (sqlSession != null)&#123;
                //如果type=&quot;POOLED&quot;,代表使用连接池,close则是将连接回收到连接池中
                //如果type=&quot;UNPOOLED&quot;,代表直连,close则会调用Connection.close()方法关闭连接
                sqlSession.close();
            &#125;
        &#125;
    &#125;
    /**
     * MyBatisUtils使用指南
     * @throws Exception
     */
    @Test
    public void testMyBatisUtils() throws Exception &#123;
        SqlSession sqlSession = null;
        try &#123;
            sqlSession = MyBatisUtils.openSession();
            Connection connection = sqlSession.getConnection();
            System.out.println(connection);
        &#125;catch (Exception e)&#123;
            throw e;
        &#125; finally &#123;
            MyBatisUtils.closeSession(sqlSession);
        &#125;
    &#125;

    /**
     * select查询语句执行
     * @throws Exception
     */
    @Test
    public void testSelectAll() throws Exception &#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            List&lt;Goods&gt; list = session.selectList(&quot;goods.selectAll&quot;);
            for(Goods g : list)&#123;
                System.out.println(g.getTitle());
            &#125;
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="MyBatis数据查询步骤"><a href="#MyBatis数据查询步骤" class="headerlink" title="MyBatis数据查询步骤"></a>MyBatis数据查询步骤</h5><ul>
<li><h6 id="创建实体类-Entity-x2F-工具类-Utils"><a href="#创建实体类-Entity-x2F-工具类-Utils" class="headerlink" title="创建实体类(Entity) &#x2F;工具类(Utils)"></a>创建实体类(Entity) &#x2F;工具类(Utils)</h6></li>
</ul>
<pre><code class="java">Goods.java
private Integer goodsId;//商品编号
    private String title;//标题
    private String subTitle;//子标题
    private Float originalCost;//原始价格
    private Float currentPrice;//当前价格
    private Float discount;//折扣率
    private Integer isFreeDelivery;//是否包邮 ,1-包邮 0-不包邮
    private Integer categoryId;//分类编号
    Getter+Setter...
</code></pre>
<pre><code class="java">MyBatisUtils.java
package com.imooc.mybatis;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.Reader;
//MaBatisUtils工具类,创建全局唯一的SqlSessionFactory对象
public class MyBatisUtils &#123;
    //利用static(静态)属于类不属于对象,且全局唯一
    private static SqlSessionFactory sqlSessionFactory = null;
    static&#123; //利用静态块在初始化类时实例化sqlSessionFactory
        //利用Reader加载classpath下的mybatis-config.xml核心配置文件
        Reader reader = null;//按照字符流读取
        try &#123;
            reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);
            //初始化SqlSessionFactory对象,同时解析mybatis-config.xml文件
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);//read解析上面的对象
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
            //初始化错误时,通过抛出异常ExceptionInInitializerError通知调用者
            throw new ExceptionInInitializerError(e);
        &#125;
    &#125;

    /**
     * openSession 创建一个新的SqlSession对象
     * @return SqlSession对象
     */
    public static SqlSession openSession()&#123;
        return sqlSessionFactory.openSession();
    &#125;

    /**
     * 释放一个有效的SqlSession对象
     * @param session 准备释放SqlSession对象
     */
    public static void closeSession(SqlSession session)&#123;
        if(session != null)&#123;
            session.close();
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><h6 id="创建Mapper-XML-在resources下创建-表属性和字段一一对应"><a href="#创建Mapper-XML-在resources下创建-表属性和字段一一对应" class="headerlink" title="创建Mapper XML (在resources下创建) 表属性和字段一一对应"></a>创建Mapper XML (在resources下创建) 表属性和字段一一对应</h6></li>
</ul>
<p>若要让mybatis认识xml 要在mybatis-config.xml里面声明 增加&lt; mappers &gt;</p>
<pre><code class="xml">goods.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;goods&quot;&gt; &lt;!--区分不同的工作空间--&gt;
    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        select * from t_goods order by goods_id desc limit 10&lt;!--将每一条记录包装成↑的goods对象--&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;   &lt;!--环境配置标签--&gt;
    &lt;environments default=&quot;prd&quot;&gt; &lt;!--当环境默认数据源为dev时候使用运行的代码[不同id来切换]--&gt;
        &lt;environment id=&quot;dev&quot;&gt;  &lt;!--唯一标识--&gt;
            &lt;!--采用JDBC方式对数据库事务进行管理--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--采用连接池方式管理数据库连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
        &lt;environment id=&quot;prd&quot;&gt;
            &lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--采用连接池方式管理数据库连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.1.155:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/goods.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li><h6 id="编写-lt-select-gt-SQL标签"><a href="#编写-lt-select-gt-SQL标签" class="headerlink" title="编写&lt; select &gt;SQL标签"></a>编写&lt; select &gt;SQL标签</h6></li>
</ul>
<pre><code class="xml">goods.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;goods&quot;&gt; &lt;!--区分不同的工作空间--&gt;
    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        select * from t_goods order by goods_id desc limit 10&lt;!--将每一条记录包装成↑的goods对象--&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ul>
<li><h6 id="开启驼峰命名映射"><a href="#开启驼峰命名映射" class="headerlink" title="开启驼峰命名映射"></a>开启驼峰命名映射</h6></li>
</ul>
<pre><code class="xml">&lt;settings&gt;&lt;!--开启驼峰命名转换 goods_id → goodsId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
</code></pre>
<ul>
<li><h6 id="新增-lt-mapper-gt"><a href="#新增-lt-mapper-gt" class="headerlink" title="新增&lt; mapper &gt;"></a>新增&lt; mapper &gt;</h6></li>
</ul>
<pre><code class="xml">mybatis-config.xml
&lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/goods.xml&quot;/&gt;
    &lt;/mappers&gt;
</code></pre>
<ul>
<li><h6 id="SqlSession执行select语句"><a href="#SqlSession执行select语句" class="headerlink" title="SqlSession执行select语句"></a>SqlSession执行select语句</h6></li>
</ul>
<h3 id="SQL传参-动态传入数据"><a href="#SQL传参-动态传入数据" class="headerlink" title="SQL传参[动态传入数据]"></a>SQL传参[动态传入数据]</h3><pre><code class="java">goods.xml
&lt;select id=&quot;selectById&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
    select * from t_goods where goods_id = #&#123;value&#125;
&lt;/select&gt;

MyBatisTestor.java
@Test
    public void testSelectById() throws Exception&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            Goods goods = session.selectOne(&quot;goods.selectById&quot;, 1602);
            System.out.println(goods.getTitle());
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">goods.xml
&lt;select id=&quot;selectByPriceRange&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
            select * from t_goods
            where
                current_price between #&#123;min&#125; and #&#123;max&#125;
            order by current_price
            limit 0,#&#123;limit&#125;
    &lt;/select&gt;
        
MyBatisTestor.java (多参数传递要指定Map接口)
@Test
    public void selectByPriceRange() throws Exception&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            Map param = new HashMap();
            param.put(&quot;min&quot;, 100);
            param.put(&quot;max&quot;, 500);
            param.put(&quot;limit&quot;, 10);
            List&lt;Goods&gt; list = session.selectList(&quot;goods.selectByPriceRange&quot;,param);
            for (Goods g:list)&#123;
                System.out.println(g.getTitle() + &quot;:&quot; + g.getCurrentPrice());
            &#125;
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<h3 id="获取多表关联查询结果-Map"><a href="#获取多表关联查询结果-Map" class="headerlink" title="获取多表关联查询结果[Map]"></a><span style = "color:red">获取多表关联查询结果</span>[Map]</h3><p><strong>LinkedHashMap链表</strong>形式的HashMap不会出现乱序</p>
<blockquote>
<p>利用LinkedHashMap保存多表关联结果<br>MyBatis会将每一条记录包装为LinkedHashMap对象<br>key是字段名，value是字段对应的值，字段类型根据表结构进行自动判断<br>优点：易于扩展，易于使用<br>缺点：太过灵活，无法进行编译时检查</p>
</blockquote>
<pre><code class="java">goods.xml
&lt;select id=&quot;selectGoodsMap&quot; resultType=&quot;java.util.LinkedHashMap&quot;&gt;
        select g.* , c.category_name from t_goods g , t_category c
        where g.category_id = c.category_id
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java [map类 或 实体类]
@Test
    public void selectGoodsMap() throws Exception&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            List&lt;Map&gt; list = session.selectList(&quot;goods.selectGoodsMap&quot;);
            for (Map map : list)&#123;
                System.out.println(map);
            &#125;
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
&#125;
</code></pre>
<h3 id="ResultMap结果映射-多表查询结果-多人协作首选"><a href="#ResultMap结果映射-多表查询结果-多人协作首选" class="headerlink" title="ResultMap结果映射[多表查询结果 多人协作首选]"></a>ResultMap结果映射[多表查询结果 多人协作首选]</h3><h6 id="把复杂的查询结果映射成DTO对象来进行保存-调用的时候轻松获得属性-书写大量的映射规则"><a href="#把复杂的查询结果映射成DTO对象来进行保存-调用的时候轻松获得属性-书写大量的映射规则" class="headerlink" title="把复杂的查询结果映射成DTO对象来进行保存 调用的时候轻松获得属性 [书写大量的映射规则]"></a>把复杂的查询结果映射成DTO对象来进行保存 调用的时候轻松获得属性 [书写大量的映射规则]</h6><ul>
<li>ResultMap可以将查询结果映射为复杂类型的Java对象</li>
<li>ResultMap适用于Java对象保存多表关联结果</li>
<li>ResultMap支持对象关联查询等高级特性</li>
</ul>
<p>结果用java对象进行保存 dto包[<strong>GoodsDTO</strong>]是数据传输对象包[<strong>扩展包</strong>] 为了扩展的需要可以扩展</p>
<pre><code class="xml">结果映射规则进行赋值 转换为哪个dto
查询出来后每次都会給goods中的goodsId进行赋值
用GoodsDTO.java 来承载多表关联查询的结果

GoodsDTO.java
public class GoodsDTO &#123;
    private Goods goods = new Goods();
    private String categoryName;
    private String test;
    Getter+Setter
&#125;

Goods.java
public class Goods &#123;
    private Integer goodsId;//商品编号
    private String title;//标题
    private String subTitle;//子标题
    private Float originalCost;//原始价格
    private Float currentPrice;//当前价格
    private Float discount;//折扣率
    private Integer isFreeDelivery;//是否包邮 ,1-包邮 0-不包邮
    private Integer categoryId;//分类编号
&#125;
</code></pre>
<pre><code class="java">MyBatisTestor.java
@Test
    public void selectGoodsDTO() throws Exception&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            List&lt;GoodsDTO&gt; list = session.selectList(&quot;goods.selectGoodsDTO&quot;);
            for (GoodsDTO g : list)&#123;
                System.out.println(g.getGoods().getTitle());
            &#125;
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<pre><code class="xml">Goods.xml
&lt;resultMap id=&quot;rmGoods&quot; type=&quot;com.imooc.mybatis.dto.GoodsDTO&quot;&gt;
        &lt;id property=&quot;goods.goodsId&quot; column=&quot;goods_id&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;goods.title&quot; column=&quot;title&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.originalCost&quot; column=&quot;original_cost&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.currentPrice&quot; column=&quot;current_price&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.discount&quot; column=&quot;discount&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.isFreeDelivery&quot; column=&quot;is_free_delivery&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.categoryId&quot; column=&quot;category_id&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;categoryName&quot; column=&quot;category_name&quot;/&gt;
        &lt;result property=&quot;test&quot; column=&quot;test&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectGoodsDTO&quot; resultMap=&quot;rmGoods&quot;&gt;
        select g.* , c.category_name from t_goods g , t_category c
        where g.category_id = c.category_id
    &lt;/select&gt;
</code></pre>
<hr>
<img src="https://raw.githubusercontent.com/P-luminary/images/a5a064ed1e21f056da98a03d61f9970413b74d57/data/ResultMap%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84.jpg"  />

<pre><code class="xml">GoodsDTO.java
public class GoodsDTO &#123;
    private Goods goods = new Goods();
    private Category category = new Category();
    private String test;
    Getter+Setter...
&#125;

Category.java
public class Category &#123; //标准的Java Bean 换DTO的  private Category category = new Category();
    private Integer categoryId;
    private String categoryName;
    private Integer parentId;
    private Integer categoryLevel;
    private Integer categoryOrder;
    Getter+Setter...
&#125;
</code></pre>
<pre><code class="xml">Goods.xml
&lt;resultMap id=&quot;rmGoods&quot; type=&quot;com.imooc.mybatis.dto.GoodsDTO&quot;&gt;
        &lt;id property=&quot;goods.goodsId&quot; column=&quot;goods_id&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;goods.title&quot; column=&quot;title&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.originalCost&quot; column=&quot;original_cost&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.currentPrice&quot; column=&quot;current_price&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.discount&quot; column=&quot;discount&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.isFreeDelivery&quot; column=&quot;is_free_delivery&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.categoryId&quot; column=&quot;category_id&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;category.categoryId&quot; column=&quot;category_id&quot;/&gt;
        &lt;result property=&quot;category.categoryName&quot; column=&quot;category_name&quot;/&gt;
        &lt;result property=&quot;category.parentId&quot; column=&quot;parent_id&quot;/&gt;
        &lt;result property=&quot;category.categoryLevel&quot; column=&quot;category_level&quot;/&gt;
        &lt;result property=&quot;category.categoryOrder&quot; column=&quot;category_order&quot;/&gt;
        &lt;result property=&quot;test&quot; column=&quot;test&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectGoodsDTO&quot; resultMap=&quot;rmGoods&quot;&gt;
        select g.* , c.*,&#39;1&#39; from t_goods g , t_category c
        where g.category_id = c.category_id
    &lt;/select&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java
@Test
    public void selectGoodsDTO() throws Exception&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            List&lt;GoodsDTO&gt; list = session.selectList(&quot;goods.selectGoodsDTO&quot;);
            for (GoodsDTO g : list)&#123;
                System.out.println(g.getGoods().getTitle());
            &#125;
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<h3 id="MyBatis数据插入操作"><a href="#MyBatis数据插入操作" class="headerlink" title="MyBatis数据插入操作"></a>MyBatis数据插入操作</h3><h5 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h5><ul>
<li>数据库事务是保证数据操作完整性的基础</li>
</ul>
<p>客户端[Java] → 事务日志[增删改查数据] → 向MySQL写入<strong>commit</strong> → 数据表作为更新数据 【若执行roll back后事务日志和数据表的数据都会被清除】</p>
<h5 id="MyBatis写操作包含三种"><a href="#MyBatis写操作包含三种" class="headerlink" title="MyBatis写操作包含三种"></a>MyBatis写操作包含三种</h5><ul>
<li><h6 id="插入-lt-insert-gt"><a href="#插入-lt-insert-gt" class="headerlink" title="插入&lt; insert &gt;"></a>插入&lt; insert &gt;</h6></li>
</ul>
<pre><code class="xml">goods.xml 新增操作
 &lt;!--flushCache=&quot;true&quot;在sql执行后强制清空缓存--&gt;
&lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.mybatis.entity.Goods&quot;flushCache=&quot;true&quot;&gt;
 INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id)
 VALUES (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;)
  &lt;selectKey resultType=&quot;Integer&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt; &lt;!--主键自动生成--&gt;
    select last_insert_id()
  &lt;/selectKey&gt;
&lt;/insert&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java
@Test
    public void selectInsert() throws Exception&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            Goods goods = new Goods();
            goods.setTitle(&quot;测试商品&quot;);
            goods.setSubTitle(&quot;测试子标题&quot;);
            goods.setOriginalCost(200f);
            goods.setCurrentPrice(100f);
            goods.setDiscount(0.5f);
            goods.setIsFreeDelivery(1);
            goods.setCategoryId(43);
            //insert()方法返回值代表本次成功插入的记录总数
            int num = session.insert(&quot;goods.insert&quot;, goods);
            session.commit();
            System.out.println(goods.getGoodsId());
        &#125;catch (Exception e)&#123;
            if (session != null)&#123;
                session.rollback();
            &#125;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<ul>
<li><h6 id="更新-lt-update-gt"><a href="#更新-lt-update-gt" class="headerlink" title="更新 &lt; update&gt;"></a>更新 &lt; update&gt;</h6>不推荐goods.set…来插入，而是推荐使用获取到原始的商品信息<code>Goods goods = session.selectOne(&quot;goods.selectById&quot;, 739);</code>再在原始信息上做出调整和更新。对数据影响最小</li>
</ul>
<pre><code class="xml">goods.xml
 &lt;update id=&quot;update&quot; parameterType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        UPDATE t_goods
        SET
          title = #&#123;title&#125;,
          sub_title = #&#123;subTitle&#125;,
          original_cost = #&#123;originalCost&#125;,
          current_price = #&#123;currentPrice&#125;,
          discount = #&#123;discount&#125;,
          is_free_delivery = #&#123;isFreeDelivery&#125;,
          category_id = #&#123;categoryId&#125;
        WHERE
          good_id = #&#123;goodsId&#125; &lt;!--对主键进行筛选--&gt;
    &lt;/update&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java
 @Test
    public void testUpdate() throws Exception&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            Goods goods = session.selectOne(&quot;goods.selectById&quot;, 739);//得到指定编号的对象
            goods.setTitle(&quot;更新测试商品&quot;);
            int num = session.update(&quot;goods.update&quot;, goods);
            session.commit();
        &#125;catch (Exception e)&#123;
            if (session!=null)
                session.rollback();
        &#125;
    &#125;
</code></pre>
<ul>
<li><h6 id="删除-lt-delete-gt"><a href="#删除-lt-delete-gt" class="headerlink" title="删除 &lt; delete &gt;"></a>删除 &lt; delete &gt;</h6>大多数删除操作都是根据主键来运行的</li>
</ul>
<pre><code class="xml">good.xml
&lt;delete id=&quot;delete&quot; parameterType=&quot;integer&quot;&gt;
    delete from t_goods where goods_id = #&#123;value&#125;
&lt;/delete&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java
 @Test
    public void Delete()&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            int num = session.delete(&quot;goods.delete&quot;, 739);
            session.commit();
        &#125;catch (Exception e)&#123;
            if (session!=null)&#123;
                session.rollback();
            &#125;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<h3 id="SelectKey与UserGeneratedKeys的区别"><a href="#SelectKey与UserGeneratedKeys的区别" class="headerlink" title="SelectKey与UserGeneratedKeys的区别"></a><span style = "color:red">SelectKey</span>与<span style = "color:red">UserGeneratedKeys</span>的区别</h3><pre><code class="xml">SelectKey属性用法
&lt;insert id=&quot;insert&quot; parameterType=&quot;com.itlaoqi.mybatis.entity.Goods&quot;&gt;
  INSERT INTO SQL语句
============================获取主键值===============================(↑案例)
 &lt;selectKey resultType=&quot;Integer&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt;
   select last_insert_id()
 &lt;/selectKey&gt;
&lt;/insert&gt;

★ selectKey标签需要明确编写获取最新主键的SQL语句  获取主键 ★
★ selectKey适用于所有的关系型数据库 ★
★ selectKey标签是通用方案,适用于所有数据库,但编写麻烦 ★
</code></pre>
<pre><code class="html">UserGeneratedKeys属性用法
&lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
   userGeneratedKeys=&quot;true&quot;
   keyProperty=&quot;goodsId&quot; &lt;!--主键值--&gt;
   keyColumn=&quot;goods_id&quot;&gt; &lt;!--字段名--&gt;
  INSERT INTO SQL语句
&lt;/insert&gt;
★ useGeneratedKeys属性会自动根据驱动生成对应SQL语句 自动获取主键 ★
★ useGeneratedKeys只支持&quot;自增主键&quot;类型的数据库 ★
★ useGeneratedKeys属性只支持&quot;自增主键&quot;数据库,使用简单
</code></pre>
<h6 id="在Oracle中selectKey的用法"><a href="#在Oracle中selectKey的用法" class="headerlink" title="在Oracle中selectKey的用法"></a>在Oracle中selectKey的用法</h6><pre><code class="xml">&lt;insert id=&quot;insert&quot; parameterType=&quot;com.itlaoqi.mybatis.entity.Goods&quot;&gt;
  InSERT INTO SQL语句
  &lt;selectKey resultType=&quot;Integer&quot; order=“BEFORE” keyProperty=&quot;goodsId&quot;&gt;
      SELECT seq_goods.nextval as id from dual  
  &lt;/selectKey&gt;
&lt;/insert&gt;
</code></pre>
<h3 id="SQL注入攻击-缺少转义操作"><a href="#SQL注入攻击-缺少转义操作" class="headerlink" title="SQL注入攻击[缺少转义操作]"></a>SQL注入攻击[缺少转义操作]</h3><ul>
<li>SQL注入是指攻击者利用SQL漏洞，绕过系统约束，越权获取数据的攻击方式</li>
</ul>
<pre><code class="sql">SQLd代码:
&quot;select * from a where name =&#39;&quot; + name + &quot; &#39;&quot;;

正常情况下:
name:张三 → select * from a where name = &#39;张三&#39;;

SQL注入攻击:
name:&#39; or 1=1 or 1=&#39;
select * from a whrer name = &quot; or 1=1 or 1=&quot;
</code></pre>
<h5 id="MyBatis两种传值方式"><a href="#MyBatis两种传值方式" class="headerlink" title="MyBatis两种传值方式"></a>MyBatis两种传值方式</h5><ul>
<li><p><strong>${}</strong><u>文本替换</u>(原文传值)(<u>产生的sql语句绝不能是外界输入的</u>), 未经过任何处理对SQL文本替换 {<em>根据前台输入的条件不同来选择不同的字段排序 没有对输入的数据进行预编译处理 导致输入的内容变成了sql的一部分</em>}</p>
<p><code>$&#123;order&#125;</code><br><code>param.put(&quot;order&quot;,&quot; order by title desc&quot;);</code></p>
<blockquote>
<p>用${}原传值：select * from t_goods where title &#x3D; ‘ ‘ or 1 &#x3D;1 or title &#x3D; ‘【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版’”); 成为sql的一部分</p>
</blockquote>
</li>
<li><p><span style = "color:red"><strong>#{}</strong></span><u>预编译传值</u>, 使用预编译传值可以预防SQL注入</p>
<blockquote>
<p>用#{}预编译：select * from t_goods where title &#x3D; “ ‘ ‘ or 1 &#x3D;1 or title &#x3D; ‘【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版’”);  #输入的会变成字符串</p>
</blockquote>
</li>
</ul>
<pre><code class="xml">goods.xml
&lt;select id=&quot;selectByTitle&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
  select * from t_goods where title = $&#123;title&#125;
&lt;/select&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java
 @Test
    public void testSelectByTitle()&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            Map param = new HashMap();
            pparam.put(&quot;title&quot;,&quot;&#39;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#39;&quot;);
            param.put(&quot;order&quot;, &quot; order by title desc&quot;);
//param.put(&quot;titile&quot;,&quot;&#39;&#39; or 1=1 or title=&#39;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#39;&quot;);
//用$&#123;&#125;原传值：select * from t_goods where title = &#39;&#39; or 1 =1 or title = &#39;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#39;&quot;); 成为sql的一部分
//用#&#123;&#125;预编译：select * from t_goods where title = &quot;&#39;&#39; or 1 =1 or title = &#39;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#39;&quot;);
            List&lt;Goods&gt; list = session.selectList(&quot;goods.selectByTitle&quot;, param);
            for(Goods g:list)&#123;
                System.out.println(g.getTitle() + &quot;:&quot; + g.getCurrentPrice());
            &#125;
        &#125;catch (Exception e)&#123;
            if (session!=null)&#123;
                session.rollback();
            &#125;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<p><img src="https://github.com/P-luminary/images/blob/master/data/MyBatis%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg?raw=true" alt="使用上传照片"></p>
<h1 id="MyBatis进阶教程"><a href="#MyBatis进阶教程" class="headerlink" title="MyBatis进阶教程"></a>MyBatis进阶教程</h1><h3 id="MyBatis日志管理"><a href="#MyBatis日志管理" class="headerlink" title="MyBatis日志管理"></a>MyBatis日志管理</h3><h6 id="什么是日志"><a href="#什么是日志" class="headerlink" title="什么是日志"></a>什么是日志</h6><ul>
<li>日志文件是用于记录系统操作事件的记录文件或文件集合</li>
<li>日志保存历史数据, 是诊断问题以及理解系列活动的重要依据</li>
</ul>
<blockquote>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/012b30f438d154d94993533f729816ae155eff3a/data/MyBatis%E4%B8%A4%E5%A4%A7%E6%97%A5%E5%BF%97.png" alt="上传照片"></p>
<pre><code class="xml">goods.xml
&lt;select id=&quot;selectByTitle&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        select * from t_goods where title = #&#123;title&#125;
            $&#123;order&#125;
    &lt;/select&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java
@Test
    public void testSelectByTitle()&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            Map param = new HashMap();
            param.put(&quot;title&quot;,&quot;&#39;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#39;&quot;);
            param.put(&quot;order&quot;, &quot; order by title desc&quot;);
//param.put(&quot;titile&quot;,&quot;&#39;&#39; or 1=1 or title=&#39;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#39;&quot;);
//用$&#123;&#125;原传值：select * from t_goods where title = &#39;&#39; or 1 =1 or title = &#39;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#39;&quot;); 成为sql的一部分
//用#&#123;&#125;预编译：select * from t_goods where title = &quot;&#39;&#39; or 1 =1 or title = &#39;【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版&#39;&quot;);
            List&lt;Goods&gt; list = session.selectList(&quot;goods.selectByTitle&quot;, param);
            for(Goods g:list)&#123;
                System.out.println(g.getTitle() + &quot;:&quot; + g.getCurrentPrice());
            &#125;
        &#125;catch (Exception e)&#123;
            if (session!=null)&#123;
                session.rollback();
            &#125;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
   &#125;
</code></pre>
<pre><code class="xml">logback.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;[%thread] %d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
&lt;!--            23:39:16.761 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.--&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;!--
        日志输出级别(优先级高到低):
        error: 错误 - 系统的故障日志
        warn: 警告 - 存在风险或使用不当的日志
        info: 一般性消息
        debug: 程序内部用于调试信息
        trace: 程序运行的跟踪信息
     --&gt;
&lt;!--生产环境最低级别设置info以上 开发环境最低级别设置debug以上方便调试--&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="MyBatis动态SQL"><a href="#MyBatis动态SQL" class="headerlink" title="MyBatis动态SQL"></a>MyBatis动态SQL</h3><h5 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h5><ul>
<li>动态SQL是指根据参数数据动态组织SQL的技术</li>
</ul>
<pre><code class="html">&lt;select id=&quot;dynamicSQL&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com...Goods&quot;&gt;
    select * from t_goods
    where     &lt;!--动态增加SQL的数据--&gt;
        &lt;if test=&quot;categoryId != null&quot;&gt;
            and category_id=#&#123;categoryId&#125;
        &lt;/if&gt;
        &lt;if test=&quot;currentPrice != null&quot;&gt;
            and current_price &amp;lt; #&#123;currentPrice&#125;
        &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<pre><code class="xml">goods.xml
&lt;select id=&quot;dynamicSQL&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        select * from t_goods
        &lt;where&gt;    &lt;!--根据查询条件动态增加SQL的数据--&gt;
        &lt;if test=&quot;categoryId != null&quot;&gt;
            and category_id=#&#123;categoryId&#125;
        &lt;/if&gt;
        &lt;if test=&quot;currentPrice != null&quot;&gt;
            and current_price &amp;lt; #&#123;currentPrice&#125;
        &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;where&gt;&lt;/where&gt;  where标签会动态的对子sql进行判断
</code></pre>
<h3 id="MyBatis二级缓存-可共享对象"><a href="#MyBatis二级缓存-可共享对象" class="headerlink" title="MyBatis二级缓存 (可共享对象)"></a>MyBatis二级缓存 (可共享对象)</h3><p>sql语句第一次查询 sql存储在硬盘上<br>优化：第一次查询的时候放在某个内存 再次访问就很快 (缓存)</p>
<ul>
<li>一级缓存默认开启，缓存范围SqlSession会话</li>
<li>二级缓存手动开启，属于范围Mapper Namespace</li>
</ul>
<h3 id="二级缓存运行规则"><a href="#二级缓存运行规则" class="headerlink" title="二级缓存运行规则"></a>二级缓存运行规则</h3><ul>
<li>二级开启后默认所有查询操作均使用缓存</li>
<li>写操作<u>commit提交时对该namespace缓存<strong>强制清空</strong></u></li>
<li>配置<strong>useCache&#x3D;false</strong>可以不用缓存</li>
<li>配置<strong>flushCache&#x3D;true</strong>代表强制清空缓存</li>
</ul>
<pre><code class="java">@Test
public void testLv1Cache()&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            Goods goods = session.selectOne(&quot;goods.selectById&quot;, 1603);
            session.commit();//commit提交时对该namespace缓存强制清空
            Goods goods1 = session.selectOne(&quot;goods.selectById&quot;, 1603);
            System.out.println(goods.hashCode() + &quot;:&quot; + goods1.hashCode());
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>Goods goods &#x3D; session.selectOne(“goods.selectById”, 1603);<br>session.commit();&#x2F;&#x2F;commit提交时对该namespace缓存强制清空<br>缓存和语句距离太短 资源浪费 使用率不高哦</p>
</blockquote>
<p><code>&lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;600000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;</code></p>
<h6 id="运行结果只出现一条sql语句-结果的goods-hasCode的结果来自同一块内存区域"><a href="#运行结果只出现一条sql语句-结果的goods-hasCode的结果来自同一块内存区域" class="headerlink" title="运行结果只出现一条sql语句 结果的goods.hasCode的结果来自同一块内存区域"></a>运行结果只出现一条sql语句 结果的goods.hasCode的结果来自同一块内存区域</h6><pre><code class="java">MyBatisTestor.java
 @Test
    public void testLv2Cache()&#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            Goods goods = session.selectOne(&quot;goods.selectById&quot;, 1603);
            System.out.println(goods.hashCode());
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;

        try&#123;
            session = MyBatisUtils.openSession();
            Goods goods = session.selectOne(&quot;goods.selectById&quot;, 1603);
            System.out.println(goods.hashCode());
        &#125;catch (Exception e)&#123;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;

08:59:50.304 [main] DEBUG goods - Cache Hit Ratio [goods]: 0.5
缓存命中率越高 证明优化越好
</code></pre>
<pre><code class="xml">goods.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;goods&quot;&gt; &lt;!--区分不同的工作空间--&gt;
    &lt;!--开启了二级缓存
        eviction是缓存的清除策略，当缓存对象数量达到上限后，自动触发对应算法对缓存对象清除
        1. LRU - 最近最久未使用：移除最长随时间不被使用的对象&#123;893&#125;
           LFU - 最近时间内方位最少的移除&#123;1&#125;
        【LRU + LFU 增强缓存速度】
        01 02 03 04 .. 0512
        14 99 83 1        893
        2. FIFO - 先进先出：按对象进入缓存的顺序来移除它们
        3. SOFT - 软引用：移除基于垃圾收集器状态和软引用规则的对象
        4. WEAK - 弱引用：更积极的移除基于垃圾收集器状态和弱引用规则的对象
        flushInterval 代表间隔多长时间自动清空缓存,单位毫秒,600000毫秒=10分钟
        size 缓存存储上限,用于保存对象或集合(1个结婚算1个对象)的数据上限
        readOnly 设置为true,代表返回只读缓存,每次从缓存取出的是缓存对象本身,这种执行效率较高
                 设置为false,代表每次取出的是缓存对象的&quot;副本&quot;,每一次取出的对象都是不同的，这种安全性较高
    --&gt;
    &lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;600000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;
    &lt;!--useCache=&quot;false&quot;代表查询结果不放入缓存--&gt;
    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot; useCache=&quot;false&quot;&gt;
        select * from t_goods order by goods_id desc limit 10&lt;!--将每一条记录包装成↑的goods对象--&gt;
    &lt;/select&gt;
    &lt;select id=&quot;selectById&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        select * from t_goods where goods_id = #&#123;value&#125;
    &lt;/select&gt;

    &lt;select id=&quot;selectByPriceRange&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
            select * from t_goods
            where
                current_price between #&#123;min&#125; and #&#123;max&#125;
            order by current_price
            limit 0,#&#123;limit&#125;
    &lt;/select&gt;
&lt;!--flushCache=&quot;true&quot;在sql执行后强制清空缓存 效果和commit相同--&gt; 
    &lt;select id=&quot;selectGoodsMap&quot; resultType=&quot;java.util.LinkedHashMap&quot; flushCache=&quot;true&quot;&gt;
        select g.* , c.category_name from t_goods g , t_category c
        where g.category_id = c.category_id
    &lt;/select&gt;

    &lt;resultMap id=&quot;rmGoods&quot; type=&quot;com.imooc.mybatis.dto.GoodsDTO&quot;&gt;
        &lt;id property=&quot;goods.goodsId&quot; column=&quot;goods_id&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;goods.title&quot; column=&quot;title&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.originalCost&quot; column=&quot;original_cost&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.currentPrice&quot; column=&quot;current_price&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.discount&quot; column=&quot;discount&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.isFreeDelivery&quot; column=&quot;is_free_delivery&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;goods.categoryId&quot; column=&quot;category_id&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;category.categoryId&quot; column=&quot;category_id&quot;/&gt;
        &lt;result property=&quot;category.categoryName&quot; column=&quot;category_name&quot;/&gt;
        &lt;result property=&quot;category.parentId&quot; column=&quot;parent_id&quot;/&gt;
        &lt;result property=&quot;category.categoryLevel&quot; column=&quot;category_level&quot;/&gt;
        &lt;result property=&quot;category.categoryOrder&quot; column=&quot;category_order&quot;/&gt;
        &lt;result property=&quot;test&quot; column=&quot;test&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectGoodsDTO&quot; resultMap=&quot;rmGoods&quot;&gt;
        select g.* , c.*,&#39;1&#39; from t_goods g , t_category c
        where g.category_id = c.category_id
    &lt;/select&gt;

    &lt;!--flushCache=&quot;true&quot;在sql执行后强制清空缓存 效果和commit相同--&gt; 
    &lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.mybatis.entity.Goods&quot; flushCache=&quot;true&quot;&gt;
        INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id)
        VALUES (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;)
        &lt;selectKey resultType=&quot;Integer&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt; &lt;!--主键自动生成--&gt;
        select last_insert_id()
        &lt;/selectKey&gt;
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        UPDATE t_goods
        SET
          title = #&#123;title&#125;,
          sub_title = #&#123;subTitle&#125;,
          original_cost = #&#123;originalCost&#125;,
          current_price = #&#123;currentPrice&#125;,
          discount = #&#123;discount&#125;,
          is_free_delivery = #&#123;isFreeDelivery&#125;,
          category_id = #&#123;categoryId&#125;
        WHERE
          good_id = #&#123;goodsId&#125; &lt;!--对主键进行筛选--&gt;
    &lt;/update&gt;

    &lt;delete id=&quot;delete&quot; parameterType=&quot;integer&quot;&gt;
        delete from t_goods where goods_id = #&#123;value&#125;
    &lt;/delete&gt;

    &lt;select id=&quot;selectByTitle&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        select * from t_goods where title = #&#123;title&#125;
            $&#123;order&#125;
    &lt;/select&gt;

    &lt;select id=&quot;dynamicSQL&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        select * from t_goods
        &lt;where&gt;    &lt;!--根据查询条件动态增加SQL的数据--&gt;
        &lt;if test=&quot;categoryId != null&quot;&gt;
            and category_id=#&#123;categoryId&#125;
        &lt;/if&gt;
        &lt;if test=&quot;currentPrice != null&quot;&gt;
            and current_price &amp;lt; #&#123;currentPrice&#125;
        &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h6 id="一级缓存被默认开启的随着sql开-随着sql关"><a href="#一级缓存被默认开启的随着sql开-随着sql关" class="headerlink" title="一级缓存被默认开启的随着sql开 随着sql关"></a>一级缓存被默认开启的随着sql开 随着sql关</h6><p>复习<code>&lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;600000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;</code> 当中的各种</p>
<blockquote>
<cache eviction="LRU" flushInterval="600000" size="512" readOnly="true"/>
<!--开启了二级缓存
        eviction是缓存的清除策略，当缓存对象数量达到上限后，自动触发对应算法对缓存对象清除

<pre><code>    1. LRU - 最近最久未使用：移除最长随时间不被使用的对象&#123;893&#125;
       LFU - 最近时间内方位最少的移除&#123;1&#125;
    【LRU + LFU 增强缓存速度】
    01 02 03 04 .. 0512
    14 99 83 1        893
    2. FIFO - 先进先出：按对象进入缓存的顺序来移除它们
    3. SOFT - 软引用：移除基于垃圾收集器状态和软引用规则的对象
    4. WEAK - 弱引用：更积极的移除基于垃圾收集器状态和弱引用规则的对象
   flushInterval - 代表间隔多长时间自动清空缓存,单位毫秒,600000毫秒=10分钟
   size - 缓存存储上限,用于保存对象或集合(1个结婚算1个对象)的数据上限
   readOnly - 设置为true,代表返回只读缓存,每次从缓存取出的是缓存对象本身,这种执行效率较高
        设置为false,代表每次取出的是缓存对象的&quot;副本&quot;,每一次取出的对象都是不同的，这种安全性较高
</code></pre>
<p>–&gt;</p>
 <!--flushCache="true"在sql执行后强制清空缓存 效果和commit相同--> 
<pre><code>&lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.mybatis.entity.Goods&quot; flushCache=&quot;true&quot;&gt;
</code></pre>
</blockquote>
<h3 id="MyBatis多表级联查询-通过一个对象获得另外一个对象"><a href="#MyBatis多表级联查询-通过一个对象获得另外一个对象" class="headerlink" title="MyBatis多表级联查询 (通过一个对象获得另外一个对象)"></a>MyBatis多表级联查询 (通过一个对象获得另外一个对象)</h3><p>一个比较有多个学生 而 一个学生在同一时间只能隶属于一个班级</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f2a315e37664fff7d79598eb4220fe3e413005cf/data/%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90.png" alt="实体关系分析"></p>
<h6 id="商品和详情对象关联查询-商品是1-详情是多-详情那方要持有商品的主键"><a href="#商品和详情对象关联查询-商品是1-详情是多-详情那方要持有商品的主键" class="headerlink" title="商品和详情对象关联查询 [商品是1 详情是多 详情那方要持有商品的主键]"></a>商品和详情对象关联查询 [<u>商品是1 详情是多 详情那方要持有商品的主键</u>]</h6><h3 id="ManyToOne对象关联查询-collection"><a href="#ManyToOne对象关联查询-collection" class="headerlink" title="ManyToOne对象关联查询 [collection]"></a>ManyToOne对象关联查询 [collection]</h3><pre><code class="xml">mybatis-config.xml 最底下加一层
&lt;mappers&gt;
   &lt;mapper resource=&quot;mappers/goods.xml&quot;/&gt;
   &lt;mapper resource=&quot;mappers/goods_detail.xml&quot;/&gt;
&lt;/mappers&gt;


good.xml
 &lt;!--
        resultMap可以用于说明一对多或者多对一的映射逻辑
        id 是 resultMap属性引用标志
        type 指向One的实体(Goods)
    --&gt;
    &lt;resultMap id=&quot;rmGoods1&quot; type=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        &lt;!-- 映射goods对象的主键到goods_id字段 --&gt;
        &lt;id column=&quot;goods_id&quot; property=&quot;goodsId&quot;&gt;&lt;/id&gt;
        &lt;!--
            collection的含义是,在
            select * from t_goods limit 0,1 得到结果后,对所有Goods对象遍历得到goods_id字段值,
            并代入到goodsDetail命名空间的findByGoodsId的SQL中执行查询,
            将得到的&quot;商品详情&quot;集合赋值给goodsDetails List对象.
        --&gt;
        &lt;collection property=&quot;goodsDetails&quot; select=&quot;goodsDetail.selectByGoodsId&quot;
                    column=&quot;goods_id&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectOneToMany&quot; resultMap=&quot;rmGoods1&quot;&gt;
        select * from t_goods limit 0,10
    &lt;/select&gt;


goods_details.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;goodsDetail&quot;&gt;
    &lt;select id=&quot;selectByGoodsId&quot; parameterType=&quot;Integer&quot;
            resultType=&quot;com.imooc.mybatis.entity.GoodsDetail&quot;&gt;
        select * from t_goods_detail where goods_id = #&#123;value&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">Goods.java 再加一个
public class Goods &#123;
    private Integer goodsId;//商品编号
    private String title;//标题
    private String subTitle;//子标题
    private Float originalCost;//原始价格
    private Float currentPrice;//当前价格
    private Float discount;//折扣率
    private Integer isFreeDelivery;//是否包邮 ,1-包邮 0-不包邮
    private Integer categoryId;//分类编号
    private List&lt;GoodsDetail&gt; goodsDetails;
    Getter+Setter
&#125;
</code></pre>
<pre><code class="java">MaBatisTestor.java 
/**
     * 测试多对一对象关联映射
     */
    @Test
    public void testOneToMany() throws Exception &#123;
        SqlSession session = null;
        try &#123;
            session = MyBatisUtils.openSession();
            List&lt;Goods&gt; list = session.selectList(&quot;goods.selectOneToMany&quot;);
            for(Goods goods:list) &#123;
                System.out.println(goods.getTitle() + &quot;:&quot; + goods.getGoodsDetails().size());
            &#125;
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<h3 id="ManyToOne对象关联查询-association"><a href="#ManyToOne对象关联查询-association" class="headerlink" title="ManyToOne对象关联查询 [association]"></a>ManyToOne对象关联查询 [association]</h3><h5 id="商品和详情对象关联查询"><a href="#商品和详情对象关联查询" class="headerlink" title="商品和详情对象关联查询"></a>商品和详情对象关联查询</h5><pre><code class="xml">goods_detail.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;goodsDetail&quot;&gt;
    &lt;select id=&quot;selectByGoodsId&quot; parameterType=&quot;Integer&quot;
            resultType=&quot;com.imooc.mybatis.entity.GoodsDetail&quot;&gt;
        select * from t_goods_detail where goods_id = #&#123;value&#125;
    &lt;/select&gt;

    &lt;resultMap id=&quot;rmGoodsDetail&quot; type=&quot;com.imooc.mybatis.entity.GoodsDetail&quot;&gt;
        &lt;id column=&quot;gd_id&quot; property=&quot;gdId&quot;/&gt;
        &lt;!--字段映射--&gt;
        &lt;result column=&quot;goods_id&quot; property=&quot;goodsId&quot;/&gt;
        &lt;!--从多的一方关联单的一方     在goods.xml中的goods空间 根据查询结果id带入到这个语句赋值到goods语句--&gt;
        &lt;association property=&quot;goods&quot; select=&quot;goods.selectById&quot; column=&quot;goods_id&quot;&gt;&lt;/association&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectManyToOne&quot; resultMap=&quot;rmGoodsDetail&quot;&gt;
        select * from t_goods_detail limit 0,20
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java
 @Test
    public void testManyToOne() throws Exception &#123;
        SqlSession session = null;
        try &#123;
            session = MyBatisUtils.openSession();
            List&lt;GoodsDetail&gt; list = session.selectList(&quot;goodsDetail.selectManyToOne&quot;);
            for(GoodsDetail gd:list) &#123;
                System.out.println(gd.getGdPicUrl() + &quot;:&quot; + gd.getGoods().getTitle());
            &#125;
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">GoodsDetail.java
public class GoodsDetail &#123;
    private Integer gdId;
    private Integer goodsId;
    private String gdPicUrl;
    private Integer gdOrder;
    private Goods goods;
    Getter + Setter
&#125;
</code></pre>
<h3 id="分页查询的麻烦事"><a href="#分页查询的麻烦事" class="headerlink" title="分页查询的麻烦事"></a>分页查询的麻烦事</h3><ul>
<li>当前页数据查询 - select * from tab limit 0,10</li>
<li>总记录数查询 - select count(*) from tab</li>
<li>程序计算总页数、上一页页码、下一页页码</li>
</ul>
<h5 id="分页插件PageHelper"><a href="#分页插件PageHelper" class="headerlink" title="分页插件PageHelper"></a><span style = "color:red"><strong>分页插件PageHelper</strong></span></h5><h3 id="PageHelper使用流程"><a href="#PageHelper使用流程" class="headerlink" title="PageHelper使用流程"></a>PageHelper使用流程</h3><ul>
<li>maven引入PageHelper与jsqlparser</li>
<li>mybatis-config.xml增加Plugin配置</li>
<li>代码中使用PageHelper.startPage()自动分页</li>
</ul>
<pre><code class="xml">pom.xml
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;5.1.10&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;
    &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;!--最核心处理的sql语句--&gt;
    &lt;version&gt;2.0&lt;/version&gt;
&lt;/dependency&gt;


goods.xml
&lt;select id=&quot;selectPage&quot; resultType=&quot;com.imooc.mybatis.entity.Goods&quot;&gt;
        select * from t_goods where current_price &amp;lt; 1000
&lt;/select&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;   &lt;!--环境配置标签--&gt;
    &lt;settings&gt;&lt;!--开启驼峰命名转换 goods_id → goodsId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;!--启动Pagehelper分页插件--&gt;
    &lt;plugins&gt;
        &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
            &lt;!--设置数据库类型--&gt;
            &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt;
            &lt;!--分页合理化--&gt;
            &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
    &lt;environments default=&quot;dev&quot;&gt; &lt;!--当环境默认数据源为dev时候使用运行的代码[不同id来切换]--&gt;
        &lt;environment id=&quot;dev&quot;&gt;  &lt;!--唯一标识--&gt;
            &lt;!--采用JDBC方式对数据库事务进行管理--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--采用连接池方式管理数据库连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
        &lt;environment id=&quot;prd&quot;&gt;
            &lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--采用连接池方式管理数据库连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.1.155:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/goods.xml&quot;/&gt;
        &lt;mapper resource=&quot;mappers/goods_detail.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java
@Test
    public void testSelectPage() throws Exception &#123;
        SqlSession session = null;
        try &#123;
            session = MyBatisUtils.openSession();
            /*startPage方法自动将下一次查询进行分页*/
            PageHelper.startPage(2,10);
            Page&lt;Goods&gt; page = (Page)session.selectList(&quot;goods.selectPage&quot;);
            System.out.println(&quot;总页数:&quot; + page.getPages());
            System.out.println(&quot;总记录数:&quot; + page.getTotal());
            System.out.println(&quot;开始行号:&quot; + page.getStartRow());
            System.out.println(&quot;结束行号:&quot; + page.getEndRow());
            System.out.println(&quot;当前页码:&quot; + page.getPageNum());
            List&lt;Goods&gt; data = page.getResult();//当前页数据
            for (Goods g : data) &#123;
                System.out.println(g.getTitle());
            &#125;
            System.out.println(&quot;&quot;);
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<h3 id="不同数据库分页的实现原理-面试-x2F-笔试"><a href="#不同数据库分页的实现原理-面试-x2F-笔试" class="headerlink" title="不同数据库分页的实现原理 [面试&#x2F;笔试]"></a><span style = "color : red">不同数据库分页的实现原理</span> [面试&#x2F;笔试]</h3><p><strong>MySQL分页</strong> <code>select * from table limit 10,20;</code> <u>起始行号 向后取多少值</u><br><strong>Oracle分页(三层嵌套)</strong></p>
<pre><code class="sql">Oracle分页(三层嵌套)
select t3.* from(
    select t2.*,rownum as row_num from(
        select * from table order by id asc
    ) t2 where rownum &lt;= 20
)t3
where t2.row_num&gt;11
</code></pre>
<p><strong>SQL Server 2000</strong></p>
<pre><code class="sql">select top 3 * from table
where
  id not in
  (select top 15 id from table)
</code></pre>
<p><strong>SQL Server 2012+</strong></p>
<pre><code class="sql">select * from table order by id 
   offset 4 rows fetch next 5 rows only
</code></pre>
<h3 id="MyBatis配置C3P0连接池"><a href="#MyBatis配置C3P0连接池" class="headerlink" title="MyBatis配置C3P0连接池"></a>MyBatis配置C3P0连接池</h3><pre><code class="xml">pom.xml
&lt;dependency&gt;
     &lt;groupId&gt;com.mchange&lt;/groupId&gt;
    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
    &lt;version&gt;0.9.5.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;environment id=&quot;dev&quot;&gt;  &lt;!--唯一标识--&gt;
            &lt;!--采用JDBC方式对数据库事务进行管理--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--采用连接池方式管理数据库连接--&gt;
&lt;!--            &lt;dataSource type=&quot;POOLED&quot;&gt;--&gt;
            &lt;dataSource type=&quot;com.imooc.mybatis.datasource.C3P0DataSourceFactory&quot;&gt;
                &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;initialPoolSize&quot; value=&quot;5&quot;/&gt;
                &lt;property name=&quot;maxPoolSize&quot; value=&quot;20&quot;/&gt;
                &lt;property name=&quot;minPoolSize&quot; value=&quot;5&quot;/&gt;
                &lt;!--...--&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
</code></pre>
<pre><code class="java">C3P0DataSourceFactory.java
package com.imooc.mybatis.datasource;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;

/**
 * C3P0与MyBatis兼容使用的数据源工厂类
 */
public class C3P0DataSourceFactory extends UnpooledDataSourceFactory&#123;
    public C3P0DataSourceFactory()&#123;
        this.dataSource = new ComboPooledDataSource();
    &#125;
&#125;
</code></pre>
<h3 id="MyBatis批处理-利用集合保存批处理数据-海量数据导入"><a href="#MyBatis批处理-利用集合保存批处理数据-海量数据导入" class="headerlink" title="MyBatis批处理 [利用集合保存批处理数据] [海量数据导入]"></a>MyBatis批处理 [利用集合保存批处理数据] [海量数据导入]</h3><pre><code class="xml">goods.xml
&lt;!--    INSERT INTO table--&gt;
&lt;!--    VALUES(&quot;a&quot;,&quot;a1&quot;,&quot;a2&quot;),(&quot;b&quot;,&quot;b1&quot;,&quot;b2&quot;),(...)--&gt;
&lt;insert id=&quot;batchInsert&quot; parameterType=&quot;java.util.List&quot;&gt;
     INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id)
     VALUES
    &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt;
      (#&#123;item.title&#125;,#&#123;item.subTitle&#125;, #&#123;item.originalCost&#125;, #&#123;item.currentPrice&#125;, #&#123;item.discount&#125;, #&#123;item.isFreeDelivery&#125;, #&#123;item.categoryId&#125;)
    &lt;/foreach&gt;
&lt;!--批量插入数据的局限：1.无法获得插入数据的id  2.批量生成的SQL太长，可能会被服务器拒绝(可以分段2次for循环)--&gt;
&lt;/insert&gt;
</code></pre>
<pre><code class="java">MyBatisTestor.java
/**
     * 批量插入测试
     * @throws Exception
     */
    @Test
    public void testBatchInsert() throws Exception &#123;
        SqlSession session = null;
        try &#123;
            long st = new Date().getTime();
            session = MyBatisUtils.openSession();
            List list = new ArrayList();
            for (int i = 0; i &lt; 10000; i++) &#123;
                Goods goods = new Goods();
                goods.setTitle(&quot;测试商品&quot;);
                goods.setSubTitle(&quot;测试子标题&quot;);
                goods.setOriginalCost(200f);
                goods.setCurrentPrice(100f);
                goods.setDiscount(0.5f);
                goods.setIsFreeDelivery(1);
                goods.setCategoryId(43);
                //insert()方法返回值代表本次成功插入的记录总数

                list.add(goods);
            &#125;
            session.insert(&quot;goods.batchInsert&quot;, list);
            session.commit();//提交事务数据
            long et = new Date().getTime();
            System.out.println(&quot;执行时间:&quot; + (et - st) + &quot;毫秒&quot;);
//            System.out.println(goods.getGoodsId());
        &#125; catch (Exception e) &#123;
            if (session != null) &#123;
                session.rollback();//回滚事务
            &#125;
            throw e;
        &#125; finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;

====================================================================
 /**
     * 10000次数据插入对比测试用例
     * @throws Exception
     */
    @Test
    public void testInsert1() throws Exception &#123;
        SqlSession session = null;
        try&#123;
            long st = new Date().getTime();
            session = MyBatisUtils.openSession();
            List list = new ArrayList();
            for(int i = 0 ; i &lt; 10000 ; i++) &#123;
                Goods goods = new Goods();
                goods.setTitle(&quot;测试商品&quot;);
                goods.setSubTitle(&quot;测试子标题&quot;);
                goods.setOriginalCost(200f);
                goods.setCurrentPrice(100f);
                goods.setDiscount(0.5f);
                goods.setIsFreeDelivery(1);
                goods.setCategoryId(43);
                //insert()方法返回值代表本次成功插入的记录总数
                //每循环一次 插入一次
                session.insert(&quot;goods.insert&quot; , goods);
            &#125;

            session.commit();//提交事务数据
            long et = new Date().getTime();
            System.out.println(&quot;执行时间:&quot; + (et-st) + &quot;毫秒&quot;);
//            System.out.println(goods.getGoodsId());
        &#125;catch (Exception e)&#123;
            if(session != null)&#123;
                session.rollback();//回滚事务
            &#125;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
</code></pre>
<h3 id="MyBatis常用注解-注解适合小型敏捷项目-XML适合大型协作项目"><a href="#MyBatis常用注解-注解适合小型敏捷项目-XML适合大型协作项目" class="headerlink" title="MyBatis常用注解 (注解适合小型敏捷项目 XML适合大型协作项目)"></a>MyBatis常用注解 (<u>注解适合小型敏捷项目 XML适合大型协作项目</u>)</h3><table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">对应XML</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Insert</td>
<td align="center">&lt; insert &gt;</td>
<td align="center">更新SQL</td>
</tr>
<tr>
<td align="center">@Update</td>
<td align="center">&lt; update &gt;</td>
<td align="center">更新SQL</td>
</tr>
<tr>
<td align="center">@Delete</td>
<td align="center">&lt; delete &gt;</td>
<td align="center">删除SQL</td>
</tr>
<tr>
<td align="center">@Select</td>
<td align="center">&lt; select &gt;</td>
<td align="center">查询SQL</td>
</tr>
<tr>
<td align="center">@Param</td>
<td align="center">–</td>
<td align="center">参数映射</td>
</tr>
<tr>
<td align="center">@Results</td>
<td align="center">&lt; resultMap &gt;</td>
<td align="center">结果映射</td>
</tr>
<tr>
<td align="center">@Result</td>
<td align="center">&lt; id &gt; &lt; result &gt;</td>
<td align="center">字段映射</td>
</tr>
</tbody></table>
<h6 id="把XML中的写入代码中"><a href="#把XML中的写入代码中" class="headerlink" title="把XML中的写入代码中"></a>把XML中的写入代码中</h6><pre><code class="java">dao.GoodsDAO.java
package com.imooc.mybatis.dao;

import com.imooc.mybatis.dto.GoodsDTO;
import com.imooc.mybatis.entity.Goods;
import org.apache.ibatis.annotations.*;

import java.util.List;

public interface GoodsDAO &#123;
    @Select(&quot;select * from t_goods where current_price between #&#123;min&#125; and #&#123;max&#125; order by current_price limit 0,#&#123;limit&#125;&quot;)
    public List&lt;Goods&gt; selectByPriceRange(@Param(&quot;min&quot;) Float min, @Param(&quot;max&quot;) Float max, @Param(&quot;limit&quot;) Integer limit);

    @Insert(&quot;INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) VALUES (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;)&quot;)
    //&lt;selectKey&gt; befor是true则在这之前执行 keyProperty主键 resultType返回主键类型
    @SelectKey(statement = &quot;select last_insert_id()&quot; , before = false , keyProperty = &quot;goodsId&quot; , resultType = Integer.class)
    public int insert(Goods goods);

    @Select(&#123;&quot;select * from t_goods&quot;&#125;)
    //&lt;resultMap&gt;
    @Results(&#123; //select实行完以下结果 按照以下规则并赋值給GoodsDTO对象
            //&lt;id&gt;
            @Result(column = &quot;goods_id&quot;, property = &quot;goodsId&quot;, id = true),
            //&lt;result&gt;
            @Result(column = &quot;title&quot;, property = &quot;title&quot;),
            @Result(column = &quot;current_price&quot;, property = &quot;currentPrice&quot;),
    &#125;)
    public List&lt;GoodsDTO&gt; selectAll();

&#125;
</code></pre>
<pre><code class="java">dto.GoodsDTO
package com.imooc.mybatis.dto;

public class GoodsDTO &#123;
    private Integer goodsId;//商品编号
    private String title;//标题
    private Float currentPrice;//当前价格

    public Integer getGoodsId() &#123;
        return goodsId;
    &#125;

    public void setGoodsId(Integer goodsId) &#123;
        this.goodsId = goodsId;
    &#125;

    public String getTitle() &#123;
        return title;
    &#125;

    public void setTitle(String title) &#123;
        this.title = title;
    &#125;

    public Float getCurrentPrice() &#123;
        return currentPrice;
    &#125;

    public void setCurrentPrice(Float currentPrice) &#123;
        this.currentPrice = currentPrice;
    &#125;
&#125;
</code></pre>
<pre><code class="java">entity.Goods.java
public class Goods &#123;
    private Integer goodsId;//商品编号
    private String title;//标题
    private String subTitle;//子标题
    private Float originalCost;//原始价格
    private Float currentPrice;//当前价格
    private Float discount;//折扣率
    private Integer isFreeDelivery;//是否包邮 ,1-包邮 0-不包邮
    private Integer categoryId;//分类编号
    Getter + Setter
&#125;
</code></pre>
<pre><code class="xml">resources.logback.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
   &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
       &lt;encoder&gt;
           &lt;pattern&gt;[%thread] %d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
       &lt;/encoder&gt;
   &lt;/appender&gt;

    &lt;!--
        日志输出级别(优先级高到低):
        error: 错误 - 系统的故障日志
        warn: 警告 - 存在风险或使用不当的日志
        info: 一般性消息
        debug: 程序内部用于调试信息
        trace: 程序运行的跟踪信息
     --&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="xml">resources.mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;!-- goods_id ==&gt; goodsId 驼峰命名转换 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;

    &lt;!--设置默认指向的数据库--&gt;
    &lt;environments default=&quot;dev&quot;&gt;
        &lt;!--配置环境，不同的环境不同的id名字--&gt;
        &lt;environment id=&quot;dev&quot;&gt;
            &lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--采用连接池方式管理数据库连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
&lt;!--        &lt;mapper class=&quot;com.imooc.mybatis.dao.GoodsDAO&quot;/&gt;--&gt;
        &lt;package name=&quot;com.imooc.mybatis.dao&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">test.java.com.imooc.mybatis.MyBatisTestor
package com.imooc.mybatis;

import com.imooc.mybatis.dao.GoodsDAO;
import com.imooc.mybatis.dto.GoodsDTO;
import com.imooc.mybatis.entity.Goods;
import com.imooc.mybatis.utils.MyBatisUtils;
import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import java.util.List;

//JUNIT单元测试类
public class MyBatisTestor &#123;

    @Test
    public void testSelectByPriceRange() throws Exception &#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); //包含注解的接口
            List&lt;Goods&gt; list = goodsDAO.selectByPriceRange(100f, 500f, 20);
            System.out.println(list.size());
        &#125;catch (Exception e)&#123;
            throw e;
        &#125; finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;

    /**
     * 新增数据
     * @throws Exception
     */
    @Test
    public void testInsert() throws Exception &#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            Goods goods = new Goods();
            goods.setTitle(&quot;测试商品&quot;);
            goods.setSubTitle(&quot;测试子标题&quot;);
            goods.setOriginalCost(200f);
            goods.setCurrentPrice(100f);
            goods.setDiscount(0.5f);
            goods.setIsFreeDelivery(1);
            goods.setCategoryId(43);
            GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class);
            //insert()方法返回值代表本次成功插入的记录总数
            int num = goodsDAO.insert(goods);
            session.commit();//提交事务数据
            System.out.println(goods.getGoodsId()); //最新的数据回填給goodsId
        &#125;catch (Exception e)&#123;
            if(session != null)&#123;
                session.rollback();//回滚事务
            &#125;
            throw e;
        &#125;finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;

    @Test
    public void testSelectAll() throws Exception &#123;
        SqlSession session = null;
        try&#123;
            session = MyBatisUtils.openSession();
            GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class);
            List&lt;GoodsDTO&gt; list = goodsDAO.selectAll();
            System.out.println(list.size());
        &#125;catch (Exception e)&#123;
            throw e;
        &#125; finally &#123;
            MyBatisUtils.closeSession(session);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-annotation&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/10/30/后端/MyBatis基础与进阶/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/10/26/后端/Maven,工厂模式,反射模式,Lambda表达式,stream流式处理/">
        <h2>
            Maven,工厂模式,反射模式,Lambda表达式,stream流式处理
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/26
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="Maven构建工具"><a href="#Maven构建工具" class="headerlink" title="Maven构建工具"></a>Maven构建工具</h3><h6 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h6><ul>
<li>Maven是项目管理工具，对软件项目提供构建与依赖管理</li>
<li>Maven是Apache下的Java开源项目</li>
<li>Maven为Java项目提供了统一的管理方式，已经成为业界标准</li>
</ul>
<h6 id="Maven核心特性"><a href="#Maven核心特性" class="headerlink" title="Maven核心特性"></a>Maven核心特性</h6><ul>
<li>项目设置遵循统一的规则，保证不同开发环境的兼容性</li>
<li>强大的依赖管理，项目依赖组件自动下载、自动更新</li>
<li>可扩展的插件机制，使用简单，功能丰富</li>
</ul>
<h6 id="Maven的坐标"><a href="#Maven的坐标" class="headerlink" title="Maven的坐标"></a>Maven的坐标</h6><ul>
<li><strong>GroupId</strong>：机构或者团体的英文，采用”逆向域名”形式书写</li>
<li><strong>ArtifactId</strong>：项目名称，说明其用途，例如：cms、oa…</li>
<li><strong>Version</strong>：版本号，一般采用”版本+单词”形式，例如：1.0.0.RELEASE</li>
</ul>
<h3 id="Maven项目标准结构"><a href="#Maven项目标准结构" class="headerlink" title="Maven项目标准结构"></a>Maven项目标准结构</h3><table>
<thead>
<tr>
<th>目录</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>${basedir}</td>
<td>根目录，用于保存pom.xml</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;main&#x2F;java</td>
<td>Java源代码目录</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;main&#x2F;resources</td>
<td>资源目录，保存配置文件、静态图片等</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;test&#x2F;java</td>
<td>测试类的源代码</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;test&#x2F;resources</td>
<td>测试时需要使用的资源文件</td>
</tr>
<tr>
<td>${basedir}&#x2F;target</td>
<td>项目输出的目录，用于存储jar、war文件</td>
</tr>
<tr>
<td>${basedir}&#x2F;target&#x2F;class</td>
<td>字节码(.class)的编译输出目录</td>
</tr>
<tr>
<td>${basedir}&#x2F;<strong>pom.xml</strong></td>
<td>项目(<strong>P</strong>roject)对象(<strong>O</strong>bject)模型(<strong>M</strong>odel)文件</td>
</tr>
</tbody></table>
<h3 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h3><ul>
<li>Maven利用<strong>dependency</strong>(依赖) 自动下载、管理第三方Jar</li>
<li>在pom.xml文件中配置项目依赖的第三方组件</li>
<li>maven自动将依赖从<strong>远程仓库</strong>下载至<strong>本地仓库</strong>，并在工程中引用</li>
</ul>
<pre><code class="html">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p><span style = "color : red"><a target="_blank" rel="noopener" href="https://search.maven.org/">Maven Central Repository Search</a>可以搜索<strong>maven</strong></span></p>
<pre><code class="html">pom.xml
&lt;dependencies&gt;
    &lt;dependency&gt;
          &lt;groupId&gt;com.belerweb&lt;/groupId&gt;
          &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt;
          &lt;version&gt;2.5.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="java">PinyinTestor.java
import net.sourceforge.pinyin4j.PinyinHelper;

import java.util.Scanner;

public class PinyinTestor &#123;
    public static void main(String[] args) &#123;
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String[] pingyin = PinyinHelper.toHanyuPinyinStringArray(str.charAt(0)); //将输入的第一个数据变成字符串数组
        for (String py : pingyin)&#123;
            System.out.println(py);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="本地仓库与中央仓库"><a href="#本地仓库与中央仓库" class="headerlink" title="本地仓库与中央仓库"></a>本地仓库与中央仓库</h3><p><strong>maven</strong> 在项目启动的时候会对 <strong>pom.xml</strong> 进行加载 之后会在<strong>本地仓库</strong> <strong>.m2\repository</strong> 去查找依赖文件(jar包) 如果查不到或不存在 就会去<strong>中央仓库</strong>下载(repo.maven.apache.org)到本地仓库</p>
<h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><ul>
<li>Maven可将Java项目打包为<strong>jar、war</strong>包</li>
<li>Maven项目打包是通过<strong>Plugins</strong>(插件)技术实现</li>
<li>Maven输出jar包插件：maven-assembly-plugin</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/32c4c5407cd517b9304127dfdab23e910c4aea0c/data/Maven%E6%89%93%E5%8C%85.png" style="zoom:200%;" />

<pre><code class="html">//阿里云镜像下载地址
&lt;repositories&gt;
  &lt;repository&gt;
      &lt;!-- 创建私服的地址 --&gt;
    &lt;id&gt;aliyun&lt;/id&gt;
    &lt;name&gt;aliyun&lt;/name&gt;
    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<h3 id="Maven构建Web工程"><a href="#Maven构建Web工程" class="headerlink" title="Maven构建Web工程"></a>Maven构建Web工程</h3><p>创建Maven-Project</p>
<pre><code class="html">Group Id: maven-first
Artifacr Id: maven
Version: 1.0.0-RELEASE
Packaging: jar
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/czc9309/article/details/80304074">IntelliJ IDEA创建maven web项目（IDEA新手适用）_idea maven创建web项目-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45384457/article/details/128532296">IDEA2022版本创建maven web项目（两种方式）最全图文教学_idea创建maven项目没有webapp-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41523340/article/details/122598795">IDEA中创建Maven Web项目的两种方法_idea maven创建web项目-CSDN博客</a><br>Project Structure → Modules → ＋增加Web</p>
<blockquote>
<p><strong>web application exploded</strong>：这个是以文件夹形式发布项目，发布项目时就会自动生成文件夹在指定的output directory；<br><strong>web application archive</strong>：就是war包形式,将项目打成一个war包在指定位置</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_63324772/article/details/124516436">Tomcat报404问题解决方案大全(包括tomcat可以正常运行但是报404)_tomcat 404_ISAS的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">Windows下如何查看某个端口被谁占用 | 菜鸟教程 (runoob.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41926609/article/details/104977944">(.iml的问题)IDEA中用Maven创建web项目部署运行时页面报错404解决方法_maven web项目404-CSDN博客</a></p>
<h3 id="Web应用打包"><a href="#Web应用打包" class="headerlink" title="Web应用打包"></a>Web应用打包</h3><pre><code class="html">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Web_one&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar\war&lt;/packaging&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.2.2&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>打包成war\jar后可以通过tomcat中的临时启动服务器来运行</p>
<h3 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>mvn archetype:generate</td>
<td>创建Maven工程结构</td>
</tr>
<tr>
<td>mvn <strong>compile</strong></td>
<td>编译源代码 .class</td>
</tr>
<tr>
<td>mvn <strong>test</strong></td>
<td>执行测试用例</td>
</tr>
<tr>
<td>mvn <strong>clean</strong></td>
<td>清除产生的项目</td>
</tr>
<tr>
<td>mvn <strong>package</strong></td>
<td>项目打包</td>
</tr>
<tr>
<td>mvn <strong>install</strong></td>
<td>安装至本地仓库</td>
</tr>
</tbody></table>
<h3 id="修改本地仓库地址"><a href="#修改本地仓库地址" class="headerlink" title="修改本地仓库地址"></a>修改本地仓库地址</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/781d364e7b198b48320f5f30b0353f09e0a6e491/data/Maven%E4%BF%AE%E6%94%B9%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png"></p>
<h3 id="工厂模式-运用于真实项目"><a href="#工厂模式-运用于真实项目" class="headerlink" title="工厂模式 [运用于真实项目]"></a>工厂模式 [运用于真实项目]</h3><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><ul>
<li>设计模式是前辈总结的设计经验</li>
<li>设计模式的目标是代码更容易理解，更容易维护</li>
<li>通过设计模式可以让代码更加可靠</li>
</ul>
<h5 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h5><ul>
<li>创建型模式 [帮助我们如何更精巧的创建对象]</li>
<li>结构型模式 [在软件结构上通过重构\抽象 让软件结构变得更有条理]</li>
<li>行为型模式 [现实中的场景对软件的设计和优化]</li>
</ul>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><ul>
<li>工厂模式用于隐藏创建对象的细节</li>
<li>工厂模式核心：工厂类(Factory)</li>
<li>工厂模式可以细分为<strong>简单工厂</strong>、工厂方法与抽象方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/05e0a6dc8012091ace359e456d27a0e99790d5e4/data/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png" alt="简单工厂图"></p>
<h6 id="项目应用-i18n国际化-软件分工更明确-软件耦合降低"><a href="#项目应用-i18n国际化-软件分工更明确-软件耦合降低" class="headerlink" title="项目应用-i18n国际化 (软件分工更明确 软件耦合降低)"></a>项目应用-i18n国际化 (软件分工更明确 软件耦合降低)</h6><p>不同国家显示页面的语言不同<br>抽象一个接口！！</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8697c92cea29312070f514788d158aadbde6513f/data/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E4%BB%A3%E7%A0%81.png"></p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h6 id="反射Reflect"><a href="#反射Reflect" class="headerlink" title="反射Reflect"></a>反射Reflect</h6><ul>
<li>反射式在<strong>运行时</strong>动态访问类与对象的技术 [写死的代码不灵活]</li>
<li>反射是JDK1.2版本后的高级特性，隶属于<strong>java.lang.reflect</strong></li>
<li>大多数Java框架都是基于<strong>反射实现参数</strong>配置、<strong>动态注入</strong>等特性</li>
</ul>
<h6 id="初始反射技术"><a href="#初始反射技术" class="headerlink" title="初始反射技术"></a>初始反射技术</h6><pre><code class="java">未运用反射技术
 public static void case1()&#123;
        Scanner scanner = new Scanner(System.in);
        System.out.print(&quot;请输入计算类名:&quot;);
        String op = scanner.next();
        System.out.print(&quot;请输入a:&quot;);
        int a = scanner.nextInt();
        System.out.print(&quot;请输入b:&quot;);
        int b = scanner.nextInt();
        MathOperation mathOperation = null;
        if(op.equals(&quot;Addition&quot;))&#123;
            mathOperation = new Addition();
        &#125;else if(op.equals(&quot;Subtraction&quot;)) &#123;
            mathOperation = new Subtraction();
        &#125;else if(op.equals(&quot;Multiplication&quot;))&#123;
            mathOperation = new Multiplication();
        &#125;else&#123;
            System.out.println(&quot;无效的计算类&quot;);
            return;
        &#125;
        float result = mathOperation.operate(a, b);
        System.out.println(result);
    &#125;

======================================================
运用反射技术
 public static void case2()&#123;
        Scanner scanner = new Scanner(System.in);
        System.out.print(&quot;请输入计算类名:&quot;);
        String op = scanner.next(); ****
        System.out.print(&quot;请输入a:&quot;);
        int a = scanner.nextInt();
        System.out.print(&quot;请输入b:&quot;);
        int b = scanner.nextInt();
        MathOperation mathOperation = null;
        try &#123;
            mathOperation = (MathOperation) Class.forName(&quot;com.imooc.reflect.&quot; + op).newInstance(); //class.forName加载指定的类 实例化对象 运行时动态决定op创建哪些对象 访问哪些属性****
        &#125;catch(Exception e)&#123;
            System.out.println(&quot;无效的计算类&quot;);
            return;
        &#125;
        float result = mathOperation.operate(a, b);
        System.out.println(result); 
    &#125;
</code></pre>
<h3 id="反射的核心类"><a href="#反射的核心类" class="headerlink" title="反射的核心类"></a>反射的核心类</h3><h5 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a><strong>Class类</strong></h5><p>Class是JVM中代表”类和接口”的类<br>Class对象具体包含了某个特定类的结构信息<br>通过Class对象可获取对应类的构造方法&#x2F;方法&#x2F;成员变量</p>
<h6 id="Class核心方法"><a href="#Class核心方法" class="headerlink" title="Class核心方法"></a><span style = "color : red">Class核心方法</span></h6><table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Class.forName() [传入完整类名包括包]</td>
<td>静态方法,用于获取指定Class对象</td>
</tr>
<tr>
<td>classObj.newInstance()</td>
<td>通过<strong>默认构造方法创建新的对象</strong></td>
</tr>
<tr>
<td>classObj.getConstructor()</td>
<td>获得指定的public修饰构造方法Constructor对象</td>
</tr>
<tr>
<td>classObj.getMethod()</td>
<td>获取指定的public修饰方法Method对象</td>
</tr>
<tr>
<td>classObj.getField()</td>
<td>获取指定的public修饰成员变量Field对象</td>
</tr>
</tbody></table>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;
&#125;
</code></pre>
<pre><code class="java">ClassSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

public class ClassSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            //Class.forName()方法将指定的类加载到jvm,并返回对应Class对象
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            System.out.println(&quot;Employee已被加载到jvm&quot;);
            //newInstance通过默认构造方法创建新的对象
            Employee emp = (Employee)employeeClass.newInstance();
            System.out.println(emp);
        &#125; catch (ClassNotFoundException e) &#123;
            //类名与类路径书写错误时抛出&quot;类无法找到&quot;异常
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            //对象无法被实例化，抛出&quot;实例化异常&quot;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            //非法访问异常 在程序外或作用域外访问对象或成员变量时抛出
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>
<h5 id="Constructor构造方法类"><a href="#Constructor构造方法类" class="headerlink" title="Constructor构造方法类"></a><strong>Constructor构造方法类</strong></h5><ul>
<li>Constructor类是对Java类中的构造方法的抽象</li>
<li>Contructor对象包括了具体类的某个具体构造方法的声明</li>
<li>通过Constructor对象调用带参构造方法创建对象</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>classObj.getConstructor()</td>
<td>获取指定public修饰的构造方法对象</td>
</tr>
<tr>
<td>constructorObj.newInstance()</td>
<td>通过对应的构造方法创建对象</td>
</tr>
</tbody></table>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Employee(Integer eno, String ename, Float salary, String dname) &#123;
        this.eno = eno;
        this.ename = ename;
        this.salary = salary;
        this.dname = dname;
        System.out.println(&quot;Employee带参构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">ConstructorSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class ConstructorSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123; //得到对应的class对象
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            System.out.println(employee);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
            //类名与类路径书写错误时抛出&quot;类无法找到&quot;异常
        &#125; catch (NoSuchMethodException e) &#123;
            //没有找到与之对应格式的写法
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            //当被调用的方法的内部抛出了异常而没有被捕获时
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            //对象无法被实例化，抛出&quot;实例化异常&quot;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            //非法访问异常 在程序外或作用域外访问对象或成员变量时抛出
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a><strong>Method类</strong></h5><ul>
<li>Method对象指代某个类中的方法的描述</li>
<li>Method对象使用classObj.getMethod()方法获取</li>
<li>通过Method对象调用指定对象的对应方法</li>
</ul>
<p><span style = "color : red"><strong>Method核心方法</strong></span></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>classObj.getMethod()</td>
<td>获取指定public修饰的方法对象</td>
</tr>
<tr>
<td>methodObj.invoke()</td>
<td>调用指定对象的对应方法</td>
</tr>
</tbody></table>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

import com.sun.org.apache.bcel.internal.generic.RETURN;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Employee(Integer eno, String ename, Float salary, String dname) &#123;
        this.eno = eno;
        this.ename = ename;
        this.salary = salary;
        this.dname = dname;
        System.out.println(&quot;Employee带参构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    public Employee updateSalary(Float val)&#123;
        this.salary = this.salary + val;
        System.out.println(this.ename + &quot;调薪至&quot; + this.salary + &quot;元&quot;);
        return this;

    &#125;
&#125;
</code></pre>
<pre><code class="java">MethodSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class MethodSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123;
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            Method updateSalaryMethod = employeeClass.getMethod(&quot;updateSalary&quot;, new Class[]&#123; //传入参数
               Float.class
            &#125;);
            Employee employee1 = (Employee)updateSalaryMethod.invoke(employee, new Object[]&#123;1000f&#125;); //若有返回值 要强制转换
            System.out.println(employee1);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Field成员变量类"><a href="#Field成员变量类" class="headerlink" title="Field成员变量类"></a><strong>Field成员变量类</strong></h5><ul>
<li>Field对应某个具体类中的成员变量的声明</li>
<li>Field对象使用**classObj.getField()**方法获取</li>
<li>通过Field对象可为某对象成员变量赋值&#x2F;取值</li>
</ul>
<p><span style = "color : red"><strong>Field类核心方法</strong></span></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>classObj.getField()</td>
<td>获取指定publicc修饰的成员变量对象</td>
</tr>
<tr>
<td>fieldObj.set()</td>
<td>为某对象指定成员变量赋值</td>
</tr>
<tr>
<td>fieldObj.get()</td>
<td>获取某对象指定成员变量数值</td>
</tr>
</tbody></table>
<p>快速添加包裹try catch → 框上要包裹的 点Code → surround with<br>get()&#x2F;set()都是(在entify中)public共有方法</p>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

import com.sun.org.apache.bcel.internal.generic.RETURN;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    public String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Employee(Integer eno, String ename, Float salary, String dname) &#123;
        this.eno = eno;
        this.ename = ename;
        this.salary = salary;
        this.dname = dname;
        System.out.println(&quot;Employee带参构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    public Employee updateSalary(Float val)&#123;
        this.salary = this.salary + val;
        System.out.println(this.ename + &quot;调薪至&quot; + this.salary + &quot;元&quot;);
        return this;

    &#125;
&#125;
</code></pre>
<pre><code class="java">FieldSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;

public class FieldSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123;
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            Field enameField = employeeClass.getField(&quot;ename&quot;);
            enameField.set(employee,&quot;李雷&quot;);
            String ename = (String) enameField.get(employee);
            System.out.println(&quot;ename:&quot; + ename);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchFieldException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="getDeclared系列方法"><a href="#getDeclared系列方法" class="headerlink" title="getDeclared系列方法"></a>getDeclared系列方法</h3><ul>
<li><span style = "color:red"><strong>getDeclaredConstructor(s)</strong> | <strong>Method(s)</strong> | <strong>Field(s)</strong></span> 获取对应对象</li>
<li><strong>getConstructor(s)</strong> | <strong>Method(s)</strong> | <strong>Field(s)</strong> 只能获取public对象</li>
<li>访问<strong>非作用域内构造方法、方法、成员变量</strong>，会抛出异常</li>
</ul>
<p>public可以直接获取 private只能通过get…获取</p>
<pre><code class="java">Employee.java + getDeclaredSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class getDeclaredSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123;
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            Field[] fields = employeeClass.getDeclaredFields();
            for (Field field : fields)&#123;
//                System.out.println(field.getName());
                if (field.getModifiers() == 1) &#123;//成员变量修饰符 public修饰
                    Object val = field.get(employee);
                    System.out.println(field.getName() + &quot;:&quot; + val);
                &#125; else if (field.getModifiers() == 2) &#123; //private修饰
                    String methodName = &quot;get&quot; + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1);//(0,1)是截取字符串 第一个大写字母
                    Method getMethod = employeeClass.getMethod(methodName);
                    Object ret = getMethod.invoke(employee);
                    System.out.println(field.getName() + &quot;:&quot; + ret);
                &#125;
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="反射在项目中的应用"><a href="#反射在项目中的应用" class="headerlink" title="反射在项目中的应用"></a>反射在项目中的应用</h3><h6 id="反射最重要的就是可以在运行时"><a href="#反射最重要的就是可以在运行时" class="headerlink" title="反射最重要的就是可以在运行时"></a>反射最重要的就是可以在运行时</h6><p><a href="seata.io/en-us/">反射的应用网站</a></p>
<p>对原始程序无需任何调整，只需要把对应的接口进行实现，放到线上服务器，再调整配置文件。</p>
<pre><code class="java">Zhcn.java
package com.imooc.i18n;

public class Zhcn implements I18N&#123;
    @Override
    public String say() &#123;
        return &quot;生命不息奋斗不止&quot;;
    &#125;
&#125;
=========================================================
En.java
package com.imooc.i18n;

public class En implements I18N&#123;
    @Override
    public String say() &#123;
        return &quot;Case to the struggle and cease to the life&quot;;
    &#125;
&#125;
========================================================
接口I18N.java
package com.imooc.i18n;

public interface I18N &#123;
    public String say();
&#125;
</code></pre>
<pre><code class="java">package com.imooc.i18n;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.Properties;

public class Application &#123;
    public static void say()&#123;
        Properties properties = new Properties(); //加载指定的配置文件
        String configPath = Application.class.getResource(&quot;/config.properties&quot;).getPath();
        try &#123;
            configPath = new URLDecoder().decode(configPath,&quot;UTF-8&quot;);//路径中的空格默认得到url编码所以要转换一下
            properties.load(new FileInputStream(configPath)); //内容来源于文件 文件输入流
            String language = properties.getProperty(&quot;language&quot;);
            I18N i18n = (I18N)Class.forName(language).newInstance();
            System.out.println(i18n.say());
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Application.say();
    &#125;
&#125;
</code></pre>
<pre><code class="html">language=com.imooc.i18n.En
或
language=com.imooc.i18n.Zhcn
</code></pre>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><ul>
<li>JDK8(1.8以上)开始支持Lambda表达式，用来让程序编写更优雅</li>
<li>利用Lambda可以更简洁的<strong>实现匿名内部类</strong>与<strong>函数声明与调用</strong></li>
<li>基于Lambda提供<strong>stream流</strong>式处理极大简化对集合的操作</li>
</ul>
<h6 id="传统代码"><a href="#传统代码" class="headerlink" title="传统代码"></a>传统代码</h6><pre><code class="java">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;,&quot;anna&quot;,&quot;mike&quot;,&quot;xenia&quot;);
//实现集合排序
Collections.sort(names,new Comparator&lt;String&gt;()&#123;
  @Override
  public int compare(String a,String b)&#123;
      return b.compareTo(a);
  &#125;  
&#125;);
</code></pre>
<h6 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h6><pre><code class="java">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;,&quot;anna&quot;,&quot;mike&quot;,&quot;xenia&quot;);
//通过lambda表达式简化匿名类的编写
Collections.sort(names,(a,b) -&gt; b.compareTo(a));
</code></pre>
<h3 id="Lambda表达式语法-代码脚手架"><a href="#Lambda表达式语法-代码脚手架" class="headerlink" title="Lambda表达式语法 [代码脚手架]"></a><span style = "color : red">Lambda表达式语法</span> [代码脚手架]</h3><p><strong><span style = "color:red">(参数列表) —＞实现语句</span></strong><br>[<u>使用逗号分割参数,参数类型可省略,单参数括号可省略</u>]<br>[<u>单行直接写 多行用{}包括</u>]</p>
<pre><code class="java">MathOperation.java
public interface MathOperation &#123;
    //四则运算接口
    public Float operate(Integer a, Integer b);
&#125;
</code></pre>
<pre><code class="java">LambdaSample.java
public class LambdaSample &#123;
    public static void main(String[] args) &#123;
        //标准Lambda使用方法
        //约束条件：Lambda表达式只能实现有且只有一个抽象方法的接口,Java称为&quot;函数式接口&quot;
        //1.标注使用方式
        MathOperation addition = (Integer a, Integer b) -&gt; &#123;
            System.out.println(&quot;加法运算&quot;);
            return a+b+0f; //定义的接口是Float
        &#125;;
        System.out.println(addition.operate(5, 5));

        //2.lambda允许忽略参数类型
        MathOperation substration = (a,b) -&gt; &#123;
            return a-b+0f;
        &#125;;
        System.out.println(substration.operate(5, 3));

        //3.单行实现代码可以省略大括号和return
        MathOperation multiplication = (a,b) -&gt; a*b+0f;
        System.out.println(multiplication.operate(3, 5));
    &#125;
&#125;
</code></pre>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul>
<li>函数式编程是基于函数式接口并使用lambda表达的编程方式</li>
<li>函数式编程理念是将代码作为可重用数据带入到程序运行中</li>
<li>函数式编程强调”<strong>你想做什么</strong>“，而不是”<strong>你想怎么做</strong>“</li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul>
<li>函数式接口是有且只有一个抽象方法的接口</li>
<li>Java中拥有大量函数式接口，如<strong>java.lang.Runnable</strong></li>
<li>JDK8后提供了一系列新的函数式接口，位于<strong>java.util.function</strong></li>
</ul>
<h3 id="函数式接口Perdicate"><a href="#函数式接口Perdicate" class="headerlink" title="函数式接口Perdicate"></a>函数式接口Perdicate</h3><ul>
<li>Perdicate是新增的函数式接口，位于<strong>java.util.function</strong></li>
<li><u>Perdicate用于测试传入的数据是否满足<strong>判断要求</strong></u></li>
<li>Perdicate接口需要实现test()方法进行逻辑判断</li>
</ul>
<p><span style = "color:red"> 用<strong>lambda表达式</strong>来实现<strong>predicate</strong>的验证</span><br>将已有的代码变成可重复使用的资源放入程序中</p>
<pre><code class="java">PredicateSample.java
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

/*
    理解函数式编程
    Perdicate函数式接口的使用方法
 */
public class PredicateSample &#123;
    public static void main(String[] args) &#123;
        Predicate &lt;Integer&gt; predicate = n-&gt;n&gt;4; //隐藏着return
        boolean result = predicate.test(10);
        System.out.println(result);
        List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);
        filter(list,n-&gt;n%2==1); //传入函数式接口的实现lambda 取所有奇数
        filter(list,n-&gt;n%2==0); //取所有偶数
        filter(list,n-&gt;n&gt;5 &amp;&amp; n%2==0); //取所有大于5的偶数
    &#125;
    public static void filter(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)&#123;
        for (Integer num:list)&#123;
            if (predicate.test(num))&#123;
                System.out.println(num + &quot; &quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="各种函数接口"><a href="#各种函数接口" class="headerlink" title="各种函数接口"></a>各种函数接口</h3><h5 id="JDK8常用函数式接口"><a href="#JDK8常用函数式接口" class="headerlink" title="JDK8常用函数式接口"></a>JDK8常用函数式接口</h5><h6 id="consumer函数接口"><a href="#consumer函数接口" class="headerlink" title="consumer函数接口"></a>consumer函数接口</h6><table>
<thead>
<tr>
<th><strong>接口</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Consumer&lt; T &gt;</strong></td>
<td><strong>对应有一个输入参数无输出的功能代码</strong></td>
</tr>
<tr>
<td><strong>Function&lt; T,R &gt;</strong></td>
<td>对应有一个输入参数且需要返回参数的功能代码</td>
</tr>
<tr>
<td><strong>Predicate&lt; T &gt;</strong></td>
<td>用于条件判断，固定返回布尔值</td>
</tr>
</tbody></table>
<pre><code class="java">ConsumerSample.java
import java.util.function.Consumer;

/*
    Consumer接口的使用
 */
public class ConsumerSample &#123;
    public static void main(String[] args) &#123;
        output(s-&gt; System.out.println(&quot;向控制台打印：&quot; + s));
        //字符串作为网络数据包向某个网站发送
        output(s-&gt;&#123;
            System.out.println(&quot;向XXX网络发送数据包:&quot; + s);
        &#125;);
    &#125;
    public static void output(Consumer&lt;String&gt; consumer)&#123;
        String text = &quot;苦其心志,劳其筋骨&quot;;
        consumer.accept(text);
    &#125;
&#125;
</code></pre>
<h6 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h6><pre><code class="java">FunctionSample.java
import java.util.Random;
import java.util.function.Function;

/*
    利用Function函数式接口生成定长随机字符串[加密解密会用到]
 */
public class FunctionSample &#123;
    public static void main(String[] args) &#123;
        Function&lt;Integer,String&gt; randomStringFunction = l-&gt;&#123;
            String chars = &quot;abcdefghijklmnopqrstuvxwyz0123456789&quot;;
            StringBuffer stringBuffer = new StringBuffer();
            Random random = new Random();
            for (int i = 0; i &lt; l; i++) &#123;
                int position = random.nextInt(chars.length());
                stringBuffer.append(chars.charAt(position));//按指定位置将字符提取并追加
            &#125;
            return stringBuffer.toString();
        &#125;;
        String randowmString = randomStringFunction.apply(16);//生成16位长的字符串
        System.out.println(randowmString);
    &#125;
&#125;
</code></pre>
<h6 id="functionalInterface注解"><a href="#functionalInterface注解" class="headerlink" title="@functionalInterface注解"></a>@functionalInterface注解</h6><pre><code class="java">MathOperation.java
@FunctionalInterface //通知编译器这是函数式接口，进行抽象方法检查
public interface MathOperation &#123;
    //四则运算接口

    public Float operate(Integer a, Integer b);
&#125;
</code></pre>
<h3 id="函数式编程与面向对象编程比较"><a href="#函数式编程与面向对象编程比较" class="headerlink" title="函数式编程与面向对象编程比较"></a>函数式编程与面向对象编程比较</h3><table>
<thead>
<tr>
<th></th>
<th>面向对象编程</th>
<th>函数式编程</th>
</tr>
</thead>
<tbody><tr>
<td>设计思路</td>
<td>面向对象</td>
<td>面向过程</td>
</tr>
<tr>
<td>开发侧重</td>
<td>侧重过程,重分析,重设计</td>
<td>侧重结果,快速实现</td>
</tr>
<tr>
<td>可读性</td>
<td>结构复杂,相对较差</td>
<td>更适合人眼阅读,可读性更好</td>
</tr>
<tr>
<td>代码量</td>
<td>多</td>
<td>少</td>
</tr>
<tr>
<td>并发问题</td>
<td>设计不当,会出现线程安全问题</td>
<td>不会出现线程安全问题</td>
</tr>
<tr>
<td>健壮性</td>
<td>好</td>
<td>差</td>
</tr>
<tr>
<td>使用场景</td>
<td>中大型项目,多人协作工程</td>
<td>小型应用,要求快速实现</td>
</tr>
</tbody></table>
<h3 id="Stream流式处理"><a href="#Stream流式处理" class="headerlink" title="Stream流式处理"></a>Stream流式处理</h3><ul>
<li>Stream流式处理式建立在Lambda基础上的多数据处理技术 </li>
<li>Stream对集合数据处理进行高度抽象，极大简化代码量</li>
<li>Stream可对集合进行迭代,去重,筛选,排序,聚合等一系列处理</li>
</ul>
<h3 id="Stream示例"><a href="#Stream示例" class="headerlink" title="Stream示例"></a>Stream示例</h3><pre><code class="java">//获取List集合中最大的偶数
Optional&lt;Integer&gt; op = Arrays.asList(1,2,3,4,5,6).stream()
.filter(x-&gt;x%2==0) //处理完得到一个只包含偶数的list流数据
.sorted((a,b)-&gt;b-a) //大的在前面 小的在后面
.findFirst(); //获取最大的数据
System.out.println(op.get());
</code></pre>
<h3 id="Stream常用方法"><a href="#Stream常用方法" class="headerlink" title="Stream常用方法"></a><span style = "color : red">Stream常用方法</span></h3><table>
<thead>
<tr>
<th>接口</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>forEach</td>
<td>循环遍历</td>
</tr>
<tr>
<td>map</td>
<td>map方法用于映射每个元素到对应的结果</td>
</tr>
<tr>
<td>filter</td>
<td>filter方法用于通知设置的条件过滤出元素</td>
</tr>
<tr>
<td>limit</td>
<td>limit方法用于获取指定数量的流</td>
</tr>
<tr>
<td>sorted</td>
<td>sorted方法用于对流进行排序</td>
</tr>
<tr>
<td>Collectors</td>
<td>Collectors类实现将流转换成集合和聚合元素</td>
</tr>
</tbody></table>
<pre><code class="java">StreamGenerator.java
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/*
Stream流对象的五种创建方式
 */
public class StreamGenerator &#123;
    //1.基于数组进行创建
    @Test
    public void generator1()&#123;
        String[] arr = &#123;&quot;Lily&quot;,&quot;Andy&quot;,&quot;Jackson&quot;,&quot;Smith&quot;&#125;;
        Stream&lt;String&gt; stream = Stream.of(arr);
        stream.forEach(s -&gt; System.out.println(s)); //forEach中使用Lambda表达式
    &#125;

    //2.基于集合进行创建
    @Test
    public void generator2()&#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;Lily&quot;);
        list.add(&quot;Andy&quot;);
        list.add(&quot;Jackson&quot;);
        list.add(&quot;Smith&quot;);
        Stream&lt;String&gt; stream = list.stream(); //利用集合获取stream
        stream.forEach(s -&gt; System.out.println(s));
    &#125;

    //3.利用generate方法创建无限长度流
    @Test
    public void generator3()&#123;
        Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; new Random().nextInt(100000));//Supplier&lt;T&gt; s 创建新对象
        stream.limit(10).forEach(i -&gt; System.out.println(i)); //limit限制长度
    &#125;

    //4.基于迭代器创建流
    @Test
    public void generator4()&#123;
        Stream&lt;Integer&gt; stream = Stream.iterate(1, n -&gt; n + 1);//无限长度自增
        stream.limit(100).forEach(i -&gt; System.out.println(i));
    &#125;

    //5.基于字符序列创建流
    @Test
    public void genetator5()&#123;
        String str = &quot;abcdefg我&quot;;
        IntStream stream = str.chars();
        stream.forEach(c -&gt; System.out.println((char)c));
    &#125;
&#125;
</code></pre>
<pre><code class="java">StreamMethod.java
import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamMethod &#123;
    @Test //提取集合中所有偶数并求和
    public void case1()&#123;
        List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
        int sum = list.stream() //获取stream对象
                .mapToInt(s -&gt; Integer.parseInt(s)) //对每个元素字符串转为整数
                .filter(n -&gt; n%2==0) //filter对流数据进行过滤
                .sum();//求和
        System.out.println(sum);
    &#125;

    @Test //所有名字首字母大写
    public void case2()&#123;
        List&lt;String&gt; list = Arrays.asList(&quot;lily&quot;,&quot;smith&quot;,&quot;jackson&quot;);
        List newList = list.stream()
                .map(s -&gt; s.substring(0, 1).toUpperCase() + s.substring(1)) //首字母大写转换
//                .forEach(s -&gt; System.out.println(s));
                .collect(Collectors.toList()); //collect对流数据进行收集,生成新的List/Set(将重复数据自动清除)
        System.out.println(newList);
    &#125;

    @Test //将所有奇数从大到小进行排序，且不允许出现重复
    public void case3()&#123;
        List&lt;Integer&gt; list = Arrays.asList(1, 60, 38, 21, 51, 60, 51, 73);
        List newList = list.stream().distinct() //去除重复的流数据
                .filter(n -&gt; n%2==1)
                .sorted((a,b) -&gt; b-a) //从大到小的数据排列
                .collect(Collectors.toList());
        System.out.println(newList);
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/10/26/后端/Maven,工厂模式,反射模式,Lambda表达式,stream流式处理/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/10/23/后端/java数据库开发(JDBC)/">
        <h2>
            java数据库开发(JDBC)
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/23
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="IDEA窗口快捷键"><a href="#IDEA窗口快捷键" class="headerlink" title="IDEA窗口快捷键"></a>IDEA窗口快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+Alt+S</td>
<td>Settings面板</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+F&#x2F;R</strong></td>
<td>当前Project中全局查找&#x2F;替换</td>
</tr>
<tr>
<td><strong>Ctrl+Shif+N</strong></td>
<td>文件查找面板</td>
</tr>
<tr>
<td>Alt+Insert</td>
<td>快速生成面板</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+A</strong></td>
<td>Find Action模糊<strong>查询快速定位</strong></td>
</tr>
</tbody></table>
<h3 id="代码快捷键"><a href="#代码快捷键" class="headerlink" title="代码快捷键"></a>代码快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+←→</td>
<td>上一个&#x2F;下一个单词</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+Enter</strong></td>
<td><strong>自动完成</strong></td>
</tr>
<tr>
<td>Alt+Enter</td>
<td>智能提示</td>
</tr>
<tr>
<td>Ctrl+Alt+L</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl+(Shift)+&#x2F;</td>
<td>行注释&#x2F;块注释</td>
</tr>
<tr>
<td>Ctrl+Alt+Shift+J</td>
<td>列操作</td>
</tr>
<tr>
<td>Shift+F6</td>
<td>重命名(当前选择变量修改)</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>选中单词</td>
</tr>
</tbody></table>
<h3 id="代码快速定位"><a href="#代码快速定位" class="headerlink" title="代码快速定位"></a>代码快速定位</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+(Shift)+E</td>
<td>最近访问(编辑)的文件列表</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+1~9</strong></td>
<td><strong>创建书签</strong></td>
</tr>
<tr>
<td><strong>Shift+F11</strong></td>
<td><strong>查看书签</strong></td>
</tr>
<tr>
<td><strong>Ctrl+1~9</strong></td>
<td><strong>快速切换书签</strong></td>
</tr>
<tr>
<td>Alt+←→</td>
<td>切换书签</td>
</tr>
</tbody></table>
<h6 id="Template使用"><a href="#Template使用" class="headerlink" title="Template使用"></a>Template使用</h6><p><strong>Live Templates</strong>可以添加常用快捷字母作为快捷代码</p>
<blockquote>
<p>右方 + “custom”<br>“<strong>Abbreviation</strong>：al”<br>“<strong>Description</strong>：Create ArrayList”<br>“<strong>Template text</strong>：List&lt; String &gt;list &#x3D; new ArrayList();”<br>“<strong>Template text</strong>：List&lt; $VAR1$&gt;$VAR2$ &#x3D; new ArrayList();”<br>点击define设置全部</p>
</blockquote>
<h3 id="运行与打包"><a href="#运行与打包" class="headerlink" title="运行与打包"></a>运行与打包</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Shift+F9</td>
<td>调试</td>
</tr>
<tr>
<td>Shift+F10</td>
<td>运行</td>
</tr>
<tr>
<td>F8</td>
<td>单步运行</td>
</tr>
<tr>
<td>F9</td>
<td>恢复运行至下一个端点</td>
</tr>
<tr>
<td>Shift+Ctrl+F8</td>
<td>查看所有端点</td>
</tr>
</tbody></table>
<h6 id="Jar包核心配置文件设置-加载响应的Class"><a href="#Jar包核心配置文件设置-加载响应的Class" class="headerlink" title="Jar包核心配置文件设置(加载响应的Class)"></a>Jar包核心配置文件设置(加载响应的Class)</h6><h4 id="将编译的类导入jar包"><a href="#将编译的类导入jar包" class="headerlink" title="将编译的类导入jar包"></a>将编译的类导入jar包</h4><p><strong><u>‘……’ compile output</u></strong><br><strong>Project Structure → Artifacts → Outpub Layout</strong></p>
<p>设置jar包的入口类 → Create Manifest… → Main Class(Jar包加载相应目录)</p>
<h4 id="生成jar包"><a href="#生成jar包" class="headerlink" title="生成jar包"></a>生成jar包</h4><p>上述操作完毕后 点<strong>Build</strong> 点<strong>Build Artifacts…</strong> </p>
<h3 id="IDEA快速开发Web应用"><a href="#IDEA快速开发Web应用" class="headerlink" title="IDEA快速开发Web应用"></a>IDEA快速开发Web应用</h3><p>New Project → Java Enterprise → SDK1.8 &#x3D; Java EE7</p>
<h6 id="改变Tomcat启动时自动弹出的地址"><a href="#改变Tomcat启动时自动弹出的地址" class="headerlink" title="改变Tomcat启动时自动弹出的地址"></a>改变Tomcat启动时自动弹出的地址</h6><p><strong>Run&#x2F;Debug Configurations</strong> → Deployment → 下方的 Application context</p>
<h6 id="Project-Structure"><a href="#Project-Structure" class="headerlink" title="Project Structure"></a>Project Structure</h6><p>Artifacts 中默认存在 <strong>javaweb: war exploded</strong> 代表用文件夹的方式与Tomcat联动<br>点Add → <strong>Web Application: Archive</strong>打包 右侧是待添加 [文件成功发布到jar包中 <strong>‘javaweb’ compile output</strong>] 右侧的<strong>Web facet resources</strong> 是 jsp, html等静态资源双击放到左边[<strong>‘javaweb’module: ‘Web’ facet resources</strong>] 至此javaweb.war包就包含了所有文件。上述操作完毕后 点<strong>Build</strong> 点<strong>Build Artifacts…</strong> build！！之后若在实际运行的时候放在D:\apache-tomcat-8.5.93\webapps内 之后启动<strong>tomcat</strong>[D:\apache-tomcat-8.5.93\bin\startup.bat]就可以显示结果</p>
<h3 id="JDBC-Java-DataBase-Connectivity-快速入门"><a href="#JDBC-Java-DataBase-Connectivity-快速入门" class="headerlink" title="JDBC(Java DataBase Connectivity)快速入门"></a>JDBC(Java DataBase Connectivity)快速入门</h3><p>JDBC作用，<u>在java程序中与关系型数据库进行交互</u></p>
<h6 id="JDBC优点"><a href="#JDBC优点" class="headerlink" title="JDBC优点"></a>JDBC优点</h6><ul>
<li>统一的API，提供一致的开发过程</li>
<li>易于学习，容易上手，代码结构稳定</li>
<li>功能强大，执行效率高，可处理海量数据</li>
</ul>
<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><table>
<thead>
<tr>
<th>1.加载并注册JDBC驱动</th>
</tr>
</thead>
<tbody><tr>
<td>2.创建数据库连接</td>
</tr>
<tr>
<td>3.创建Satement对象</td>
</tr>
<tr>
<td>4.遍历查询结果</td>
</tr>
<tr>
<td>5.关闭连接.释放资源</td>
</tr>
</tbody></table>
<h3 id="Class-forName的作用"><a href="#Class-forName的作用" class="headerlink" title="Class.forName的作用"></a>Class.forName的作用</h3><ul>
<li>Class.forName用于加载指定的JDBC驱动类</li>
<li>Class.forName本质是通知JDBC注册这个驱动类</li>
<li>驱动由数据库厂商自行开发，俩厂家不同链接祖父串了，字符串也不同</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/34bcb468f79e1c2701e12f8c4d8eb06954ed2f38/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p>
<h3 id="创建数据库连接代码"><a href="#创建数据库连接代码" class="headerlink" title="创建数据库连接代码"></a>创建数据库连接代码</h3><pre><code class="sql">String dbDriver = &quot;com.mysql.cj.jdbc.Driver&quot;; //JDBC驱动类
String dbURL = &quot;jdbc:mysql://localhost:3306/imooc&quot;; //连接字符串
String dbUsername =  &quot;root&quot;;
String dbPassword = &quot;123456&quot;;
//1.加载并初始化JDBC驱动
Class.forName(dbDriver);
//2.创建数据库连接
Connection connection = DriverManager.getConnection(dbURL,dbUsername,dbPassword);
</code></pre>
<pre><code class="sql">StandardJDBCSample.java
package com.example.imoocjdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class StandardJDBCSample &#123;
    public static void main(String[] args) &#123;
        Connection conn = null;
        try &#123;
            //1.加载并注册JDBC驱动
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //加载指定的类
            //2.创建数据库连接
            conn = DriverManager.getConnection(
                    &quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;&amp;allowPublicKeyRetrieval=true&quot;,
                    &quot;root&quot;, &quot;root&quot;
            ); //程序和数据库的网络通信桥梁
            //3.创建Satement对象 ResultSet结果集
            Statement stmt = conn.createStatement(); //一条或多条sql语句
            ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM employee WHERE dname=&#39;研发部&#39;&quot;);
            //4.遍历查询结果
            while (rs.next()) &#123;
                Integer eno = rs.getInt(1); //把当前行指定未知的提取 eno
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary);
            &#125;
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            try &#123;
                if (conn != null &amp;&amp; conn.isClosed() == false) &#123;
                    //5.关闭连接.释放资源
                    conn.close();
                &#125;
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="JDBC驱动的秘密"><a href="#JDBC驱动的秘密" class="headerlink" title="JDBC驱动的秘密"></a>JDBC驱动的秘密</h3><h5 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h5><ul>
<li><strong>DriverManager</strong>用于注册&#x2F;管理JDBC驱动程序</li>
<li><strong>DriverManager.getConnection</strong>(连接字符串,用户名,密码)</li>
<li>返回值<strong>Connection</strong>对象,对应数据库的物理网络连接</li>
</ul>
<h5 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h5><ul>
<li><strong>Connection</strong>对象用于JDBC与数据库的网络通信对象</li>
<li>java.sql.Connection是一个接口，具体由驱动厂商实现</li>
<li>所有数据库的操作都建立在Connection上</li>
</ul>
<h3 id="MySQL连接字符串"><a href="#MySQL连接字符串" class="headerlink" title="MySQL连接字符串"></a>MySQL连接字符串</h3><ul>
<li>格式: jdbc:mysql:&#x2F;&#x2F;[主机ip] [:端口]&#x2F;数据库名?参数列表</li>
<li>主机ip与端口是可选设置，默认值为127.0.0.1与3306</li>
<li>参数列表采用url编码,格式:参数1&#x3D;值1&amp;参数2&#x3D;值2</li>
</ul>
<h6 id="MySQL连接字符串常用参数"><a href="#MySQL连接字符串常用参数" class="headerlink" title="MySQL连接字符串常用参数"></a>MySQL连接字符串常用参数</h6><table>
<thead>
<tr>
<th>参数名</th>
<th>建议参数值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>useSSL</td>
<td>true(生产) false(开发)</td>
<td>是否禁用ssl</td>
</tr>
<tr>
<td>useUnicode</td>
<td>true</td>
<td>启用unicode编码传输数据</td>
</tr>
<tr>
<td>characterEncoding</td>
<td>UTF-8</td>
<td>使用UTF-8编码传输数据</td>
</tr>
<tr>
<td>serverTimezone</td>
<td>Asia&#x2F;Shanghai</td>
<td>使用东8时区时间,UTC+8</td>
</tr>
<tr>
<td>allowPublicKeyRetrieval</td>
<td>true</td>
<td>允许从客户端获取公钥加密传输</td>
</tr>
</tbody></table>
<h6 id="超级异常捕获"><a href="#超级异常捕获" class="headerlink" title="超级异常捕获"></a>超级异常捕获</h6><p>选中所需要的代码区域 → Code → Surround With → 6.try…catch</p>
<h3 id="SQL注入攻击-数据泄露"><a href="#SQL注入攻击-数据泄露" class="headerlink" title="SQL注入攻击 [数据泄露]"></a>SQL注入攻击 [数据泄露]</h3><p>当输入部门名称：**’ or 1&#x3D;1 or 1&#x3D;’**<br>只要在or左右两侧有一个成立就都成立的 输入的数据中并没有对单引号加以处理；</p>
<pre><code class="sql">package com.imooc.jdbc.hrapp.command;

import java.sql.*;
import java.util.Scanner;

/**
 * 数据查询方法
 */
public class QueryCommand implements Command &#123;
    @Override
    public void execute() &#123;
        System.out.print(&quot;请输入部门名称：&quot;);
        Scanner in = new Scanner(System.in);
        String pdname = in.nextLine();
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try &#123;
            //1. 加载并注册JDBC驱动
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
            //2. 创建数据库连接
            conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;);
            //3. 创建Statement对象
            stmt = conn.createStatement();
            //结果集
            System.out.println(&quot;select * from employee where dname=&#39;&quot; + pdname + &quot;&#39;&quot;);
            rs = stmt.executeQuery(&quot;select * from employee where dname=&#39;&quot; + pdname + &quot;&#39;&quot;);
            //4. 遍历查询结果
            //rs.next()返回布尔值，代表是否存在下一条记录
            //如果有，返回true,同时结果集提取下一条记录
            //如果没有，返回false，循环就会停止
            while (rs.next()) &#123;
                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary);

            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //5. 关闭连接,释放资源
            try &#123;
                if(rs != null)&#123;
                    rs.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;

            try &#123;
                if(stmt != null)&#123;
                    stmt.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;

            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed() ) &#123;
                    conn.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="PreparedStatement-解决SQL攻击注入问题-特殊字符转义"><a href="#PreparedStatement-解决SQL攻击注入问题-特殊字符转义" class="headerlink" title="PreparedStatement[解决SQL攻击注入问题(特殊字符转义)]"></a><span style = "color:red">PreparedStatement[解决SQL攻击注入问题(特殊字符转义)]</span></h3><h6 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h6><ul>
<li>SQL注入攻击是指利用SQL漏洞越权获取数据的黑客行为</li>
<li>SQL注入攻击根源是未对原始SQL中的敏感字符做特殊处理</li>
<li>解决方法：放弃Statement改用PreparedStatement处理SQL</li>
</ul>
<h6 id="PreparedStatement-变化的地方用问号替代"><a href="#PreparedStatement-变化的地方用问号替代" class="headerlink" title="PreparedStatement [变化的地方用问号替代]"></a>PreparedStatement [变化的地方用问号替代]</h6><ul>
<li>PreparedStatement预编译Statement是Statement的子接口</li>
<li>PreparedStatement对SQL进行参数化, 预防SQL注入攻击</li>
<li>PreparedStatement比Statement执行效率更高</li>
<li>要用<strong>参数化</strong>的sql语句(问号只能出现在值的地方 且不能二次计算)<br><strong>String sql &#x3D; “select * from employee where <u>dname&#x3D;?</u> and <u>eno &gt; ?</u>“;</strong><br><strong>pstmt &#x3D; conn.prepareStatement(sql);</strong><br><strong>pstmt.setString(1,pdname);</strong> &#x2F;&#x2F;插入多句 自动寻导入上方sql语句<br><strong>pstmt.setInt(2,3500);</strong></li>
</ul>
<pre><code class="sql">//利用PreparedStatement预防SQL注入风险
//当dname值为&#39; or 1=1 or 1=&#39; 时，查询不到任何结果
//SQL:select * from employee where dname = &#39;\&#39; or 1=1 or 1=\”
String sql = &quot;select * from employee where dname=?&quot;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1,dname); //设置SQL参数,参数从1开始
ResultSet rs = pstmt.executeQuery();
while(rs.next())&#123;
    ...
&#125;
</code></pre>
<h3 id="JDBC实现写数据"><a href="#JDBC实现写数据" class="headerlink" title="JDBC实现写数据"></a>JDBC实现写数据</h3><h5 id="封装DbUtils工具类-重复代码封装工具类-封装打开和关闭连接方法"><a href="#封装DbUtils工具类-重复代码封装工具类-封装打开和关闭连接方法" class="headerlink" title="封装DbUtils工具类 [重复代码封装工具类(封装打开和关闭连接方法)]"></a>封装DbUtils工具类 [<u>重复代码封装工具类(封装打开和关闭连接方法)</u>]</h5><pre><code class="sql">DbUtils.java
package common;

import kotlin.Result;

import java.sql.*;

public class DbUtils &#123;
    /**
     * 创建新的数据库连接
     * @return 新的Connection对象
     * @throws ClassNotFoundException
     * @throws SQLException
     */
    public static Connection getConnection() throws ClassNotFoundException, SQLException &#123;
        //1. 加载并注册JDBC驱动
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        //2. 创建数据库连接
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;);
        return conn;
    &#125;

    /**
     * 关闭连接，释放资源
     * @param rs 结果集对象
     * @param stmt Statement对象
     * @param conn Connection对象
     */
    public static void closeConnection(ResultSet rs, Statement stmt, Connection conn)&#123;
        try &#123;
            if(rs != null)&#123;
                rs.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;

        try &#123;
            if(stmt != null)&#123;
                stmt.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;

        try &#123;
            if(conn != null &amp;&amp; !conn.isClosed() ) &#123;
                conn.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="JDBC执行INSERT语句"><a href="#JDBC执行INSERT语句" class="headerlink" title="JDBC执行INSERT语句"></a>JDBC执行INSERT语句</h3><pre><code class="sql">String sql = &quot;insert into employee(eno,ename) values(?,?)&quot;;
PreparedStatement pstmt = conn.PreparedStatement(sql);
pstmt.setInt(1,10);
pstmt.setString(2,&quot;张三&quot;);
//executeUpdate方法返回记录数
int cnt = pstmt.executeUpdate(); //cnt=1
System.out.println(&quot;数据新增成功&quot;);
</code></pre>
<h3 id="JDBC执行UPDATE语句"><a href="#JDBC执行UPDATE语句" class="headerlink" title="JDBC执行UPDATE语句"></a>JDBC执行UPDATE语句</h3><pre><code class="sql">String sql = &quot;update employee set salary = salary + 1000 where dname=?&quot;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1,&quot;研发部&quot;);
//executeUpdate方法返回记录数
int cnt = pstmt.exexuteUpdate();
System.out.println(“研发部”+cnt+&quot;名员工提薪1000元&quot;);
</code></pre>
<h3 id="JDBC执行DELETE语句"><a href="#JDBC执行DELETE语句" class="headerlink" title="JDBC执行DELETE语句"></a>JDBC执行DELETE语句</h3><pre><code class="sql">String sql = &quot;delete from employee where eno = ?&quot;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setInt(1,3395);
//executeUpdate方法返回记录数
int cnt = pstmt.executeUpdate();
System.out.println(cnt+&quot;名员工数据已被删除&quot;);
</code></pre>
<h3 id="JDBC事务管理方式"><a href="#JDBC事务管理方式" class="headerlink" title="JDBC事务管理方式"></a>JDBC事务管理方式</h3><ul>
<li>事务是以一种可靠的、一致的方式，访问和操作数据库的程序单元</li>
<li>说人话：要么把事情做完，要么什么都不做，不要做一半</li>
<li>事务依赖于数据库实现，MySQL通过<strong>事务区</strong>作为数据缓冲地带</li>
</ul>
<blockquote>
<h6 id="事务的提交操作"><a href="#事务的提交操作" class="headerlink" title="事务的提交操作"></a>事务的提交操作</h6><p>应用程序写操作給事务区等全部完成后事务区再<strong>commit提交</strong>給数据表<strong>一次性写入</strong>給mysql。提交成功后事务区中的数据被清空</p>
<h6 id="事务的回滚操作"><a href="#事务的回滚操作" class="headerlink" title="事务的回滚操作"></a>事务的回滚操作</h6><p>应用程序写操作給事务区，如果+100突然-100程序报错了，由jdbc会向事务区发起rollback回滚操作 清空事务区，最终数据表不会产生任何写操作[<u>要么什么都不做，不要做一半</u>]</p>
</blockquote>
<h3 id="JDBC两种事务模式"><a href="#JDBC两种事务模式" class="headerlink" title="JDBC两种事务模式"></a>JDBC两种事务模式</h3><ul>
<li><h6 id="自动提交事务模式"><a href="#自动提交事务模式" class="headerlink" title="自动提交事务模式"></a>自动提交事务模式</h6></li>
</ul>
<p>​        自动提交模式是指每一次写操作SQL，自动提交事务</p>
<pre><code class="sql">自动提交开启方法:
conn.setAutoCommit(true)
</code></pre>
<p>​        自动事务是JDBC默认行为，此模式无法保证多数据一致性[A钱少了 B钱增加]</p>
<ul>
<li><h6 id="手动提交事务模式"><a href="#手动提交事务模式" class="headerlink" title="手动提交事务模式"></a>手动提交事务模式</h6></li>
</ul>
<p>​        手动提交模式是指显式调用commit()与rollback()方法管理事务</p>
<pre><code class="sql">手动提交开启方法:
conn.setAutoCommit(false)
</code></pre>
<p>​        手动提交事务可保证多数据一致性，但必须手动调用提交&#x2F;回滚方法</p>
<h3 id="实现批量增加员工"><a href="#实现批量增加员工" class="headerlink" title="实现批量增加员工"></a>实现批量增加员工</h3><pre><code class="sql">package test;

import common.DbUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TransactionSample &#123;
    public static void main(String[] args) &#123;
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123; //JDBC默认使用自动提交模式
            conn = DbUtils.getConnection();
            conn.setAutoCommit(false); //关闭自动提交
            String sql = &quot;insert ignore into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;;
            for (int i = 1000; i &lt; 2000; i++) &#123;
                if (i==1005)&#123;
//                    throw new RuntimeException(&quot;插入失败&quot;);
                &#125;
                pstmt = conn.prepareStatement(sql);
                pstmt.setInt(1,i);
                pstmt.setString(2,&quot;员工&quot; + i);
                pstmt.setFloat(3,4000f);
                pstmt.setString(4,&quot;市场部&quot;);
                pstmt.executeUpdate();
            &#125;
            conn.commit(); //提交数据
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed()) &#123;
                    conn.rollback(); //回滚数据
                &#125;
            &#125; catch (SQLException ex) &#123;
                throw new RuntimeException(ex);
            &#125;
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="基于实体类实现分页数据封装"><a href="#基于实体类实现分页数据封装" class="headerlink" title="基于实体类实现分页数据封装"></a>基于实体类实现分页数据封装</h3><p>日常开发中如果要对数据进行提取以后最常见的形式是将数据转换为对应的实体类再放到集合中进行保存，即使被关闭数据也不会丢失。</p>
<pre><code class="sql">package common;

import common.entity.Employee;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 分页查询员工数据
 */
public class PaginationCommand implements Command&#123;
    @Override
    public void execute() &#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入页号:&quot;);
        int page = in.nextInt();
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        List&lt;Employee&gt; list = new ArrayList(); //将底下的信息封装到实体类中
        try &#123;
            conn = DbUtils.getConnection(); //?前面第几行 10从这行开始向后取10条记录 limit是分页独有的方言
            String sql = &quot;select * from employee limit ?,10&quot;;
            pstmt = conn.prepareStatement(sql);
            pstmt.setInt(1,(page-1)*10); //第二页(2-1)*10从第十条记录开始向后取10条
            rs = pstmt.executeQuery();
            while(rs.next())&#123;
                Integer eno = rs.getInt(&quot;eno&quot;); //不能在原有字段1前再新增1 按照名字来获取
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                //JDBC获取日期使用java.sql.Date,其继承自java.util.Date
                //所以两者互相兼容
                Date hiredate = rs.getDate(&quot;hiredate&quot;);
                Employee emp = new Employee(); //每产生一条记录都要封装成Employee对象
                emp.setEno(eno);
                emp.setEname(ename);
                emp.setSalary(salary);
                emp.setDname(dname);
                emp.setHiredate(hiredate);//把每一条记录都封装成为了实体类 放入list
                list.add(emp);
            &#125;
            System.out.println(list.size());
        &#125; catch (Exception e)&#123;
            e.printStackTrace();
        &#125; finally &#123;
            DbUtils.closeConnection(rs,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="JDBC中Date日期对象的处理"><a href="#JDBC中Date日期对象的处理" class="headerlink" title="JDBC中Date日期对象的处理"></a>JDBC中Date日期对象的处理</h3><pre><code class="sql">package common;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

/*
   新增员工数据
 */
public class InsertCommand implements Command&#123;
    @Override
    public void execute()&#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入员工编号:&quot;);
        int eno = in.nextInt();
        System.out.println(&quot;请输入员工姓名:&quot;);
        String ename = in.next();
        System.out.println(&quot;请输入员工薪资:&quot;);
        float salary = in.nextFloat();
        System.out.println(&quot;请输入隶属部门:&quot;);
        String dname = in.next();
        System.out.println(&quot;请输入入职日期:&quot;);
        String strHiredate = in.next();
        //String到java.sql.Date分为两步
        //1.前端传入的String字符串转为java.util.Date
        java.util.Date udHiredate = null;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            udHiredate = sdf.parse(strHiredate);//对原有字符串解析
        &#125; catch (ParseException e) &#123;
            throw new RuntimeException(e);
        &#125;
        //2.java.util.Date转为java.sql.Date
        long time = udHiredate.getTime();//获取从1970到现在的毫秒数
        java.sql.Date sdHiredate = new java.sql.Date(time); //sdHiredate成功表达了strHiredate所表达的时间
        Connection conn = null;
        PreparedStatement pstmt = null;
        //新增数据 获取数据库连接
        try &#123;
            conn = DbUtils.getConnection(); //↓作为写操作的sql一定要是参数化的(pstmt)
            String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) value(?,?,?,?,?)&quot;;
            pstmt = conn.prepareStatement(sql); //sql被解析
            pstmt.setInt(1,eno);
            pstmt.setString(2,ename);
            pstmt.setFloat(3,salary);
            pstmt.setString(4,dname);
            pstmt.setDate(5,sdHiredate); //目标java.sql.Date
            int cnt = pstmt.executeUpdate();//所有要改变数据表的都要使用executeUpdate
            System.out.println(&quot;cnt:&quot; + cnt); //代表本次写入影响的记录数量
            System.out.println(ename + &quot;员工入职手续已办理&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn); //释放所有资源
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="JDBC批量处理"><a href="#JDBC批量处理" class="headerlink" title="JDBC批量处理"></a>JDBC批量处理</h3><p>需要反复执行同时一次性要插入很多数据的操作使用批处理操作</p>
<pre><code class="sql">BatchSample.java
package test;

import common.DbUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Date;

public class BatchSample &#123;
    private static void tc1()&#123;
        //标准未使用批处理
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123; //JDBC默认使用自动提交模式
            long startTime = new Date().getTime();
            conn = DbUtils.getConnection();
            conn.setAutoCommit(false); //关闭自动提交
            String sql = &quot;insert ignore into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;;
            for (int i = 100000; i &lt; 200000; i++) &#123;
                pstmt = conn.prepareStatement(sql);
                pstmt.setInt(1,i);
                pstmt.setString(2,&quot;员工&quot; + i);
                pstmt.setFloat(3,4000f);
                pstmt.setString(4,&quot;市场部&quot;);
                pstmt.executeUpdate();
            &#125;
            conn.commit(); //提交数据
            long endTime = new Date().getTime();
            System.out.println(&quot;tc1()执行时长: &quot; + (endTime-startTime));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed()) &#123;
                    conn.rollback(); //回滚数据
                &#125;
            &#125; catch (SQLException ex) &#123;
                throw new RuntimeException(ex);
            &#125;
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;

    private static void tc2()&#123;
        //使用批处理插入若干数据
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123; //JDBC默认使用自动提交模式
            long startTime = new Date().getTime();
            conn = DbUtils.getConnection();
            conn.setAutoCommit(false); //关闭自动提交
            String sql = &quot;insert ignore into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;;
            for (int i = 200000; i &lt; 300000; i++) &#123;
                pstmt = conn.prepareStatement(sql);
                pstmt.setInt(1,i);
                pstmt.setString(2,&quot;员工&quot; + i);
                pstmt.setFloat(3,4000f);
                pstmt.setString(4,&quot;市场部&quot;);
//                pstmt.executeUpdate();
                pstmt.addBatch();//将参数加入批处理任务
            &#125;
            pstmt.executeBatch();//执行批处理任务
            conn.commit(); //提交数据
            long endTime = new Date().getTime();
            System.out.println(&quot;tc2()执行时长: &quot; + (endTime-startTime));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed()) &#123;
                    conn.rollback(); //回滚数据
                &#125;
            &#125; catch (SQLException ex) &#123;
                throw new RuntimeException(ex);
            &#125;
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        tc1(); //222279ms
        tc2(); //15827 ms
    &#125;
&#125;
</code></pre>
<h3 id="综合数据库的增删改查"><a href="#综合数据库的增删改查" class="headerlink" title="综合数据库的增删改查"></a>综合数据库的增删改查</h3><pre><code class="sql">HumanResourceApplication.java
package test;

import common.*;

import java.util.Scanner;

public class HumanResourceApplication &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;1-查询部门员工&quot;);
        System.out.println(&quot;2-办理员工入职&quot;);
        System.out.println(&quot;3-调整薪资&quot;);
        System.out.println(&quot;4-员工离职&quot;);
        System.out.println(&quot;5-分页查询员工数据&quot;);
        System.out.println(&quot;请选择功能:&quot;);
        Scanner in = new Scanner(System.in);
        Integer cmd = in.nextInt();
        Command command = null;
        switch (cmd)&#123;
            case 1://查询部门员工
                command = new PstmtQueryCommand();
                command.execute();
                break;
            case 2:
                command = new InsertCommand();
                command.execute();
                break;
            case 3:
                command = new UpdateCommand();
                command.execute();
                break;
            case 4:
                command = new DeleteCommand();
                command.execute();
                break;
            case 5:
                command = new PaginationCommand();
                command.execute();
                break;
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="插入员工"><a href="#插入员工" class="headerlink" title="插入员工"></a>插入员工</h6><pre><code class="sql">InsertCommand.java
package common;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

/*
   新增员工数据
 */
public class InsertCommand implements Command&#123;
    @Override
    public void execute()&#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入员工编号:&quot;);
        int eno = in.nextInt();
        System.out.println(&quot;请输入员工姓名:&quot;);
        String ename = in.next();
        System.out.println(&quot;请输入员工薪资:&quot;);
        float salary = in.nextFloat();
        System.out.println(&quot;请输入隶属部门:&quot;);
        String dname = in.next();
        System.out.println(&quot;请输入入职日期:&quot;);
        String strHiredate = in.next();
        //String到java.sql.Date分为两步
        //1.前端传入的String字符串转为java.util.Date
        java.util.Date udHiredate = null;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            udHiredate = sdf.parse(strHiredate);//对原有字符串解析
        &#125; catch (ParseException e) &#123;
            throw new RuntimeException(e);
        &#125;
        //2.java.util.Date转为java.sql.Date
        long time = udHiredate.getTime();//获取从1970到现在的毫秒数
        java.sql.Date sdHiredate = new java.sql.Date(time); //sdHiredate成功表达了strHiredate所表达的时间
        Connection conn = null;
        PreparedStatement pstmt = null;
        //新增数据 获取数据库连接
        try &#123;
            conn = DbUtils.getConnection(); //↓作为写操作的sql一定要是参数化的(pstmt)
            String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) value(?,?,?,?,?)&quot;;
            pstmt = conn.prepareStatement(sql); //sql被解析
            pstmt.setInt(1,eno);
            pstmt.setString(2,ename);
            pstmt.setFloat(3,salary);
            pstmt.setString(4,dname);
            pstmt.setDate(5,sdHiredate); //目标java.sql.Date
            int cnt = pstmt.executeUpdate();//所有要改变数据表的都要使用executeUpdate
            System.out.println(&quot;cnt:&quot; + cnt); //代表本次写入影响的记录数量
            System.out.println(ename + &quot;员工入职手续已办理&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn); //释放所有资源
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="更新员工数据"><a href="#更新员工数据" class="headerlink" title="更新员工数据"></a>更新员工数据</h6><pre><code class="sql">UpdateCommand.java
package common;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Scanner;

public class UpdateCommand implements Command&#123;
    @Override
    public void execute()&#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入员工编号&quot;);
        int eno = in.nextInt();
        System.out.println(&quot;请输入员工新的薪资&quot;);
        float salary = in.nextFloat();
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123;
            conn = DbUtils.getConnection();
            String sql = &quot;update employee set salary=? where dname=?&quot;;
             pstmt = conn.prepareStatement(sql);
             pstmt.setFloat(1,salary);
             pstmt.setInt(2,eno);
             int cnt = pstmt.executeUpdate();
             if (cnt == 1)&#123;
                 System.out.println(&quot;员工薪资调整完毕&quot;);
             &#125;else &#123;
                 System.out.println(&quot;未找到&quot; + eno + &quot;编号员工数据&quot;);
             &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="删除员工数据"><a href="#删除员工数据" class="headerlink" title="删除员工数据"></a>删除员工数据</h6><pre><code class="sql">DeleteCommand.java
package common;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Scanner;

public class DeleteCommand implements Command&#123;
    @Override
    public void execute()&#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入员工编号&quot;);
        int eno = in.nextInt();
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123;
            conn = DbUtils.getConnection();
            String sql = &quot;delete from employee where eno = ?&quot;;
             pstmt = conn.prepareStatement(sql);
             pstmt.setFloat(1,eno);
             int cnt = pstmt.executeUpdate();
             if (cnt == 1)&#123;
                 System.out.println(&quot;员工离职手续已完成&quot;);
             &#125;else &#123;
                 System.out.println(&quot;未找到&quot; + eno + &quot;编号员工数据&quot;);
             &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="查找员工数据"><a href="#查找员工数据" class="headerlink" title="查找员工数据"></a>查找员工数据</h6><pre><code class="sql">PstmtQueryCommand.java
package common;

import java.sql.*;
import java.util.Scanner;

/**
 * PreparedStatement对象使用方法
 */
public class PstmtQueryCommand implements Command &#123;

    public void execute() &#123;
        System.out.print(&quot;请输入部门名称：&quot;);
        Scanner in = new Scanner(System.in);
        String pdname = in.nextLine();
        Connection conn = null;
//        Statement stmt = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try &#123;
            //1. 加载并注册JDBC驱动
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
            //2. 创建数据库连接
            conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;);
            //3. 创建PreparedStatement对象
            String sql = &quot;select * from employee where dname=? and eno &gt; ?&quot;;
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1,pdname); //注意:参数索引从1
            pstmt.setInt(2,3500);
            //结果集
            rs = pstmt.executeQuery();
            //4. 遍历查询结果
            //rs.next()返回布尔值，代表是否存在下一条记录
            //如果有，返回true,同时结果集提取下一条记录
            //如果没有，返回false，循环就会停止
            while (rs.next()) &#123;
                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary);

            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //5. 关闭连接,释放资源
            try &#123;
                if(rs != null)&#123;
                    rs.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;

            try &#123;
                if(pstmt != null)&#123;
                    pstmt.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;

            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed() ) &#123;
                    conn.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="分页查询员工数据"><a href="#分页查询员工数据" class="headerlink" title="分页查询员工数据"></a>分页查询员工数据</h6><pre><code class="sql">PaginationCommand.java
package common;

import common.entity.Employee;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 分页查询员工数据
 */
public class PaginationCommand implements Command&#123;
    @Override
    public void execute() &#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入页号:&quot;);
        int page = in.nextInt();
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        List&lt;Employee&gt; list = new ArrayList(); //将底下的信息封装到实体类中
        try &#123;
            conn = DbUtils.getConnection(); //?前面第几行 10从这行开始向后取10条记录 limit是分页独有的方言
            String sql = &quot;select * from employee limit ?,10&quot;;
            pstmt = conn.prepareStatement(sql);
            pstmt.setInt(1,(page-1)*10); //第二页(2-1)*10从第十条记录开始向后取10条
            rs = pstmt.executeQuery();
            while(rs.next())&#123;
                Integer eno = rs.getInt(&quot;eno&quot;); //不能在原有字段1前再新增1 按照名字来获取
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                //JDBC获取日期使用java.sql.Date,其继承自java.util.Date
                //所以两者互相兼容
                Date hiredate = rs.getDate(&quot;hiredate&quot;);
                Employee emp = new Employee(); //每产生一条记录都要封装成Employee对象
                emp.setEno(eno);
                emp.setEname(ename);
                emp.setSalary(salary);
                emp.setDname(dname);
                emp.setHiredate(hiredate);//把每一条记录都封装成为了实体类 放入list
                list.add(emp);
            &#125;
            System.out.println(list.size());
        &#125; catch (Exception e)&#123;
            e.printStackTrace();
        &#125; finally &#123;
            DbUtils.closeConnection(rs,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="DbUtils【通用】"><a href="#DbUtils【通用】" class="headerlink" title="DbUtils【通用】"></a>DbUtils【通用】</h6><pre><code class="sql">DbUtils.java
package common;

import kotlin.Result;

import java.sql.*;

public class DbUtils &#123;
    /**
     * 创建新的数据库连接
     * @return 新的Connection对象
     * @throws ClassNotFoundException
     * @throws SQLException
     */
    public static Connection getConnection() throws ClassNotFoundException, SQLException &#123;
        //1. 加载并注册JDBC驱动
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        //2. 创建数据库连接
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;);
        return conn;
    &#125;

    /**
     * 关闭连接，释放资源
     * @param rs 结果集对象
     * @param stmt Statement对象
     * @param conn Connection对象
     */
    public static void closeConnection(ResultSet rs, Statement stmt, Connection conn)&#123;
        try &#123;
            if(rs != null)&#123;
                rs.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;

        try &#123;
            if(stmt != null)&#123;
                stmt.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;

        try &#123;
            if(conn != null &amp;&amp; !conn.isClosed() ) &#123;
                conn.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="Employee（entity）"><a href="#Employee（entity）" class="headerlink" title="Employee（entity）"></a>Employee（entity）</h6><pre><code class="sql">package common.entity;

import java.util.Date;

/**
 * 员工实体类
 */
public class Employee &#123;
    /**
     * 1. 具备默认构造函数
     * 2. 属性私有
     * 3. 存在getter与setter
     */
    public Employee()&#123;

    &#125;
    //通常和数据库数据一一对应
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    public Date getHiredate() &#123;
        return hiredate;
    &#125;

    public void setHiredate(Date hiredate) &#123;
        this.hiredate = hiredate;
    &#125;
&#125;
</code></pre>
<h3 id="阿里巴巴Druid连接池-类似于施工仓库-在启动应用时创建连接池"><a href="#阿里巴巴Druid连接池-类似于施工仓库-在启动应用时创建连接池" class="headerlink" title="阿里巴巴Druid连接池[类似于施工仓库 在启动应用时创建连接池]"></a>阿里巴巴Druid连接池[类似于施工仓库 在启动应用时创建连接池]</h3><p>JDBC先去创建与数据库的连接 比较浪费资源和时间</p>
<ul>
<li>Druid是阿里巴巴开源连接池组件，是最好的连接池之一</li>
<li>Druid对数据库连接进行有效管理与重用，最大化程序执行效率</li>
<li>连接池负责创建管理连接，程序只负责取用和归还</li>
</ul>
<p>&#x2F;druid-config.properties要放到resources文件夹内</p>
<pre><code class="sql">druid-config.properties

driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true
username=root
password=root
initialSize=10 #初始数量
maxActive=20 #数据库最大连接数量
#最好初始数量=最大数量 一开始j
</code></pre>
<pre><code class="sql">DruidSample.java
package test;

import com.alibaba.druid.pool.DruidDataSourceFactory;
import common.DbUtils;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.net.URLDecoder;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.Properties;

public class DruidSample &#123;
    public static void main(String[] args) &#123;
        //1.加载属性文件
        Properties properties = new Properties();
        String propertyFile = DruidSample.class.getResource(&quot;/druid-config.properties&quot;).getPath();
        //空格-&gt;%20 会被转换
        try &#123;
            propertyFile = new URLDecoder().decode(propertyFile,&quot;UTF-8&quot;); //%20还原回去
            properties.load(new FileInputStream(propertyFile));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try &#123;
            //2.获取DataSource数据源对象
            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
            //3.创建数据库连接
            conn = dataSource.getConnection();
            pstmt = conn.prepareStatement(&quot;select * from employee limit 0,100&quot;);
            rs = pstmt.executeQuery();
            while (rs.next()) &#123;
                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(eno + &quot;-&quot; + ename + &quot;-&quot; + salary + &quot;-&quot; + dname);
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            DbUtils.closeConnection(rs,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="扩展知识：C3P0连接池"><a href="#扩展知识：C3P0连接池" class="headerlink" title="扩展知识：C3P0连接池"></a>扩展知识：C3P0连接池</h3><p>不用属性文件，改用<strong>c3p0-config.xml</strong>保存文件</p>
<blockquote>
<p>在里面&amp;无法转义 要写成  ‘ <u>&amp; amp;</u> ‘</p>
</blockquote>
<h6 id="idea-C3P0时出现java-sql-SQLException-No-suitable-driver的几种解决办法"><a href="#idea-C3P0时出现java-sql-SQLException-No-suitable-driver的几种解决办法" class="headerlink" title="idea C3P0时出现java.sql.SQLException: No suitable driver的几种解决办法"></a>idea C3P0时出现java.sql.SQLException: No suitable driver的几种解决办法</h6><blockquote>
<p>1、对lib包Add as library<br>2、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=c3p0&spm=1001.2101.3001.7020">c3p0</a>-config.xml<strong>必须放在source目录下</strong>，在此目录会被自动读取<br>3、c3p0命名必须是c3p0-config.xml（至少<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=xml%E6%A0%BC%E5%BC%8F&spm=1001.2101.3001.7020">xml格式</a>是这样）<br>4、c3p0-config.xml文件配置错误、书写错误</p>
</blockquote>
<pre><code class="sql">c3p0-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;c3p0-config&gt;
    &lt;default-config&gt;
        &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&lt;/property&gt;
        &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;
        &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt;
        &lt;!-- 连接池初始连接数量 --&gt;
        &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;
        &lt;!--最大连接数量--&gt;
        &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt;
    &lt;/default-config&gt;
&lt;/c3p0-config&gt;
</code></pre>
<pre><code class="sql">C3P0Sample.java
package test;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import common.DbUtils;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class C3P0Sample &#123;
    public static void main(String[] args) &#123;
        //1.加载配置文件
        //2.创建DataSource
        DataSource dataSource = new ComboPooledDataSource();
        //3.得到数据库连接
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try &#123;
            conn = dataSource.getConnection();
            pstmt = conn.prepareStatement(&quot;select * from employee limit 0,10&quot;);
            rs = pstmt.executeQuery();
            while(rs.next())&#123;
                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(eno + &quot;-&quot; + ename + &quot;-&quot; + salary + &quot;-&quot; + dname);
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            DbUtils.closeConnection(rs,pstmt,conn); //将数据库连接回收到连接池中而不是真正关闭
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Apache-Commos-DBUtils"><a href="#Apache-Commos-DBUtils" class="headerlink" title="Apache Commos DBUtils"></a>Apache Commos DBUtils</h3><ul>
<li>commons-dbutils是Apache提供的开源JDBC工具类库</li>
<li>它是对JDBC的简单封装，学习成本极低</li>
<li>使用commons-dbutils可以极大简化JDBC编码工作量</li>
</ul>
<pre><code class="sql">DbUtilsSample.java 【对数据的查询与更新】
package test;

import com.alibaba.druid.pool.DruidDataSourceFactory;
import common.DbUtils;
import common.entity.Employee;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanListHandler;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;
import java.util.Properties;

/**
 * Apache DBUtils + Druid 联合使用演示
 */
public class DbUtilsSample &#123;
    private static void query()&#123;
        Properties properties = new Properties();
        String propertyFile = DbUtilsSample.class.getResource(&quot;/druid-config.properties&quot;).getPath();
        try &#123;
            propertyFile = new URLDecoder().decode(propertyFile, &quot;UTF-8&quot;);
            properties.load(new FileInputStream(propertyFile));
            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
            //利用Apache DbUtils大幅简化了数据的提取过程
            QueryRunner qr = new QueryRunner(dataSource); //查询执行者  ↓连接自动关闭 不用手动写代码
            List&lt;Employee&gt; list = qr.query(&quot;select * from employee limit ?,10&quot;,
                    new BeanListHandler&lt;&gt;(Employee.class),
                    new Object[]&#123;10&#125;);//没有结果集只能new 结果自动转换成List实体类 后面的是问号赋值
            for (Employee emp : list)&#123;
                System.out.println(emp.getEname());
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    private static void update()&#123;
        Properties properties = new Properties();
        String propertyFile = DbUtilsSample.class.getResource(&quot;/druid-config.properties&quot;).getPath();
        Connection conn = null;
        try &#123;
            propertyFile = new URLDecoder().decode(propertyFile,&quot;UTF-8&quot;);
            properties.load(new FileInputStream(propertyFile)); //文件加载
            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//利用工厂类对properties信息进行载入创建对应的datasource对象
            conn = dataSource.getConnection();//获取数据库连接
            conn.setAutoCommit(false);
            String sql1 = &quot;update employee set salary=salary+1000 where eno=?&quot;;
            String sql2 = &quot;update employee set salary=salary-599 where eno=?&quot;;
            QueryRunner qr = new QueryRunner();
            qr.update(conn, sql1, new Object[]&#123;1000&#125;);//写入表操作都用update
            qr.update(conn, sql2, new Object[]&#123;1001&#125;);//分别完成加工资和减工资的操作
            conn.commit();//如果都执行成功 就提交 否则回滚
        &#125; catch (Exception e) &#123;
           e.printStackTrace();
            try &#123;
                if (conn!=null &amp;&amp; !conn.isClosed())&#123;
                    conn.rollback();
                &#125;
            &#125; catch (SQLException e1) &#123;
                e1.printStackTrace();
            &#125;
        &#125;finally &#123;
            try &#123;
                if (conn!=null &amp;&amp; !conn.isClosed())&#123;
                    conn.close(); //对数据库进行回收
                &#125;
            &#125; catch (SQLException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
//        query();
        update();
    &#125;

&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/10/23/后端/java数据库开发(JDBC)/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/10/17/语法/思诚科技项目实训/">
        <h2>
            思诚科技项目实训
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="html基础知识"><a href="#html基础知识" class="headerlink" title="html基础知识"></a>html基础知识</h2><h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><h6 id="拖拽法"><a href="#拖拽法" class="headerlink" title="拖拽法"></a>拖拽法</h6><h6 id="菜单打开"><a href="#菜单打开" class="headerlink" title="菜单打开"></a>菜单打开</h6><p>拓展插件：Chinese、Open in browser</p>
<h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><p>代码格式化</p>
<ul>
<li><p>Tab 往右缩进</p>
</li>
<li><p>Shift + Tab 向左回退</p>
</li>
<li><p>一个Tab等于两个空格</p>
</li>
<li><p>设置一个Tab等于2个空格</p>
</li>
<li><p>设置键盘快捷方式 大写与小写 ctrl+shift+u&#x2F;l</p>
</li>
<li><p>shift + alt + ↓ 快速复制上一行</p>
</li>
<li><p>ctrl + f 搜索</p>
</li>
<li><p>ctrl + h 替换</p>
</li>
<li><p>ctrl + z 撤销</p>
</li>
<li><p>多光标修改 选中修改的 ctrl+d 加上上下移动</p>
</li>
</ul>
<h3 id="快速写代码-按-ctrl-i-自动导入快捷代码"><a href="#快速写代码-按-ctrl-i-自动导入快捷代码" class="headerlink" title="快速写代码 [按 ctrl+i 自动导入快捷代码]"></a>快速写代码 [<u>按 ctrl+i 自动导入快捷代码</u>]</h3><ul>
<li><p>div + Tab 快速输入div块</p>
</li>
<li><p>div.red + Tab    <u>&lt; div class&#x3D;”red”&gt; &lt; &#x2F;div&gt;</u></p>
</li>
<li><p>div#box.red + Tab    <u>&lt; div id&#x3D;”box” class&#x3D;”red”&gt; &lt; &#x2F;div&gt;</u></p>
</li>
<li><p>div[name&#x3D;box] [title&#x3D;气泡]   + Tab   <u>&lt; div name&#x3D;”box” title&#x3D;”气泡”&gt; &lt; &#x2F;div&gt;</u></p>
</li>
<li><p>a#link.red[href&#x3D;#] [ title&#x3D;我是连接] + Tab   <u>&lt; a href&#x3D;”#” id&#x3D;”link” class&#x3D;”red” title&#x3D;”我是连接”&gt;&lt; &#x2F;a&gt;</u></p>
</li>
<li><p>div{文本} + Tab   <u>&lt; div&gt;aaaa&lt; &#x2F;div&gt;</u></p>
</li>
<li><p>输入ul&gt;li{项目} + Tab </p>
<pre><code class="html">&lt;ul&gt;
  &lt;li&gt;牛逼&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</li>
<li><p>ul#box&gt;li.red[title&#x3D;’”标题”]{项目1}</p>
<pre><code class="html">&lt;ul id=&quot;box&quot;&gt;
  &lt;li class=&quot;red&quot; title=&quot;标题&quot;&gt;项目1&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</li>
<li><p>ui&gt;li*5  一个ul标签和五个li标签   <strong>大于号是子类</strong>[父子关系]</p>
</li>
<li><p>p*3{段落$}  </p>
<pre><code class="html">&lt;p&gt;段落1&lt;/p&gt;
&lt;p&gt;段落2&lt;/p&gt;
&lt;p&gt;段落3&lt;/p&gt;
</code></pre>
</li>
<li><p>ul#nav&gt;li.item*5{项目列表$} + Tab</p>
<pre><code class="html">&lt;ul id=&quot;nav&quot;&gt;
    &lt;li class=&quot;item&quot; 列表1=&quot;&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item&quot; 列表2=&quot;&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item&quot; 列表3=&quot;&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item&quot; 列表4=&quot;&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item&quot; 列表5=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</li>
<li><p>div[name&#x3D;”box”]&gt;p.red&gt;span*3{文本$} + Tab</p>
<pre><code class="html">&lt;div name=&quot;box&quot;&gt;
    &lt;p class=&quot;red&quot;&gt;
        &lt;span&gt;文本1&lt;/span&gt;
        &lt;span&gt;文本2&lt;/span&gt;
        &lt;span&gt;文本3&lt;/span&gt;
    &lt;/p&gt;
&lt;/div&gt;
&lt;!--#是id    .是class    [name=&quot;box&quot;]--&gt;
</code></pre>
</li>
<li><p>h${标题$}*6</p>
<pre><code class="html">&lt;h1&gt;标题1&lt;/h1&gt;
&lt;h2&gt;标题2&lt;/h2&gt;
&lt;h3&gt;标题3&lt;/h3&gt;
&lt;h4&gt;标题4&lt;/h4&gt;
&lt;h5&gt;标题5&lt;/h5&gt;
&lt;h6&gt;标题6&lt;/h6&gt;
</code></pre>
</li>
<li><p>h${标题$}*6  <u><strong>按ctrl+i</strong> 自动导入快捷代码</u></p>
</li>
<li><p>(h2{标题}+p{段落})*3  [<u>同类关系</u>]</p>
<pre><code class="html">&lt;h2&gt;标题&lt;/h2&gt;
&lt;p&gt;段落&lt;/p&gt;
&lt;h2&gt;标题&lt;/h2&gt;
&lt;p&gt;段落&lt;/p&gt;
&lt;h2&gt;标题&lt;/h2&gt;
&lt;p&gt;段落&lt;/p&gt;
</code></pre>
</li>
<li><pre><code class="html">div#faq&gt;h2&#123;常见问题&#125;dl.list&gt;(dt&#123;问题$&#125;+dd&#123;答案$&#125;)*4
div#faq&gt;(h2&#123;常见问题&#125;+dl.list&gt;(dt&#123;问题$&#125;+dd&#123;答案$&#125;)*4)

&lt;div id=&quot;faq&quot;&gt;
    &lt;h2&gt;常见问题&lt;/h2&gt;
    &lt;dl class=&quot;list&quot;&gt;
        &lt;dt&gt;问题1&lt;/dt&gt;
        &lt;dd&gt;答案1&lt;/dd&gt;
        &lt;dt&gt;问题2&lt;/dt&gt;
        &lt;dd&gt;答案2&lt;/dd&gt;
        &lt;dt&gt;问题3&lt;/dt&gt;
        &lt;dd&gt;答案3&lt;/dd&gt;
        &lt;dt&gt;问题4&lt;/dt&gt;
        &lt;dd&gt;答案4&lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><p>输入 ul&gt;li{列表$$}*10 + Tab 确保位数</p>
<pre><code class="html">&lt;ul&gt;
    &lt;li&gt;列表01&lt;/li&gt;
    &lt;li&gt;列表02&lt;/li&gt;
    &lt;li&gt;列表03&lt;/li&gt;
    &lt;li&gt;列表04&lt;/li&gt;
    &lt;li&gt;列表05&lt;/li&gt;
    &lt;li&gt;列表06&lt;/li&gt;
    &lt;li&gt;列表07&lt;/li&gt;
    &lt;li&gt;列表08&lt;/li&gt;
    &lt;li&gt;列表09&lt;/li&gt;
    &lt;li&gt;列表10&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</li>
</ul>
<h3 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a>MarkDown语法</h3><p>在VsCode预览<code>ctrl + shift + v</code> </p>
<p>中划线：  ’ <strong>~~ 1111 ~~</strong> ‘<br>分割线：’<strong>— + 回车</strong>‘<br>超链接：’<strong>[网易] (<a target="_blank" rel="noopener" href="http://www.163.com/">http://www.163.com</a>)</strong>‘<br>图片:  ‘<strong>! [图片名称] (图片URL)</strong>‘</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2023/10/17/语法/思诚科技项目实训/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/10/08/后端/数据库/">
        <h2>
            数据库
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/8
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="数据库基础内容"><a href="#数据库基础内容" class="headerlink" title="数据库基础内容"></a>数据库基础内容</h1><h3 id="数据库系统-DBMS"><a href="#数据库系统-DBMS" class="headerlink" title="数据库系统(DBMS)"></a>数据库系统(DBMS)</h3><ul>
<li>关系型数据库系统(RDBMS)是指使用了关系模型的数据库</li>
<li>关系模型中，数据是分类存放的，数据之间可以有联系</li>
<li>淘宝网背后是3000多个数据库并发的<strong>集群</strong></li>
<li>DB2电信金融领域   Oracle数据库集群  <strong><span style = "color:red">MySQL开源灵活</span></strong>  SQL Server教育领域免费</li>
<li><strong>NoSQL数据库</strong>[Redis]指的是数据分类存放，但是数据之间没有关联关系的数据库系统<br>主流NoSQL数据库 &#x3D;&gt; <strong>Redis(内存 双十一秒杀)</strong>   MemCache   <strong>MongoDB(新闻)</strong>   Neo4J<br>NoSQL数据库只是关系型数据库的补充</li>
</ul>
<h3 id="MySQL衍生版"><a href="#MySQL衍生版" class="headerlink" title="MySQL衍生版"></a>MySQL衍生版</h3><p><strong>Oracle</strong>  Percona(Linux系统)  MariaDB</p>
<h3 id="重设root密码-D-x2F-temp-txt"><a href="#重设root密码-D-x2F-temp-txt" class="headerlink" title="重设root密码 (D:&#x2F;temp.txt)"></a>重设root密码 (D:&#x2F;temp.txt)</h3><ul>
<li><p>创建一个Txt文件，定义修改密码的SQL语句</p>
<pre><code class="sql">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; 
</code></pre>
</li>
<li><p>Windows PowerSheell(管理员) 窗口打开<br>停止服务</p>
<pre><code class="sql">net stop mysql180

mysqld --defaults-file=&quot;D:\MySQL\MySQL Server 8.0\my.ini&quot; --init-file==&quot;D:/temp.txt&quot; --console
ctrl+C取消
</code></pre>
<p>启动服务</p>
<pre><code class="sql">net start mysql180
</code></pre>
</li>
</ul>
<h3 id="MySQL配置文件"><a href="#MySQL配置文件" class="headerlink" title="MySQL配置文件"></a>MySQL配置文件</h3><ul>
<li><p>在<strong>my.ini</strong>文件中，我们可以设置各种MySQL的配置，例如字符集、端口号、目录地址等等</p>
<p>my.init{客户端配置信息：[client]…    [mysql]…      <strong>数据库配置信息</strong>：[mysqld]…}</p>
</li>
</ul>
<pre><code class="sql">[client]

# pipe=

# socket=MYSQL 端口号

port=3306

# 错误时主板没有轰鸣声
[mysql]
no-beep

# server_type=3
[mysqld]
#端口号
port=3306


# basedir=&quot;D:/MySQL/MySQL Server 8.0/&quot;
# Path to the database root
datadir=D:/MySQL/MySQL Server 8.0\Data

# with an account. 密码认证插件
authentication_policy=mysql_native_password

#默认存储引擎
default-storage-engine=INNODB

# database servers. 开启严格模式
sql-mode=&quot;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&quot;

# General and Slow logging. 用文件记录日志
log-output=FILE
# 关闭日志输出
general-log=0
# 日志文件名称
general_log_file=&quot;PLUMINARY.log&quot;
# 开启慢查询日志
slow-query-log=1
#慢查询日志文件名称
slow_query_log_file=&quot;PLUMINARY-slow.log&quot;
#大于多少秒的执行SQL被记录在慢查询日志
long_query_time=10

# Error Logging.错误日志名称
log-error=&quot;PLUMINARY.err&quot;

# from every other ID in use by any other source or replica. 集群会用到数据库ID
server-id=1

# 把表名转换成小写
lower_case_table_names=1

# 导入导出数据的目录地址
secure-file-priv=&quot;D:/MySQL/MySQL Server 8.0/Uploads&quot;

#最大连接数
max_connections=151
</code></pre>
<h3 id="定义逻辑库、数据表"><a href="#定义逻辑库、数据表" class="headerlink" title="定义逻辑库、数据表"></a>定义逻辑库、数据表</h3><ul>
<li>SQL是用于访问和处理数据的标准的计算机语言</li>
</ul>
<h5 id="SQL语句的注释"><a href="#SQL语句的注释" class="headerlink" title="SQL语句的注释"></a>SQL语句的注释</h5><pre><code class="sql"># 这是一段注释文字
/* 这是另一段注释文字 */
</code></pre>
<h3 id="创建逻辑库"><a href="#创建逻辑库" class="headerlink" title="创建逻辑库"></a>创建逻辑库</h3><pre><code class="sql">CREATE DATABASE 逻辑库名称; #创建
SHOW DATABASES; #展现逻辑库
DROP DATABASE 逻辑库名称; #删除
</code></pre>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><pre><code class="sql">CREATE TABLE 数据表(
  列名1 数据类型[约束] [COMMENT 注释],
  列名2 数据类型[约束] [COMMENT 注释],
  ......
)[COMMENT = 注释];


CREATA TABLE student(
  id INT UNSIGNED PRIMARY KEY, #主键约束 不可重复
  name VARCHAR(20) NOT NULL, #varchar 字符串 最大不超过20个字符 NOT NULL必填,不允许没有数据
  sex CHAR(1) NOT NULL, #char 字符
  birthday DATE NOT NULL, 
  tel CHAR(11) NOT NULL,
  remark VARCHAR(200)  #备注不超过200字符串
);

INSERT INTO student VALUES(1,&quot;李强&quot;,&quot;男&quot;,&quot;1995-05-15&quot;,&quot;13312345678&quot;,NULL);

SHOW tables; #展现数据表名称
DESC student; #数据表结构具体情况
SHOW CREATE TABLE student; #查询当时的sql语句
DROP TABLE student; #删除数据表
</code></pre>
<h3 id="数据定义语言：数据类型"><a href="#数据定义语言：数据类型" class="headerlink" title="数据定义语言：数据类型"></a>数据定义语言：数据类型</h3><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TINYINT</td>
<td align="center">1字节</td>
<td align="center">小整数</td>
</tr>
<tr>
<td align="center">SMALLINT</td>
<td align="center">2字节</td>
<td align="center">普通整数</td>
</tr>
<tr>
<td align="center">MEDIUMIINT</td>
<td align="center">3字节</td>
<td align="center">普通整数</td>
</tr>
<tr>
<td align="center"><strong>INT</strong></td>
<td align="center"><strong>4字节</strong></td>
<td align="center"><strong>较大整数</strong></td>
</tr>
<tr>
<td align="center">BIGINT</td>
<td align="center">8字节</td>
<td align="center">大整数</td>
</tr>
<tr>
<td align="center"><strong>FLOAT</strong></td>
<td align="center"><strong>4字节</strong></td>
<td align="center"><strong>单精度浮点数</strong></td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="center">8字节</td>
<td align="center">双精度浮点数</td>
</tr>
<tr>
<td align="center">DECIMAL[精确钱]</td>
<td align="center">——–</td>
<td align="center">DECIMAL(10,2)</td>
</tr>
</tbody></table>
<ul>
<li>十进制的浮点数无法在计算机中用二进制精确表达 比如0.2</li>
</ul>
<pre><code class="sql">   num FLOAT(20,10) #位数20 小数点后精确10位  在num中输入0.2的时候 变成了0.200000000030
=&gt; num DECIMAL(20,10)
</code></pre>
<h3 id="数据类型：字符串"><a href="#数据类型：字符串" class="headerlink" title="数据类型：字符串"></a>数据类型：字符串</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>CHAR</strong></td>
<td align="center">1-255字符</td>
<td align="center">固定长度字符串</td>
</tr>
<tr>
<td align="center"><strong>VARCHAR</strong></td>
<td align="center">1-65535字符</td>
<td align="center">不固定长度字符串</td>
</tr>
<tr>
<td align="center">TEXT</td>
<td align="center">1-65535字符</td>
<td align="center"><strong>不确定</strong>长度字符串[后不加括号]</td>
</tr>
<tr>
<td align="center">MEDIUMETEXT</td>
<td align="center">1-1千6百万字符</td>
<td align="center"><strong>不确定</strong>长度字符串[后不加括号]</td>
</tr>
<tr>
<td align="center">LONGTEXT</td>
<td align="center">1-42亿字符</td>
<td align="center"><strong>不确定</strong>长度字符串[后不加括号]</td>
</tr>
</tbody></table>
<h4 id="数据类型：日期类型-年月日中间横线分割-要加引号"><a href="#数据类型：日期类型-年月日中间横线分割-要加引号" class="headerlink" title="数据类型：日期类型(年月日中间横线分割 要加引号)"></a>数据类型：日期类型(年月日中间横线分割 要加引号)</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE</td>
<td align="center">3字节</td>
<td align="center">日期</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">3字节</td>
<td align="center">时间</td>
</tr>
<tr>
<td align="center">YEAR</td>
<td align="center">1字节</td>
<td align="center">年份</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">8字节</td>
<td align="center">日期时间[电影开始时间]</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="center">4字节</td>
<td align="center">时间戳</td>
</tr>
</tbody></table>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><pre><code class="sql">ALTER TABLE 表名称
ADD 列1 数据类型 [约束] [COMMENT 注释],
ADD 列2 数据类型 [约束] [COMMENT 注释],
......;

ADD address VARCHAR(200) NOT NULL;
</code></pre>
<h5 id="修改字段名称"><a href="#修改字段名称" class="headerlink" title="修改字段名称"></a>修改字段名称</h5><pre><code class="sql">ALTER TABLE 表名称
CHANGE 列1 新列名1 数据类型 [约束] [COMMENT 注释],
CHANGE 列2 新列名2 数据类型 [约束] [COMMENT 注释],
......;

修改字段
ALTER TABLE student
MODIFY home_tel VARCHAR(20) NOT NULL;
CHANGE address home_address VARCHAR(200) NOT NULL; #改变字段名
</code></pre>
<h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><pre><code class="sql">ALTER TABLE 表名称
DROP 列1，
DROP 列2，
......;
</code></pre>
<h3 id="数据库的范式"><a href="#数据库的范式" class="headerlink" title="数据库的范式"></a>数据库的范式</h3><h4 id="第一范式：原子性"><a href="#第一范式：原子性" class="headerlink" title="第一范式：原子性"></a>第一范式：原子性</h4><ul>
<li>第一范式是数据库的基本要求，不满足组这一点就不是关系数据库</li>
<li>数据库的每一列都是<strong>不可分割</strong>的基本数据项，同一列中不能有多个值，也不能存在重复的属性</li>
</ul>
<h6 id="不符合第一范式"><a href="#不符合第一范式" class="headerlink" title="不符合第一范式"></a>不符合第一范式</h6><table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
<th align="center">班级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">刘娜</td>
<td align="center">高三年级1班</td>
</tr>
</tbody></table>
<h6 id="符合第一范式"><a href="#符合第一范式" class="headerlink" title="符合第一范式"></a>符合第一范式</h6><table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
<th align="center">年纪</th>
<th align="center">班级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">刘娜</td>
<td align="center">高三</td>
<td align="center">1班</td>
</tr>
</tbody></table>
<h4 id="第二范式：唯一性"><a href="#第二范式：唯一性" class="headerlink" title="第二范式：唯一性"></a>第二范式：唯一性</h4><ul>
<li>数据表中的<strong>每条记录必须是唯一的</strong>。为了实现区分，通常要为表加上一列用来存储唯一标识，这个唯一属性列被称为主键列</li>
</ul>
<h6 id="无法区分重复的数据"><a href="#无法区分重复的数据" class="headerlink" title="无法区分重复的数据"></a>无法区分重复的数据</h6><table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">考试成绩</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
<tr>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
</tbody></table>
<h6 id="数据具有唯一性"><a href="#数据具有唯一性" class="headerlink" title="数据具有唯一性"></a>数据具有唯一性</h6><table>
<thead>
<tr>
<th align="center">流水号</th>
<th align="center">学号</th>
<th align="center">考试成绩</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">201807152687</td>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
<tr>
<td align="center">201807152694</td>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
</tbody></table>
<h4 id="第三范式：关联性"><a href="#第三范式：关联性" class="headerlink" title="第三范式：关联性"></a>第三范式：关联性</h4><ul>
<li>每列都与主键有直接关系，<strong>不存在传递依赖</strong></li>
</ul>
<h6 id="违反第三范式"><a href="#违反第三范式" class="headerlink" title="违反第三范式"></a>违反第三范式</h6><table>
<thead>
<tr>
<th align="center">爸爸</th>
<th align="center">儿子</th>
<th align="center">女儿</th>
<th align="center">女儿的玩具</th>
<th align="center">女儿的衣服</th>
</tr>
</thead>
<tbody><tr>
<td align="center">陈华</td>
<td align="center">陈浩</td>
<td align="center">陈婷婷</td>
<td align="center">海绵宝宝</td>
<td align="center">校服</td>
</tr>
</tbody></table>
<p>拿爸爸作为主键 儿子和女儿字段都是依赖于爸爸字段 但是后面的字段<strong>违反了第三范式</strong> <u>女儿的玩具和女儿的衣服是依赖于女儿这个字段的并不依赖于爸爸这个字段</u><br>数据表关系都非常松散 在检索的时候非常慢 因为爸爸主键字段查询非常快 但是查女儿的玩具和女儿的衣服找不到一样的主键</p>
<h6 id="遵守第三范式"><a href="#遵守第三范式" class="headerlink" title="遵守第三范式"></a>遵守第三范式</h6><table>
<thead>
<tr>
<th align="center">爸爸</th>
<th align="center">儿子</th>
<th align="center">女儿</th>
</tr>
</thead>
<tbody><tr>
<td align="center">陈华</td>
<td align="center">陈浩</td>
<td align="center">陈婷婷</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">女儿</th>
<th align="center">女儿的玩具</th>
<th align="center">女儿的衣服</th>
</tr>
</thead>
<tbody><tr>
<td align="center">陈婷婷</td>
<td align="center">海绵宝宝</td>
<td align="center">校服</td>
</tr>
</tbody></table>
<ul>
<li>依照第三范式，数据可以拆分保存到不同的数据表，彼此保持关联</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">部门</th>
<th align="center">电话</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">财务部</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">技术部</td>
<td align="center">1002</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">销售部</td>
<td align="center">1003</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">姓名</th>
<th align="center">性别</th>
<th align="center">部门</th>
<th align="center">入职日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">陈浩</td>
<td align="center">男</td>
<td align="center"><strong>10</strong></td>
<td align="center">2018-05-10</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">李婷婷</td>
<td align="center">女</td>
<td align="center"><strong>30</strong></td>
<td align="center">2018-03-22</td>
</tr>
</tbody></table>
<p>部门字段也是依赖于编号的 两张表没有违反第三范式</p>
<h3 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h3><ul>
<li>MySQL中的字段约束共有四种：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">约束名称</th>
<th align="center">关键字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主键约束</td>
<td align="center">PRIMARY KEY</td>
<td align="center">字段值唯一，且不能为NULL</td>
</tr>
<tr>
<td align="center">非空约束</td>
<td align="center">NOT NULL</td>
<td align="center">字段值不能为NULL</td>
</tr>
<tr>
<td align="center">唯一约束</td>
<td align="center">UNIQUE</td>
<td align="center">字段值唯一，且可以为NULL</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">FOREIGN KEY</td>
<td align="center">保持关联数据的逻辑性</td>
</tr>
</tbody></table>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><ul>
<li>主键约束要求字段的值在全表必须唯一，而且不能为NULL值</li>
<li>建议主键一定要使用数字类型，因为数字的检索速度会非常快</li>
<li>如果主键是数字类型，还可也设置自动增长</li>
</ul>
<pre><code class="sql">CREATE TABLE t_teacher(
    id INT PRIMARY KEY AUTO_INCREMENT, #自带索引功能 自带排序
    ......
);
</code></pre>
<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><ul>
<li>非空约束要求字段的值不能为NULL值</li>
<li>NULL值以为没有值，而不是 “” 空字符串</li>
</ul>
<pre><code class="sql">CREATE TABLE t_teacher(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    married BOOLEAN NOT NULL DEFAULT FALSE #若不写则是默认值false
);
</code></pre>
<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><ul>
<li>唯一约束要求字段值如果不为NULL，那么在全表必须唯一</li>
</ul>
<pre><code class="sql">CREATE TABLE t_tracher(
    ......
    tel CHAR(11) NOT NULL UNIQUE
);
</code></pre>
<pre><code class="sql">t_  tb_  一般是真实的表  
v_ vw_   一般是视图虚拟表的意思
</code></pre>
<h6 id="总结代码"><a href="#总结代码" class="headerlink" title="总结代码"></a>总结代码</h6><pre><code class="sql">CREATE TABLE t_teacher(
    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    tel CHAR(11) NOT NULL UNIQUE, #唯一约束 UNIQUE 字段值唯一，且可以为NULL
    married BOOLEAN NOT NULL DEFAULT FALSE
);
-------------------------------------------------------------------------
CREATE TABLE student(
    id INT UNSIGNED PRIMARY KEY,
    name VARCHAR(20) NOT NULL,
    sex CHAR(1) NOT NULL,
    birthday DATE NOT NULL,
    tel CHAR(11) NOT NULL,
    remark VARCHAR(200)
);
INSERT INTO student VALUES (1,&quot;李强&quot;,&quot;男&quot;,&quot;1995-05-15&quot;,&quot;13312345678&quot;,NULL);
DESC student; 
SHOW CREATE TABLE student;

ALTER TABLE student
ADD address VARCHAR(200) NOT NULL, #添加字段信息
ADD home_tel CHAR(11) NOT NULL;

ALTER TABLE student
MODIFY home_tel VARCHAR(20) NOT NULL; #改字段类型信息

ALTER TABLE student
CHANGE address home_address VARCHAR(200) NOT NULL; #改变字段名

ALTER TABLE student
DROP address; #删除字段
</code></pre>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul>
<li>外键约束用来保证关联数据的逻辑关系</li>
<li>外键约束的定义是写在子表上的</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">部门</th>
<th align="center">电话</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">财务部</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">技术部</td>
<td align="center">1002</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">销售部</td>
<td align="center">1003</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">姓名</th>
<th align="center">性别</th>
<th align="center">部门</th>
<th align="center">入职日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">陈浩</td>
<td align="center">男</td>
<td align="center"><strong>10</strong></td>
<td align="center">2018-05-10</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">李婷婷</td>
<td align="center">女</td>
<td align="center"><strong>30</strong></td>
<td align="center">2018-03-22</td>
</tr>
</tbody></table>
<pre><code class="sql">CREATE TABLE t_dept(
    deptno INT UNSIGNED PRIMARY KEY,
    dname VARCHAR(20) NOT NULL UNIQUE,
    tel CHAR(4) UNIQUE #写了电话必须唯一
);
</code></pre>
<pre><code class="sql">CREATE TABLE t_emp(
    empno INT UNSIGNED PRIMARY KEY,
    ename VARCHAR(20) NOT NULL,
    sex EUNM(&quot;男&quot;,&quot;女&quot;) NOT NULL, #枚举 选择其中一个
    deptno INT UNSIGNED,
    hiredate DATE NOT NULL,
    FOREIGN KEY (deptno) REFERENCES t_dept(deptno) #和父表进行外键约束关联
);
</code></pre>
<p>不允许删除第一个编号 需要先删除第二个表的记录 再删除第一个表记录 逻辑关系有保证</p>
<h3 id="外键约束的闭环问题-【因此开发中放弃外键约束】"><a href="#外键约束的闭环问题-【因此开发中放弃外键约束】" class="headerlink" title="外键约束的闭环问题 【因此开发中放弃外键约束】"></a>外键约束的闭环问题 【因此开发中放弃外键约束】</h3><ul>
<li>如果形成外键闭环，我们将无法删除任何一张表的记录</li>
</ul>
<h3 id="数据排序的好处"><a href="#数据排序的好处" class="headerlink" title="数据排序的好处"></a>数据排序的好处</h3><ul>
<li>一旦数据排序后，查找的速度就会翻倍，现实世界跟程序世界都是如此</li>
</ul>
<h3 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h3><pre><code class="sql">CREATE TABLE 表名称(
    ......,
    INDEX [索引名称] (字段),
    ......
);

#数据库对这个索引字段排序生成二叉树 每个字段都是有索引名称的
CREATE TABLE t_message(
    id INT UNSIGNED PRIMARY KEY,
    content VARCHAR(200) NOT NULL,
    type ENUM(&quot;公告&quot;,&quot;通报&quot;,&quot;个人通知&quot;) NOT NULL,
    create_time TIMESTAMP NOT NULL,
    INDEX idx_type (type)
); #利用二叉树的二分查找去查找索引字段就会非常快
</code></pre>
<h3 id="如何添加与删除索引"><a href="#如何添加与删除索引" class="headerlink" title="如何添加与删除索引"></a>如何添加与删除索引</h3><pre><code class="sql">CREATE INDEX 索引名称 ON 表名(字段); #添加索引
ALTER TABLE 表名称 ADD INDEX [索引名](字段); #添加索引
SHOW INDEX FORM 表名; #展示索引表  PRIMARY KEY AUTO_INCREMENT, #自带索引功能 自带排序
DROP INDEX 索引名称 ON 表名; #删除索引
</code></pre>
<h3 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h3><ul>
<li>数据量很大，而且经常被查询的数据表可以设置索引 (日志表很少查询 无需设置 因为数据库要维护二叉树)</li>
<li>索引只添加在<strong>经常被用作检索</strong>条件的字段上面</li>
<li>不要在<strong>大字段</strong>上创建索引</li>
</ul>
<p>(<u>以上均为DDL语句</u>)</p>
<h6 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h6><h3 id="数据操作语句：普通查询"><a href="#数据操作语句：普通查询" class="headerlink" title="数据操作语句：普通查询"></a>数据操作语句：普通查询</h3><h5 id="记录查询"><a href="#记录查询" class="headerlink" title="记录查询"></a>记录查询</h5><ul>
<li>最基本的查询语句是由<strong>SELECT</strong> 和 <strong>FROM</strong>关键字组成</li>
</ul>
<pre><code class="sql">USE demo;
SELECT * FROM t_emp; #FROM是从员工表查数据 *是在结果集里显示员工表所有字段
SELECT empno,ename,sal FROM t_emp; #不查询所有 单独查询想要的
</code></pre>
<ul>
<li>SELECT语句屏蔽了物理层的操作，用户不必关心数据的真实存储，交给数据库高效查找数据</li>
<li>通常情况下 ，SELECT子句中使用了表达式，那么这列的名字就默认为表达式，因此需要一种对列明重命名的机制 [<strong>起别名</strong>：只是对查询的结果集字段改名称]</li>
</ul>
<pre><code class="sql">SELECT
  empno,
  sal*12 AS &quot;income&quot;
FROM t_emp;
</code></pre>
<ul>
<li>上述sql 查询语句的子句执行顺序</li>
</ul>
<p>① <strong>词法分析与优化</strong>：读取SQL语句<br>② <strong>FROM</strong>：选择数据来源<br>③ <strong>SELECT</strong>：选择输出内容</p>
<h3 id="数据操作语言：数据分页"><a href="#数据操作语言：数据分页" class="headerlink" title="数据操作语言：数据分页"></a>数据操作语言：数据分页</h3><ul>
<li>朋友圈只会加载少量部分信息，不用一次性加载全部朋友圈，那样只会浪费CPU时间、内存和网络带宽</li>
<li>如果结果集的记录很多，则可以使用LIMIT关键字限定结果集数量</li>
</ul>
<pre><code class="sql">SELECT ... FROM ... LIMIT 起始位置,偏移量; 
SELECT empno,ename FROM t_emp LIMIT 0,20; #从0往后取20条数据
</code></pre>
<h6 id="数据分页简写"><a href="#数据分页简写" class="headerlink" title="数据分页简写"></a>数据分页简写</h6><ul>
<li>如果LIMIT子句只有一个参数，它表示的是偏移量，起始值默认为0</li>
</ul>
<pre><code class="sql">SELECT empno,ename FROM t_emp LIMIT 10;
SELECT empno,ename FROM t_emp LIMIT 0,10;
FROM → SELECT → LIMIT
</code></pre>
<h3 id="结果集排序"><a href="#结果集排序" class="headerlink" title="结果集排序"></a>结果集排序</h3><ul>
<li>如果没有设置，查询语句不会对结果集进行排序。也就是说，如果想让结果集按照某种顺序排序，就必须使用ORDER BY子句 【<strong>默认升序</strong>】</li>
</ul>
<pre><code class="sql">SELECT ... FROM ... ORDER BY 列名 [ASC|DESC];
SELECT ename,sal FROM t_emp ORDER BY sal;
</code></pre>
<h3 id="排序关键字"><a href="#排序关键字" class="headerlink" title="排序关键字"></a>排序关键字</h3><ul>
<li>ASC代表升序(默认)，DESC代表降序</li>
<li>如果排序列是数字类型，数据库就按照数字大小排序，如果是日期类型就按照日期大小排序，如果是字符串就暗战字符集序号排序。</li>
</ul>
<pre><code class="sql">SELECT ename,sal FROM t_emp ORDER BY hiredate DESC;
</code></pre>
<h6 id="排序字段内容相同的情况"><a href="#排序字段内容相同的情况" class="headerlink" title="排序字段内容相同的情况"></a>排序字段内容相同的情况</h6><ul>
<li>如果两条数据排序字段内容相同 <strong>sal 都是3000</strong><br>默认情况下是按照主键升序</li>
</ul>
<h6 id="多个排序字段"><a href="#多个排序字段" class="headerlink" title="多个排序字段"></a>多个排序字段</h6><ul>
<li>使用ORDER BY规定首要排序顺序条件和次要排序条件。数据库会先按照要排序条件排序，如果遇到首要排序内容相同的记录，那么就会启动次要排序条件接着排序</li>
</ul>
<pre><code class="sql">SELECT ename,sal,hiredate 
FROM t_emp 
ORDER BY hiredate DESC,sal ASC;
#先按照首要排序hiredate降序 再启动次要排序sal降序

SELECT ename,sal,hiredate
FROM t_emp
ORDER BY sal DESC 
LIMIT 0,5  #工资排在前五位进行降序
</code></pre>
<h6 id="排序-分页"><a href="#排序-分页" class="headerlink" title="排序+分页"></a>排序+分页</h6><ul>
<li>ODER BY 子句书写的时候放在LIMIT子句的前面<br><strong>FROM → SELECT → ORDER BY → LIMIT</strong></li>
</ul>
<h3 id="结果集中的重复数据"><a href="#结果集中的重复数据" class="headerlink" title="结果集中的重复数据"></a>结果集中的重复数据</h3><ul>
<li><p>假如我们要查询员工表有多种职业，写出来的sql语句</p>
<pre><code class="sql">SELECT job FROM t_emp; #结果集内可能会出现重复记录
</code></pre>
</li>
<li><p>如果去除重复的数据，可以使用 <strong>DISTINCT</strong> 关键字来实现</p>
<pre><code class="sql">SELECT DISTINCT 字段 FROM ...;
SELECT DISTINCT job FROM t_emp;
</code></pre>
</li>
</ul>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul>
<li><p>使用<strong>DISTINCT</strong>的<strong>SELECT</strong>子句中只能查询一列数据，如果查询多列，去除重复记录就会失效</p>
<pre><code class="sql">SELECT DISTINCT job,ename FROM t_emp; #有job相同但是ename不相同 不能查询
</code></pre>
</li>
<li><p><strong>DISTINCT</strong>关键字只能再SELECT子句中使用一次 [必须放在第一个字段前面]</p>
</li>
</ul>
<h3 id="数据操作语言：条件查询-一"><a href="#数据操作语言：条件查询-一" class="headerlink" title="数据操作语言：条件查询(一)"></a>数据操作语言：条件查询(一)</h3><ul>
<li><p>满足某一种或几种条件的记录。这类条件要用<strong>WHERE</strong>子句来实现数据的筛选</p>
<pre><code class="sql">SELECT ... FROM ... WHERE 条件 [AND|OR] 条件 ...;

SELECT empno,ename,sal FROM t_emp
WHERE deptno=10 AND sal&gt;=2000;

SELECT empno,ename,sal
FROM t_emp
WHERE(deptno=10 OR deptno=20) AND sal&gt;=2000;
</code></pre>
</li>
</ul>
<h6 id="四类运算符"><a href="#四类运算符" class="headerlink" title="四类运算符"></a>四类运算符</h6><ul>
<li><p>WHERE语句中的条件运算会用到以下四种运算符</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">数学运算符</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">比较运算符</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">逻辑运算符</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">按位运算符</td>
</tr>
</tbody></table>
</li>
</ul>
<h6 id="算数运算符-加-减-乘-x2F-除-模"><a href="#算数运算符-加-减-乘-x2F-除-模" class="headerlink" title="算数运算符 [+加  -减  *乘  &#x2F;除  %模]"></a>算数运算符 [+加  -减  *乘  &#x2F;除  %模]</h6><p>NULL值与任何数字加减乘除都是NULL值 如果想要运算 必须加入 <strong>IFNULL</strong>(null,0); 意思是遇到NULL值就用0来计算 10+IFNULL(null,0) &#x3D; 10<br><strong>DATEDIFF</strong>(入职日期-现在的日期)&#x2F;365</p>
<pre><code class="sql">从t_emp表中找出 号位是10 和 总工资≥15000 的并且 计算工龄超过20年的人
SELECT empno,ename,sal,hiredate
FROM t_emp
WHERE deptno=10 AND (sal+IFNULL(NULL,0))*12&gt;=15000
AND DATEDIFF(NOW(),hiredate)/365&gt;=20;
</code></pre>
<h6 id="比较运算符-gt-大于-gt-x3D-大于等于-lt-小于-lt-x3D-小于等于-x3D-等于-x3D-不等于-IN包含deptno-IN-10-30-40"><a href="#比较运算符-gt-大于-gt-x3D-大于等于-lt-小于-lt-x3D-小于等于-x3D-等于-x3D-不等于-IN包含deptno-IN-10-30-40" class="headerlink" title="比较运算符 [&gt;大于 &gt;&#x3D;大于等于 &lt;小于 &lt;&#x3D;小于等于 &#x3D;等于 !&#x3D;不等于 IN包含deptno IN(10,30,40)]"></a>比较运算符 [&gt;大于 &gt;&#x3D;大于等于 &lt;小于 &lt;&#x3D;小于等于 &#x3D;等于 !&#x3D;不等于 IN包含deptno IN(10,30,40)]</h6><pre><code class="sql">查询10 20 30部门里面在1980年以前入职的员工而且不能是SALESMAN职位
SELECT
  empno,ename,sal,deptno,hiredate
FROM t_emp;
WHERE deptno IN(10,20,30) AND job!=&quot;SALESMAN&quot;
AND hiredate&lt;&quot;1985-01-01&quot;;
</code></pre>
<h6 id="续比较运算符"><a href="#续比较运算符" class="headerlink" title="+续比较运算符"></a>+续比较运算符</h6><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">表达式</th>
<th align="center">意义</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8</td>
<td align="center">IS NULL</td>
<td align="center">为空</td>
<td align="center">comm IS NULL</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">IS NOT NULL</td>
<td align="center">不为空</td>
<td align="center">comm IS NOT NULL</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">BETWEEN AND</td>
<td align="center">范围</td>
<td align="center">sal BETWEEN 2000 AND 3000</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">LIKE</td>
<td align="center">模糊查询</td>
<td align="center">ename LIKE “A%”</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><span style = "color : red"><strong>REGEXP</strong></span></td>
<td align="center"><span style = "color : red"><strong>正则表达式</strong></span></td>
<td align="center"><strong>ename REGEXP “[a-zA-Z]{4}”</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>__代表前方一个未知    %代表前方N个未知</p>
</blockquote>
<pre><code class="sql">SELECT 
ename,comm,sal
FROM t_emp WHERE comm IS NULL
AND sal BETWEEN 2000 AND 3000;
AND ename LIKE &quot;_LAKE&quot;;

SELECT 
ename,comm,sal
FROM t_emp WHERE comm IS NULL
AND sal BETWEEN 2000 AND 3000;
AND ename REGEXP &quot;^[\\u4e00-\\u9fa5]&#123;2,4&#125;$&quot;; #正则表达汉字范围寻找两到四个中文字符
</code></pre>
<h6 id="按位运算符-amp-位与-位或-位取反-位异或-lt-lt-左移-gt-gt-右移"><a href="#按位运算符-amp-位与-位或-位取反-位异或-lt-lt-左移-gt-gt-右移" class="headerlink" title="按位运算符 [&amp;位与  |位或  ~位取反  ^位异或  &lt;&lt;左移  &gt;&gt;右移]"></a>按位运算符 [&amp;位与  |位或  ~位取反  ^位异或  &lt;&lt;左移  &gt;&gt;右移]</h6><p>&lt;&lt; 左移  10&lt;&lt;1 把10转换成二进制位 在最右面补上一个0 整体向左移动了一个单位<br>》》左移  10&lt;&lt;1 把10转换成二进制位 在最右面抹去一个0 整体向右移动了一个单位</p>
<h3 id="二进制按位运算"><a href="#二进制按位运算" class="headerlink" title="二进制按位运算"></a>二进制按位运算</h3><ul>
<li>二进制运算的实质是将参与运算的两个操作数，按对应的二进制数逐位进行逻辑运算<br>SELECT 3 &amp; 7;    0011 &amp; 0111 &#x3D; 0011 &#x3D; 3</li>
</ul>
<h3 id="数据操作语言：条件查询-二-AND与-OR或-NOT非-XOR异或"><a href="#数据操作语言：条件查询-二-AND与-OR或-NOT非-XOR异或" class="headerlink" title="数据操作语言：条件查询(二) [AND与 OR或 NOT非 XOR异或]"></a>数据操作语言：条件查询(二) [AND与 OR或 NOT非 XOR异或]</h3><pre><code class="sql">查询10和20之外部门的信息
SELECT
  ename,deptno,sal
FROM t_emp
WHERE NOT deptno IN(10,20) XOR sal&gt;=2000;
</code></pre>
<h3 id="WHERE子句的注意事项"><a href="#WHERE子句的注意事项" class="headerlink" title="WHERE子句的注意事项"></a>WHERE子句的注意事项</h3><ul>
<li>WHERE子句中，条件执行的顺序是从左到右的。所以我们应该把<strong>索引条件，或者筛选掉记录最多的条件</strong>写在最左侧<pre><code class="sql">SELECT empno,ename FROM t_emp
WHERE ename = &quot;FORD&quot; AND sal &gt;= 2000;

SELECT empno,ename FROM t_emp
WHERE deptno = 10 AND sal &gt;= 2000;
</code></pre>
</li>
</ul>
<h3 id="各种子句的执行排序"><a href="#各种子句的执行排序" class="headerlink" title="各种子句的执行排序"></a>各种子句的执行排序</h3><h5 id="FROM-→-WHERE-→-SELECT-→-ORDER-BY-→-LIMIT"><a href="#FROM-→-WHERE-→-SELECT-→-ORDER-BY-→-LIMIT" class="headerlink" title="FROM → WHERE → SELECT → ORDER BY → LIMIT"></a>FROM → WHERE → SELECT → ORDER BY → LIMIT</h5><p>先表 再查出符合条件的记录 才能从中挑选出符合的字段 先排序后限制</p>
<hr>
<h1 id="数据库高级内容"><a href="#数据库高级内容" class="headerlink" title="数据库高级内容"></a>数据库高级内容</h1><h3 id="数据操作语言：聚合函数"><a href="#数据操作语言：聚合函数" class="headerlink" title="数据操作语言：聚合函数"></a>数据操作语言：聚合函数</h3><ul>
<li><p>聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对<strong>数据求和</strong>、求<strong>最大值</strong>和<strong>最小值</strong>、求<strong>平均值</strong>等等</p>
</li>
<li><p>求公司员工的平均月收入是多少？</p>
<pre><code class="sql">底薪+佣金(不是null)
SELECT AVG(sal+IFNULL(comm,0)) FROM t_emp;
</code></pre>
</li>
</ul>
<h5 id="SUM函数"><a href="#SUM函数" class="headerlink" title="SUM函数"></a>SUM函数</h5><ul>
<li><p>SUM函数用于求和，只能用于数字类型，字符类型的统计结果为0，日期类型统计结果是毫秒数相加</p>
<pre><code class="sql">SELECT SUM(ename) FROM t_emp

SELECT SUM(sal) FROM t_emp
WHERE deptno IN (10,20);
</code></pre>
</li>
</ul>
<h5 id="MAX函数"><a href="#MAX函数" class="headerlink" title="MAX函数"></a>MAX函数</h5><ul>
<li><p>MAX函数用于获得非空值的最大值</p>
<pre><code class="sql">SELECT MAX(comm) FORM t_emp;

①查询10和20部门中,月收入最高的员工？
SELECT 
MAX(sal+IFNULL(comm,0)) FROM t_temp
FROM t_emp
WHERE deptno IN (10,20);

②查询员工名字最长的是几个字符？
SELECT MAX(LENGTH(ename)) FROM t_emp;

SELECT
SUM(sal),MAX(sal+IFNULL(comm,0)) 
FROM t_emp
WHERE deptno IN(10,20); 
</code></pre>
</li>
</ul>
<h5 id="MIN函数"><a href="#MIN函数" class="headerlink" title="MIN函数"></a>MIN函数</h5><ul>
<li><p>MIN函数用于获得非空值的最小值</p>
<pre><code class="sql">SELECT MIN(empno) FROM t_emp;
</code></pre>
</li>
</ul>
<h5 id="AVG函数"><a href="#AVG函数" class="headerlink" title="AVG函数"></a>AVG函数</h5><ul>
<li><p>AVG函数用于获得非空值的平均值，非数字数据统计结果为0</p>
<pre><code class="sql">SELECT AVG(sal+IFNULL(comm,0)) FROM t_emp;
</code></pre>
</li>
</ul>
<h5 id="COUNT函数"><a href="#COUNT函数" class="headerlink" title="COUNT函数"></a>COUNT函数</h5><ul>
<li><p>COUNT(*) [<u>找所有</u>]用于获得包含空值的记录数，COUNT(列名)用于获得包含非空值的记录数</p>
<pre><code class="sql">SELECT COUNT(*) FROM t_emp; #统计所有   15 
SELECT COUNT(comm) FROM t_emp; #统计数量是非空   5
</code></pre>
</li>
<li><p>查询10和20部门中，底薪超过2000元并且工龄超过15年的员工人数</p>
<pre><code class="sql">SELECT COUNT(*) 
FROM t_emp
WHERE deptno IN(10,20) 
AND sal&gt;=2000
AND DATEDIFF(NOW(),hiredate)/365&gt;=15;
</code></pre>
</li>
<li><p>查询1985年以后入职的员工，底薪超过公司平均底薪的员工数量？</p>
<pre><code class="sql">×××××××××错误示范×××××××××
SELECT COUNT(*) FROM t_emp
WHERE hiredate&gt;=&quot;1985-01-01&quot;
AND sal&gt;AVG(sal); #AVG无法运行 聚合函数不能出现在WHERE里面
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：分组查询"><a href="#数据操作语言：分组查询" class="headerlink" title="数据操作语言：分组查询"></a>数据操作语言：分组查询</h3><h6 id="为什么要分组？"><a href="#为什么要分组？" class="headerlink" title="为什么要分组？"></a>为什么要分组？</h6><ul>
<li>默认情况下汇总函数是对全表范围内的数据做统计</li>
<li>GROUP BY子句的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对每个小区域分别进行数据汇总处理</li>
</ul>
<pre><code class="sql">SELECT deptno,ROUND(AVG(sal))
FROM t_emp
GROUP BY deptno; #分组来计算AVG
</code></pre>
<h3 id="逐级分组"><a href="#逐级分组" class="headerlink" title="逐级分组"></a>逐级分组</h3><ul>
<li>数据库支持多列分组条件，执行的时候逐级分组</li>
<li>查询每个部门里，每种职位的人员数量和平均底薪</li>
</ul>
<pre><code class="sql">#按照部门和工作分组 ↓这种职位人数 ↓这种职位底薪平均值
SELECT deptno,job,COUNT(*),AVG(sal)
FROM t_emp 
GROUP BY deptno,job
ORDER BY deptno; #按照deptno去排序
</code></pre>
<h3 id="对SELECT子句的要求"><a href="#对SELECT子句的要求" class="headerlink" title="对SELECT子句的要求"></a>对SELECT子句的要求</h3><ul>
<li>查询语句中如果含有<strong>GROUP BY</strong>子句，那么SELECT子句中的内容就必须要遵守规定：SELECT子句中可以包括聚合函数，或者GROUP BY子句的分组列，其余内容均不可以出现在<strong>SELECT</strong>子句中</li>
</ul>
<pre><code class="sql">#正确示范
SELECT deptno,COUNT(*),AVG(sal)
FROM t_emp GROUP BY deptno;

#错误示范
SELECT deptno,COUNT(*),AVG(sal),sal
FROM t_emp GROUP BY deptno;
</code></pre>
<h3 id="对分组结果集再次做汇总计算"><a href="#对分组结果集再次做汇总计算" class="headerlink" title="对分组结果集再次做汇总计算"></a>对分组结果集再次做汇总计算</h3><pre><code class="sql">SELECT 
deptno,COUNT(*),AVG(sal),MAX(sal),MIN(sal)
FROM t_emp 
GROUP BY deptno WITH ROLLUP; #WITH ROLLUP对汇总函数再次进行汇总运算
</code></pre>
<h3 id="GROUP-CONCAT函数"><a href="#GROUP-CONCAT函数" class="headerlink" title="GROUP_CONCAT函数"></a>GROUP_CONCAT函数</h3><ul>
<li><p><strong>GROUP_CONCAT</strong>函数可以把分组查询中的<strong>某个字段拼接成一个字符串</strong></p>
</li>
<li><p>查询每个部门内底薪超过2000元的人数和员工姓名</p>
<pre><code class="sql">SELECT deptno,GROUP_CONCAT(ename),COUNT(*)
FROM t_emp 
WHERE sal&gt;=2000
GROUP BY deptno;
</code></pre>
<table>
<thead>
<tr>
<th align="center">deptno</th>
<th align="center">COUNT(*)</th>
<th align="center">GROUP_CONCAT(ename)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">CLARK,KING</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">3</td>
<td align="center">JONES,SCOTT,FORD</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">1</td>
<td align="center">BLAKE</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="各种子句的执行顺序"><a href="#各种子句的执行顺序" class="headerlink" title="各种子句的执行顺序"></a>各种子句的执行顺序</h3><h5 id="FROM-→-WHERE-→-GROUP-BY-→-SELECT-→-ORDER-BY-→-LIMIT"><a href="#FROM-→-WHERE-→-GROUP-BY-→-SELECT-→-ORDER-BY-→-LIMIT" class="headerlink" title="FROM → WHERE → GROUP BY → SELECT → ORDER BY  → LIMIT"></a>FROM → WHERE → GROUP BY → SELECT → ORDER BY  → LIMIT</h5><p><strong>WHERE</strong>符合的留下来交给<strong>GROUP BY</strong>去分组之后调用<strong>SELECT</strong>中的聚合函数计算 <strong>ORDER BY</strong>子句对结果排序交给<strong>LIMIT</strong>子句来挑选返回哪些数据</p>
<h3 id="分组查询遇到的困难？"><a href="#分组查询遇到的困难？" class="headerlink" title="分组查询遇到的困难？"></a>分组查询遇到的困难？</h3><ul>
<li><p>查询部门平均底薪超过2000元的部门编号</p>
<pre><code class="sql">#错误演示[因为WHERE语句出现了聚合函数]
SELECT deptno FROM t_emp
WHERE AVG(sal)&gt;=2000
GROUP BY deptno;
</code></pre>
</li>
<li><p><strong>HAVING</strong>语句是紧紧跟着<strong>GROUP BY</strong>语句的 <u>HAVING子句可以写聚合函数作为判断条件</u></p>
<pre><code class="sql">SELECT deptno
FROM t_emp
GROUP BY deptno HAVING AVG(sal)&gt;=2000;
</code></pre>
</li>
</ul>
<h3 id="HAVING子句的用途"><a href="#HAVING子句的用途" class="headerlink" title="HAVING子句的用途"></a>HAVING子句的用途</h3><ul>
<li><p>查询每个部门中，<u>1982年以后入职的员工$<em>{普通条件可以写在WHERE里}$</u><u>超过2个人</u>$</em>{COUNT(*)&gt;&#x3D;2}$的部门编号<br>不能拿<strong>聚合函数</strong>和<strong>某一个字段</strong>做判断</p>
<pre><code class="sql">SELECT deptno 
FROM t_emp
WHERE hiredate&gt;=&quot;1982-01-01&quot;
GROUP BY deptno HAVING COUNT(*)&gt;=2;
ORDER BY deptno ASC;

SELECT deptno 
FROM t_emp
WHERE hiredate&gt;=&quot;1982-01-01&quot;
GROUP BY deptno HAVING COUNT(*)&gt;=2 AND AVG(sal)&gt;=2000;
</code></pre>
</li>
</ul>
<h3 id="HAVING子句的特殊用法-作用类似于WHERE"><a href="#HAVING子句的特殊用法-作用类似于WHERE" class="headerlink" title="HAVING子句的特殊用法 [作用类似于WHERE]"></a>HAVING子句的特殊用法 [作用类似于WHERE]</h3><ul>
<li><p>按照数字1分组，MySQL会根据SELECT子句中的列进行分组，HAVING子句也可以正常使用<br>能用WHERE就不要先用HAVING 它的作用是給聚合函数做判断</p>
<pre><code class="sql">#不推荐写法
SELECT deptno,COUNT(*) 
FROM t_emp
GROUP BY 1 HAVING deptno IN (10,20);

#推荐写法
SELECT deptno,COUNT(*) 
FROM t_emp
WHERE deptno IN(10,20)
GROUP BY 1;
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：表链接查询-一"><a href="#数据操作语言：表链接查询-一" class="headerlink" title="数据操作语言：表链接查询(一)"></a>数据操作语言：表链接查询(一)</h3><h5 id="从多张表中提取数据"><a href="#从多张表中提取数据" class="headerlink" title="从多张表中提取数据"></a>从多张表中提取数据</h5><ul>
<li><p>从多张表中提取数据，必须指定关联的条件。如果不定义关联条件就会出现无条件链接，两张表的数据会交叉连接，产生<strong>笛卡尔积</strong></p>
</li>
<li><p>规定了链接条件的表链接语句，就不会出现笛卡尔积 [On条件]</p>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname
FROM t_emp e JOIN t_dept d #給表起别名
ON e.deptno=d.deptno; #员工部门编号等于部门的部门编号
</code></pre>
</li>
</ul>
<h3 id="表链接的分类"><a href="#表链接的分类" class="headerlink" title="表链接的分类"></a>表链接的分类</h3><ul>
<li>表链接分为两种：<strong>内链接</strong>和<strong>外连接</strong></li>
<li><strong>内链接</strong>是结果集中只保留符合连接条件的记录</li>
<li><strong>外连接</strong>是不管符不符合链接条件，记录都要保留在结果集中</li>
</ul>
<h6 id="内链接"><a href="#内链接" class="headerlink" title="内链接"></a>内链接</h6><pre><code class="sql">SELECT ... FROM 表1
[INNER] JOIN 表2 ON 条件
[INNER] JOIN 表3 ON 条件
...
</code></pre>
<h6 id="内连接的多种语法形式"><a href="#内连接的多种语法形式" class="headerlink" title="内连接的多种语法形式"></a>内连接的多种语法形式</h6><pre><code class="sql">SELECT ... FROM 表1 JOIN 表2 ON 连接条件;
SELECT ... FROM 表1 JOIN 表2 WHERE 连接条件
SELECT ... FROM 表1,表2 WHERE 连接条件;
</code></pre>
<h3 id="内连接练习1"><a href="#内连接练习1" class="headerlink" title="内连接练习1"></a>内连接练习1</h3><ul>
<li><strong>查询每个员工的工号、姓名、部门名称、底薪、职位、工资等级</strong>？且保证工资符合范围</li>
</ul>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname,e.sal,e.job,s.grade
FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno
JOIN t_salgrade s ON e.sal BETWEEN s.losal AND s.hisal;
</code></pre>
<ul>
<li>内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以</li>
</ul>
<h3 id="内连接练习2"><a href="#内连接练习2" class="headerlink" title="内连接练习2"></a>内连接练习2</h3><ul>
<li><p>查询与<strong>SCOTT</strong>相同部门的员工都有谁？</p>
</li>
<li><p>相同的数据表也可以做表连接</p>
<pre><code class="sql">SELECT deptno
FROM t_emp
WHERE ename=&quot;SCOTT&quot;; 

#子查询的结果变成了条件  SCOTT本人不算
SELECT deptno
FROM t_emp
WHERE deptno=(SELECT dptno FROM t_emp WHERE ename=&quot;SCOTT&quot;);
AND ename!=&quot;SCOTT&quot;;

#改造快速一些  ON后是筛选条件 和 WHERE作用差不多
SELECT e2.ename
FROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno
WHERE e1.ename=&quot;SCOTT&quot; AND e2.ename!=&quot;SCOTT&quot;; 
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：表链接查询-二"><a href="#数据操作语言：表链接查询-二" class="headerlink" title="数据操作语言：表链接查询(二)"></a>数据操作语言：表链接查询(二)</h3><h5 id="内连接查询练习1"><a href="#内连接查询练习1" class="headerlink" title="内连接查询练习1"></a>内连接查询练习1</h5><ul>
<li>查询底薪超过公司平均底薪的员工信息？<br><span style="color : red"><strong>把聚合函数查询的结果做成一张表 再进行表连接 【分部描述】</strong></span></li>
</ul>
<pre><code class="sql">#错误展示
SELECT e2.empno,e2.ename,e2.sal  #因为ON可以换成WHERE 然而WHERE后面有聚合函数 所以会报错
FORM t_emp e1 JOIN t_emp e2 ON e2.sal&gt;=AVG(e1.sal);

#把聚合函数查询的结果做成一张表 再进行表连接 【分部描述】
SELECT AVG(sal)
FROM t_emp;

SELECT e.empno,e.ename,e.sal
FROM t_emp e JOIN(SELECT AVG(sal) avg FROM t_emp) t #avg别名
ON e.sal&gt;=t.avg;
</code></pre>
<ul>
<li>查询RESEARCH部门的人数、最高底薪、最低底薪、平均底薪、平均工龄？</li>
</ul>
<pre><code class="sql">SELECT COUNT(*),MAX(e.sal),MIN(e.sal),AVG(e.sal),AVG(DATEDIFF(NOW(),e.hiredate)/365)
FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno
WHERE d.dname=&quot;RESEARCH&quot;;

SELECT FLOOR(28.9); #变成28 向上取整
SELECT CEIL(1.1);   #变成1  向上取整
</code></pre>
<h5 id="内连接查询练习2"><a href="#内连接查询练习2" class="headerlink" title="内连接查询练习2"></a>内连接查询练习2</h5><ul>
<li><p>查询每种职业的最高工资、最低工资、平均工资、最高工资等级和最低工资等级？</p>
<pre><code class="sql">SELECT 
e.job,MAX(e.sal+IFNULL(e,comm,0)),
MIN(e.sal+IFNULL(e,comm,0)),AVG(e.sal+IFNULL(e,comm,0)),
MAX(s.grade),MIN(s.grade)
FROM t_emp e JOIN t_salgrade s
ON (e.sal+IFNULL(e,comm,0)) BETWEEN s.losal AND s.hisal
GROUP BY e.job;
</code></pre>
</li>
<li><p>查询每个底薪超过部门平均底薪的员工信息 [<strong>用表连接 而不是子查询</strong>]</p>
<pre><code class="sql">SELECT e.empno,e.ename,e.sal
FROM t_emp e JOIN
(SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY dptno) t #别名t
ON e.deptno=t.deptno AND e.sal&gt;=t.avg;
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：表链接查询-三"><a href="#数据操作语言：表链接查询-三" class="headerlink" title="数据操作语言：表链接查询(三)"></a>数据操作语言：表链接查询(三)</h3><h5 id="为什么要使用外连接"><a href="#为什么要使用外连接" class="headerlink" title="为什么要使用外连接"></a>为什么要使用外连接</h5><ul>
<li>如果说陈浩是一名临时人员，没有固定的部门编制(NULL)，那么我们想查询每名员工和他的部门名称，用内连接就会遗漏掉陈浩，所以要引用外连接的语法才能解决这个问题</li>
</ul>
<h5 id="外连接简介"><a href="#外连接简介" class="headerlink" title="外连接简介"></a>外连接简介</h5><ul>
<li><p>外连接与内连接的区别在于，除了符合条件的记录之外，结果集中还会保留不符合条件的记录</p>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname
FROM t_emp e  #因为陈浩部门编制是NULL 不能直接JOIN 只能LEFT JOIN
LEFT JOIN t_dept d ON e.deptno=d.deptno; 
</code></pre>
<table>
<thead>
<tr>
<th>7902</th>
<th>FORD</th>
<th>RESEARCH</th>
</tr>
</thead>
<tbody><tr>
<td>7934</td>
<td>MILLER</td>
<td>ACCOUNTING</td>
</tr>
<tr>
<td>8000</td>
<td>陈浩</td>
<td>(<strong>NULL</strong>)</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="左连接和右连接"><a href="#左连接和右连接" class="headerlink" title="左连接和右连接"></a>左连接和右连接</h3><ul>
<li><p>左外连接就是保留左表所有的记录，与右表做连接。如果右表有符合条件的记录就与左表连接。如果右表没有符合条件的记录，就用NULL与左表连接。右外连接也是如此。</p>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname
FORM t_dept d RIGHT JOIN t_emp e #要保留所有的t_emp e
ON e.deptno=d.deptno;
</code></pre>
</li>
</ul>
<h3 id="外连接练习1"><a href="#外连接练习1" class="headerlink" title="外连接练习1"></a>外连接练习1</h3><ul>
<li><p>查询每个部门的名称和部门的人数？ [40有部门没员工 要保存空值]<br><u>左外连接把部门表写在左侧    右外连接把部门表写在右侧</u></p>
<pre><code class="sql">SELECT d.dname,COUNT(*)
FROM t_dept d LEFT JOIN t_emp e #保留左表的所有记录 右表有空
ON d.deptno=e.deptno
GROUP BY d.deptno; #因为保留了左表所有记录 所以分组按照部门号分
#最终有一条t_dept与t_emp中的NULL做连接 所以 COUNT算上此记录
#若要将右表的NULL值忽略掉 要在COUNT(d.deptno)这样写

SELECT d.dname,COUNT(d.deptno)
FROM t_dept d LEFT JOIN t_emp e #保留左表的所有记录
ON d.deptno=e.deptno
GROUP BY d.deptno;
</code></pre>
<table>
<thead>
<tr>
<th>dname</th>
<th>COUNT(d.deptno)</th>
</tr>
</thead>
<tbody><tr>
<td>ACCOUNTING</td>
<td>3</td>
</tr>
<tr>
<td>RESEARCH</td>
<td>5</td>
</tr>
<tr>
<td>SALES</td>
<td>6</td>
</tr>
<tr>
<td><strong>OPERATIONS</strong></td>
<td><strong>0</strong></td>
</tr>
</tbody></table>
</li>
<li><p>查询每个部门的名称和部门的人数？如果没有部门的员工，部门名称用NULL代替</p>
</li>
<li><p><strong>UNION关键字</strong>可以将多个查询语句的结果集进行合并</p>
<pre><code class="sql">(查询语句) UNION (查询语句) UNION (查询语句)...
（SELECT d.name,COUNT(e.deptno)
FROM t_dept d LEFT JOIN t_emp e
ON d.deptno=e.deptno
GROUP BY d.deptno
）UNION
(SELECT d.dname,COUNT(*)
FROM t_dept d RIGHT JOIN t_emp e
ON d.deptno=e.deptno
GROUP BY d.deptno
);
</code></pre>
</li>
</ul>
<h3 id="数据库操作语言：表连接查询-四"><a href="#数据库操作语言：表连接查询-四" class="headerlink" title="数据库操作语言：表连接查询(四)"></a>数据库操作语言：表连接查询(四)</h3><ul>
<li><p>查询每名员工的编号、姓名、部门、月薪、工资等级、工龄、上司编号、上司姓名、上司部门？<br>[不知道：员工信息 员工的上司信息    两个不知道信息是不能使用子查询的  <u>员工表 部门表 公司等级表</u>]</p>
<pre><code class="sql">#陈浩要保存下来 用外连接
SELECT
e.empno,e.ename,d.dname,
e.sal+IFNULL(e.comm,0),s.grade,
FLOOR(DATEDIFF(NOW(),e.hiredate)/365),
t.empno AS mgrno,t.ename AS mname,t.dname AS mdname #定义上司的数据
FROM t_emp e 
LEFT JOIN t_dept d ON e.deptno=d.deptno #结果集所有记录保存下来跟工资等级表做连接
LEFT JOIN t_salgrade s ON e.sal BETWEEN s.losal AND s.hisal
LEFT JOIN
(SELECT e1.empno,e1.ename,d1.dname
FROM t_emp e1 JOIN t_dept d1
ON e1.deptno=d1.deptno
)t ON e.mgr=t.empno;
</code></pre>
</li>
</ul>
<h3 id="外连接的注意事项"><a href="#外连接的注意事项" class="headerlink" title="外连接的注意事项"></a>外连接的注意事项</h3><ul>
<li><strong>内连接</strong>值保留符合条件的记录，所以查询条件写在ON子句和WHERE子句中的效果是相同的。但是<strong>外连接</strong>里，条件写在WHERE子句里，不符合条件的记录是会被过滤掉的，而不是保留下来的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2af31e5baf5f6fc6e517ef9c13f689a8ab3db3a0/data/%E5%86%85%E5%A4%96%E8%BF%9E%E6%8E%A5WHEWE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p>
<h3 id="数据操作语言：子查询-一"><a href="#数据操作语言：子查询-一" class="headerlink" title="数据操作语言：子查询(一)"></a>数据操作语言：子查询(一)</h3><p>WHERE中的子查询是需要反复查询的 不推荐使用，但是把它所得的结果集作为一张表跟其他表做连接是推荐的</p>
<ul>
<li><p>子查询是一种查询中嵌套查询的语句</p>
</li>
<li><p>查询底薪超过公司平均底薪的员工信息</p>
<pre><code class="sql">SELECT empno,ename,sal
FORM t_emp
WHERE sal&gt;=(SELECT AVG(sal) FROM t_emp); #不推荐使用 最好用表连接
</code></pre>
</li>
</ul>
<h6 id="子查询的分类"><a href="#子查询的分类" class="headerlink" title="子查询的分类"></a>子查询的分类</h6><ul>
<li>子查询可以写在三个地方：<strong>WHERE子句、FROM子句、SELECT子句</strong>，但是只有FROM子句子查询是最可取的</li>
</ul>
<h6 id="WHERE子查询"><a href="#WHERE子查询" class="headerlink" title="WHERE子查询"></a>WHERE子查询</h6><ul>
<li><p>这种子查询最简单，最容易理解，但是确实<strong>效率很低</strong>的子查询</p>
</li>
<li><p>查询底薪超过公司平均底薪的员工信息</p>
<pre><code class="sql">SELECT empno,ename,sal
FORM t_emp #↓↓↓↓ 比较每条记录都要重写执行子查询 ↓↓↓↓
WHERE sal&gt;=(SELECT AVG(sal) FROM t_emp); #不推荐使用 最好用表连接
</code></pre>
</li>
</ul>
<h6 id="FROM子查询"><a href="#FROM子查询" class="headerlink" title="FROM子查询"></a>FROM子查询</h6><ul>
<li><p>这种子查询只会执行一次，所以<strong>查询效率很高</strong></p>
</li>
<li><p>查询底薪超过公司平均底薪的员工信息</p>
<pre><code class="sql">SELECT
e.empno,e.ename,e.sal,t.avg
FROM t_emp e JOIN
(SELECT deptno,AVG(sal) AS avg
FORM t_emp 
GROUP BY deptno) t #按照部门编号去分组 起别名
ON e.deptno=t.deptno 
AND e.sal&gt;=t.avg;
</code></pre>
</li>
</ul>
<h6 id="SELECT子查询"><a href="#SELECT子查询" class="headerlink" title="SELECT子查询"></a>SELECT子查询</h6><ul>
<li><p>这种子查询每输出一条记录的时候都要执行一次，<strong>查询效率很低</strong></p>
<pre><code class="sql">SELECT
e.empno,
e.ename,
(SELECT dname FROM t_dept WHERE deptno=e.deptno)
FROM t_emp e;
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：子查询-二"><a href="#数据操作语言：子查询-二" class="headerlink" title="数据操作语言：子查询(二)"></a>数据操作语言：子查询(二)</h3><h5 id="单行子查询和多行子查询-结果集可以作为新表连接"><a href="#单行子查询和多行子查询-结果集可以作为新表连接" class="headerlink" title="单行子查询和多行子查询 [结果集可以作为新表连接]"></a>单行子查询和多行子查询 [结果集可以作为新表连接]</h5><ul>
<li><p>单行子查询的结果集只有一条记录，多行子查询结果集有多行记录</p>
</li>
<li><p>多行子查询只能出现在WHERE子句和FROM子句中</p>
</li>
<li><p>如何用子查询查找FORD和MARTIN两个人的同事</p>
<pre><code class="sql">SELECT ename #排除那俩人之外
FROM t_emp 
WHERE
deptno IN    # deptno = 不行因为后面返回了两条记录
(SELECT deptno FROM t_emp WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;)); #返回两条记录
AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;);
</code></pre>
</li>
</ul>
<h3 id="WHERE子句中的多行子查询"><a href="#WHERE子句中的多行子查询" class="headerlink" title="WHERE子句中的多行子查询"></a>WHERE子句中的多行子查询</h3><ul>
<li><p>WHERE子句中，可以使用<strong>IN、ALL、ANY、EXISTS</strong>关键字来处理多行表达式结果集的条件判断</p>
</li>
<li><p>调查”FORD”和”MARTIN”底薪都高的员工信息</p>
<pre><code class="sql">SELECT ename 
FROM t_emp 
WHERE sal &gt; ALL #ALL是sal里的数比结果集里的所有值都大  ANY则是比任何一个人大
(SELECT sal FROM t_emp #结果集里返回了多条记录
WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;))
AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;); #不包含这俩人
</code></pre>
</li>
</ul>
<h3 id="EXISTS关键字"><a href="#EXISTS关键字" class="headerlink" title="EXISTS关键字"></a>EXISTS关键字</h3><ul>
<li><p><strong>EXISTS关键字</strong>是把原来在子查询之外的条件判断，写到了子查询的里面<br>EXISTS用上之后WHERE就不写任何语句了</p>
<pre><code class="sql">SELECT ... FROM 表名 WHERE [NOT] EXISTS(子查询);
</code></pre>
</li>
<li><p>查询工资等级是3级或者4级的员工信息</p>
<pre><code class="sql">#排斥此方法 效率低下
SELECT
FROM t_emp
WHERE EXISTS(
SELECT * FROM t_salgrade
WHERE sal BETWEEN losal AND hisal 
AND grade IN(3,4)
);
</code></pre>
</li>
</ul>
<h1 id="MySQL对数据的基本操作"><a href="#MySQL对数据的基本操作" class="headerlink" title="MySQL对数据的基本操作"></a>MySQL对数据的基本操作</h1><h3 id="数据操作语言：INSERT语句"><a href="#数据操作语言：INSERT语句" class="headerlink" title="数据操作语言：INSERT语句"></a>数据操作语言：INSERT语句</h3><ul>
<li><p><strong>INSERT</strong>语句可以向数据表写入记录，可以是一条记录，也可以是多条记录</p>
<pre><code class="sql">INSERT INTO 表名(字段1,字段2,......) #添加字段可以快速写入 
VALUES(值1,值2,......);

INSERT INTO 表名(字段1,字段2,......) 
VALUES(值1,值2,......),(值1,值2,......); #多条记录

INSERT INTO t_dept(deptno,dname,loc)
VALUES(520,&quot;研发部&quot;,&quot;河北&quot;),(250,&quot;销售部&quot;,&quot;江西&quot;);

#向技术部添加一条员工记录 
#[技术部编号不知道 子查询技术部的编号 结果 写到VALUES子句里面通过INSERT插入员工表里面]
INSERT INTO t_emp
(empno,ename,job,mgr,hiredate,sal,comm,deptno)
VALUES(8001,&quot;潘春尧&quot;,&quot;SALESMAN&quot;,8000,&quot;2023-10-15&quot;,2000,NULL,
(SELECT deptno FROM t_dept WHERE dname=&quot;技术部&quot;)); #子查询单个结果返回
</code></pre>
</li>
</ul>
<h3 id="INSERT语法方言"><a href="#INSERT语法方言" class="headerlink" title="INSERT语法方言"></a>INSERT语法方言</h3><ul>
<li><p>MySQL的INSERT语句有一种方言语法</p>
<pre><code class="sql">INSERT INTO 表名 SET 字段1=值1,字段2=值2,......; #只适合Mysql数据库

(INSERT) INTO t_emp
SET empno=8002,ename=&quot;JACK&quot;,job=&quot;SLAESMAN&quot;,mgr=8000,
hiredate=&quot;1985-01-01&quot;,sal=2500,comm=NULL,deptno=50;

DELETE FROM t_emp WHERE empno=8002;
</code></pre>
</li>
</ul>
<h3 id="IGNORE关键字"><a href="#IGNORE关键字" class="headerlink" title="IGNORE关键字"></a>IGNORE关键字</h3><ul>
<li><p><strong>IGNORE</strong>关键字会让<strong>INSERT</strong>只插入数据库不存在的记录</p>
<pre><code class="sql">INSERT [IGNORE] INTO 表名...;
INSERT IGNORE INTO t_dept(deptno,dname,loc)
VALUES(40,&quot;技术部&quot;,&quot;北京&quot;); #40编号是主键被占用了 和已经现存的记录有冲突

#运用方言写
INSERT IGNORE INTO t_dept
SET deptno=40,dname=&quot;技术部&quot;,loc=&quot;北京&quot;;

#多重数据忽略不正确的数据
INSERT IGNORE INTO t_dept(deptno,dname,loc)
VALUES(40,&quot;A&quot;,&quot;北京&quot;),(80,&quot;B&quot;,&quot;上海&quot;);

#VALUES(40,&quot;A&quot;,&quot;北京&quot;),(80,&quot;B&quot;,&quot;上海&quot;)
#&gt; Affected rows: 1
#&gt; 时间: 0.002s
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：UPDATE语句-一"><a href="#数据操作语言：UPDATE语句-一" class="headerlink" title="数据操作语言：UPDATE语句(一)"></a>数据操作语言：UPDATE语句(一)</h3><ul>
<li><p>UPDATE语句用于修改表的记录<br><strong>UPDATE</strong>中的<strong>NIGNORE</strong>直接忽略冲突的语句</p>
<pre><code class="sql">UPDATE [IGNORE] 表名
SET 字段1=值1，字段2=值2,......
[WHERE 条件1...] #有条件的修改记录
[ORDER BY...] #对数据先排序 后修改员工编号＋1 
[LIMIT...]; #取分页数据

#把每个员工的编号和上司的编号+1，用ORDER BY子句完成
UPDATE t_emp 
SET empno=empno+1,mgr=mgr+1
ORDER BY empno DESC;

#把用收入前三名的员工底薪减100元，用LIMIT子句完成
UPDATE t_emp
SET sal=sal-100 
ORDER BY sal+IFNULL(comm,0) DESC #降序 
LIMIT 3; #取前三条记录
</code></pre>
</li>
</ul>
<h3 id="UPDATE语句的表连接-一"><a href="#UPDATE语句的表连接-一" class="headerlink" title="UPDATE语句的表连接(一)"></a>UPDATE语句的表连接(一)</h3><ul>
<li><p>因为相关子查询效率非常低，所以我们可以利用表连接的方式来改造UPDATE语句</p>
<pre><code class="sql">UPDATE 表1 JOIN 表2 ON 条件
SET 字段1=值1,字段2=值2,......;
</code></pre>
</li>
<li><p>表连接的UPDATE语句可以修改多张表的记录[<strong>进化</strong>]</p>
<pre><code class="sql">UPDATE 表1,表2
SET 字段1=值1,字段2=值2,......
WHERE 连接条件;

#把ALLEN调往RESEARCH部门，职务调整为ANALYST
[员工表+部门表]
UPDATE t_emp e JOIN t_dept d
SET e.deptno=d.deptno
WHERE e.ename=&quot;ALLEN&quot; AND d.dname=&quot;RESEARCH&quot;
#//在t_emp表中找到ALLEN + 在t_dept表中找到RESEARCH 
#//然后把d.deptno赋值給e.deptno

UPDATE t_emp e JOIN t_dept d
SET e.deptno=d.deptno,e.job=&quot;ANALYST&quot;,d.loc=&quot;北京&quot;
WHERE e.ename=&quot;ALLEN&quot; AND d.dname=&quot;RESEARCH&quot;
</code></pre>
</li>
<li><p>把底薪低于公司平均底薪的员工，底薪增加150元<br>[运用<strong>表连接</strong>的方法比<strong>WHERE语句</strong>的效率高]</p>
<pre><code class="sql">UPDATE t_emp e JOIN
(SELECT AVG(sal) AS avg FROM t_emp) t
ON e.sal&lt;t.avg
SET e.sal=e.sal+150;
</code></pre>
</li>
</ul>
<h3 id="UPDATE语句的表连接-二"><a href="#UPDATE语句的表连接-二" class="headerlink" title="UPDATE语句的表连接(二)"></a>UPDATE语句的表连接(二)</h3><ul>
<li><p>UPDATE语句的表连接既可以是内连接，又可以是外连接</p>
<pre><code class="sql">UPDATE 表1[LEFT|RIGHT] JOIN 表2 ON 条件 
SET 字段1=值1,字段2=值2,...;
</code></pre>
</li>
<li><p>把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门<br>[把所有员工保留下来 但是陈浩没有部门 用内连接的话会把陈浩忽略掉 要用<strong>左外连接</strong>把左表所有数据保留下来再去跟部门表作连接]</p>
<pre><code class="sql">#把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门
UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno #连接条件 不符合的也保留
SET e.deptno=202
WHERE e.deptno IS NULL OR (d.dname=&quot;SALES&quot; AND e.sal&lt;2000);
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：-DELETE语句-一"><a href="#数据操作语言：-DELETE语句-一" class="headerlink" title="数据操作语言： DELETE语句(一)"></a>数据操作语言： DELETE语句(一)</h3><ul>
<li>DELETE语句用于删除记录<pre><code class="sql">DELETE [IGNORE] FROM 表名
[WHERE 条件1,条件2,...] #按照条件删除记录
[ORDER BY...] #排序后删除
[LIMIT...]; #分页 工资降序排序 排在前五名的删掉
#顺序依次向下 最后一个是DELETE
</code></pre>
</li>
</ul>
<h6 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h6><ul>
<li><p>删除10部门中，工龄超过20年的员工记录</p>
<pre><code class="sql">DELETE FROM t_emp
WHERE deptno=10 AND DATEDIFF(NOW(),hiredate)/365&gt;=20;
</code></pre>
</li>
<li><p>删除20部门中工资最高的员工记录</p>
<pre><code class="sql">DELETE FROM t_emp
WHERE deptno=20
ORDER BY sal+IFNULL(comm,0) DESC
LIMIT 1;
</code></pre>
</li>
</ul>
<h3 id="DELETE语句的表连接-一"><a href="#DELETE语句的表连接-一" class="headerlink" title="DELETE语句的表连接(一)"></a>DELETE语句的表连接(一)</h3><ul>
<li><p>因为相关子查询效率非常低，所有我们可以利用表连接的方法来改造<strong>DELETE</strong>语句</p>
<pre><code class="sql">DELETE 表1,...FROM 表1 JOIN 表2 ON 条件 #删除哪张表记录的操作
[WHERE 条件1,条件2,...]
[ORDER BY...]
[LIMIT...];

#删除SALES部门和该部门的全部员工记录
#无需外连接 因为没有部门需要不删除的
DELETE e,d
FROM t_emp e JOIN t_dept d NO e.deptno=d.deptno #部门名称
WHERE d.dname=&quot;SALES&quot;;
</code></pre>
</li>
<li><p>删除<strong>SALES部门</strong>和该部门的全部员工记录[<strong>表连接</strong>]</p>
<pre><code class="sql">DELETE e
FROM t_emp e JOIN
(SELECT deptno,AVG(sal) AS sal FROM t_emp GOURP BY deptno)
ON e.deptno=t.deptno AND e.sal&lt;t.sal
</code></pre>
</li>
<li><p>删除员工KING和他的直接下属的员工记录，用表连接实现</p>
<pre><code class="sql">DELETE e
FROM t_emp e JOIN
(SELECT empno FROM t_emp WHERE ename=&quot;KING&quot;) t
ON e.mgr=t.empno OR e.empno=t.empno; #KING的下属 OR KING这个人
</code></pre>
</li>
</ul>
<h3 id="DELETE语句的表连接-二"><a href="#DELETE语句的表连接-二" class="headerlink" title="DELETE语句的表连接(二)"></a>DELETE语句的表连接(二)</h3><ul>
<li><p>DELETE语句的表连接既可以是内连接，又可以是外连接</p>
<pre><code class="sql">DELETE 表1,... FROM 表1 [LEFT|RIGHT] JOIN 表2 ON 条件...;
</code></pre>
</li>
<li><p>删除SALES部门的员工，以及没有部门的员工 [左外 因为陈浩没部门要保留 外连接(不可用内连接)]</p>
<pre><code class="sql">DELETE e
FROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno
WHERE d.dname=&quot;SALES&quot; OR e.deptno IS NULL
</code></pre>
</li>
</ul>
<h3 id="快速删除数据表全部记录"><a href="#快速删除数据表全部记录" class="headerlink" title="快速删除数据表全部记录"></a>快速删除数据表全部记录</h3><ul>
<li><p>DELETE语句实在事务机制下删除记录，删除记录之前，先把将要删除的记录保存到日志文件里面，然后删除记录</p>
</li>
<li><p>TRUNCATE语句再事务机制之外删除记录，速度大于DELETE语句</p>
<pre><code class="sql">TRUNCATE TABLE 表名;
</code></pre>
</li>
</ul>
<h3 id="MySql的内置函数"><a href="#MySql的内置函数" class="headerlink" title="MySql的内置函数"></a>MySql的内置函数</h3><p>数据库函<strong>数分类：数字、字符、日期、条件</strong>函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用力</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ABS</td>
<td align="center">绝对值</td>
<td align="center">ABS(-100)</td>
</tr>
<tr>
<td align="center">ROUND</td>
<td align="center">四舍五入</td>
<td align="center">ROUND(4.62)</td>
</tr>
<tr>
<td align="center">FOLLR</td>
<td align="center">强制舍位到最近的整数</td>
<td align="center">FLOOR(9,9) &#x3D; 9</td>
</tr>
<tr>
<td align="center">CEIL</td>
<td align="center">强制仅为最近的整数</td>
<td align="center">CEIL(3.2) &#x3D; 4</td>
</tr>
<tr>
<td align="center">POWER</td>
<td align="center">幂函数</td>
<td align="center">POWER(2,3)</td>
</tr>
<tr>
<td align="center">LOG</td>
<td align="center">对数函数</td>
<td align="center">LOG(7,3)</td>
</tr>
<tr>
<td align="center">LN</td>
<td align="center">对数函数</td>
<td align="center">LN(1,0)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SQRT</td>
<td align="center">开平方</td>
<td align="center">SQRT(9)</td>
</tr>
<tr>
<td align="center">PI</td>
<td align="center">圆周率</td>
<td align="center">P10</td>
</tr>
<tr>
<td align="center">SIN</td>
<td align="center">三角函数</td>
<td align="center">sin(1)</td>
</tr>
<tr>
<td align="center">TAN</td>
<td align="center">三角函数</td>
<td align="center">TAN(1)</td>
</tr>
<tr>
<td align="center">COT</td>
<td align="center">三角函数</td>
<td align="center">COT(1)</td>
</tr>
<tr>
<td align="center">COS</td>
<td align="center">三角函数</td>
<td align="center">COS(2)</td>
</tr>
<tr>
<td align="center">DADIANS</td>
<td align="center">角度来换成角度</td>
<td align="center">DADIANS(20)</td>
</tr>
<tr>
<td align="center">DEGREES</td>
<td align="center">弧度转换角度</td>
<td align="center">DEGRESS(1)</td>
</tr>
</tbody></table>
<h3 id="获取系统的时间函数"><a href="#获取系统的时间函数" class="headerlink" title="获取系统的时间函数"></a>获取系统的时间函数</h3><ul>
<li><strong>NOW</strong>()函数能获得系统日期和时间，yyyy-MMMM-dd hh:mm:ss</li>
<li><strong>CURDATE</strong>()函数能获得当前系统日期，yyyy&#x3D;MM&#x3D;ddd</li>
<li><strong>CURTIME</strong>()函数能获得当前时间系统信息，hh:mm:ss</li>
</ul>
<h3 id="日期格式化函数-一"><a href="#日期格式化函数-一" class="headerlink" title="日期格式化函数(一)"></a>日期格式化函数(一)</h3><ul>
<li><p>**DATE_FORMAT()**函数用于格式化日期，返回用户想要的日期格式</p>
<pre><code class="sql">DATE_FORMAT(r日期,表达式)

SELECT ename,DATE_FORMAT(hiredate,&quot;%Y&quot;) AS &quot;year&quot;
FROM t_emp; 
</code></pre>
</li>
</ul>
<h3 id="日期格式化函数-二"><a href="#日期格式化函数-二" class="headerlink" title="日期格式化函数(二)"></a>日期格式化函数(二)</h3><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">作用</th>
<th align="center">占位符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%Y</td>
<td align="center">年份</td>
<td align="center">%m</td>
<td align="center">月份</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">日期</td>
<td align="center">%w</td>
<td align="center">星期(数字)</td>
</tr>
<tr>
<td align="center">%W</td>
<td align="center">星期(名称)</td>
<td align="center">%j</td>
<td align="center">本年第几天</td>
</tr>
<tr>
<td align="center">%U</td>
<td align="center">本年第几周</td>
<td align="center">%H</td>
<td align="center">小时(24)</td>
</tr>
<tr>
<td align="center">%h</td>
<td align="center">小时(12)</td>
<td align="center">%i</td>
<td align="center">分钟</td>
</tr>
<tr>
<td align="center">%s</td>
<td align="center">秒</td>
<td align="center">%r</td>
<td align="center">时间(12)</td>
</tr>
<tr>
<td align="center">%T</td>
<td align="center">时间(24)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><p>利用日期函数，查询明年你的生日是星期几？</p>
<pre><code class="sql">SELECT DATE_FORMAT(&quot;2019-6-20&quot;,&quot;%w&quot;); #数字
SELECT DATE_FORMAT(&quot;2019-6-20&quot;,&quot;%W&quot;); #英文星期
</code></pre>
</li>
<li><p>利用日期函数，查询1981年上半年入职的员工多少人？[聚合函数 全表范围不用分组GROUP BY]</p>
<pre><code class="sql">SELECT COUNT(*) FROM t_emp
WHERE DATE_FORMAT(hiredate,&quot;%Y&quot;)=1981
AND DATE_FORMAT(hiredate,&quot;%m&quot;)&lt;=6 #上半年
</code></pre>
</li>
</ul>
<h3 id="日期计算的注意事项"><a href="#日期计算的注意事项" class="headerlink" title="日期计算的注意事项"></a>日期计算的注意事项</h3><ul>
<li>MySQL数据库里面，两个日期不能直接加减，日期也不能与数字加减</li>
</ul>
<h6 id="日期偏移计算"><a href="#日期偏移计算" class="headerlink" title="日期偏移计算"></a>日期偏移计算</h6><ul>
<li><p>DATE_ADD()函数可以实现日期的偏移计算，而且时间单位很灵活</p>
<pre><code class="sql">DATE_ADD(日期,INTERVAL 偏移量 时间单位)

SELECT DATE_ADD(NOW(),INTERVAL 15 DAY); #15天之后
SELECT DATE_ADD(NOW(),INTERVAL -300 MINUTE); #300分钟之前  2023-10-16 04:48:48
SELECT DATE_FORMAT(
DATE_ADD(DATE_ADD(NOW(),INTERVAL -6 MONTH),INTERVAL -3 DAY),&quot;%Y/%m/%d&quot;); #2023/04/13
</code></pre>
</li>
</ul>
<h6 id="计算日期之间相隔的天数"><a href="#计算日期之间相隔的天数" class="headerlink" title="计算日期之间相隔的天数"></a>计算日期之间相隔的天数</h6><ul>
<li><p>**DATEDIFF()**函数用来计算两个日期之间相差的天数</p>
<pre><code class="sql">DATEDIFF(日期,日期)
</code></pre>
</li>
</ul>
<h3 id="字符函数-一"><a href="#字符函数-一" class="headerlink" title="字符函数(一)"></a>字符函数(一)</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOWER</td>
<td align="center">转换小写字符</td>
<td align="center">LOWER(ename)</td>
</tr>
<tr>
<td align="center">UPPER</td>
<td align="center">转换大写字符</td>
<td align="center">UPPER(ename)</td>
</tr>
<tr>
<td align="center">LENGTH</td>
<td align="center">字符数量</td>
<td align="center">LENGTH(ename)</td>
</tr>
<tr>
<td align="center">CONCAT</td>
<td align="center">连接字符串</td>
<td align="center">CONCAT(sal, “$”)</td>
</tr>
<tr>
<td align="center">INSTR</td>
<td align="center">字符出现的位置</td>
<td align="center">INSTR(ename, “A”)</td>
</tr>
<tr>
<td align="center">INSERT</td>
<td align="center">插入&#x2F;替换字符</td>
<td align="center">INSERT(“你好”,1,0,”先生”)<br />替换1个字符  0表示不替换—候补</td>
</tr>
<tr>
<td align="center">REPLACE</td>
<td align="center">替换字符</td>
<td align="center">REPLACE(“你好先生”,“先生”,”女士”)<br />先生换成女士</td>
</tr>
</tbody></table>
<pre><code class="sql">SELECT
  LOWER(ename),UPPER(ename),LENGTH(ename),CONCAT(sal,&quot;$&quot;),INSTR(ename,&quot;A&quot;)
FROM t_emp;
</code></pre>
<h3 id="字符函数-二"><a href="#字符函数-二" class="headerlink" title="字符函数(二)"></a>字符函数(二)</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SUBSTR</td>
<td align="center">截取字符串</td>
<td align="center">SUBSTR(“你好世界”,3,4)<br />3开始位置 4结束位置</td>
</tr>
<tr>
<td align="center">SUBSTRING</td>
<td align="center">截取字符串</td>
<td align="center">SUBSTRING(“你好世界”,3,2)<br />3个字符开始往后截取2个位置</td>
</tr>
<tr>
<td align="center">LPAD</td>
<td align="center">左侧填充字符</td>
<td align="center">LPAD(“Hello”,10,”<em>“)<br />潘</em>* 10最终字符串一共为10个字符<br />电话隐私保护加※号</td>
</tr>
<tr>
<td align="center">RPAD</td>
<td align="center">右侧填充字符</td>
<td align="center">RPAD(“Hello”,10,”*”)</td>
</tr>
<tr>
<td align="center">TRIM</td>
<td align="center">去除首位空格</td>
<td align="center">TRIM(“ 你好先生 “)</td>
</tr>
</tbody></table>
<pre><code class="sql">SELECT LPAD(SUBSTRING(&quot;15027597319&quot;,8,4),11,&quot;*&quot;);
SELECT RPAD(SUBSTRING(&quot;潘春尧&quot;,1,1),LENGTH(&quot;潘春尧&quot;)/3,&quot;*&quot;); 
#LENGTH是算英文字符 再除以3就是汉字的字符个数
</code></pre>
<h3 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h3><ul>
<li><p>SQL语句中可以利用条件函数来实现变成语言里的条件判断</p>
<pre><code class="sql">IFNULL(表达式,值)
IF(表达式,值1,值2)
</code></pre>
</li>
<li><p>中秋节公司发放礼品，SALES部门发放礼品A，其余部门发放礼品B，打印每名员工获得的礼品<br>[按部门名称作表连接 部门表和员工表 内连接没有部门的没有礼品]</p>
<pre><code class="sql">SELECT 
  e.empno,e.ename,d.dname,
  IF(d.dname=&quot;SALES&quot;,&quot;礼品A&quot;,&quot;礼品B&quot;)
FROM t_emp e JOIN t_tept d ON e,deptno=d.deptno;
</code></pre>
</li>
</ul>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul>
<li><p>复杂的条件判断可以用条件语句来实现，比IF语句功能更强大</p>
<pre><code class="sql">CASE 
  WHEN 表达式 THEN 值1
  WHEN 表达式 THEN 值2
  ......
  ELSE 值N
END
</code></pre>
</li>
<li><p>公司年庆决定组织员工集体旅游，每个部门旅游目的地是不同的。<strong>SALES</strong>部门去P1地点，<strong>ACCOUNTING</strong>部门去P2地点，<strong>RESEARCH</strong>部门去P3地点，查询每名员工的旅行地点。</p>
<pre><code class="sql">SELECT 
  e.empno,e.ename,
  CASE 
    WHEN d.dname=&quot;SALES&quot; THEN &quot;p1&quot;
    WHEN d.dname=&quot;ACCOUNTING&quot; THEN &quot;p2&quot;
    WHEN d.dname=&quot;RESEARCH&quot; THEN &quot;P3&quot;
FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno;
</code></pre>
</li>
</ul>
<h6 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h6><ul>
<li><p>某公司决定为员工调整基本工资，具体调整方案如下：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">条件</th>
<th align="center">涨幅</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SALES部门中工龄超过20年</td>
<td align="center">10%</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SALES部门中工龄不满20年</td>
<td align="center">5%</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">ACCOUNTING部门</td>
<td align="center">+300元</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">RESEARCH部门里低于部门平均底薪</td>
<td align="center">+200元</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">没有部门的员工</td>
<td align="center">+100元</td>
</tr>
</tbody></table>
<pre><code class="sql">[员工表连接部门表]
UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno
LEFT JOIN (SELECT deptno,AVG(sal) AS avg FROM t_temp GOURP BY deptno) t
ON e.deptno=t.deptno
SET sal=(
    CASE 
      WHEN d,dname=&quot;SALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&gt;=20 
      THEN e.sal*1.1
      WHEN d,dname=&quot;ALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&lt;20 
      THEN e.sal*1.50
      WHEN d,dname=&quot;ACCOUNTING&quot; THEN e.sal+300
      WHEN d,dname=&quot;RESEARCH&quot; THEN e.sal&lt;t.avg THEN e.sal+200
      WHEN e.deotno IS NULL THEN e.sal+100
      ELSE e.sal
    END
);
</code></pre>
</li>
</ul>
<h3 id="事务机制-一-进入企业市场的第一步"><a href="#事务机制-一-进入企业市场的第一步" class="headerlink" title="事务机制(一) 进入企业市场的第一步"></a>事务机制(一) 进入企业市场的第一步</h3><h5 id="避免写入直接操作数据文件"><a href="#避免写入直接操作数据文件" class="headerlink" title="避免写入直接操作数据文件"></a>避免写入直接操作数据文件</h5><ul>
<li>如果数据的写入直接操作数据文件是非常危险的事情</li>
</ul>
<h5 id="利用日志来实现间接写入"><a href="#利用日志来实现间接写入" class="headerlink" title="利用日志来实现间接写入"></a>利用日志来实现间接写入</h5><ul>
<li>MySQL总共有5种日志，其中只有redo日志和undo日志与事务有关<br>[<strong>数据库</strong> 拷贝数据给 <strong>undo日志</strong> 记录修改 <strong>redo日志</strong> 与数据库<strong>同步数据</strong>]</li>
</ul>
<h5 id="事务机制-Transaction"><a href="#事务机制-Transaction" class="headerlink" title="事务机制(Transaction)"></a>事务机制(Transaction)</h5><ul>
<li>RDBMS &#x3D; SQL语句 + 事务(ACID)</li>
<li>事务是一个或者多个SQL语句组成的整体，要么全部执行成功，要么全都执行失败</li>
</ul>
<h5 id="事务案例"><a href="#事务案例" class="headerlink" title="事务案例"></a>事务案例</h5><ul>
<li>把10部门中MANGER员工调往20部门，其他岗位的员工调往30部门，然后删除10部门<br><span style = "color:red"><strong>事务</strong>：<u><em><strong>开启事务</strong></em> [把要修改的数据拷贝到<strong>undo日志</strong>[可恢复]内,做的修改会被记录到<strong>redo日志</strong>[同步]里面] <em><strong>UPDATE语句</strong></em>  <em><strong>DELETE语句  提交事务</strong></em></u></span></li>
</ul>
<h3 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h3><ul>
<li><p>默认情况下，MySQL执行每条SQL语句都会自动开启和提交事务</p>
</li>
<li><p>为了让多条SQL语句纳入到一个事务之下，可以手动管理事务</p>
<pre><code class="sql">START TRANSACTION;
SQL语句
[COMMIT|ROLLBACK];

START TRANSACTION;
DELETE FROM t_emp
DELETE FROM t_dept;
SELECT * FROM t_emp;
SELECT * FROM t_dept;
#这些删除修改只是在redo日志文件中进行的修改并未提交 
#虽然SELECT查不到了 但是点开左列的表中数据仍未删除
#只要不提交事务 redo日志就不会和数据库做同步
COMMIT; #把结果提交到日志里面 就会同步了
ROLLBACK; #做标记 回滚 一起失败
</code></pre>
</li>
</ul>
<h4 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h4><h6 id="原子性-一致性-隔离性-持久性"><a href="#原子性-一致性-隔离性-持久性" class="headerlink" title="原子性   一致性    隔离性   持久性"></a>原子性   一致性    隔离性   持久性</h6><h4 id="事务的原子性"><a href="#事务的原子性" class="headerlink" title="事务的原子性"></a>事务的原子性</h4><ul>
<li>一个事务中的所有操作要么全部完成，要么全部失败。事务执行后，不允许停留在中间某个状态</li>
</ul>
<h4 id="事务的一致性"><a href="#事务的一致性" class="headerlink" title="事务的一致性"></a>事务的一致性</h4><ul>
<li>不管任何给定的时间、并发事务由多少，事务必须保证运行结果的一致性<br>[<strong>阻止事务之间互相读取临时数据</strong>] [A給B 10元 事务<u>没有提交后且回滚了</u> C给A20元 此时A应该有30元 ]</li>
</ul>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><ul>
<li>隔离性要求事务不受其他并发事务的影响，如同在给定的时间内，该事务是数据库唯一运行的事务</li>
<li>默认情况下A事务，只能看到日志中该事务的相关数据 [A,B事务可以看undo和redo日志]</li>
</ul>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><ul>
<li>事务一旦提交，结果便是永久性的。即便发生宕机，仍然可以依靠事务日志完成数据的持久化</li>
</ul>
<h3 id="事务机制-二"><a href="#事务机制-二" class="headerlink" title="事务机制(二)"></a>事务机制(二)</h3><h4 id="事务的四个隔离级别-可设置相互读取"><a href="#事务的四个隔离级别-可设置相互读取" class="headerlink" title="事务的四个隔离级别(可设置相互读取)"></a>事务的四个隔离级别(可设置相互读取)</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">隔离级别</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">read uncommitted</td>
<td align="center">读取未提交数据</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">read committed</td>
<td align="center">读取已提交数据</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">repeatable read</td>
<td align="center">重复读取</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">serializable</td>
<td align="center">序列化</td>
</tr>
</tbody></table>
<h3 id="业务案例1-购票系统"><a href="#业务案例1-购票系统" class="headerlink" title="业务案例1 [购票系统]"></a>业务案例1 [购票系统]</h3><h6 id="A事务-B事务"><a href="#A事务-B事务" class="headerlink" title="A事务  B事务"></a>A事务  B事务</h6><table>
<thead>
<tr>
<th align="center">车次</th>
<th align="center">车厢</th>
<th align="center">坐席</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1A</td>
<td align="center">未售出</td>
</tr>
<tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1B</td>
<td align="center">未售出</td>
</tr>
</tbody></table>
<p>A事务看到G8047 1A坐席未售出 用UPDATE把状态修改成已售出 因为没有提交 所以只修改在了undo日志里 真实的数据没有发生改变。此时B事务启动了看到了1A坐席还有票 于是更新且提交了 于是数据已经发生了改变。</p>
<h6 id="A事务"><a href="#A事务" class="headerlink" title="A事务"></a>A事务</h6><table>
<thead>
<tr>
<th align="center">车次</th>
<th align="center">车厢</th>
<th align="center">坐席</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1A</td>
<td align="center"><strong><span style = "color :red">已售出</span></strong></td>
</tr>
<tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1B</td>
<td align="center">未售出</td>
</tr>
</tbody></table>
<h6 id="所以在这个案例中我们需要B事务去读取A事务的状态-发现在A事务的临时数据里购买了坐席-那么B事务就可以去购买其他的坐席"><a href="#所以在这个案例中我们需要B事务去读取A事务的状态-发现在A事务的临时数据里购买了坐席-那么B事务就可以去购买其他的坐席" class="headerlink" title="所以在这个案例中我们需要B事务去读取A事务的状态 发现在A事务的临时数据里购买了坐席 那么B事务就可以去购买其他的坐席"></a>所以在这个案例中我们需要B事务去读取A事务的状态 发现在A事务的临时数据里购买了坐席 那么B事务就可以去购买其他的坐席</h6><h4 id="修改事务隔离级别"><a href="#修改事务隔离级别" class="headerlink" title="修改事务隔离级别"></a>修改事务隔离级别</h4><ul>
<li><p><span style = "color :red"><strong>READ UNCOMMITTED</strong></span> 代表可以读取其他事务未提交的数据</p>
<pre><code class="sql"># ↓设置当前绘画的事务级别↓ [并非全局]
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
</code></pre>
<pre><code class="sql">*无标题-查询1
START TRANSACTION;
UPDATE t_emp SET sal=1;
-----------------------
*无标题-查询2
START TRANSACTION;
SELECT empno,enam,sal FROM t_emp;
#发现员工的sal并未变成1块钱

#解决问题：增加事务隔离级别  一个事务读到了另一个事务的数据
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT empno,enam,sal FROM t_emp;
COMMIT;
</code></pre>
</li>
</ul>
<h3 id="业务案例2-银行转账"><a href="#业务案例2-银行转账" class="headerlink" title="业务案例2 [银行转账]"></a>业务案例2 [银行转账]</h3><h6 id="Scott账户有5000元余额-B事务开始执行支出100元-此时A事务执行转账1000元到该用户-如果AB都正常commit-最终账户余额是5900元-但是如果B事务是一个错误的消费被回滚-退款操作-最终账户应该是6000元。如果允许A事务去读取B事务的临时数据-按照4900-1000-x3D-5900元-若A回滚就凭空少了100元"><a href="#Scott账户有5000元余额-B事务开始执行支出100元-此时A事务执行转账1000元到该用户-如果AB都正常commit-最终账户余额是5900元-但是如果B事务是一个错误的消费被回滚-退款操作-最终账户应该是6000元。如果允许A事务去读取B事务的临时数据-按照4900-1000-x3D-5900元-若A回滚就凭空少了100元" class="headerlink" title="Scott账户有5000元余额 B事务开始执行支出100元 此时A事务执行转账1000元到该用户 如果AB都正常commit 最终账户余额是5900元 但是如果B事务是一个错误的消费被回滚[退款操作] 最终账户应该是6000元。如果允许A事务去读取B事务的临时数据 按照4900+1000&#x3D;5900元 若A回滚就凭空少了100元"></a>Scott账户有5000元余额 B事务开始执行支出100元 此时A事务执行转账1000元到该用户 如果AB都正常commit 最终账户余额是5900元 但是如果B事务是一个错误的消费被回滚[退款操作] 最终账户应该是6000元。如果允许A事务去读取B事务的临时数据 按照4900+1000&#x3D;5900元 若A回滚就凭空少了100元</h6><h4 id="修改事务隔离级别-1"><a href="#修改事务隔离级别-1" class="headerlink" title="修改事务隔离级别"></a>修改事务隔离级别</h4><ul>
<li><p><span style = "color :red"><strong>READ COMMITTED</strong></span> 代表只能读取其他事务提交的数据</p>
<pre><code class="sql"># ↓设置当前绘画的事务级别↓ [并非全局]
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
</code></pre>
</li>
</ul>
<h3 id="业务案例3-电商案例"><a href="#业务案例3-电商案例" class="headerlink" title="业务案例3 [电商案例]"></a>业务案例3 [电商案例]</h3><p><strong>A事务</strong> 下单购买 商品(价格350元)   <strong>B事务</strong>要对 该商品涨价</p>
<h4 id="修改事务隔离级别【READ为默认级别】"><a href="#修改事务隔离级别【READ为默认级别】" class="headerlink" title="修改事务隔离级别【READ为默认级别】"></a>修改事务隔离级别【READ为默认级别】</h4><ul>
<li><p><span style = "color :red"><strong>REPEATABLE READ</strong></span> 代表事务在执行中反复读取数据，得到的结果是一致性的，<strong>不会受其他事务影响</strong></p>
<pre><code class="sql">#就算事务A提交了数据 也不影响事务B的查询原始数据
SET SESSION TRANSACTION ISOLATION LEVEL REPEATALE READ;
</code></pre>
</li>
</ul>
<pre><code class="sql">START TRANSACTION; 
UPDATE t_emp SET sal=1; 
COMMIT;
-----------------------
SET SESSION TRANSACTION ISOLATION LEVEL REPEATALE READ;
START TRANSACTION; 
SELECT empno,ename,sal FROM t_emp; 
COMMIT;
</code></pre>
<h3 id="事务的序列化"><a href="#事务的序列化" class="headerlink" title="事务的序列化"></a>事务的序列化</h3><ul>
<li><p>由于事务并发执行所带来的各种问题，<strong>前三种隔离级别只适用于在某些业务场景中</strong>，但是序列化的隔离性，让事务逐一执行，就不会产生上述问题了。</p>
<pre><code class="sql">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
</code></pre>
</li>
</ul>
<pre><code class="sql">START TRANSACTION; ①
UPDATE t_emp SET sal=1; ②
COMMIT; ⑤
-----------------------
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION; ③
SELECT empno,ename,sal FROM t_emp; ④ #此时会等待 只需要执行上方COMMIT
COMMIT;
</code></pre>
<h3 id="数据导入与导出"><a href="#数据导入与导出" class="headerlink" title="数据导入与导出"></a>数据导入与导出</h3><h4 id="数据导出与备份的区别"><a href="#数据导出与备份的区别" class="headerlink" title="数据导出与备份的区别"></a>数据导出与备份的区别</h4><ul>
<li>数据导出，导出的纯粹是业务数据</li>
<li>数据备份，备份的是数据文件、日志文件、索引文件灯</li>
</ul>
<p><strong>全量备份 → 增量备份1 → 增量备份2</strong></p>
<h4 id="数据导出的分类"><a href="#数据导出的分类" class="headerlink" title="数据导出的分类"></a>数据导出的分类</h4><p><strong>数据库</strong>可以导出<strong>SQL文档(数据不多)</strong> 也可以 导出<strong>文本文档(数据巨大)</strong></p>
<h4 id="导出SQL文件-或者手动右键库-存储SQL文件"><a href="#导出SQL文件-或者手动右键库-存储SQL文件" class="headerlink" title="导出SQL文件 [或者手动右键库 存储SQL文件]"></a>导出SQL文件 [或者手动右键库 存储SQL文件]</h4><ul>
<li><p><strong>mysqldump</strong>用来把业务数据导出成SQL文件，其中也包括了表结构</p>
<pre><code class="sql">#导出命令行 不写no-date就导出即包含 表结构 又包含 数据
mysqldump -uroot -p [no-date] 逻辑库 &gt; 路径
# D:/MySQL/demo.sql
</code></pre>
</li>
</ul>
<h4 id="导入SQL文件"><a href="#导入SQL文件" class="headerlink" title="导入SQL文件"></a>导入SQL文件</h4><ul>
<li>source命令用于导入SQL文件，包括创建数据表，写入记录等<pre><code class="sql">sql &gt; USE demo;
sql &gt; SOURCE backup.sql;
</code></pre>
</li>
</ul>
<h6 id="导出纯粹的业务数据"><a href="#导出纯粹的业务数据" class="headerlink" title="导出纯粹的业务数据"></a>导出纯粹的业务数据</h6><blockquote>
<p>若数据巨大 先导出表结构 再导出数据库文档(.txt) 之后再导入 就会快很多</p>
</blockquote>
<ul>
<li><p>t_emp 右键 存储sql文件 <strong>仅结构</strong> 再次右键 导出向导… txt文档 (跳过词法分析与语法优化)</p>
<pre><code class="sql">&quot;empno&quot;    &quot;ename&quot;    &quot;job&quot;    &quot;mgr&quot;    &quot;hiredate&quot;    &quot;sal&quot;    &quot;comm&quot;    &quot;deptno&quot;
&quot;7369&quot;    &quot;SMITH&quot;    &quot;CLERK&quot;    &quot;7902&quot;    &quot;17/12/1980&quot;    &quot;800&quot;        &quot;20&quot;
&quot;7499&quot;    &quot;ALLEN&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;20/2/1981&quot;    &quot;1600&quot;    &quot;300&quot;    &quot;30&quot;
&quot;7521&quot;    &quot;WARD&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;22/2/1981&quot;    &quot;1250&quot;    &quot;500&quot;    &quot;30&quot;
&quot;7566&quot;    &quot;JONES&quot;    &quot;MANAGER&quot;    &quot;7839&quot;    &quot;2/4/1981&quot;    &quot;2975&quot;        &quot;20&quot;
&quot;7654&quot;    &quot;MARTIN&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;28/9/1981&quot;    &quot;1250&quot;    &quot;1400&quot;    &quot;30&quot;
&quot;7698&quot;    &quot;BLAKE&quot;    &quot;MANAGER&quot;    &quot;7839&quot;    &quot;1/5/1981&quot;    &quot;2850&quot;        &quot;30&quot;
&quot;7782&quot;    &quot;CLARK&quot;    &quot;MANAGER&quot;    &quot;7839&quot;    &quot;9/6/1981&quot;    &quot;2450&quot;        &quot;10&quot;
&quot;7788&quot;    &quot;SCOTT&quot;    &quot;ANALYST&quot;    &quot;7566&quot;    &quot;9/12/1982&quot;    &quot;3000&quot;        &quot;20&quot;
&quot;7839&quot;    &quot;KING&quot;    &quot;PRESIDENT&quot;        &quot;17/11/1981&quot;    &quot;5000&quot;        &quot;10&quot;
&quot;7844&quot;    &quot;TURNER&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;8/9/1981&quot;    &quot;1500&quot;    &quot;0&quot;    &quot;30&quot;
&quot;7876&quot;    &quot;ADAMS&quot;    &quot;CLERK&quot;    &quot;7788&quot;    &quot;12/1/1983&quot;    &quot;1100&quot;        &quot;20&quot;
&quot;7900&quot;    &quot;JAMES&quot;    &quot;CLERK&quot;    &quot;7698&quot;    &quot;3/12/1981&quot;    &quot;950&quot;        &quot;30&quot;
&quot;7902&quot;    &quot;FORD&quot;    &quot;ANALYST&quot;    &quot;7566&quot;    &quot;3/12/1981&quot;    &quot;3000&quot;        &quot;20&quot;
&quot;7934&quot;    &quot;MILLER&quot;    &quot;CLERK&quot;    &quot;7782&quot;    &quot;23/1/1982&quot;    &quot;1300&quot;        &quot;10&quot;
</code></pre>
</li>
<li><p>导入回来 先删除t_emp 在dmeo右键 运行文件 导入刚刚右键存储的t_emp的结构(仅结构) 此时员工表结构就回来了 导入向导… 下一步 找到导出的txt文档  第一个数据行1(第一行有效数据) 在导入向导中根据<strong>源字段</strong>匹配<strong>目标字段</strong> (txt+结构&#x3D;数据表)</p>
</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/10/08/后端/数据库/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/2/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            

            
            <a href="/">
                <span class="page-num">1</span>
            </a>
            

            

            
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
        </span>
        

        <span class="current">
            3
        </span>

        
        <span>
            <a href="/page/4/">
                <span class="page-num">
                    4
                </span>
            </a>
            
            <a href="/page/5">
                <span class="page-num">
                    5
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/12">
                <span class="page-num">
                    12
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/4/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>